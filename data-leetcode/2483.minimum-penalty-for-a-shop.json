[
    {
        "title": "Minimum Penalty for a Shop",
        "question_content": "You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':\n\n\tif the ith character is 'Y', it means that customers come at the ith hour\n\twhereas 'N' indicates that no customers come at the ith hour.\n\nIf the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:\n\n\tFor every hour when the shop is open and no customers come, the penalty increases by 1.\n\tFor every hour when the shop is closed and customers come, the penalty increases by 1.\n\nReturn the earliest hour at which the shop must be closed to incur a minimum penalty.\nNote that if a shop closes at the jth hour, it means the shop is closed at the hour j.\n&nbsp;\nExample 1:\n\nInput: customers = \"YYNY\"\nOutput: 2\nExplanation: \n- Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.\n- Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.\n- Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\n- Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.\nClosing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.\n\nExample 2:\n\nInput: customers = \"NNNNN\"\nOutput: 0\nExplanation: It is best to close the shop at the 0th hour as no customers arrive.\nExample 3:\n\nInput: customers = \"YYYY\"\nOutput: 4\nExplanation: It is best to close the shop at the 4th hour as customers arrive at each hour.\n\n&nbsp;\nConstraints:\n\n\t1 <= customers.length <= 105\n\tcustomers consists only of characters 'Y' and 'N'.",
        "solutions": [
            {
                "id": 3973809,
                "title": "99-70-2-approach-single-pass-prefix-sum",
                "content": "# Interview Guide: Minimum Penalty for a Shop\\n\\n## Problem Understanding\\n\\n**Description**:  \\nSo, you\\'re ramping up for coding interviews or just looking to sharpen your algorithmic skills, right? Well, the \"Minimum Penalty for a Shop\" problem is a perfect starting point. Imagine owning a shop and you need to decide when to close it. You have a log of \\'Y\\'s and \\'N\\'s, indicating customer visits and no-shows. Your goal? Find that sweet spot\\u2014the earliest time to close and minimize penalties.\\n\\n## Interview Preparation Tips & Considerations\\n\\n### 1. **Don\\'t Skim Over Constraints**  \\n  - First, note that the log can be lengthy, up to $$10^5$$ characters. This tells you that your solution must be optimized to handle large inputs efficiently.\\n  - Secondly, the log contains only \\'Y\\' and \\'N\\'. This simplicity is deceptive; the challenge lies in optimizing your approach.\\n\\n### 2. **Approach Selection: Your First Critical Decision**\\n  - **Single Pass**: If time complexity is your main concern, this approach should be your go-to. It runs in $$O(n)$$ time and uses a minuscule $$O(1)$$ space. This is ideal for interviews where time is of the essence.\\n  \\n  - **Prefix-Suffix Sums**: Opt for this if you have more freedom with space. It also operates in $$O(n)$$ time but uses $$O(n)$$ space. This approach provides a more in-depth understanding of the log.\\n\\n### How to Start Coding?  \\n1. **Understand the Problem**: Before you even touch the keyboard, make sure you understand what the problem is asking. Do a dry run with a sample input.\\n  \\n2. **Choose Your Approach**: Based on the problem constraints and what you\\'re comfortable with, select an approach. Each has its merits and demerits.\\n\\n3. **Pseudocode First**: Write down a quick pseudocode to outline your thoughts. It helps to see the logic on paper before coding.\\n\\n4. **Code and Test**: Now, dive into the code. Keep testing at every significant step to ensure you\\'re on the right track.\\n\\n5. **Edge Cases**: Don\\'t forget them; they\\'re the Achilles heel in coding interviews. Make sure your solution handles all edge cases.\\n\\n6. **Review**: Before saying you\\'re done, review the code for any possible optimizations or errors. \\n\\n---\\n\\n# More than Live Coding:\\nhttps://youtu.be/Za91oxv7uls?si=VYY0Fxj9NxpY1WkF\\n\\n---\\n\\n# Single Pass Approach\\n\\n## Explanation\\n\\nThe logic behind the Single Pass Approach is to efficiently iterate through the customer visit log string once, while keeping track of the penalty score. This way, we can find the optimal time to close the shop with minimal computational overhead. Here\\'s a detailed explanation:\\n\\n### 1. **Initialization**:  \\nWe start by initializing three variables: `max_score`, `score`, and `best_hour` to 0. \\n- `max_score`: To keep track of the highest score seen so far.\\n- `score`: To hold the current penalty score.\\n- `best_hour`: To remember the hour where `max_score` occurred.\\n\\n```python\\nmax_score = score = 0\\nbest_hour = -1\\n```\\n\\n### 2. **Iterate through the String**:  \\nHere comes the main part. We loop through each character `c` in the customer visit log string. We use a single variable `score` to keep track of the penalty.\\n\\n- If `c` is \\'Y\\':  \\n  This means a customer is visiting the shop at this hour, so we increment `score` by 1. This is because if the shop were closed at this hour, it would incur a penalty.\\n\\n- If `c` is \\'N\\':  \\n  No customer is visiting, so we decrement `score` by 1. This implies that keeping the shop open at this hour would be wasteful and result in a penalty.\\n\\n```python\\nfor i, c in enumerate(customers):\\n    score += 1 if c == \\'Y\\' else -1\\n```\\n\\n### 3. **Track Max Score and Best Hour**:  \\nAt each iteration, we compare `score` with `max_score`. If `score` is greater, it means we\\'ve found a new optimal time to close the shop. So, we update `max_score` and set `best_hour` to the current index `i`.\\n\\n```python\\n    if score > max_score:\\n        max_score, best_hour = score, i\\n```\\n\\n### 4. **Return Result**:  \\nFinally, we\\'ve iterated through the entire string and found the optimal time to close the shop, which is stored in `best_hour`. We return `best_hour + 1` (because the question is 0-indexed).\\n\\n```python\\nreturn best_hour + 1\\n```\\n\\n## Complexity\\n\\n### Time Complexity:  \\nThe algorithm runs in $$ O(n) $$ time since we go through the string once.\\n\\n### Space Complexity:  \\nThe space complexity is $$ O(1) $$, as we use constant extra space.\\n\\n# Prefix-Suffix Sums Approach\\n\\n### Explanation\\n\\n1. **Initialization**:  \\n  Initialize two empty arrays `prefixN` and `suffixY` with a leading zero. Initialize counters `cntN` and `cntY` to zero.\\n\\n2. **Compute Prefix Sums for \\'N\\'**:  \\n  Traverse the string and update `prefixN` with the count of \\'N\\'s until the current index.\\n\\n3. **Compute Suffix Sums for \\'Y\\'**:  \\n  Traverse the string in reverse and update `suffixY` with the count of \\'Y\\'s from the current index to the end.\\n\\n4. **Calculate Penalties**:  \\n  Compute the penalty for each hour as `prefixN[i] + suffixY[i]`.\\n\\n5. **Find Minimum Penalty**:  \\n  Identify the index with the minimum penalty.\\n\\n6. **Return Result**:  \\n  Return the index as the best time to close the shop.\\n\\n### Complexity\\n\\n- **Time Complexity**: $$O(n)$$\\n- **Space Complexity**: $$O(n)$$\\n\\n## Conclusion\\n\\nBoth approaches solve the problem effectively, each with its own advantages. The Single Pass approach is more space-efficient, while the Prefix-Suffix Sums approach is more intuitive. The choice between the two depends on whether space efficiency or ease of understanding is a higher priority.\\n\\n---\\n\\n# Performance Table \\n\\n## Single Pass\\n\\n| Language           | Runtime (ms) | Memory (MB) |\\n|--------------------|--------------|-------------|\\n| Rust               | 4            | 2.2         |\\n| Go                 | 7            | 5.6         |\\n| Java               | 9            | 43.9        |\\n| C++                | 23           | 10.7        |\\n| PHP                | 29           | 19.9        |\\n| Python3 (Single Pass) | 74       | 17.4        |\\n| JavaScript         | 65           | 44.7        |\\n| C#                 | 70           | 42.2        |\\n| Python3 (Prefix)   | 228          | 25.8        |\\n\\nThe table reveals how the Single Pass approach in Python significantly outperforms the Prefix approach, underscoring the importance of algorithmic optimization. It also offers a fascinating look at the performance variations across different programming languages.\\n\\n![j3.png](https://assets.leetcode.com/users/images/52a280a5-5d2c-4ffc-9b14-b3dbdccacb7a_1693271732.9935198.png)\\n\\n---\\n\\n# Code Single Pass\\n``` Python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        max_score = score = 0\\n        best_hour = -1\\n\\n        for i, c in enumerate(customers):\\n            score += 1 if c == \\'Y\\' else -1\\n            if score > max_score:\\n                max_score, best_hour = score, i\\n                \\n        return best_hour + 1\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int max_score = 0, score = 0, best_hour = -1;\\n        for(int i = 0; i < customers.size(); ++i) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if(score > max_score) {\\n                max_score = score;\\n                best_hour = i;\\n            }\\n        }\\n        return best_hour + 1;\\n    }\\n};\\n```\\n``` Go []\\nfunc bestClosingTime(customers string) int {\\n    max_score, score, best_hour := 0, 0, -1\\n    for i := 0; i < len(customers); i++ {\\n        if customers[i] == \\'Y\\' {\\n            score++\\n        } else {\\n            score--\\n        }\\n        if score > max_score {\\n            max_score = score\\n            best_hour = i\\n        }\\n    }\\n    return best_hour + 1\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn best_closing_time(customers: String) -> i32 {\\n        let mut max_score = 0;\\n        let mut score = 0;\\n        let mut best_hour = -1;\\n        \\n        for (i, c) in customers.chars().enumerate() {\\n            if c == \\'Y\\' {\\n                score += 1;\\n            } else {\\n                score -= 1;\\n            }\\n            \\n            if score > max_score {\\n                max_score = score;\\n                best_hour = i as i32;\\n            }\\n        }\\n        \\n        best_hour + 1\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public int bestClosingTime(String customers) {\\n        int max_score = 0, score = 0, best_hour = -1;\\n        for(int i = 0; i < customers.length(); ++i) {\\n            score += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n            if(score > max_score) {\\n                max_score = score;\\n                best_hour = i;\\n            }\\n        }\\n        return best_hour + 1;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nvar bestClosingTime = function(customers) {\\n    let max_score = 0, score = 0, best_hour = -1;\\n    for(let i = 0; i < customers.length; ++i) {\\n        score += (customers[i] === \\'Y\\') ? 1 : -1;\\n        if(score > max_score) {\\n            max_score = score;\\n            best_hour = i;\\n        }\\n    }\\n    return best_hour + 1;\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    public function bestClosingTime($customers) {\\n        $max_score = $score = 0;\\n        $best_hour = -1;\\n        \\n        for($i = 0; $i < strlen($customers); ++$i) {\\n            $score += ($customers[$i] === \\'Y\\') ? 1 : -1;\\n            if($score > $max_score) {\\n                $max_score = $score;\\n                $best_hour = $i;\\n            }\\n        }\\n        \\n        return $best_hour + 1;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int BestClosingTime(string customers) {\\n        int max_score = 0, score = 0, best_hour = -1;\\n        for(int i = 0; i < customers.Length; ++i) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if(score > max_score) {\\n                max_score = score;\\n                best_hour = i;\\n            }\\n        }\\n        return best_hour + 1;\\n    }\\n}\\n```\\n\\n# Code  Prefix Sums\\n``` Python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n, cntN, cntY = len(customers), 0, 0\\n        prefixN, suffixY = [0], [0]\\n        \\n        for c in customers:\\n            cntN += (c == \\'N\\')\\n            prefixN.append(cntN)\\n        \\n        for c in reversed(customers):\\n            cntY += (c == \\'Y\\')\\n            suffixY.append(cntY)\\n        \\n        suffixY.reverse()\\n        \\n        best_hour, _ = min(enumerate(a + b for a, b in zip(prefixN, suffixY)), key=lambda x: x[1])\\n        \\n        return best_hour\\n```\\n\\nEvery line of code you write brings you one step closer to becoming an expert. Both brevity and clarity have their merits in coding. So keep exploring and don\\'t hesitate to share your unique perspective. You never know, your insight might just be the \\'aha\\' moment someone else needs. Happy Coding! \\uD83D\\uDE80\\uD83D\\uDCA1",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Prefix Sum"
                ],
                "code": "```python\\nmax_score = score = 0\\nbest_hour = -1\\n```\n```python\\nfor i, c in enumerate(customers):\\n    score += 1 if c == \\'Y\\' else -1\\n```\n```python\\n    if score > max_score:\\n        max_score, best_hour = score, i\\n```\n```python\\nreturn best_hour + 1\\n```\n``` Python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        max_score = score = 0\\n        best_hour = -1\\n\\n        for i, c in enumerate(customers):\\n            score += 1 if c == \\'Y\\' else -1\\n            if score > max_score:\\n                max_score, best_hour = score, i\\n                \\n        return best_hour + 1\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int max_score = 0, score = 0, best_hour = -1;\\n        for(int i = 0; i < customers.size(); ++i) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if(score > max_score) {\\n                max_score = score;\\n                best_hour = i;\\n            }\\n        }\\n        return best_hour + 1;\\n    }\\n};\\n```\n``` Go []\\nfunc bestClosingTime(customers string) int {\\n    max_score, score, best_hour := 0, 0, -1\\n    for i := 0; i < len(customers); i++ {\\n        if customers[i] == \\'Y\\' {\\n            score++\\n        } else {\\n            score--\\n        }\\n        if score > max_score {\\n            max_score = score\\n            best_hour = i\\n        }\\n    }\\n    return best_hour + 1\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn best_closing_time(customers: String) -> i32 {\\n        let mut max_score = 0;\\n        let mut score = 0;\\n        let mut best_hour = -1;\\n        \\n        for (i, c) in customers.chars().enumerate() {\\n            if c == \\'Y\\' {\\n                score += 1;\\n            } else {\\n                score -= 1;\\n            }\\n            \\n            if score > max_score {\\n                max_score = score;\\n                best_hour = i as i32;\\n            }\\n        }\\n        \\n        best_hour + 1\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public int bestClosingTime(String customers) {\\n        int max_score = 0, score = 0, best_hour = -1;\\n        for(int i = 0; i < customers.length(); ++i) {\\n            score += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n            if(score > max_score) {\\n                max_score = score;\\n                best_hour = i;\\n            }\\n        }\\n        return best_hour + 1;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nvar bestClosingTime = function(customers) {\\n    let max_score = 0, score = 0, best_hour = -1;\\n    for(let i = 0; i < customers.length; ++i) {\\n        score += (customers[i] === \\'Y\\') ? 1 : -1;\\n        if(score > max_score) {\\n            max_score = score;\\n            best_hour = i;\\n        }\\n    }\\n    return best_hour + 1;\\n};\\n```\n``` PHP []\\nclass Solution {\\n    public function bestClosingTime($customers) {\\n        $max_score = $score = 0;\\n        $best_hour = -1;\\n        \\n        for($i = 0; $i < strlen($customers); ++$i) {\\n            $score += ($customers[$i] === \\'Y\\') ? 1 : -1;\\n            if($score > $max_score) {\\n                $max_score = $score;\\n                $best_hour = $i;\\n            }\\n        }\\n        \\n        return $best_hour + 1;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int BestClosingTime(string customers) {\\n        int max_score = 0, score = 0, best_hour = -1;\\n        for(int i = 0; i < customers.Length; ++i) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if(score > max_score) {\\n                max_score = score;\\n                best_hour = i;\\n            }\\n        }\\n        return best_hour + 1;\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n, cntN, cntY = len(customers), 0, 0\\n        prefixN, suffixY = [0], [0]\\n        \\n        for c in customers:\\n            cntN += (c == \\'N\\')\\n            prefixN.append(cntN)\\n        \\n        for c in reversed(customers):\\n            cntY += (c == \\'Y\\')\\n            suffixY.append(cntY)\\n        \\n        suffixY.reverse()\\n        \\n        best_hour, _ = min(enumerate(a + b for a, b in zip(prefixN, suffixY)), key=lambda x: x[1])\\n        \\n        return best_hour\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974020,
                "title": "full-explanation-o-n-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem is about **determining the optimal time** to **close** a shop based on **customer visit patterns**, while aiming to minimize the penalty incurred. The goal is to **find the hour** at which closing the shop results in the least penalty.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Scoring System:** The code employs a scoring system where each customer arriving at the shop increments the score by 1, and each hour without a customer decrements the score by 1. This score represents the difference between the number of arriving customers and the number of non-arriving hours.\\n**this line of code ensure scoring system-**\\n```\\nscore += (customers[i] == \\'Y\\') ? 1 : -1;\\n```\\n2. **Max Score and Right time:** The code maintains **two variables:** **max_score** and **right_time**. max_score keeps track of the **highest score encountered** during iteration, and right_time stores the hour **at** **which this maximum score** occurs.\\n\\n\\n3. **Iterating Through Hours:** The code iterates through each hour in the customer visit log. **For each hour, it updates the score** based on **whether a customer arrived or not**. **If** the **updated score** surpasses the **previously recorded maximum score**, the **max_score is updated**, and the **right_time** is set to the current hour.\\n\\n\\n4. **Returning the Result:** After iterating through all hours, the code returns **right_time + 1**. **Adding 1 is necessary because hours are 0-indexed**, and the **expected output is 1-indexed**.\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int max_score = 0, score = 0, right_time = -1;\\n        for(int i = 0; i < customers.size(); ++i) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if(score > max_score) {\\n                max_score = score;\\n                right_time = i;\\n            }\\n        }\\n        return right_time + 1;\\n    }\\n};\\n```\\n# Code Java\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int maxScore = 0, score = 0, rightTime = -1;\\n        for (int i = 0; i < customers.length(); ++i) {\\n            score += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n            if (score > maxScore) {\\n                maxScore = score;\\n                rightTime = i;\\n            }\\n        }\\n        return rightTime + 1;\\n    }\\n}\\n\\n```\\n# Code Python\\n```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        max_score = 0\\n        score = 0\\n        right_time = -1\\n        for i in range(len(customers)):\\n            score += 1 if customers[i] == \\'Y\\' else -1\\n            if score > max_score:\\n                max_score = score\\n                right_time = i\\n        return right_time + 1\\n```\\n# REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.\\n\\n![UPVOTE.png](https://assets.leetcode.com/users/images/eef4d775-9487-41d9-b1a8-0b93ded5f09d_1693274187.94641.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nscore += (customers[i] == \\'Y\\') ? 1 : -1;\\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int max_score = 0, score = 0, right_time = -1;\\n        for(int i = 0; i < customers.size(); ++i) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if(score > max_score) {\\n                max_score = score;\\n                right_time = i;\\n            }\\n        }\\n        return right_time + 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int maxScore = 0, score = 0, rightTime = -1;\\n        for (int i = 0; i < customers.length(); ++i) {\\n            score += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n            if (score > maxScore) {\\n                maxScore = score;\\n                rightTime = i;\\n            }\\n        }\\n        return rightTime + 1;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        max_score = 0\\n        score = 0\\n        right_time = -1\\n        for i in range(len(customers)):\\n            score += 1 if customers[i] == \\'Y\\' else -1\\n            if score > max_score:\\n                max_score = score\\n                right_time = i\\n        return right_time + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850432,
                "title": "o-n-c-prefix-sum-one-pass-explained",
                "content": "Here, the idea is to store the number of \\'Y\\' and \\'N\\' in a vector, let\\'s call them vector y and n;\\nAt any instance i  **the penalty depend on the sum of number of \\'Y\\' remaining and the number of \\'N\\' passed.** \\nSo, for that we\\'ll be calculating the **suffix sum of \\'Y\\' and prefix sum of \\'N\\'** and storing them on vector y and n respectively. Then for each index the ans becomes\\n**y[i]+n[i], and taking the minimum** of all the indeces gives us the answer!\\nWe\\'ll be pushing 0 to y at end because at last no \\'Y\\' will be  left and similarly we\\'ll do that for \\'N\\' at initial stage as no \\'N\\' have been passed.\\n\\n\\n```\\nclass Solution {\\n\\tpublic:\\n\\t\\tint bestClosingTime(string a) {\\n\\t\\t\\tint s=a.size();\\n\\t\\t\\tvector<int> y,n;\\n\\t\\t\\ty.push_back(0);\\n\\t\\t\\tn.push_back(0);\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0;i<s;i++){\\n\\t\\t\\t\\tif(a[i]==\\'N\\')cnt++;\\n\\t\\t\\t\\tn.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\tcnt=0;\\n\\t\\t\\tfor(int i=s-1;i>=0;i--){\\n\\t\\t\\t\\tif(a[i]==\\'Y\\')cnt++;\\n\\t\\t\\t\\ty.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\treverse(y.begin(),y.end());\\n\\t\\t\\tint ans=INT_MAX,ind=0;\\n\\t\\t\\tfor(int i=0;i<s+1;i++){\\n\\t\\t\\t\\tint h=y[i]+n[i];\\n\\t\\t\\t\\tif(h<ans){\\n\\t\\t\\t\\t\\tans=h;\\n\\t\\t\\t\\t\\tind=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\n\\t\\t}\\n\\t};\\n```\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\nWe can optimise it further. As **at any instance i, remaining \\'Y\\' should be minimum and remaining \\'N\\' should be maximum.** Therefore, the number of **\\'Y\\' passed should be maximum and number of \\'N\\' passed should be minimum.**\\nSo, for that we\\'ll be calculating the score, whenever \\'Y\\' will be found score increases elsewise decreases!\\nMaximum score will be recorded, till which the shop will be open and after that shop closes so ind+1 gives the answer.\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int n=s.size();\\n        int ind=-1,mxscore=0,score=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'Y\\') score++;\\n            else score--;\\n            if(score>mxscore){\\n                mxscore=score;\\n                ind=i;\\n            }\\n        }\\n        return ind+1;\\n        \\n    }\\n};\\n```\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\t\\tint bestClosingTime(string a) {\\n\\t\\t\\tint s=a.size();\\n\\t\\t\\tvector<int> y,n;\\n\\t\\t\\ty.push_back(0);\\n\\t\\t\\tn.push_back(0);\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0;i<s;i++){\\n\\t\\t\\t\\tif(a[i]==\\'N\\')cnt++;\\n\\t\\t\\t\\tn.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\tcnt=0;\\n\\t\\t\\tfor(int i=s-1;i>=0;i--){\\n\\t\\t\\t\\tif(a[i]==\\'Y\\')cnt++;\\n\\t\\t\\t\\ty.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\treverse(y.begin(),y.end());\\n\\t\\t\\tint ans=INT_MAX,ind=0;\\n\\t\\t\\tfor(int i=0;i<s+1;i++){\\n\\t\\t\\t\\tint h=y[i]+n[i];\\n\\t\\t\\t\\tif(h<ans){\\n\\t\\t\\t\\t\\tans=h;\\n\\t\\t\\t\\t\\tind=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\n\\t\\t}\\n\\t};\\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int n=s.size();\\n        int ind=-1,mxscore=0,score=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'Y\\') score++;\\n            else score--;\\n            if(score>mxscore){\\n                mxscore=score;\\n                ind=i;\\n            }\\n        }\\n        return ind+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850480,
                "title": "python-one-pass-count-profit-not-penalty-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Comment #1.** Instead of computing penalty, we can compute total profit for the shop being open up to a certain hour, then choose the hour that gives the maximal profit.\\n\\n**Python #1.** A one-pass solution (thx @ForgottenSemicolon for the idea)\\n```\\nclass Solution:\\n    def bestClosingTime(self, cust: str) -> int:\\n        \\n        h = m = s = 0\\n        for i, ch in enumerate(cust):       # [1] compute running profit where\\n            s += (ch == \"Y\") * 2 - 1        #     we add +1 for Y, -1 for N\\n            if s > m:                       # [2] keep track of the maximal \\n                m, h = s, i+1               #     profit and its hour\\n        \\n        return h                            # [3] this is the hour with minimal penalty\\n```\\n\\n****\\n\\nThere is also a straightforward solution with computing separate scores.\\n\\n**Comment #2.** Calculate penalties for **yes** and **no** separately, then combine to find the minimum of their sums. The tricky part here is that \\n * for **N**, we penalize before an hour begins, namely, the penalty for the `i`*-th* hour is actually the penalty for all hours strictly less than `i`; thus, we also need to account for the `n`*-th* (non-existing) hour;\\n * for **Y**, we also penalize before an hour begins, but this time the penalty for the `i`*-th* hour is the penalty for all hours greater **or equal** than `i`; thus the `n`*-th* hour is initialized with `0` and never updated (because this is a fake hour that can never be reached, it\\'s only needed for **N**\\'s).\\n\\n**Python #2.**\\n```\\nclass Solution:\\n    def bestClosingTime(self, c: str) -> int:\\n        \\n        n = len(c)\\n        no, yes = [0] * (n+1), [0] * (n+1)\\n\\n        p = 0                           # [1] compute penalties for\\n        for i in range(n):              #     allowing no customers\\n            no[i] = p\\n            p += (c[i] == \"N\")          # [2] don\\'t forget to penalize\\n        no[n] = p                       #     for the last hour\\n        \\n        p = 0                           # [3] compute penalties for\\n        for i in reversed(range(n)):    #     missing customers\\n            p += (c[i] == \"Y\")          # [4] penalty for last hour was\\n            yes[i] = p                  #     already correclty set to 0\\n        \\n        t = m = inf                     # [5] now scan both penalty lists\\n        for i in range(n+1):            #     and find the minimal one\\n            p = yes[i] + no[i]\\n            if p < m:\\n                m, t = p, i\\n        \\n        return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bestClosingTime(self, cust: str) -> int:\\n        \\n        h = m = s = 0\\n        for i, ch in enumerate(cust):       # [1] compute running profit where\\n            s += (ch == \"Y\") * 2 - 1        #     we add +1 for Y, -1 for N\\n            if s > m:                       # [2] keep track of the maximal \\n                m, h = s, i+1               #     profit and its hour\\n        \\n        return h                            # [3] this is the hour with minimal penalty\\n```\n```\\nclass Solution:\\n    def bestClosingTime(self, c: str) -> int:\\n        \\n        n = len(c)\\n        no, yes = [0] * (n+1), [0] * (n+1)\\n\\n        p = 0                           # [1] compute penalties for\\n        for i in range(n):              #     allowing no customers\\n            no[i] = p\\n            p += (c[i] == \"N\")          # [2] don\\'t forget to penalize\\n        no[n] = p                       #     for the last hour\\n        \\n        p = 0                           # [3] compute penalties for\\n        for i in reversed(range(n)):    #     missing customers\\n            p += (c[i] == \"Y\")          # [4] penalty for last hour was\\n            yes[i] = p                  #     already correclty set to 0\\n        \\n        t = m = inf                     # [5] now scan both penalty lists\\n        for i in range(n+1):            #     and find the minimal one\\n            p = yes[i] + no[i]\\n            if p < m:\\n                m, t = p, i\\n        \\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974267,
                "title": "video-time-o-n-space-o-1-with-python-javascript-java-and-c",
                "content": "# Intuition\\nThe main point of this code is to determine the best closing time for a shop based on customer visit records. It calculates the optimal time to close the shop such that if there are any customers inside, the shop closes at the next hour. The code iterates through the customer records, maintaining a counter (customer_left) to track the difference between incoming and departing customers. It updates the result (res) whenever the condition of having customers inside (customer_left > 0) is met, indicating that the shop should close at the next hour.\\n\\nThis python solution beats 98%.\\n\\n![Screen Shot 2023-08-29 at 13.19.36.png](https://assets.leetcode.com/users/images/0ae31508-b474-4c78-8def-711442fa3961_1693282808.376522.png)\\n\\n---\\n\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 251 videos as of August 29th, 2023.\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/KB4ZPkw9IsA\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize variables:\\n   - `res`: To store the best closing time (initially set to 0).\\n   - `customer_left`: To keep track of the difference between customers who came in and customers who left (initially set to 0).\\n\\n2. Loop through the `customers` string using an index `i`:\\n   - For each index `i`:\\n     - Check if the current customer is coming in (\\'Y\\'):\\n       - Increment `customer_left` by 1 to account for the incoming customer.\\n\\n3. Check if customers are still inside the shop:\\n   - If `customer_left` is greater than 0 (meaning there are still customers inside):\\n     - Update `res` with the current index `i + 1` (since we\\'re 0-indexed and the result needs to be 1-indexed).\\n     - Reset `customer_left` to 0 to indicate that all customers are accounted for.\\n\\n4. If the current customer is not coming in (\\'N\\'):\\n   - Decrement `customer_left` by 1 to account for the departing customer.\\n\\n5. After iterating through all customers:\\n   - Return the calculated `res`, which represents the best closing time to minimize the penalty.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n\\n```python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        res = 0\\n        customer_left = 0\\n        \\n        for i in range(len(customers)):\\n            if customers[i] == \\'Y\\':\\n                customer_left += 1\\n\\n                if customer_left > 0:\\n                    res = i + 1\\n                    customer_left = 0                \\n            else:\\n                customer_left -= 1\\n                    \\n        return res\\n\\n```\\n```javascript []\\nvar bestClosingTime = function(customers) {\\n    let res = 0;\\n    let customerLeft = 0;\\n\\n    for (let i = 0; i < customers.length; i++) {\\n        if (customers[i] === \\'Y\\') {\\n            customerLeft++;\\n\\n            if (customerLeft > 0) {\\n                res = i + 1;\\n                customerLeft = 0;\\n            }\\n        } else {\\n            customerLeft--;\\n        }\\n    }\\n\\n    return res;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int res = 0;\\n        int customerLeft = 0;\\n\\n        for (int i = 0; i < customers.length(); i++) {\\n            if (customers.charAt(i) == \\'Y\\') {\\n                customerLeft++;\\n\\n                if (customerLeft > 0) {\\n                    res = i + 1;\\n                    customerLeft = 0;\\n                }\\n            } else {\\n                customerLeft--;\\n            }\\n        }\\n\\n        return res;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int res = 0;\\n        int customerLeft = 0;\\n\\n        for (int i = 0; i < customers.length(); i++) {\\n            if (customers[i] == \\'Y\\') {\\n                customerLeft++;\\n\\n                if (customerLeft > 0) {\\n                    res = i + 1;\\n                    customerLeft = 0;\\n                }\\n            } else {\\n                customerLeft--;\\n            }\\n        }\\n\\n        return res;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        res = 0\\n        customer_left = 0\\n        \\n        for i in range(len(customers)):\\n            if customers[i] == \\'Y\\':\\n                customer_left += 1\\n\\n                if customer_left > 0:\\n                    res = i + 1\\n                    customer_left = 0                \\n            else:\\n                customer_left -= 1\\n                    \\n        return res\\n\\n```\n```javascript []\\nvar bestClosingTime = function(customers) {\\n    let res = 0;\\n    let customerLeft = 0;\\n\\n    for (let i = 0; i < customers.length; i++) {\\n        if (customers[i] === \\'Y\\') {\\n            customerLeft++;\\n\\n            if (customerLeft > 0) {\\n                res = i + 1;\\n                customerLeft = 0;\\n            }\\n        } else {\\n            customerLeft--;\\n        }\\n    }\\n\\n    return res;    \\n};\\n```\n```java []\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int res = 0;\\n        int customerLeft = 0;\\n\\n        for (int i = 0; i < customers.length(); i++) {\\n            if (customers.charAt(i) == \\'Y\\') {\\n                customerLeft++;\\n\\n                if (customerLeft > 0) {\\n                    res = i + 1;\\n                    customerLeft = 0;\\n                }\\n            } else {\\n                customerLeft--;\\n            }\\n        }\\n\\n        return res;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int res = 0;\\n        int customerLeft = 0;\\n\\n        for (int i = 0; i < customers.length(); i++) {\\n            if (customers[i] == \\'Y\\') {\\n                customerLeft++;\\n\\n                if (customerLeft > 0) {\\n                    res = i + 1;\\n                    customerLeft = 0;\\n                }\\n            } else {\\n                customerLeft--;\\n            }\\n        }\\n\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974627,
                "title": "c-easy-approach-day-29",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string custom) {\\n        int y=0,n=0;\\n        for(auto i:custom){\\n            if(i==\\'Y\\')y++;\\n        }\\n        int mn = INT_MAX,index,penalty;\\n        for(int i=0;i<custom.size();i++){\\n            penalty = y + n;\\n            if(penalty<mn){\\n                mn = penalty;\\n                index = i;\\n            }\\n            if(custom[i]==\\'Y\\')y--;\\n            else n++;\\n        }\\n        penalty = y + n;\\n        if(penalty<mn){\\n                mn = penalty;\\n                index = custom.size();\\n        }\\n        return index;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/2137717e-1540-4e2b-8f7b-4735f781e7df_1693286878.7564614.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string custom) {\\n        int y=0,n=0;\\n        for(auto i:custom){\\n            if(i==\\'Y\\')y++;\\n        }\\n        int mn = INT_MAX,index,penalty;\\n        for(int i=0;i<custom.size();i++){\\n            penalty = y + n;\\n            if(penalty<mn){\\n                mn = penalty;\\n                index = i;\\n            }\\n            if(custom[i]==\\'Y\\')y--;\\n            else n++;\\n        }\\n        penalty = y + n;\\n        if(penalty<mn){\\n                mn = penalty;\\n                index = custom.size();\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851426,
                "title": "o-n",
                "content": "The initial penalty is when the shop stays closed.\\n\\nThen, we open it for days `[0, n)`, update the penalty, track and return the minimum one.\\n\\n**C++**\\n```cpp\\nint bestClosingTime(string cust) {\\n    int p = count(begin(cust), end(cust), \\'Y\\'), min_p = p, j = 0;\\n    for (int i = 0; i < cust.size(); ++i) {\\n        p += cust[i] == \\'Y\\' ? -1 : 1;\\n        if (p < min_p) {\\n            min_p = p;\\n            j = i + 1;\\n        }\\n    }\\n    return j;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint bestClosingTime(string cust) {\\n    int p = count(begin(cust), end(cust), \\'Y\\'), min_p = p, j = 0;\\n    for (int i = 0; i < cust.size(); ++i) {\\n        p += cust[i] == \\'Y\\' ? -1 : 1;\\n        if (p < min_p) {\\n            min_p = p;\\n            j = i + 1;\\n        }\\n    }\\n    return j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975617,
                "title": "optimal-shop-closing-time-for-minimum-penalty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to determine the earliest hour at which the shop should be closed to incur a minimum penalty. We can track the cumulative penalty and identify the hour at which the penalty is minimized.\\n\\n# Beats:\\n![image.png](https://assets.leetcode.com/users/images/f5cdcf4c-70ac-404b-a93a-4096317e3be8_1693301698.4971545.png)\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize variables x, y, and z to keep track of the best closing time, maximum penalty, and current penalty.\\n2.Loop through the customer log using the enumerate function to keep track of both the character and its index.\\n3.Update the current penalty z based on the customer\\'s presence (\\'Y\\' or \\'N\\').\\n4.If the current penalty z is greater than the maximum penalty y, update y to z and x to the current index + 1 (since the index is 0-based).\\n5.After looping through the customer log, return the value of x, which represents the earliest hour to close the shop for minimum penalty.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def bestClosingTime(self, cust: str) -> int:\\n        \\n        x = y = z = 0\\n        for i, charr in enumerate(cust):     \\n            z += (charr == \"Y\") * 2 - 1       \\n            if z > y:                       \\n                y, x = z, i+1               \\n        return x\\n    #UPVOTE IF U FIND HELPFUL!!!\\n    #CAN VISIT MY PROFILE TOO!!!\\n    \"\"\"https://leetcode.com/Pratikk_Rathod/\"\"\"                    \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to determine the earliest hour at which the shop should be closed to incur a minimum penalty. We can track the cumulative penalty and identify the hour at which the penalty is minimized.\\n\\n# Beats:\\n![image.png](https://assets.leetcode.com/users/images/f5cdcf4c-70ac-404b-a93a-4096317e3be8_1693301698.4971545.png)\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize variables x, y, and z to keep track of the best closing time, maximum penalty, and current penalty.\\n2.Loop through the customer log using the enumerate function to keep track of both the character and its index.\\n3.Update the current penalty z based on the customer\\'s presence (\\'Y\\' or \\'N\\').\\n4.If the current penalty z is greater than the maximum penalty y, update y to z and x to the current index + 1 (since the index is 0-based).\\n5.After looping through the customer log, return the value of x, which represents the earliest hour to close the shop for minimum penalty.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def bestClosingTime(self, cust: str) -> int:\\n        \\n        x = y = z = 0\\n        for i, charr in enumerate(cust):     \\n            z += (charr == \"Y\") * 2 - 1       \\n            if z > y:                       \\n                y, x = z, i+1               \\n        return x\\n    #UPVOTE IF U FIND HELPFUL!!!\\n    #CAN VISIT MY PROFILE TOO!!!\\n    \"\"\"https://leetcode.com/Pratikk_Rathod/\"\"\"                    \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3974073,
                "title": "simple-solution-beginner-friendly-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize variables` j`, `score`, and `maxScore` to keep track of the best closing time, the current score, and the maximum score encountered.\\n- Convert the input string `customers` to a character array` a`.\\n- Iterate through each character in the character array using a loop.\\n- Update the `score` based on whether the current character is \\'Y\\' or not (\\'Y\\' increments the score, while other characters decrement it).\\n- If the current `score` becomes greater than the `maxScore`, update `maxScore` and set j to the current index (i).\\n- Finally, return the value of` j + 1`, which represents the best closing time index.\\n\\nThis code essentially finds the index at which the sum of \\'Y\\' occurrences minus \\'N\\' occurrences is the highest. This indicates the best point in time for closing, as there have been more customers arriving (\\'Y\\') than leaving (\\'N\\') up to that point.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```Java []\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int j = -1, score = 0, maxScore = 0;\\n        char[] a = customers.toCharArray();\\n        for (int i = 0; i < a.length; i++) {\\n            score += a[i] == \\'Y\\'? 1 : -1;\\n            if (score > maxScore) {\\n                j = i;\\n                maxScore = score;\\n            }\\n        }\\n        return j + 1;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        j = -1\\n        score = 0\\n        maxScore = 0\\n        a = list(customers)\\n        \\n        for i in range(len(a)):\\n            if a[i] == \\'Y\\':\\n                score += 1\\n            else:\\n                score -= 1\\n            \\n            if score > maxScore:\\n                j = i\\n                maxScore = score\\n        \\n        return j + 1\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int j = -1, score = 0, maxScore = 0;\\n        \\n        for (int i = 0; i < customers.size(); ++i) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if (score > maxScore) {\\n                j = i;\\n                maxScore = score;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n};\\n\\n```\\n# If you like the solution please Upvote.\\n![5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg](https://assets.leetcode.com/users/images/1d05967c-278a-41fa-9a2a-ee36fce993dc_1693276698.7428517.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int j = -1, score = 0, maxScore = 0;\\n        char[] a = customers.toCharArray();\\n        for (int i = 0; i < a.length; i++) {\\n            score += a[i] == \\'Y\\'? 1 : -1;\\n            if (score > maxScore) {\\n                j = i;\\n                maxScore = score;\\n            }\\n        }\\n        return j + 1;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        j = -1\\n        score = 0\\n        maxScore = 0\\n        a = list(customers)\\n        \\n        for i in range(len(a)):\\n            if a[i] == \\'Y\\':\\n                score += 1\\n            else:\\n                score -= 1\\n            \\n            if score > maxScore:\\n                j = i\\n                maxScore = score\\n        \\n        return j + 1\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int j = -1, score = 0, maxScore = 0;\\n        \\n        for (int i = 0; i < customers.size(); ++i) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if (score > maxScore) {\\n                j = i;\\n                maxScore = score;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850506,
                "title": "simple-python-solution",
                "content": "* *Time Complexity :* **O(N)** (N in length of ```customer```)\\n* *Space Complexity :* **O(1)**\\n```\\nclass Solution(object):\\n    def bestClosingTime(self, customers):\\n        n = len(customers)\\n        penalty = customers.count(\\'Y\\')\\n        if penalty == n: \\n            return n\\n        min_, ans = n, 0\\n        for index, value in enumerate(customers):\\n            if min_ > penalty:\\n                min_ = penalty\\n                ans = index\\n            if value == \\'Y\\':\\n                penalty -= 1\\n            else:\\n                penalty += 1\\n        if min_ > penalty: return n\\n        return ans\\n```\\n**UpVote**, if it you like the solution **:)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```customer```\n```\\nclass Solution(object):\\n    def bestClosingTime(self, customers):\\n        n = len(customers)\\n        penalty = customers.count(\\'Y\\')\\n        if penalty == n: \\n            return n\\n        min_, ans = n, 0\\n        for index, value in enumerate(customers):\\n            if min_ > penalty:\\n                min_ = penalty\\n                ans = index\\n            if value == \\'Y\\':\\n                penalty -= 1\\n            else:\\n                penalty += 1\\n        if min_ > penalty: return n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850447,
                "title": "java-simple-greedy-solution",
                "content": "```\\n\\n/* Dry run for 1st tc \\n\\n\"YYNY\"-->totalY=3\\n         -->totalN=1\\n    for 0th ind penalty=(totalY-maintainY)= 3-0 =3, maintainY= 0+1 =1, as \\'Y\\'\\n    for 1st ind penalty=(totalY-maintainY)= 3-1 =2, maintainY= 1+1 =2, as \\'Y\\'\\n    for 2nd ind penalty=(totalY-maintainY)= 3-2 =1, maintainY= 2-1 =1,as \\'N\\'\\n    for 3rd ind penalty=(totalY-maintainY)= 3-1 =2, maintainY= 1+1 =2,as \\'Y\\'\\n    for last (string length) n of N is the penalty i.e penalty=totalN= 1\\n    \\n    out of these min index of min penalty is 2\\n    *At last index penalty will be only customer does not come\\n    *maintainY shows till now how much \\'Y\\' we have traversed as there will no penalty for the before indexes \\n*/\\n\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int totalY=0;int totalN=0;\\n        //calculating presum of Y\\n        for(char c:customers.toCharArray()){\\n            if(c==\\'Y\\')totalY++;\\n            if(c==\\'N\\')totalN++;\\n        }\\n        \\n        int minI=(int)1e9;//maintaining minimum index\\n        int min_diff=(int)1e9;//maintaining minimum diff\\n        int maintainY=0;//going forward maintaining no of Y to be sbstracted from presum(total sum of Y)\\n    \\n        for(int i=0;i<customers.length();i++){\\n            //checking if (totalY-maintainY) is less than prev diff then update\\n            if((totalY-maintainY)<min_diff){\\n                min_diff=totalY-maintainY;\\n                minI=i;\\n            }\\n            if(customers.charAt(i)==\\'Y\\')maintainY++;\\n            else maintainY--;\\n        }\\n        \\n        //for outside case\\n        // if at string length mindiff is less than or equal totalN comparing the smallest index\\n        \\n        if(min_diff<=totalN){\\n            minI=Math.min(minI,customers.length());\\n        }\\n        //else if totalN is less then min index should be string length \\n        else{\\n            minI=customers.length();\\n        }\\n        \\n        return minI;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n\\n/* Dry run for 1st tc \\n\\n\"YYNY\"-->totalY=3\\n         -->totalN=1\\n    for 0th ind penalty=(totalY-maintainY)= 3-0 =3, maintainY= 0+1 =1, as \\'Y\\'\\n    for 1st ind penalty=(totalY-maintainY)= 3-1 =2, maintainY= 1+1 =2, as \\'Y\\'\\n    for 2nd ind penalty=(totalY-maintainY)= 3-2 =1, maintainY= 2-1 =1,as \\'N\\'\\n    for 3rd ind penalty=(totalY-maintainY)= 3-1 =2, maintainY= 1+1 =2,as \\'Y\\'\\n    for last (string length) n of N is the penalty i.e penalty=totalN= 1\\n    \\n    out of these min index of min penalty is 2\\n    *At last index penalty will be only customer does not come\\n    *maintainY shows till now how much \\'Y\\' we have traversed as there will no penalty for the before indexes \\n*/\\n\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int totalY=0;int totalN=0;\\n        //calculating presum of Y\\n        for(char c:customers.toCharArray()){\\n            if(c==\\'Y\\')totalY++;\\n            if(c==\\'N\\')totalN++;\\n        }\\n        \\n        int minI=(int)1e9;//maintaining minimum index\\n        int min_diff=(int)1e9;//maintaining minimum diff\\n        int maintainY=0;//going forward maintaining no of Y to be sbstracted from presum(total sum of Y)\\n    \\n        for(int i=0;i<customers.length();i++){\\n            //checking if (totalY-maintainY) is less than prev diff then update\\n            if((totalY-maintainY)<min_diff){\\n                min_diff=totalY-maintainY;\\n                minI=i;\\n            }\\n            if(customers.charAt(i)==\\'Y\\')maintainY++;\\n            else maintainY--;\\n        }\\n        \\n        //for outside case\\n        // if at string length mindiff is less than or equal totalN comparing the smallest index\\n        \\n        if(min_diff<=totalN){\\n            minI=Math.min(minI,customers.length());\\n        }\\n        //else if totalN is less then min index should be string length \\n        else{\\n            minI=customers.length();\\n        }\\n        \\n        return minI;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974601,
                "title": "putta-easy-solution-c-prefix-sum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        vector<int> right(n+1,0);\\n        vector<int> left(n+1,0);\\n        left[0] = 0;\\n\\n        for(int i = 1;i<n+1;i++){\\n            if(customers[i-1] == \\'N\\'){\\n                left[i] = left[i-1] +1;\\n            }\\n            else left[i] = left[i-1];\\n        }\\n\\n        right[n] = 0;\\n        for(int i = n-1;i>=0;i--){\\n            if(customers[i] == \\'Y\\'){\\n                right[i] = right[i+1] +1;\\n            }\\n            else right[i] = right[i+1];\\n        }\\n        \\n        int index = 0;\\n        int min1 = 1e9;\\n        for(int i  = 0;i<n+1;i++){\\n            if (right[i]+left[i] < min1){\\n                min1 = right[i]+left[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        vector<int> right(n+1,0);\\n        vector<int> left(n+1,0);\\n        left[0] = 0;\\n\\n        for(int i = 1;i<n+1;i++){\\n            if(customers[i-1] == \\'N\\'){\\n                left[i] = left[i-1] +1;\\n            }\\n            else left[i] = left[i-1];\\n        }\\n\\n        right[n] = 0;\\n        for(int i = n-1;i>=0;i--){\\n            if(customers[i] == \\'Y\\'){\\n                right[i] = right[i+1] +1;\\n            }\\n            else right[i] = right[i+1];\\n        }\\n        \\n        int index = 0;\\n        int min1 = 1e9;\\n        for(int i  = 0;i<n+1;i++){\\n            if (right[i]+left[i] < min1){\\n                min1 = right[i]+left[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853213,
                "title": "precise-c-o-n-time-o-1-space-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string cs) {\\n            int con=0,mx=0,res=0;\\n            for(int i=0;i<cs.length();i++)\\n            {\\n                if(cs[i]==\\'Y\\')\\n                   con++;\\n                else\\n                    con--;\\n                if(con>mx)\\n                {\\n                    mx=con;\\n                    res=i+1;\\n                }\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string cs) {\\n            int con=0,mx=0,res=0;\\n            for(int i=0;i<cs.length();i++)\\n            {\\n                if(cs[i]==\\'Y\\')\\n                   con++;\\n                else\\n                    con--;\\n                if(con>mx)\\n                {\\n                    mx=con;\\n                    res=i+1;\\n                }\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851607,
                "title": "python-3-3-lines-w-example-t-m-97-25",
                "content": "```\\nclass Solution:                                                 #     Ex:   customers = \"YYNYNY\"\\n    def bestClosingTime(self, customers: str) -> int: \\n                                                                #        idx    0  1  2  3  4  5  6  7  8  9\\n                                                                #               \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013\\n                                                                #                 \"Y  Y  N  N  Y  Y  Y  N  Y\"\\n\\n        arr = [2*(ch==\\'Y\\')-1 for ch in customers]               # <--    arr =    [1, 1,-1,-1, 1, 1, 1,-1, 1]\\n                                                      \\n        arr = list(accumulate(arr, initial = 0))                # <--    arr = [0, 1, 2, 1, 0, 1, 2, 3, 2, 3]\\n                                                                #                                    |     |\\n                                                                #                                  idx=7 idx=9\\n        return arr.index(max(arr))                              # <--       return 7\\n\\n```\\n[https://leetcode.com/problems/minimum-penalty-for-a-shop/submissions/1035324655/](http://)\\n\\n\\n\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~ `len(nums)`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:                                                 #     Ex:   customers = \"YYNYNY\"\\n    def bestClosingTime(self, customers: str) -> int: \\n                                                                #        idx    0  1  2  3  4  5  6  7  8  9\\n                                                                #               \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013  \\u2013\\n                                                                #                 \"Y  Y  N  N  Y  Y  Y  N  Y\"\\n\\n        arr = [2*(ch==\\'Y\\')-1 for ch in customers]               # <--    arr =    [1, 1,-1,-1, 1, 1, 1,-1, 1]\\n                                                      \\n        arr = list(accumulate(arr, initial = 0))                # <--    arr = [0, 1, 2, 1, 0, 1, 2, 3, 2, 3]\\n                                                                #                                    |     |\\n                                                                #                                  idx=7 idx=9\\n        return arr.index(max(arr))                              # <--       return 7\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973831,
                "title": "easy-solution-pyton3-c-c-java-explain-line-by-line",
                "content": "# Problem Explanation:\\n\\nIn this problem, you are given a string representing the customer visit log of a shop. The string consists of \\'N\\' and \\'Y\\' characters, where \\'N\\' indicates that no customers come to the shop at a specific hour, and \\'Y\\' indicates that customers do come to the shop at that hour. The goal is to determine the earliest hour at which the shop should be closed to incur the minimum penalty.\\n\\nThe penalty is calculated as follows:\\n\\nFor every hour when the shop is open (\\'N\\') and no customers come (\\'N\\'), the penalty increases by 1.\\nFor every hour when the shop is closed (\\'Y\\') and customers come (\\'Y\\'), the penalty increases by 1.\\nThe task is to find the hour at which the shop should be closed to minimize the total penalty.\\n# Solution Explanation:\\nThe solution uses a systematic approach to find the optimal closing hour that results in the minimum penalty. It iterates through all possible closing hours and calculates penalties at each hour, keeping track of the minimum penalty encountered.\\n\\nCalculate the total number of customers (Y) in the input string. This is done by iterating through the string and counting the occurrences of \\'Y\\'.\\n\\nInitialize variables:\\n\\nmin_p to store the minimum penalty encountered. It is initially set to the length of the input string n.\\nhour to store the optimal closing hour.\\ny_found to keep track of the number of customers (\\'Y\\') found up to the current hour.\\nn_found to keep track of the number of non-customers (\\'N\\') found up to the current hour.\\nIterate through all possible closing hours (h from 0 to n):\\n\\nCalculate the remaining number of customers (y_remaining) that would come after the current hour. This is equal to the total number of customers (Y) minus the number of customers found up to the current hour (y_found).\\nCalculate the penalty at the current hour (pen) by summing up the remaining customers and the non-customers found so far (n_found).\\nIf the calculated penalty (pen) is less than the current minimum penalty (min_p), update hour to the current hour and update min_p with the new penalty.\\nUpdate counters:\\n\\nUpdate n_found and y_found based on whether the character at the current hour is \\'N\\' or \\'Y\\'.\\nReturn the optimal closing hour (hour) that results in the minimum penalty.\\n\\nBy systematically calculating penalties for different closing hours and tracking customers and non-customers encountered, the solution efficiently finds the optimal closing hour that minimizes the total penalty.\\n\\n\\n```Python3 []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n, Y = len(customers), 0\\n        for i in range(n):\\n            Y += (1 if customers[i] == \\'Y\\' else 0)\\n        min_p, hour, y_found, n_found = n, n, 0, 0\\n        for h in range(n + 1):\\n            y_remaining = Y - y_found\\n            pen = y_remaining + n_found\\n            if pen < min_p:\\n                hour = h\\n                min_p = pen\\n            n_found += (1 if h < n and customers[h] == \\'N\\' else 0)\\n            y_found += (1 if h < n and customers[h] == \\'Y\\' else 0)\\n        return hour\\n```\\n```python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n, Y = len(customers), 0\\n        for i in range(n):\\n            Y += (1 if customers[i] == \\'Y\\' else 0)\\n        min_p, hour, y_found, n_found = n, n, 0, 0\\n        for h in range(n + 1):\\n            y_remaining = Y - y_found\\n            pen = y_remaining + n_found\\n            if pen < min_p:\\n                hour = h\\n                min_p = pen\\n            n_found += (1 if h < n and customers[h] == \\'N\\' else 0)\\n            y_found += (1 if h < n and customers[h] == \\'Y\\' else 0)\\n        return hour\\n```\\n```C# []\\npublic class Solution\\n{\\n    public int BestClosingTime(string customers)\\n    {\\n        int n = customers.Length;\\n        int Y = 0;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            Y += (customers[i] == \\'Y\\' ? 1 : 0);\\n        }\\n        \\n        int min_p = n;\\n        int hour = n;\\n        int y_found = 0;\\n        int n_found = 0;\\n        \\n        for (int h = 0; h <= n; h++)\\n        {\\n            int y_remaining = Y - y_found;\\n            int pen = y_remaining + n_found;\\n            \\n            if (pen < min_p)\\n            {\\n                hour = h;\\n                min_p = pen;\\n            }\\n            \\n            if (h < n && customers[h] == \\'N\\')\\n            {\\n                n_found++;\\n            }\\n            \\n            if (h < n && customers[h] == \\'Y\\')\\n            {\\n                y_found++;\\n            }\\n        }\\n        \\n        return hour;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.length();\\n        int Y = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            Y += (customers[i] == \\'Y\\' ? 1 : 0);\\n        }\\n\\n        int min_p = n;\\n        int hour = n;\\n        int y_found = 0;\\n        int n_found = 0;\\n\\n        for (int h = 0; h <= n; h++) {\\n            int y_remaining = Y - y_found;\\n            int pen = y_remaining + n_found;\\n\\n            if (pen < min_p) {\\n                hour = h;\\n                min_p = pen;\\n            }\\n\\n            if (h < n && customers[h] == \\'N\\') {\\n                n_found++;\\n            }\\n\\n            if (h < n && customers[h] == \\'Y\\') {\\n                y_found++;\\n            }\\n        }\\n\\n        return hour;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public int bestClosingTime(String customers) {\\n        int n = customers.length();\\n        int Y = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            Y += (customers.charAt(i) == \\'Y\\' ? 1 : 0);\\n        }\\n\\n        int min_p = n;\\n        int hour = n;\\n        int y_found = 0;\\n        int n_found = 0;\\n\\n        for (int h = 0; h <= n; h++) {\\n            int y_remaining = Y - y_found;\\n            int pen = y_remaining + n_found;\\n\\n            if (pen < min_p) {\\n                hour = h;\\n                min_p = pen;\\n            }\\n\\n            if (h < n && customers.charAt(h) == \\'N\\') {\\n                n_found++;\\n            }\\n\\n            if (h < n && customers.charAt(h) == \\'Y\\') {\\n                y_found++;\\n            }\\n        }\\n\\n        return hour;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n, Y = len(customers), 0\\n        for i in range(n):\\n            Y += (1 if customers[i] == \\'Y\\' else 0)\\n        min_p, hour, y_found, n_found = n, n, 0, 0\\n        for h in range(n + 1):\\n            y_remaining = Y - y_found\\n            pen = y_remaining + n_found\\n            if pen < min_p:\\n                hour = h\\n                min_p = pen\\n            n_found += (1 if h < n and customers[h] == \\'N\\' else 0)\\n            y_found += (1 if h < n and customers[h] == \\'Y\\' else 0)\\n        return hour\\n```\n```python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n, Y = len(customers), 0\\n        for i in range(n):\\n            Y += (1 if customers[i] == \\'Y\\' else 0)\\n        min_p, hour, y_found, n_found = n, n, 0, 0\\n        for h in range(n + 1):\\n            y_remaining = Y - y_found\\n            pen = y_remaining + n_found\\n            if pen < min_p:\\n                hour = h\\n                min_p = pen\\n            n_found += (1 if h < n and customers[h] == \\'N\\' else 0)\\n            y_found += (1 if h < n and customers[h] == \\'Y\\' else 0)\\n        return hour\\n```\n```C# []\\npublic class Solution\\n{\\n    public int BestClosingTime(string customers)\\n    {\\n        int n = customers.Length;\\n        int Y = 0;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            Y += (customers[i] == \\'Y\\' ? 1 : 0);\\n        }\\n        \\n        int min_p = n;\\n        int hour = n;\\n        int y_found = 0;\\n        int n_found = 0;\\n        \\n        for (int h = 0; h <= n; h++)\\n        {\\n            int y_remaining = Y - y_found;\\n            int pen = y_remaining + n_found;\\n            \\n            if (pen < min_p)\\n            {\\n                hour = h;\\n                min_p = pen;\\n            }\\n            \\n            if (h < n && customers[h] == \\'N\\')\\n            {\\n                n_found++;\\n            }\\n            \\n            if (h < n && customers[h] == \\'Y\\')\\n            {\\n                y_found++;\\n            }\\n        }\\n        \\n        return hour;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.length();\\n        int Y = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            Y += (customers[i] == \\'Y\\' ? 1 : 0);\\n        }\\n\\n        int min_p = n;\\n        int hour = n;\\n        int y_found = 0;\\n        int n_found = 0;\\n\\n        for (int h = 0; h <= n; h++) {\\n            int y_remaining = Y - y_found;\\n            int pen = y_remaining + n_found;\\n\\n            if (pen < min_p) {\\n                hour = h;\\n                min_p = pen;\\n            }\\n\\n            if (h < n && customers[h] == \\'N\\') {\\n                n_found++;\\n            }\\n\\n            if (h < n && customers[h] == \\'Y\\') {\\n                y_found++;\\n            }\\n        }\\n\\n        return hour;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public int bestClosingTime(String customers) {\\n        int n = customers.length();\\n        int Y = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            Y += (customers.charAt(i) == \\'Y\\' ? 1 : 0);\\n        }\\n\\n        int min_p = n;\\n        int hour = n;\\n        int y_found = 0;\\n        int n_found = 0;\\n\\n        for (int h = 0; h <= n; h++) {\\n            int y_remaining = Y - y_found;\\n            int pen = y_remaining + n_found;\\n\\n            if (pen < min_p) {\\n                hour = h;\\n                min_p = pen;\\n            }\\n\\n            if (h < n && customers.charAt(h) == \\'N\\') {\\n                n_found++;\\n            }\\n\\n            if (h < n && customers.charAt(h) == \\'Y\\') {\\n                y_found++;\\n            }\\n        }\\n\\n        return hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858372,
                "title": "java-o-n-solution",
                "content": "# Approach\\n* Lets cosider presence of customer at an open hour gives 1 amount of profit, absense gives 1 amount of loss. \\n* Now, the problem is to find the hour when the store is in most profitable position. \\n* In other words, given a profit curve, need to find out the peak of the curve.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int maxProfit = 0;\\n        int profit = 0;\\n        int hour = 0;\\n\\n        for(int i=0; i<customers.length(); i++){\\n            profit = customers.charAt(i)==\\'Y\\' ? profit+1 : profit-1;\\n            if(profit>maxProfit){\\n                maxProfit = profit;\\n                hour = i+1;\\n            }\\n        }\\n\\n        return hour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int maxProfit = 0;\\n        int profit = 0;\\n        int hour = 0;\\n\\n        for(int i=0; i<customers.length(); i++){\\n            profit = customers.charAt(i)==\\'Y\\' ? profit+1 : profit-1;\\n            if(profit>maxProfit){\\n                maxProfit = profit;\\n                hour = i+1;\\n            }\\n        }\\n\\n        return hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974171,
                "title": "beats-100-mind-blowing-technique-with-picture-detail-explanations",
                "content": "![image.png](https://assets.leetcode.com/users/images/a39896fb-646d-4011-be64-f8c865a1bad9_1693274817.5841289.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> For every hour when the shop is open and no customers come, the penalty increases by 1.\\nFor every hour when the shop is closed and customers come, the penalty increases by 1.\\n\\nConsider the case where we close the shop at the `i`<sup>th</sup> hour with `iPenalty` and at the `j`<sup>th</sup> hour with `jPenalty`(`i` < `j`).\\nThe intuition is that the difference between `iPenalty` and `jPenalty`, aka `jPenalty - iPenalty`\\uFF0C is only related to `customers[i...j-1]`. The rest doesn\\'t matter.\\n![image.png](https://assets.leetcode.com/users/images/f7ae8839-f24a-4fbc-8439-c56537f20a6a_1693276512.8678613.png)\\nWhether we close the shop at the `i`<sup>th</sup> or `j`<sup>th</sup> hour, the penalties of both would have to count for the number of `N`s in `customers[0, i - 1]` and `Y`s in `customers[j, n - 1]`. \\n***Therefore the difference(`jPenalty - iPenalty`) is just the number of `N`s minus the number of `Y`s in `customers[i, j - 1]`.***\\nA Further explanation would be: `iPenalty` would have to count for the number of `Y`s in `customers[i, j - 1]`, while `jPenalty` would have to count for the number of `N`s in `customers[i, j - 1]`.\\nNow, if the difference (`jPenalty - iPenalty`) is less than zero, it means `jPenalty` is less than `iPenalty`. In other words, it\\'s better to close the shop at the `j`<sup>th</sup> hour than at the `i`<sup>th</sup> hour.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we assume we close the shop at the `0`<sup>th</sup> hour.\\nSet `bestTime = 0` and `penaltyDiff = 0`\\n2. Iterate through `customers`, for the `i`<sup>th</sup> character:\\n    - If `customers[i] == \\'Y\\'`, decrement `penaltyDiff` by 1. Otherwise, increment `penaltyDiff` by 1.\\n    - If `penaltyDiff < 0`, set `bestTime = i + 1` and `penaltyDiff = 0`\\n1. Return `bestTime` after the iteration.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        char[] chars = customers.toCharArray();\\n        int bestTime = 0, penaltyDiff = 0;\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == \\'Y\\') penaltyDiff--;\\n            else penaltyDiff++;\\n\\n            if (penaltyDiff < 0) {\\n                penaltyDiff = 0;\\n                bestTime = i + 1;\\n            }\\n        }\\n        return bestTime;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        bestTime, penaltyDiff = 0, 0\\n            \\n        for i in range(0, len(customers)):\\n            if customers[i] == \\'Y\\':\\n                penaltyDiff -= 1\\n            else:\\n                penaltyDiff += 1\\n            \\n            if penaltyDiff < 0:\\n                penaltyDiff = 0;\\n                bestTime = i + 1;\\n        return bestTime;\\n```\\n```c []\\nint bestClosingTime(char * customers){\\n    int bestTime = 0, penaltyDiff = 0;\\n\\n    for (int i = 0, len = strlen(customers); i < len; i++) {\\n        if (customers[i] == \\'Y\\') penaltyDiff--;\\n        else penaltyDiff++;\\n\\n        if (penaltyDiff < 0) {\\n            penaltyDiff = 0;\\n            bestTime = i + 1;\\n        }\\n    }\\n    return bestTime;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int bestTime = 0, penaltyDiff = 0;\\n        \\n        for (int i = 0, len = customers.length(); i < len; i++) {\\n            if (customers[i] == \\'Y\\') penaltyDiff--;\\n            else penaltyDiff++;\\n        \\n            if (penaltyDiff < 0) {\\n                penaltyDiff = 0;\\n                bestTime = i + 1;\\n            }\\n        }\\n        return bestTime;\\n    }\\n};\\n```\\n```javascript []\\nvar bestClosingTime = function(customers) {\\n    var bestTime = 0, penaltyDiff = 0;\\n\\n    for (var i = 0; i < customers.length; i++) {\\n        if (customers[i] == \\'Y\\') penaltyDiff--;\\n        else penaltyDiff++;\\n\\n        if (penaltyDiff < 0) {\\n            penaltyDiff = 0;\\n            bestTime = i + 1;\\n        }\\n    }\\n    return bestTime;\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        char[] chars = customers.toCharArray();\\n        int bestTime = 0, penaltyDiff = 0;\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == \\'Y\\') penaltyDiff--;\\n            else penaltyDiff++;\\n\\n            if (penaltyDiff < 0) {\\n                penaltyDiff = 0;\\n                bestTime = i + 1;\\n            }\\n        }\\n        return bestTime;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        bestTime, penaltyDiff = 0, 0\\n            \\n        for i in range(0, len(customers)):\\n            if customers[i] == \\'Y\\':\\n                penaltyDiff -= 1\\n            else:\\n                penaltyDiff += 1\\n            \\n            if penaltyDiff < 0:\\n                penaltyDiff = 0;\\n                bestTime = i + 1;\\n        return bestTime;\\n```\n```c []\\nint bestClosingTime(char * customers){\\n    int bestTime = 0, penaltyDiff = 0;\\n\\n    for (int i = 0, len = strlen(customers); i < len; i++) {\\n        if (customers[i] == \\'Y\\') penaltyDiff--;\\n        else penaltyDiff++;\\n\\n        if (penaltyDiff < 0) {\\n            penaltyDiff = 0;\\n            bestTime = i + 1;\\n        }\\n    }\\n    return bestTime;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int bestTime = 0, penaltyDiff = 0;\\n        \\n        for (int i = 0, len = customers.length(); i < len; i++) {\\n            if (customers[i] == \\'Y\\') penaltyDiff--;\\n            else penaltyDiff++;\\n        \\n            if (penaltyDiff < 0) {\\n                penaltyDiff = 0;\\n                bestTime = i + 1;\\n            }\\n        }\\n        return bestTime;\\n    }\\n};\\n```\n```javascript []\\nvar bestClosingTime = function(customers) {\\n    var bestTime = 0, penaltyDiff = 0;\\n\\n    for (var i = 0; i < customers.length; i++) {\\n        if (customers[i] == \\'Y\\') penaltyDiff--;\\n        else penaltyDiff++;\\n\\n        if (penaltyDiff < 0) {\\n            penaltyDiff = 0;\\n            bestTime = i + 1;\\n        }\\n    }\\n    return bestTime;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851127,
                "title": "without-extra-space-one-traversal-c",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int ans=0,maxVal=0,count=0;\\n\\n        for(int i=0;i<customers.length();i++){\\n\\n            if(customers[i] == \\'Y\\') \\n                count++;\\n            else \\n                count--;\\n\\n            if(count > maxVal){ //not equal to because we want the minimum answer\\n                ans=i+1;\\n                maxVal = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int ans=0,maxVal=0,count=0;\\n\\n        for(int i=0;i<customers.length();i++){\\n\\n            if(customers[i] == \\'Y\\') \\n                count++;\\n            else \\n                count--;\\n\\n            if(count > maxVal){ //not equal to because we want the minimum answer\\n                ans=i+1;\\n                maxVal = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850443,
                "title": "c-solution-with-o-n-time-very-simple-and-easy-to-understand",
                "content": "<b>Up vote if you like the solution\\n```\\n/*\\nWe need to evaluate penality due to N and due to Y separately.\\nTo do nPenality we need to iterate from left to right and create an array, where ith idex represent\\npenality due to N, if closed at ith hour.\\nSimilarly, we need to evaluate yPenalty from right to left and store the value in a variable as we \\nare using this value directly and don\\'t have to store in an array.\\nso the closing time will be the ith value with least value of nPenality[i] + yPanelty;\\n*/\\n\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        vector<int> nPenalty(customers.size() + 1, 0);\\n        int yPenalty = 0; \\n        for(int i = 0; i < customers.size(); ++i){\\n            nPenalty[i+1] = nPenalty[i];\\n            if(customers[i] == \\'N\\') nPenalty[i+1]++;\\n        }\\n        int mn = nPenalty.back(), ans = customers.size();\\n        for(int i = customers.size()-1;  i >= 0; --i){\\n            if(customers[i] == \\'Y\\') yPenalty++;\\n            if(mn >= nPenalty[i] + yPenalty){\\n                ans = i;\\n                mn = nPenalty[i] + yPenalty;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nWe need to evaluate penality due to N and due to Y separately.\\nTo do nPenality we need to iterate from left to right and create an array, where ith idex represent\\npenality due to N, if closed at ith hour.\\nSimilarly, we need to evaluate yPenalty from right to left and store the value in a variable as we \\nare using this value directly and don\\'t have to store in an array.\\nso the closing time will be the ith value with least value of nPenality[i] + yPanelty;\\n*/\\n\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        vector<int> nPenalty(customers.size() + 1, 0);\\n        int yPenalty = 0; \\n        for(int i = 0; i < customers.size(); ++i){\\n            nPenalty[i+1] = nPenalty[i];\\n            if(customers[i] == \\'N\\') nPenalty[i+1]++;\\n        }\\n        int mn = nPenalty.back(), ans = customers.size();\\n        for(int i = customers.size()-1;  i >= 0; --i){\\n            if(customers[i] == \\'Y\\') yPenalty++;\\n            if(mn >= nPenalty[i] + yPenalty){\\n                ans = i;\\n                mn = nPenalty[i] + yPenalty;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974369,
                "title": "c-o-n-presum",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.length();\\n        \\n\\t\\t// Storing count of \\'Y\\' penalties on right if we close on \\'ith index\\'\\n        vector<int> right(n+1,0);\\n        for(int i=n-1;i>=0;i--) right[i] = (i<n-1 ? right[i+1]:0) + (customers[i]==\\'Y\\');\\n        \\n\\t\\t // storing \\'N\\' penalties on left if close on \\'ith\\' index\\n        vector<int> left(n,0);\\n        \\n        int min_penalty=n+1;\\n        int idx=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            int penalty = right[i] + (i>0 ? left[i-1]:0);\\n            \\n            if(min_penalty > penalty){\\n                min_penalty=min(min_penalty,penalty);\\n                idx = i;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tleft[i] = (i>0 ? left[i-1]:0) + (customers[i]==\\'N\\');\\n        }\\n        \\n\\t\\t// if we decide to close after all customers have come\\n        if(min_penalty > right[n] + left[n-1]) return n;\\n\\t\\t\\n        return idx;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.length();\\n        \\n\\t\\t// Storing count of \\'Y\\' penalties on right if we close on \\'ith index\\'\\n        vector<int> right(n+1,0);\\n        for(int i=n-1;i>=0;i--) right[i] = (i<n-1 ? right[i+1]:0) + (customers[i]==\\'Y\\');\\n        \\n\\t\\t // storing \\'N\\' penalties on left if close on \\'ith\\' index\\n        vector<int> left(n,0);\\n        \\n        int min_penalty=n+1;\\n        int idx=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            int penalty = right[i] + (i>0 ? left[i-1]:0);\\n            \\n            if(min_penalty > penalty){\\n                min_penalty=min(min_penalty,penalty);\\n                idx = i;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tleft[i] = (i>0 ? left[i-1]:0) + (customers[i]==\\'N\\');\\n        }\\n        \\n\\t\\t// if we decide to close after all customers have come\\n        if(min_penalty > right[n] + left[n-1]) return n;\\n\\t\\t\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850636,
                "title": "c-easy-prefix-count-time-o-n-constant-space",
                "content": "Count the number of YES before hand.\\nNow simply calculate penalty for each time values.\\n\\n```\\nint bestClosingTime(string cust) {\\n        int yesc = 0, noc = 0;\\n        \\n        for(char c:cust)\\n            if(c == \\'Y\\')\\n                yesc++;\\n        \\n        \\n        int penal=0,mintime=INT_MAX,minpenal = INT_MAX;\\n        \\n        for(int i=0;i<=cust.length();i++)\\n        {\\n            penal = yesc + noc;\\n            if(penal < minpenal)\\n            {\\n                mintime = i;\\n                minpenal = penal;\\n            }\\n            if(i<cust.length() && cust[i] == \\'N\\')\\n                noc++;\\n            if(i<cust.length() && cust[i] == \\'Y\\')\\n                yesc--;\\n        }\\n        return mintime;\\n    }\\n```\\n**PLEASE UPVOTE IF YOU LIKE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint bestClosingTime(string cust) {\\n        int yesc = 0, noc = 0;\\n        \\n        for(char c:cust)\\n            if(c == \\'Y\\')\\n                yesc++;\\n        \\n        \\n        int penal=0,mintime=INT_MAX,minpenal = INT_MAX;\\n        \\n        for(int i=0;i<=cust.length();i++)\\n        {\\n            penal = yesc + noc;\\n            if(penal < minpenal)\\n            {\\n                mintime = i;\\n                minpenal = penal;\\n            }\\n            if(i<cust.length() && cust[i] == \\'N\\')\\n                noc++;\\n            if(i<cust.length() && cust[i] == \\'Y\\')\\n                yesc--;\\n        }\\n        return mintime;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850620,
                "title": "java-solution-using-array-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int yes[]=new int[customers.length()+1];\\n\\t\\tint no[]=new int[customers.length()+1];\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tfor(int i=customers.length()-1;i>=0;i--) {\\n\\t\\t\\tif(customers.charAt(i)==\\'Y\\') count++;\\n\\t\\t\\tyes[i]=count;\\n\\t\\t}\\n\\t\\tcount=0;\\n\\t\\tfor(int i=0;i<customers.length();i++) {\\n\\t\\t\\tif(customers.charAt(i)==\\'N\\') count++;\\n\\t\\t\\tno[i+1]=count;\\n\\t\\t}\\n     //   no[customers.length()-1]=no[customers.length()-2];\\n\\t\\t\\n\\t\\tint ans[]=new int[yes.length];\\n\\t\\tint min=Integer.MAX_VALUE;\\n\\t\\tint res=0;\\n\\t\\tfor(int i=0;i<yes.length;i++) {\\n\\t\\t\\tint sum=yes[i]+no[i];\\n\\t\\t\\tif(min>sum) {\\n\\t\\t\\t\\tmin=sum;\\n\\t\\t\\t\\tres=i;\\n             //   System.out.println(no[customers.length()-1]);\\n\\t\\t\\t}\\n            \\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int yes[]=new int[customers.length()+1];\\n\\t\\tint no[]=new int[customers.length()+1];\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tfor(int i=customers.length()-1;i>=0;i--) {\\n\\t\\t\\tif(customers.charAt(i)==\\'Y\\') count++;\\n\\t\\t\\tyes[i]=count;\\n\\t\\t}\\n\\t\\tcount=0;\\n\\t\\tfor(int i=0;i<customers.length();i++) {\\n\\t\\t\\tif(customers.charAt(i)==\\'N\\') count++;\\n\\t\\t\\tno[i+1]=count;\\n\\t\\t}\\n     //   no[customers.length()-1]=no[customers.length()-2];\\n\\t\\t\\n\\t\\tint ans[]=new int[yes.length];\\n\\t\\tint min=Integer.MAX_VALUE;\\n\\t\\tint res=0;\\n\\t\\tfor(int i=0;i<yes.length;i++) {\\n\\t\\t\\tint sum=yes[i]+no[i];\\n\\t\\t\\tif(min>sum) {\\n\\t\\t\\t\\tmin=sum;\\n\\t\\t\\t\\tres=i;\\n             //   System.out.println(no[customers.length()-1]);\\n\\t\\t\\t}\\n            \\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850448,
                "title": "c-easy-detailed-explanation",
                "content": "**Approach-** Shop can be closed at any j value where 0<=j<= n. for ith index we are looking for \\n=> number of \\'N\\' occuring before i +  number of \\'Y\\' from i to n\\n\\nreason behind this is penalty condition-\\n1) open + no customer = penalty\\n2) close + customer = penalty\\n\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string str) {\\n        int n = str.size();\\n        \\n        //left- open- how many \\'N\\' are there before i\\n        //right- close- how many \\'Y\\' are there from i to n\\n        vector<int> left(n), right(n);\\n        \\n        int nCount=0, yCount= 0, totalN= 0;\\n        //yCount and totalN\\n        for(int i=0; i<n; i++){\\n            if(str[i]==\\'Y\\')\\n                yCount++;\\n            else\\n                totalN++;\\n        }\\n        \\n        //prepare left and right\\n        for(int i=0; i<n; i++){\\n            right[i] = yCount;\\n            \\n            if(str[i]== \\'Y\\') yCount--;\\n            \\n            left[i] = nCount;       //<i\\n            if(str[i]==\\'N\\')\\n                nCount++;\\n        }\\n        \\n        //get penalties\\n        int mn= INT_MAX, ans= 0;\\n        for(int i=0; i<n; i++){\\n            int temp = left[i]+right[i];\\n            if(temp<mn){\\n                mn = temp;\\n                ans = i;\\n            }\\n            \\n            // // cout<<mn<<\" \";\\n            // cout<<left[i]<<\" \"<<right[i]<<endl;\\n        }\\n        \\n        \\n        //totalN is penalty of j=n;\\n        return (min(mn, totalN) == mn) ? ans : n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string str) {\\n        int n = str.size();\\n        \\n        //left- open- how many \\'N\\' are there before i\\n        //right- close- how many \\'Y\\' are there from i to n\\n        vector<int> left(n), right(n);\\n        \\n        int nCount=0, yCount= 0, totalN= 0;\\n        //yCount and totalN\\n        for(int i=0; i<n; i++){\\n            if(str[i]==\\'Y\\')\\n                yCount++;\\n            else\\n                totalN++;\\n        }\\n        \\n        //prepare left and right\\n        for(int i=0; i<n; i++){\\n            right[i] = yCount;\\n            \\n            if(str[i]== \\'Y\\') yCount--;\\n            \\n            left[i] = nCount;       //<i\\n            if(str[i]==\\'N\\')\\n                nCount++;\\n        }\\n        \\n        //get penalties\\n        int mn= INT_MAX, ans= 0;\\n        for(int i=0; i<n; i++){\\n            int temp = left[i]+right[i];\\n            if(temp<mn){\\n                mn = temp;\\n                ans = i;\\n            }\\n            \\n            // // cout<<mn<<\" \";\\n            // cout<<left[i]<<\" \"<<right[i]<<endl;\\n        }\\n        \\n        \\n        //totalN is penalty of j=n;\\n        return (min(mn, totalN) == mn) ? ans : n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3974425,
                "title": "95-faster-java-c-easy-to-undersatnd-simple",
                "content": "# variables and use\\n - int n = length of customer\\n - int penalty = for count each hour penalty\\n - int min_penalty= for minimum penalty\\n - int min_hour = minimum hour for min_penalty \\n\\n# Approach\\n\\n - initialy shop colse at 0th hour coutn penalty for 0th hour \\n - penaly is applide for each \\'Y\\' so total penalty for 0th hour is total accurence of \\'Y\\'\\n - and suppose 0th hour penalty is minimum penalty and min_hour=0\\n \\n-  Now iterate loop from 0 to n)-1 times\\n\\n- if at i th hour shop is open and i th hour cusromer is present(customers[i-1]==\\'Y\\') then penalty will be decrease\\n- else at i th hour shop is open and i th hour cusromer is not present(customers[i-1]==\\'N\\') then penalty will be increase\\n- now if penaly for close shope at ith hour is less than min_penalty than update min_hour and min_penalty\\n \\n- return min_hour\\n  \\n\\n# Complexity\\n- Time complexity: O(N);\\n\\n- Space complexity: O(4);\\n- because 4 variables are used\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) \\n    {\\n        int n=customers.length();\\n\\n        int min_penalty=0;\\n        int min_hour=0;\\n        int penalty=0;\\n\\n        // if shop close at 0th hour\\n        for(int i=0; i<n; i++)\\n        {\\n            if(customers[i]==\\'Y\\')\\n                penalty++;\\n            \\n        }   \\n\\n        min_penalty=penalty;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(customers[i-1]==\\'Y\\')\\n                penalty--;\\n            else\\n                penalty++;\\n\\n            if(penalty<min_penalty)\\n            {\\n                min_penalty=penalty;\\n                min_hour=i;\\n            }    \\n        } \\n\\n        return min_hour;    \\n    }\\n};\\n```\\n\\n# Java code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) \\n    {\\n        int n=customers.length();\\n\\n        int min_penalty=0;\\n        int min_hour=0; \\n        int penalty=0;\\n\\n        // if shop close at 0th hour\\n        for(int i=0; i<n; i++)\\n        {\\n            if(customers.charAt(i)==\\'Y\\')\\n                penalty++;    \\n        }   \\n\\n        min_penalty=penalty;\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(customers.charAt(i-1)==\\'Y\\')\\n                penalty--;\\n            else\\n                penalty++;\\n\\n            if(penalty<min_penalty)\\n            {\\n                min_penalty=penalty;\\n                min_hour=i;\\n            }    \\n        } \\n\\n        return min_hour;\\n    }\\n}\\n```\\nPlease Upvote is code is helpfull for you",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) \\n    {\\n        int n=customers.length();\\n\\n        int min_penalty=0;\\n        int min_hour=0;\\n        int penalty=0;\\n\\n        // if shop close at 0th hour\\n        for(int i=0; i<n; i++)\\n        {\\n            if(customers[i]==\\'Y\\')\\n                penalty++;\\n            \\n        }   \\n\\n        min_penalty=penalty;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(customers[i-1]==\\'Y\\')\\n                penalty--;\\n            else\\n                penalty++;\\n\\n            if(penalty<min_penalty)\\n            {\\n                min_penalty=penalty;\\n                min_hour=i;\\n            }    \\n        } \\n\\n        return min_hour;    \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) \\n    {\\n        int n=customers.length();\\n\\n        int min_penalty=0;\\n        int min_hour=0; \\n        int penalty=0;\\n\\n        // if shop close at 0th hour\\n        for(int i=0; i<n; i++)\\n        {\\n            if(customers.charAt(i)==\\'Y\\')\\n                penalty++;    \\n        }   \\n\\n        min_penalty=penalty;\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(customers.charAt(i-1)==\\'Y\\')\\n                penalty--;\\n            else\\n                penalty++;\\n\\n            if(penalty<min_penalty)\\n            {\\n                min_penalty=penalty;\\n                min_hour=i;\\n            }    \\n        } \\n\\n        return min_hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974144,
                "title": "3-c-prefix-sum-solutions-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse prefix sums for computing penalties where nn[i] denotes the # of \\'N\\' before the hour i and y_rem denotes the # of \\'Y\\' from hour i on.\\n```\\np[i]=nn[i] + y_rem;\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n2nd solution optimizes the code  slightly by using count function and one for loop & uses only O(1) SC!\\n\\nLet\\'s consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\\n```\\n0: nn=0 y_rem=4 penalty=4\\n1: nn=1 y_rem=4 penalty=5\\n2: nn=1 y_rem=3 penalty=4\\n3: nn=1 y_rem=2 penalty=3\\n4: nn=1 y_rem=1 penalty=2\\n5: nn=2 y_rem=1 penalty=3\\n6: nn=3 y_rem=1 penalty=4\\n7: nn=4 y_rem=1 penalty=5\\n8: nn=4 y_rem=0 penalty=4\\n9: nn=5 y_rem=0 penalty=5\\n10: nn=6 y_rem=0 penalty=6\\nminI=4\\n```\\nIf you look the code in 2nd solution carefully, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!( Since it known the relation between previous penalty and current penalty\\n```\\nint y=customers[i-1] == \\'Y\\'?1:-1;\\npenalty-=y; \\n```\\n) The counting  for y_rem, i.e. the # of \\'Y\\' from hour i on, can be saved. The 3rd solution is so simple! And it beats 100% with runtime 11 ms. Cheers!!!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\\\to O(1)$$\\n# 1st Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        vector<int> nn(n+1, 0), p(n+1, 0);\\n        int y_rem = 0;\\n        \\n        nn[0] = 0;\\n        y_rem = (customers[0]==\\'Y\\');\\n        \\n        for (int i = 1; i <= n; i++) {\\n            nn[i]=nn[i-1]+(customers[i-1]==\\'N\\'); \\n            y_rem+=(customers[i-1]==\\'Y\\'); \\n        }\\n        \\n        p[0] = nn[0]+y_rem;\\n        int minP=p[0], minI=0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            y_rem -= (customers[i-1] == \\'Y\\');\\n            p[i]=nn[i] + y_rem;\\n            \\n            if (minP> p[i]) {\\n                minP=p[i];\\n                minI=i;\\n            }\\n        }\\n        return minI;\\n    }\\n};\\n\\n```\\n# 2nd solution with SC O(1) Beats 96.91% runtime 18 ms\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        int y_rem = count(customers.begin(), customers.end(), \\'Y\\');\\n        int nn = 0;\\n        \\n        int penalty = nn+y_rem;\\n        int minP=penalty, minI=0;\\n        \\n        for (int i=1; i <= n; i++) {\\n            int y=customers[i-1] == \\'Y\\';\\n            y_rem -= y;\\n            nn+=(1-y); \\n            penalty=nn+y_rem;\\n            \\n            if (minP> penalty) {\\n                minP=penalty;\\n                minI=i;\\n            }\\n        }\\n        return minI;\\n    }\\n};\\n\\n```\\nNote that this code can be furthermore optimized to replace the part in for loop\\n```\\nint y=customers[i-1] == \\'Y\\';\\ny_rem -= y;\\nnn+=(1-y); \\npenalty=nn+y_rem;\\n```\\nby the following simplification\\n\\n```\\nint y=customers[i-1] == \\'Y\\'?1:-1;\\npenalty-=y;\\n```\\n# 3rd solution beats 100% with runtime 11 ms\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n    \\n        int penalty=0;//without adding y_rem does not matter \\n        int minP=penalty, minI=0;\\n    //    cout<<0<<\": nn=\"<<nn<<\" penalty=\"<<penalty<<endl;\\n        for (int i=1; i <= n; i++) {\\n            int y=customers[i-1] == \\'Y\\'?1:-1;\\n            penalty-=y;\\n    //        cout<<i<<\": nn=\"<<nn<<\" penalty=\"<<penalty<<endl;\\n            if (minP> penalty) {\\n                minP=penalty;\\n                minI=i;\\n            }\\n        }\\n    //    cout<<\"minI=\"<<minI<<endl;\\n        return minI;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\np[i]=nn[i] + y_rem;\\n```\n```\\n0: nn=0 y_rem=4 penalty=4\\n1: nn=1 y_rem=4 penalty=5\\n2: nn=1 y_rem=3 penalty=4\\n3: nn=1 y_rem=2 penalty=3\\n4: nn=1 y_rem=1 penalty=2\\n5: nn=2 y_rem=1 penalty=3\\n6: nn=3 y_rem=1 penalty=4\\n7: nn=4 y_rem=1 penalty=5\\n8: nn=4 y_rem=0 penalty=4\\n9: nn=5 y_rem=0 penalty=5\\n10: nn=6 y_rem=0 penalty=6\\nminI=4\\n```\n```\\nint y=customers[i-1] == \\'Y\\'?1:-1;\\npenalty-=y; \\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        vector<int> nn(n+1, 0), p(n+1, 0);\\n        int y_rem = 0;\\n        \\n        nn[0] = 0;\\n        y_rem = (customers[0]==\\'Y\\');\\n        \\n        for (int i = 1; i <= n; i++) {\\n            nn[i]=nn[i-1]+(customers[i-1]==\\'N\\'); \\n            y_rem+=(customers[i-1]==\\'Y\\'); \\n        }\\n        \\n        p[0] = nn[0]+y_rem;\\n        int minP=p[0], minI=0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            y_rem -= (customers[i-1] == \\'Y\\');\\n            p[i]=nn[i] + y_rem;\\n            \\n            if (minP> p[i]) {\\n                minP=p[i];\\n                minI=i;\\n            }\\n        }\\n        return minI;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        int y_rem = count(customers.begin(), customers.end(), \\'Y\\');\\n        int nn = 0;\\n        \\n        int penalty = nn+y_rem;\\n        int minP=penalty, minI=0;\\n        \\n        for (int i=1; i <= n; i++) {\\n            int y=customers[i-1] == \\'Y\\';\\n            y_rem -= y;\\n            nn+=(1-y); \\n            penalty=nn+y_rem;\\n            \\n            if (minP> penalty) {\\n                minP=penalty;\\n                minI=i;\\n            }\\n        }\\n        return minI;\\n    }\\n};\\n\\n```\n```\\nint y=customers[i-1] == \\'Y\\';\\ny_rem -= y;\\nnn+=(1-y); \\npenalty=nn+y_rem;\\n```\n```\\nint y=customers[i-1] == \\'Y\\'?1:-1;\\npenalty-=y;\\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n    \\n        int penalty=0;//without adding y_rem does not matter \\n        int minP=penalty, minI=0;\\n    //    cout<<0<<\": nn=\"<<nn<<\" penalty=\"<<penalty<<endl;\\n        for (int i=1; i <= n; i++) {\\n            int y=customers[i-1] == \\'Y\\'?1:-1;\\n            penalty-=y;\\n    //        cout<<i<<\": nn=\"<<nn<<\" penalty=\"<<penalty<<endl;\\n            if (minP> penalty) {\\n                minP=penalty;\\n                minI=i;\\n            }\\n        }\\n    //    cout<<\"minI=\"<<minI<<endl;\\n        return minI;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2853674,
                "title": "easy-to-understand-solution-with-explanation-plz-upvote-if-you-liked-it",
                "content": "# Java simple solution, easy to understand.\\n# Explanation:\\nFirst we calculate penalty when we close the shop at zero hour.\\n\\n- To do this we iterate over the string and whenever we get a \\'Y\\', we increase the penalty by 1, because we already closed the shop at 0th hour, so whenever a customer arrive we get a penalty. Let say we store it in a variable - \"currPenalty\" .\\n\\nNow we try to calculate the same for every hour(i.e. index).\\n- We again iterate over the given string from index 1 till last index.\\nNow if we close the shop at 1st hour, we know that shop was opened for previous hour i.e.  0th hour and closed after 1 (including 1). Therefore we can use the \\'currPenalty\\' calculated at previous index and adding or removing the penalty for previous index. *(if customer doesnt come, we add the penalty and if customer comes we remove the penalty bcoz the shop was open at previous index)*\\n\\n_Now we do this for every index meanwhile calculating the minimum penalty and its corresponding index_.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String cust) {\\n        \\n        int n = cust.length(), currPenalty = 0, ind = 0, minPenalty;\\n        //Calculating penalty when shop is closed at 0th hour.\\n        for(char ch : cust.toCharArray()){\\n            if(ch == \\'Y\\') currPenalty++;\\n        }\\n        minPenalty = currPenalty;\\n        //Calculating penalty for every index. When we close shop at every hour one by one.\\n        //Also keeping track of minimum penalty and its index.\\n        for(int i = 1; i <= n; i++){\\n            if(cust.charAt(i-1) == \\'Y\\'){\\n                currPenalty--;\\n            }\\n            else currPenalty++;\\n            if(currPenalty < minPenalty){\\n                minPenalty = currPenalty;\\n                ind = i;\\n            }\\n        }\\n        \\n        return ind;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String cust) {\\n        \\n        int n = cust.length(), currPenalty = 0, ind = 0, minPenalty;\\n        //Calculating penalty when shop is closed at 0th hour.\\n        for(char ch : cust.toCharArray()){\\n            if(ch == \\'Y\\') currPenalty++;\\n        }\\n        minPenalty = currPenalty;\\n        //Calculating penalty for every index. When we close shop at every hour one by one.\\n        //Also keeping track of minimum penalty and its index.\\n        for(int i = 1; i <= n; i++){\\n            if(cust.charAt(i-1) == \\'Y\\'){\\n                currPenalty--;\\n            }\\n            else currPenalty++;\\n            if(currPenalty < minPenalty){\\n                minPenalty = currPenalty;\\n                ind = i;\\n            }\\n        }\\n        \\n        return ind;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852232,
                "title": "c-very-easy-to-understand-using-simple-prefix-and-suffix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        vector<int> pref(n+1,0);\\n        vector<int> suff(n+1,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n          if(customers[i-1]==\\'N\\')\\n          pref[i]+=pref[i-1]+1;\\n          else\\n          pref[i]+=pref[i-1];\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(customers[i]==\\'Y\\')\\n            suff[i]+=(suff[i+1]+1);\\n            else\\n            suff[i]+=(suff[i+1]);\\n        }\\n        vector<int> ans(n+1);\\n        for(int i=0;i<=n;i++)\\n        {\\n            ans[i]=pref[i]+suff[i];\\n        }\\n        int x=*min_element(ans.begin(),ans.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(ans[i]==x)\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        vector<int> pref(n+1,0);\\n        vector<int> suff(n+1,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n          if(customers[i-1]==\\'N\\')\\n          pref[i]+=pref[i-1]+1;\\n          else\\n          pref[i]+=pref[i-1];\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(customers[i]==\\'Y\\')\\n            suff[i]+=(suff[i+1]+1);\\n            else\\n            suff[i]+=(suff[i+1]);\\n        }\\n        vector<int> ans(n+1);\\n        for(int i=0;i<=n;i++)\\n        {\\n            ans[i]=pref[i]+suff[i];\\n        }\\n        int x=*min_element(ans.begin(),ans.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(ans[i]==x)\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850584,
                "title": "c-o-n-easy-understanding-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string cus) {\\n        int l = cus.length();\\n        int cY=0, cN=0;\\n        //counting Number of Y\\n        for(int i=0; i<l; i++){\\n            if(cus[i]==\\'Y\\'){\\n                cY++;\\n            }\\n        }\\n        int loss = INT_MAX;\\n        int ans =0;\\n        \\n        for(int i=0; i<l; i++){\\n            //counting total Number of penalty at ith time\\n            int x = cY+cN;\\n            if(loss > x){\\n                ans = i;\\n                loss = x;\\n            }\\n            //If a customer is coming in ith time then closing after ith time will not cause penalty\\n            if(cus[i]==\\'Y\\'){\\n                cY--;\\n            }else{\\n                //If no customer is coming in ith time then keep the shop open after ith time will cause penalty\\n                cN++;\\n            }\\n        }\\n        //Edge case\\n        int x = cY+cN;\\n        if(loss>x){\\n            ans  = l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string cus) {\\n        int l = cus.length();\\n        int cY=0, cN=0;\\n        //counting Number of Y\\n        for(int i=0; i<l; i++){\\n            if(cus[i]==\\'Y\\'){\\n                cY++;\\n            }\\n        }\\n        int loss = INT_MAX;\\n        int ans =0;\\n        \\n        for(int i=0; i<l; i++){\\n            //counting total Number of penalty at ith time\\n            int x = cY+cN;\\n            if(loss > x){\\n                ans = i;\\n                loss = x;\\n            }\\n            //If a customer is coming in ith time then closing after ith time will not cause penalty\\n            if(cus[i]==\\'Y\\'){\\n                cY--;\\n            }else{\\n                //If no customer is coming in ith time then keep the shop open after ith time will cause penalty\\n                cN++;\\n            }\\n        }\\n        //Edge case\\n        int x = cY+cN;\\n        if(loss>x){\\n            ans  = l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975569,
                "title": "c-prefix-sum-simple-and-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Intuition behind is prefix sum . Intuition was simple that at index \\'i\\' if we close the shop then all the \\'Y\\' afterwards will make count to penality, on the otherhand those hours where we encountered \\'N\\' before \\'i\\'th index also increases penality and in the end we have to consider the \\'i\\' th value as well that is if it\\'s \\'Y\\' then it\\'ll add to penality else continue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n To approach this problem we need count of \\'Y\\' and \\'N\\' for the prefix sum part. For this we need to created a vector of pair where first part of pair is the count of \\'Y\\' till \\'i\\' th index and same for \\'N\\' which is stored in the second part of the pair vector. We maintained to variable \\ni.e \\'a\\' and \\'b\\' for counts. \\nWe created two more variables i.e ans and ind where ans store the minimum penality till i\\'th index and ind is for storing index with minimum penality encountered. At each index we store the number of \\'N\\' encountered so far and all the \\'Y\\' after index \\'i\\' as mention in the intuition and all this is stored in a variable temp. check if ans is less then the temp(penality at i) then make ans equal to temp change the ind to i.\\n\\nAt the end if ans is greater than total \\'N\\' in the string then return \\'n\\' else return \\'ind\\'.\\n \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe use 2 for loops which makes the time complexity O(2n) which is nothing but equivalent to O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince we used the prefix sum approach and created a vector of size n hence the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n         int n = customers.size();\\n        int ans=INT_MAX,ind = -1,a=0,b=0;\\n       vector<pair<int,int>>v(n);\\n       for(int i=0;i<n;i++){\\n           if(customers[i]==\\'Y\\'){\\n               a++;v[i] = {a,b};\\n           }\\n           else if(customers[i]==\\'N\\'){\\n               b++;v[i] = {a,b};\\n           }\\n       }\\n       for(int i=0;i<n;i++){\\n           int temp = v[i].second + v[n-1].first - v[i].first;\\n           if(customers[i]==\\'Y\\')temp++;\\n           else if(customers[i]==\\'N\\')temp--;\\n           if(ans>temp){\\n               ans = temp;\\n               ind =i;\\n           }\\n       }\\n        return ans>v[n-1].second?n:ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n         int n = customers.size();\\n        int ans=INT_MAX,ind = -1,a=0,b=0;\\n       vector<pair<int,int>>v(n);\\n       for(int i=0;i<n;i++){\\n           if(customers[i]==\\'Y\\'){\\n               a++;v[i] = {a,b};\\n           }\\n           else if(customers[i]==\\'N\\'){\\n               b++;v[i] = {a,b};\\n           }\\n       }\\n       for(int i=0;i<n;i++){\\n           int temp = v[i].second + v[n-1].first - v[i].first;\\n           if(customers[i]==\\'Y\\')temp++;\\n           else if(customers[i]==\\'N\\')temp--;\\n           if(ans>temp){\\n               ans = temp;\\n               ind =i;\\n           }\\n       }\\n        return ans>v[n-1].second?n:ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974844,
                "title": "two-pass-prefix-sum",
                "content": "*Time Complexity - > O(3N), Space Copmlexity -> O(2N)*\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        int n = c.size();\\n        int prefix[n+1];\\n        prefix[n] = 0;\\n        \\n        for(int i = n-1; i >= 0; i--){\\n           if(c[i] == \\'Y\\'){\\n               prefix[i] = 1 + prefix[i+1];\\n           }\\n            else prefix[i] = prefix[i+1];\\n        }\\n        \\n        int suffix[n+1];\\n        suffix[0] = 0;\\n        \\n        for(int i = 1; i <= n; i++){\\n            if(c[i-1] == \\'N\\'){\\n                suffix[i] = 1 + suffix[i-1];\\n            }\\n            else suffix[i] = suffix[i-1];\\n        }\\n        \\n     /*  for(int i = 0 ; i <=n ;i++)cout<<prefix[i]<<\" \";\\n       cout<<\"\\\\n\";\\n       for(int i = 0 ; i <=n ;i++)cout<<suffix[i]<<\" \";   */\\n        \\n        \\n        int mini = INT_MAX; \\n        int idx = 0;\\n        for(int i = 0; i <= n; i++){\\n            int curr = prefix[i] + suffix[i];\\n            if(mini > curr){\\n                mini = curr;\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        int n = c.size();\\n        int prefix[n+1];\\n        prefix[n] = 0;\\n        \\n        for(int i = n-1; i >= 0; i--){\\n           if(c[i] == \\'Y\\'){\\n               prefix[i] = 1 + prefix[i+1];\\n           }\\n            else prefix[i] = prefix[i+1];\\n        }\\n        \\n        int suffix[n+1];\\n        suffix[0] = 0;\\n        \\n        for(int i = 1; i <= n; i++){\\n            if(c[i-1] == \\'N\\'){\\n                suffix[i] = 1 + suffix[i-1];\\n            }\\n            else suffix[i] = suffix[i-1];\\n        }\\n        \\n     /*  for(int i = 0 ; i <=n ;i++)cout<<prefix[i]<<\" \";\\n       cout<<\"\\\\n\";\\n       for(int i = 0 ; i <=n ;i++)cout<<suffix[i]<<\" \";   */\\n        \\n        \\n        int mini = INT_MAX; \\n        int idx = 0;\\n        for(int i = 0; i <= n; i++){\\n            int curr = prefix[i] + suffix[i];\\n            if(mini > curr){\\n                mini = curr;\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3557985,
                "title": "c-simple-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int sum = 0;\\n        for(auto &i: s){\\n            sum += (i==\\'Y\\');\\n        }\\n        int ans = 0, k = 0;\\n        int x = sum;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i]==\\'N\\')k++;//in prefix string no of NO\\n            if(s[i]==\\'Y\\')sum--;//in suffix no of YES\\n            if(sum+k<x){//if current penalty < previously calculated penalty than update and\\n                x = sum+k;\\n                ans = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int sum = 0;\\n        for(auto &i: s){\\n            sum += (i==\\'Y\\');\\n        }\\n        int ans = 0, k = 0;\\n        int x = sum;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i]==\\'N\\')k++;//in prefix string no of NO\\n            if(s[i]==\\'Y\\')sum--;//in suffix no of YES\\n            if(sum+k<x){//if current penalty < previously calculated penalty than update and\\n                x = sum+k;\\n                ans = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851230,
                "title": "penalize-suffix-array",
                "content": "# Intuition\\nCreate A Suffix Array of penalty to close at each hour and using it find the first hour with minimum penalty.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalcultate the penalty in one go for clossing at `n`.\\nThen Compute the suffix array:\\nif `customers[i] == \\'Y\\'` then `+1` \\nelse `-1`\\nGet the min element position and return.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        vector<int> suffix(n + 1, 0);\\n        int penalty = 0;\\n        for(char ch: customers)\\n            if(ch == \\'N\\')\\n                penalty++;\\n        suffix[n] = penalty;\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(customers[i] == \\'N\\')\\n                suffix[i] = suffix[i + 1] - 1;\\n            else\\n                suffix[i] = suffix[i + 1] + 1;\\n        }\\n        return min_element(suffix.begin(), suffix.end()) - suffix.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        vector<int> suffix(n + 1, 0);\\n        int penalty = 0;\\n        for(char ch: customers)\\n            if(ch == \\'N\\')\\n                penalty++;\\n        suffix[n] = penalty;\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(customers[i] == \\'N\\')\\n                suffix[i] = suffix[i + 1] - 1;\\n            else\\n                suffix[i] = suffix[i + 1] + 1;\\n        }\\n        return min_element(suffix.begin(), suffix.end()) - suffix.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850676,
                "title": "python-time-o-n-space-o-1-video-solution",
                "content": "You can watch the [video solution](https://youtu.be/rt9NncFGekY).\\n\\nLet\\'s consider the customers to be of two type.\\n1. **Bad** Customer (***N***) - who doesn\\'t purchase.\\n2. **Good** Customer (***Y***) - who purchases.\\n\\n\\n# Penalty\\nThe penalty at any given hour, will be the sum of\\n1. **Good**(Y) customers that won\\'t be served if we close now\\n2. **Bad**(N) customers that have been served\\n\\n\\n# 0th hour\\nInitially if we close at `0th hour` ( no customer has been served)\\nthe penalty would be no. of **Good**(***Y***) customers\\n\\n\\n# Nth hour\\nIf we close at `nth hour` ( all customers have been served)\\nthe penalty would be no. of **Bad**(***N***) customers`\\n\\n\\nWe can assume this to our `inital_min_penalty` and `closing_hour`.\\n\\n\\n# Find min penalty & hour\\n\\nFor calculating the penalty of closing at `hour h`, we have to keep track of \\n1. No. of **Bad** customers served.\\nThis can be kept track by no. of **Bad** customers encountered.\\n\\n2. No. of **Good** customer that will be left unserved.\\nThis can be kept track by subtracting from total no. of **Good** customers , the  no . of **Good** customers found so far.\\n\\nIf our **current penalty** is the minimum, then we will update the `hour` & `min_penalty`.\\n\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\nIf you liked this solution, please upvote.\\n\\nCheers.\\n# Python solution:\\n\\n```\\nclass Solution:\\n    def bestClosingTime(self, cus: str) -> int:\\n        n = len(cus)\\n        \\n        Y = 0  # no. of good(Y) customers\\n\\t\\t\\n\\t\\t# This loop will count the total no. of N & Y customers.\\n        for i in range(n):\\n            Y +=(1 if cus[i]==\\'Y\\' else 0)\\n        \\n        min_p = n # Let\\'s assume we served all bad customers.\\n        hour = n  # And the hour would be n. \\n        \\n\\t\\t# We will calculate the penalty for each hour now. \\n\\t\\t# penalty = ( no. of Good(Y) remaining + no. of Bad(N) encountered )\\n\\t\\t# Initially at the start of 0 hour, both of them would be 0.\\n        y_found=0\\n        n_found = 0\\n\\t\\t\\n\\t\\t# We will try for all the hours (h) and try to find the minimum penalty.\\n        for h in range(n+1):\\n\\t\\t\\t\\n\\t\\t\\t# This is the first part of penalty if we close now .\\n\\t\\t\\t#( no. of Good(Y) that won\\'t be served if we close now).\\n            y_remaining = Y - y_found   \\n            \\n\\t\\t\\t# Penalty = Good(Y) customers that will be left out \\n\\t\\t\\t# + Bad(N) customers that have been served\\n            pen = y_remaining + n_found\\n\\t\\t\\t\\n\\t\\t\\t# If penalty is less than our min. penalty encountered so far. \\n\\t\\t\\t# We will update the closing hour, and the min. penalty\\n            if pen<min_p: \\n                hour = h\\n                min_p = pen\\n                \\n\\t\\t\\t# We will update the count of Bad(N) & Good(Y) customer.\\n            n_found+=(1 if h<n and cus[h]==\\'N\\' else 0)\\n            y_found+=(1 if h<n and cus[h]==\\'Y\\' else 0)\\n        \\n\\t\\t# This will be the earliest hour for the min. penalty\\n        return hour\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "You can watch the [video solution](https://youtu.be/rt9NncFGekY).\\n\\nLet\\'s consider the customers to be of two type.\\n1. **Bad** Customer (***N***) - who doesn\\'t purchase.\\n2. **Good** Customer (***Y***) - who purchases.\\n\\n\\n# Penalty\\nThe penalty at any given hour, will be the sum of\\n1. **Good**(Y) customers that won\\'t be served if we close now\\n2. **Bad**(N) customers that have been served\\n\\n\\n# 0th hour\\nInitially if we close at `0th hour` ( no customer has been served)\\nthe penalty would be no. of **Good**(***Y***) customers\\n\\n\\n# Nth hour\\nIf we close at `nth hour` ( all customers have been served)\\nthe penalty would be no. of **Bad**(***N***) customers`\\n\\n\\nWe can assume this to our `inital_min_penalty` and `closing_hour`.\\n\\n\\n# Find min penalty & hour\\n\\nFor calculating the penalty of closing at `hour h`, we have to keep track of \\n1. No. of **Bad** customers served.\\nThis can be kept track by no. of **Bad** customers encountered.\\n\\n2. No. of **Good** customer that will be left unserved.\\nThis can be kept track by subtracting from total no. of **Good** customers , the  no . of **Good** customers found so far.\\n\\nIf our **current penalty** is the minimum, then we will update the `hour` & `min_penalty`.\\n\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\nIf you liked this solution, please upvote.\\n\\nCheers.\\n# Python solution:\\n\\n```\\nclass Solution:\\n    def bestClosingTime(self, cus: str) -> int:\\n        n = len(cus)\\n        \\n        Y = 0  # no. of good(Y) customers\\n\\t\\t\\n\\t\\t# This loop will count the total no. of N & Y customers.\\n        for i in range(n):\\n            Y +=(1 if cus[i]==\\'Y\\' else 0)\\n        \\n        min_p = n # Let\\'s assume we served all bad customers.\\n        hour = n  # And the hour would be n. \\n        \\n\\t\\t# We will calculate the penalty for each hour now. \\n\\t\\t# penalty = ( no. of Good(Y) remaining + no. of Bad(N) encountered )\\n\\t\\t# Initially at the start of 0 hour, both of them would be 0.\\n        y_found=0\\n        n_found = 0\\n\\t\\t\\n\\t\\t# We will try for all the hours (h) and try to find the minimum penalty.\\n        for h in range(n+1):\\n\\t\\t\\t\\n\\t\\t\\t# This is the first part of penalty if we close now .\\n\\t\\t\\t#( no. of Good(Y) that won\\'t be served if we close now).\\n            y_remaining = Y - y_found   \\n            \\n\\t\\t\\t# Penalty = Good(Y) customers that will be left out \\n\\t\\t\\t# + Bad(N) customers that have been served\\n            pen = y_remaining + n_found\\n\\t\\t\\t\\n\\t\\t\\t# If penalty is less than our min. penalty encountered so far. \\n\\t\\t\\t# We will update the closing hour, and the min. penalty\\n            if pen<min_p: \\n                hour = h\\n                min_p = pen\\n                \\n\\t\\t\\t# We will update the count of Bad(N) & Good(Y) customer.\\n            n_found+=(1 if h<n and cus[h]==\\'N\\' else 0)\\n            y_found+=(1 if h<n and cus[h]==\\'Y\\' else 0)\\n        \\n\\t\\t# This will be the earliest hour for the min. penalty\\n        return hour\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2850490,
                "title": "short-concise-single-pass-o-1-space-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        int cnt = 0, val = INT_MIN, ans, f = 0;\\n        for(int i=0; i<c.size(); i++) {\\n            cnt += c[i] == \\'Y\\' ? 1 : -1;\\n            if(cnt > 0) f = 1;\\n            if(cnt > val) ans = i + 1, val = cnt;\\n        }\\n        return !f ? 0 : ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        int cnt = 0, val = INT_MIN, ans, f = 0;\\n        for(int i=0; i<c.size(); i++) {\\n            cnt += c[i] == \\'Y\\' ? 1 : -1;\\n            if(cnt > 0) f = 1;\\n            if(cnt > val) ans = i + 1, val = cnt;\\n        }\\n        return !f ? 0 : ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850437,
                "title": "c-use-prefix-sum-simple-efficient-approach",
                "content": "**Approach:** \\nFrom 1st test case, it\\'s clear that we need total sum and prefix sum of string to calculate penalty for each index(hour).\\n1. In total sum, we store number of \\'Y\\' in a string.\\n2. Then create a hashmap to store penalty for each index.\\n3. If shope is open and costumer come we increase prefix sum by 1 else we decrease prefix sum by 1 and find penalty for each index by substracting prefix sum from total sum and stores in hashmap.\\n4. At last, we return index with minimum penalty.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int bestClosingTime(string s) \\n    {\\n        int totsum=0;\\n        int presum=0;\\n        int n=s.size();\\n        \\n\\t\\t//calculate total sum\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'Y\\') totsum++;\\n        }\\n        \\n\\t\\t//find penalty for each hour and stores into hashmap\\n        map<int, int> mp;\\n        mp[0] = totsum;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'Y\\')\\n            {\\n                presum++;\\n            }\\n            else\\n                presum--;\\n            \\n            mp[i+1] = totsum-presum;   \\n        }\\n        \\n\\t\\t//find earlier hour with minimum penalty\\n        int hour=n;\\n        int p=n;\\n        for(auto it:mp)\\n        {\\n            if(it.second < p)\\n            {\\n                hour=it.first;\\n                p = it.second;\\n            }\\n        }\\n        return hour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int bestClosingTime(string s) \\n    {\\n        int totsum=0;\\n        int presum=0;\\n        int n=s.size();\\n        \\n\\t\\t//calculate total sum\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'Y\\') totsum++;\\n        }\\n        \\n\\t\\t//find penalty for each hour and stores into hashmap\\n        map<int, int> mp;\\n        mp[0] = totsum;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'Y\\')\\n            {\\n                presum++;\\n            }\\n            else\\n                presum--;\\n            \\n            mp[i+1] = totsum-presum;   \\n        }\\n        \\n\\t\\t//find earlier hour with minimum penalty\\n        int hour=n;\\n        int p=n;\\n        for(auto it:mp)\\n        {\\n            if(it.second < p)\\n            {\\n                hour=it.first;\\n                p = it.second;\\n            }\\n        }\\n        return hour;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977201,
                "title": "easy-c-solution-o-n",
                "content": "![Screenshot (84).png](https://assets.leetcode.com/users/images/711b18e1-2f55-45d9-bb1b-ff924574e568_1693326584.9925787.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int left = 0,right = 0;\\n        int n = customers.length();\\n        for(int i=0;i<n;i++){\\n            if(customers[i] == \\'Y\\') right++;\\n        }\\n        pair<int,int>mini = {left+right,0};\\n      \\n        for(int i=1;i<=n;i++){\\n            if(customers[i-1]==\\'N\\') {\\n                left++;\\n\\n            }\\n            else if(customers[i-1] == \\'Y\\'){\\n                right--;\\n            }\\n            if(left+right < mini.first){\\n                mini.first = left+right;\\n                mini.second = i;\\n            }\\n            \\n        }\\n       return mini.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int left = 0,right = 0;\\n        int n = customers.length();\\n        for(int i=0;i<n;i++){\\n            if(customers[i] == \\'Y\\') right++;\\n        }\\n        pair<int,int>mini = {left+right,0};\\n      \\n        for(int i=1;i<=n;i++){\\n            if(customers[i-1]==\\'N\\') {\\n                left++;\\n\\n            }\\n            else if(customers[i-1] == \\'Y\\'){\\n                right--;\\n            }\\n            if(left+right < mini.first){\\n                mini.first = left+right;\\n                mini.second = i;\\n            }\\n            \\n        }\\n       return mini.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975789,
                "title": "basic-c-implementation-easy-to-understand-prefix-suffix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int m=s.size();\\n        vector<int> y, n;\\n        for (int i=0; i<m; i++) {\\n            if (s[i]==\\'Y\\') {\\n                y.push_back(1);\\n            } else {\\n                y.push_back(0);\\n            }\\n        }\\n        // we will push 0 at the end because we have to find from 0-mth hour so vector size will be m+1\\n        y.push_back(0);\\n        // we will make the suffix sum for vector y\\n        for (int i=m; i>=1; i--) {\\n            y[i-1]=y[i]+y[i-1];\\n        }\\n        // in this we will push 0 in the beginning \\n        n.push_back(0);\\n        for (int i=0; i<m; i++) {\\n            if (s[i]==\\'N\\') {\\n                n.push_back(1);\\n            } else {\\n                n.push_back(0);\\n            }\\n        }\\n        // prefix sum for vector n\\n        for (int i=0; i<m; i++) {\\n            n[i+1]=n[i]+n[i+1];\\n        }\\n        // the purpose of pushing 0 at the beginning in y and at the end in n is\\n        // at the 0th hr the penalty is the suffix sum of y and at the mth hr the penalty is prefix sum of n \\n        // after this we will add the values of y and n and find minimum value index from starting\\n        for (int i=0; i<y.size(); i++) {\\n            cout<<y[i]<<\" \";\\n            y[i]=y[i]+n[i];\\n        }\\n        int a=0;\\n        int k=*min_element(y.begin(), y.end());\\n        for (int i=0; i<y.size(); i++) {\\n            if (y[i]==k) {\\n                a=i;\\n                break;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int m=s.size();\\n        vector<int> y, n;\\n        for (int i=0; i<m; i++) {\\n            if (s[i]==\\'Y\\') {\\n                y.push_back(1);\\n            } else {\\n                y.push_back(0);\\n            }\\n        }\\n        // we will push 0 at the end because we have to find from 0-mth hour so vector size will be m+1\\n        y.push_back(0);\\n        // we will make the suffix sum for vector y\\n        for (int i=m; i>=1; i--) {\\n            y[i-1]=y[i]+y[i-1];\\n        }\\n        // in this we will push 0 in the beginning \\n        n.push_back(0);\\n        for (int i=0; i<m; i++) {\\n            if (s[i]==\\'N\\') {\\n                n.push_back(1);\\n            } else {\\n                n.push_back(0);\\n            }\\n        }\\n        // prefix sum for vector n\\n        for (int i=0; i<m; i++) {\\n            n[i+1]=n[i]+n[i+1];\\n        }\\n        // the purpose of pushing 0 at the beginning in y and at the end in n is\\n        // at the 0th hr the penalty is the suffix sum of y and at the mth hr the penalty is prefix sum of n \\n        // after this we will add the values of y and n and find minimum value index from starting\\n        for (int i=0; i<y.size(); i++) {\\n            cout<<y[i]<<\" \";\\n            y[i]=y[i]+n[i];\\n        }\\n        int a=0;\\n        int k=*min_element(y.begin(), y.end());\\n        for (int i=0; i<y.size(); i++) {\\n            if (y[i]==k) {\\n                a=i;\\n                break;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3975502,
                "title": "best-c-solution-u-can-get",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT AND COMMENT FOR ANY DOUBTS**\\n# Approach\\nThis code is implementing a function called bestClosingTime that takes a string customers as input, where each character represents whether a customer arrived (\\'Y\\') or left (\\'N\\') during a certain hour. The goal of the function is to find the hour with the highest net customer count (more arrivals than departures) and return that hour + 1.\\n\\nLet\\'s break down the code step by step:\\n\\nInitialize Variables:\\n\\nmaxscore: Keeps track of the maximum net customer count encountered so far.\\nscore: Represents the net customer count at the current hour.\\nbesthour: Stores the hour with the highest net customer count.\\nAll these variables are initialized with appropriate initial values.\\n\\nLoop Through the String:\\nThe code uses a loop to iterate through the characters of the customers string. The loop variable i represents the current hour.\\n\\nUpdate the score:\\n\\nIf the current character is \\'Y\\' (indicating a customer arrived), the score is incremented by 1.\\nIf the current character is \\'N\\' (indicating a customer left), the score is decremented by 1.\\nThis process keeps track of the net customer count at each hour.\\n\\nUpdate maxscore and besthour:\\nIf the current value of score is greater than the current value of maxscore, it means that the net customer count at the current hour is the highest encountered so far. In this case:\\n\\nmaxscore is updated with the new highest net customer count (score).\\nbesthour is updated with the current hour (i).\\nReturn the Result:\\nAfter the loop, the besthour value (representing the hour with the highest net customer count) is returned +1. This is because the array indices are 0-based, but the question likely expects the answer in 1-based index form.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int maxscore = 0, score = 0, besthour = -1;\\n        for(int i = 0; i < customers.size(); i++) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if(score > maxscore) {\\n                maxscore = score;\\n                besthour = i;\\n            }\\n        }\\n        return besthour + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int maxscore = 0, score = 0, besthour = -1;\\n        for(int i = 0; i < customers.size(); i++) {\\n            score += (customers[i] == \\'Y\\') ? 1 : -1;\\n            if(score > maxscore) {\\n                maxscore = score;\\n                besthour = i;\\n            }\\n        }\\n        return besthour + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975283,
                "title": "c-o-n-beats-100-easy-solution-fully-explained-w-comments-day-29",
                "content": "# Approach\\nThe basic approach is to know the penalty beforehand if we dont open the store at all and then increase the hour at which we shut one-by-one and calculate the new penalty, if the current penalty is smaller than previous, then we store the new min. penalty and store its closing hour.\\nFinally we return the hour at which we incurr least penalty!\\n\\nplease UPVOTE if this helped you!\\nlooking forward to discussions!\\ncheers!\\n\\n# Complexity\\n- Time complexity:\\n```O(N)``` as we traverse through the string with a single loop\\n\\n- Space complexity:\\n```O(1)``` constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        \\n        int n = c.size(); // c = customers\\n        int totalY=0; int cntN=0; int cntY=0;\\n        int penalty=1e8; //initially taking penalty as a large number \\n        int hour=0;      // hour = the hour at which we close\\n\\n        for(int i=0; i<n; i++) if(c[i]==\\'Y\\')totalY++; //counting all the Y\\'s (prefix sum logic basically)\\n\\n        //if closed at 0th hour=> did not open shop at all\\n        if(penalty > totalY){\\n            penalty = totalY;\\n            hour=0; // => 0th hour\\n        }\\n\\n        //traversing through the string\\n        for(int i=0; i<n; i++){ \\n\\n            if(c[i]==\\'Y\\') cntY++; //counting Y\\'s encountered till now\\n            else if(c[i]==\\'N\\') cntN++; //counting N\\'s encountered till now\\n\\n //IMP :    val = the penalty if i shut store at the END OF THIS hour i.e (i+1)th hour\\n            int val = (totalY-cntY) + cntN; //i.e (remamaing Ys) + (Ns till now)\\n\\n            //if this \\'val\\' penalty is smaller, then we update our min penalty value and closing hour\\n            if(penalty > val){ \\n                penalty = val;\\n                hour=i+1; //as closing would be index+1 th hour\\n            }\\n        }\\n\\n        return hour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```O(N)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        \\n        int n = c.size(); // c = customers\\n        int totalY=0; int cntN=0; int cntY=0;\\n        int penalty=1e8; //initially taking penalty as a large number \\n        int hour=0;      // hour = the hour at which we close\\n\\n        for(int i=0; i<n; i++) if(c[i]==\\'Y\\')totalY++; //counting all the Y\\'s (prefix sum logic basically)\\n\\n        //if closed at 0th hour=> did not open shop at all\\n        if(penalty > totalY){\\n            penalty = totalY;\\n            hour=0; // => 0th hour\\n        }\\n\\n        //traversing through the string\\n        for(int i=0; i<n; i++){ \\n\\n            if(c[i]==\\'Y\\') cntY++; //counting Y\\'s encountered till now\\n            else if(c[i]==\\'N\\') cntN++; //counting N\\'s encountered till now\\n\\n //IMP :    val = the penalty if i shut store at the END OF THIS hour i.e (i+1)th hour\\n            int val = (totalY-cntY) + cntN; //i.e (remamaing Ys) + (Ns till now)\\n\\n            //if this \\'val\\' penalty is smaller, then we update our min penalty value and closing hour\\n            if(penalty > val){ \\n                penalty = val;\\n                hour=i+1; //as closing would be index+1 th hour\\n            }\\n        }\\n\\n        return hour;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974915,
                "title": "prefix-sum-and-space-optimisation-hack-o-n-time-and-o-1-space-c-highly-efficient-solution",
                "content": "# Intuition\\nIf we can find the total penalty for keeping our shop open till day i, in $$O(1)$$ time, we can reduce the time complexity by a lot.\\n\\n# Approach\\nHave some preprocessing to calculate the cost of keeping the shop closed on all days, and then one by one open the shop and keeping adding or subtracting the penalty from the previous day penalty corresponding to if there were customers or not on the previous day.\\n\\n# Solution 1 (Using an array to store penalties)\\n**Time Complexity: $$O(n)$$**\\n**Space Complexity: $$O(n)$$**\\n\\nCreate an array to store the total penalty incurred to keep the shop open on `day i`. On every iteration, use the penalty information of the previous day to calculate the penalty for opening the shop till `day i`.\\n\\n# Code\\n\\n```\\nint bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int totalPenaltyFromFirst=0;\\n        for(auto c:customers){\\n            totalPenaltyFromFirst+=(c==\\'Y\\' ? 1 : 0);\\n        } //preprocessing for calculating total penalty for keeping shop closed on all days\\n\\n        int minHour=0;\\n        vector<int> penalties(n+1,0);\\n        penalties[0]=totalPenaltyFromFirst;\\n        int minPenalty=penalties[0];\\n\\n        for(int i=1;i<=n;i++){\\n            penalties[i]=penalties[i-1];\\n            if(customers[i-1]==\\'Y\\'){\\n                penalties[i]--; // person came on previous day, cost recovered, penalty reduced\\n            }\\n            else if(customers[i-1]==\\'N\\'){\\n                penalties[i]++; // person didn\\'t come on previous day, cost beared, penalty increased\\n            }\\n\\n            if(penalties[i]<minPenalty){\\n                minPenalty=penalties[i];\\n                minHour=i;\\n                //if today\\'s penalty is less than previous min penalty, update it\\n            }\\n        }\\n\\n        return minHour;\\n    }\\n```\\n![image.png](https://assets.leetcode.com/users/images/23a99079-54c1-4a56-b45f-362de22813b0_1693290553.624397.png)\\n\\n\\n\\n# Solution 2 (Space Optimization on Solution 1)\\n**Time Complexity: $$O(n)$$**\\n**Space Complexity: $$O(1)$$**\\n\\nWe need only one variable to dynamically update the penalty on day i, penalty on day before it (`penalty[i-1]`). So, instead of maintaining a whole array, we maintain a variable, `prevPenalty` that keeps the track of the penalty on the previous day.\\nThe hack used is that instead of maintaining the penalty for `day i`, we update previous day\\'s penalty so that at the end of the loop, it automatically holds the penalty for `day i`, which will be used by `day i+1`\\n\\n# Code\\n\\n```\\nint bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int totalPenaltyFromFirst=0;\\n        for(auto c:customers){\\n            totalPenaltyFromFirst+=(c==\\'Y\\' ? 1 : 0);\\n        } //preprocessing for calculating total penalty for keeping shop closed on all days\\n\\n        int minHour=0;\\n        int prevPenalty=totalPenaltyFromFirst;\\n        int minPenalty=totalPenaltyFromFirst;\\n\\n        for(int i=1;i<=n;i++){\\n            if(customers[i-1]==\\'Y\\'){\\n                prevPenalty--; // person came on previous day, cost recovered, penalty reduced\\n            }\\n            else if(customers[i-1]==\\'N\\'){\\n                prevPenalty++; // person didn\\'t come on previous day, cost beared, penalty increased\\n            }\\n\\n            if(prevPenalty<minPenalty){\\n                minPenalty=prevPenalty;\\n                minHour=i;\\n                //if updated penalty for today is less than previous min penalty, update it\\n            }\\n        }\\n        return minHour;\\n    }\\n```\\n![image.png](https://assets.leetcode.com/users/images/b7ef5556-93a9-4b6a-a711-9b333af53923_1693290596.3022137.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nint bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int totalPenaltyFromFirst=0;\\n        for(auto c:customers){\\n            totalPenaltyFromFirst+=(c==\\'Y\\' ? 1 : 0);\\n        } //preprocessing for calculating total penalty for keeping shop closed on all days\\n\\n        int minHour=0;\\n        vector<int> penalties(n+1,0);\\n        penalties[0]=totalPenaltyFromFirst;\\n        int minPenalty=penalties[0];\\n\\n        for(int i=1;i<=n;i++){\\n            penalties[i]=penalties[i-1];\\n            if(customers[i-1]==\\'Y\\'){\\n                penalties[i]--; // person came on previous day, cost recovered, penalty reduced\\n            }\\n            else if(customers[i-1]==\\'N\\'){\\n                penalties[i]++; // person didn\\'t come on previous day, cost beared, penalty increased\\n            }\\n\\n            if(penalties[i]<minPenalty){\\n                minPenalty=penalties[i];\\n                minHour=i;\\n                //if today\\'s penalty is less than previous min penalty, update it\\n            }\\n        }\\n\\n        return minHour;\\n    }\\n```\n```\\nint bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int totalPenaltyFromFirst=0;\\n        for(auto c:customers){\\n            totalPenaltyFromFirst+=(c==\\'Y\\' ? 1 : 0);\\n        } //preprocessing for calculating total penalty for keeping shop closed on all days\\n\\n        int minHour=0;\\n        int prevPenalty=totalPenaltyFromFirst;\\n        int minPenalty=totalPenaltyFromFirst;\\n\\n        for(int i=1;i<=n;i++){\\n            if(customers[i-1]==\\'Y\\'){\\n                prevPenalty--; // person came on previous day, cost recovered, penalty reduced\\n            }\\n            else if(customers[i-1]==\\'N\\'){\\n                prevPenalty++; // person didn\\'t come on previous day, cost beared, penalty increased\\n            }\\n\\n            if(prevPenalty<minPenalty){\\n                minPenalty=prevPenalty;\\n                minHour=i;\\n                //if updated penalty for today is less than previous min penalty, update it\\n            }\\n        }\\n        return minHour;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974866,
                "title": "c-easy-approach-solution-tc-o-n-full-explanation",
                "content": "# Approach\\nSuppose, you close the shop at xth hour where 0<=x<=n.\\nThen, the penalty is count of \\'N\\' untill the shop is opened plus count of \\'Y\\' after the shop is closed.\\n\\nNow, you just have to loop through 0-n and store the first hour which has the minimum penalty.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        //curN-->>Count of \\'N\\' till which hour the shop is open.\\n        //curY-->>Count of \\'Y\\' from where shop is closed to the end hour.\\n        //At any time the penalty is,curP i.e. ()curY+curN).\\n\\n        int curY=0,curN=0,n=customers.length();\\n        for(auto ch:customers) if(ch==\\'Y\\') curY++;\\n        int ans,minPenalty=n+1;\\n        for(int i=0;i<n;i++){\\n           int curP=curY+curN;\\n           if(curP<minPenalty){\\n               minPenalty=curP;\\n               ans=i;\\n           }\\n           if(customers[i]==\\'N\\') curN++;\\n           else curY--;\\n        }\\n        if(curN<minPenalty){\\n            ans=n;\\n            minPenalty=curN;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        //curN-->>Count of \\'N\\' till which hour the shop is open.\\n        //curY-->>Count of \\'Y\\' from where shop is closed to the end hour.\\n        //At any time the penalty is,curP i.e. ()curY+curN).\\n\\n        int curY=0,curN=0,n=customers.length();\\n        for(auto ch:customers) if(ch==\\'Y\\') curY++;\\n        int ans,minPenalty=n+1;\\n        for(int i=0;i<n;i++){\\n           int curP=curY+curN;\\n           if(curP<minPenalty){\\n               minPenalty=curP;\\n               ans=i;\\n           }\\n           if(customers[i]==\\'N\\') curN++;\\n           else curY--;\\n        }\\n        if(curN<minPenalty){\\n            ans=n;\\n            minPenalty=curN;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974771,
                "title": "single-pass-prefix-sum-o-n-solution-with-explanation",
                "content": "\\n# Approach\\nWe traverse over the string and increase our points for every \\'Y\\' and decrease our points for every \\'N\\'.\\n\\nWhenever our points > maximum points(maxi), we update our maxi as well as our hour, which we will tell us on which hour to close the shop.\\n\\nAt any point of the for loop, our hour variable will tell till which hour should our shop be kept open to gain maximum points, hence the hour at which shop should be closed is hour + 1.\\n\\n# Single Pass Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int maxi = 0;\\n        int points = 0;\\n        int hour = -1;\\n        for(int i = 0; i < customers.size(); i++){\\n            if(customers[i] == \\'Y\\') points+= 1;\\n            else points+= -1;\\n\\n            if(points > maxi){\\n                maxi = points;\\n                hour = i;\\n            }\\n        }\\n        return hour + 1;\\n    }\\n};\\n```\\n# Prefix Sum approach\\nIn this approach we calculate the prefixSum of N for each index and suffixSum of Y for each index,\\n\\nprefixSum for an index i means, number of N before that index.\\nhence for index 0 , since its the first index, prefixSum will always be 0.\\n\\nSimilarly, for suffixSum, suffixSum for an index is number of \\'Y\\' after that index, hence for index n, which is last index, suffixSum will always be 0.\\n\\nWe increment the prefixSum for an index if the character at that index is \\'N\\', and for suffixSum, we increment if character is \\'Y\\'.\\n\\nAt last, we find total penalty by taking sum of prefix and suffix for each index, and the index with minimum penalty will be our answer.\\n\\n# Prefix Sum Code\\n```\\nint bestClosingTime(string customers){\\n        int n = customers.size();\\n        vector<int> prefix(n + 1, 0);\\n        vector<int> suffix(n + 1, 0);\\n\\n        for(int i = 1; i <= n; i++){\\n            if(customers[i-1] == \\'N\\') prefix[i] = prefix[i-1] + 1;\\n            else prefix[i] = prefix[i-1];\\n        }\\n\\n        for(int i = n-1; i >= 0; i--){\\n            if(customers[i] == \\'Y\\') suffix[i] = suffix[i+1] + 1;\\n            else suffix[i] = suffix[i+1];\\n        }\\n\\n        int ans = 0;\\n        int mini = INT_MAX;\\n        for(int i = 0; i <= n; i++){\\n            if(prefix[i] + suffix[i] < mini){\\n                mini = prefix[i] + suffix[i];\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int maxi = 0;\\n        int points = 0;\\n        int hour = -1;\\n        for(int i = 0; i < customers.size(); i++){\\n            if(customers[i] == \\'Y\\') points+= 1;\\n            else points+= -1;\\n\\n            if(points > maxi){\\n                maxi = points;\\n                hour = i;\\n            }\\n        }\\n        return hour + 1;\\n    }\\n};\\n```\n```\\nint bestClosingTime(string customers){\\n        int n = customers.size();\\n        vector<int> prefix(n + 1, 0);\\n        vector<int> suffix(n + 1, 0);\\n\\n        for(int i = 1; i <= n; i++){\\n            if(customers[i-1] == \\'N\\') prefix[i] = prefix[i-1] + 1;\\n            else prefix[i] = prefix[i-1];\\n        }\\n\\n        for(int i = n-1; i >= 0; i--){\\n            if(customers[i] == \\'Y\\') suffix[i] = suffix[i+1] + 1;\\n            else suffix[i] = suffix[i+1];\\n        }\\n\\n        int ans = 0;\\n        int mini = INT_MAX;\\n        for(int i = 0; i <= n; i++){\\n            if(prefix[i] + suffix[i] < mini){\\n                mini = prefix[i] + suffix[i];\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974377,
                "title": "profit-loss-java-beginner-friendly",
                "content": "Hi,\\n\\nUpon examining this problem, I observed that it is a straightforward profit and loss situation. If he opens the shop for a certain period, he will gain some profit; however, if the customers do not come, he will incur a loss.\\n\\nSo, I began in the same way. Initially, I iterated through the given string to identify instances of profit and loss. Since the shop had not opened yet, the number of customers he would miss represented a loss for him (indicated by \\'Y\\'), while the opposite indicated profit (indicated by \\'N\\').\\n\\nFor the sake of clarity, I stored these values in an array starting at position 0. Subsequently, I iterated through each character, increasing the profit count for \\'Y\\' and the loss count for \\'N\\'.\\n\\nFinally, I traversed the final array to determine the maximum profit and the corresponding hour, returning its position.\\n\\nWe can solve this problem without storing it in an array by directly comparing the values. However, I opted for this approach to ensure beginners can understand it clearly.\\n\\nHappy learning! If you find this helpful, please consider upvoting :)\\n\\n```\\n    public int bestClosingTime(String customers) {\\n        int y=0, n=0;\\n        for(char ch: customers.toCharArray()){\\n            if(ch==\\'Y\\')\\n                y++;\\n            else\\n                n++;\\n        }\\n        int profit = n;\\n        int loss = y;\\n        int[] arr = new int[customers.length()+1];\\n        arr[0]=profit-loss;\\n        for(int i=1; i<=customers.length(); i++){\\n            char ch = customers.charAt(i-1);\\n            if(ch==\\'Y\\'){\\n                profit++;\\n            } else {\\n                loss++;\\n            }\\n            arr[i]=profit-loss;\\n        }\\n        int idx=0, max = Integer.MIN_VALUE;\\n        for(int i=0; i<=customers.length(); i++){\\n            if(arr[i]>max){\\n                max = arr[i];\\n                idx=i;\\n            }\\n        }\\n        return idx;\\n    }\\n\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "Hi,\\n\\nUpon examining this problem, I observed that it is a straightforward profit and loss situation. If he opens the shop for a certain period, he will gain some profit; however, if the customers do not come, he will incur a loss.\\n\\nSo, I began in the same way. Initially, I iterated through the given string to identify instances of profit and loss. Since the shop had not opened yet, the number of customers he would miss represented a loss for him (indicated by \\'Y\\'), while the opposite indicated profit (indicated by \\'N\\').\\n\\nFor the sake of clarity, I stored these values in an array starting at position 0. Subsequently, I iterated through each character, increasing the profit count for \\'Y\\' and the loss count for \\'N\\'.\\n\\nFinally, I traversed the final array to determine the maximum profit and the corresponding hour, returning its position.\\n\\nWe can solve this problem without storing it in an array by directly comparing the values. However, I opted for this approach to ensure beginners can understand it clearly.\\n\\nHappy learning! If you find this helpful, please consider upvoting :)\\n\\n```\\n    public int bestClosingTime(String customers) {\\n        int y=0, n=0;\\n        for(char ch: customers.toCharArray()){\\n            if(ch==\\'Y\\')\\n                y++;\\n            else\\n                n++;\\n        }\\n        int profit = n;\\n        int loss = y;\\n        int[] arr = new int[customers.length()+1];\\n        arr[0]=profit-loss;\\n        for(int i=1; i<=customers.length(); i++){\\n            char ch = customers.charAt(i-1);\\n            if(ch==\\'Y\\'){\\n                profit++;\\n            } else {\\n                loss++;\\n            }\\n            arr[i]=profit-loss;\\n        }\\n        int idx=0, max = Integer.MIN_VALUE;\\n        for(int i=0; i<=customers.length(); i++){\\n            if(arr[i]>max){\\n                max = arr[i];\\n                idx=i;\\n            }\\n        }\\n        return idx;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3974083,
                "title": "prefix-sum-is-the-saviour",
                "content": "# Intuition\\nIt\\'s a simple prefix sum logic problem.\\n\\n# Approach\\nStep-1:\\nJust consider that shop closes at 0th hour and calculate the total penalty that can be occured.\\nIf you found \\'Y\\' then you can add the penalty since the shop is closed at 0th hour itself, whenever a customer come penalty is added\\n\\nStep-2:\\nNow iterate through each hour and check where the penalty is minimum. \\nStore that minimum penalty hour and return that hour.\\nNow whenever you encounter a customer since we are trying to reduce the penalty we have a prefix sum continuously to check where it is gonna be minimum.\\nWhen we encounter \\'Y\\' we reduce the penalty else we increase the penalty again, because it is mentioned that if the shop is left open with no customer then the penalty also increases by \\'1\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int penalty = 0;\\n        int n = customers.length();\\n        for(int i=0;i<n;i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty++;\\n            }\\n        }\\n        int minPenalty = penalty;\\n        int closeTime = 0;\\n        for(int i=0;i<n;i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty--;\\n            }else{\\n                penalty++;\\n            }\\n            if(penalty<minPenalty){\\n                minPenalty = penalty;\\n                closeTime = i+1;\\n            }\\n        }\\n        return closeTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int penalty = 0;\\n        int n = customers.length();\\n        for(int i=0;i<n;i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty++;\\n            }\\n        }\\n        int minPenalty = penalty;\\n        int closeTime = 0;\\n        for(int i=0;i<n;i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty--;\\n            }else{\\n                penalty++;\\n            }\\n            if(penalty<minPenalty){\\n                minPenalty = penalty;\\n                closeTime = i+1;\\n            }\\n        }\\n        return closeTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850936,
                "title": "easy-to-read-efficient-js",
                "content": "Use balance counter to find peak days with customers then return that day + 1 as our closing day.\\n\\n# Code\\n```\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nvar bestClosingTime = function(customers) {\\n    let max = 0;\\n    let balance = 0;\\n    let answer = 0\\n    for(var i = 0;i < customers.length;i++){\\n        if(customers[i] === \"Y\"){\\n            balance++\\n        }\\n        else balance--\\n        if(balance > max){\\n            max = balance;\\n            answer = i + 1\\n        }\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nvar bestClosingTime = function(customers) {\\n    let max = 0;\\n    let balance = 0;\\n    let answer = 0\\n    for(var i = 0;i < customers.length;i++){\\n        if(customers[i] === \"Y\"){\\n            balance++\\n        }\\n        else balance--\\n        if(balance > max){\\n            max = balance;\\n            answer = i + 1\\n        }\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850783,
                "title": "python-explained-simple-easy-to-understand-o-n-time-o-1-space-prefix-sum",
                "content": "# Intuition\\n- \\'Y\\' affected the penalty after the closing time.\\n- Whereas \\'N\\' affected it before the closing time.\\n- Hence it is a **Prefix Sum** problem.\\n\\n# Approach\\n1. Calculated the sum of the string i.e. penalty if closed at 0th hour (if \\'Y\\' then +1 else 0).\\n2. We iterate the array and calculate the current penalty.\\n3. Curr Penalty = Prev Penalty (-1 if current element is \\'Y\\' else +1)\\n4. Then we compare the current penalty with the minimum penalty and change if needed, along with storing the index of the minimum penalty hour too.\\n5. Return minimum penalty index\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\ndef bestClosingTime(customers: str) -> int:\\n    penalty = 0\\n    for i in customers:\\n        penalty += 1 if i == \\'Y\\' else 0\\n\\n    minPenalty = penalty\\n    minPenIndex = 0\\n    for i in range(len(customers)):\\n        penalty += -1 if customers[i] == \\'Y\\' else 1\\n        if penalty < minPenalty:\\n            minPenalty = penalty\\n            minPenIndex = i + 1\\n\\n    return minPenIndex\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\ndef bestClosingTime(customers: str) -> int:\\n    penalty = 0\\n    for i in customers:\\n        penalty += 1 if i == \\'Y\\' else 0\\n\\n    minPenalty = penalty\\n    minPenIndex = 0\\n    for i in range(len(customers)):\\n        penalty += -1 if customers[i] == \\'Y\\' else 1\\n        if penalty < minPenalty:\\n            minPenalty = penalty\\n            minPenIndex = i + 1\\n\\n    return minPenIndex\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2850607,
                "title": "c-o-n-simple-traversal",
                "content": "1.  my intuition behind this problem was , that at any index the shop closes the penalty will be calculated as the sum of (no.N\\'s before that index + no. of Y\\'s from that index to the end). \\n2. using this logic we calculate the penalty at each index and check if the previous calculated penalty was bigger if it was we update it with the new one, and store the index at i.\\n3. once you are done with that there\\'s still a catch missing , if the shop closes at the very end , i mean after the array has ended at that point the penalty will be the number of N\\'s simply so compare it with that.\\n```\\n\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        int y =0;\\n        int n =0;\\n        for(int i =0;i<c.size();i++)\\n        {\\n            if(c[i]==\\'Y\\')\\n                y++;\\n            else\\n                n++;\\n        }\\n        // this stores the present number of y\\'s and n\\'s we have trversed till the ith index\\n        int newy=0;\\n        int newn=0;\\n        c[0]==\\'Y\\'?newy=1:newn=1;\\n        int pen=y;\\n        int ans=0;\\n        for(int i =1;i<c.size();i++)\\n        {\\n            int p = newn+(y-newy);\\n            if(p<pen)\\n            {\\n                pen=p;\\n                ans=i;\\n            }\\n            c[i]==\\'Y\\'?newy+=1:newn+=1;\\n        }\\n        if(n<pen)\\n        {\\n            ans=c.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nI persoanlly think that this has more approches to it. I\\'ll look into that and try adding it.\\nWish me luck tho.\\nThanks.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        int y =0;\\n        int n =0;\\n        for(int i =0;i<c.size();i++)\\n        {\\n            if(c[i]==\\'Y\\')\\n                y++;\\n            else\\n                n++;\\n        }\\n        // this stores the present number of y\\'s and n\\'s we have trversed till the ith index\\n        int newy=0;\\n        int newn=0;\\n        c[0]==\\'Y\\'?newy=1:newn=1;\\n        int pen=y;\\n        int ans=0;\\n        for(int i =1;i<c.size();i++)\\n        {\\n            int p = newn+(y-newy);\\n            if(p<pen)\\n            {\\n                pen=p;\\n                ans=i;\\n            }\\n            c[i]==\\'Y\\'?newy+=1:newn+=1;\\n        }\\n        if(n<pen)\\n        {\\n            ans=c.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850572,
                "title": "prefix-suffix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) \\n    {\\n        int n = customers.size();\\n        vector<vector<int>>pre(n, vector<int>(2, 0));\\n        pre[0][0] = (customers[0] == \\'N\\')? 1 : 0;\\n        pre[0][1] = (customers[0] == \\'Y\\')? 1 : 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            pre[i][0] = (customers[i] == \\'N\\'? 1 : 0) + pre[i - 1][0];\\n            pre[i][1] = (customers[i] == \\'Y\\'? 1 : 0) + pre[i - 1][1];\\n        }\\n        //================================================\\n        vector<vector<int>>post(n, vector<int>(2, 0));\\n        post[n - 1][0] = (customers[n - 1] == \\'N\\')? 1 : 0;\\n        post[n - 1][1] = (customers[n - 1] == \\'Y\\')? 1 : 0;\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            post[i][0] = (customers[i] == \\'N\\'? 1 : 0) + post[i + 1][0];\\n            post[i][1] = (customers[i] == \\'Y\\'? 1 : 0) + post[i + 1][1];\\n        }\\n        //=====================================================\\n        int mnPenalty = n, ans = -1;\\n        for (int i = 0; i <= n; i++)\\n        {\\n            int prevPenalty = (i - 1 < 0)? 0 : pre[i - 1][0];\\n            int nextPenalty = (i == n)? 0 : post[i][1];\\n            int penalty = prevPenalty + nextPenalty;\\n            if (penalty < mnPenalty)\\n            {\\n                ans = i;\\n                mnPenalty = penalty;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) \\n    {\\n        int n = customers.size();\\n        vector<vector<int>>pre(n, vector<int>(2, 0));\\n        pre[0][0] = (customers[0] == \\'N\\')? 1 : 0;\\n        pre[0][1] = (customers[0] == \\'Y\\')? 1 : 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            pre[i][0] = (customers[i] == \\'N\\'? 1 : 0) + pre[i - 1][0];\\n            pre[i][1] = (customers[i] == \\'Y\\'? 1 : 0) + pre[i - 1][1];\\n        }\\n        //================================================\\n        vector<vector<int>>post(n, vector<int>(2, 0));\\n        post[n - 1][0] = (customers[n - 1] == \\'N\\')? 1 : 0;\\n        post[n - 1][1] = (customers[n - 1] == \\'Y\\')? 1 : 0;\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            post[i][0] = (customers[i] == \\'N\\'? 1 : 0) + post[i + 1][0];\\n            post[i][1] = (customers[i] == \\'Y\\'? 1 : 0) + post[i + 1][1];\\n        }\\n        //=====================================================\\n        int mnPenalty = n, ans = -1;\\n        for (int i = 0; i <= n; i++)\\n        {\\n            int prevPenalty = (i - 1 < 0)? 0 : pre[i - 1][0];\\n            int nextPenalty = (i == n)? 0 : post[i][1];\\n            int penalty = prevPenalty + nextPenalty;\\n            if (penalty < mnPenalty)\\n            {\\n                ans = i;\\n                mnPenalty = penalty;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850566,
                "title": "easy-java-greedy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String s) {\\n        int n=s.length();\\n        int [] a1 = new int[n];\\n        int [] a2 = new int[n];\\n        char[] a3 = s.toCharArray();\\n        if(a3[0]==\\'N\\')\\n        {\\n            a2[0]++;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(a3[i]==\\'N\\')\\n            {\\n                a2[i]++;\\n            }\\n            a2[i]+=a2[i-1];\\n        }\\n        if(a3[n-1]==\\'Y\\')\\n        {\\n            a1[n-1]++;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(a3[i]==\\'Y\\')\\n            {\\n                a1[i]++;\\n            }\\n            a1[i]+=a1[i+1];\\n        }\\n        \\n        int m=10000000;\\n        int index=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int p = a1[i];\\n            int pr=0;\\n            if(i-1>=0)\\n            {\\n                pr = a2[i-1];\\n            }\\n            p+=pr;\\n            if(p<m)\\n            {\\n                m=p;\\n                index=i;\\n            }\\n        }\\n        return a2[n-1]<m ? n : index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String s) {\\n        int n=s.length();\\n        int [] a1 = new int[n];\\n        int [] a2 = new int[n];\\n        char[] a3 = s.toCharArray();\\n        if(a3[0]==\\'N\\')\\n        {\\n            a2[0]++;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(a3[i]==\\'N\\')\\n            {\\n                a2[i]++;\\n            }\\n            a2[i]+=a2[i-1];\\n        }\\n        if(a3[n-1]==\\'Y\\')\\n        {\\n            a1[n-1]++;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(a3[i]==\\'Y\\')\\n            {\\n                a1[i]++;\\n            }\\n            a1[i]+=a1[i+1];\\n        }\\n        \\n        int m=10000000;\\n        int index=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int p = a1[i];\\n            int pr=0;\\n            if(i-1>=0)\\n            {\\n                pr = a2[i-1];\\n            }\\n            p+=pr;\\n            if(p<m)\\n            {\\n                m=p;\\n                index=i;\\n            }\\n        }\\n        return a2[n-1]<m ? n : index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850477,
                "title": "cpp-prefix-sum-o-n",
                "content": "# Intuition\\nCalculate prefix sum of all `Y`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate prefix sum of all `Y`\\nAssume we shut the shop at `ith` index and take minimum of all\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int n = s.size();\\n        vector<int> ps(n+1);\\n        for(int i=1;i<=n;i++)ps[i]=ps[i-1]+(s[i-1]==\\'Y\\');\\n        int curr = n,ans = n;\\n        for(int i=0;i<=n;i++) {\\n            if(ps.back()-2*ps[i] + i < curr) {\\n                curr = ps.back()-2*ps[i] + i;\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int n = s.size();\\n        vector<int> ps(n+1);\\n        for(int i=1;i<=n;i++)ps[i]=ps[i-1]+(s[i-1]==\\'Y\\');\\n        int curr = n,ans = n;\\n        for(int i=0;i<=n;i++) {\\n            if(ps.back()-2*ps[i] + i < curr) {\\n                curr = ps.back()-2*ps[i] + i;\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850470,
                "title": "python-easy-to-read-o-n-prefix-sum",
                "content": "\\n    def bestClosingTime(self, customers: str) -> int:\\n        n = len(customers)\\n        nPrefSum, yPrefSum = [0]*(n+1) , [0]*(n+1)\\n        for i in range(n) :\\n            nPrefSum[i] = nPrefSum[i-1] + (customers[i] == \"N\")\\n            yPrefSum[n-i-1] = yPrefSum[n-i] + (customers[n-i-1] == \"Y\")\\n        \\n        penalty = float(\"inf\")\\n        res = float(\"inf\")\\n        for i in range(n,-1,-1) :\\n            currPenalty = yPrefSum[i] + nPrefSum[i-1]\\n            if currPenalty <= penalty :\\n                penalty = currPenalty\\n                res = i\\n        return res",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "\\n    def bestClosingTime(self, customers: str) -> int:\\n        n = len(customers)\\n        nPrefSum, yPrefSum = [0]*(n+1) , [0]*(n+1)\\n        for i in range(n) :\\n            nPrefSum[i] = nPrefSum[i-1] + (customers[i] == \"N\")\\n            yPrefSum[n-i-1] = yPrefSum[n-i] + (customers[n-i-1] == \"Y\")\\n        \\n        penalty = float(\"inf\")\\n        res = float(\"inf\")\\n        for i in range(n,-1,-1) :\\n            currPenalty = yPrefSum[i] + nPrefSum[i-1]\\n            if currPenalty <= penalty :\\n                penalty = currPenalty\\n                res = i\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 4022000,
                "title": "minimum-penalty-for-a-shop-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int penalty=0,curPenalty=0,ans=0;\\n        for(int i=0;i<customers.size();i++){\\n            char ch=customers[i];\\n            if(ch==\\'Y\\')curPenalty--;\\n            else curPenalty++;\\n            if(penalty>curPenalty){\\n                ans=i+1;\\n                penalty=curPenalty;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int penalty=0,curPenalty=0,ans=0;\\n        for(int i=0;i<customers.size();i++){\\n            char ch=customers[i];\\n            if(ch==\\'Y\\')curPenalty--;\\n            else curPenalty++;\\n            if(penalty>curPenalty){\\n                ans=i+1;\\n                penalty=curPenalty;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996753,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount two seide penalty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to count penalties at every moment of time. We count two side penalties: right and left. A right side penalty is a penalty for opening hours when there are no customers. A left side penalty is a penalty for non-working hours when there are customers. And at each point of time, we calculate the current penalty as the sum of the penalty on the left side and the penalty on the right side, and after that we compare this sum with the previous maximum penalty.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int left_penalty = 0, right_penalty = 0;\\n        int best_score = INT_MAX, ans;\\n\\n        for (auto &x: customers) {\\n            if (customers[&x - &customers[0]] == \\'Y\\')\\n                right_penalty++;\\n        }\\n\\n        for (auto &x: customers) {\\n            if (right_penalty + left_penalty < best_score) {\\n                best_score = right_penalty + left_penalty;\\n                ans = &x - &customers[0];\\n            }\\n\\n            if (x == \\'Y\\') {\\n                right_penalty--;\\n            } else {\\n                left_penalty++;\\n            }\\n        }\\n\\n        if (right_penalty + left_penalty < best_score) {\\n                best_score = right_penalty + left_penalty;\\n                ans = customers.size();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def bestClosingTime(self, customers):\\n        l_penalty = 0\\n        r_penalty = 0\\n        ans = 0\\n        best_score = sys.maxint\\n\\n        for ch in customers:\\n            if ch == \"Y\":\\n                r_penalty += 1\\n\\n        for i, x in enumerate(customers):\\n            print(l_penalty + r_penalty)\\n\\n            if l_penalty + r_penalty < best_score:\\n                best_score = l_penalty + r_penalty\\n                ans = i\\n\\n            if x == \"Y\":\\n                r_penalty -= 1\\n            else:\\n                l_penalty += 1\\n\\n        if l_penalty + r_penalty < best_score:\\n                best_score = l_penalty + r_penalty\\n                ans = len(customers)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int left_penalty = 0, right_penalty = 0;\\n        int best_score = INT_MAX, ans;\\n\\n        for (auto &x: customers) {\\n            if (customers[&x - &customers[0]] == \\'Y\\')\\n                right_penalty++;\\n        }\\n\\n        for (auto &x: customers) {\\n            if (right_penalty + left_penalty < best_score) {\\n                best_score = right_penalty + left_penalty;\\n                ans = &x - &customers[0];\\n            }\\n\\n            if (x == \\'Y\\') {\\n                right_penalty--;\\n            } else {\\n                left_penalty++;\\n            }\\n        }\\n\\n        if (right_penalty + left_penalty < best_score) {\\n                best_score = right_penalty + left_penalty;\\n                ans = customers.size();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass Solution(object):\\n    def bestClosingTime(self, customers):\\n        l_penalty = 0\\n        r_penalty = 0\\n        ans = 0\\n        best_score = sys.maxint\\n\\n        for ch in customers:\\n            if ch == \"Y\":\\n                r_penalty += 1\\n\\n        for i, x in enumerate(customers):\\n            print(l_penalty + r_penalty)\\n\\n            if l_penalty + r_penalty < best_score:\\n                best_score = l_penalty + r_penalty\\n                ans = i\\n\\n            if x == \"Y\":\\n                r_penalty -= 1\\n            else:\\n                l_penalty += 1\\n\\n        if l_penalty + r_penalty < best_score:\\n                best_score = l_penalty + r_penalty\\n                ans = len(customers)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977326,
                "title": "easy-approach-using-prefix-sum-and-suffix-sum",
                "content": "# Intuition\\nif i am clsoing the shop at ith hour what do i need to know--> penalty before ith hour if shop is open till 0 to (i-1) + penalty from ith hour to last hour if shop is closed at ith hour..that is---->open_pre[i-1]+close_suf[i];\\n\\n# Approach\\nprefix and suffix sum\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n \\n        int n=s.size();\\n        vector<int>open_pre(n+1,0);\\n       \\n       for(int i=1;i<n+1;i++)\\n       {\\n           if(s[i-1]==\\'N\\')//shop is open and no customer the increase the penalty\\n           {\\n               open_pre[i]=open_pre[i-1]+1;\\n           }\\n           else{\\n               open_pre[i]=open_pre[i-1];\\n           }\\n       }\\n      vector<int>close_suf(n+1,0);\\n          \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'Y\\')// shop is closed and there are customer than increase the penalty\\n            {\\n                close_suf[i]=close_suf[i+1]+1;\\n            }\\n            else{\\n                close_suf[i]=close_suf[i+1];\\n            }\\n        }\\n        int mn=INT_MAX;\\n        int ans;\\n        for(int i=0;i<n+1;i++)\\n        {\\n            if(i==0)\\n            {\\n              if(mn>close_suf[0])\\n                {\\n                    mn=close_suf[0];\\n                     ans=i;\\n                }\\n            }\\n            else if(i==n)\\n            {\\n                if(mn>open_pre[n])\\n                {\\n                    mn=open_pre[n];\\n                     ans=i;\\n                }\\n            }\\n            else{\\n                if(mn>open_pre[i-1]+close_suf[i])\\n                {\\n                    mn=open_pre[i-1]+close_suf[i];\\n                     ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n \\n        int n=s.size();\\n        vector<int>open_pre(n+1,0);\\n       \\n       for(int i=1;i<n+1;i++)\\n       {\\n           if(s[i-1]==\\'N\\')//shop is open and no customer the increase the penalty\\n           {\\n               open_pre[i]=open_pre[i-1]+1;\\n           }\\n           else{\\n               open_pre[i]=open_pre[i-1];\\n           }\\n       }\\n      vector<int>close_suf(n+1,0);\\n          \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'Y\\')// shop is closed and there are customer than increase the penalty\\n            {\\n                close_suf[i]=close_suf[i+1]+1;\\n            }\\n            else{\\n                close_suf[i]=close_suf[i+1];\\n            }\\n        }\\n        int mn=INT_MAX;\\n        int ans;\\n        for(int i=0;i<n+1;i++)\\n        {\\n            if(i==0)\\n            {\\n              if(mn>close_suf[0])\\n                {\\n                    mn=close_suf[0];\\n                     ans=i;\\n                }\\n            }\\n            else if(i==n)\\n            {\\n                if(mn>open_pre[n])\\n                {\\n                    mn=open_pre[n];\\n                     ans=i;\\n                }\\n            }\\n            else{\\n                if(mn>open_pre[i-1]+close_suf[i])\\n                {\\n                    mn=open_pre[i-1]+close_suf[i];\\n                     ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975872,
                "title": "c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string",
                "content": "\\n----------------------------------------------------------------------\\n# Let\\'s Connect on :- [LinkedIn](https://www.linkedin.com/in/mann-chandarana-115255230/)\\n----------------------------------------------------------------------\\n\\n# Intuition\\nAs we have to maintain the count of yes or no thatswhy we can maintain prefix sum array or prefix sum variable\\n\\n# Approach\\n1) Count the number of \\'N\\' because if the shop closes at nth hour the penalty will be number of \\'N\\', because until that time shop was opened and no customer came.\\n2) Then start from the last index and if \\'Y\\' comes increase the value of penalty, here because at that index the shop closes but at the same time customer came so increase the penalty.\\n3) And if \\'N\\' come decrease the value of count because at that index shop closes and there should be no penalty but in the first step we added the penalty of that index so we have to decrease the penalty by one.\\n4) Maintain the variable minimum and index to find the minimum penalty.\\n5) Please see the code for the better understanding.\\n\\n----------------------------------------------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n----------------------------------------------------------------------\\n\\n# Code\\n```\\nint bestClosingTime(string customers)\\n{\\n    int n = customers.size();\\n    int count = (customers.begin(), customers.end(), \\'N\\');\\n    int score = count, best_hour = n;\\n    int min_score = score;\\n\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n        score += customers[i] == \\'N\\' ? -1 : 1;\\n\\n        if (score <= min_score)\\n        {\\n            best_hour = i;\\n            min_score = score;\\n        }\\n    }\\n\\n    return best_hour;\\n}\\n```\\n----------------------------------------------------------------------\\n## REQUEST : If you found this post helpful, be kind enough to smash a upvote. I will be grateful.\\n\\n----------------------------------------------------------------------\\n![upvote.jpeg](https://assets.leetcode.com/users/images/c7f1451a-fd02-4140-8a44-f19e9615f37d_1693305786.6586564.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nint bestClosingTime(string customers)\\n{\\n    int n = customers.size();\\n    int count = (customers.begin(), customers.end(), \\'N\\');\\n    int score = count, best_hour = n;\\n    int min_score = score;\\n\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n        score += customers[i] == \\'N\\' ? -1 : 1;\\n\\n        if (score <= min_score)\\n        {\\n            best_hour = i;\\n            min_score = score;\\n        }\\n    }\\n\\n    return best_hour;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975383,
                "title": "python-easy-to-understand-30ms-fast-optimal-solution",
                "content": "# Python | Easy to Understand | <30ms | Fast | Optimal Solution\\n```\\nclass Solution:\\n    def bestClosingTime(self, cust: str) -> int:\\n        \\n        h = m = s = 0\\n        for i, ch in enumerate(cust):     \\n            s += (ch == \"Y\") * 2 - 1       \\n            if s > m:                       \\n                m, h = s, i+1               \\n        return h                            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bestClosingTime(self, cust: str) -> int:\\n        \\n        h = m = s = 0\\n        for i, ch in enumerate(cust):     \\n            s += (ch == \"Y\") * 2 - 1       \\n            if s > m:                       \\n                m, h = s, i+1               \\n        return h                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975364,
                "title": "c-30ms-fastest-easy-to-understand",
                "content": "# C++ | <30ms | Fastest | Easy to Understand\\n```\\nclass Solution {\\n\\tpublic:\\n\\t\\tint bestClosingTime(string a) {\\n\\t\\t\\tint s=a.size();\\n\\t\\t\\tvector<int> y,n;\\n\\t\\t\\ty.push_back(0);\\n\\t\\t\\tn.push_back(0);\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0;i<s;i++){\\n\\t\\t\\t\\tif(a[i]==\\'N\\')cnt++;\\n\\t\\t\\t\\tn.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\tcnt=0;\\n\\t\\t\\tfor(int i=s-1;i>=0;i--){\\n\\t\\t\\t\\tif(a[i]==\\'Y\\')cnt++;\\n\\t\\t\\t\\ty.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\treverse(y.begin(),y.end());\\n\\t\\t\\tint ans=INT_MAX,ind=0;\\n\\t\\t\\tfor(int i=0;i<s+1;i++){\\n\\t\\t\\t\\tint h=y[i]+n[i];\\n\\t\\t\\t\\tif(h<ans){\\n\\t\\t\\t\\t\\tans=h;\\n\\t\\t\\t\\t\\tind=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\n\\t\\t}\\n\\t};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\t\\tint bestClosingTime(string a) {\\n\\t\\t\\tint s=a.size();\\n\\t\\t\\tvector<int> y,n;\\n\\t\\t\\ty.push_back(0);\\n\\t\\t\\tn.push_back(0);\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0;i<s;i++){\\n\\t\\t\\t\\tif(a[i]==\\'N\\')cnt++;\\n\\t\\t\\t\\tn.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\tcnt=0;\\n\\t\\t\\tfor(int i=s-1;i>=0;i--){\\n\\t\\t\\t\\tif(a[i]==\\'Y\\')cnt++;\\n\\t\\t\\t\\ty.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\treverse(y.begin(),y.end());\\n\\t\\t\\tint ans=INT_MAX,ind=0;\\n\\t\\t\\tfor(int i=0;i<s+1;i++){\\n\\t\\t\\t\\tint h=y[i]+n[i];\\n\\t\\t\\t\\tif(h<ans){\\n\\t\\t\\t\\t\\tans=h;\\n\\t\\t\\t\\t\\tind=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975323,
                "title": "easy-to-understand-code-with-simple-explaination-for-the-daily-challenge",
                "content": "```\\n/*    \\n         penalty comes because of 2 reasons :-\\n        \\n         1) The shopkeeper remains idle for some h hours which increases penalty by h\\n         2) The number of customers that visited the shop after shop being closed\\n        \\n         Intuition:-\\n         \\n          -> Since the above two factors decide the penalty , we need to create 2 prefix array , one will tell the number of \\'N\\' from left including the present index and one will tell the number of \\'Y\\' to the right side of the present index;\\n          \\n*/\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        \\n        string s = \"#\" + customers;\\n        \\n        int n = s.length();\\n        \\n        vector<int> left(n,0);\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'N\\'){\\n                left[i] = left[i-1]+1;\\n            }\\n            else{\\n                left[i] = left[i-1];\\n            }\\n        }\\n        \\n        vector<int> right(n,0);\\n        \\n        if(s[n-1]==\\'Y\\'){\\n            right[s.length()-1] = 1;\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'Y\\'){\\n                right[i] = right[i+1]+1;\\n            }\\n            else{\\n                right[i] = right[i+1];\\n            }\\n        }\\n        \\n        \\n        vector<int> temp(n,0);\\n        \\n        for(int i=0;i<temp.size()-1;i++){\\n            temp[i] = left[i] + right[i+1];\\n        }\\n        \\n        temp[temp.size()-1] = left[temp.size()-1];\\n        \\n        \\n        int min_penalty = INT_MAX;\\n        \\n        int hour = -1;\\n        \\n        for(int i=0;i<temp.size();i++){\\n            \\n            if(temp[i]<min_penalty){\\n                min_penalty = temp[i];\\n                hour = i;\\n            }\\n        }\\n        \\n        return hour;\\n        \\n    }\\n};\\n```\\n\\nplease upvote if you like the solution",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n/*    \\n         penalty comes because of 2 reasons :-\\n        \\n         1) The shopkeeper remains idle for some h hours which increases penalty by h\\n         2) The number of customers that visited the shop after shop being closed\\n        \\n         Intuition:-\\n         \\n          -> Since the above two factors decide the penalty , we need to create 2 prefix array , one will tell the number of \\'N\\' from left including the present index and one will tell the number of \\'Y\\' to the right side of the present index;\\n          \\n*/\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        \\n        string s = \"#\" + customers;\\n        \\n        int n = s.length();\\n        \\n        vector<int> left(n,0);\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'N\\'){\\n                left[i] = left[i-1]+1;\\n            }\\n            else{\\n                left[i] = left[i-1];\\n            }\\n        }\\n        \\n        vector<int> right(n,0);\\n        \\n        if(s[n-1]==\\'Y\\'){\\n            right[s.length()-1] = 1;\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'Y\\'){\\n                right[i] = right[i+1]+1;\\n            }\\n            else{\\n                right[i] = right[i+1];\\n            }\\n        }\\n        \\n        \\n        vector<int> temp(n,0);\\n        \\n        for(int i=0;i<temp.size()-1;i++){\\n            temp[i] = left[i] + right[i+1];\\n        }\\n        \\n        temp[temp.size()-1] = left[temp.size()-1];\\n        \\n        \\n        int min_penalty = INT_MAX;\\n        \\n        int hour = -1;\\n        \\n        for(int i=0;i<temp.size();i++){\\n            \\n            if(temp[i]<min_penalty){\\n                min_penalty = temp[i];\\n                hour = i;\\n            }\\n        }\\n        \\n        return hour;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975315,
                "title": "4-line-java-o-n-time-o-1-space-not-a-typical-explanation",
                "content": "# To Be Positive Or Not To Be Positive: That is the question.\\nNew psychological studies show that it\\'s best to look at the full half of the glass.\\n\\nSo although the problem is focusing on the concept of `penalty`, \\xA0let\\'s be positive and focus on maximizing `score`: \\n\\nWe start from the beginning with a score of `0`. If customers come, we increase the `currentScore` for that hour and if they don\\'t come, we decrease it. \\n\\nWe also keep track of the `maximumScore` and `bestIndex`:\\n\\xA0if `currentScore` becomes more than `maximumScore`, we update the `maximumScore` and the `bestIndex` where the `maximumScore` was gained.\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Beats 99.71% but ...\\n\\nI know you are here to see the 4 liner. \\n\\n```    \\nint maxScore = 0;\\nint bestIndex = 0;\\nint currentScore = 0;\\nfor (int i = 0; i < customers.length(); ++i) {\\n  char customerShowedUp = customers.charAt(i);\\n  if (customerShowedUp == \\'Y\\') {\\n    ++currentScore;\\n  } else {\\n    --currentScore;\\n  }\\n  if (maxScore < currentScore) {\\n    maxScore = currentScore;\\n    bestIndex = i + 1;\\n  }\\n}\\nreturn bestIndex;\\n\\n```\\n\\nBut we have 16 lines. Since 4 * 4 = 16, we can say O(16) = O(4). So I proved that we could successfully have a 4 liner Java code.\\nJK, But before going further, there\\'s an important question that is exploding in your brain:\\n\\n# Question:\\n\\nThat\\'s crazy! Why do we assign `i + 1` for `bestIndex`? What\\'s wrong with putting `i`? It doesn\\'t make any f***ing sense!\\n\\n# Answer:\\n\\nGreat question! I\\'m happy that you asked. Based on the description we should: \"*Return the earliest hour at which the shop must be **CLOSED** to incur a minimum penalty.*\" \\n\\nWe should return the bestIndex to **close** the shop. If `maxScore` happens at index `i`,\\xA0it doesn\\'t make sense to close the store at `i` while we could make more money and who doesn\\'t like that? So we close the score at the next index.\\n\\n# As An Interviewer:\\n\\nI have worked in a few giant tech companies and have interviewed hundreds of candidates. This is the only serious thing I say: Code readability matters a lot! Don\\'t think that if you turn the above readable code into 4 lines you will definitely gain more points in the interview. But if you want to learn more about how we can cut a few more lines: \\n\\n# Give me the Scissors AKA Ternary Operator\\n\\nOK, let\\'s get down to business. First, we need to understand [What the f*** is Ternary Operator?](https://www.w3schools.com/java/java_conditions_shorthand.asp)\\n\\nThen we can turn\\n\\n```\\xA0 \\nif (customerShowedUp == \\'Y\\') {\\xA0\\n \\xA0 ++currentScore;\\xA0\\n} else {\\xA0 \\xA0\\n --currentScore;\\xA0 \\n}\\n```\\n\\ninto:\\n\\n```\\xA0 \\ncurrentScore = (customerShowedUp == \\'Y\\') ? currentScore + 1 : currentScore - 1;\\n```\\n\\nor we can use `+=` instead of `=`\\n\\n```\\xA0\\n currentScore += (customerShowedUp == \\'Y\\') ? 1 : \\xA0- 1;\\n```\\n\\n\\n# Darn it!\\n\\nBut how can we turn\\n```\\xA0 \\nif (maxScore < currentScore) {\\xA0 \\xA0 \\n  maxScore = currentScore;\\xA0 \\xA0 \\n  bestIndex = i + 1;\\xA0 \\n}\\n```\\n\\ninto a ternary operator? The ternary operator is good when we want to update one variable as it returns only one variable.\\n\\n# What\\'s wrong with an array?\\nThe trick is that that \"one\" variable, could be an array of size 3 which includes all 3 variables that we need. We call the array `mic`, because index 0 is our **m**axScore, index 1 is best**I**ndex, and index 2 is: **c**urrentScore. Let\\'s rewrite what we already have with our amazing array:\\n```\\nint[] mic = {0, 0, 0}; //maxScore , bestIndex, currentScore\\nfor (int i = 0; i < customers.length(); ++i) {\\n  char customerShowedUp = customers.charAt(i);\\n  mic[2] += (customerShowedUp == \\'Y\\') ? 1 : -1;\\n  if (mic[0] < mic[2]) {\\n    mic[0] = mic[2];\\n    mic[1] = i + 1;\\n  }\\n}\\nreturn mic[1];\\n```\\n\\n\\nSaving one more line by removing `customerShowedUp` :\\n\\n\\n```\\nint[] mic = {0, 0, 0}; //maxScore , bestIndex, currentScore\\nfor (int i = 0; i < customers.length(); ++i) {\\n  mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n  if (mic[0] < mic[2]) {\\n    mic[0] = mic[2];\\n    mic[1] = i + 1;\\n  }\\n}\\nreturn mic[1];\\n\\n```\\n\\n# \"Last Step\":\\nHow to trim this?\\n```\\xA0\\nif (mic[0] < mic[2]) {\\n  mic[0] = mic[2];\\n  mic[1] = i + 1;\\n}\\n```\\n\\nWe can update the `mic` if `mic[0] < mic[2]`, otherwise, we keep `mic` the way it is:\\n\\n```\\nmic = (mic[0] < mic[2]) ? new int[] {mic[2], i + 1, mic[2]} : mic;\\n\\n```\\n\\nSo we cut it down to 6 lines:\\n\\n```\\nint[] mic = {0, 0, 0}; //maxScore , bestIndex, currentScore\\nfor (int i = 0; i < customers.length(); ++i) {\\n    mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n    mic = (mic[0] < mic[2]) ? new int[]{mic[2], i + 1, mic[2]} : mic;\\n}\\nreturn mic[1];\\n\\n```\\n\\n# Sorry, this is really the Last Step:\\n\\n\\nNow in ` (mic[0] < mic[2]) `, we just need to replace `mic[2]` with the line above it: `mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1` which will make the whole line like a stupid line of random characters:\\n```\\nmic = (mic[0] < (mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1)) ? new int[] {mic[2], i + 1, mic[2]} : mic;\\n\\n```\\n# Complexity\\n\\n- Time complexity:\\n \\xA0O(n)\\n- Space complexity:\\xA0 \\n  O(1)\\n# Code\\n\\n```\\nint[] mic = {0, 0, 0};//maxScore, index, currentScore\\nfor (int i = 0; i < customers.length(); ++i)\\n  mic = (mic[0] < (mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1)) ? new int[]{mic[2], i + 1, mic[2]} : mic;\\nreturn mic[1];\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```    \\nint maxScore = 0;\\nint bestIndex = 0;\\nint currentScore = 0;\\nfor (int i = 0; i < customers.length(); ++i) {\\n  char customerShowedUp = customers.charAt(i);\\n  if (customerShowedUp == \\'Y\\') {\\n    ++currentScore;\\n  } else {\\n    --currentScore;\\n  }\\n  if (maxScore < currentScore) {\\n    maxScore = currentScore;\\n    bestIndex = i + 1;\\n  }\\n}\\nreturn bestIndex;\\n\\n```\n```\\xA0 \\nif (customerShowedUp == \\'Y\\') {\\xA0\\n \\xA0 ++currentScore;\\xA0\\n} else {\\xA0 \\xA0\\n --currentScore;\\xA0 \\n}\\n```\n```\\xA0 \\ncurrentScore = (customerShowedUp == \\'Y\\') ? currentScore + 1 : currentScore - 1;\\n```\n```\\xA0\\n currentScore += (customerShowedUp == \\'Y\\') ? 1 : \\xA0- 1;\\n```\n```\\xA0 \\nif (maxScore < currentScore) {\\xA0 \\xA0 \\n  maxScore = currentScore;\\xA0 \\xA0 \\n  bestIndex = i + 1;\\xA0 \\n}\\n```\n```\\nint[] mic = {0, 0, 0}; //maxScore , bestIndex, currentScore\\nfor (int i = 0; i < customers.length(); ++i) {\\n  char customerShowedUp = customers.charAt(i);\\n  mic[2] += (customerShowedUp == \\'Y\\') ? 1 : -1;\\n  if (mic[0] < mic[2]) {\\n    mic[0] = mic[2];\\n    mic[1] = i + 1;\\n  }\\n}\\nreturn mic[1];\\n```\n```\\nint[] mic = {0, 0, 0}; //maxScore , bestIndex, currentScore\\nfor (int i = 0; i < customers.length(); ++i) {\\n  mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n  if (mic[0] < mic[2]) {\\n    mic[0] = mic[2];\\n    mic[1] = i + 1;\\n  }\\n}\\nreturn mic[1];\\n\\n```\n```\\xA0\\nif (mic[0] < mic[2]) {\\n  mic[0] = mic[2];\\n  mic[1] = i + 1;\\n}\\n```\n```\\nmic = (mic[0] < mic[2]) ? new int[] {mic[2], i + 1, mic[2]} : mic;\\n\\n```\n```\\nint[] mic = {0, 0, 0}; //maxScore , bestIndex, currentScore\\nfor (int i = 0; i < customers.length(); ++i) {\\n    mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n    mic = (mic[0] < mic[2]) ? new int[]{mic[2], i + 1, mic[2]} : mic;\\n}\\nreturn mic[1];\\n\\n```\n```\\nmic = (mic[0] < (mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1)) ? new int[] {mic[2], i + 1, mic[2]} : mic;\\n\\n```\n```\\nint[] mic = {0, 0, 0};//maxScore, index, currentScore\\nfor (int i = 0; i < customers.length(); ++i)\\n  mic = (mic[0] < (mic[2] += (customers.charAt(i) == \\'Y\\') ? 1 : -1)) ? new int[]{mic[2], i + 1, mic[2]} : mic;\\nreturn mic[1];\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974811,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn the problem, we need to return the earliest hour at which the shop must be closed to incur a minimum penalty. So we iterate through the customer behaviors while calculating a \"penalty\" value for each customer. If the current penalty becomes less than the previous minimum penalty, the start time for the optimal closing is updated. We ultimately return the start time with the lowest penalty. We basically prioritize customers staying (\\'N\\') over leaving (\\'Y\\') and aim to find the closing time with the fewest penalties.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFollow the following steps:\\n- We loop through each customer behavior represented by the customers string.\\n\\n- - If the customer leaves (\\'Y\\'), decrement \\'curPenalty\\'; if they stay (\\'N\\'), increment \\'curPenalty\\'.\\n- Then we compare \\'penalty\\' with \\'curPenalty\\' to find the minimum penalty.\\n\\n- - If the current penalty (\\'curPenalty\\') becomes less than the previous minimum penalty (\\'penalty\\'), update start with the current index (i) and update \\'penalty\\' with \\'curPenalty\\'.\\n- After iterating through all customers, the start index will hold the optimal closing time with the minimum penalty.\\n\\n- Return the calculated start index as the result of the function.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int penalty=0,curPenalty=0,start=0;\\n        for(int i=0;i<customers.size();i++){\\n            char ch=customers[i];\\n            if(ch==\\'Y\\')curPenalty--;\\n            else curPenalty++;\\n            if(penalty>curPenalty){\\n                start=i+1;\\n                penalty=curPenalty;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int penalty=0,curPenalty=0,start=0;\\n        for(int i=0;i<customers.size();i++){\\n            char ch=customers[i];\\n            if(ch==\\'Y\\')curPenalty--;\\n            else curPenalty++;\\n            if(penalty>curPenalty){\\n                start=i+1;\\n                penalty=curPenalty;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974713,
                "title": "kotlin-linear-solution-that-beats-at-least-80-solutions",
                "content": "# Intuition\\nI will better consider maximum income for store\\'s open hours. And if there will not be a customer income will decrese for every hour.\\n\\n# Approach\\nFor every ``i-th`` hour that customer arrives, we will increase so-called `income`. And if the income is greater than previous maximum income then we will retake maximum income and store the minimum index `mi`.\\nFor every ``i-th`` hour that customer will not come, and if we were not closed the store then income will decrease.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun bestClosingTime(customers: String): Int {\\n        var income = 0\\n        var max = 0\\n        var mi = 0\\n        customers.forEachIndexed { i, c ->\\n            if (c==\\'Y\\') {\\n                income++\\n                if (income > max) {\\n                    max = income\\n                    mi = i+1\\n                }\\n            } else {\\n                income--\\n            }\\n        }\\n        return mi\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    fun bestClosingTime(customers: String): Int {\\n        var income = 0\\n        var max = 0\\n        var mi = 0\\n        customers.forEachIndexed { i, c ->\\n            if (c==\\'Y\\') {\\n                income++\\n                if (income > max) {\\n                    max = income\\n                    mi = i+1\\n                }\\n            } else {\\n                income--\\n            }\\n        }\\n        return mi\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974265,
                "title": "prefix-sum-solution-o-1-space-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We will try closing the shop at every hour between $[0, n]$. We will **calculate the penalty that can occur for every hour** and simply **choose the smallest hour with the minimum penalty.**\\n- We will iterate over the $customers$ string from left to right.\\n- If we choose to close the shop at hour $i$, the total penalty will be the number of `N\\'s` in the prefix $customers[0 ... i - 1]$ plus the number of `Y\\'s` in the suffix $customers[i ... n-1]$.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We initially count the total number of `Y\\'s` in the string.\\n- We keep a track of the number of `Y\\'s` we have seen so far while iterating. This enables us to calculate `leftN` and `rightY`. \\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n = len(customers)\\n\\n        totalY = customers.count(\\'Y\\')\\n        minPenalty = bestHour = n + 1\\n        prefixY = 0\\n\\n        for hour in range(n + 1):\\n            leftN = hour - prefixY\\n            rightY = totalY - prefixY\\n            curPenalty = leftN + rightY\\n\\n            if curPenalty < minPenalty:\\n                minPenalty = curPenalty\\n                bestHour = hour\\n\\n            if hour < n: \\n                prefixY += customers[hour] == \\'Y\\'\\n\\n        return bestHour\\n```\\n\\n#### Hope you have a great day! Do upvote the solution!",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n = len(customers)\\n\\n        totalY = customers.count(\\'Y\\')\\n        minPenalty = bestHour = n + 1\\n        prefixY = 0\\n\\n        for hour in range(n + 1):\\n            leftN = hour - prefixY\\n            rightY = totalY - prefixY\\n            curPenalty = leftN + rightY\\n\\n            if curPenalty < minPenalty:\\n                minPenalty = curPenalty\\n                bestHour = hour\\n\\n            if hour < n: \\n                prefixY += customers[hour] == \\'Y\\'\\n\\n        return bestHour\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974235,
                "title": "c-java-easy-detailed-solution-o-n",
                "content": "# Intuition\\n In this question there we can get penalty only from two reasons\\n - For every hour when the shop is open and no customers come\\n - For every hour when the shop is closed and customers come\\n  \\nso to count the penalty of ith hour we will consider two things :\\n - how many hours no customer come i.e,the count of \\'N\\' till (i-1)th hour\\n - how many hours the customer came but the shop was closed i.e, count of \\'Y\\' from jth index to last element\\n\\nNow we will return minimum indexed penalty element from the string.\\n\\n# Approach\\n  - Count the number of Y in the string \\n  - for every iteration of the string \\n         if character is Y decrease total count of yes by 1.\\n         if character is N increase count of no by 1\\n - return the index of element with least index and minimum penalty.\\n\\n# Complexity\\n- Time complexity\\n  O(N)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n      int p =0; \\n      for(int i=0;i<c.size();i++){\\n             if(c[i]==\\'Y\\')p++;\\n      }\\n      int no=0;\\n      int ans =p;\\n      int in =0;\\n      for(int i=0;i<c.size();i++){\\n          if(c[i]==\\'Y\\'){\\n           p--;\\n          }else{\\n            no++;\\n          }\\n          if(ans>no+p){\\n            in = i+1;\\n            ans =no+p;\\n          }\\n         \\n      }\\n       \\n      return in;\\n\\n\\n    }\\n};\\n```\\n\\n# JAVA CODE\\n```\\nclass Solution {\\n    public int bestClosingTime(String c) {\\n         int p =0; \\n      for(int i=0;i<c.length();i++){\\n             if(c.charAt(i)==\\'Y\\')p++;\\n      }\\n      int no=0;\\n      int ans =p;\\n      int in =0;\\n      for(int i=0;i<c.length();i++){\\n          if(c.charAt(i)==\\'Y\\'){\\n           p--;\\n          }else{\\n            no++;\\n          }\\n          if(ans>no+p){\\n            in = i+1;\\n            ans =no+p;\\n          }\\n         \\n      }\\n       \\n      return in;\\n\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n      int p =0; \\n      for(int i=0;i<c.size();i++){\\n             if(c[i]==\\'Y\\')p++;\\n      }\\n      int no=0;\\n      int ans =p;\\n      int in =0;\\n      for(int i=0;i<c.size();i++){\\n          if(c[i]==\\'Y\\'){\\n           p--;\\n          }else{\\n            no++;\\n          }\\n          if(ans>no+p){\\n            in = i+1;\\n            ans =no+p;\\n          }\\n         \\n      }\\n       \\n      return in;\\n\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int bestClosingTime(String c) {\\n         int p =0; \\n      for(int i=0;i<c.length();i++){\\n             if(c.charAt(i)==\\'Y\\')p++;\\n      }\\n      int no=0;\\n      int ans =p;\\n      int in =0;\\n      for(int i=0;i<c.length();i++){\\n          if(c.charAt(i)==\\'Y\\'){\\n           p--;\\n          }else{\\n            no++;\\n          }\\n          if(ans>no+p){\\n            in = i+1;\\n            ans =no+p;\\n          }\\n         \\n      }\\n       \\n      return in;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974162,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, aproach, and complexity dicussed in detail in video solution\\nhttps://youtu.be/rpu6GvyWkC8\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int sz = customers.size();\\n\\n        int nTotal = count(customers.begin(), customers.end(), \\'N\\');\\n        int yTotal = count(customers.begin(), customers.end(), \\'Y\\');\\n       \\n        if(nTotal == 0)return sz;\\n\\n        int nCnt = 0, yCnt = 0, minPen = INT_MAX, minClose = INT_MAX;\\n       \\n        for(int indx = 0; indx < sz; indx++){\\n            int pen = nCnt + (yTotal - yCnt);\\n            if(pen < minPen){\\n                minPen = pen;\\n                minClose = indx;\\n            }\\n            if(customers[indx] == \\'Y\\')yCnt++;\\n            else nCnt++;\\n        }\\n   \\n        int pen = nCnt;\\n        if(pen  < minPen){\\n            minPen = pen;\\n            minClose = sz;\\n        }\\n\\n        return minClose;        \\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int sz = customers.length();\\n        int nTotal = 0, yTotal = 0;\\n        for(var c : customers.toCharArray()){\\n            if(c == \\'Y\\')yTotal++;\\n            else nTotal++;\\n        }\\n        if(nTotal == 0)return sz;\\n        int nCnt = 0, yCnt = 0, minPen = Integer.MAX_VALUE, minClose = Integer.MAX_VALUE;\\n        for(int indx = 0; indx < sz; indx++){\\n            int pen = nCnt + (yTotal - yCnt);\\n            if(pen < minPen){\\n                minPen = pen;\\n                minClose = indx;\\n            }\\n            if(customers.charAt(indx) == \\'Y\\')yCnt++;\\n            else nCnt++;\\n        }\\n        int pen = nCnt;\\n        if(pen  < minPen){\\n            minPen = pen;\\n            minClose = sz;\\n        }\\n        return minClose;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int sz = customers.size();\\n\\n        int nTotal = count(customers.begin(), customers.end(), \\'N\\');\\n        int yTotal = count(customers.begin(), customers.end(), \\'Y\\');\\n       \\n        if(nTotal == 0)return sz;\\n\\n        int nCnt = 0, yCnt = 0, minPen = INT_MAX, minClose = INT_MAX;\\n       \\n        for(int indx = 0; indx < sz; indx++){\\n            int pen = nCnt + (yTotal - yCnt);\\n            if(pen < minPen){\\n                minPen = pen;\\n                minClose = indx;\\n            }\\n            if(customers[indx] == \\'Y\\')yCnt++;\\n            else nCnt++;\\n        }\\n   \\n        int pen = nCnt;\\n        if(pen  < minPen){\\n            minPen = pen;\\n            minClose = sz;\\n        }\\n\\n        return minClose;        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int sz = customers.length();\\n        int nTotal = 0, yTotal = 0;\\n        for(var c : customers.toCharArray()){\\n            if(c == \\'Y\\')yTotal++;\\n            else nTotal++;\\n        }\\n        if(nTotal == 0)return sz;\\n        int nCnt = 0, yCnt = 0, minPen = Integer.MAX_VALUE, minClose = Integer.MAX_VALUE;\\n        for(int indx = 0; indx < sz; indx++){\\n            int pen = nCnt + (yTotal - yCnt);\\n            if(pen < minPen){\\n                minPen = pen;\\n                minClose = indx;\\n            }\\n            if(customers.charAt(indx) == \\'Y\\')yCnt++;\\n            else nCnt++;\\n        }\\n        int pen = nCnt;\\n        if(pen  < minPen){\\n            minPen = pen;\\n            minClose = sz;\\n        }\\n        return minClose;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974040,
                "title": "2-best-c-solutions-with-explanation-one-pass-solution-beats-100",
                "content": "# Code\\n```\\n// Two for loop\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int total = 0;\\n        // first calculate total penalty if shop closes at 0th hour\\n        for(int i=0; i<customers.length(); i++){\\n            if(customers[i] == \\'Y\\')\\n                total++;\\n        }\\n        int res = total, ans = 0;\\n        // Then for each hour, check if customers come or not\\n        // If we close the shop at that hour and check if penalty is minimum\\n        for(int i=0; i<customers.length(); i++){\\n            if(customers[i] == \\'Y\\')\\n                total -= 1;\\n            else\\n                total += 1;\\n            if(res > total){\\n                ans = i+1;\\n                res = total;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// One pass - Single for loop\\n// The index at where the profit is highest, the answer should be index+1\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int index = -1, ans = 0, total = 0;\\n        for(int i=0; i<customers.length(); i++){\\n            if(customers[i] == \\'Y\\') \\n                total++;\\n            else \\n                total--;\\n            if(total > ans){\\n                ans = total;\\n                index = i;\\n            }\\n        }\\n        return index + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n// Two for loop\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int total = 0;\\n        // first calculate total penalty if shop closes at 0th hour\\n        for(int i=0; i<customers.length(); i++){\\n            if(customers[i] == \\'Y\\')\\n                total++;\\n        }\\n        int res = total, ans = 0;\\n        // Then for each hour, check if customers come or not\\n        // If we close the shop at that hour and check if penalty is minimum\\n        for(int i=0; i<customers.length(); i++){\\n            if(customers[i] == \\'Y\\')\\n                total -= 1;\\n            else\\n                total += 1;\\n            if(res > total){\\n                ans = i+1;\\n                res = total;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// One pass - Single for loop\\n// The index at where the profit is highest, the answer should be index+1\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int index = -1, ans = 0, total = 0;\\n        for(int i=0; i<customers.length(); i++){\\n            if(customers[i] == \\'Y\\') \\n                total++;\\n            else \\n                total--;\\n            if(total > ans){\\n                ans = total;\\n                index = i;\\n            }\\n        }\\n        return index + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973991,
                "title": "beats-99-o-n-approach-explained-greedy",
                "content": "# Approach\\nThe main logic of this code is to determine the best time to close a shop among a sequence of customers in order to minimize the total penalty. The penalty is calculated based on the number of customers who want the shop to remain open (\\'Y\\') and the number of customers who don\\'t (\\'N\\').\\n\\n\\n1. **Count Initial \\'Yes\\' Customers:** Count the initial number of customers who want the shop to remain open (\\'Y\\'). This count is stored in the variable `yes`.\\n\\n2. **Initialization:** Three key variables are initialized:\\n   - `ans`: This will store the best time (position) to close the shop.\\n   - `penalty`: This represents the current total penalty. It is initially set to the number of customers who want the shop to remain open (`yes`).\\n   - `no`: This counts the number of customers who want the shop to close (\\'N\\').\\n\\n3. **Loop Through Customers:** The code then iterates through each customer in the sequence.\\n   - If the customer is \\'N\\' (wants the shop to close), the `no` count is incremented.\\n   - If the customer is \\'Y\\' (wants the shop to remain open), the `yes` count is decremented since the shop is going to close.\\n   \\n4. **Calculate Current Penalty:** For each iteration, the current penalty is calculated as the sum of remaining \\'yes\\' customers (those who haven\\'t been served yet) and the \\'no\\' customers (those who want the shop to close).\\n\\n5. **Update Best Time and Penalty:** If the current penalty is lower than the stored `penalty`, it means that closing the shop at this position could lead to a lower total penalty. In this case, the `ans` variable is updated with the current position `i+1`, and the `penalty` is updated with the current penalty value.\\n\\n6. **Return Best Time:** After looping through all customers, the method returns the value of `ans`, which indicates the best time (position) to close the shop in order to minimize the total penalty.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int yes =0;\\n        int n = customers.size();\\n\\n        for (int i=0; i<n; i++){\\n            if (customers[i] == \\'Y\\')  yes++;\\n        }\\n\\n        int ans= 0; int penalty = yes; int no=0;\\n        for (int i=0; i<n; i++){\\n            if (customers[i] == \\'N\\')  no++;\\n            else yes--;\\n\\n            int curr_penalty = yes + no;\\n\\n            if (curr_penalty < penalty){\\n                ans = i+1;\\n                penalty = curr_penalty;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int yes =0;\\n        int n = customers.size();\\n\\n        for (int i=0; i<n; i++){\\n            if (customers[i] == \\'Y\\')  yes++;\\n        }\\n\\n        int ans= 0; int penalty = yes; int no=0;\\n        for (int i=0; i<n; i++){\\n            if (customers[i] == \\'N\\')  no++;\\n            else yes--;\\n\\n            int curr_penalty = yes + no;\\n\\n            if (curr_penalty < penalty){\\n                ans = i+1;\\n                penalty = curr_penalty;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973813,
                "title": "c-intuition-explained-o-n-faster-than-95-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        // Intution\\n        // Maintaining two vectors one to count the number of N before and the other to count the number of Y at current and the next positions. After finding out these then we will at the current index check if the shop can be closed or not. i.e, if a shop can be closed then we the total penality will be the sum of both the values at the current index of both the vectors. Then, we will check if the current value is lesser than the previous value or not. If the current value is lesser then we will change the index.\\n        int n = customers.size();\\n        vector<int> Y(n + 1, 0);\\n        vector<int> N(n + 1, 0);\\n        int countN = 0;\\n        for(int i = 0 ; i <= n ; i++){\\n            N[i] = countN;\\n            if(i < n) countN += (customers[i] == \\'N\\');\\n        }\\n        int countY = 0;\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            countY += (customers[i] == \\'Y\\');\\n            Y[i] = countY;\\n        }\\n        int index  = -1;\\n        int minVal = INT_MAX;\\n        for(int i = 0 ; i <= n ; i++){\\n            if(Y[i] + N[i] < minVal){\\n                minVal = Y[i] + N[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        // Intution\\n        // Maintaining two vectors one to count the number of N before and the other to count the number of Y at current and the next positions. After finding out these then we will at the current index check if the shop can be closed or not. i.e, if a shop can be closed then we the total penality will be the sum of both the values at the current index of both the vectors. Then, we will check if the current value is lesser than the previous value or not. If the current value is lesser then we will change the index.\\n        int n = customers.size();\\n        vector<int> Y(n + 1, 0);\\n        vector<int> N(n + 1, 0);\\n        int countN = 0;\\n        for(int i = 0 ; i <= n ; i++){\\n            N[i] = countN;\\n            if(i < n) countN += (customers[i] == \\'N\\');\\n        }\\n        int countY = 0;\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            countY += (customers[i] == \\'Y\\');\\n            Y[i] = countY;\\n        }\\n        int index  = -1;\\n        int minVal = INT_MAX;\\n        for(int i = 0 ; i <= n ; i++){\\n            if(Y[i] + N[i] < minVal){\\n                minVal = Y[i] + N[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254666,
                "title": "one-pass-prefix-n-count-suffix-y-count-c-time-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int n = s.length(),i;\\n        vector<int> y(n+1,0),x(n+1,0);\\n        for(i = 1; i <= n; i++){\\n            if(s[i-1]==\\'N\\'){\\n                x[i] += x[i-1]+1;\\n            }else{\\n                x[i] = x[i-1];\\n            }\\n            if(s[n-i]==\\'Y\\'){\\n                y[n-i] += y[n-i+1]+1;\\n            }else{\\n                y[n-i] = y[n-i+1];\\n            }\\n        }\\n        int ans = INT_MAX,k;\\n        for(i = 0; i <= n; i++){\\n            if(y[i]+x[i]<ans){\\n                ans = y[i]+x[i];\\n                k = i;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int n = s.length(),i;\\n        vector<int> y(n+1,0),x(n+1,0);\\n        for(i = 1; i <= n; i++){\\n            if(s[i-1]==\\'N\\'){\\n                x[i] += x[i-1]+1;\\n            }else{\\n                x[i] = x[i-1];\\n            }\\n            if(s[n-i]==\\'Y\\'){\\n                y[n-i] += y[n-i+1]+1;\\n            }else{\\n                y[n-i] = y[n-i+1];\\n            }\\n        }\\n        int ans = INT_MAX,k;\\n        for(i = 0; i <= n; i++){\\n            if(y[i]+x[i]<ans){\\n                ans = y[i]+x[i];\\n                k = i;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890737,
                "title": "easy-ans-simple-c-solution-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust count total number of \\'no\\' before closing time and total number of \\'yes\\' after it. Wherever this value is minimum that is the best closing time..\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int yes=0;\\n        int n= customers.size();\\n        for (int i=0; i<n; i++){\\n            if (customers[i]==\\'Y\\')yes++;\\n        }\\n        int ans= 0; int pen= yes; int no=0;\\n        for (int i=0; i<n; i++){\\n            if (customers[i]==\\'N\\'){\\n                no++;\\n            }\\n            else yes--;\\n            int curr_pen= yes + no;\\n            if (curr_pen<pen){\\n                ans= i+1;\\n                pen= curr_pen;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int yes=0;\\n        int n= customers.size();\\n        for (int i=0; i<n; i++){\\n            if (customers[i]==\\'Y\\')yes++;\\n        }\\n        int ans= 0; int pen= yes; int no=0;\\n        for (int i=0; i<n; i++){\\n            if (customers[i]==\\'N\\'){\\n                no++;\\n            }\\n            else yes--;\\n            int curr_pen= yes + no;\\n            if (curr_pen<pen){\\n                ans= i+1;\\n                pen= curr_pen;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852465,
                "title": "java-solution-faster-than-100-o-n-time-o-1-space",
                "content": "```java \\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int max=0;\\n        int c=0;\\n        int maxi=-1;\\n        for(int i=0;i<customers.length();i++)\\n        {\\n            if(customers.charAt(i)==\\'Y\\')\\n                c++;\\n            else\\n                c--;\\n            if(max<c){\\n                max=c;\\n                maxi=i;\\n            }\\n        }\\n        return maxi+1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int bestClosingTime(String customers) {\\n        int max=0;\\n        int c=0;\\n        int maxi=-1;\\n        for(int i=0;i<customers.length();i++)\\n        {\\n            if(customers.charAt(i)==\\'Y\\')\\n                c++;\\n            else\\n                c--;\\n            if(max<c){\\n                max=c;\\n                maxi=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2851016,
                "title": "o-1-space-o-n-time-c-easy-solution",
                "content": "For ith hour, penalty will be, number of y after ith hour + number of n before ith hour\\nInitially, penalty will be number of y total.\\nCode - \\n```class Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int y = 0,n = 0;\\n        for(int i = 0;i < s.length();i++){\\n            if(s[i] == \\'Y\\')\\n                y++;\\n        }\\n        int mini = y,ans = 0;\\n        for(int i = 0;i < s.length();i++){\\n            if(s[i] == \\'Y\\')\\n                y--;\\n            else \\n                n++;\\n            if(y + n < mini)\\n                ans = i+1, mini = y + n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```class Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int y = 0,n = 0;\\n        for(int i = 0;i < s.length();i++){\\n            if(s[i] == \\'Y\\')\\n                y++;\\n        }\\n        int mini = y,ans = 0;\\n        for(int i = 0;i < s.length();i++){\\n            if(s[i] == \\'Y\\')\\n                y--;\\n            else \\n                n++;\\n            if(y + n < mini)\\n                ans = i+1, mini = y + n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850968,
                "title": "easy-c-solution-with-prefix-sum-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First make prefix sum array for both count of \\'Y\\' and count of \\'N\\'\\n-Keep 0 at index 0 of both of the array as at 0th hour shop is closed so no customer has visited at that time\\n2) Then calculate the penalty for each index or time and keep maintaining the minimum penalty index\\n\\npenalty = Totalcustomers - customers till that hour + number of case till that hour where no customer has visited the shop\\n\\n3)Return your minimum index\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int y[customers.length()+1];\\n        int n[customers.length()+1];\\n        y[0]=0;\\n        n[0]=0;\\n        int ytill{0};\\n        int ntill{0};\\n        \\n        for(int i{0};i<customers.length();i++){\\n            if(customers[i]==\\'Y\\'){\\n                ytill++;\\n            }else{\\n                ntill++;\\n            }\\n            y[i+1]=ytill;\\n            n[i+1]=ntill;\\n        }\\n        \\n        int ind{0};\\n        for(int i{1};i<customers.length()+1;i++){\\n            //calculate penalty\\n            //Penalty = ytill - y[i] + n[i]\\n            if(ytill-y[ind]+n[ind]>ytill-y[i]+n[i]){\\n                ind=i;\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int y[customers.length()+1];\\n        int n[customers.length()+1];\\n        y[0]=0;\\n        n[0]=0;\\n        int ytill{0};\\n        int ntill{0};\\n        \\n        for(int i{0};i<customers.length();i++){\\n            if(customers[i]==\\'Y\\'){\\n                ytill++;\\n            }else{\\n                ntill++;\\n            }\\n            y[i+1]=ytill;\\n            n[i+1]=ntill;\\n        }\\n        \\n        int ind{0};\\n        for(int i{1};i<customers.length()+1;i++){\\n            //calculate penalty\\n            //Penalty = ytill - y[i] + n[i]\\n            if(ytill-y[ind]+n[ind]>ytill-y[i]+n[i]){\\n                ind=i;\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850860,
                "title": "python3-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        ans=0\\n        cnt=least=customers.count(\\'Y\\')\\n        for i ,j in enumerate(customers):\\n            if j==\\'N\\':\\n                cnt+=1\\n\\n            else:\\n                cnt-=1\\n\\n            if cnt<least:\\n                ans=i+1\\n                least=cnt\\n\\n        return ans        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        ans=0\\n        cnt=least=customers.count(\\'Y\\')\\n        for i ,j in enumerate(customers):\\n            if j==\\'N\\':\\n                cnt+=1\\n\\n            else:\\n                cnt-=1\\n\\n            if cnt<least:\\n                ans=i+1\\n                least=cnt\\n\\n        return ans        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850596,
                "title": "c-easy-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n\\n        int n=customers.size()+1;\\n        \\n        int res=0,temp=INT_MAX;\\n        \\n        vector<int>no(n+1,0),yes(n+1,0);\\n        \\n        for(int i=1;i<=customers.size();i++){\\n            \\n            if(customers[i-1]==\\'N\\'){\\n                no[i]=no[i-1]+1;\\n            }\\n            else no[i]=no[i-1];\\n            \\n            if(customers[n-i-1]==\\'Y\\'){\\n                yes[n-i-1]=yes[n-i]+1;\\n            }\\n            else yes[n-i-1]=yes[n-i];\\n                \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int t=yes[i]+no[i];\\n            if(t<temp){\\n                temp=t;\\n                res=i;\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n\\n        int n=customers.size()+1;\\n        \\n        int res=0,temp=INT_MAX;\\n        \\n        vector<int>no(n+1,0),yes(n+1,0);\\n        \\n        for(int i=1;i<=customers.size();i++){\\n            \\n            if(customers[i-1]==\\'N\\'){\\n                no[i]=no[i-1]+1;\\n            }\\n            else no[i]=no[i-1];\\n            \\n            if(customers[n-i-1]==\\'Y\\'){\\n                yes[n-i-1]=yes[n-i]+1;\\n            }\\n            else yes[n-i-1]=yes[n-i];\\n                \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int t=yes[i]+no[i];\\n            if(t<temp){\\n                temp=t;\\n                res=i;\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850558,
                "title": "2483-minimum-penalty-for-a-shop-java",
                "content": "```\\n\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        \\n        int n = customers.length();\\n        int [] arr1 = new int[n];\\n        int [] arr2 = new int[n];\\n        char[]ca = customers.toCharArray();\\n        \\n        if(ca[0]==\\'N\\')\\n            arr2[0]++;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(ca[i]==\\'N\\')arr2[i]++;arr2[i]+=arr2[i-1];\\n        }\\n        \\n        if(ca[n-1]==\\'Y\\')arr1[n-1]++;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n             if(ca[i]==\\'Y\\')arr1[i]++;arr1[i]+=arr1[i+1];\\n        }\\n        \\n        int marks = 10000000;\\n        int ind = -1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr = arr1[i];int prev = 0;\\n            if(i-1>=0)prev = arr2[i-1];curr +=prev;\\n            if(curr<marks)\\n            {\\n                marks = curr;\\n                ind = i;\\n            }\\n        }\\n\\n        int lastt = arr2[n-1];\\n        if(lastt<marks)return n;\\n        return ind;\\n        \\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        \\n        int n = customers.length();\\n        int [] arr1 = new int[n];\\n        int [] arr2 = new int[n];\\n        char[]ca = customers.toCharArray();\\n        \\n        if(ca[0]==\\'N\\')\\n            arr2[0]++;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(ca[i]==\\'N\\')arr2[i]++;arr2[i]+=arr2[i-1];\\n        }\\n        \\n        if(ca[n-1]==\\'Y\\')arr1[n-1]++;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n             if(ca[i]==\\'Y\\')arr1[i]++;arr1[i]+=arr1[i+1];\\n        }\\n        \\n        int marks = 10000000;\\n        int ind = -1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr = arr1[i];int prev = 0;\\n            if(i-1>=0)prev = arr2[i-1];curr +=prev;\\n            if(curr<marks)\\n            {\\n                marks = curr;\\n                ind = i;\\n            }\\n        }\\n\\n        int lastt = arr2[n-1];\\n        if(lastt<marks)return n;\\n        return ind;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991525,
                "title": "c-solution-for-minimum-penalty-for-a-shop-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to iterate through the hours one by one, tracking the penalty incurred if the shop is closed at each hour. The goal is to find the earliest hour at which the shop should be closed to minimize the penalty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.\\tInitialize curPenalty to keep track of the current penalty, starting with the total number of \\u2018Y\\u2019 (customers) in the input string.\\n2.\\tInitialize minPenalty to store the minimum penalty encountered, initially set to the current penalty.\\n3.\\tInitialize earliestHour to store the hour at which the shop should be closed to incur the minimum penalty, initially set to 0.\\n4.\\tIterate through the input string, updating curPenalty based on whether a customer (\\u2018Y\\u2019) arrives or not (\\u2018N\\u2019).\\n5.\\tAfter each update of curPenalty, check if it is smaller than minPenalty. If it is, update minPenalty and earliestHour.\\n6.\\tContinue this process for all hours, and the value stored in earliestHour at the end will be the optimal closing time to minimize the penalty.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the length of the input string customers. This is because we iterate through the string once to calculate the penalty.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because we only use a constant amount of extra space to store variables like curPenalty, minPenalty, and earliestHour, regardless of the input size.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BestClosingTime(string customers) {\\n        int curPenalty = 0;\\n        int n = customers.Length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (customers[i] == \\'Y\\') {\\n                curPenalty++;\\n            }\\n        }\\n\\n        // Start with closing at hour 0, the penalty equals all \\'Y\\' in closed hours.\\n        int minPenalty = curPenalty;\\n        int earliestHour = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            char ch = customers[i];\\n\\n            // If the status in hour i is \\'Y\\', moving it to open hours decrements\\n            // the penalty by 1. Otherwise, moving \\'N\\' to open hours increments\\n            // the penalty by 1.\\n            if (ch == \\'Y\\') {\\n                curPenalty--;\\n            } else {\\n                curPenalty++;\\n            }\\n\\n            // Update earliestHour if a smaller penalty is encountered.\\n            if (curPenalty < minPenalty) {\\n                earliestHour = i + 1;\\n                minPenalty = curPenalty;\\n            }\\n        }\\n\\n        return earliestHour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BestClosingTime(string customers) {\\n        int curPenalty = 0;\\n        int n = customers.Length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (customers[i] == \\'Y\\') {\\n                curPenalty++;\\n            }\\n        }\\n\\n        // Start with closing at hour 0, the penalty equals all \\'Y\\' in closed hours.\\n        int minPenalty = curPenalty;\\n        int earliestHour = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            char ch = customers[i];\\n\\n            // If the status in hour i is \\'Y\\', moving it to open hours decrements\\n            // the penalty by 1. Otherwise, moving \\'N\\' to open hours increments\\n            // the penalty by 1.\\n            if (ch == \\'Y\\') {\\n                curPenalty--;\\n            } else {\\n                curPenalty++;\\n            }\\n\\n            // Update earliestHour if a smaller penalty is encountered.\\n            if (curPenalty < minPenalty) {\\n                earliestHour = i + 1;\\n                minPenalty = curPenalty;\\n            }\\n        }\\n\\n        return earliestHour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981480,
                "title": "python-3-very-simple-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        opened = []\\n        nSum = 0\\n        for c in customers:\\n            if c == \"N\":\\n                nSum += 1\\n            opened.append(nSum)\\n        closed = []\\n        ySum = 0\\n        for c in customers[::-1]:\\n            if c == \"Y\":\\n                ySum += 1\\n            closed.append(ySum)\\n        closed = closed[::-1]\\n        \\n        minimum = [closed[0], 0]\\n        for i in range(len(customers)):\\n            compareVal = opened[i]\\n            if i < len(closed)-1:\\n                compareVal += closed[i+1]\\n            if compareVal < minimum[0]:\\n                minimum = [compareVal, i+1]\\n        return minimum[1]\\n```\\n![image.png](https://assets.leetcode.com/users/images/8be15a15-e80a-41a0-b91b-b9eb3308aa94_1693414729.9059217.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        opened = []\\n        nSum = 0\\n        for c in customers:\\n            if c == \"N\":\\n                nSum += 1\\n            opened.append(nSum)\\n        closed = []\\n        ySum = 0\\n        for c in customers[::-1]:\\n            if c == \"Y\":\\n                ySum += 1\\n            closed.append(ySum)\\n        closed = closed[::-1]\\n        \\n        minimum = [closed[0], 0]\\n        for i in range(len(customers)):\\n            compareVal = opened[i]\\n            if i < len(closed)-1:\\n                compareVal += closed[i+1]\\n            if compareVal < minimum[0]:\\n                minimum = [compareVal, i+1]\\n        return minimum[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978826,
                "title": "java-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int prefix[] = new int[customers.length()];\\n        int suffix[] = new int[customers.length()];\\n        int count  = 0;\\n        for(int i=0; i<customers.length(); i++) {\\n            prefix[i] = count;\\n            if(customers.charAt(i)==\\'N\\') {\\n                count++;\\n            }\\n        }\\n        count = 0;\\n        for(int i=customers.length()-1; i>=0; i--) {\\n            if(customers.charAt(i)==\\'Y\\') {\\n                count++;\\n            }\\n            suffix[i] = count;\\n        }\\n        ArrayList<Integer>l = new ArrayList<>();\\n        for(int i=0; i<prefix.length; i++) {\\n            l.add(prefix[i]+suffix[i]);\\n        }\\n        l.add(prefix[prefix.length-1]+0);\\n        int val = Collections.min(l);\\n        for(int i=0; i<l.size(); i++) {\\n            if(l.get(i)==val) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int prefix[] = new int[customers.length()];\\n        int suffix[] = new int[customers.length()];\\n        int count  = 0;\\n        for(int i=0; i<customers.length(); i++) {\\n            prefix[i] = count;\\n            if(customers.charAt(i)==\\'N\\') {\\n                count++;\\n            }\\n        }\\n        count = 0;\\n        for(int i=customers.length()-1; i>=0; i--) {\\n            if(customers.charAt(i)==\\'Y\\') {\\n                count++;\\n            }\\n            suffix[i] = count;\\n        }\\n        ArrayList<Integer>l = new ArrayList<>();\\n        for(int i=0; i<prefix.length; i++) {\\n            l.add(prefix[i]+suffix[i]);\\n        }\\n        l.add(prefix[prefix.length-1]+0);\\n        int val = Collections.min(l);\\n        for(int i=0; i<l.size(); i++) {\\n            if(l.get(i)==val) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978256,
                "title": "c-easy-and-readable-solution-faster-than-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/0f9fe2e4-37b9-467d-ba21-2ab19abf2b78_1693345064.8784416.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int BestClosingTime(string c) {\\n        int max = 0;\\n        int score = 0;\\n        int best = -1;\\n        for (int i = 0; i < c.Length; ++i) \\n        {\\n            score += (c[i] == \\'Y\\') ? 1 : -1;\\n            if (score > max)\\n            {\\n                max = score;\\n                best = i;\\n            }\\n        }\\n        return best + 1;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BestClosingTime(string c) {\\n        int max = 0;\\n        int score = 0;\\n        int best = -1;\\n        for (int i = 0; i < c.Length; ++i) \\n        {\\n            score += (c[i] == \\'Y\\') ? 1 : -1;\\n            if (score > max)\\n            {\\n                max = score;\\n                best = i;\\n            }\\n        }\\n        return best + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978237,
                "title": "easy-code-beats-100-in-o-n-and-o-1-time-space-complexities-respectively",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int penalty=0,curPenalty=0,ans=0;\\n        for(int i=0;i<customers.size();i++){\\n            char ch=customers[i];\\n            if(ch==\\'Y\\')curPenalty--;\\n            else curPenalty++;\\n            if(penalty>curPenalty){\\n                ans=i+1;\\n                penalty=curPenalty;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int penalty=0,curPenalty=0,ans=0;\\n        for(int i=0;i<customers.size();i++){\\n            char ch=customers[i];\\n            if(ch==\\'Y\\')curPenalty--;\\n            else curPenalty++;\\n            if(penalty>curPenalty){\\n                ans=i+1;\\n                penalty=curPenalty;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978184,
                "title": "c-clean-code-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string cust) \\n    {\\n        int yesc = 0, noc = 0;\\n        \\n        for(char c:cust)\\n            if(c == \\'Y\\')\\n                yesc++;\\n        \\n        \\n        int penal=0,mintime=INT_MAX,minpenal = INT_MAX;\\n        \\n        for(int i=0;i<=cust.length();i++)\\n        {\\n            penal = yesc + noc;\\n            if(penal < minpenal)\\n            {\\n                mintime = i;\\n                minpenal = penal;\\n            }\\n            if(i<cust.length() && cust[i] == \\'N\\')\\n                noc++;\\n            if(i<cust.length() && cust[i] == \\'Y\\')\\n                yesc--;\\n        }\\n        return mintime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string cust) \\n    {\\n        int yesc = 0, noc = 0;\\n        \\n        for(char c:cust)\\n            if(c == \\'Y\\')\\n                yesc++;\\n        \\n        \\n        int penal=0,mintime=INT_MAX,minpenal = INT_MAX;\\n        \\n        for(int i=0;i<=cust.length();i++)\\n        {\\n            penal = yesc + noc;\\n            if(penal < minpenal)\\n            {\\n                mintime = i;\\n                minpenal = penal;\\n            }\\n            if(i<cust.length() && cust[i] == \\'N\\')\\n                noc++;\\n            if(i<cust.length() && cust[i] == \\'Y\\')\\n                yesc--;\\n        }\\n        return mintime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977964,
                "title": "python-solution-using-prefix-sum-and-dictionary",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n\\n        d = {i : 1e9 for i in range(len(customers)+1)}\\n        yp = [0 for i in range(len(customers))]\\n        np = [0 for i in range(len(customers))]\\n\\n        for i in range(len(customers)) :\\n            if customers[i] == \"Y\" :\\n                yp[i] += yp[i-1] + 1 \\n            else :\\n                yp[i] = yp[i-1]\\n            if customers[i] == \"N\" :\\n                np[i] += np[i-1] + 1 \\n            else:\\n                np[i] = np[i-1]\\n            \\n        yp = [0] + yp\\n        np = [0] + np\\n\\n        d[yp[-1]] = 0\\n\\n        for i in range(1,len(customers)+1) :\\n            val = yp[-1] - yp[i]\\n            val += np[i]\\n\\n            d[val] = min(d[val] , i )\\n\\n        dic = {}\\n        for k,v in d.items():\\n            if v !=1e9:\\n                dic[k] = v \\n\\n        dic = dict(sorted(dic.items() , key = lambda x : x[0]))\\n\\n        for k,v in dic.items():\\n            return v\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n\\n        d = {i : 1e9 for i in range(len(customers)+1)}\\n        yp = [0 for i in range(len(customers))]\\n        np = [0 for i in range(len(customers))]\\n\\n        for i in range(len(customers)) :\\n            if customers[i] == \"Y\" :\\n                yp[i] += yp[i-1] + 1 \\n            else :\\n                yp[i] = yp[i-1]\\n            if customers[i] == \"N\" :\\n                np[i] += np[i-1] + 1 \\n            else:\\n                np[i] = np[i-1]\\n            \\n        yp = [0] + yp\\n        np = [0] + np\\n\\n        d[yp[-1]] = 0\\n\\n        for i in range(1,len(customers)+1) :\\n            val = yp[-1] - yp[i]\\n            val += np[i]\\n\\n            d[val] = min(d[val] , i )\\n\\n        dic = {}\\n        for k,v in d.items():\\n            if v !=1e9:\\n                dic[k] = v \\n\\n        dic = dict(sorted(dic.items() , key = lambda x : x[0]))\\n\\n        for k,v in dic.items():\\n            return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977923,
                "title": "easiest-c-solution",
                "content": "\\n\\n# Approach\\nThe function starts by initializing three variables:\\n\\npoints: This variable keeps track of the difference between the number of \\'Y\\' and \\'N\\' characters encountered so far.\\nhour: This variable will store the index of the hour with the maximum number of \\'Y\\' characters encountered.\\nz: This variable keeps track of the maximum value of points encountered.\\nThe code then enters a loop that iterates through each character in the customers string.\\n\\nInside the loop:\\n\\nIf the current character is \\'Y\\', the points variable is incremented by 1, indicating a customer arrival.\\nIf the current character is \\'N\\', the points variable is decremented by 1, indicating a customer departure.\\nAfter updating the points variable, the code checks if the current value of points (representing the difference between customers arrived and departed) is greater than the current maximum value z. If it is, z is updated to the current points value, and the hour is updated to the current index i. This keeps track of the hour with the maximum number of customers.\\n\\nFinally, the function returns hour + 1 as the best closing time. Adding 1 is done to convert the 0-based index to a 1-based hour representation.\\n\\nIn summary, this code snippet aims to find the hour with the maximum number of customers based on the given input string of \\'Y\\' and \\'N\\' characters. It uses a sliding window approach to track the difference between customer arrivals and departures, and it updates the best closing time whenever the current window yields a higher number of customers than previous windows.\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n      \\n        int points = 0;\\n        int hour=-1;\\n        int z=0;\\n        for(int i = 0; i < customers.size(); i++){\\n            if(customers[i] == \\'Y\\'){\\n            points=points+ 1;\\n            }\\n            else{ \\n                points= points-1;\\n            }\\n            if(points>z){\\n                z=points;\\n                hour = i;\\n            }\\n        }\\n        return hour+1 ;\\n    \\n}\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n      \\n        int points = 0;\\n        int hour=-1;\\n        int z=0;\\n        for(int i = 0; i < customers.size(); i++){\\n            if(customers[i] == \\'Y\\'){\\n            points=points+ 1;\\n            }\\n            else{ \\n                points= points-1;\\n            }\\n            if(points>z){\\n                z=points;\\n                hour = i;\\n            }\\n        }\\n        return hour+1 ;\\n    \\n}\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977805,
                "title": "easy-and-short-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int yes=0 , no=0 , k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(customers[i]==\\'Y\\')\\n            k++;\\n        }\\n        yes=k;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(customers[i]==\\'Y\\')\\n            k--;\\n            else\\n            k++;\\n            if(k<yes)\\n            {\\n                yes=k;\\n                no=i+1;\\n            }\\n        }\\n        return no;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int yes=0 , no=0 , k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(customers[i]==\\'Y\\')\\n            k++;\\n        }\\n        yes=k;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(customers[i]==\\'Y\\')\\n            k--;\\n            else\\n            k++;\\n            if(k<yes)\\n            {\\n                yes=k;\\n                no=i+1;\\n            }\\n        }\\n        return no;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977763,
                "title": "dynamic-customer-status-analysis-for-optimal-closing-time",
                "content": "# Intuition\\nThe initial thoughts for solving this problem involve keeping track of the customers\\' statuses (whether they are leaving or staying) and determining the optimal closing time based on the changes in these statuses.\\n\\n# Approach\\nThe approach to solving the problem involves iterating through the customers\\' statuses and maintaining a dynamic programming array dp that keeps track of the cumulative changes in the number of customers present at different times. The key idea is to count the number of customers who are still present at each time and the ones who have left.\\n\\nStarting with a base case, the initial value of dp[0] is set to the count of customers who plan to stay (\\'Y\\'). Then, as we iterate through the customers\\' statuses, if a customer decides to leave (\\'N\\'), the value of dp[i+1] is updated to reflect one more customer present compared to the previous time. Conversely, if a customer decides to stay (\\'Y\\'), the value of dp[i+1] is updated to indicate one less customer present compared to the previous time.\\n\\nFinally, the index of the minimum value in the dp array represents the optimal closing time with the least number of remaining customers.\\n\\n# Complexity\\n- Time complexity:\\nThe solution iterates through the customers array once to compute the changes in the cumulative customer count, which takes linear time. Finding the index of the minimum value in the dp array also takes linear time. Therefore, the overall time complexity is O(n), where n is the length of the customers array.\\n\\n- Space complexity:\\nThe solution uses an additional dp array to store cumulative changes in the customer count. Therefore, the space complexity is O(n), where n is the length of the customers array.\\n\\n# Code\\n```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n = len(customers)\\n        dp = [0] * (n+1)\\n        dp[0] = customers.count(\\'Y\\')\\n        for i in range(n):\\n            if customers[i] == \\'N\\':\\n                dp[i+1] = dp[i] + 1\\n            else:\\n                dp[i+1] = dp[i] - 1\\n        return dp.index(min(dp))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        n = len(customers)\\n        dp = [0] * (n+1)\\n        dp[0] = customers.count(\\'Y\\')\\n        for i in range(n):\\n            if customers[i] == \\'N\\':\\n                dp[i+1] = dp[i] + 1\\n            else:\\n                dp[i+1] = dp[i] - 1\\n        return dp.index(min(dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977754,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!--Brute Force -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int ans=0,p=INT_MAX;\\nvector<int>s1,s2;\\ns1.push_back(0);\\ns2.push_back(0);\\nint x=1,y=1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'Y\\'){s1.push_back(s1[x-1]+1);x++;s2.push_back(s2[y-1]);y++;}\\n            else {s2.push_back(s2[y-1]+1);y++;s1.push_back(s1[x-1]);x++;}\\n        }\\n        for(int i=0;i<s.size();i++){\\n        if(p>((s2[i]-s2[0])+(s1[s.size()]-s1[i]))){ans=i;p=((s2[i]-s2[0])+(s1[s.size()]-s1[i]));}\\n        cout<<(s2[i]-s2[0])<<\" \"<<s1[s.size()]-s1[i]<<endl;\\n         }\\nif(p>s2[s.size()]){ans=s.size();}\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        int ans=0,p=INT_MAX;\\nvector<int>s1,s2;\\ns1.push_back(0);\\ns2.push_back(0);\\nint x=1,y=1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'Y\\'){s1.push_back(s1[x-1]+1);x++;s2.push_back(s2[y-1]);y++;}\\n            else {s2.push_back(s2[y-1]+1);y++;s1.push_back(s1[x-1]);x++;}\\n        }\\n        for(int i=0;i<s.size();i++){\\n        if(p>((s2[i]-s2[0])+(s1[s.size()]-s1[i]))){ans=i;p=((s2[i]-s2[0])+(s1[s.size()]-s1[i]));}\\n        cout<<(s2[i]-s2[0])<<\" \"<<s1[s.size()]-s1[i]<<endl;\\n         }\\nif(p>s2[s.size()]){ans=s.size();}\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3977691,
                "title": "noob-guy-s-code-don-t-click",
                "content": "Hello there, Stranger \\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F\\nThanks for stopping by \\uD83E\\uDEE1\\nHope you find what you\\'re looking for \\uD83D\\uDE0C\\nHave a great day \\uD83C\\uDF89\\uD83D\\uDE07\\nThank you \\uD83D\\uDC4D\\n\\n# Runtime & Memory\\n![lcss.png](https://assets.leetcode.com/users/images/ca3f9057-b2bd-48f6-b0c5-10db8d8af429_1693333074.1236238.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nvar bestClosingTime = function(customers) {\\n    const n = customers.length;\\n    let curPenalty = earliestHour = minPenalty = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (customers[i] === \\'Y\\') curPenalty -= 1;\\n        else curPenalty += 1;\\n        if (curPenalty < minPenalty) {\\n            minPenalty = curPenalty;\\n            earliestHour = i + 1;\\n        }\\n    }\\n    return earliestHour;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nvar bestClosingTime = function(customers) {\\n    const n = customers.length;\\n    let curPenalty = earliestHour = minPenalty = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (customers[i] === \\'Y\\') curPenalty -= 1;\\n        else curPenalty += 1;\\n        if (curPenalty < minPenalty) {\\n            minPenalty = curPenalty;\\n            earliestHour = i + 1;\\n        }\\n    }\\n    return earliestHour;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977675,
                "title": "c-super-easy-clean-code-prefix-suffix-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n\\n        vector<int> prefix_n(n+1,0);\\n        vector<int> suffix_y(n+1,0);\\n\\n        for(int i=1; i<=n; i++){\\n            prefix_n[i] += prefix_n[i-1] + (customers[i-1]==\\'N\\');\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            suffix_y[i] += suffix_y[i+1] + (customers[i]==\\'Y\\');\\n        }\\n\\n        int penalty = 1e9;\\n        int ans = -1;\\n        for(int i=0; i<=n; i++){\\n            if(penalty > prefix_n[i] + suffix_y[i]){\\n                penalty = prefix_n[i] + suffix_y[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n\\n        vector<int> prefix_n(n+1,0);\\n        vector<int> suffix_y(n+1,0);\\n\\n        for(int i=1; i<=n; i++){\\n            prefix_n[i] += prefix_n[i-1] + (customers[i-1]==\\'N\\');\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            suffix_y[i] += suffix_y[i+1] + (customers[i]==\\'Y\\');\\n        }\\n\\n        int penalty = 1e9;\\n        int ans = -1;\\n        for(int i=0; i<=n; i++){\\n            if(penalty > prefix_n[i] + suffix_y[i]){\\n                penalty = prefix_n[i] + suffix_y[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977619,
                "title": "easy-solutions-basic-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int maxSUM = 0;\\n        int index = 0;\\n        int sum = 0;\\n        for(int i=0;i<customers.size();i++){\\n            if(customers[i]==\\'Y\\'){\\n                sum+=1;\\n            }\\n            else{\\n                sum-=1;\\n            }\\n            if(sum>maxSUM){\\n               maxSUM = sum ;\\n               index = i+1;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int maxSUM = 0;\\n        int index = 0;\\n        int sum = 0;\\n        for(int i=0;i<customers.size();i++){\\n            if(customers[i]==\\'Y\\'){\\n                sum+=1;\\n            }\\n            else{\\n                sum-=1;\\n            }\\n            if(sum>maxSUM){\\n               maxSUM = sum ;\\n               index = i+1;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977388,
                "title": "simple-solution-explained-with-examples-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet us say the string  = \"YYYNY\"\\n\\nNow, a simple question, **what will be the penalty at the 5th hour** (The size of string) => It is simple\\n\\n**The total no of \"N\" in the string**, so it means **the count  = 1 at the 5th index..**\\n\\nWhat will be the penalty at **4th index**..**it will be 2**, because we encounter a \"Y\" and **we closed a shop** when we should not have closed it..\\n\\nWhat **will be the penalty at 3rd index**,** it will be 1**, because the shop is closed and **customer also did not visit..**\\n\\nDID YOU SEE THE PATTERN..\\n\\nWHEN WE START TRAVERSING FROM THE END OF THE ARRAY..\\n\\n**FIRST CALCULATE THE TOTAL NO OF \"N\" IN YOUR SRING...AND MAKE I EQUAL TO COUNT..**\\n\\n**IF WE ENCOUNTER A \"Y\", WE WILL INCREASE THE COUNT  BY 1**\\n\\n**IF WE ENCOUNTER A \"N\", WE WILL DECERASE THE COUNT BY 1..**\\n\\nNow, at every point we will just **see the count<=max_count**, if it is then we will just upadte the index..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe traversed the whole string so **O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo extra space taken so **O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        \\n        int count = 0;\\n        for(int i=0; i<customers.size(); i++)\\n        {\\n            if(customers[i]==\\'N\\')\\n            {\\n                count++;\\n            }\\n        }\\n        int max_idx = customers.size();\\n        int max_no = count;\\n\\n        for(int i=customers.size()-1; i>=0; i--)\\n        {\\n            if(customers[i]==\\'N\\')\\n            {\\n                if(count!=0)\\n                {\\n                    count--;\\n                }\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(count<=max_no)\\n            {\\n                max_no = count;\\n                max_idx = i;\\n            }\\n\\n        }\\n\\n        return max_idx;\\n\\n    }\\n};\\n```\\n\\n**TIME FOR A MEME NOW**\\n\\n![WhatsApp Image 2023-08-29 at 22.40.00.jpeg](https://assets.leetcode.com/users/images/55a18595-9b8a-42a6-97cd-93c4df79a359_1693329079.5153.jpeg)\\n\\n\\n# **IF YOU LIKE MY SOLUTION,PLEASE UPVOTE..**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        \\n        int count = 0;\\n        for(int i=0; i<customers.size(); i++)\\n        {\\n            if(customers[i]==\\'N\\')\\n            {\\n                count++;\\n            }\\n        }\\n        int max_idx = customers.size();\\n        int max_no = count;\\n\\n        for(int i=customers.size()-1; i>=0; i--)\\n        {\\n            if(customers[i]==\\'N\\')\\n            {\\n                if(count!=0)\\n                {\\n                    count--;\\n                }\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(count<=max_no)\\n            {\\n                max_no = count;\\n                max_idx = i;\\n            }\\n\\n        }\\n\\n        return max_idx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977335,
                "title": "python-shortest-1-liner-functional-programming",
                "content": "# Approach\\nSimilar to [Editorial solution. Approach 2](https://leetcode.com/problems/minimum-penalty-for-a-shop/editorial/) but shorter and functional.\\n\\n1. Map `customers` value to `penalties` such that `-1 if \\'Y\\', +1 if \\'N\\'`\\n\\n2. Calculate prefix sum of `penalties` to form `cummulative_penalties`.\\n\\n3. Pair up `cummulative_penalties` with corresponding `indexes`.\\n\\n4. Choose the `index` with minimum `cummulative_penalties`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\nSplit to multiline for readability:\\n```python\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        penalties = map({\\'Y\\': -1, \\'N\\': 1}.get, customers)\\n        cummulative_penalties = accumulate(penalties, initial=0)\\n        cm_pt_indexes = zip(cummulative_penalties, count())\\n        return min(cm_pt_indexes)[-1]\\n\\n\\n```\\n\\nOriginal 1-liner:\\n```python\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        return min(zip(accumulate(map({\\'Y\\': -1, \\'N\\': 1}.get, customers), initial=0), count()))[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        penalties = map({\\'Y\\': -1, \\'N\\': 1}.get, customers)\\n        cummulative_penalties = accumulate(penalties, initial=0)\\n        cm_pt_indexes = zip(cummulative_penalties, count())\\n        return min(cm_pt_indexes)[-1]\\n\\n\\n```\n```python\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        return min(zip(accumulate(map({\\'Y\\': -1, \\'N\\': 1}.get, customers), initial=0), count()))[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977258,
                "title": "beats-100-one-pass-o-n-using-tochararray",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# FYI:\\nConverting a ```string``` to ```toCharArray()``` makes executuion faster as array elements are stored in sequential memory locations and are accessed faster than string elements.\\nSo always convert ```string``` into ```character arrays``` for effificent solutions.\\nThis concept makes your solution go from ```90%``` to ```100%``` faster.\\n# Solution:\\nThe question clearly says that either ```Y``` or ```N``` characters are present in the string. That means if ```Y``` is not present then character ```N``` is present, and vice versa.\\nSo, we can calculate which index has more value, and return that index.\\nSo, while iterating the array, we can calculate ```currentValue``` of the index(```add 1 for \\'Y\\' and substract 1 for \\'N\\'```). If anytime in the iteration the ```currentValue``` increases over the ```maxValue``` update the maxValue(```maxValue=currentValue```) and also update the ```index```.\\nAfter iteration return ```index+1```.\\n\\nInitialize the values as:\\n```maxValue=0```\\n```currentVlaue=0```\\n```index=-1```\\n- Please upvote if you learned something new :)\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String c) {\\n        char arr[]=c.toCharArray();\\n        int maxValue=0;\\n        int currentValue=0;\\n        int index=-1;\\n        for(int i=0;i<arr.length;i++){\\n            currentValue+=(arr[i]==\\'Y\\') ? 1 : -1;\\n            if(currentValue>maxValue){\\n                maxValue=currentValue;\\n                index=i;\\n            }\\n        }\\n        return index+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```string```\n```toCharArray()```\n```string```\n```character arrays```\n```90%```\n```100%```\n```Y```\n```N```\n```Y```\n```N```\n```currentValue```\n```add 1 for \\'Y\\' and substract 1 for \\'N\\'```\n```currentValue```\n```maxValue```\n```maxValue=currentValue```\n```index```\n```index+1```\n```maxValue=0```\n```currentVlaue=0```\n```index=-1```\n```\\nclass Solution {\\n    public int bestClosingTime(String c) {\\n        char arr[]=c.toCharArray();\\n        int maxValue=0;\\n        int currentValue=0;\\n        int index=-1;\\n        for(int i=0;i<arr.length;i++){\\n            currentValue+=(arr[i]==\\'Y\\') ? 1 : -1;\\n            if(currentValue>maxValue){\\n                maxValue=currentValue;\\n                index=i;\\n            }\\n        }\\n        return index+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977122,
                "title": "easy-prefix-sum-solution-in-o-n-t-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply perform prefix sum approach , as the shop closes on particular index just prefix sum of \\'N\\' before the index and the suffix sum of \\'Y\\' after the index . Moving further decrement the suffix value if the value at a particular index is \\'Y\\'.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n         int n=customers.length();\\n         int suff=0;\\n         for(int i=0;i<n;i++){\\n             if(customers[i]==\\'Y\\') suff++;\\n         }\\n        int maxi=suff;\\n        int maxiIndex=0;\\n         int pre=0;\\n         for(int i=0;i<n;i++){\\n             if(customers[i]==\\'N\\') pre++;\\n             if(customers[i]==\\'Y\\') suff--;\\n             if((pre+suff)<maxi){\\n                 maxi=pre+suff;\\n                 maxiIndex=i+1;\\n             }\\n         }\\n         \\n         return maxiIndex;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n         int n=customers.length();\\n         int suff=0;\\n         for(int i=0;i<n;i++){\\n             if(customers[i]==\\'Y\\') suff++;\\n         }\\n        int maxi=suff;\\n        int maxiIndex=0;\\n         int pre=0;\\n         for(int i=0;i<n;i++){\\n             if(customers[i]==\\'N\\') pre++;\\n             if(customers[i]==\\'Y\\') suff--;\\n             if((pre+suff)<maxi){\\n                 maxi=pre+suff;\\n                 maxiIndex=i+1;\\n             }\\n         }\\n         \\n         return maxiIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977120,
                "title": "solved-with-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nvar bestClosingTime = function (customers) {\\n    let tmp = 0, cus = 0, horur = -1;\\n    for (let i = 0; i < customers.length; ++i) {\\n        cus += (customers[i] === \\'Y\\') ? 1 : -1;\\n        if (cus > tmp) {\\n            tmp = cus;\\n            horur = i;\\n        }\\n    }\\n    return horur + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nvar bestClosingTime = function (customers) {\\n    let tmp = 0, cus = 0, horur = -1;\\n    for (let i = 0; i < customers.length; ++i) {\\n        cus += (customers[i] === \\'Y\\') ? 1 : -1;\\n        if (cus > tmp) {\\n            tmp = cus;\\n            horur = i;\\n        }\\n    }\\n    return horur + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976988,
                "title": "simple-solution-java-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int penalty = 0;\\n        for(int i=0;i<customers.length();i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty++;\\n            }\\n        }\\n        int min = penalty;\\n        int hour = 0;\\n        for(int i=0;i<customers.length();i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty--;\\n            } else {\\n                penalty++;\\n            }\\n            if(penalty<min){\\n                min = penalty;\\n                hour = i+1;\\n            }\\n        }\\n        return hour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int penalty = 0;\\n        for(int i=0;i<customers.length();i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty++;\\n            }\\n        }\\n        int min = penalty;\\n        int hour = 0;\\n        for(int i=0;i<customers.length();i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty--;\\n            } else {\\n                penalty++;\\n            }\\n            if(penalty<min){\\n                min = penalty;\\n                hour = i+1;\\n            }\\n        }\\n        return hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976942,
                "title": "o-n-time-complexity-o-1-space-complexity-beats-100-of-c-users-7ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a prefix sum method, however here since we have only one query we don\\'t need to store the entire array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over the string using the index i.\\nStore the number of N you have encountered till the index i and the number of Y you will encounter after the index i. Find the minimum of the sums of these two numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0); cout.tie(0);\\n        int n = customers.size();\\n        int No = 0, Yes = 0;        \\n        for(int i = 0; i < n; i++){\\n            if(customers[i] == \\'Y\\') Yes++;\\n        }\\n        int ans = Yes, mn = 0;\\n        for(int i = 0; i < n; i++){\\n            if(customers[i] == \\'N\\') No++;\\n            else Yes--;\\n            if(No + Yes < ans){\\n                ans = No + Yes;\\n                mn = i + 1;\\n            } \\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0); cout.tie(0);\\n        int n = customers.size();\\n        int No = 0, Yes = 0;        \\n        for(int i = 0; i < n; i++){\\n            if(customers[i] == \\'Y\\') Yes++;\\n        }\\n        int ans = Yes, mn = 0;\\n        for(int i = 0; i < n; i++){\\n            if(customers[i] == \\'N\\') No++;\\n            else Yes--;\\n            if(No + Yes < ans){\\n                ans = No + Yes;\\n                mn = i + 1;\\n            } \\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3976643,
                "title": "simple-prefixsum-and-suffixsum-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int pre[n];int temp=0;\\n        for(int i=0;i<n;i++){\\n            if(customers[i]==\\'N\\'){\\n                temp++;\\n            }\\n            pre[i]=temp;\\n        }\\n        int suff[n];temp=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(customers[i]==\\'Y\\'){\\n                temp++;\\n            }\\n            suff[i]=temp;\\n        }int mini=pre[n-1];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n               mini=min(mini,suff[i]);\\n            }\\n            else{\\n                mini=min(mini,pre[i-1]+suff[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i==0 && suff[i]==mini){\\n                return i;\\n            }\\n            else if(i!=0 && (mini==suff[i]+pre[i-1])){\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int pre[n];int temp=0;\\n        for(int i=0;i<n;i++){\\n            if(customers[i]==\\'N\\'){\\n                temp++;\\n            }\\n            pre[i]=temp;\\n        }\\n        int suff[n];temp=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(customers[i]==\\'Y\\'){\\n                temp++;\\n            }\\n            suff[i]=temp;\\n        }int mini=pre[n-1];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n               mini=min(mini,suff[i]);\\n            }\\n            else{\\n                mini=min(mini,pre[i-1]+suff[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(i==0 && suff[i]==mini){\\n                return i;\\n            }\\n            else if(i!=0 && (mini==suff[i]+pre[i-1])){\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976632,
                "title": "o-n-runtime-optimized-brute-force-using-prefix-and-suffix-concept",
                "content": "# Intuition\\nThe very first thing comes to mind while solving this problem is:-\\n\\n1. if at index \\'idx\\' we close the shop then the arriving customer after closing the shop will be penalty. Also since we closed the shop at \\'idx\\' index meaning till **idxth hour(idx index)** if there is any hour when customer didn\\'t came will be counted as penalty.\\n\\nIn simple words penalty = how many customers didn\\'t came when the shop was open **+** how many customers came after the shop was closed.\\n\\n---\\n\\nsimplifying the formula we can uderstand as => \\n\\n**penalty  =  prefix_N + suffix_Y**\\n\\nnow how many prefix \\'N\\' are there, can be calculated easily just by going in loop and doing prefix_N++ but in case of suffix_Y, we need to know how many yes are there, so\\nthe formula for suffix_y becomes \\n\\n\\n\\n**Suffix_y=total_count_Y - prefix_Y**\\n\\n\\nbut there is a catch in the story since at index \"idx\" we can encounter *yes* or a *no* i.e string[idx] can be *Y* or *N* that means we have to consider them as well while calculating penalty.\\n\\n---\\n\\nso`if(customers[i]==\\'Y\\')\\n    penalty = prefix_N + Suffix_y + 1;\\n`\\nhere we are adding 1 because we are closing shop at a idx where value is \\'Y\\' meaning at that hour customer arrived.\\nwe have only calculated penalty of before and after the shop was closed. But what if while closing shop, any customer comes? Then what we can do is what ever the penalty was , increases by 1 since the customer came while closing the shop adds up.\\n\\nsimilarly if we encounter \\'N\\' at idx postion we have to decrease by 1\\n\\nso `if(customers[i]==\\'Y\\')\\n    penalty = prefix_N + Suffix_y - 1;`\\n\\nwe are decreasing here because of a different reason, and that reason is we have to understand that while counting prefix_N we have counted the current \\'N\\' also, but we need only and only the prefix \\'N\\' so we need to decrease that 1 \\'N\\' i.e the current from the prefix_N.\\n\\n# Approach\\n1.we need all the \\'Y\\' and \\'N\\' count for calculating the suffix.\\n\\nso make two variable & run a loop and count how many yes and no are there.\\n\\n\\n    `code starts\\n    int yes=0;\\n    int no=0;\\n    \\n    for(int i=0; i<customers.size(); i++) {\\n        if(customers[i]==\\'Y\\'){\\n            yes++;\\n        }\\n        else{\\n            no++;\\n        }\\n    } \\n    code ends`\\n\\nnow we go through the loop again one more time to find the idx for minimum penalty.\\n\\n```c++ []\\nif(customers[i]==\\'Y\\'){\\n    prey++;\\n    int suffy=yes-prey;\\n    penalty=pren+suffy+1;\\n    \\n    if(penalty<ans){\\n        \\n        idx=i;\\n        ans = min(ans, penalty);\\n    }\\n}\\nelse{\\n    pren++;\\n    int suffy=yes-prey;\\n    penalty=pren+suffy-1;\\n    if(penalty<ans) {\\n        \\n        idx=i;\\n        ans=min(ans, penalty);\\n    }\\n}\\n```\\n\\n**Edge case**\\nLast but not the least we need to check penalty for one more index, i.e outside the size of string.\\n\\nThe idea is that, what if the string be YYYYY , in this case what ever the idx we close the shop there will be some penalty. But if we close the shop after the all the customers arrived then we can have 0 penalty. \\n\\nMeaning closing the shop at customer.size()th hour.This value is outside the string . here the penalty will be only the total nuber of \\'N\\' since shop is closed at nth index i.e no customer came after it.\\n\\n***suffix_Y=0*** and ***prefix_N=total_count_N*** also we need not to add or decrease any 1 from penalty since no customer came or \\'N\\' was there as the index lies outside the string.\\n\\ntherefore the penalty here is \\n***PENALTY =TOTAL NO OF N***\\n```c++ []\\nint last_close=no;//total count of N was \\n                    //stored earlier in \\n                    //a variable \"no\".\\nif(last_close < ans){\\n            \\n    idx=customers.size();\\n    return idx;\\n}\\n```\\n# Complexity\\n- Time complexity:\\nwe are counting Y and N freqency in the first loop then after that we are againg iterating through the same loop to find our ans.\\n \\n$$T.C=O(n)+O(n)=2O(N) = O(n)$$\\n\\n- Space complexity:\\nNo extra space is used expext delaring prefix_n, suffix_y.\\n\\n$$S.C = O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        \\n        int penalty=0;\\n        int yes=0;\\n        int no=0;\\n        \\n        for(int i=0; i<customers.size(); i++) {\\n            if(customers[i]==\\'Y\\'){\\n                yes++;\\n            }\\n            else{\\n                no++;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        int pren=0;\\n        int prey=0;\\n        int idx=customers.size();\\n        for(int i=0; i<customers.size(); i++){\\n            \\n            //close shop at postion i->idx\\n            if(customers[i]==\\'Y\\'){\\n                prey++;\\n                int suffy=yes-prey;\\n                penalty=pren+suffy+1;\\n                \\n                if(penalty<ans){\\n                    cout<<i<<\"-\"<<penalty<<endl;\\n                    idx=i;\\n                    ans = min(ans, penalty);\\n                }\\n            }\\n            else{\\n                pren++;\\n                int suffy=yes-prey;\\n                penalty=pren+suffy-1;\\n                if(penalty<ans) {\\n                    cout<<i<<\"-\"<<penalty<<endl;\\n                    idx=i;\\n                    ans=min(ans, penalty);\\n                }\\n            }\\n        }\\n        int last_close=no;\\n        if(last_close < ans){\\n            \\n            idx=customers.size();\\n            return idx;\\n        }\\n        \\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "String",
                    "Suffix Array",
                    "Iterator",
                    "Prefix Sum",
                    "Shortest Path"
                ],
                "code": "```c++ []\\nif(customers[i]==\\'Y\\'){\\n    prey++;\\n    int suffy=yes-prey;\\n    penalty=pren+suffy+1;\\n    \\n    if(penalty<ans){\\n        \\n        idx=i;\\n        ans = min(ans, penalty);\\n    }\\n}\\nelse{\\n    pren++;\\n    int suffy=yes-prey;\\n    penalty=pren+suffy-1;\\n    if(penalty<ans) {\\n        \\n        idx=i;\\n        ans=min(ans, penalty);\\n    }\\n}\\n```\n```c++ []\\nint last_close=no;//total count of N was \\n                    //stored earlier in \\n                    //a variable \"no\".\\nif(last_close < ans){\\n            \\n    idx=customers.size();\\n    return idx;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        \\n        int penalty=0;\\n        int yes=0;\\n        int no=0;\\n        \\n        for(int i=0; i<customers.size(); i++) {\\n            if(customers[i]==\\'Y\\'){\\n                yes++;\\n            }\\n            else{\\n                no++;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        int pren=0;\\n        int prey=0;\\n        int idx=customers.size();\\n        for(int i=0; i<customers.size(); i++){\\n            \\n            //close shop at postion i->idx\\n            if(customers[i]==\\'Y\\'){\\n                prey++;\\n                int suffy=yes-prey;\\n                penalty=pren+suffy+1;\\n                \\n                if(penalty<ans){\\n                    cout<<i<<\"-\"<<penalty<<endl;\\n                    idx=i;\\n                    ans = min(ans, penalty);\\n                }\\n            }\\n            else{\\n                pren++;\\n                int suffy=yes-prey;\\n                penalty=pren+suffy-1;\\n                if(penalty<ans) {\\n                    cout<<i<<\"-\"<<penalty<<endl;\\n                    idx=i;\\n                    ans=min(ans, penalty);\\n                }\\n            }\\n        }\\n        int last_close=no;\\n        if(last_close < ans){\\n            \\n            idx=customers.size();\\n            return idx;\\n        }\\n        \\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3976530,
                "title": "beginner-friendly-java-solution",
                "content": "# **Intuition:**\\nImagine a line of customers waiting to enter a store. Some of them have a \"Yes\" (Y) tag, and others have a \"No\" (N) tag. We want to find the best position to close the door such that the number of customers inside and outside is minimized. \\n\\n# **Approach:**\\n1. We\\'ll create two arrays, `prev` and `next`, to keep track of the number of \"No\" tags before and after each position respectively.\\n2. We\\'ll iterate through the customers\\' tags and fill up the `prev` array while counting the number of \"No\" tags we encounter.\\n3. Then, we\\'ll fill up the `next` array by iterating backward through the customers\\' tags while counting the number of \"Yes\" tags.\\n4. For each position, we\\'ll calculate the sum of the corresponding `prev` and `next` values, and keep track of the minimum sum and its corresponding position.\\n5. Finally, we\\'ll return the position where the door should be closed to minimize the number of customers inside and outside the store.\\n\\n# **Complexity:**\\n- **Time complexity**: O(n), where n is the number of customers.\\n- **Space complexity**: O(n).\\n\\n# **Code:**\\n\\n```java\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        \\n        int n = customers.length();  // Total number of customers\\n        int prev[] = new int[n+1];   // Array to store \"No\" count before each position\\n        int next[] = new int[n+1];   // Array to store \"Yes\" count after each position\\n        int ans = Integer.MAX_VALUE; // Initialize the answer with a large value\\n        int res = 0;  // Position to close the door\\n\\n        int count = 0;  // Initialize the count of \"No\" tags\\n\\n        // Filling up the \"prev\" array while counting \"No\" tags\\n        for(int i=0; i<n; i++){\\n\\n            prev[i] = count;  // Store the current \"No\" count\\n\\n            if(customers.charAt(i) == \\'N\\'){\\n                count++;  // Increase the \"No\" count\\n            }\\n        }\\n\\n        prev[n] = count;  // Store the final \"No\" count\\n\\n        count = 0;  // Reset the count\\n\\n        next[n] = 0;  // Initialize the last position\\'s \"Yes\" count\\n\\n        // Check each position to find the best closing time\\n        for(int i=n-1; i>=0; i--){\\n\\n            if(customers.charAt(i) == \\'Y\\'){\\n                count++;  // Increase the \"Yes\" count\\n            }\\n\\n            next[i] = count;  // Store the current \"Yes\" count\\n\\n            // Calculate the sum of \"No\" count before and \"Yes\" count after\\n            int sum = next[i] + prev[i];\\n\\n            // If the current sum is smaller than the previous minimum sum\\n            if(ans >= sum){\\n\\n                ans = sum;  // Update the minimum sum\\n                res = i;     // Update the best closing position\\n            }\\n        }\\n\\n        return res;  // Return the best closing position\\n    }\\n}\\n```\\n\\n**Example 1:**\\nLet\\'s consider an example with customer tags: \"YNYNYNNY\".\\n- The `prev` array will be [0, 0, 1, 1, 2, 2, 2, 3].\\n- The `next` array will be [3, 3, 2, 2, 2, 1, 1, 0].\\n- The best closing position is at index 3, where the sum of \"prev\" and \"next\" is 2 (1 from \"prev\" and 1 from \"next\"). This means there are 2 customers outside and 2 customers inside the store, which is the minimum possible.\\n\\n**Example 2:**\\nConsider another example with customer tags: \"YNNYNYNYN\".\\n- The `prev` array will be [0, 0, 1, 1, 1, 2, 2, 2, 3].\\n- The `next` array will be [3, 3, 3, 2, 2, 2, 1, 1, 0].\\n- The best closing position is at index 6, where the sum of \"prev\" and \"next\" is 2 (2 from \"prev\" and 0 from \"next\"). This means there are 2 customers outside and 2 customers inside the store, which is again the minimum possible.\\n\\nThis algorithm helps the store owner find the best time to close the door to make sure both customers inside and outside are minimized, ensuring a fair and efficient shopping experience!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        \\n        int n = customers.length();  // Total number of customers\\n        int prev[] = new int[n+1];   // Array to store \"No\" count before each position\\n        int next[] = new int[n+1];   // Array to store \"Yes\" count after each position\\n        int ans = Integer.MAX_VALUE; // Initialize the answer with a large value\\n        int res = 0;  // Position to close the door\\n\\n        int count = 0;  // Initialize the count of \"No\" tags\\n\\n        // Filling up the \"prev\" array while counting \"No\" tags\\n        for(int i=0; i<n; i++){\\n\\n            prev[i] = count;  // Store the current \"No\" count\\n\\n            if(customers.charAt(i) == \\'N\\'){\\n                count++;  // Increase the \"No\" count\\n            }\\n        }\\n\\n        prev[n] = count;  // Store the final \"No\" count\\n\\n        count = 0;  // Reset the count\\n\\n        next[n] = 0;  // Initialize the last position\\'s \"Yes\" count\\n\\n        // Check each position to find the best closing time\\n        for(int i=n-1; i>=0; i--){\\n\\n            if(customers.charAt(i) == \\'Y\\'){\\n                count++;  // Increase the \"Yes\" count\\n            }\\n\\n            next[i] = count;  // Store the current \"Yes\" count\\n\\n            // Calculate the sum of \"No\" count before and \"Yes\" count after\\n            int sum = next[i] + prev[i];\\n\\n            // If the current sum is smaller than the previous minimum sum\\n            if(ans >= sum){\\n\\n                ans = sum;  // Update the minimum sum\\n                res = i;     // Update the best closing position\\n            }\\n        }\\n\\n        return res;  // Return the best closing position\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976485,
                "title": "2483-minimum-penalty-for-a-shop-java",
                "content": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int n = customers.length();\\n        \\n        // If there\\'s only one customer\\n        if (n == 1) {\\n            if (customers.charAt(0) == \\'Y\\')\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        // Array to store the count of \\'Y\\' customers up to each index\\n        int[] cnt = new int[n + 1];\\n        \\n        // Initializing the count based on the first customer\\n        if (customers.charAt(0) == \\'Y\\')\\n            cnt[0] = 1;\\n        else\\n            cnt[0] = 0;\\n        \\n        int pen = Integer.MAX_VALUE, ans = 0;\\n        \\n        // Calculating the count of \\'Y\\' customers up to each index\\n        for (int i = 1; i < n; i++) {\\n            if (customers.charAt(i) == \\'Y\\')\\n                cnt[i] = cnt[i - 1] + 1;\\n            else\\n                cnt[i] = cnt[i - 1];\\n        }\\n        \\n        // Count of \\'N\\' customers = total customers - count of \\'Y\\' customers\\n        cnt[n] = n - cnt[n - 1];\\n        pen = cnt[n - 1];\\n        \\n        // Finding the optimal closing time\\n        for (int i = 1; i <= n; i++) {\\n            int temppenality = cnt[n - 1] - cnt[i - 1] + i - cnt[i - 1];\\n            \\n            // Updating minimum penalty and optimal closing time\\n            if (pen > temppenality) {\\n                pen = temppenality;\\n                ans = i;\\n            }\\n        }\\n        \\n        // Checking if all customers are \\'Y\\' and the best closing time is 1\\n        return (cnt[n - 1] == n && pen == 1) ? n : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int n = customers.length();\\n        \\n        // If there\\'s only one customer\\n        if (n == 1) {\\n            if (customers.charAt(0) == \\'Y\\')\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        // Array to store the count of \\'Y\\' customers up to each index\\n        int[] cnt = new int[n + 1];\\n        \\n        // Initializing the count based on the first customer\\n        if (customers.charAt(0) == \\'Y\\')\\n            cnt[0] = 1;\\n        else\\n            cnt[0] = 0;\\n        \\n        int pen = Integer.MAX_VALUE, ans = 0;\\n        \\n        // Calculating the count of \\'Y\\' customers up to each index\\n        for (int i = 1; i < n; i++) {\\n            if (customers.charAt(i) == \\'Y\\')\\n                cnt[i] = cnt[i - 1] + 1;\\n            else\\n                cnt[i] = cnt[i - 1];\\n        }\\n        \\n        // Count of \\'N\\' customers = total customers - count of \\'Y\\' customers\\n        cnt[n] = n - cnt[n - 1];\\n        pen = cnt[n - 1];\\n        \\n        // Finding the optimal closing time\\n        for (int i = 1; i <= n; i++) {\\n            int temppenality = cnt[n - 1] - cnt[i - 1] + i - cnt[i - 1];\\n            \\n            // Updating minimum penalty and optimal closing time\\n            if (pen > temppenality) {\\n                pen = temppenality;\\n                ans = i;\\n            }\\n        }\\n        \\n        // Checking if all customers are \\'Y\\' and the best closing time is 1\\n        return (cnt[n - 1] == n && pen == 1) ? n : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976341,
                "title": "beginner-friendly-time-o-n-space-o-1-easy-approach",
                "content": "There is given if the shop is closed and there is customer at that hour then it have to pay the penalty or shop is open and there is no customer at the hour then also .. \\n\\nso, at the 0th hours if we close the shop and there is customer at 0,1,etc hours then what will be total penalty it would have to pay , total number of Y ... which is our initial Penalty . \\nso , Initailly we are pay the panelty on the basis of total Y so we first calculate the total Y and for N (when there is no customer ) we will calculate on the go . \\n\\nhere is the code i think you will understand it clearly \\n\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        \\n        int n = customers.length();\\n        int index = 0;\\n        int prePenalty = 0;\\n        int totalY =0;\\n        int totalN =0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(customers.charAt(i)==\\'Y\\'){\\n                totalY++;\\n            }\\n        }\\n        \\n        prePenalty = totalY;\\n        \\n        for(int i =1;i<=n;i++){\\n            \\n            if(customers.charAt(i-1)==\\'Y\\'){\\n                totalY-=1;\\n            }\\n            else if(customers.charAt(i-1)==\\'N\\'){\\n                totalN++;\\n            }\\n            \\n            int totalPen = totalY+totalN;\\n            \\n            if(totalPen<prePenalty){\\n                index =i;\\n                prePenalty=totalPen;\\n            }\\n        }\\n        \\n        return index;\\n        \\n    }\\n}\\n```\\n\\nIf you find this solution helpful please upVote..\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        \\n        int n = customers.length();\\n        int index = 0;\\n        int prePenalty = 0;\\n        int totalY =0;\\n        int totalN =0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(customers.charAt(i)==\\'Y\\'){\\n                totalY++;\\n            }\\n        }\\n        \\n        prePenalty = totalY;\\n        \\n        for(int i =1;i<=n;i++){\\n            \\n            if(customers.charAt(i-1)==\\'Y\\'){\\n                totalY-=1;\\n            }\\n            else if(customers.charAt(i-1)==\\'N\\'){\\n                totalN++;\\n            }\\n            \\n            int totalPen = totalY+totalN;\\n            \\n            if(totalPen<prePenalty){\\n                index =i;\\n                prePenalty=totalPen;\\n            }\\n        }\\n        \\n        return index;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976302,
                "title": "simple-solution-with-using-stack-ds-beats-87-92",
                "content": "# Intuition\\nThe task description wants from us to find **the earliest hour**, that\\'ll incur **a minimum penalty**.\\n\\n---\\n\\n\\nLet\\'s dive and obtain some facts:\\n1. `Y` and `N` can be convert to bool `1` and `0`, respectively, if at `i`- th hour there\\'re at least **1 customer** or not\\n2. at each hour we want to calculate **a minimum penalty** as \\n`sum of all zeros BEFORE the shop will closed`\\n3. and at each step we need to somehow **manage the TOTAL** penalty\\n```\\ncustomers = [1, 1, 0, 1]\\n# at i=0 step\\ntotal = [1, 2, 2, 3]\\n# or\\ntotal = 3\\n```\\nIf you haven\\'t already familiar with [prefix sum algorithm](https://en.wikipedia.org/wiki/Prefix_sum#:~:text=In%20computer%20science%2C%20the%20prefix,y0%20%3D%20x&text=y1%20%3D%20x0%20%2B%20x&text=y2%20%3D%20x0%20%2B%20x1%2B%20x), it\\'s time to have a look.\\n\\n\\n---\\nTo be short, building of prefix sum is one of the easiest algorithm. Let\\'s have a look for an example (pseudocode)\\n```\\n# if you have an array or list like\\nA = [1, 2, 3, 4]\\n\\n# the prefix sum can be created as \\n# 1. the total sum of elements\\ntotal = sum(A)\\n\\n# 2. or iterating from i to n elements\\nprefix = [A[0]]\\n\\nfor i in range of 1-n:\\n    add to prefix list sum of prefix[i - 1] + A[i]\\n\\n```\\n\\n# Approach\\n1. initialize `cur` and `total` vars, that\\'ll store initial amount of `Y`- s, and `ans` - variable with initial `0`\\n2. iterate for all `customers` - collection\\n3. add (`+1`) the particular penalty, if `customers[j] == \\'N\\'` or extract `-1`\\n4. at each step check, if the `total` penalty is more than `cur` and replace `total` with the `cur` minimum, and `ans` with `j`\\n5. return the `ans`\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating over all `customers`\\n\\n- Space complexity: **O(1)**, because we don\\'t use extra space.\\n\\n# Code\\n```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        cur = total = customers.count(\\'Y\\')\\n        ans = 0\\n\\n        for j in range(len(customers)):\\n            total += 1 if customers[j] == \\'N\\' else -1\\n            \\n            if total < cur:\\n                cur = total\\n                ans = j + 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\ncustomers = [1, 1, 0, 1]\\n# at i=0 step\\ntotal = [1, 2, 2, 3]\\n# or\\ntotal = 3\\n```\n```\\n# if you have an array or list like\\nA = [1, 2, 3, 4]\\n\\n# the prefix sum can be created as \\n# 1. the total sum of elements\\ntotal = sum(A)\\n\\n# 2. or iterating from i to n elements\\nprefix = [A[0]]\\n\\nfor i in range of 1-n:\\n    add to prefix list sum of prefix[i - 1] + A[i]\\n\\n```\n```\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        cur = total = customers.count(\\'Y\\')\\n        ans = 0\\n\\n        for j in range(len(customers)):\\n            total += 1 if customers[j] == \\'N\\' else -1\\n            \\n            if total < cur:\\n                cur = total\\n                ans = j + 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976127,
                "title": "simple-c-solution-with-explanation-o-n-time-complexity-beats-90-of-the-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main idea behind this solution is that the penalty at any given hour is equal to the sum of  number of Y\\'s after the closing hour and\\nnumber of N\\'s before the closing hour. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps\\n1- First count the number of Y\\'s in the string\\n2- Penalty at 0th hour is equal to total number of Y\\'s in the string\\n3- Take the penalty at 0th hour as Min\\n4- Traverse the string.If s[i]==\"Y\" we decrement the number of Y\\'s after the closing hour (nextY)   by else if i>0 and s[i-1]==\"N\" we increment the number of N\\'s before the closing hour (prevN) by  1.\\n5- Penalty=prevN+nextY\\n6 -Compare the Penalty at ith hour with min penalty and store the minimum of the two  values in min variable and the hour value in res variable \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        //count number of Y\\'s \\n        int y=0;\\n        for (int i=0;i<s.length();i++){\\n            if(s[i]==\\'Y\\')\\n            y++;\\n            \\n        }\\n\\n        if(y==s.length())\\n        return s.length();\\n\\n        if(y==0)\\n        return 0;\\n\\n        //Penalty at 0th hour is equal to number of Y\\'s in the string\\n        //Taking a the penalty at 0th hour as minimum penalty and comparing it with penalties at different position\\n\\n        int min=y;\\n\\n        //nextY stores the number of Y\\'s after the closing hour\\n        //prevN stores the number of N\\'s before the closing hour\\n        //Penalty=nextY+prevN\\n        //Compare the Penalty at ith position and min and storing the value in min variable \\n\\n        int nextY=y,prevN=0,res=0;\\n        for (int i=0;i<s.length();i++){\\n            if(s[i]==\\'Y\\')\\n            { \\n                nextY=nextY-1;\\n            }\\n           if(i>0&&s[i-1]==\\'N\\')\\n            prevN++;\\n\\n           if(prevN+nextY<min)\\n          { \\n              min=prevN+nextY;\\n              res=i+1;\\n          }\\n\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) {\\n        //count number of Y\\'s \\n        int y=0;\\n        for (int i=0;i<s.length();i++){\\n            if(s[i]==\\'Y\\')\\n            y++;\\n            \\n        }\\n\\n        if(y==s.length())\\n        return s.length();\\n\\n        if(y==0)\\n        return 0;\\n\\n        //Penalty at 0th hour is equal to number of Y\\'s in the string\\n        //Taking a the penalty at 0th hour as minimum penalty and comparing it with penalties at different position\\n\\n        int min=y;\\n\\n        //nextY stores the number of Y\\'s after the closing hour\\n        //prevN stores the number of N\\'s before the closing hour\\n        //Penalty=nextY+prevN\\n        //Compare the Penalty at ith position and min and storing the value in min variable \\n\\n        int nextY=y,prevN=0,res=0;\\n        for (int i=0;i<s.length();i++){\\n            if(s[i]==\\'Y\\')\\n            { \\n                nextY=nextY-1;\\n            }\\n           if(i>0&&s[i-1]==\\'N\\')\\n            prevN++;\\n\\n           if(prevN+nextY<min)\\n          { \\n              min=prevN+nextY;\\n              res=i+1;\\n          }\\n\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976106,
                "title": "c-intuitive-solution-with-detailed-explanation",
                "content": "# Intuition\\nThe problem can be thought of as minimizing the score.\\n\\nAs the problem statement describes there are different cases for Y and N and what they are valued as.\\n\\nThe best way to understand this is through an illustration.\\n\\n![IMG_0704.jpeg](https://assets.leetcode.com/users/images/73b8a6bd-3f2a-4247-9528-8ce0e985b75a_1693308400.080159.jpeg)\\n\\nfrom this we can assign values for left and right sides of the divider (close time).\\n\\n**Left (shop is open)**\\n- y = 0\\n- n = 1\\n\\n**Right (shop is closed)**\\n- y = 1\\n- n = 0\\n\\nThis is intuitive as we want to decrease the penalty. \\nIt is bad when the shop is open and there is no customers.\\nIt is bad when the shop is closed and there is customers. \\n\\nTherefore we need to find the point in time which minimizes these penalty conditions\\n\\n# Approach 1: Intuitive O(n) time O(n) space\\n\\n**1. Count how many Y and N there is**\\n- This initial step is crucial as it tells us the initial answers for a close time of 0 or leaving the shop always open\\n- The penalty for a close time of 0 is every Y \\n- The penalty for leaving the shop always open is N\\n\\n```\\ninput = \"YYNY\"\\n\\nyes = 3, no = 1\\n\\nend = 0\\n    |YYNY  : 3\\n\\nend = 3\\n     YYNY| : 1\\n```\\n\\n**2. Calculate the rest**\\n- this can be done by iterating i from left to right, where i represents when the closing time is\\n- therefore when a Y moves from the rightside to the left, it decreases our total score\\n- when a N moves from right to left it increases our score\\n```\\ninput = \"YYNY\"\\n\\nyes = 3, no = 1\\n\\nend = 0\\n    |YYNY  : 3\\n\\nend = 1\\n    Y|YNY  : 2 (score--)\\n\\nend = 2\\n     YY|NY : 1 (score--)\\n\\nend = 3\\n     YYN|Y : 2 (score++)\\n\\nend = 4\\n     YYNY| : 1 (score--)\\n```\\n\\nAll of these scores can be stored in an array\\n```\\npenaltys = [3,2,1,2,1]\\n```\\n\\n**3. Finding the best index**\\nThrough an iteration through the penaltys array construced, we would return the earliest best time to close the sotre. In this case it would be 2, since penaltys[2] has the equal least penalty, but it has the earliest closing time.\\n\\n\\n\\n# Complexity\\n**Time complexity: O(n) (where n is the size of input customers array)**\\n- pass one through customers O(n)\\n- pass two through customers O(n)\\n- pass three through penaltys O(n)\\n\\ntotal = O(n+n+n) = O(n)\\n\\n**Space complexity: O(n)**\\n- we use a vector of size N to store the penalty at each time O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        // count how many yes there is\\n        int yes = 0;\\n        for(char c : customers) {\\n            if(c == \\'Y\\') yes++;\\n        }\\n        int no = customers.size() - yes;\\n\\n        // construct penalties vector to store results\\n        vector<int> penaltys(customers.size() + 1);\\n\\n        // fill in start and end positions \\n        penaltys[0] = yes;\\n        penaltys[penaltys.size() - 1] = no;\\n\\n        // calculate the rest\\n        int pen = yes;\\n        for(int i = 0; i < customers.size(); i++) {\\n            if(customers[i] == \\'Y\\') pen--;\\n            else pen++;\\n            penaltys[i + 1] = pen;\\n        }\\n\\n        // find the best index\\n        int best = 0;\\n        for(int i = 1; i < penaltys.size(); i++) {\\n            if(penaltys[i] < penaltys[best]) best = i;\\n        }\\n\\n        return best;\\n\\n    }\\n};\\n```\\n# Approach 2: Optimized O(n) time O(1) space\\n- instead of storing the penalty for every score, we only need to know the score of the current position and the best so far.\\n- This means we can reduce the space complexity to O(1) whilst keeping the approach the exact same\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        // count how many yes there is\\n        int pen = 0;\\n        for(char c : customers) {\\n            if(c == \\'Y\\') pen++;\\n        }\\n\\n        // store current best index and pen\\n        int idx = 0;\\n        int curr_best = pen;\\n\\n        for(int i = 0; i < customers.size(); i++) {\\n            // shift end point and change pen\\n            int new_pen = pen;\\n            if(customers[i] == \\'Y\\') new_pen--;\\n            else new_pen++;\\n\\n            // if new best store res\\n            if(new_pen < curr_best){\\n                curr_best = new_pen;\\n                idx = i + 1;\\n            } \\n\\n            // update the current penalty score for use the next iteration\\n            pen = new_pen;\\n        }\\n\\n        return idx;\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ninput = \"YYNY\"\\n\\nyes = 3, no = 1\\n\\nend = 0\\n    |YYNY  : 3\\n\\nend = 3\\n     YYNY| : 1\\n```\n```\\ninput = \"YYNY\"\\n\\nyes = 3, no = 1\\n\\nend = 0\\n    |YYNY  : 3\\n\\nend = 1\\n    Y|YNY  : 2 (score--)\\n\\nend = 2\\n     YY|NY : 1 (score--)\\n\\nend = 3\\n     YYN|Y : 2 (score++)\\n\\nend = 4\\n     YYNY| : 1 (score--)\\n```\n```\\npenaltys = [3,2,1,2,1]\\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        // count how many yes there is\\n        int yes = 0;\\n        for(char c : customers) {\\n            if(c == \\'Y\\') yes++;\\n        }\\n        int no = customers.size() - yes;\\n\\n        // construct penalties vector to store results\\n        vector<int> penaltys(customers.size() + 1);\\n\\n        // fill in start and end positions \\n        penaltys[0] = yes;\\n        penaltys[penaltys.size() - 1] = no;\\n\\n        // calculate the rest\\n        int pen = yes;\\n        for(int i = 0; i < customers.size(); i++) {\\n            if(customers[i] == \\'Y\\') pen--;\\n            else pen++;\\n            penaltys[i + 1] = pen;\\n        }\\n\\n        // find the best index\\n        int best = 0;\\n        for(int i = 1; i < penaltys.size(); i++) {\\n            if(penaltys[i] < penaltys[best]) best = i;\\n        }\\n\\n        return best;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        // count how many yes there is\\n        int pen = 0;\\n        for(char c : customers) {\\n            if(c == \\'Y\\') pen++;\\n        }\\n\\n        // store current best index and pen\\n        int idx = 0;\\n        int curr_best = pen;\\n\\n        for(int i = 0; i < customers.size(); i++) {\\n            // shift end point and change pen\\n            int new_pen = pen;\\n            if(customers[i] == \\'Y\\') new_pen--;\\n            else new_pen++;\\n\\n            // if new best store res\\n            if(new_pen < curr_best){\\n                curr_best = new_pen;\\n                idx = i + 1;\\n            } \\n\\n            // update the current penalty score for use the next iteration\\n            pen = new_pen;\\n        }\\n\\n        return idx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976101,
                "title": "easy-o-n-solution-beginners-friendly-beats-90",
                "content": "# Complexity\\n- Time complexity:\\nO(2N) -> O(N) to get the number of Y in the string\\n-------->O(N) for the actual computation \\n\\n- Space complexity:\\nO(1) constant sapce is being used\\n\\n\\n# Dry Run\\n![WhatsApp Image 2023-08-29 at 17.23.20.jpg](https://assets.leetcode.com/users/images/c4c5dd42-f48f-499e-84b5-95596c0b423c_1693310041.1876564.jpeg)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int count_Y = 0, count_N = 0;\\n        for(int i=0;i<customers.size(); i++){\\n            if(customers[i] == \\'Y\\') count_Y++;\\n        }\\n        int mini = 1e9, ind = -1;\\n        for(int i=0; i<customers.size(); i++){\\n            int temp = count_Y + count_N;\\n            //Checking greedyly if we could find someone less than\\n            //what we have selected ans just updating it\\n            if(mini > temp){\\n                mini = temp; ind = i;\\n            }\\n            (customers[i] == \\'Y\\')? count_Y-- : count_N++;\\n        } \\n        //Just to check for the last hour\\n        int temp = count_Y + count_N;\\n        if(mini > temp){\\n            mini = temp; ind = customers.size();\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int count_Y = 0, count_N = 0;\\n        for(int i=0;i<customers.size(); i++){\\n            if(customers[i] == \\'Y\\') count_Y++;\\n        }\\n        int mini = 1e9, ind = -1;\\n        for(int i=0; i<customers.size(); i++){\\n            int temp = count_Y + count_N;\\n            //Checking greedyly if we could find someone less than\\n            //what we have selected ans just updating it\\n            if(mini > temp){\\n                mini = temp; ind = i;\\n            }\\n            (customers[i] == \\'Y\\')? count_Y-- : count_N++;\\n        } \\n        //Just to check for the last hour\\n        int temp = count_Y + count_N;\\n        if(mini > temp){\\n            mini = temp; ind = customers.size();\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976063,
                "title": "very-very-easy-c-plz-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int ans=0;\\n        int n=customers.size();\\n        int penal=0;\\n        int minpenal=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(customers[i]==\\'Y\\')\\n              penal++;\\n        }\\n        minpenal=penal;\\n        for(int i=1;i<=n;i++)\\n        {\\n             if(customers[i-1]==\\'Y\\')\\n                   penal--; \\n               else\\n               penal++;\\n               if(penal<minpenal)\\n               {\\n                  minpenal=penal;\\n                  ans=i;\\n               }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int ans=0;\\n        int n=customers.size();\\n        int penal=0;\\n        int minpenal=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(customers[i]==\\'Y\\')\\n              penal++;\\n        }\\n        minpenal=penal;\\n        for(int i=1;i<=n;i++)\\n        {\\n             if(customers[i-1]==\\'Y\\')\\n                   penal--; \\n               else\\n               penal++;\\n               if(penal<minpenal)\\n               {\\n                  minpenal=penal;\\n                  ans=i;\\n               }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975953,
                "title": "very-simple-and-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLike it\\'s said in the hints, at any given index, the penalty of closing the shop at that hour is given by:\\n`no. of N\\'s on the left` + `no. of Y\\'s on the right`\\n*because if we close the shop at a given hour, then the no. of hours when there were no customers before closing would contribute to the penalty.*\\n*Also the no. of hours in which customers were present after closing would contribute to the penalty.*\\n **Now we just need to minimize the penalty.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Iterate the given string and find the count of N\\'s and Y\\'s.\\n- Now we start iterating from the very start and keep track of the no. of N\\'s on the left and Y\\'s on the right of the index we are currently standing on.\\n- Add the no. of N\\'s on the left and the sum of Y\\'s on the right and minimize this quantity.\\n- Store the index `ind` of the element where the above quantity is minimum.\\n- `ind + 1` will be the answer (in case of 0 based indexing).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int yes = 0, no = 0;\\n        for(int i=0; i<customers.size(); i++){\\n            if(customers[i]==\\'Y\\') yes++;\\n            else no++;\\n        }\\n        int mini = yes;\\n        int ans = -1;\\n        int leftNo = 0, rightYes = yes;\\n        for(int i=0; i<customers.size(); i++){\\n            if(customers[i]==\\'Y\\') rightYes--;\\n            else leftNo++;\\n            if(leftNo + rightYes < mini){\\n                mini = leftNo + rightYes;\\n                ans = i+1;\\n            }\\n        }\\n        if(ans==-1) ans = 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int yes = 0, no = 0;\\n        for(int i=0; i<customers.size(); i++){\\n            if(customers[i]==\\'Y\\') yes++;\\n            else no++;\\n        }\\n        int mini = yes;\\n        int ans = -1;\\n        int leftNo = 0, rightYes = yes;\\n        for(int i=0; i<customers.size(); i++){\\n            if(customers[i]==\\'Y\\') rightYes--;\\n            else leftNo++;\\n            if(leftNo + rightYes < mini){\\n                mini = leftNo + rightYes;\\n                ans = i+1;\\n            }\\n        }\\n        if(ans==-1) ans = 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975825,
                "title": "full-explanation-o-n-easy-java-approach-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1.Scoring System:\\n2.Max Score and Right time:\\n# Complexity\\n- Time complexity: O(n\\n<!--O(n) -->\\n\\n- Space complexity:O(1)\\n<!-- O(1)-->\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int maxScore = 0, score = 0, rightTime = -1;\\n        for (int i = 0; i < customers.length(); ++i) {\\n            score += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n            if (score > maxScore) {\\n                maxScore = score;\\n                rightTime = i;\\n            }\\n        }\\n        return rightTime + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int maxScore = 0, score = 0, rightTime = -1;\\n        for (int i = 0; i < customers.length(); ++i) {\\n            score += (customers.charAt(i) == \\'Y\\') ? 1 : -1;\\n            if (score > maxScore) {\\n                maxScore = score;\\n                rightTime = i;\\n            }\\n        }\\n        return rightTime + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975790,
                "title": "easy-c-solution-using-prefix-array-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose shops are closed at ith hour.So customers who will come before ith hour can enter in shop.So in this case penalty will occur only when at some hour j(j < i), no customer will arrive.Also for customers who will arrive from hour i onwards penalty will be charged.So based on this intution, the code is written.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int prefix[n+1];\\n\\n        int cnt=0;\\n        for(auto i:customers){\\n            if(i==\\'N\\') cnt++;\\n        }\\n\\n        prefix[n]=cnt;\\n        int ans=n;\\n        int cnt_yes=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(customers[i]==\\'Y\\'){\\n                cnt_yes++;\\n                prefix[i]=cnt+cnt_yes;\\n            }else{\\n                cnt--;\\n                prefix[i]=cnt+cnt_yes;\\n            }\\n\\n            if(prefix[i]<=prefix[ans]) ans=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        int prefix[n+1];\\n\\n        int cnt=0;\\n        for(auto i:customers){\\n            if(i==\\'N\\') cnt++;\\n        }\\n\\n        prefix[n]=cnt;\\n        int ans=n;\\n        int cnt_yes=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(customers[i]==\\'Y\\'){\\n                cnt_yes++;\\n                prefix[i]=cnt+cnt_yes;\\n            }else{\\n                cnt--;\\n                prefix[i]=cnt+cnt_yes;\\n            }\\n\\n            if(prefix[i]<=prefix[ans]) ans=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975755,
                "title": "easy-to-understand-solution-for-beginners",
                "content": "# Intuition\\nIf You observe the given Example carefully you can see we are calculating the penalty at each index.We can easily think for a O(N^2) Solution by using 2 for loops.We can Optimise it if we check how we are calculating the penalty at each step its like if we close the shop at that given index, the penalty will be just counting the number of \"N\" before that index and number of \"Y\" current+after that Index.\\n# Approach\\nPrefix and Suffix Sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int ans=INT_MAX;\\n        int res;\\n        int n=customers.size();\\n       vector<int>yes(n+1,0);\\n       vector<int>no(n+1,0);\\n\\n        // for prefix sum of \"N\"\\n\\n        for(int i=1;i<=n;i++){\\n            if(customers[i-1]==\\'N\\')\\n               no[i]=no[i-1]+1;\\n            else\\n            no[i]=no[i-1];   \\n        }\\n        // for suffix sum of \"Y\"\\n\\n        if(customers[n-1]==\\'Y\\')\\n            yes[n]=1;\\n         for(int i=n-1;i>0;i--){\\n               if(customers[i-1]==\\'Y\\')\\n                 yes[i]=yes[i+1]+1;\\n                else\\n                yes[i]=yes[i+1];     \\n         }\\n         \\n         // Calculating the Penalty at each Index\\n        \\n         for(int i=0;i<n;i++){\\n                int penal=yes[i+1]+no[i];\\n                if(penal<ans){\\n                    res=i;\\n                   ans=min(ans,penal);\\n                }\\n               \\n        }\\n        if(no[n]<ans)\\n           return n;\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int ans=INT_MAX;\\n        int res;\\n        int n=customers.size();\\n       vector<int>yes(n+1,0);\\n       vector<int>no(n+1,0);\\n\\n        // for prefix sum of \"N\"\\n\\n        for(int i=1;i<=n;i++){\\n            if(customers[i-1]==\\'N\\')\\n               no[i]=no[i-1]+1;\\n            else\\n            no[i]=no[i-1];   \\n        }\\n        // for suffix sum of \"Y\"\\n\\n        if(customers[n-1]==\\'Y\\')\\n            yes[n]=1;\\n         for(int i=n-1;i>0;i--){\\n               if(customers[i-1]==\\'Y\\')\\n                 yes[i]=yes[i+1]+1;\\n                else\\n                yes[i]=yes[i+1];     \\n         }\\n         \\n         // Calculating the Penalty at each Index\\n        \\n         for(int i=0;i<n;i++){\\n                int penal=yes[i+1]+no[i];\\n                if(penal<ans){\\n                    res=i;\\n                   ans=min(ans,penal);\\n                }\\n               \\n        }\\n        if(no[n]<ans)\\n           return n;\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975744,
                "title": "easy-beginner-freindly-prefix-and-suffix-sum-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int bestClosingTime(string customers) {\\n      /* \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n      */       \\n     int n = customers.size();\\n     vector<int>prefixCountOfN(n+1, 0);\\n     vector<int>suffixCountOfY(n+1, 0);\\n \\n    int cnt = 0;\\n    for(int i=1; i<n+1; i++){\\n       if(customers[i-1] == \\'N\\'){\\n        prefixCountOfN[i] = prefixCountOfN[i-1] + 1;\\n       }\\n       else{\\n           prefixCountOfN[i] = prefixCountOfN[i-1];\\n    }  \\n    }\\n\\n    for(int i=n-1; i>=0; i--){\\n       if(customers[i] == \\'Y\\'){\\n        suffixCountOfY[i] = suffixCountOfY[i+1] + 1;\\n       }\\n       else{\\n        suffixCountOfY[i] = suffixCountOfY[i+1] ;\\n    }  \\n    }\\n  \\n // int sum = 0;\\n int mini = 1e9;\\n int idx;\\n for(int i=0; i<n+1; i++){\\n  int sum =  prefixCountOfN[i] + suffixCountOfY[i];\\n   if(sum < mini){\\n   idx = i;\\n   mini = sum;\\n   }\\n }\\n   return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int bestClosingTime(string customers) {\\n      /* \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n      */       \\n     int n = customers.size();\\n     vector<int>prefixCountOfN(n+1, 0);\\n     vector<int>suffixCountOfY(n+1, 0);\\n \\n    int cnt = 0;\\n    for(int i=1; i<n+1; i++){\\n       if(customers[i-1] == \\'N\\'){\\n        prefixCountOfN[i] = prefixCountOfN[i-1] + 1;\\n       }\\n       else{\\n           prefixCountOfN[i] = prefixCountOfN[i-1];\\n    }  \\n    }\\n\\n    for(int i=n-1; i>=0; i--){\\n       if(customers[i] == \\'Y\\'){\\n        suffixCountOfY[i] = suffixCountOfY[i+1] + 1;\\n       }\\n       else{\\n        suffixCountOfY[i] = suffixCountOfY[i+1] ;\\n    }  \\n    }\\n  \\n // int sum = 0;\\n int mini = 1e9;\\n int idx;\\n for(int i=0; i<n+1; i++){\\n  int sum =  prefixCountOfN[i] + suffixCountOfY[i];\\n   if(sum < mini){\\n   idx = i;\\n   mini = sum;\\n   }\\n }\\n   return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975733,
                "title": "python-brute-force-prefix-sum-one-pass",
                "content": "# **1. BRUTE FORCE SOLUTION - O(N^2)** Time & O(1) Space\\n\\nIn the Brute Force approach, we will go over every possible value of \"j\" and try to see at what value of \"j\", if we close the shop, we get the minimum penalty. \\n\\nSince for each value of \"j\", we are going over the whole string, the overall time complexity comes out to be O(N^2) and hence, we get TLE on large test cases.\\n\\n```\\ndef bestClosingTime(self, customers: str) -> int:\\n\\n\\t# Length of customers string\\n\\tn = len(customers)\\n\\n\\t# minimum penalty\\n\\tminPenalty = float(\"inf\")\\n\\n\\t# Earliest hour\\n\\tearliestHour = -1\\n\\n\\t# j can be at least 0 and at most n\\n\\t# So, we take each value of \"j\" and see which one gives us minimum penalty\\n\\tfor j in range(n + 1):\\n\\t\\t# Penalty for current \"j\" value\\n\\t\\tcurrPenalty = 0\\n\\n\\t\\t# Go over each character in the customers string\\n\\t\\tfor i in range(n):\\n\\t\\t\\t# If j is <= i, it means the shop is already closed\\n\\t\\t\\tif j <= i:\\n\\t\\t\\t\\t# So, if at \"i\" hour customers came, increment penalty\\n\\t\\t\\t\\tif customers[i] == \"Y\": currPenalty += 1\\n\\n\\t\\t\\t# If shop is not already closed\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# If no customers came, increment penalty\\n\\t\\t\\t\\tif customers[i] == \"N\": currPenalty += 1\\n\\n\\t\\t# Update the earliest hour if current penalty is smaller than minimum penalty\\n\\t\\tif currPenalty < minPenalty:\\n\\t\\t\\tminPenalty = currPenalty\\n\\t\\t\\tearliestHour = j\\n\\n\\t# Return the earliest hour    \\n\\treturn earliestHour\\n```\\n\\n# **2. PREFIX SUM SOLUTION - O(N) Time & O(N) Space**\\n\\nThe reason why the Brute Force Solution gives TLE is because of the inner loop where we loop over the whole string again and again for each \"j\" value.\\n\\nIf we analyze the Brute Force Solution, we will see that we are doing some unnecessary calculations again and again even though we can already precompute the data and use it.\\n\\n\\tLet\\'s take an example\\n\\t\\n\\tcustomers = \"YYNY\"\\n\\t\\n\\tIn Brute Force Approach, for each \"j\", we go over the string.\\n\\t\\n\\tWhen j = 0, it means the shop is closed at the 0th hour itself.\\n\\tSo, we calculate penalty as - \\n\\t\\n\\t At i = 0, we have \"Y\" and since shop is closed, penalty += 1\\n\\t At i = 1, we have \"Y\" and since shop is closed, penalty += 1\\n\\t At i = 2, we have \"N\" and since shop is closed, penalty += 0\\n\\t At i = 3, we have \"Y\" and since shop is closed, penalty += 1\\n\\t \\n\\t So, total penalty if we close the shop at j = 0 is 3\\n\\t \\n\\t \\n\\t When j = 1, it means the shop is closed at the 1st hour.\\n\\t So, we calculate penalty as - \\n\\t\\n\\t At i = 0, we have \"Y\" and since shop is open, penalty += 0\\n\\t At i = 1, we have \"Y\" and since shop is closed, penalty += 1\\n\\t At i = 2, we have \"N\" and since shop is closed, penalty += 0\\n\\t At i = 3, we have \"Y\" and since shop is closed, penalty += 1\\n\\t \\n\\t So, total penalty if we close the shop at j = 1 is 2\\n\\t \\n\\t When j = 2, it means the shop is closed at the 2nd hour.\\n\\t So, we calculate penalty as - \\n\\t\\n\\t At i = 0, we have \"Y\" and since shop is open, penalty += 0\\n\\t At i = 1, we have \"Y\" and since shop is open, penalty += 0\\n\\t At i = 2, we have \"N\" and since shop is closed, penalty += 0\\n\\t At i = 3, we have \"Y\" and since shop is closed, penalty += 1\\n\\t \\n\\t So, total penalty if we close the shop at j = 2 is 1\\n\\t \\n\\t And so on...\\n\\t \\nHere, the penalty values will either increment by 0 or by 1 depending on whether the shop is closed or open at that point. So, if we already know that there are only two values to choose from, why are we going over the list again and again? \\n\\nSuppose Shop remains open all the time. In that case, for each character, this is how the data will be -\\n\\n\\tshopOpenData = [0,0,1,0]\\n\\t\\n    Since at index = 2 we have \"N\", a penalty of 1 will be added.\\n\\t\\nNow, Suppose the Shop remains closed all the time, in that case, for each character, this is how the data will be - \\n\\n\\tshopClosedData = [1,1,0,1]\\n\\t\\n    Since at index = 0,1, and 3 we have \"Y\", a penalty of 1 will be added.\\n\\t\\n\\tNow, let\\'s say we close the shop at j = 2. What does that mean?\\n\\n\\tIt means that at and after hour 2 the shop will be closed\\n\\tIt also means from hour 0 to 1 the shop will be open\\n\\t\\n\\tNow, since the shop is closed at and after hour = 2, \\n\\twe can use the shopClosedData to get the total penalty value for closed shop\\n\\t\\n\\tIt will simply be shopClosedData[2] + shopClosedData[3] => 1\\n\\t\\n\\tAnd since the shop is open from 0 to 1 hour\\n\\tWe can use the shopOpenData to get the total penalty value for opened shop\\n\\t\\n\\tIt will simply be shopOpenData[0] + shopOpenData[1] => 0\\n\\t\\n\\tSo, total penalty => 1 when shop is closed at hour = 2\\n\\t\\nIf we write the solution based on these observations, then also we will get TLE because for every hour, we have to manually sum the values in both the lists in the particular ranges.\\n\\nWe can avoid that if we convert these lists into prefix sum lists such that to get the sum between any two indices, we can get that in O(1) time.\\n\\nSo, after converting them into prefix sum lists - \\n\\t\\n\\n\\tshopOpenData = [0,0,0,1,1]\\n\\tshopClosedData = [0,1,2,2,3]\\n\\t\\n\\tNow, suppose at j = 2, shop is closed\\n\\t\\n\\tso, to get penalty when shop closes at j = 2 we just do - \\n\\t\\n\\t\\tshopClosedData[n] - shopClosedData[j]\\n\\t\\t\\n\\tAnd, to get the penalty when shop is open, we do -\\n\\t\\n\\t\\tshopOpenData[j]\\n\\t\\t\\n\\t\\t\\nAnd that\\'s the whole idea of the Prefix Sum solution. The only downside is that there is extra space used and we also have two separate for loops.\\n\\n```\\ndef bestClosingTime(self, customers: str) -> int:\\n\\n\\t# Length of customers string\\n\\tn = len(customers)\\n\\n\\t# minimum penalty\\n\\tminimumPenalty = float(\"inf\")\\n\\n\\t# Earliest hour\\n\\tearliestHour = -1\\n\\n\\t# We increment penalty by 1 if we get \"Y\" when shop is closed at that time\\n\\tshopClosedData = [0] * (n + 1)\\n\\n\\t# We increment penalty by 1 if we get \"N\" when shop is open at that time\\n\\tshopOpenData = [0] * (n + 1)\\n\\t\\n\\tfor i in range(1,n + 1):\\n\\t\\tif customers[i - 1] == \"Y\": \\n\\t\\t\\tshopClosedData[i] = shopClosedData[i - 1] + 1\\n\\t\\t\\tshopOpenData[i] = shopOpenData[i - 1]\\n\\t\\telse:\\n\\t\\t\\tshopClosedData[i] = shopClosedData[i - 1]\\n\\t\\t\\tshopOpenData[i] = shopOpenData[i - 1] + 1\\n\\n\\t# Now, we go over each possible value of \"j\"\\n\\tfor j in range(n + 1):\\n\\n\\t\\t# At and after this \"j\" hour the shop is closed\\n\\t\\t# So, basically, the shop remains closed from hour \"j\" to \"n\"\\n\\t\\tcontributionWhenShopClosed = shopClosedData[n] - shopClosedData[j]\\n\\n\\t\\t# Before \"j\" hour the shop is open\\n\\t\\t# So, basically, the shop remains open from hour \"0\" to \"j - 1\"\\n\\t\\tcontributionWhenShopOpen = shopOpenData[j]\\n\\n\\t\\t# So, total contribution to penalty\\n\\t\\tcurrPenalty = contributionWhenShopClosed + contributionWhenShopOpen\\n\\n\\t\\t# Update the earliest hour if current value is smaller than minimumPenalty\\n\\t\\tif currPenalty < minimumPenalty:\\n\\t\\t\\tminimumPenalty = currPenalty\\n\\t\\t\\tearliestHour = j\\n\\n\\n\\t# Return the earliest hour    \\n\\treturn earliestHour\\n```\\n\\n\\n# **3. ONE PASS - O(N) Time & O(1) Space**\\nFinally, we come to the most optimal solution in which we have only one for loop and we use no extra space.\\n\\nWe just need to see this problem from a diffferent perspective.\\n\\nLet\\'s say when a customer comes at an hour, our profit increases. But, when a customer does not come at any hour, we get a loss.\\n\\nSo, in this way, the best time to close the shop would be when we have the maximum profit. In this way, the loss or penalty will be minimum.\\n\\n```\\ndef bestClosingTime(self, customers: str) -> int:\\n        \\n        # Length of customers string\\n        n = len(customers)\\n        \\n        # Penalty is minimized when the profit is maximized\\n        # That is, we should keep our shop open while we have the most customers coming to the shop\\n        maxProfit = 0\\n        currProfit = 0\\n        \\n        # Earliest Hour\\n        earliestHour = 0\\n        \\n        for i in range(n):\\n\\t\\t\\n            # If customer comes to the shop, profit increases\\n            if customers[i] == \"Y\": currProfit += 1\\n            \\n            # If customer does not come, profit decreases since we get a penalty of 1\\n            else: currProfit -= 1\\n                \\n            # If at this hour, we have the maximum currProfit so far\\n            # It is not ideal to close the shop at this point\\n            # But, if we close the shop at next hour\\n            # Then we may get the maximum profit and least penalty\\n            if currProfit > maxProfit:\\n                maxProfit = currProfit\\n                earliestHour = i + 1\\n\\n        # Return the earliest hour    \\n        return earliestHour\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\ndef bestClosingTime(self, customers: str) -> int:\\n\\n\\t# Length of customers string\\n\\tn = len(customers)\\n\\n\\t# minimum penalty\\n\\tminPenalty = float(\"inf\")\\n\\n\\t# Earliest hour\\n\\tearliestHour = -1\\n\\n\\t# j can be at least 0 and at most n\\n\\t# So, we take each value of \"j\" and see which one gives us minimum penalty\\n\\tfor j in range(n + 1):\\n\\t\\t# Penalty for current \"j\" value\\n\\t\\tcurrPenalty = 0\\n\\n\\t\\t# Go over each character in the customers string\\n\\t\\tfor i in range(n):\\n\\t\\t\\t# If j is <= i, it means the shop is already closed\\n\\t\\t\\tif j <= i:\\n\\t\\t\\t\\t# So, if at \"i\" hour customers came, increment penalty\\n\\t\\t\\t\\tif customers[i] == \"Y\": currPenalty += 1\\n\\n\\t\\t\\t# If shop is not already closed\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# If no customers came, increment penalty\\n\\t\\t\\t\\tif customers[i] == \"N\": currPenalty += 1\\n\\n\\t\\t# Update the earliest hour if current penalty is smaller than minimum penalty\\n\\t\\tif currPenalty < minPenalty:\\n\\t\\t\\tminPenalty = currPenalty\\n\\t\\t\\tearliestHour = j\\n\\n\\t# Return the earliest hour    \\n\\treturn earliestHour\\n```\n```\\ndef bestClosingTime(self, customers: str) -> int:\\n\\n\\t# Length of customers string\\n\\tn = len(customers)\\n\\n\\t# minimum penalty\\n\\tminimumPenalty = float(\"inf\")\\n\\n\\t# Earliest hour\\n\\tearliestHour = -1\\n\\n\\t# We increment penalty by 1 if we get \"Y\" when shop is closed at that time\\n\\tshopClosedData = [0] * (n + 1)\\n\\n\\t# We increment penalty by 1 if we get \"N\" when shop is open at that time\\n\\tshopOpenData = [0] * (n + 1)\\n\\t\\n\\tfor i in range(1,n + 1):\\n\\t\\tif customers[i - 1] == \"Y\": \\n\\t\\t\\tshopClosedData[i] = shopClosedData[i - 1] + 1\\n\\t\\t\\tshopOpenData[i] = shopOpenData[i - 1]\\n\\t\\telse:\\n\\t\\t\\tshopClosedData[i] = shopClosedData[i - 1]\\n\\t\\t\\tshopOpenData[i] = shopOpenData[i - 1] + 1\\n\\n\\t# Now, we go over each possible value of \"j\"\\n\\tfor j in range(n + 1):\\n\\n\\t\\t# At and after this \"j\" hour the shop is closed\\n\\t\\t# So, basically, the shop remains closed from hour \"j\" to \"n\"\\n\\t\\tcontributionWhenShopClosed = shopClosedData[n] - shopClosedData[j]\\n\\n\\t\\t# Before \"j\" hour the shop is open\\n\\t\\t# So, basically, the shop remains open from hour \"0\" to \"j - 1\"\\n\\t\\tcontributionWhenShopOpen = shopOpenData[j]\\n\\n\\t\\t# So, total contribution to penalty\\n\\t\\tcurrPenalty = contributionWhenShopClosed + contributionWhenShopOpen\\n\\n\\t\\t# Update the earliest hour if current value is smaller than minimumPenalty\\n\\t\\tif currPenalty < minimumPenalty:\\n\\t\\t\\tminimumPenalty = currPenalty\\n\\t\\t\\tearliestHour = j\\n\\n\\n\\t# Return the earliest hour    \\n\\treturn earliestHour\\n```\n```\\ndef bestClosingTime(self, customers: str) -> int:\\n        \\n        # Length of customers string\\n        n = len(customers)\\n        \\n        # Penalty is minimized when the profit is maximized\\n        # That is, we should keep our shop open while we have the most customers coming to the shop\\n        maxProfit = 0\\n        currProfit = 0\\n        \\n        # Earliest Hour\\n        earliestHour = 0\\n        \\n        for i in range(n):\\n\\t\\t\\n            # If customer comes to the shop, profit increases\\n            if customers[i] == \"Y\": currProfit += 1\\n            \\n            # If customer does not come, profit decreases since we get a penalty of 1\\n            else: currProfit -= 1\\n                \\n            # If at this hour, we have the maximum currProfit so far\\n            # It is not ideal to close the shop at this point\\n            # But, if we close the shop at next hour\\n            # Then we may get the maximum profit and least penalty\\n            if currProfit > maxProfit:\\n                maxProfit = currProfit\\n                earliestHour = i + 1\\n\\n        # Return the earliest hour    \\n        return earliestHour\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3975644,
                "title": "intuitive-c-approach-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe change of index move \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncalculate the \\'N\\' before index & \\'Y\\' after index, it would be penalty\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        //the count of penalty on the back of index;\\n        int y = 0;\\n        //the count of penalty on the front of index;\\n        int n = 0;\\n        for(auto i : customers){\\n            if(i == \\'Y\\'){\\n                y++;\\n            }\\n        }\\n        vector<int> penalty(customers.size() + 1, 0);\\n        penalty[0] = y;\\n        int index = 1;\\n        for(auto i : customers){\\n            if(i == \\'Y\\'){\\n                y--;\\n            }\\n            else if(i == \\'N\\'){\\n                n++;\\n            }\\n            penalty[index] = y + n;\\n            index++;\\n        }\\n        //find the first minimum\\n        int min = INT_MAX;\\n        for(auto i : penalty){\\n            min = (i < min) ? i : min;\\n        }\\n        for(int i = 0; i < penalty.size(); i++){\\n            if(penalty[i] == min){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        //the count of penalty on the back of index;\\n        int y = 0;\\n        //the count of penalty on the front of index;\\n        int n = 0;\\n        for(auto i : customers){\\n            if(i == \\'Y\\'){\\n                y++;\\n            }\\n        }\\n        vector<int> penalty(customers.size() + 1, 0);\\n        penalty[0] = y;\\n        int index = 1;\\n        for(auto i : customers){\\n            if(i == \\'Y\\'){\\n                y--;\\n            }\\n            else if(i == \\'N\\'){\\n                n++;\\n            }\\n            penalty[index] = y + n;\\n            index++;\\n        }\\n        //find the first minimum\\n        int min = INT_MAX;\\n        for(auto i : penalty){\\n            min = (i < min) ? i : min;\\n        }\\n        for(int i = 0; i < penalty.size(); i++){\\n            if(penalty[i] == min){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975550,
                "title": "ruby-soln-one-pass-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt every step we need to figure out if there\\'s a customer or not and wha\\'s the cost to pay for that result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBecause this problem is 0-indexed we set earliest_hour at -1 instead of 0. We set cost and max_cost at 0 initially and go through the customers accounting for cost state. If the cost of the index we\\'re in exceeds max_cost, we set max_cost to the cost computed and earlier_hour to current index. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - We go through customers size once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - We don\\'t pay any extra cost in space, we only keep track of index and cost\\n\\n# Code\\n```\\n# @param {String} customers\\n# @return {Integer}\\ndef best_closing_time(customers)\\n    max_cost = cost = 0\\n    earlier_hour = -1 # 0-indexed\\n\\n    customers.size.times do |i|\\n        cost += 1 if customers[i] == \"Y\"\\n        cost -= 1 if customers[i] == \"N\"\\n\\n        if cost > max_cost\\n            earlier_hour = i \\n            max_cost = cost \\n        end\\n    end\\n\\n    # Because it\\'s 0-indexed we need to add 1 to our index to get hour \\n    earlier_hour + 1 \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} customers\\n# @return {Integer}\\ndef best_closing_time(customers)\\n    max_cost = cost = 0\\n    earlier_hour = -1 # 0-indexed\\n\\n    customers.size.times do |i|\\n        cost += 1 if customers[i] == \"Y\"\\n        cost -= 1 if customers[i] == \"N\"\\n\\n        if cost > max_cost\\n            earlier_hour = i \\n            max_cost = cost \\n        end\\n    end\\n\\n    # Because it\\'s 0-indexed we need to add 1 to our index to get hour \\n    earlier_hour + 1 \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3975411,
                "title": "accepted-o-n-java-simple-and-efficient-explained-forloop",
                "content": "\\n# Welcome Dear,\\nAfter 2 min you will say, this question is very easy. Let\\'s Start\\n### Best Tips which can Change your LIFE :\\n* Always try to understand Questions, Never Think about solution. \\n* Always find a logic in the Questions, Find some pattern in Inputs.\\n* If you have a logic you can easily write code, DSA is all about making logics and finding patterns Not writting solutions.\\n\\nFirst we will understand the Question, What Question wants from us ?\\n***Return the earliest hour at which the shop must be closed to incur a minimum penalty.***\\nCatch these words, Earliest Hour and Minimum Penalty.\\nIf you read the Question you will undderstand that Earliest Hour is basically a index which we have to return and Minimum Penalty have its own rules to find out which are given in Question.\\n\\nLet\\'s Do a Dry Run:\\nNote :\\n* we will close our shop at ith index, then we will check penalties for that index.\\n* Story : You are a shopkeeper. One day at your shop no one came and you was sitting and waiting for customers that is loss for you and if you close your shop at some hour and after that closing shop some cutomers came that is also loss for you.\\n* Remember ith index is always a closing hour and which hour will have minimum penalty we will return that hour .\\n\\n![image](https://assets.leetcode.com/users/images/d03c52e2-9a51-48b5-8959-2e2222830f1e_1693298475.6116288.jpeg)\\n\\n\\nIf i tell you after ith index how many customer will come and before ith index how many customers will not come and you add both that customers then you will get the total penalty for that i th hour .\\n```\\ntotal loss (penalty) if you close shop at ith index = customer came after closing + no customers came before closing \\n```\\n\\nThat all about this Question Logic now to find these cumstomers who is coming after closing and no customer coming before closing shop, we can make some variables which can store that.\\nIf you can think some other better idea Now must implement that and share with all.\\n\\nSo my logic was firstly i will find total customers who will come means \\'y\\' . COUNT total \\'Y\\' and a else condition which will help to count total \\'N\\' means no customers .\\n\\nNow we will traverse on each hour and check after this index how many \\'Y\\' exist and before this hour how many \\'N\\' exist. After all these steps we will get penalty for that ith index.\\nwe can make a variable \"earliestHour \" which will help us to store that hour on which  minimum penalty  will occur.\\nAnd every time we will update values of custmors who is coming after and not coming customers before that ith hour. This logic is very easy think that you are moving forword and every time you are left some values and you recognise then is it is \\'Y\\' or \\'N\\' and you will update  prevY, prevN, nextY, nextN .\\n\\n\\nI Hope you have a better understanding now, I spent my 1 hour+ in this article please upvote.\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int prevY=0, prevN=0;\\n        int nextY=0, nextN=0;\\n        for(int i=0;i<customers.length();i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                nextY++;\\n            }else{\\n                nextN++;\\n            }\\n        }\\n        \\n        \\n        int minPenalty = Integer.MAX_VALUE , earliestHour = 0;\\n        \\n        for(int i=0;i<=customers.length();i++){          \\n            int penaltyFromNow = prevN + nextY;\\n            \\n            if(minPenalty > penaltyFromNow){\\n                earliestHour = i;\\n                minPenalty = penaltyFromNow;\\n            }\\n            if(i==customers.length()){\\n                return earliestHour;\\n            }\\n            if(customers.charAt(i)==\\'Y\\'){\\n                prevY++ ;\\n                nextY--;\\n            }else{\\n                prevN++;\\n                nextN--;\\n            }\\n        }\\n        return earliestHour;\\n    }\\n}\\n```\\n\\n**Please Upvote me I spent my Life 1 hour+ for you guys, Because it will motivate me to do something better for this world and socity and next time i will do more best to understand others.**\\n\\n![image](https://assets.leetcode.com/users/images/837921dd-babd-404d-b3a6-a3ee8016e26d_1693298508.976588.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\ntotal loss (penalty) if you close shop at ith index = customer came after closing + no customers came before closing \\n```\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int prevY=0, prevN=0;\\n        int nextY=0, nextN=0;\\n        for(int i=0;i<customers.length();i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                nextY++;\\n            }else{\\n                nextN++;\\n            }\\n        }\\n        \\n        \\n        int minPenalty = Integer.MAX_VALUE , earliestHour = 0;\\n        \\n        for(int i=0;i<=customers.length();i++){          \\n            int penaltyFromNow = prevN + nextY;\\n            \\n            if(minPenalty > penaltyFromNow){\\n                earliestHour = i;\\n                minPenalty = penaltyFromNow;\\n            }\\n            if(i==customers.length()){\\n                return earliestHour;\\n            }\\n            if(customers.charAt(i)==\\'Y\\'){\\n                prevY++ ;\\n                nextY--;\\n            }else{\\n                prevN++;\\n                nextN--;\\n            }\\n        }\\n        return earliestHour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975388,
                "title": "prefix-sum-java-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String c) {\\n        int n=c.length();\\n        //count the number of Y after including this point\\n        int[] yc=new int[n];\\n        //count the number of N before including this point\\n        int[] nc=new int[n];\\n        nc[0]=c.charAt(0)==\\'N\\'?1:0;\\n        yc[0]=c.charAt(0)==\\'Y\\'?1:0;\\n        for(int i=1;i<n;i++){\\n            if(c.charAt(i)==\\'N\\')nc[i]=nc[i-1]+1;\\n            else  nc[i]=nc[i-1];\\n            if(c.charAt(i)==\\'Y\\')yc[i]=yc[i-1]+1;\\n            else yc[i]=yc[i-1];\\n            \\n        }\\n\\n        int min=Integer.MAX_VALUE;\\n        int index=-1;\\n        for(int i=0;i<n+1;i++){\\n            //number of Y after the shop is closed\\n            int yp=(i==0)?yc[n-1]:yc[n-1]-yc[i-1];\\n            //number of N when he shop was open\\n            int np=(i==0)?0:nc[i-1];\\n\\n            //finding the penalty \\n            int pen=yp+np;\\n            //checking if it is the minimum one\\n            if(pen<min){\\n                min=pen;\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String c) {\\n        int n=c.length();\\n        //count the number of Y after including this point\\n        int[] yc=new int[n];\\n        //count the number of N before including this point\\n        int[] nc=new int[n];\\n        nc[0]=c.charAt(0)==\\'N\\'?1:0;\\n        yc[0]=c.charAt(0)==\\'Y\\'?1:0;\\n        for(int i=1;i<n;i++){\\n            if(c.charAt(i)==\\'N\\')nc[i]=nc[i-1]+1;\\n            else  nc[i]=nc[i-1];\\n            if(c.charAt(i)==\\'Y\\')yc[i]=yc[i-1]+1;\\n            else yc[i]=yc[i-1];\\n            \\n        }\\n\\n        int min=Integer.MAX_VALUE;\\n        int index=-1;\\n        for(int i=0;i<n+1;i++){\\n            //number of Y after the shop is closed\\n            int yp=(i==0)?yc[n-1]:yc[n-1]-yc[i-1];\\n            //number of N when he shop was open\\n            int np=(i==0)?0:nc[i-1];\\n\\n            //finding the penalty \\n            int pen=yp+np;\\n            //checking if it is the minimum one\\n            if(pen<min){\\n                min=pen;\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975320,
                "title": "c-best-solution-prefix-sum-easy-interation-beats-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main intuition is that at every element we want to get count of Y after it and Count of N before that index and see if this sum is minimum or not. If it is then we get the smallest element as answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet two variables countY and countN.\\n\\n1. Get total number of Y\\'s in string and store in countY.\\n2. Iterate through array for 0 to N hours.\\n3. If its Y then decrease countY and if it is N increase CountN.\\n4. Update the index if the sum of both counts is minimum.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string v) {\\n\\n        int countN=0, countY=0, n=v.size();\\n        int penalty=n;\\n        int result;\\n\\n        for(int i=0;i<n;i++){\\n            if(v[i]==\\'Y\\') countY++;\\n        }\\n\\n        for(int i=0;i<=n;i++){\\n\\n            if(i!=0 && v[i-1]==\\'Y\\'){\\n                countY--;\\n            }\\n\\n            if(i!=0 && v[i-1]==\\'N\\') countN++;\\n\\n            if(penalty>countY+countN){\\n                penalty=totalY+countN;\\n                result=i;\\n            }\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string v) {\\n\\n        int countN=0, countY=0, n=v.size();\\n        int penalty=n;\\n        int result;\\n\\n        for(int i=0;i<n;i++){\\n            if(v[i]==\\'Y\\') countY++;\\n        }\\n\\n        for(int i=0;i<=n;i++){\\n\\n            if(i!=0 && v[i-1]==\\'Y\\'){\\n                countY--;\\n            }\\n\\n            if(i!=0 && v[i-1]==\\'N\\') countN++;\\n\\n            if(penalty>countY+countN){\\n                penalty=totalY+countN;\\n                result=i;\\n            }\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975298,
                "title": "c-o-n-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n= customers.size();\\n        int prefixN[n+1];\\n        int suffixY[n+1];\\n        memset(prefixN, 0, sizeof(prefixN));\\n        memset(suffixY, 0, sizeof(suffixY));\\n        //prefix\\n        if(customers[0]==\\'N\\')\\n        prefixN[0]=1;\\n        for(int i=1; i<customers.size(); i++)\\n        {\\n            if(customers[i]==\\'N\\')\\n            prefixN[i]= 1+ prefixN[i-1];\\n            else\\n            prefixN[i]=prefixN[i-1];\\n        }\\n\\n        //suffix\\n        if(customers[n-1]==\\'Y\\')\\n        suffixY[n-1]=1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(customers[i]==\\'Y\\')\\n            suffixY[i]= 1+ suffixY[i+1];\\n            else\\n            suffixY[i]= suffixY[i+1];\\n        }\\n\\n        int mini= 1e6;int res=-1;\\n        //calculate penalty\\n        for(int i=0; i<=n; i++)\\n        {\\n            int penalty= suffixY[i];\\n            if(i>0)\\n            penalty+= prefixN[i-1];\\n            if(penalty<mini)\\n            {\\n                mini= penalty;\\n                res=i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n= customers.size();\\n        int prefixN[n+1];\\n        int suffixY[n+1];\\n        memset(prefixN, 0, sizeof(prefixN));\\n        memset(suffixY, 0, sizeof(suffixY));\\n        //prefix\\n        if(customers[0]==\\'N\\')\\n        prefixN[0]=1;\\n        for(int i=1; i<customers.size(); i++)\\n        {\\n            if(customers[i]==\\'N\\')\\n            prefixN[i]= 1+ prefixN[i-1];\\n            else\\n            prefixN[i]=prefixN[i-1];\\n        }\\n\\n        //suffix\\n        if(customers[n-1]==\\'Y\\')\\n        suffixY[n-1]=1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(customers[i]==\\'Y\\')\\n            suffixY[i]= 1+ suffixY[i+1];\\n            else\\n            suffixY[i]= suffixY[i+1];\\n        }\\n\\n        int mini= 1e6;int res=-1;\\n        //calculate penalty\\n        for(int i=0; i<=n; i++)\\n        {\\n            int penalty= suffixY[i];\\n            if(i>0)\\n            penalty+= prefixN[i-1];\\n            if(penalty<mini)\\n            {\\n                mini= penalty;\\n                res=i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975296,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int pos=-1,n=0;\\n        for(int i=0;i<customers.length();i++){\\n            char ch=customers.charAt(i);\\n            if(ch==\\'N\\'){ \\n                n--;\\n                if(pos==-1||n>=0){\\n                    pos=i;\\n                    n=-1;\\n                    \\n                }\\n                \\n            }else if(ch==\\'Y\\'&&pos!=-1){\\n                n++;\\n            }\\n        }\\n        if(n<=0&&pos!=-1) return pos;\\n        return customers.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int pos=-1,n=0;\\n        for(int i=0;i<customers.length();i++){\\n            char ch=customers.charAt(i);\\n            if(ch==\\'N\\'){ \\n                n--;\\n                if(pos==-1||n>=0){\\n                    pos=i;\\n                    n=-1;\\n                    \\n                }\\n                \\n            }else if(ch==\\'Y\\'&&pos!=-1){\\n                n++;\\n            }\\n        }\\n        if(n<=0&&pos!=-1) return pos;\\n        return customers.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975220,
                "title": "easy-to-understand-beginner-friendly-two-prefix-sum-array-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        int yes[n];\\n        int no[n];\\n        int count = 0;\\n        for(int i = 0; i<n ; i++){\\n            if(customers[i] == \\'Y\\') count++;\\n            yes[i] = count;   \\n        }\\n        cout<<endl;\\n        count = 0;\\n        for(int i =0;i<n;i++){\\n            if(customers[i] == \\'N\\') count++;\\n            no[i] = count;\\n        }\\n        int last = yes[n-1];\\n        int penalty[n+1];\\n        for(int i =0;i<n;i++){\\n            char temp = customers[i];\\n            if(temp == \\'Y\\'){\\n                int a = last - yes[i]+1;\\n                int b = no[i];\\n                penalty[i] = a+b;\\n            }\\n            else{\\n                int a = last - yes[i];\\n                int b = no[i] - 1;\\n                penalty[i] = a+b;\\n            }\\n        }\\n        penalty[n] = no[n-1];\\n        int mini = INT_MAX;\\n        for(int i =0;i<=n;i++){\\n            mini = min(mini,penalty[i]);\\n            \\n        }\\n        for(int i =0;i<=n;i++){\\n            if(penalty[i] == mini) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        int yes[n];\\n        int no[n];\\n        int count = 0;\\n        for(int i = 0; i<n ; i++){\\n            if(customers[i] == \\'Y\\') count++;\\n            yes[i] = count;   \\n        }\\n        cout<<endl;\\n        count = 0;\\n        for(int i =0;i<n;i++){\\n            if(customers[i] == \\'N\\') count++;\\n            no[i] = count;\\n        }\\n        int last = yes[n-1];\\n        int penalty[n+1];\\n        for(int i =0;i<n;i++){\\n            char temp = customers[i];\\n            if(temp == \\'Y\\'){\\n                int a = last - yes[i]+1;\\n                int b = no[i];\\n                penalty[i] = a+b;\\n            }\\n            else{\\n                int a = last - yes[i];\\n                int b = no[i] - 1;\\n                penalty[i] = a+b;\\n            }\\n        }\\n        penalty[n] = no[n-1];\\n        int mini = INT_MAX;\\n        for(int i =0;i<=n;i++){\\n            mini = min(mini,penalty[i]);\\n            \\n        }\\n        for(int i =0;i<=n;i++){\\n            if(penalty[i] == mini) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3975123,
                "title": "c-dp-o-n-simple-intuitive-detailed-explaination",
                "content": "For me, this solution is much more intuitive than the other prefix sum solutions, and has the same time and space complexity.\\nIt\\'s my first post, please share with me if you have any thoughts. :)\\n\\n# Intuition\\nThe idea is very simple, we just calculate every i-th hour\\'s penalty. But the burte force approach would cost $$O(n^2)$$, hence we have to find a way to improve the TC.\\n\\n# Approach\\nWe can use DP to solve this. Let `dp[i]` denotes the **penalty if we close at i-th hour**. \\nThen `dp[i] = customer[i - 1] == \\'Y\\' ? dp[i - 1] - 1 : dp[i - 1] + 1`.\\n\\nThe idea is that if we close at i-th hour, then the penalty would be equal to the penalty we close at (i-1)-th hour plus the penalty of opening at (i-1)-th hour.\\n\\nFor example, we have `cusotomers = \"YYNY\"`.\\n* If we close at 0-th hour (base case):\\n    * the shop\\'s opening hour is `[close close close close]`.\\n    * we have a penatly of `dp[0] = 1+1+0+1 = 3`.\\n\\n* If we close at 1-th hour: \\n    * the shop\\'s opening hour is `[open close close close]`. \\n    * Difference between closing at 0-th hour is **only the penalty of opening at 0-th hour**. \\n    * Therefore the penalty of 1-th hour is `dp[1] = dp[0] + (penalty of opening at 0-th hour) = 3 - 1`.\\n* If we close at 2-th hour:\\n    * the shop\\'s opening hour is `[open open close close]`.\\n    * Differece between closing at 1-th hour is the penalty of opening at 1-th hour.\\n    * we have a penalty of `dp[2] = dp[1] - 1 = 2 - 1 = 1`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        vector<int> dp(n + 1, 0);\\n\\n        // calculate the penalty if closing at 0-th hour\\n        for (auto &c : customers) { \\n            if (c == \\'Y\\') dp[0]++;\\n        }\\n\\n        int minP = dp[0];\\n        int minIdx = 0; \\n\\n        // calculate the penalty of each hour by leveraging the previous result\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = customers[i - 1] == \\'Y\\' ? dp[i - 1] - 1 : dp[i - 1] + 1;\\n            if (dp[i] < minP) {\\n                minIdx = i; // record the minimum index\\n                minP = dp[i];\\n            }\\n        }\\n\\n        return minIdx;\\n    }\\n}; \\n```\\n\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n\\n# Improvement\\nNotice that we can further improve the space complexity, since we only use the result from previous hour.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        int prePenalty = 0, curPenalty, minIdx = 0;\\n\\n        for (auto &c : customers) \\n            if (c == \\'Y\\') prePenalty++; // penalty of 0-th hour\\n\\n        int minP = prePenalty;\\n        for (int i = 1; i <= n; i++) {\\n            curPenalty = customers[i - 1] == \\'Y\\' ? prePenalty - 1 : prePenalty + 1;\\n            if (curPenalty < minP) {\\n                minIdx = i;\\n                minP = curPenalty;\\n            }\\n\\n            prePenalty = curPenalty;\\n        }\\n\\n        return minIdx;\\n    }\\n};\\n```\\n\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        vector<int> dp(n + 1, 0);\\n\\n        // calculate the penalty if closing at 0-th hour\\n        for (auto &c : customers) { \\n            if (c == \\'Y\\') dp[0]++;\\n        }\\n\\n        int minP = dp[0];\\n        int minIdx = 0; \\n\\n        // calculate the penalty of each hour by leveraging the previous result\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = customers[i - 1] == \\'Y\\' ? dp[i - 1] - 1 : dp[i - 1] + 1;\\n            if (dp[i] < minP) {\\n                minIdx = i; // record the minimum index\\n                minP = dp[i];\\n            }\\n        }\\n\\n        return minIdx;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        int prePenalty = 0, curPenalty, minIdx = 0;\\n\\n        for (auto &c : customers) \\n            if (c == \\'Y\\') prePenalty++; // penalty of 0-th hour\\n\\n        int minP = prePenalty;\\n        for (int i = 1; i <= n; i++) {\\n            curPenalty = customers[i - 1] == \\'Y\\' ? prePenalty - 1 : prePenalty + 1;\\n            if (curPenalty < minP) {\\n                minIdx = i;\\n                minP = curPenalty;\\n            }\\n\\n            prePenalty = curPenalty;\\n        }\\n\\n        return minIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975037,
                "title": "java-o-n-simple-explained-solution-with-prefix-sum",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Here prefix array is maintained to know the penalty occurs if the shop is closed in the i th hour i.e (0,1,2,3,...)\\n- We know maximum penalty can be occured only for the total amount of customers (for that **sum** is maintained)\\n- If we close the  shop in $$O th$$ hour i.e if shop never opened    \\n       **total penalty  = sum**\\n- Now we traverse the string with i = 0,1,2,....\\n        1. If previouse customers came then penalty will be less than previous hour\\n        2. If previouse costomers didn\\'t come penalty will be more than previous hour\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int sum =0;\\n        int n = customers.length();\\n        //calculating the total \\'Y\\' present (max penalty can be occured)\\n        for(int i=0;i<customers.length();i++)\\n        {\\n            if(customers.charAt(i)==\\'Y\\') sum++;\\n        }\\n\\n        //Prefix is maintained to know the previous penalty\\n        int[] prefix = new int[n+1];\\n\\n        // It mean is penalty if shop is closed on 0th hour\\n        prefix[0] = sum;\\n\\n        //This is to find the min penalty\\n        int min= sum;\\n\\n        //This is to store the min penalty hour index\\n        int idx=0;\\n\\n        // We start from 0th index i.e 1st hour\\n        // customer.charAt(0) --> 0th index\\n        // prefix[i+1] --> 1st hour\\n        for(int i=0;i<n;i++)\\n        {\\n            if(customers.charAt(i)==\\'Y\\')\\n            {\\n                prefix[i+1] = prefix[i]-1;\\n            }\\n            else{\\n                prefix[i+1] = prefix[i]+1;\\n            }\\n            \\n            //if min penalty iccured here will be stored\\n            if(min> prefix[i+1])\\n            {\\n                min= prefix[i+1];\\n                idx=i+1;\\n            }\\n            \\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int sum =0;\\n        int n = customers.length();\\n        //calculating the total \\'Y\\' present (max penalty can be occured)\\n        for(int i=0;i<customers.length();i++)\\n        {\\n            if(customers.charAt(i)==\\'Y\\') sum++;\\n        }\\n\\n        //Prefix is maintained to know the previous penalty\\n        int[] prefix = new int[n+1];\\n\\n        // It mean is penalty if shop is closed on 0th hour\\n        prefix[0] = sum;\\n\\n        //This is to find the min penalty\\n        int min= sum;\\n\\n        //This is to store the min penalty hour index\\n        int idx=0;\\n\\n        // We start from 0th index i.e 1st hour\\n        // customer.charAt(0) --> 0th index\\n        // prefix[i+1] --> 1st hour\\n        for(int i=0;i<n;i++)\\n        {\\n            if(customers.charAt(i)==\\'Y\\')\\n            {\\n                prefix[i+1] = prefix[i]-1;\\n            }\\n            else{\\n                prefix[i+1] = prefix[i]+1;\\n            }\\n            \\n            //if min penalty iccured here will be stored\\n            if(min> prefix[i+1])\\n            {\\n                min= prefix[i+1];\\n                idx=i+1;\\n            }\\n            \\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974991,
                "title": "c-o-n-time-and-o-1-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n 1. count of Y is maintained \\n 2. at every point the sum of number of N till that and point and the number of Y from the last is compared with the min value as the value of this sum gives the total penalty till that point of time\\n 3. with each index either the number of Y is decreased or the number of N is increased\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n      int n = customers.size(); \\n      int cnt_Y = 0 , cnt_N = 0;\\n      \\n      for(int i=0;i<n;i++) if(customers[i]==\\'Y\\')cnt_Y++;\\n      int ans = 1e9,min_index=0;\\n\\n      for(int i=0;i<n+1;i++){\\n        int psum = cnt_Y + cnt_N;\\n        if(ans>psum){\\n          ans = psum;\\n          min_index = i;\\n        }\\n        if(i<n && customers[i]==\\'Y\\') cnt_Y--;\\n        else cnt_N++;\\n      }\\n      return min_index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n      int n = customers.size(); \\n      int cnt_Y = 0 , cnt_N = 0;\\n      \\n      for(int i=0;i<n;i++) if(customers[i]==\\'Y\\')cnt_Y++;\\n      int ans = 1e9,min_index=0;\\n\\n      for(int i=0;i<n+1;i++){\\n        int psum = cnt_Y + cnt_N;\\n        if(ans>psum){\\n          ans = psum;\\n          min_index = i;\\n        }\\n        if(i<n && customers[i]==\\'Y\\') cnt_Y--;\\n        else cnt_N++;\\n      }\\n      return min_index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974914,
                "title": "most-easy-solution-in-c-o-n-time-complexity-beats-91-38",
                "content": "# Approach\\n1. The code iterates through the `customers` string character by character.\\n2. For each character, if it is `\\'Y\\'`, it means a customer arrived, so the `count` is incremented. If it is `\\'N\\'`, it means a customer left, so the `count` is decremented.\\n3. The `maxcount` keeps track of the maximum count of customers seen so far, and the `besttime` stores the position (1-indexed) of the best closing time encountered.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n \\n![image.png](https://assets.leetcode.com/users/images/7f8bdeb3-f654-4297-b092-1ddef4cb1025_1693290584.5238101.png)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int maxcount=0;\\n        int count=0;\\n        int besttime=0;\\n        for (int i=0;i<customers.size();i++){\\n            if (customers[i]==\\'Y\\')count++;\\n            else count--;\\n            if(maxcount<count){\\n                maxcount=count;\\n                besttime=i+1;//pos not index\\n            }\\n        }\\n\\n        return besttime; \\n    }\\n};\\n```\\nUpVote :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int maxcount=0;\\n        int count=0;\\n        int besttime=0;\\n        for (int i=0;i<customers.size();i++){\\n            if (customers[i]==\\'Y\\')count++;\\n            else count--;\\n            if(maxcount<count){\\n                maxcount=count;\\n                besttime=i+1;//pos not index\\n            }\\n        }\\n\\n        return besttime; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974798,
                "title": "beginers-friendly-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIF YOU LIKE THE SOLUTION PLEASE UPVOTE GUYS\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def bestClosingTime(self, cmr: str) -> int:\\n        Y_cnt=cmr.count(\"Y\")\\n        N_cnt=total_preceding_N_count=len(cmr)-Y_cnt\\n        temp=0\\n        minn=float(\"inf\")\\n        res=0\\n        for i in range(len(cmr)):\\n            if minn>Y_cnt+temp:\\n                minn=Y_cnt+temp\\n                res=i\\n            if cmr[i]==\"Y\":\\n                Y_cnt-=1\\n            elif cmr[i]==\"N\":\\n                N_cnt-=1\\n                temp+=1\\n        if total_preceding_N_count<minn:\\n            res=i+1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bestClosingTime(self, cmr: str) -> int:\\n        Y_cnt=cmr.count(\"Y\")\\n        N_cnt=total_preceding_N_count=len(cmr)-Y_cnt\\n        temp=0\\n        minn=float(\"inf\")\\n        res=0\\n        for i in range(len(cmr)):\\n            if minn>Y_cnt+temp:\\n                minn=Y_cnt+temp\\n                res=i\\n            if cmr[i]==\"Y\":\\n                Y_cnt-=1\\n            elif cmr[i]==\"N\":\\n                N_cnt-=1\\n                temp+=1\\n        if total_preceding_N_count<minn:\\n            res=i+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974775,
                "title": "java-brute-force-approach",
                "content": "```\\n// Approach 1: Brute Force - TLE\\n\\n// Time complexity: O(n^2)\\n// Space complexity: O(1)\\n\\npublic int bestClosingTime(String customers) {\\n\\tint minPenalty = Integer.MAX_VALUE;\\n\\tint earliestHour = customers.length();\\n\\t\\n\\tfor (int i = 0; i <= customers.length(); i++) {\\n\\t\\tint curPenalty = 0;\\n\\t\\t\\n\\t\\tfor (int j = 0; j < customers.length(); j++) {\\n\\t\\t\\tchar ch = customers.charAt(j);\\n\\t\\t\\t\\n\\t\\t\\tif (j >= i) {           // closed\\n\\t\\t\\t\\tif (ch == \\'Y\\')\\n\\t\\t\\t\\t\\tcurPenalty++;\\n\\t\\t\\t} else {                // open\\n\\t\\t\\t\\tif (ch == \\'N\\')\\n\\t\\t\\t\\tcurPenalty++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (curPenalty < minPenalty) {\\n\\t\\t\\tminPenalty = curPenalty;\\n\\t\\t\\tearliestHour = i;\\n\\t\\t}\\n\\t} \\n\\t\\n\\treturn earliestHour;\\n}\\n```\\n\\n**Note:-** This solution gives TLE. It\\'s provided just for understanding purpose.\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Approach 1: Brute Force - TLE\\n\\n// Time complexity: O(n^2)\\n// Space complexity: O(1)\\n\\npublic int bestClosingTime(String customers) {\\n\\tint minPenalty = Integer.MAX_VALUE;\\n\\tint earliestHour = customers.length();\\n\\t\\n\\tfor (int i = 0; i <= customers.length(); i++) {\\n\\t\\tint curPenalty = 0;\\n\\t\\t\\n\\t\\tfor (int j = 0; j < customers.length(); j++) {\\n\\t\\t\\tchar ch = customers.charAt(j);\\n\\t\\t\\t\\n\\t\\t\\tif (j >= i) {           // closed\\n\\t\\t\\t\\tif (ch == \\'Y\\')\\n\\t\\t\\t\\t\\tcurPenalty++;\\n\\t\\t\\t} else {                // open\\n\\t\\t\\t\\tif (ch == \\'N\\')\\n\\t\\t\\t\\tcurPenalty++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (curPenalty < minPenalty) {\\n\\t\\t\\tminPenalty = curPenalty;\\n\\t\\t\\tearliestHour = i;\\n\\t\\t}\\n\\t} \\n\\t\\n\\treturn earliestHour;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974698,
                "title": "c-o-n-prefix-sum",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string nums) {\\n        int n = nums.size();\\n        // assume shop close at 0th hours-> Y = 1, N =0;\\n        int sum =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==\\'Y\\') sum++;\\n        }\\n\\n        int currSum =sum;\\n        int ans =0;\\n        nums.push_back(\\'1\\'); // add any extra character in case if earliest hour is n(nums.size());\\n        for(int i =1;i<n+1;i++){\\n            if(nums[i-1]==\\'Y\\') currSum--;\\n            else currSum++;\\n            if(currSum<sum){\\n                sum = currSum;\\n                ans =i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int bestClosingTime(string nums) {\\n        int n = nums.size();\\n        // assume shop close at 0th hours-> Y = 1, N =0;\\n        int sum =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==\\'Y\\') sum++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3974690,
                "title": "easy-c-beginner-friendly-dp-prefix-sum-o-n-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor everyhour we need to caluclate number of hours that the shop remains open after that hour **(including that hour)** and number of hours the shop is open before that hour.\\n   - So if X be the 1st number and Y be the 2nd number then the penality if the shop is closed at that hour would be **X+Y**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a Prefix array and Suffix array to maintain values of X and Y for every hour.And return the index at which the penality occured is minimum. \\n\\n# Complexity\\n - # TC   *O(N)*\\n - # SC  *O(N)*\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) \\n    {\\n        int n=s.size();\\n        vector<int>pre(n+5,0),suf(n+5,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n            pre[i]=pre[i-1];\\n            if(s[i-1]==\\'N\\')pre[i]++;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suf[i]=suf[i+1];\\n            if(s[i]==\\'Y\\')suf[i]++;\\n        }\\n        int ans=-1,pen=INT_MAX;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(pre[i]+suf[i]<pen)\\n            {\\n                pen=pre[i]+suf[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s) \\n    {\\n        int n=s.size();\\n        vector<int>pre(n+5,0),suf(n+5,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n            pre[i]=pre[i-1];\\n            if(s[i-1]==\\'N\\')pre[i]++;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suf[i]=suf[i+1];\\n            if(s[i]==\\'Y\\')suf[i]++;\\n        }\\n        int ans=-1,pen=INT_MAX;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(pre[i]+suf[i]<pen)\\n            {\\n                pen=pre[i]+suf[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974603,
                "title": "javascript-easy-solution-explanation-with-comments-time-complexity-o-n-and-space-complexity-o-1",
                "content": "# Intuition\\nWe have a shop that\\'s open for a certain number of hours, and during each hour, customers may or may not visit. Given a string representing whether customers visit during each hour. \\'Y\\' means customers come, and \\'N\\' means no customers.\\n\\nThe shop has a closing time, which means we can decide at what hour the shop should close. The goal is to find the earliest hour at which we should close the shop to minimize the penalty. The penalty increases in two cases:\\n\\n1.) If the shop is open during an hour, but no customers come.\\n2.) If the shop is closed during an hour, but customers come.\\n\\nTask is to find the earliest closing hour that minimizes this penalty. In other words, we want to find the earliest hour at which we should close the shop to avoid both these penalty scenarios as much as possible.\\n\\nLet\\'s understand with easy example:-\\n\\nSuppose the shop operates from 9 AM to 6 PM, which is a total of 10 hours. The customer visit pattern is given by the string \"NNYNYNNYYY\". \\n\\nCase 1 :- If the shop closes at 6 PM (10th hour), the penalties would be:\\n\\n-> Penalty 1: The shop is open, but no customers come (7th and 9th hour). Penalty increases by 2.\\n-> Penalty 2: The shop is closed, but customers come (3rd, 5th, 7th, 9th, and 10th hour). Penalty increases by 5.\\n\\nTotal penalty: 2 + 5 = 7.\\n\\nCase 2 :- If the shop closes at 5 PM (9th hour), the penalties would be:\\n\\n-> Penalty 1: The shop is open, but no customers come (7th hour). Penalty increases by 1.\\n-> Penalty 2: The shop is closed, but customers come (3rd, 5th, 7th, and 9th hour). Penalty increases by 4.\\n\\nTotal penalty: 1 + 4 = 5.\\n\\n\\nCase 3 :- If the shop closes at 4 PM (8th hour), the penalties would be:\\n\\n-> Penalty 1: The shop is open, but no customers come (7th hour). Penalty increases by 1.\\n-> Penalty 2: The shop is closed, but customers come (3rd, 5th, and 7th hour). Penalty increases by 3.\\n\\nTotal penalty: 1 + 3 = 4.\\n\\nIn this example, closing the shop at 4 PM incurs the minimum penalty of 4.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) linear\\n  \\n- Space complexity: O(1) constant\\n\\n# Code\\n```\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nconst bestClosingTime = (customers) => {\\n  // Count the number of \"Y\" occurrences in the customers array\\n  let numberOfYs = 0;\\n  for (const char of customers) {\\n    if (char === \"Y\") {\\n      numberOfYs++;\\n    }\\n  }\\n  \\n  const totalYs = numberOfYs;\\n  let optimalTime = 0;\\n  let lowestPenalty = totalYs;\\n  \\n  // Iterate through the customers array to find the optimal closing time\\n  for (let i = 0; i < customers.length && numberOfYs > 0; i++) {\\n    // Calculate the number of \"N\" occurrences before the current index\\n    const numberOfNs = i - (totalYs - numberOfYs);\\n    \\n    // Update the count of remaining \"Y\" occurrences\\n    if (customers[i] === \"Y\") {\\n      numberOfYs--;\\n    }\\n    \\n    // If the current penalty is not lower, continue to the next iteration\\n    if (numberOfYs + numberOfNs >= lowestPenalty) {\\n      continue;\\n    }\\n    \\n    // Update the best closing time and the lowest penalty\\n    optimalTime = i + 1;\\n    lowestPenalty = numberOfYs + numberOfNs;\\n  }\\n  \\n  return optimalTime;\\n};\\n\\n// Test cases\\nconsole.log(bestClosingTime(\"YYNY\")); // Output: 2\\nconsole.log(bestClosingTime(\"NNNNN\")); // Output: 0\\nconsole.log(bestClosingTime(\"YYYY\")); // Output: 4\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} customers\\n * @return {number}\\n */\\nconst bestClosingTime = (customers) => {\\n  // Count the number of \"Y\" occurrences in the customers array\\n  let numberOfYs = 0;\\n  for (const char of customers) {\\n    if (char === \"Y\") {\\n      numberOfYs++;\\n    }\\n  }\\n  \\n  const totalYs = numberOfYs;\\n  let optimalTime = 0;\\n  let lowestPenalty = totalYs;\\n  \\n  // Iterate through the customers array to find the optimal closing time\\n  for (let i = 0; i < customers.length && numberOfYs > 0; i++) {\\n    // Calculate the number of \"N\" occurrences before the current index\\n    const numberOfNs = i - (totalYs - numberOfYs);\\n    \\n    // Update the count of remaining \"Y\" occurrences\\n    if (customers[i] === \"Y\") {\\n      numberOfYs--;\\n    }\\n    \\n    // If the current penalty is not lower, continue to the next iteration\\n    if (numberOfYs + numberOfNs >= lowestPenalty) {\\n      continue;\\n    }\\n    \\n    // Update the best closing time and the lowest penalty\\n    optimalTime = i + 1;\\n    lowestPenalty = numberOfYs + numberOfNs;\\n  }\\n  \\n  return optimalTime;\\n};\\n\\n// Test cases\\nconsole.log(bestClosingTime(\"YYNY\")); // Output: 2\\nconsole.log(bestClosingTime(\"NNNNN\")); // Output: 0\\nconsole.log(bestClosingTime(\"YYYY\")); // Output: 4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974557,
                "title": "98-65-easy",
                "content": "Bu masalani yechishda asosiysi i- nuqtacha bo\\'lgan N larni soni va i dan n gacha bo\\'lgan Y larni sonini aniqlashdir.\\nYa\\'ni biz do\\'konni i-soatda yopsak shu soatgacha nechta soatda odam kelmadi, Va shu soatdan keyin nechta odam keldi, shu ikkalasini yig\\'indisi bu jarimalar deganidur.\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n         int n = customers.length();\\n        int[] a = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            if (customers.charAt(i) == \\'Y\\') {\\n                a[i + 1] = a[i] + 1;\\n            } else {\\n                a[i + 1] = a[i];\\n            }\\n        }\\n        int min = n;\\n        int index = 0;\\n        int ball;\\n        for (int i = 0; i <= n; i++) {\\n            ball = (i - a[i]) + (a[n] - a[i]);\\n            if (min > ball) {\\n                min = ball;\\n                index = i;\\n                if (min == 0) return index;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n         int n = customers.length();\\n        int[] a = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            if (customers.charAt(i) == \\'Y\\') {\\n                a[i + 1] = a[i] + 1;\\n            } else {\\n                a[i + 1] = a[i];\\n            }\\n        }\\n        int min = n;\\n        int index = 0;\\n        int ball;\\n        for (int i = 0; i <= n; i++) {\\n            ball = (i - a[i]) + (a[n] - a[i]);\\n            if (min > ball) {\\n                min = ball;\\n                index = i;\\n                if (min == 0) return index;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974479,
                "title": "c-java-python-prefix-sums-easy-understanding-solution",
                "content": "\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int yes = 0, no = 0;\\n        int ans = -1;\\n        int penalty = INT_MAX;\\n        int n = customers.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (customers[i]== \\'Y\\') yes++;\\n        }\\n\\n        for (int i = 0; i <= n; ++i) {\\n            int prevInd = i - 1;\\n            if (prevInd >= 0) {\\n                if (customers[prevInd] == \\'Y\\') yes--;\\n                else no++;\\n            }\\n\\n            if (yes + no < penalty) {\\n                penalty = yes + no;\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int yes = 0, no = 0;\\n        int ans = -1;\\n        int penalty = Integer.MAX_VALUE;\\n        int n = customers.length();\\n        for (int i = 0; i < n; ++i) {\\n            if (customers.charAt(i) == \\'Y\\') yes++;\\n        }\\n\\n        for (int i = 0; i <= n; ++i) {\\n            int prevInd = i - 1;\\n            if (prevInd >= 0) {\\n                if (customers.charAt(prevInd) == \\'Y\\') yes--;\\n                else no++;\\n            }\\n\\n            if (yes + no < penalty) {\\n                penalty = yes + no;\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        yes, no = 0, 0\\n        ans = -1\\n        penalty = float(\"inf\")\\n        n = len(customers)\\n\\n        for i in range(n):\\n            if customers[i] == \"Y\":\\n                yes += 1\\n        \\n        for i in range(n + 1):\\n            prevInd = i - 1\\n            if prevInd >= 0:\\n                if customers[prevInd] == \"Y\":\\n                    yes -= 1\\n                else:\\n                    no += 1\\n            \\n            if yes + no < penalty:\\n                penalty = yes + no\\n                ans = i\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int yes = 0, no = 0;\\n        int ans = -1;\\n        int penalty = INT_MAX;\\n        int n = customers.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (customers[i]== \\'Y\\') yes++;\\n        }\\n\\n        for (int i = 0; i <= n; ++i) {\\n            int prevInd = i - 1;\\n            if (prevInd >= 0) {\\n                if (customers[prevInd] == \\'Y\\') yes--;\\n                else no++;\\n            }\\n\\n            if (yes + no < penalty) {\\n                penalty = yes + no;\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int yes = 0, no = 0;\\n        int ans = -1;\\n        int penalty = Integer.MAX_VALUE;\\n        int n = customers.length();\\n        for (int i = 0; i < n; ++i) {\\n            if (customers.charAt(i) == \\'Y\\') yes++;\\n        }\\n\\n        for (int i = 0; i <= n; ++i) {\\n            int prevInd = i - 1;\\n            if (prevInd >= 0) {\\n                if (customers.charAt(prevInd) == \\'Y\\') yes--;\\n                else no++;\\n            }\\n\\n            if (yes + no < penalty) {\\n                penalty = yes + no;\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:\\n        yes, no = 0, 0\\n        ans = -1\\n        penalty = float(\"inf\")\\n        n = len(customers)\\n\\n        for i in range(n):\\n            if customers[i] == \"Y\":\\n                yes += 1\\n        \\n        for i in range(n + 1):\\n            prevInd = i - 1\\n            if prevInd >= 0:\\n                if customers[prevInd] == \"Y\":\\n                    yes -= 1\\n                else:\\n                    no += 1\\n            \\n            if yes + no < penalty:\\n                penalty = yes + no\\n                ans = i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974444,
                "title": "counting-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n**penalty for ith index = occurrence of \\'N\\' before i + occurance of \\'Y\\' after i.**\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        int m = c.size(),t_count_y = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            if(c[i]==\\'Y\\') t_count_y++;\\n        }\\n\\n        int  count_n = 0,pre_count_y = 0;\\n        int  ans = -1,minval = INT_MAX;\\n\\n        for(int i = 0;i<m+1;i++)\\n        {\\n            int pan = (t_count_y-pre_count_y)+count_n;\\n            if(pan<minval)\\n            {\\n              ans = i;\\n              minval = pan;\\n            } \\n            if(i<m && c[i]==\\'Y\\')  pre_count_y++;\\n            else count_n++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/abe180ac-3c82-4f2c-8c72-bb040415fb1e_1693284082.3631158.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string c) {\\n        int m = c.size(),t_count_y = 0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            if(c[i]==\\'Y\\') t_count_y++;\\n        }\\n\\n        int  count_n = 0,pre_count_y = 0;\\n        int  ans = -1,minval = INT_MAX;\\n\\n        for(int i = 0;i<m+1;i++)\\n        {\\n            int pan = (t_count_y-pre_count_y)+count_n;\\n            if(pan<minval)\\n            {\\n              ans = i;\\n              minval = pan;\\n            } \\n            if(i<m && c[i]==\\'Y\\')  pre_count_y++;\\n            else count_n++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974439,
                "title": "using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPrefix_Sum\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s ){\\n        int i,j,n=0,y=0;\\n        vector<int> v(s.size(),0);\\n        vector<int> psn(s.size(),0),psy(s.size(),0);\\n        for(i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'N\\') { n++; }\\n            else  { y++; }\\n            psn[i]=n;\\n            psy[i]=y; \\n        }\\n        // n--;\\n        // y--;\\n        // for(auto x:psn) cout<<x<<\" \";\\n        // cout<<endl;\\n        // for(auto x:psy) cout<<x<<\" \";\\n        // cout<<endl;\\n        // cout<<n<<\" \"<<y<<endl;\\n        for(i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'N\\') v[i]=psn[i]-1+(y-psy[i]);\\n            else v[i]=psn[i]+(y-psy[i]);\\n        }\\n        // for(auto x:v) cout<<x<<\" \";\\n        int mi=*min_element(v.begin(),v.end());\\n        int idx=find(v.begin(),v.end(),mi)-v.begin();\\n\\n        // for(i=0;i<v.size();i++)\\n        // {\\n        //     if(v[i]<mi)\\n        //     {\\n        //         mi=v[i];\\n        //         idx=i+1;\\n        //     }\\n        // }\\n        if(y<=mi) return 0;\\n        if(y==0) return 0;\\n        return idx+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string s ){\\n        int i,j,n=0,y=0;\\n        vector<int> v(s.size(),0);\\n        vector<int> psn(s.size(),0),psy(s.size(),0);\\n        for(i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'N\\') { n++; }\\n            else  { y++; }\\n            psn[i]=n;\\n            psy[i]=y; \\n        }\\n        // n--;\\n        // y--;\\n        // for(auto x:psn) cout<<x<<\" \";\\n        // cout<<endl;\\n        // for(auto x:psy) cout<<x<<\" \";\\n        // cout<<endl;\\n        // cout<<n<<\" \"<<y<<endl;\\n        for(i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'N\\') v[i]=psn[i]-1+(y-psy[i]);\\n            else v[i]=psn[i]+(y-psy[i]);\\n        }\\n        // for(auto x:v) cout<<x<<\" \";\\n        int mi=*min_element(v.begin(),v.end());\\n        int idx=find(v.begin(),v.end(),mi)-v.begin();\\n\\n        // for(i=0;i<v.size();i++)\\n        // {\\n        //     if(v[i]<mi)\\n        //     {\\n        //         mi=v[i];\\n        //         idx=i+1;\\n        //     }\\n        // }\\n        if(y<=mi) return 0;\\n        if(y==0) return 0;\\n        return idx+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3974408,
                "title": "easy-solution-o-n-o-1-c-100-beat-explanation",
                "content": "\\n# Approach\\n    Firstly count all the penalties(all \\'N)\\n    Then traverse the string from right to left(from end)\\n    If ith is \\'Y\\' then penalty++ else penalty--\\n    Check if penalty is smaller then ans or not\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        int penalty = 0;\\n        for(auto it : customers)\\n            if(it == \\'N\\')\\n                penalty++;\\n        \\n        int i = n - 1;\\n        int ans = penalty;\\n        int result = n;\\n        while(i >= 0){\\n            if(customers[i] == \\'Y\\')\\n                penalty++;\\n            else{\\n                penalty--;\\n                if(penalty <= ans){\\n                    result = i;\\n                    ans = penalty;\\n                }\\n            }\\n            --i;\\n        }\\n        return result;\\n    }\\n};\\n```\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/f5984a3d-9752-4d74-beff-da8eb0f3c37b_1693283584.9963892.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.size();\\n        int penalty = 0;\\n        for(auto it : customers)\\n            if(it == \\'N\\')\\n                penalty++;\\n        \\n        int i = n - 1;\\n        int ans = penalty;\\n        int result = n;\\n        while(i >= 0){\\n            if(customers[i] == \\'Y\\')\\n                penalty++;\\n            else{\\n                penalty--;\\n                if(penalty <= ans){\\n                    result = i;\\n                    ans = penalty;\\n                }\\n            }\\n            --i;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974397,
                "title": "easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust Increment penality for \\'N\\' and decrement penality for \\'Y\\' and store index coresponding to min penality.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int pen=0;\\n        int cust=0;\\n        for(auto i:customers){\\n            if(i==\\'Y\\')\\n            cust++;\\n        }\\n        int Index=0;\\n        int minP=cust;\\n        for(int i=0;i<customers.size();i++){\\n            if(customers[i]==\\'N\\'){\\n                cust++;\\n            }\\n            else cust--;\\n            if(cust<minP){\\n                minP=cust;\\n                Index=i+1;\\n            }\\n          \\n        }\\n        return Index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int pen=0;\\n        int cust=0;\\n        for(auto i:customers){\\n            if(i==\\'Y\\')\\n            cust++;\\n        }\\n        int Index=0;\\n        int minP=cust;\\n        for(int i=0;i<customers.size();i++){\\n            if(customers[i]==\\'N\\'){\\n                cust++;\\n            }\\n            else cust--;\\n            if(cust<minP){\\n                minP=cust;\\n                Index=i+1;\\n            }\\n          \\n        }\\n        return Index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974300,
                "title": "java-easy-solution-o-n",
                "content": "# Intuition\\nGiven a log of customer visits to the shop, we need to identify the optimal time to close the shop to minimize the penalty. Naturally, we think about checking for each possible closing time. We can either simulate for each time and accumulate penalties or find a more efficient way to compute penalties for each hour. Using prefix and suffix sum arrays to calculate the number of hours without customers before and the number of customers after every hour seems like a potential solution.\\n\\n# Approach\\n1. First, we create two arrays:\\n\\n* customers_after: Represents the number of hours with customers from a given hour till the end.\\n* no_customers_before: Represents the number of hours without customers before a given hour (exclusive).\\n2. To populate customers_after:\\n\\n* We traverse the string customers in reverse order.\\n* For each \\'Y\\' we find, we increase the count for that hour.\\n* Additionally, the current hour count will also include the count from the next hour (because it represents all customers till the end from that hour).\\n3. To populate no_customers_before:\\n\\n* We traverse the string customers in forward order.\\n* For each \\'N\\' we find, we increase the count for the next hour.\\n* Every next hour will also include the count from the previous hour.\\n4. Finally, we traverse both the arrays together for each hour to calculate the sum of the penalty for that hour. We keep track of the minimum sum and its corresponding index.\\n\\n5. Return the index with the minimum penalty.\\n\\n# Complexity\\n- ***Time complexity:*** O(N)\\n\\n- ***Space complexity:*** O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        \\n        int length = customers.length();\\n\\n        int[] customers_after = new int[length+1];\\n        int[] no_customers_before = new int[length+1];\\n\\n        customers_after[length] = 0;\\n        for(int i=length-1;i>=0;i--){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                customers_after[i]++;\\n            }\\n            customers_after[i]+=customers_after[i+1];\\n        }\\n\\n        for(int i=0;i<length;i++){\\n            if(customers.charAt(i)==\\'N\\'){\\n                no_customers_before[i+1]++;\\n            }\\n            no_customers_before[i+1] += no_customers_before[i];\\n        }\\n\\n        int index = 0;\\n        int min_sum = Integer.MAX_VALUE;\\n\\n        for(int i=0;i<length+1;i++){\\n            if(no_customers_before[i]+customers_after[i]<min_sum){\\n                min_sum = no_customers_before[i] + customers_after[i];\\n                index = i;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        \\n        int length = customers.length();\\n\\n        int[] customers_after = new int[length+1];\\n        int[] no_customers_before = new int[length+1];\\n\\n        customers_after[length] = 0;\\n        for(int i=length-1;i>=0;i--){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                customers_after[i]++;\\n            }\\n            customers_after[i]+=customers_after[i+1];\\n        }\\n\\n        for(int i=0;i<length;i++){\\n            if(customers.charAt(i)==\\'N\\'){\\n                no_customers_before[i+1]++;\\n            }\\n            no_customers_before[i+1] += no_customers_before[i];\\n        }\\n\\n        int index = 0;\\n        int min_sum = Integer.MAX_VALUE;\\n\\n        for(int i=0;i<length+1;i++){\\n            if(no_customers_before[i]+customers_after[i]<min_sum){\\n                min_sum = no_customers_before[i] + customers_after[i];\\n                index = i;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974298,
                "title": "java-prefix-sum-easy",
                "content": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int n = customers.length();\\n        int[] yes = new int[n];\\n        int[] no = new int[n];\\n        int i = 0;\\n        if(customers.charAt(i) == \\'Y\\')\\n            yes[0] = 1;\\n        else\\n            no[0] = 1;\\n        for( i = 1 ; i < n ; i++){\\n            char c = customers.charAt(i);\\n            if(c == \\'Y\\'){\\n                yes[i] = yes[i-1] + 1;\\n                no[i] = no[i-1];\\n            }else{\\n                no[i] = no[i-1] + 1;\\n                yes[i] = yes[i-1];\\n            }\\n            // System.out.println(yes[i]+\"___\"+no[i]);\\n        }\\n        int ans = Integer.MAX_VALUE, h = -1;\\n        \\n        for(i = 0 ; i < n ; i++){\\n            int temp = 0;\\n            if(i == 0){\\n                ans = yes[n-1];\\n                h = 0;\\n                \\n                // System.out.println(ans+\" penalty for i \"+i);\\n                continue;\\n            }\\n            int penaltyLeft = no[i-1];\\n            int penaltyRight = n-i-(no[n-1] - no[i-1]);\\n            // // System.out.println(penaltyLeft+\" penalty \"+penaltyRight);\\n            temp = penaltyLeft + penaltyRight;\\n            // System.out.println(temp+\" penalty for i \"+i);\\n            if(temp < ans){\\n                ans = temp;\\n                h = i;\\n            }\\n        }\\n        if(ans > no[n-1]){\\n            h = n;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int n = customers.length();\\n        int[] yes = new int[n];\\n        int[] no = new int[n];\\n        int i = 0;\\n        if(customers.charAt(i) == \\'Y\\')\\n            yes[0] = 1;\\n        else\\n            no[0] = 1;\\n        for( i = 1 ; i < n ; i++){\\n            char c = customers.charAt(i);\\n            if(c == \\'Y\\'){\\n                yes[i] = yes[i-1] + 1;\\n                no[i] = no[i-1];\\n            }else{\\n                no[i] = no[i-1] + 1;\\n                yes[i] = yes[i-1];\\n            }\\n            // System.out.println(yes[i]+\"___\"+no[i]);\\n        }\\n        int ans = Integer.MAX_VALUE, h = -1;\\n        \\n        for(i = 0 ; i < n ; i++){\\n            int temp = 0;\\n            if(i == 0){\\n                ans = yes[n-1];\\n                h = 0;\\n                \\n                // System.out.println(ans+\" penalty for i \"+i);\\n                continue;\\n            }\\n            int penaltyLeft = no[i-1];\\n            int penaltyRight = n-i-(no[n-1] - no[i-1]);\\n            // // System.out.println(penaltyLeft+\" penalty \"+penaltyRight);\\n            temp = penaltyLeft + penaltyRight;\\n            // System.out.println(temp+\" penalty for i \"+i);\\n            if(temp < ans){\\n                ans = temp;\\n                h = i;\\n            }\\n        }\\n        if(ans > no[n-1]){\\n            h = n;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974283,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int l=customers.length();\\n        int y=0,n=0; // counting the number of Y and N.\\n        int ans=l; // result is stored in ans\\n        for(int i=l-1;i>=0;i--)\\n        {\\n            if(customers[i] == \\'Y\\')// if \\'Y\\' is there then increment y\\n            {\\n                y++;\\n                continue;// lower part will not execute\\n            }\\n            n++;// else increment n.\\n            if(n >= y)// if value of n >= y then we have to close the shop, so we get no penalty.\\n            {\\n                // initialize n and y to zero.\\n                n=0;\\n                y=0;\\n                // update result(ans) to i. and repeat the process\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int l=customers.length();\\n        int y=0,n=0; // counting the number of Y and N.\\n        int ans=l; // result is stored in ans\\n        for(int i=l-1;i>=0;i--)\\n        {\\n            if(customers[i] == \\'Y\\')// if \\'Y\\' is there then increment y\\n            {\\n                y++;\\n                continue;// lower part will not execute\\n            }\\n            n++;// else increment n.\\n            if(n >= y)// if value of n >= y then we have to close the shop, so we get no penalty.\\n            {\\n                // initialize n and y to zero.\\n                n=0;\\n                y=0;\\n                // update result(ans) to i. and repeat the process\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974282,
                "title": "an-intuitive-and-beginner-friendly-solution",
                "content": "# Intuition\\nSelf Intuitive\\n\\n# Complexity\\n- Time complexity: O(N) -- [Linear Time]\\n\\n- Space complexity: O(1)  -- [Constant space]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int ans = customers.size(), penality = 0;\\n        for(auto customer : customers) if(customer == \\'N\\') penality++; // count all penalities\\n\\n        int newPenality = penality, minPenSoFar = penality;\\n\\n        for(int i = customers.size()-1; i >= 0; i--) {\\n\\n            if(customers[i]==\\'Y\\') newPenality = penality+1;\\n\\n            else if(customers[i]==\\'N\\') newPenality = penality-1;\\n\\n            minPenSoFar = min(minPenSoFar, newPenality);\\n\\n            if(newPenality <= penality and newPenality == minPenSoFar) ans = i;\\n\\n            penality = newPenality;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int ans = customers.size(), penality = 0;\\n        for(auto customer : customers) if(customer == \\'N\\') penality++; // count all penalities\\n\\n        int newPenality = penality, minPenSoFar = penality;\\n\\n        for(int i = customers.size()-1; i >= 0; i--) {\\n\\n            if(customers[i]==\\'Y\\') newPenality = penality+1;\\n\\n            else if(customers[i]==\\'N\\') newPenality = penality-1;\\n\\n            minPenSoFar = min(minPenSoFar, newPenality);\\n\\n            if(newPenality <= penality and newPenality == minPenSoFar) ans = i;\\n\\n            penality = newPenality;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974133,
                "title": "prefix-sum-solution-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The code prepares two lists: one counting \"No\" customers before each time and the other counting \"Yes\" customers after each time.\\n2. Then, it checks each time as a potential closing time, calculates the penalty, and remembers the time with the lowest penalty.\\n3. After checking all times, it says when the business should close to face the least penalty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. It starts by counting how many \"No\" customers appear before each position in the day (morning to evening). This is stored in the prefixN array.\\n\\n2. Similarly, it counts how many \"Yes\" customers appear after each position in the day, but it does this in reverse order (evening to morning). This is stored in the suffixY array.\\n\\n3. Then, it goes through each possible closing time in the day and calculates the penalty by adding the \"No\" customers before that time (from prefixN) and the \"Yes\" customers after that time (from suffixY).\\n\\n4. It keeps track of the time that results in the minimum penalty. This will be the best time for the business to close.\\n\\n5. Finally, it returns the time that leads to the minimum penalty.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.length();\\n\\n        vector<int> prefixN(n+1,0);\\n\\n        vector<int> suffixY(n+1,0);\\n\\n        for(int i=1;i<=n;i++) {\\n            prefixN[i] = prefixN[i-1];\\n\\n            if(customers[i-1] == \\'N\\')\\n                prefixN[i]++;\\n        }\\n\\n\\n        for(int i=n-1;i>=0;i--) {\\n            suffixY[i] = suffixY[i+1];\\n\\n            if(customers[i] == \\'Y\\')\\n                suffixY[i]++;\\n        }\\n\\n\\n        int minPenalty = INT_MAX;\\n        int ind = 0;\\n\\n        int penalty = 0;\\n\\n        for(int i=0;i<=n;i++) {\\n            penalty = prefixN[i] + suffixY[i];\\n\\n            if(penalty < minPenalty) {\\n                minPenalty = penalty;\\n                ind = i;\\n            }\\n        }\\n\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.length();\\n\\n        vector<int> prefixN(n+1,0);\\n\\n        vector<int> suffixY(n+1,0);\\n\\n        for(int i=1;i<=n;i++) {\\n            prefixN[i] = prefixN[i-1];\\n\\n            if(customers[i-1] == \\'N\\')\\n                prefixN[i]++;\\n        }\\n\\n\\n        for(int i=n-1;i>=0;i--) {\\n            suffixY[i] = suffixY[i+1];\\n\\n            if(customers[i] == \\'Y\\')\\n                suffixY[i]++;\\n        }\\n\\n\\n        int minPenalty = INT_MAX;\\n        int ind = 0;\\n\\n        int penalty = 0;\\n\\n        for(int i=0;i<=n;i++) {\\n            penalty = prefixN[i] + suffixY[i];\\n\\n            if(penalty < minPenalty) {\\n                minPenalty = penalty;\\n                ind = i;\\n            }\\n        }\\n\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974108,
                "title": "the-best-solution-beats-100-space-and-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 8ms\\nBeats 100.00% of users with C\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- 6.92MB\\nBeats 100.00% of users with C\\n\\n\\n# Code\\n```\\nint bestClosingTime(char * customers){\\n  int n = strlen(customers) ;\\n  int  earliest = 0 , penalty = 0 , smallPenalty = 0; \\n\\n  // close at 0 , and at 1 , the only difference between these two is at the i = 0 ; \\n  // penalty will ++ if customers[0] == \\'Y\\'  ans , --  else , \\n      int j = 0 ;  // j is the closing hour \\n      int i = 0 ;\\n      penalty = 0 ;\\n      while( i < n ){  // first time , close from the 0\\'th hour.\\n          if (( customers[i] == \\'Y\\' && i >= j ) || ( customers[i] == \\'N\\' && i < j )){\\n              penalty ++ ;\\n          }\\n          i++ ;\\n      }\\n        smallPenalty = penalty ; \\n        // we must do earliest = j , but earliest it is already declared 0 and j is 0 ;\\n     \\n        for ( j= 1  ; j < n+1 ; j++){    //  everytime j will ++ , the difference between this case and the previous is in the hour ( j - 1 ) ,\\n //  it was closed and now opened\\n            if ( customers[j-1] == \\'N\\'){ \\n                penalty++ ;\\n            } \\n            else{\\n                penalty--;\\n            }\\n           \\n         if ( penalty < smallPenalty){\\n             smallPenalty = penalty ;\\n             earliest = j ;\\n            }\\n        \\n    }   \\n    \\n  return earliest ;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint bestClosingTime(char * customers){\\n  int n = strlen(customers) ;\\n  int  earliest = 0 , penalty = 0 , smallPenalty = 0; \\n\\n  // close at 0 , and at 1 , the only difference between these two is at the i = 0 ; \\n  // penalty will ++ if customers[0] == \\'Y\\'  ans , --  else , \\n      int j = 0 ;  // j is the closing hour \\n      int i = 0 ;\\n      penalty = 0 ;\\n      while( i < n ){  // first time , close from the 0\\'th hour.\\n          if (( customers[i] == \\'Y\\' && i >= j ) || ( customers[i] == \\'N\\' && i < j )){\\n              penalty ++ ;\\n          }\\n          i++ ;\\n      }\\n        smallPenalty = penalty ; \\n        // we must do earliest = j , but earliest it is already declared 0 and j is 0 ;\\n     \\n        for ( j= 1  ; j < n+1 ; j++){    //  everytime j will ++ , the difference between this case and the previous is in the hour ( j - 1 ) ,\\n //  it was closed and now opened\\n            if ( customers[j-1] == \\'N\\'){ \\n                penalty++ ;\\n            } \\n            else{\\n                penalty--;\\n            }\\n           \\n         if ( penalty < smallPenalty){\\n             smallPenalty = penalty ;\\n             earliest = j ;\\n            }\\n        \\n    }   \\n    \\n  return earliest ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974075,
                "title": "actual-brute-force-prefix-suffix-o-n-time-o-1-space-c",
                "content": "YouTube Video - https://www.youtube.com/watch?v=XHgelA78SGs\\n\\n```\\n//Approach-1 : T.C - O(n^2) - TLE\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.length();\\n        int minPenalty = INT_MAX;\\n        int minHour    = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            int j = i-1;\\n            int penalty = 0;\\n            //Find penalty when shop was open & we had \\'N\\'\\n            while(j >= 0) {\\n                if(customers[j] == \\'N\\') {\\n                    penalty++;\\n                }\\n                j--;\\n            }\\n            \\n            j = i;\\n            //Find penalty when shop was closed & we had \\'Y\\'\\n            while(j < n) {\\n                if(customers[j] == \\'Y\\') {\\n                    penalty++;\\n                }\\n                j++;\\n            }\\n            \\n            if(penalty < minPenalty) {\\n                minPenalty = penalty; \\n                minHour    = i;\\n            }\\n            \\n        }\\n        \\n        //Trying closing at nth Hour\\n        int nthHourPenalty = count(customers.begin(), customers.end(), \\'N\\');\\n        if(nthHourPenalty < minPenalty) {\\n                minPenalty = nthHourPenalty; \\n                minHour    = n;\\n        }\\n        \\n        return minHour;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (keeping track of count of \\'N\\' and \\'Y\\' for any index)\\n//Note that for any index i we close at that time, we want to know \\n//--how many \\'N\\' were there from [0, i-1]\\n//--how many \\'Y\\' were there from [i, n-1]\\n//T.C : O(n)\\n//S.C : O(n)\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n           = customers.length();\\n     \\n        vector<int> prefixN(n+1, 0);\\n        prefixN[0] = 0;\\n            \\n        vector<int> suffixY(n+1, 0);\\n        suffixY[n] = 0;\\n        \\n        for(int i = 1; i<=n; i++) {\\n            if(customers[i-1] == \\'N\\') {\\n                prefixN[i] = prefixN[i-1] + 1;\\n            } else {\\n                prefixN[i] = prefixN[i-1];\\n            }\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            if(customers[i] == \\'Y\\') {\\n                suffixY[i] = suffixY[i+1]+1;\\n            } else {\\n                suffixY[i] = suffixY[i+1];   \\n            }\\n        }\\n        \\n        int minPenalty = INT_MAX;\\n        int minHour    = INT_MAX;\\n        \\n        for(int i = 0; i<n+1; i++) {\\n            int currPenalty = prefixN[i] + suffixY[i];\\n            \\n            if(currPenalty < minPenalty) {\\n                minPenalty = currPenalty;\\n                minHour    = i;\\n            }\\n        }\\n        \\n        return minHour;\\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-3 - 2 Pass Solution\\n//(T.C : O(n)\\n//S.C : O(1)\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n           = customers.length();\\n        \\n        int minHour  = 0;\\n        int penalty  = count(begin(customers), end(customers), \\'Y\\');\\n        \\n        int minPenalty = penalty;\\n\\n        for(int i = 0; i< n ; i++) {\\n            \\n            if(customers[i] == \\'Y\\') {\\n                penalty--;\\n            } else {\\n                penalty++;\\n            }\\n            \\n            if(penalty < minPenalty) {\\n                minHour = i+1;\\n                minPenalty = penalty;\\n            }\\n        }\\n        \\n        return minHour;\\n        \\n    }\\n};\\n\\n\\n//Approach-4 (1 Pass solution)\\n//(T.C : O(n)\\n//S.C : O(1)\\n//Coming soon today\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 : T.C - O(n^2) - TLE\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n = customers.length();\\n        int minPenalty = INT_MAX;\\n        int minHour    = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            int j = i-1;\\n            int penalty = 0;\\n            //Find penalty when shop was open & we had \\'N\\'\\n            while(j >= 0) {\\n                if(customers[j] == \\'N\\') {\\n                    penalty++;\\n                }\\n                j--;\\n            }\\n            \\n            j = i;\\n            //Find penalty when shop was closed & we had \\'Y\\'\\n            while(j < n) {\\n                if(customers[j] == \\'Y\\') {\\n                    penalty++;\\n                }\\n                j++;\\n            }\\n            \\n            if(penalty < minPenalty) {\\n                minPenalty = penalty; \\n                minHour    = i;\\n            }\\n            \\n        }\\n        \\n        //Trying closing at nth Hour\\n        int nthHourPenalty = count(customers.begin(), customers.end(), \\'N\\');\\n        if(nthHourPenalty < minPenalty) {\\n                minPenalty = nthHourPenalty; \\n                minHour    = n;\\n        }\\n        \\n        return minHour;\\n    }\\n};\\n```\n```\\n//Approach-2 (keeping track of count of \\'N\\' and \\'Y\\' for any index)\\n//Note that for any index i we close at that time, we want to know \\n//--how many \\'N\\' were there from [0, i-1]\\n//--how many \\'Y\\' were there from [i, n-1]\\n//T.C : O(n)\\n//S.C : O(n)\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n           = customers.length();\\n     \\n        vector<int> prefixN(n+1, 0);\\n        prefixN[0] = 0;\\n            \\n        vector<int> suffixY(n+1, 0);\\n        suffixY[n] = 0;\\n        \\n        for(int i = 1; i<=n; i++) {\\n            if(customers[i-1] == \\'N\\') {\\n                prefixN[i] = prefixN[i-1] + 1;\\n            } else {\\n                prefixN[i] = prefixN[i-1];\\n            }\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            if(customers[i] == \\'Y\\') {\\n                suffixY[i] = suffixY[i+1]+1;\\n            } else {\\n                suffixY[i] = suffixY[i+1];   \\n            }\\n        }\\n        \\n        int minPenalty = INT_MAX;\\n        int minHour    = INT_MAX;\\n        \\n        for(int i = 0; i<n+1; i++) {\\n            int currPenalty = prefixN[i] + suffixY[i];\\n            \\n            if(currPenalty < minPenalty) {\\n                minPenalty = currPenalty;\\n                minHour    = i;\\n            }\\n        }\\n        \\n        return minHour;\\n    }\\n};\\n```\n```\\n//Approach-3 - 2 Pass Solution\\n//(T.C : O(n)\\n//S.C : O(1)\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n           = customers.length();\\n        \\n        int minHour  = 0;\\n        int penalty  = count(begin(customers), end(customers), \\'Y\\');\\n        \\n        int minPenalty = penalty;\\n\\n        for(int i = 0; i< n ; i++) {\\n            \\n            if(customers[i] == \\'Y\\') {\\n                penalty--;\\n            } else {\\n                penalty++;\\n            }\\n            \\n            if(penalty < minPenalty) {\\n                minHour = i+1;\\n                minPenalty = penalty;\\n            }\\n        }\\n        \\n        return minHour;\\n        \\n    }\\n};\\n\\n\\n//Approach-4 (1 Pass solution)\\n//(T.C : O(n)\\n//S.C : O(1)\\n//Coming soon today\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974057,
                "title": "easiest-approach-using-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n      priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n      int i=0;\\n      int sum=0;\\n      int n=customers.size();\\n      for(int i=0;i<n;i++){\\n          if(customers[i]==\\'Y\\'){\\n              sum+=1;\\n          }\\n      }\\n      pq.push({sum,0});\\n      while(i<n){\\n          if(customers[i]==\\'Y\\'){\\n              customers[i]=\\'N\\';\\n              sum-=1;\\n              pq.push({sum,i+1});\\n          }\\n          else{\\n              customers[i]=\\'Y\\';\\n              sum+=1;\\n              pq.push({sum,i+1});\\n          }\\n          i++;\\n      }\\n      int ans=pq.top().second;\\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n      priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n      int i=0;\\n      int sum=0;\\n      int n=customers.size();\\n      for(int i=0;i<n;i++){\\n          if(customers[i]==\\'Y\\'){\\n              sum+=1;\\n          }\\n      }\\n      pq.push({sum,0});\\n      while(i<n){\\n          if(customers[i]==\\'Y\\'){\\n              customers[i]=\\'N\\';\\n              sum-=1;\\n              pq.push({sum,i+1});\\n          }\\n          else{\\n              customers[i]=\\'Y\\';\\n              sum+=1;\\n              pq.push({sum,i+1});\\n          }\\n          i++;\\n      }\\n      int ans=pq.top().second;\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974055,
                "title": "easiest-approach-clean-code-beginner-friendly-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        vector<int> suffixofY(n+1,0);\\n        \\n        vector<int> prefixofN(n+1,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(customers[i-1]==\\'N\\')\\n            prefixofN[i]=prefixofN[i-1]+1;\\n            else\\n            {\\n            prefixofN[i]=prefixofN[i-1];\\n            }\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            if(customers[i]==\\'Y\\')\\n            suffixofY[i]=suffixofY[i+1]+1;\\n            else\\n            {\\n            suffixofY[i]=suffixofY[i+1];\\n            }\\n        }\\n        \\n        int minindx=0;\\n        int sum=0;\\n        int minval=INT_MAX;\\n        for(int i=0;i<=n;i++){\\n            sum=0;\\n            sum=sum+suffixofY[i]+prefixofN[i];\\n            if(sum<minval){\\n                minval=sum;\\n                minindx=i;\\n            }\\n\\n        }\\nreturn minindx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int n=customers.size();\\n        vector<int> suffixofY(n+1,0);\\n        \\n        vector<int> prefixofN(n+1,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(customers[i-1]==\\'N\\')\\n            prefixofN[i]=prefixofN[i-1]+1;\\n            else\\n            {\\n            prefixofN[i]=prefixofN[i-1];\\n            }\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            if(customers[i]==\\'Y\\')\\n            suffixofY[i]=suffixofY[i+1]+1;\\n            else\\n            {\\n            suffixofY[i]=suffixofY[i+1];\\n            }\\n        }\\n        \\n        int minindx=0;\\n        int sum=0;\\n        int minval=INT_MAX;\\n        for(int i=0;i<=n;i++){\\n            sum=0;\\n            sum=sum+suffixofY[i]+prefixofN[i];\\n            if(sum<minval){\\n                minval=sum;\\n                minindx=i;\\n            }\\n\\n        }\\nreturn minindx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973999,
                "title": "c-simple-solution-with-easy-explanation",
                "content": "\\n# Approach\\n1. First iterate through the customers string to count the number of \\'Y\\' and \\'N\\' customers.\\n2. Calculate the initial penalty (penal).\\n3. Set curr to the initial penalty value.\\n4. Iterate and Update the penalty based on whether the current customer is \\'Y\\' or \\'N\\'.\\n5. If the updated penalty is smaller than the current minimum penalty:\\n    =>Update curr to the updated penalty.\\n    =>Update index to the current index (i).\\n6. Return the index of minimum penalty\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Please Upvote if you understood it \\uD83D\\uDC4D\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int index = 0;\\n        int cuntY = 0, cuntN = 0;\\n\\n        for(int i = 0; i<customers.size(); i++){\\n            if(customers[i]==\\'Y\\'){\\n                cuntY++;\\n            }else{\\n                cuntN++;\\n            }\\n        }\\n        int penal = cuntY-cuntN;\\n        int curr = penal;\\n        for(int i = 1; i<=customers.size(); i++){\\n            char ch = customers[i-1];\\n            if(ch == \\'Y\\'){\\n                penal--;\\n                if(penal<curr){\\n                curr = penal;\\n                index=i;\\n                }\\n            }else{\\n                penal++;\\n                if(penal<curr){\\n                    curr = penal;\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int index = 0;\\n        int cuntY = 0, cuntN = 0;\\n\\n        for(int i = 0; i<customers.size(); i++){\\n            if(customers[i]==\\'Y\\'){\\n                cuntY++;\\n            }else{\\n                cuntN++;\\n            }\\n        }\\n        int penal = cuntY-cuntN;\\n        int curr = penal;\\n        for(int i = 1; i<=customers.size(); i++){\\n            char ch = customers[i-1];\\n            if(ch == \\'Y\\'){\\n                penal--;\\n                if(penal<curr){\\n                curr = penal;\\n                index=i;\\n                }\\n            }else{\\n                penal++;\\n                if(penal<curr){\\n                    curr = penal;\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973893,
                "title": "simple-php-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $customers\\n     * @return Integer\\n     */\\n    function bestClosingTime($customers) {\\n        $count = 0;\\n        $len = strlen($customers);\\n        for ($i = 0; $i < $len; $i++) {\\n            if ($customers[$i] == \\'Y\\') {\\n                $count++;\\n            }\\n        }\\n\\n        $min = $count;\\n        $minIndex = 0;\\n\\n        for ($i = 0; $i < $len; $i++) {\\n            if ($customers[$i] == \\'Y\\') {\\n                $count--; \\n            } else {\\n                $count++;\\n            }\\n\\n            if ($count < $min) {\\n                $min = $count;\\n                $minIndex = $i + 1;\\n            }\\n        }\\n\\n        return $minIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $customers\\n     * @return Integer\\n     */\\n    function bestClosingTime($customers) {\\n        $count = 0;\\n        $len = strlen($customers);\\n        for ($i = 0; $i < $len; $i++) {\\n            if ($customers[$i] == \\'Y\\') {\\n                $count++;\\n            }\\n        }\\n\\n        $min = $count;\\n        $minIndex = 0;\\n\\n        for ($i = 0; $i < $len; $i++) {\\n            if ($customers[$i] == \\'Y\\') {\\n                $count--; \\n            } else {\\n                $count++;\\n            }\\n\\n            if ($count < $min) {\\n                $min = $count;\\n                $minIndex = $i + 1;\\n            }\\n        }\\n\\n        return $minIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973881,
                "title": "c-simple-solution-9-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n           int p=0;\\n        for(auto i:customers) if(i==\\'Y\\') p=p+1;\\n       int mini = p, j = 0;\\n      for (int i = 0; i < customers.size(); ++i) {\\n        p += customers[i] == \\'Y\\' ? -1 : 1;\\n        if (p < mini) {\\n            mini = p;\\n            j = i + 1;\\n        }\\n    }\\n    return j;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/96609654-253f-4510-b344-01ed045ae7ba_1693270818.926386.webp)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n           int p=0;\\n        for(auto i:customers) if(i==\\'Y\\') p=p+1;\\n       int mini = p, j = 0;\\n      for (int i = 0; i < customers.size(); ++i) {\\n        p += customers[i] == \\'Y\\' ? -1 : 1;\\n        if (p < mini) {\\n            mini = p;\\n            j = i + 1;\\n        }\\n    }\\n    return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397313,
                "title": "c-easy-solution-beats-90-time-and-90-space",
                "content": "# Approach\\nGet the value value for the `0th` hour and use it for the other hours.\\n\\nSo for each hour look at the last hour, if it\\'s `\\'Y\\'` increase or `\\'N\\'` decrease by `1`\\nIf the result is inferior at your minimum penalties update it\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int minimumPenalties = 0, bestHour = 0, current = 0;\\n        int size = customers.size();\\n    \\n        // Getting the value if the shop is closed at 0th\\n        // So to each hour with customers (\\'Y\\') penalty increases by 1\\n        for (int i = 0; i < size; i++)\\n            if (customers[i] == \\'Y\\')\\n                minimumPenalties++;\\n        \\n        // For each hour change the value by looking the last hour and update the bestHour and the minimumPenalties accordingly\\n        current = minimumPenalties;\\n        for (int i = 1; i <= size; i++) {\\n            current += (customers[i-1] == \\'Y\\') ? -1 : 1;\\n            if (current < minimumPenalties) {\\n                bestHour = i;\\n                minimumPenalties = current;\\n            }\\n        }\\n        return bestHour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) {\\n        int minimumPenalties = 0, bestHour = 0, current = 0;\\n        int size = customers.size();\\n    \\n        // Getting the value if the shop is closed at 0th\\n        // So to each hour with customers (\\'Y\\') penalty increases by 1\\n        for (int i = 0; i < size; i++)\\n            if (customers[i] == \\'Y\\')\\n                minimumPenalties++;\\n        \\n        // For each hour change the value by looking the last hour and update the bestHour and the minimumPenalties accordingly\\n        current = minimumPenalties;\\n        for (int i = 1; i <= size; i++) {\\n            current += (customers[i-1] == \\'Y\\') ? -1 : 1;\\n            if (current < minimumPenalties) {\\n                bestHour = i;\\n                minimumPenalties = current;\\n            }\\n        }\\n        return bestHour;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264629,
                "title": "beats-100-c",
                "content": "# Intuition\\nBuild a prefix array \\nTreat Y as +1\\nN as -1 \\nThen took cumlative sum \\nThen look for smallest index with max profit(mal value in the preifx array ) which is equivalent to min penality \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) \\n    {\\n     vector<int> pre (customers.size(),0);\\n     int res = customers.size(); \\n     \\n     // build prefix array \\n     for(int i = 0; i<pre.size();i++)\\n     {\\n       if(customers[i]==\\'Y\\')\\n       pre[i] +=1; \\n       else pre[i] += -1;\\n       if(i!=0)\\n       pre[i] += pre[i-1];\\n     } \\n     int val = INT_MIN;\\n     for(auto x :pre)\\n      val = max(val,x);\\n\\n      if(val<=0)\\n      return  0; \\n      if(val==customers.size())\\n      return customers.size();\\n    \\n    for(int i =0 ; i<pre.size();i++)\\n    if(pre[i]==val)\\n    {\\n        res = i+1; \\n        break;\\n    }\\n\\n\\n    \\n\\n     return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bestClosingTime(string customers) \\n    {\\n     vector<int> pre (customers.size(),0);\\n     int res = customers.size(); \\n     \\n     // build prefix array \\n     for(int i = 0; i<pre.size();i++)\\n     {\\n       if(customers[i]==\\'Y\\')\\n       pre[i] +=1; \\n       else pre[i] += -1;\\n       if(i!=0)\\n       pre[i] += pre[i-1];\\n     } \\n     int val = INT_MIN;\\n     for(auto x :pre)\\n      val = max(val,x);\\n\\n      if(val<=0)\\n      return  0; \\n      if(val==customers.size())\\n      return customers.size();\\n    \\n    for(int i =0 ; i<pre.size();i++)\\n    if(pre[i]==val)\\n    {\\n        res = i+1; \\n        break;\\n    }\\n\\n\\n    \\n\\n     return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193657,
                "title": "solution-typescript-and-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction bestClosingTime(customers: string): number {\\n\\n    let ans :number = 0;\\n    let profit: number = 0;\\n    let maxProfit: number = 0;\\n\\n    for (let i = 0; i < customers.length; i++) {\\n      profit += customers[i] === \\'Y\\' ? 1 : -1;\\n      if (profit > maxProfit) {\\n        maxProfit = profit;\\n        ans = i + 1;\\n      }\\n    }\\n\\n return ans;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction bestClosingTime(customers: string): number {\\n\\n    let ans :number = 0;\\n    let profit: number = 0;\\n    let maxProfit: number = 0;\\n\\n    for (let i = 0; i < customers.length; i++) {\\n      profit += customers[i] === \\'Y\\' ? 1 : -1;\\n      if (profit > maxProfit) {\\n        maxProfit = profit;\\n        ans = i + 1;\\n      }\\n    }\\n\\n return ans;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2035178,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034851,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034835,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 1959852,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2035206,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2035608,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034815,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2035559,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034891,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 1946565,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2035178,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034851,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034835,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 1959852,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2035206,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2035608,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034815,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2035559,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034891,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 1946565,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "200 questions completed :-)"
                    },
                    {
                        "username": "PolYarik",
                        "content": "[@dingwalnitin](/dingwalnitin) Mostly because I do a lot of easy problems (66%), but still - thank you!\\nYou are doing great too - didn\\'t miss a single day, wow\\nWhile speed may impress someone, perseverance is much more important\\n\\nGood luck on this website and with your career!"
                    },
                    {
                        "username": "nikalinov",
                        "content": "waaaaaaaaaaaaaaaaaaaaw"
                    },
                    {
                        "username": "Slegendz",
                        "content": "Next Target: 500\\nAll the Best!"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "the grind must go on "
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "[@PolYarik](/PolYarik) dude you and i started nearly the same time, you are on fire, you are literally gliding through leetcode."
                    },
                    {
                        "username": "PolYarik",
                        "content": "That's some dedication! Keep going 🔥\nI'm not quite there yet, but trying to solve at least a problem or two every day :>\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this problems is worded terribly... maximize the total profit and return the earliest hour that profit is achieved "
                    },
                    {
                        "username": "lapartman",
                        "content": "Thank you, I wish all problems had simple, concise, and easy to understand descriptions like your example (if the complexity of the problem allows it ofc). When I\\'m already tired and only have time to begin practicing at like 20:30, the last thing I want to do is figuring out what the problem is even asking for. This task\\'s description didn\\'t need to be longer than a sentence, complete waste of time."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "And here I thought this question is comparatively better worded"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Given that that the hint tells you exactly what to do and the fact that the problem is not much more than a linear scan twice. This is really more of an easy problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@mshoosterman](/mshoosterman) how"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@rhymes17](/rhymes17) Once you come up with a 2 scan solution, it isn\\'t hard to see that the first scan is completely useless. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "The problem is a medium one because you need to come up with a solution that works in only one linear scan, i.e. one pass solution.\\nTry solving it in O(1) space and a single O(n) scan.\\nHappy Coding!"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Yes, I feel the hint should just give a direction not the whole solution.\nAt least the first one.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that I managed to get the solution without looking at either the hint or the editorial and my submission succeeded first time, I can't disagree."
                    },
                    {
                        "username": "arturszogla",
                        "content": "Was getting TLEs just because I forgot to comment out the debug prints to stdout. Turns out 10^5 calls to print take a lot of time. Gotta be careful, what code you submit as the final version."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@user5400vw](/user5400vw) Not just competitive programming, but computer science in general. Files/Byte Streams for I/O, Network requests are the bottlenecks, otherwise the CPU is very fast."
                    },
                    {
                        "username": "user5400vw",
                        "content": "first rule of competitive programming - remove your console logs "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Damn, I saw your linkedIn profile, you are 2007 CS PhD and still doing leetcode, cool!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I\\'ve made that mistake more than once, but I remember getting \"output limit exceeded\"."
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Solving the question was easier than Understanding the question"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/Ad5rVdW\">\\n  <img src=\"https://i.imgur.com/Ad5rVdW.jpg\" title=\"source: imgur.com\" width=\"300px\" style=\"height: 350px;\" />\\n</a>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "penalty is the sum of prefix count of ‘N’ and suffix count of ‘Y’! Just follow the hint! \nLet's consider the testcase \"NYYYNNNYNN\". The process is shown as follows.\n```\n0: nn=0 y_rem=4 penalty=4\n1: nn=1 y_rem=4 penalty=5\n2: nn=1 y_rem=3 penalty=4\n3: nn=1 y_rem=2 penalty=3\n4: nn=1 y_rem=1 penalty=2\n5: nn=2 y_rem=1 penalty=3\n6: nn=3 y_rem=1 penalty=4\n7: nn=4 y_rem=1 penalty=5\n8: nn=4 y_rem=0 penalty=4\n9: nn=5 y_rem=0 penalty=5\n10: nn=6 y_rem=0 penalty=6\nminI=4\n```"
                    },
                    {
                        "username": "udaygupta11",
                        "content": "what was your though process or how you arrived to this logic??"
                    },
                    {
                        "username": "IhorPryyma",
                        "content": "thanks. that example helped me to understand task :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shivang_101](/Shivang_101) I think that it is the problem for defining nn. My nn is the number of \\'N\\' before hour i. In previous version  \\'N\\'  at hour is included."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "[@user0411bt](/user0411bt) exactly same question at j=4 penalty is 2 which is the minimum"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@user0411bt](/user0411bt) Thanks! I\\'ve corrected it!"
                    },
                    {
                        "username": "user0411bt",
                        "content": "how at 1: prefix count of \\'N\\' is 2?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) In fact, there is no need for computing the real penalty, but just the correct increments for penalty. So, one for loop is good enough!"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Penalty at 0th hour must be 4, but\nNice and intuitive approach of time complexity $$O(n)$$,\nI actually did the same but with creating array but it can be done by simply using two variables in space complexity of $$O(1)$$"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "it's more like a `sliding window`\nand some helpful test cases \n`NNNYNN`\n`YYNYNYN`\n`YN`\n`NYYYNNNYNN`\n\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thanks"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "I have solved it using the prefix sum approach, but now I\\'m curious \\uD83E\\uDD14\\uD83D\\uDCAD about how to tackle it using the sliding window technique. Could you please explain the intuition and steps involved in elaborating on the solution using the sliding window approach? Your insights would be greatly appreciated."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nIt\\'s relatively easy to deduce that we need prefix and suffix count of Ys and Ns. But there are some edge cases which can be frustrating. For eg, see the test case 3, you can close the shop at `(last+1)th`hour also.\\n\\nTo handle such cases, you can add one more element to your prefix and suffix array like this:\\n\\n`if(customers.back()==\\'Y\\')`\\n    `{yes.push_back(last_element_of_yes - 1);`\\n    `no.push_back(total_count_of_no);}`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@janis__](/janis__) chat gpt reply??\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The user points out the subtlety of the problem where it\\'s possible to close the shop an hour after the last recorded hour if a customer comes in at the last hour. By adjusting the prefix and suffix arrays accordingly, it ensures that the algorithm considers this scenario, making it more robust and versatile in determining the optimal shop closing time."
                    },
                    {
                        "username": "jaggz01",
                        "content": "The problem can be solved by maximizing the profit goal. When a customer log has Y, the profit increases, and when it is N the profit decreases.\\n\\nNow, when the profit is maximum, then return the index+1"
                    }
                ]
            },
            {
                "id": 2034943,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2035759,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2035594,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2035591,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2035167,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2034980,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2034929,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2034811,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2034965,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2039587,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "What would be the penalty if the shop closed before hour 0?\nHow would this penalty change if the shop closed before hour 1?\nGiven the penalty for closing before hour ``i``, how would the penalty change if the shop closed before hour ``i+1``?\nDo you need to know the actual value of the penalty at each step of the traversal or is just knowing how the penalty changes at each step sufficient?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I find that it is always possible to improve on your existing code. For example, I just realized that you don't need to know the actual value of the penalty to solve this problem. You only need to know how it changes as you iterate through the array. So a single traversal is all you need. However, in order to avoid using the ``strlen()`` function (which does a separate traversal of the string), I had to duplicate the code in the loop for the Nth case. (Ironically, my submission time increased from 7 ms to 8 ms when I did this). https://leetcode.com/submissions/detail/1035569724/"
                    },
                    {
                        "username": "janis__",
                        "content": "[@psionl0](/psionl0) I have to improve myself, thank you."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@janis__](/janis__) I think you\\'ve got it but you didn\\'t really need to use two separate arrays to solve this. https://leetcode.com/submissions/detail/1034625504/"
                    },
                    {
                        "username": "janis__",
                        "content": "Closing before hour 0: The penalty equates to the sum of all \\'Y\\' entries.\\nBefore hour 1: Deduct from the previous penalty based on the value at hour 0: -1 for \\'Y\\', 0 change for \\'N\\'.\\nBefore hour i+1: Update the penalty from hour i by: -1 for \\'Y\\' and +1 for \\'N\\' at hour i."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "just do Enumerate all indices and find the minimum such value. \\nAt any index, the penalty is the sum of prefix count of \\u2018N\\u2019 and suffix count of \\u2018Y\\u2019.\\n\\n"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "How often do you see shops close at 1000th hour?"
                    },
                    {
                        "username": "psionl0",
                        "content": "A 24/7 shop that goes out of business might."
                    },
                    {
                        "username": "Martician",
                        "content": "The description is the only reason why this question is medium"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro I am frustrated with the descriptions"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "why is the answer for \"YN\" --> 1 ??\\n\\nIf the shop closes at 0 -> penalty is 1 + 0 = 1\\nif the shop closes at 1 -> penalty is 0 + 1 = 1\\n\\nso shouldn\\'t the answer be --> 0 ??"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[@user5400vw](/user5400vw) oh right, my bad :("
                    },
                    {
                        "username": "user5400vw",
                        "content": "if shop closes at 0, penalty is 0 + 1\nif shop closes at 1, penalty is 0 + 0.  \n(and dont forget) if shop closes at 2, penalty is 0 + 1"
                    },
                    {
                        "username": "aitachii",
                        "content": "The penalties for examples 2 and 3 are as follows:\nExample 2: `customers = \"NNNNN\"`\nThe penalty when closing at time: 0 is: 0 penalty\nThe penalty when closing at time: 1 is: 1 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 3 penalty\nThe penalty when closing at time: 4 is: 4 penalty\n\nExample 3: `customers = \"YYYY\"`\nThe penalty when closing at time: 0 is: 4 penalty\nThe penalty when closing at time: 1 is: 3 penalty\nThe penalty when closing at time: 2 is: 2 penalty\nThe penalty when closing at time: 3 is: 1 penalty\nThe penalty when closing at time: 4 is: 0 penalty\n\nBonus: `customers = \"YNYY\"`\nThe penalty when closing at time: 0 is: 3 penalty\nThe penalty when closing at time: 1 is: 2 penalty\nThe penalty when closing at time: 2 is: 3 penalty\nThe penalty when closing at time: 3 is: 2 penalty\nThe penalty when closing at time: 4 is: 1 penalty\n"
                    },
                    {
                        "username": "h_rajput",
                        "content": "Why lower bound is not working in this case?\n`class Solution {\npublic:\n    int bestClosingTime(string customers) {\n        int n=customers.size();\n        vector<int> ans(n+1,0);\n        int maximum=0;\n        \n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i-1]+ ( (customers[i-1]=='Y')? +1: -1);\n            maximum=max(maximum, ans[i]);\n        }\n       \n        auto itr= lower_bound(ans.begin(), ans.end(),maximum)-ans.begin();\n        return itr;\n        \n\n    }\n};`\n\n`customers =\"YNY\" \nOutput=3 \nExpected=1`\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The issue is that lower_bound returns the first position where maximum could be inserted without violating the order. For this problem, you actually need the position of the first occurrence of maximum in the ans vector. Use find() instead of lower_bound() to get the correct position."
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>The Prefix applies to the victim</strong>\n![leetcode](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExeXFnd3ZqeDFlNTJmd3dsdTMyanR5M20xZjVtdndhajhpZmh0ZGY0aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orieV94MAL3OLlOAU/giphy.gif)"
                    },
                    {
                        "username": "crocedev",
                        "content": "It's possible to ~~solve~~ return early without necessarily traversing the entire `customers` string.\n\n*(edited to fix misleading wording)*"
                    },
                    {
                        "username": "crocedev",
                        "content": "[@wafsinc](/wafsinc)  Poor wording on my part to say \"solve\" when what I meant to suggest is a solution can return early."
                    },
                    {
                        "username": "janis__",
                        "content": "By using a prefix sum of \\'Y\\'s, we can calculate penalties on-the-fly and pinpoint the optimal closure time in a single pass through the customers string, reducing time complexity."
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@aitachii](/aitachii) No, this is not what \"possible\" means in this context. In the context of programing/computer science, saying something like \"It\\'s possible to solve without necessarily traversing the entire string\" means \"There exists an algorithm that does not traverse the entire string for any input\"."
                    },
                    {
                        "username": "aitachii",
                        "content": "That\\'s what \"possible\" means. There is a chance for the algorithm to end early."
                    },
                    {
                        "username": "wafsinc",
                        "content": "No it\\'s not. Your solution still traverses the entire string in the worst case."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "wat"
                    },
                    {
                        "username": "lovely08",
                        "content": "I tried to solve by binary Search first on my own without looking anything but was getting 15/42 correct has anyone done this problem with binary search."
                    },
                    {
                        "username": "lovely08",
                        "content": "[@prashant_04](/prashant_04)  I am talking about doing this binary search can you share your code if you did by binary search."
                    },
                    {
                        "username": "prashant_04",
                        "content": "Yeah i iterated the string twice first to get the total counts of Y\\'s and then in the next loop i calculated the penalty for the closing the shop at each hour "
                    }
                ]
            },
            {
                "id": 2036375,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036365,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036348,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036344,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036276,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036156,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036151,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036148,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036140,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036107,
                "content": [
                    {
                        "username": "dhruvsakariya",
                        "content": "Discussion >>>>>>>>>>>> Solutions"
                    },
                    {
                        "username": "StevenGregn",
                        "content": "Very similar to best time to buy and sell stock in my opinion. The wording is what makes this problem difficult."
                    },
                    {
                        "username": "RivnaT",
                        "content": "50 Questions Completed!"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Fortunately, I gained insight into the problem after encountering \"Prefix Sum\" in the related topics. I conducted dry runs on numerous test cases generated by ChatGPT. Based on this, I devised my own solution, which involves two arrays: the first assuming the shop is closed from the 0th hour, and the second assuming it remains open until the end. By utilizing these two arrays, I was able to calculate the minimum incurred penalty. I submitted the solution and it was accepted with success! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Please tell me what is wrong with my code:-\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n       \\n        int n=customers.length();\\n        int mini=Integer.MAX_VALUE;\\n        // int[] index=new int[customers.length()];\\n        int indi= 0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            int count_n=0,count_y=0;\\n            for(int nn=0;nn<=i;nn++)\\n            {\\n                if(customers.charAt(nn)==\\'N\\')\\n                count_n++;\\n            }\\n           for(int yy=i+1;yy<n;yy++)\\n            {\\n                if(customers.charAt(yy)==\\'Y\\')\\n                count_y++;\\n            }\\n\\n            if(mini > count_n+count_y )\\n            {\\n                mini=count_n+count_y;\\n                indi=i;\\n            }\\n     \\n\\n        }\\n\\n    \\n       return indi+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "```\nclass Solution {\n    public int bestClosingTime(String customers) {\n        int totalCustomers = 0;\n        for (char c : customers.toCharArray()) {\n            if (c == 'Y') {\n                totalCustomers++;\n            }\n        }\n\n        int currentPenalty = totalCustomers;\n        int minPenalty = totalCustomers;\n        int bestClosingHour = 0;\n\n        for (int hour = 0; hour < customers.length(); hour++) {\n            if (customers.charAt(hour) == 'Y') {\n                currentPenalty--;\n            } else {\n                currentPenalty++;\n            }\n\n            if (currentPenalty < minPenalty) {\n                minPenalty = currentPenalty;\n                bestClosingHour = hour + 1; // We are 0-indexed, but the problem is 1-indexed\n            }\n        }\n\n        return bestClosingHour;\n    }\n}\n```\nAbsolutely, I'd be happy to explain the solution in a nutshell:\n\n1. **Total Customers Count:** We begin by counting the total number of 'Y' customers, as they are the ones who actually enter the shop.\n\n2. **Initialization:** We initialize two variables, `currentPenalty` and `minPenalty`, both with the value of the total number of customers. This sets the initial penalty as if the shop is closed at all hours.\n\n3. **Iterating Through Hours:** We then iterate through each hour, considering the shop's status and the customers present at that hour.\n\n   - If a customer is present ('Y'), we decrement `currentPenalty` by 1 because a customer is in the shop.\n   - If no customer is present ('N'), we increment `currentPenalty` by 1 because the shop is open but no customer is there.\n\n4. **Updating Minimum Penalty:** At each step, we compare `currentPenalty` with the current minimum penalty, `minPenalty`. If `currentPenalty` is smaller, we update `minPenalty` and record the current hour as the `bestClosingHour`.\n\n5. **Returning Result:** After iterating through all hours, we return the `bestClosingHour`, which corresponds to the hour where the penalty is minimized.\n\nThe approach works by simulating different closing times and updating the penalties based on the number of customers present. The key insight is that the change in penalty is determined by the difference between 'Y' and 'N' customers at each hour. The solution ensures that it captures the best closing hour that minimizes the penalty."
                    },
                    {
                        "username": "kos2kos",
                        "content": "Why is \"YNY\" expected outcome 1. Shouldn\\'t it be 3? Have the shop stay open all 3 hours? you incur min penalties."
                    },
                    {
                        "username": "psionl0",
                        "content": "The penalty is the same for hour = 1 as it is for hour = 3 and we are required to return the minimum hour."
                    },
                    {
                        "username": "khe1154",
                        "content": "the description is a little hard to understand and story in question does not make a lot of sense but i had fun solving it \\uD83D\\uDE00"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "This post has some advice and a detailed(not language specific) [solution link](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3978131/simple-detailed-explanation-beats-100-space-and-time/) , choose whichever you\\'re in need of, hope it helps you progress, keep up the hard work, you\\'re doing great! :)\\n\\nI\\'ve wasted around 2 hours on it, sometimes it takes a while for a question to click and that is okay! Whats important is to not give up and keep pushing through till you eventually get an hang of it.\\n\\nI was hard stuck with this question , using 2 traversals , one from front and back and then adding, finding min and doing all sorts of things to make it work. But sometimes all it takes is a clean slate, a fresh code from start is easier to work with than a jumbled mess. Comment out your progress so far if you\\'re afraid of losing it and start afresh! It sure did work for me, hope it does for you too!\\n\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this is medium because 75% of the difficulty is understading the \"upside\" down description."
                    },
                    {
                        "username": "MewGrenade",
                        "content": "This should be an easy question"
                    }
                ]
            },
            {
                "id": 2036063,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2036049,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2036000,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2035990,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2035967,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2035963,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2035921,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2035666,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2035558,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2035556,
                "content": [
                    {
                        "username": "programmer0073",
                        "content": "In the example: YYNY\\nFor shop closed at 0th Hour, first our customer comes but shop is closed, but next hour shop is open and customer also comes, so how can be palenty 1 for this?\\n\\nShould not it be 1 + 0 + 1 + 0  = 2?\\n\\nThis question is confusing."
                    },
                    {
                        "username": "sapercq",
                        "content": "TLE Error:((  \\n\\n StringBuilder sb = new StringBuilder(customers);\\n        int ans =sb.toString().replaceAll(\"[^Yy]\",\"\").length();\\n        int ans1 = 0;\\n        for(int i = 0 ; i < customers.length();i++){\\n            int quickmath = sb.substring(i+1,customers.length()).replaceAll(\"[^Yy]\",\"\").length() + sb.substring(0,i+1).replaceAll(\"[^Nn]\",\"\").length();\\n            if(quickmath<ans){\\n                ans = quickmath;\\n                ans1 = i+1;\\n\\n            }\\n\\n        }\\n        return ans1;"
                    },
                    {
                        "username": "sapercq",
                        "content": "made this and now it's not 30,its 33 im evolving!! \n\n\n\n int ans = 0;\n        int ans1 = 0;\n        int ans2 = 0;\n        List<Integer> list  = new ArrayList<>();\n\n\n        for(int i = 0 ; i<customers.length();i++){\n            list.add((int)customers.charAt(i));\n        }\n        for(int a : list){\n            ans1 += a%2;\n        }\n        for(int i = 0 ; i<list.size();i++){\n            for(int j = 0 ; j<list.size();j++){\n                if(j <= i){\n\n                    if(list.get(j) % 2 == 0){\n                        ans+=1;\n                    }\n\n                }\n                else{\n                    ans+=list.get(j)%2;\n                }\n\n\n            }\n            if(ans < ans1){\n                ans1 = ans;\n                ans2 = i+1;\n            }\n            ans =0;\n\n\n\n\n        }\n\n\n\n\n\nreturn ans2;\nI guess it's a lot easier with Streams but i don't wanna use it\n"
                    },
                    {
                        "username": "RedFiend",
                        "content": "I have runtime error, but my solution is correct in vscode. May you tell me what is the problem? \\nError: \\n`TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 42 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 14 in _serialize_int (./python3/__serializer__.py)\\nLine 63 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 33 in _driver (Solution.py)`\\n\\nMy solution: \\n `class Solution:\\n    def bestClosingTime(self, customers: str) -> int: \\n        minpenalty = 100001\\n        indx = 100001\\n        for i in range(len(customers)+1):\\n            s1 = len(customers[:i].replace(\"Y\", \"\"))\\n            s2 = len(customers[i:].replace(\"N\",\"\"))\\n            if s1+s2 < minpenalty: \\n                minpenalty = s1+s2\\n                indx = i\\n        print(indx)`"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "problem can be solve by simple counting of number of \\'Y\\'\\nfollow this hint and go forward"
                    },
                    {
                        "username": "MagicTouch",
                        "content": "why if i use link on customers i will  get bigger time?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Would you not want to close at the Third hour? \\nSo Y Y (closed penalty +1) Y = 1 how is it 2 penalty?\\n\\nInput: customers = \"YYNY\"\\nOutput: 2\\nExplanation: \\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\\n\\nDoes the shop not reopen? Is the shop not open until the third hour? I don\\'t fully understand\\n"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Relax guys, Question is marked as medium just because you have to do that in single iteration. \\nOtherwise it\\'s easy to be put in medium category."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I dont know how this guys are coding....I still need more training to understand the problem,"
                    },
                    {
                        "username": "janis__",
                        "content": "The code determines the best time to close by iteratively calculating the penalty of closing after each customer. It keeps track of the smallest penalty and the corresponding time, ensuring that as few \\'N\\' (not-served) customers as possible are left after closing."
                    },
                    {
                        "username": "devle79",
                        "content": "Definitely easy"
                    },
                    {
                        "username": "shailika",
                        "content": "I'm getting TLE for my solution.\n\nclass Solution {\n    public  int bestClosingTime(String c) {\n        int n = c.length();\n        int val[] = new int[n+1];\n\n        for(int i=0; i<=n; i++){\n            int sum=0;\n            int k=0;\n            // if shop is open\n            while(k<i){\n                if(c.charAt(k) == 'Y') sum += 0;\n                else if(c.charAt(k) == 'N')sum += 1;\n                k++;\n            }\n            int j = i;\n            // if shop is closed\n            while(j<n){\n                if(c.charAt(j) == 'Y') sum += 1;\n                else if(c.charAt(j) == 'N')sum += 0;\n                j++;\n            }\n\n            val[i]=sum;\n        }\n\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;  \n\n        for(int i=0; i<val.length; i++){\n            if(val[i] < minValue){\n            minValue = val[i];\n            minIndex = i;\n            }\n        }\n\n        return minIndex;\n    }\n}\n\n\nTestCase : 33\nwhich have 50k words."
                    },
                    {
                        "username": "chrismaruca",
                        "content": "your solution has a time complexity of O(n^2), you can do it faster with a different algorithm"
                    }
                ]
            },
            {
                "id": 2035529,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035499,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035491,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035438,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035410,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035300,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035284,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035259,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035224,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            },
            {
                "id": 2035189,
                "content": [
                    {
                        "username": "Demaxl",
                        "content": "Can you please make the descriptions easier to understand"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Here  I [explain](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975872/c-99-4-faster-easy-to-understand-easy-to-code-array-prefix-sum-string/) the prefix sum approach nicely , do checkout."
                    },
                    {
                        "username": "azadkumar",
                        "content": "IMO: It should be in easy category instead of medium."
                    },
                    {
                        "username": "aashutosh148",
                        "content": "mhen! things were good when i didn\\'t know about that Hint button... Fellas, This is easily solvable without using Prefix or suffix count... Give yourself some time"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "Know the core intuition for solving it below !!\\nhttps://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3975643/core-idea-of-approach/"
                    },
                    {
                        "username": "125156048",
                        "content": "Hint:\\n\\nPenalty decreases by 1, if you take in Y and penalty increases by 1 if you take in N,\\nboth from the max possible penalty"
                    },
                    {
                        "username": "hanse413",
                        "content": "i need help shortening the runtime. logic seems correct though.\\nclass Solution:\\n    def bestClosingTime(self, customers: str) -> int:            \\n        def penaltycalculator(closing_hour,customers,penalty = {}):\\n            if customers[0] == \"Y\":\\n                penalty[0] = 1 + customers[1:].count(\"Y\")\\n            else:\\n                penalty[0]= customers[1:].count(\"Y\")\\n            \\n            if closing_hour in penalty:\\n                return penalty[closing_hour]\\n            elif closing_hour < len(customers):\\n                if customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"Y\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                elif customers[closing_hour] == \"N\" and customers[closing_hour-1] == \"N\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n            elif closing_hour == len(customers):\\n                if customers[-1] == \"Y\":\\n                    penalty[closing_hour] = penalty[closing_hour-1]-1\\n                    return penalty[closing_hour]\\n                else:\\n                    penalty[closing_hour] = penalty[closing_hour-1]+1\\n                    return penalty[closing_hour]\\n                                       \\n        best_closing_hour = None\\n        for i in range(0,len(customers)+1):\\n            if best_closing_hour == None or penaltycalculator(i,customers) < penaltycalculator(best_closing_hour,customers):                \\n                best_closing_hour = i \\n\\n        return best_closing_hour "
                    },
                    {
                        "username": "algoacer",
                        "content": "Easy Prefix sum problem. Tip: \\n1. got to increase the index by one while calculating answer.\\n2. Don\\'t consider yes/no of the hour we are calculating for."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i [explained](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974771/single-pass-prefix-sum-o-n-solution-with-explanation/) prefix suffix sum approach nicely here"
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Don\\'t over think it. Based on the constraints you can solve it in O(n) time.\\n\\nThe question\\'s example gives you a huge hint on how to solve it.\\nSimply look at the pattern of 0s and 1s from the example and how they change and what impact it has on the penalty score.\\n\\nMy solution is posted in today\\'s daily question post if anyone wants to look at it."
                    }
                ]
            }
        ]
    }
]