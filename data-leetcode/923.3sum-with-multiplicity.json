[
    {
        "title": "3Sum With Multiplicity",
        "question_content": "Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.\nAs the answer can be very large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: arr = [1,1,2,2,3,3,4,4,5,5], target = 8\nOutput: 20\nExplanation: \nEnumerating by the values (arr[i], arr[j], arr[k]):\n(1, 2, 5) occurs 8 times;\n(1, 3, 4) occurs 8 times;\n(2, 2, 4) occurs 2 times;\n(2, 3, 3) occurs 2 times.\n\nExample 2:\n\nInput: arr = [1,1,2,2,2,2], target = 5\nOutput: 12\nExplanation: \narr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:\nWe choose one 1 from [1,1] in 2 ways,\nand two 2s from [2,2,2,2] in 6 ways.\n\nExample 3:\n\nInput: arr = [2,1,3], target = 6\nOutput: 1\nExplanation: (1, 2, 3) occured one time in the array so we return 1.\n\n&nbsp;\nConstraints:\n\n\t3 <= arr.length <= 3000\n\t0 <= arr[i] <= 100\n\t0 <= target <= 300",
        "solutions": [
            {
                "id": 181131,
                "title": "c-java-python-o-n-101-101",
                "content": "Count the occurrence of each number.\\nusing hashmap or array up to you.\\n\\nLoop `i` on all numbers,\\nloop `j` on all numbers,\\ncheck if `k = target - i - j` is valid.\\n\\nAdd the number of this combination to result.\\n3 cases covers all possible combination:\\n1. `i == j == k` \\n2. ` i == j != k`\\n3. `i < k && j < k`\\n\\n**Time Complexity**:\\n`3 <= A.length <= 3000`, so N = 3000\\nBut `0 <= A[i] <= 100`\\nSo my solution is `O(N + 101 * 101)`\\n\\n**C++:**\\n```\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int threeSumMulti(int[] A, int target) {\\n        long[] c = new long[101];\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (int i = 0; i <= 100; i++)\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k > 100 || k < 0) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return (int)(res % (1e9 + 7));\\n    }\\n```\\n**Python:**\\n```\\n    def threeSumMulti(self, A, target):\\n        c = collections.Counter(A)\\n        res = 0\\n        for i, j in itertools.combinations_with_replacement(c, 2):\\n            k = target - i - j\\n            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\\n            elif i == j != k: res += c[i] * (c[i] - 1) / 2 * c[k]\\n            elif k > i and k > j: res += c[i] * c[j] * c[k]\\n        return res % (10**9 + 7)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\n```\n```\\n    public int threeSumMulti(int[] A, int target) {\\n        long[] c = new long[101];\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (int i = 0; i <= 100; i++)\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k > 100 || k < 0) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return (int)(res % (1e9 + 7));\\n    }\\n```\n```\\n    def threeSumMulti(self, A, target):\\n        c = collections.Counter(A)\\n        res = 0\\n        for i, j in itertools.combinations_with_replacement(c, 2):\\n            k = target - i - j\\n            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\\n            elif i == j != k: res += c[i] * (c[i] - 1) / 2 * c[k]\\n            elif k > i and k > j: res += c[i] * c[j] * c[k]\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 181128,
                "title": "10-lines-super-super-easy-java-solution",
                "content": "## Think Outside of The Box! \\nIntuitively, you will try to solve it based on the solution of 3Sum.\\nBut... Build a map for counting different sums of two numbers. The rest of things are straightfoward.\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int res = 0;\\n        int mod = 1000000007;\\n        for (int i = 0; i < A.length; i++) {\\n            res = (res + map.getOrDefault(target - A[i], 0)) % mod;\\n            \\n            for (int j = 0; j < i; j++) {\\n                int temp = A[i] + A[j];\\n                map.put(temp, map.getOrDefault(temp, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int res = 0;\\n        int mod = 1000000007;\\n        for (int i = 0; i < A.length; i++) {\\n            res = (res + map.getOrDefault(target - A[i], 0)) % mod;\\n            \\n            for (int j = 0; j < i; j++) {\\n                int temp = A[i] + A[j];\\n                map.put(temp, map.getOrDefault(temp, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123612,
                "title": "c-super-simple-7-line-solution-without-sorting",
                "content": "Use a map to count all sums of two numbers.\\nThen, if target - arr[i] is in map, it means we have a three-sum, so we add it to the result.\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918718,
                "title": "python-3sum-approach-with-explanation",
                "content": "### Introduction\\n\\nGiven an array of integers `arr`, determine how many tuples `(i, j, k)` exist such that `0 <= i < j < k < len(arr)` and `arr[i] + arr[j] + arr[k] == target`.\\n\\nThis problem is similar to [15. 3Sum](https://leetcode.com/problems/3sum/), except it differs in one major way: where the similar problem requires all unique tuples, this problem requires the number of all tuples (which need not be unique).\\n\\n---\\n\\n### Base Approach\\n\\nTo begin, let\\'s understand how the 3-sum algorithm works. First, ensure that the array is sorted in ascending order (descending order works too, but we\\'ll stick to ascending).\\n\\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\t# the rest of the code here\\n```\\n\\nNext, we want a for-loop that will iterate through the array.\\n\\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\tfor i in range(len(arr)-2):\\n\\t\\t\\t# do something\\n\\t\\t\\tpass\\n\\t\\t# the rest of the code here\\n````\\n\\nNotice that we leave the last two indexes of the array untouched. This is because this for-loop will **serve as a pointer to the lowest value in the resulting tuple**; i.e., this pointer tries to find `i` in `(i, j, k)`. This also means that the resulting right end of the array (i.e., `arr[i+1:]`) will contain our remaining two pointers `j` and `k`.\\n\\nNotice now that we have simplified the problem from a 3-sum to a 2-sum; i.e., instead of finding `(i, j, k)` in `arr` where `arr[i] + arr[j] + arr[k] == target`, we now only need to find `(j, k)` in `arr[i+1:]` where `arr[j] + arr[k] == target - arr[i]`. The implementation that follows should then be similar to [1. Two Sum](https://leetcode.com/problems/two-sum/).\\n\\nIn case you are not familiar with the 2-sum algorithm: in a sorted ascending array, we have 2 pointers `j` and `k` pointing to the two ends of the array. Then, in binary-search fashion, **if `arr[j] + arr[k] < target`, we increment `j` to increase the value of `arr[j]`; if `arr[j] + arr[k] > target`, we decrement `k` to decrease the value of `arr[k]`; we continue doing this until we have found a suitable `(j, k)` or `j >= k`**.\\n\\nPutting it all together, we have:\\n\\n```python\\nclass Solution(object):\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\tres, l = 0, len(arr)\\n        for i in range(l-2):\\n\\t\\t\\t# Initialise the 2-sum pointers\\n            j, k = i+1, l-1\\n            while j < k:\\n                if arr[j]+arr[k] < target-arr[i]:  # arr[j] is too small\\n                    j += 1\\n                elif arr[j]+arr[k] > target-arr[i]:  # arr[k] is too large\\n                    k -= 1\\n\\t\\t\\t\\telse:  # arr[i]+arr[j]+arr[k] == target\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t# Shift both pointers by 1\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tk -= 1\\n\\t\\treturn res%1000000007\\n```\\n\\n---\\n\\n### Tweaking the Algorithm\\n\\nIf you tried running the code above, it would give you the wrong answer. Let\\'s use the testcase as an example:\\n\\n```text\\ntarget = 8\\narr: 1 1 2 2 3 3 4 4 5 5\\n     i   j             k  -->  arr[i] + arr[j] + arr[k] == target; j += 1, k -= 1.\\n\\t i     j         k    -->  arr[i] + arr[j] + arr[k] == target; j += 1, k -= 1.\\n```\\n\\nThe problem comes when there are multiple instances of the same number. In the above example, after finding that `j=2, k=9` satisfies the equation, we simply shift the pointers and continue, **without realising that `j=3, k=9` and `j=2, k=8` are both valid tuples as well**. Hence, we end up missing some possible tuples if we shift the pointers. But how do we know when to shift the pointers and when not to?\\n\\nThe trick in this case is to **reconsider the way that we are counting the number of valid tuples**. In the above code, we simply increment the counter by 1 (`res += 1`), but we can do this more efficiently if we had the number of instances of `arr[j]` and `arr[k]` respectively. Of course, we will need to take into account different cases whereby `arr[i]`, `arr[j]`, and/or `arr[k]` may not be fully unqiue. Since `arr[i] <= arr[j] <= arr[k]`, we have the following cases:\\n\\n```text\\nCases                               Result (note: count() is an arbitrary function)\\n1) arr[i] != arr[j] != arr[k]  -->  res += count(arr[i]) * count(arr[j]) * count(arr[k])\\n2) arr[i] == arr[j] != arr[k]  -->  res += math.comb(count(arr[i]), 2) * count(arr[k])\\n3) arr[i] != arr[j] == arr[k]  -->  res += count(arr[i]) * math.comb(count(arr[j]), 2)\\n4) arr[i] == arr[j] == arr[k]  -->  res += math.comb(count(arr[i]), 3)\\n\\nRelevant mathematical equations\\nmath.comb(count(arr[i]), 2) = count(arr[i]) * (count(arr[i]) - 1) // 2\\nmath.comb(count(arr[i]), 3) = count(arr[i]) * (count(arr[i]) - 1) * (count(arr[i]) - 2) // 6\\n```\\n\\nTo incorporate this into our code, we then have to make sure that we do not check the same number twice. To do so, we can simply **shift our pointers by the number of instances of the number**, instead of incrementing or decrementing by 1 each time.\\n\\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        cnt = Counter(arr)  # obtain the number of instances of each number\\n        res, i, l = 0, 0, len(arr)\\n        while i < l:  # in replacement of the for-loop, so that we can increment i by more than 1\\n            j, k = i, l-1  # j should be the leftmost index, hence j=i instead of j=i+1\\n            while j < k:  # i <= j < k; arr[i] <= arr[j] <= arr[k]\\n                if arr[i]+arr[j]+arr[k] < target:\\n                    j += cnt[arr[j]]\\n                elif arr[i]+arr[j]+arr[k] > target:\\n                    k -= cnt[arr[k]]\\n                else:  # arr[i]+arr[j]+arr[k] == target\\n                    if arr[i] != arr[j] != arr[k]:  # Case 1: All the numbers are different\\n                        res += cnt[arr[i]]*cnt[arr[j]]*cnt[arr[k]]\\n                    elif arr[i] == arr[j] != arr[k]:  # Case 2: The smaller two numbers are the same\\n                        res += cnt[arr[i]]*(cnt[arr[i]]-1)*cnt[arr[k]]//2  # math.comb(cnt[arr[i]], 2)*cnt[arr[k]]\\n                    elif arr[i] != arr[j] == arr[k]:  # Case 3: The larger two numbers are the same\\n                        res += cnt[arr[i]]*cnt[arr[j]]*(cnt[arr[j]]-1)//2  # math.comb(cnt[arr[j]], 2)*cnt[arr[i]]\\n                    else:  # Case 4: All the numbers are the same\\n                        res += cnt[arr[i]]*(cnt[arr[i]]-1)*(cnt[arr[i]]-2)//6  # math.comb(cnt[arr[i]], 3)\\n\\t\\t\\t\\t\\t# Shift pointers by the number of instances of the number\\n                    j += cnt[arr[j]]\\n                    k -= cnt[arr[k]]\\n            i += cnt[arr[i]]  # Shift pointer by the number of instances of the number\\n        return res%1000000007\\n```\\n\\n**TC: O(n<sup>2</sup>)**, where `n` is the length of `arr`, due to the nested while loop.\\n**SC: O(n)**, due to the Counter object.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\t# the rest of the code here\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\tfor i in range(len(arr)-2):\\n\\t\\t\\t# do something\\n\\t\\t\\tpass\\n\\t\\t# the rest of the code here\\n```\n```python\\nclass Solution(object):\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\tres, l = 0, len(arr)\\n        for i in range(l-2):\\n\\t\\t\\t# Initialise the 2-sum pointers\\n            j, k = i+1, l-1\\n            while j < k:\\n                if arr[j]+arr[k] < target-arr[i]:  # arr[j] is too small\\n                    j += 1\\n                elif arr[j]+arr[k] > target-arr[i]:  # arr[k] is too large\\n                    k -= 1\\n\\t\\t\\t\\telse:  # arr[i]+arr[j]+arr[k] == target\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t# Shift both pointers by 1\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tk -= 1\\n\\t\\treturn res%1000000007\\n```\n```text\\ntarget = 8\\narr: 1 1 2 2 3 3 4 4 5 5\\n     i   j             k  -->  arr[i] + arr[j] + arr[k] == target; j += 1, k -= 1.\\n\\t i     j         k    -->  arr[i] + arr[j] + arr[k] == target; j += 1, k -= 1.\\n```\n```text\\nCases                               Result (note: count() is an arbitrary function)\\n1) arr[i] != arr[j] != arr[k]  -->  res += count(arr[i]) * count(arr[j]) * count(arr[k])\\n2) arr[i] == arr[j] != arr[k]  -->  res += math.comb(count(arr[i]), 2) * count(arr[k])\\n3) arr[i] != arr[j] == arr[k]  -->  res += count(arr[i]) * math.comb(count(arr[j]), 2)\\n4) arr[i] == arr[j] == arr[k]  -->  res += math.comb(count(arr[i]), 3)\\n\\nRelevant mathematical equations\\nmath.comb(count(arr[i]), 2) = count(arr[i]) * (count(arr[i]) - 1) // 2\\nmath.comb(count(arr[i]), 3) = count(arr[i]) * (count(arr[i]) - 1) * (count(arr[i]) - 2) // 6\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        cnt = Counter(arr)  # obtain the number of instances of each number\\n        res, i, l = 0, 0, len(arr)\\n        while i < l:  # in replacement of the for-loop, so that we can increment i by more than 1\\n            j, k = i, l-1  # j should be the leftmost index, hence j=i instead of j=i+1\\n            while j < k:  # i <= j < k; arr[i] <= arr[j] <= arr[k]\\n                if arr[i]+arr[j]+arr[k] < target:\\n                    j += cnt[arr[j]]\\n                elif arr[i]+arr[j]+arr[k] > target:\\n                    k -= cnt[arr[k]]\\n                else:  # arr[i]+arr[j]+arr[k] == target\\n                    if arr[i] != arr[j] != arr[k]:  # Case 1: All the numbers are different\\n                        res += cnt[arr[i]]*cnt[arr[j]]*cnt[arr[k]]\\n                    elif arr[i] == arr[j] != arr[k]:  # Case 2: The smaller two numbers are the same\\n                        res += cnt[arr[i]]*(cnt[arr[i]]-1)*cnt[arr[k]]//2  # math.comb(cnt[arr[i]], 2)*cnt[arr[k]]\\n                    elif arr[i] != arr[j] == arr[k]:  # Case 3: The larger two numbers are the same\\n                        res += cnt[arr[i]]*cnt[arr[j]]*(cnt[arr[j]]-1)//2  # math.comb(cnt[arr[j]], 2)*cnt[arr[i]]\\n                    else:  # Case 4: All the numbers are the same\\n                        res += cnt[arr[i]]*(cnt[arr[i]]-1)*(cnt[arr[i]]-2)//6  # math.comb(cnt[arr[i]], 3)\\n\\t\\t\\t\\t\\t# Shift pointers by the number of instances of the number\\n                    j += cnt[arr[j]]\\n                    k -= cnt[arr[k]]\\n            i += cnt[arr[i]]  # Shift pointer by the number of instances of the number\\n        return res%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918457,
                "title": "c-simplest-solution-w-easy-explanation-intuitive",
                "content": "**APPROACH :**\\n \\n* We traverse the array using 2 loops & compute the sums of all possible pairs. \\n\\n* We store the sums of pairs in an ```unordered_map``` along with their frequency.\\n\\n* While traversing, we also check if the ```target - current element``` is present in the map. If so, we add it\\'s frequency to the result.\\n\\n* Finally we return the result.\\n\\n**Time Complexity :** O(n^2)\\n\\n**Space Complexity :** O(n^2)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int X) {\\n        int n = arr.size(), mod = 1e9+7, ans = 0;\\n        unordered_map<int, int> m;\\n        \\n        for(int i=0; i<n; i++) {\\n            ans = (ans + m[X - arr[i]]) % mod;\\n            \\n            for(int j=0; j<i; j++) m[arr[i] + arr[j]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if you like my solution & explanation :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```unordered_map```\n```target - current element```\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int X) {\\n        int n = arr.size(), mod = 1e9+7, ans = 0;\\n        unordered_map<int, int> m;\\n        \\n        for(int i=0; i<n; i++) {\\n            ans = (ans + m[X - arr[i]]) % mod;\\n            \\n            for(int j=0; j<i; j++) m[arr[i] + arr[j]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181098,
                "title": "java-python-3-o-n-2-and-o-n-101-2-codes-w-brief-anslysis",
                "content": "**Q & A**\\n\\nQ1: When we find the three array element values, x, y, and z; how do we make sure their corresponding index values meet the requirement where indexes are i < j < k? More precisely, in the if and elif statements, we compare the array element values, but not the array index values. If the LeetCode problem itself say the array is sorted, then it makes more sense. But it doesn\\'t say if the array is sorted or not. \\nA1: The problems states: ...`return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.`...\\nThe above actually means **return the number of tuples of 3 elements with a sum of target**.\\n`i < j < k` in this problem actually means `i, j` and `k` are `3` different indices.\\n\\n**End of Q & A**\\n\\n----\\n\\n**Method 1**\\n\\n**Java**\\nSimilar to 3 sum.\\n```java\\n    public int threeSumMulti(int[] A, int target) {\\n        Arrays.sort(A);\\n        long res = 0;\\n        for (int i = 0; i < A.length - 2; ++i) {\\n            int j = i + 1;\\n            int k = A.length - 1;\\n            while (j < k) {\\n                if (A[j] + A[k] < target - A[i]) { \\n                    ++j;\\n                }else if (A[j] + A[k] > target - A[i]) {\\n                    --k;\\n                }else {\\n                    int l = 1, r = 1;\\n                    while (j + l < k && A[j + l] == A[j]) { ++l; } // l: number of elements equal to A[j].\\n                    while (j + l <= k - r && A[k - r] == A[k]) { ++r; } // r: number of elements equal to A[k].\\n                    // If A[j...k] are all equal, then there are C(k - j + 1, 2) cases\\n                    // that meet the requirement;\\n                    // Otherwise, there are l * r cases that meet the requirement.\\n                    res += A[j] == A[k] ? (k - j + 1) * (k - j) / 2 : l * r ;\\n                    j += l; // forward j by l steps.\\n                    k -= r; // backward k by r steps.\\n                }\\n            }\\n        }\\n        return (int)(res % 1_000_000_007);\\n    }\\n```\\n**Python 3**\\n```python\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        ans = 0\\n        for i in range(2, len(arr)):\\n            j, k = 0, i - 1\\n            while j < k:\\n                sm = arr[i] + arr[j] + arr[k]\\n                if sm < target:\\n                    j += 1\\n                elif sm > target:\\n                    k -= 1\\n                else:\\n                    l = r = 1\\n                    while j + l < k and arr[j] == arr[j + l]:\\n                        l += 1\\n                    while j + l <= k - r and arr[k] == arr[k - r]:\\n                        r += 1\\n                    ans += (l + r) * (l + r - 1) // 2 if arr[j] == arr[k] else l * r\\n                    j += l;\\n                    k -= r;\\n        return ans % (10 ** 9 + 7)\\n```\\n**Analysis:**\\n\\nArrays.sort() cost time O(nlogn), which is a minor part; for each i, all while loops totally cost time O(n), therefore we have:\\n\\nTime: O(n ^ 2).\\n\\n----\\n\\n**Method 2**\\n\\n*Intuition*\\nThere are `3` cases for `i + j + k == target`, in which `i, j, k` are `3` elements from input `A`:\\n1. `i, j, k` are all equal; That is, `i == j && j == k`, assume there are `cnt` `i`s in `A`,  then we have `C(cnt, 3) = cnt * (cnt - 1) * (cnt - 2) / 6` possible combinations;\\n2. `i == j`, but `k` is different from them; assume there are `cnt` `i`s in `A`,  then we have `C(cnt, 2) = cnt * (cnt - 1) / 2` possible combinations of `i` and `j`, and times the frequency of `j`, `cnt3`, then we have `cnt * (cnt - 1) / 2 * cnt3`; \\n3. `i, j, k` are all distinct; we just choose each element from `cnt` `i`s, `cnt2` `j`s, and `cnt3` `k`s, respectively; There are `cnt * cnt2 * cnt3` combinations.\\n\\n**Java**\\n```java\\n    private static final int mod = 1_000_000_007;\\n    public int threeSumMulti(int[] A, int target) {\\n        long ans = 0;\\n        final Map<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a, 1 + count.getOrDefault(a, 0)); \\n        for (int i : count.keySet()) {\\n            for (int j : count.keySet()) {\\n                int k = target - i - j;\\n                if (count.containsKey(k)) {\\n                    long cnt = count.get(i), cnt2 = count.get(j), cnt3 = count.get(k);\\n                    if (i == j && j == k) {\\n                        ans += cnt * (cnt - 1) * (cnt - 2) / 6;\\n                    }else if (i == j) {\\n                        ans += cnt * (cnt - 1) / 2 * cnt3;\\n                    }else if (i < j && j < k) {\\n                        ans += cnt * cnt2 * cnt3;\\n                    }\\n                    ans %= mod;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n    }\\n```\\n\\n**Python 3**\\n```python\\n    def threeSumMulti(self, A: List[int], target: int) -> int:\\n        cnt, ans = collections.Counter(A), 0\\n        for i in cnt:\\n            for j in cnt:\\n                k = target - i - j\\n                if i == j == k:\\n                    ans += cnt[i] * (cnt[i] - 1) * (cnt[i] - 2) // 6\\n                elif i == j:\\n                    ans += cnt[i] * (cnt[i] - 1) // 2 * cnt[k]\\n                elif i < j < k:\\n                    ans += cnt[i] * cnt[j] * cnt[k]\\n        return ans % (10**9 + 7)\\n```\\nTime: O(n + 101 ^ 2), space: O(101).",
                "solutionTags": [],
                "code": "```java\\n    public int threeSumMulti(int[] A, int target) {\\n        Arrays.sort(A);\\n        long res = 0;\\n        for (int i = 0; i < A.length - 2; ++i) {\\n            int j = i + 1;\\n            int k = A.length - 1;\\n            while (j < k) {\\n                if (A[j] + A[k] < target - A[i]) { \\n                    ++j;\\n                }else if (A[j] + A[k] > target - A[i]) {\\n                    --k;\\n                }else {\\n                    int l = 1, r = 1;\\n                    while (j + l < k && A[j + l] == A[j]) { ++l; } // l: number of elements equal to A[j].\\n                    while (j + l <= k - r && A[k - r] == A[k]) { ++r; } // r: number of elements equal to A[k].\\n                    // If A[j...k] are all equal, then there are C(k - j + 1, 2) cases\\n                    // that meet the requirement;\\n                    // Otherwise, there are l * r cases that meet the requirement.\\n                    res += A[j] == A[k] ? (k - j + 1) * (k - j) / 2 : l * r ;\\n                    j += l; // forward j by l steps.\\n                    k -= r; // backward k by r steps.\\n                }\\n            }\\n        }\\n        return (int)(res % 1_000_000_007);\\n    }\\n```\n```python\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        ans = 0\\n        for i in range(2, len(arr)):\\n            j, k = 0, i - 1\\n            while j < k:\\n                sm = arr[i] + arr[j] + arr[k]\\n                if sm < target:\\n                    j += 1\\n                elif sm > target:\\n                    k -= 1\\n                else:\\n                    l = r = 1\\n                    while j + l < k and arr[j] == arr[j + l]:\\n                        l += 1\\n                    while j + l <= k - r and arr[k] == arr[k - r]:\\n                        r += 1\\n                    ans += (l + r) * (l + r - 1) // 2 if arr[j] == arr[k] else l * r\\n                    j += l;\\n                    k -= r;\\n        return ans % (10 ** 9 + 7)\\n```\n```java\\n    private static final int mod = 1_000_000_007;\\n    public int threeSumMulti(int[] A, int target) {\\n        long ans = 0;\\n        final Map<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a, 1 + count.getOrDefault(a, 0)); \\n        for (int i : count.keySet()) {\\n            for (int j : count.keySet()) {\\n                int k = target - i - j;\\n                if (count.containsKey(k)) {\\n                    long cnt = count.get(i), cnt2 = count.get(j), cnt3 = count.get(k);\\n                    if (i == j && j == k) {\\n                        ans += cnt * (cnt - 1) * (cnt - 2) / 6;\\n                    }else if (i == j) {\\n                        ans += cnt * (cnt - 1) / 2 * cnt3;\\n                    }else if (i < j && j < k) {\\n                        ans += cnt * cnt2 * cnt3;\\n                    }\\n                    ans %= mod;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n    }\\n```\n```python\\n    def threeSumMulti(self, A: List[int], target: int) -> int:\\n        cnt, ans = collections.Counter(A), 0\\n        for i in cnt:\\n            for j in cnt:\\n                k = target - i - j\\n                if i == j == k:\\n                    ans += cnt[i] * (cnt[i] - 1) * (cnt[i] - 2) // 6\\n                elif i == j:\\n                    ans += cnt[i] * (cnt[i] - 1) // 2 * cnt[k]\\n                elif i < j < k:\\n                    ans += cnt[i] * cnt[j] * cnt[k]\\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1918415,
                "title": "simple-hashmap-solution-faster-than-80",
                "content": "**Please upvote if you like the solution**\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t//Couting the occurrence of each number\\n        for(int i: arr) count[i]++;\\n        \\n        for(int i=0;i<101;i++){\\n            for(int j=i;j<101;j++){\\n                int k = target - i -j;\\n                if(k<0 || k>100)\\n                    continue;\\n\\t\\t\\t\\t// if all number are same than use nC3\\n                if(i==j && j==k){\\n                    result += (count[i]*(count[i]-1)*(count[i]-2))/6;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if first two are same than use nC2 * occurence of k\\n                else if(i==j && j!=k){\\n                    result += ((count[i]*(count[i]-1))/2)*count[k];\\n                }\\n\\t\\t\\t\\t//Last condition if all number ar different\\n\\t\\t\\t\\telse if(i<j && j<k){\\n                    result += (count[i]*count[j]*count[k]);\\n                }\\n                result %= mod;\\n            }\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t//Couting the occurrence of each number\\n        for(int i: arr) count[i]++;\\n        \\n        for(int i=0;i<101;i++){\\n            for(int j=i;j<101;j++){\\n                int k = target - i -j;\\n                if(k<0 || k>100)\\n                    continue;\\n\\t\\t\\t\\t// if all number are same than use nC3\\n                if(i==j && j==k){\\n                    result += (count[i]*(count[i]-1)*(count[i]-2))/6;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if first two are same than use nC2 * occurence of k\\n                else if(i==j && j!=k){\\n                    result += ((count[i]*(count[i]-1))/2)*count[k];\\n                }\\n\\t\\t\\t\\t//Last condition if all number ar different\\n\\t\\t\\t\\telse if(i<j && j<k){\\n                    result += (count[i]*count[j]*count[k]);\\n                }\\n                result %= mod;\\n            }\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181125,
                "title": "knapsack-o-n-target-or-straightforward-o-n-2",
                "content": "`dp[i][j][k]` represents number of combinations using `k` numbers within `A[0] ... A[i]` with the sum of `j`.\\nThen `dp[n][target][3]` is the result. O(n * target)\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int n = A.length, M = (int)1e9 + 7;\\n        int[][][] dp = new int[n + 1][target + 1][4];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0][0] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= target; j++) {\\n                for (int k = 1; k <= 3; k++) {\\n                    dp[i + 1][j][k] = dp[i][j][k];\\n                    dp[i + 1][j][k] %= M;\\n                    if (j >= A[i]) {\\n                        dp[i + 1][j][k] += dp[i][j - A[i]][k - 1];\\n                        dp[i + 1][j][k] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][target][3];\\n    }\\n}\\n```\\n\\nO(target) space:\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int n = A.length, M = (int)1e9 + 7;\\n        int[][] dp = new int[target + 1][4];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = target; j >= A[i]; j--) {\\n                for (int k = 3; k >= 1; k--) {\\n                    dp[j][k] += dp[j - A[i]][k - 1];\\n                    dp[j][k] %= M;\\n                }\\n            }\\n        }\\n        return dp[target][3];\\n    }\\n}\\n```\\n\\nO(n^2) Straightforward:\\nGuarantee `a <= b <= c`\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for (int a : A) {\\n            map.put(a, map.getOrDefault(a, 0l) + 1);\\n        }\\n        long result = 0;\\n        int M = (int)1e9 + 7;\\n        for (int a : map.keySet()) {\\n            for (int b : map.keySet()) {\\n                if (b < a || a == b && map.get(a) == 1) {\\n                    continue;\\n                }\\n                int c = target - a - b;\\n                if (c < b || !map.containsKey(c)) {\\n                    continue;\\n                }\\n                if (a == b && b == c) {\\n                    if (map.get(a) == 2) {\\n                        continue;\\n                    }\\n                    result += nCk(map.get(a), 3);\\n                } else if (a == b) {\\n                    result += nCk(map.get(a), 2) * map.get(c);\\n                } else if (b == c) {\\n                    if (map.get(b) == 1) {\\n                        continue;\\n                    }\\n                    result += nCk(map.get(b), 2) * map.get(a);\\n                } else {\\n                    result += (map.get(a) * map.get(b) * map.get(c));\\n                }\\n                result %= M;\\n            }\\n        }\\n        return (int)result;\\n    }\\n    private long nCk(long n, int k) {\\n        if (k == 3) {\\n            return (n * (n - 1) * (n - 2)) / 6;\\n        } else {\\n            return n * (n - 1) / 2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int n = A.length, M = (int)1e9 + 7;\\n        int[][][] dp = new int[n + 1][target + 1][4];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0][0] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= target; j++) {\\n                for (int k = 1; k <= 3; k++) {\\n                    dp[i + 1][j][k] = dp[i][j][k];\\n                    dp[i + 1][j][k] %= M;\\n                    if (j >= A[i]) {\\n                        dp[i + 1][j][k] += dp[i][j - A[i]][k - 1];\\n                        dp[i + 1][j][k] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][target][3];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int n = A.length, M = (int)1e9 + 7;\\n        int[][] dp = new int[target + 1][4];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = target; j >= A[i]; j--) {\\n                for (int k = 3; k >= 1; k--) {\\n                    dp[j][k] += dp[j - A[i]][k - 1];\\n                    dp[j][k] %= M;\\n                }\\n            }\\n        }\\n        return dp[target][3];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for (int a : A) {\\n            map.put(a, map.getOrDefault(a, 0l) + 1);\\n        }\\n        long result = 0;\\n        int M = (int)1e9 + 7;\\n        for (int a : map.keySet()) {\\n            for (int b : map.keySet()) {\\n                if (b < a || a == b && map.get(a) == 1) {\\n                    continue;\\n                }\\n                int c = target - a - b;\\n                if (c < b || !map.containsKey(c)) {\\n                    continue;\\n                }\\n                if (a == b && b == c) {\\n                    if (map.get(a) == 2) {\\n                        continue;\\n                    }\\n                    result += nCk(map.get(a), 3);\\n                } else if (a == b) {\\n                    result += nCk(map.get(a), 2) * map.get(c);\\n                } else if (b == c) {\\n                    if (map.get(b) == 1) {\\n                        continue;\\n                    }\\n                    result += nCk(map.get(b), 2) * map.get(a);\\n                } else {\\n                    result += (map.get(a) * map.get(b) * map.get(c));\\n                }\\n                result %= M;\\n            }\\n        }\\n        return (int)result;\\n    }\\n    private long nCk(long n, int k) {\\n        if (k == 3) {\\n            return (n * (n - 1) * (n - 2)) / 6;\\n        } else {\\n            return n * (n - 1) / 2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123894,
                "title": "3sum-with-multiplicity-short-easy-w-explanation-beats-100",
                "content": "***Solution - I***\\n\\nWe can **sort the array and use a two pointer technique** on the sorted array. For each `i` in the sorted array, find two indices `j` and `k` (i < j < k) using 2-pointer such that `arr[j] + arr[k] = target - arr[i]`. Now, in a sorted array, duplicated `arr[j]` and `arr[k]` would appear consecutively. \\n\\nFor eg. Suppose we have target=4 and we are searching for `j` and `k` in subarray `[1,1,2,2,2,3,3,3]`. We find j can be 1st index and k can be last index. We pick up all elements equal to `arr[j]` (l=2) and `arr[k]` (r=3). A total of `l*r` will be added to the final count.\\n\\nWe also need to take care when `arr[j]` and `arr[k]` are the same element. In this case, a total of `(k-i) * (k-i+1)/2` has to be added. For eg. if we had a subarray `[2,2,2]` and needed to find such that `arr[j] + arr[k] = 4`, we would have 3 total pairs (`{0,1},{0,2},{1,2}`).\\n\\n**Note :** Sorting won\\'t affect our final answer. We just need to make sure that we choose 3 distinct elements from the array and the pair (i,j,k) is counted just once. Check for some array without and with sort and you would get the idea.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time Complexity :** **`O(N^2)`**, \\n**Space Complexity :** **`O(sort)`**, only extra space needed is the implict space used in sort.\\n\\n![image](https://assets.leetcode.com/users/images/0a7c2041-597f-4e63-ae63-dd71293423ce_1616512183.3679485.png)\\n\\n\\n---------\\n---------\\n\\n***Solution - II***\\n\\nWe can notice that elements of the array can be at max `100`. We can use this to optimise the solution further.\\n\\nInstead of choosing one index and finding the other two indices using two-pointer as done in previous approach, we can choose each number from `0 to 100` and if it exists in array, find other two numbers.\\n\\nWe need to maintain a frequency array to do this efficiently. We will have following cases (here i,j,k denote value of array we are checking, not indices) - \\n\\n* `i = j = k` : Add `freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6` which is nothing but formula of number of ways to choose three distinct elements from n. \\n* `i = j != k` : Add `freq[k] + (freq[i] * (freq[i] - 1))/2` which denotes that number of `k`s and ways to choose 2 distinct elements from freq[i]\\n* `i != j = k` : Similar to above\\n* `i != j != k` : Just multiply all frequency to get the number of triplet possible.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time complexity :** `O(N + MAX^2)`, where `N` is the number of elemetns in `arr` and `MAX` is the maximum element of array.\\n**Space complexity :** `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/78e7c8d4-3227-43a4-a4be-4407041b7a42_1616509984.6405087.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181156,
                "title": "c-6-lines-4-ms-o-distinct-n-2",
                "content": "Since the numbers are in [0..100], we can use bucket sort instead of hash map. The first solution is demonstrating calculation for 4 cases:\\n- 3 * i = target\\n- 2 * i + j = target\\n- i + 2 * j = target\\n- i + j + k = target\\n```\\nint threeSumMulti(vector<int>& nums, int target) {\\n    long m[101] = {}, res = 0;\\n    for (auto n : nums) ++m[n];\\n    for (auto i = 0; i < 101; ++i) {\\n        if (i * 3 == target) res += m[i] * (m[i] - 1) * (m[i] - 2) / 6;\\n        for (auto j = i + 1, k = target - i - j; j < 101; ++j, --k) {\\n            if (i * 2 + j == target) res += m[i] * m[j] * (m[i] - 1) / 2;\\n            if (i + j * 2 == target) res += m[i] * m[j] * (m[j] - 1) / 2;\\n            if (k > j && k < 101) res += m[i] * m[j] * m[k];\\n        }\\n    }\\n    return res % 1000000007;\\n}\\n```\\nIf we analyze these calculation, we can generalize them into one and get a shorter solution. \\n```\\nint threeSumMulti(vector<int>& nums, int target) {\\n    long m[101] = {}, res = 0;\\n    for (auto n : nums) ++m[n];\\n    for (auto i = 0; i < 101; ++i)\\n        for (auto j = i, k = target - i - j; j < 101; ++j, --k)\\n            if (k >= j && k < 101) res += m[i] * (m[j] - (i == j)) * (m[k] - (k == j) * ((i == j) + 1)) /\\n                (((k == j && i == j) * 2 + 1) * ((k == j || i == j) + 1));\\n    return res % 1000000007;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint threeSumMulti(vector<int>& nums, int target) {\\n    long m[101] = {}, res = 0;\\n    for (auto n : nums) ++m[n];\\n    for (auto i = 0; i < 101; ++i) {\\n        if (i * 3 == target) res += m[i] * (m[i] - 1) * (m[i] - 2) / 6;\\n        for (auto j = i + 1, k = target - i - j; j < 101; ++j, --k) {\\n            if (i * 2 + j == target) res += m[i] * m[j] * (m[i] - 1) / 2;\\n            if (i + j * 2 == target) res += m[i] * m[j] * (m[j] - 1) / 2;\\n            if (k > j && k < 101) res += m[i] * m[j] * m[k];\\n        }\\n    }\\n    return res % 1000000007;\\n}\\n```\n```\\nint threeSumMulti(vector<int>& nums, int target) {\\n    long m[101] = {}, res = 0;\\n    for (auto n : nums) ++m[n];\\n    for (auto i = 0; i < 101; ++i)\\n        for (auto j = i, k = target - i - j; j < 101; ++j, --k)\\n            if (k >= j && k < 101) res += m[i] * (m[j] - (i == j)) * (m[k] - (k == j) * ((i == j) + 1)) /\\n                (((k == j && i == j) * 2 + 1) * ((k == j || i == j) + 1));\\n    return res % 1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767824,
                "title": "two-pointer-solution-c",
                "content": "The idea is same with 3Sum, but need to care about combination of duplicates. Firstly sort `A`, then say we fix `i` as first number, and we want to find all possibilities of `A[lo] + A[hi] == target - A[i]`:\\nCase1: `A[lo] != A[hi]`. Count the number of duplicates of `A[lo]` and `A[hi]`, as `cntlo` and `cnthi`, then for `i`, there are `cnthi*cntlo` possibilities\\nCase2: `A[lo] == A[hi]`. Now all number between `lo` and `hi` are same. Say the number of duplicates is n, any two of n can meet `A[lo] + A[hi] == target - A[i]`, that is n*(n-1)/2.\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        int ans = 0; \\n        int mod = 1e9+7;\\n        for (int i=0; i<n-2; ++i) {\\n            int lo = i+1, hi = n-1;\\n            while (lo < hi) {\\n                if (A[i] + A[lo] + A[hi] == target) {\\n                    int cntlo=1, cnthi=1;\\n                    while (lo < hi && A[lo] == A[lo+1]) {cntlo++; lo++;}\\n                    while (lo < hi && A[hi] == A[hi-1]) {cnthi++; hi--;}\\n\\t\\t\\t\\t\\t// A[lo]==A[hi]\\n                    if (lo == hi) ans =(ans+cntlo*(cntlo-1)/2)%mod;\\n\\t\\t\\t\\t\\t// A[lo]!=A[hi]\\n                    else ans = (ans+cntlo*cnthi)%mod;\\n                    lo++; hi--; \\n                } else if (A[i] + A[lo] + A[hi] > target) {\\n                    hi--;\\n                } else {\\n                    lo++;\\n                }\\n            }\\n            //cout << ans << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        int ans = 0; \\n        int mod = 1e9+7;\\n        for (int i=0; i<n-2; ++i) {\\n            int lo = i+1, hi = n-1;\\n            while (lo < hi) {\\n                if (A[i] + A[lo] + A[hi] == target) {\\n                    int cntlo=1, cnthi=1;\\n                    while (lo < hi && A[lo] == A[lo+1]) {cntlo++; lo++;}\\n                    while (lo < hi && A[hi] == A[hi-1]) {cnthi++; hi--;}\\n\\t\\t\\t\\t\\t// A[lo]==A[hi]\\n                    if (lo == hi) ans =(ans+cntlo*(cntlo-1)/2)%mod;\\n\\t\\t\\t\\t\\t// A[lo]!=A[hi]\\n                    else ans = (ans+cntlo*cnthi)%mod;\\n                    lo++; hi--; \\n                } else if (A[i] + A[lo] + A[hi] > target) {\\n                    hi--;\\n                } else {\\n                    lo++;\\n                }\\n            }\\n            //cout << ans << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1123498,
                "title": "python-combinatorics-solution-explained",
                "content": "Let us calculate `Counter(arr)`, that is how what is frequency of each number and then check `3` cases:\\n1. All numbers `i < j < k` ar different: then we can check all possible permutations for numbers `i` and `j` and then check that for `k = target - i - j` we have `i < j < k`.\\n2. For numbers `i, j, k` we have `i = j != k`. Then we have `c[i]*(c[i]-1)*c[target - 2*i]//2` number of options. Why? Because we need to choose `i` element twice, this is number of combinations with `2` elements from `c[i]` elements. Note, that I did not specify which of three indexes here is smaller and which is bigger, so here we cover all cases where exactly `2` indexes are equal.\\n3. For numers `i, j, k` we have `i = j = k`. Here answer is `c[i]*(c[i]-1)*(c[i]-2)//6`: number of combinations with `3` elements from `c[i]` elements.\\n\\n**Complexity**: time complexity is `O(n^2)`, where `n` is length of `arr`, because on first iteration we did `O(n^2)` and on second and third we did `O(n)`. Space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def threeSumMulti(self, arr, target):\\n        c = Counter(arr)\\n        ans, M = 0, 10**9 + 7\\n        for i, j in permutations(c, 2):\\n            if i < j < target - i - j:\\n                ans += c[i]*c[j]*c[target - i - j]\\n\\n        for i in c:\\n            if 3*i != target:\\n                ans += c[i]*(c[i]-1)*c[target - 2*i]//2\\n            else:\\n                ans += c[i]*(c[i]-1)*(c[i]-2)//6\\n                \\n        return ans % M\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr, target):\\n        c = Counter(arr)\\n        ans, M = 0, 10**9 + 7\\n        for i, j in permutations(c, 2):\\n            if i < j < target - i - j:\\n                ans += c[i]*c[j]*c[target - i - j]\\n\\n        for i in c:\\n            if 3*i != target:\\n                ans += c[i]*(c[i]-1)*c[target - 2*i]//2\\n            else:\\n                ans += c[i]*(c[i]-1)*(c[i]-2)//6\\n                \\n        return ans % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123830,
                "title": "js-python-java-c-efficient-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to attempt all permutations, but that would run up to **2.7e10** attempts. The first important thing to notice is that the range of numbers is very small at **[0,100]**. With that few number options, any large input array (**A**) will have many duplicates, which means we\\'re looking at a **combinatorics** solution.\\n\\nIn order to use the combinatorics shortcut, however, we\\'ll first have to make a **frequency map** of the numbers in **A**. We could always use a standard map for this, but since the range of numbers is so small and **0-indexed**, it makes more sense to use an **array** instead.\\n\\nAfter we\\'ve iterated through **A** and filled our number map (**nmap**) with the number frequencies, we can get down to the real work. The normal approach here would be to figure out the distinct numbers available and use nested loops to attempt every possible permutation. But rather than doing this, which would require many array calls, we can again take advantage of the fact that the number range is so small.\\n\\nWe can iterate through every possible permutation from **[0,100]**, regardless of wheter the numbers are in **A**. Since we\\'ve made a frequency map, those numbers will be represented as **0**\\'s, which will handily prevent anything from being added to our answer (**ans**) for permutations that we can\\'t make, and by using simple math instead of many array calls, we can actually be more performant.\\n\\nStill, there are ways to streamline this process. The basic approach will be to use a **2-pointer system** to find two of our values and then mathematically figure the third, before applying the proper permutation formula to the values.\\n\\nIt should be apparent that our largest value (**k**) can never go above the target (**T**), nor can it obviously go above the max value of **100**, so we can start it out at **min(T, 100)** and decrement from there. Also, since it will always represents the largest of the three values, it can never go below **T / 3**, because then the two smaller numbers would never be able to bring it up to **T**.\\n\\nMoving down to the next value (**j**), we can see that it can never be larger than **k** by definition, nor can it be larger than the remaining amount of space (**rem**) left to **T**, so we should start it at **min(rem, k)**. Similar to **k**, **j** can also never go below **rem / 2**.\\n\\nOnce we have two of the three values, we can check for their frequencies. If any of them are **0**\\'s, then it will automatically make the result of its permutation check a **0** as well. We can also potentially save some processing by checking for **0**\\'s and **continuing** before applying the combinatorics formulas.\\n\\nIf **i == k**, then we know that **i == j == k** because **j** has to be between **i** and **k**, so we\\'ll have to use the **n choose 3** formula. We should also check if any two other values are the same, then we should use **(n choose 2) * (n choose 1)**. Otherwise, we can just use the simple combinations formula.\\n\\nThen it\\'s important to remember to apply the **modulo** before **returning**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript was actually faster with an approach that featured isolating the actual distinct elements, sorting them, and then running efficiently through the combinations, but the code was much longer and more complex. This method is much easier and nearly as fast. In either case, we should use a typed array here for the arraymap.\\n\\nJava was oddly slower at the iteration shortcuts and actually ran faster without the added processes.\\n\\nJava and C++ should use **long** for their **ans** (prior to returning it, at least), and even for **nmap**, otherwise we\\'ll have to cast those values to **long** each time anyway.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 40.5MB** (beats 100% / 80%).\\n```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **60ms / 14.2MB** (beats 100% / 92%).\\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.3MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 10.2MB** (beats 99% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123400,
                "title": "python-dp",
                "content": "We can solve using dynamic programming and a hash table. \\n \\n The hash table is called `level2`. Suppose that we are at index `i` such that `i>2`. We consider all possible sums ending at `i` (a repeating pattern in many problems). `level2[x]` is the number of distinct pairs that sum to `x`. How do we get the distinct pairs? Consider all pairs ending at index `j` such that `0 <= j < i`. One trick is, we can find all pairs ending at index `i-1` when we are looping for `i`. This eliminates looping from the beginning each time, and everything can be done with two nested loops.\\n \\n Time: `O(N^2)`\\n Space: `O(N)`\\n\\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, t):\\n        ans = 0\\n        n = len(A)\\n        level2 = collections.defaultdict(int)\\n        for i in range(2, n):\\n            for j in range(i-1):\\n                level2[A[j] + A[i-1]] += 1\\n            ans = ans + level2[t - A[i]]\\n            ans = ans % (10**9 + 7)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeSumMulti(self, A, t):\\n        ans = 0\\n        n = len(A)\\n        level2 = collections.defaultdict(int)\\n        for i in range(2, n):\\n            for j in range(i-1):\\n                level2[A[j] + A[i-1]] += 1\\n            ans = ans + level2[t - A[i]]\\n            ans = ans % (10**9 + 7)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181089,
                "title": "dp-python",
                "content": "* Let `d1` track the count of single elements seen so far\n* Let `d2` track the count of the sum of any two elements seen so far\n* Given a new value `n`, the number of 3-sums equal to target is `d2[target-n]`\n* update `d2`, then `d1`\n```\n class Solution(object):\n     def threeSumMulti(self, A, target):\n         \"\"\"\n         :type A: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         d1=collections.defaultdict(int)\n         d2=collections.defaultdict(int)\n\n         N=len(A)\n         MOD=10**9+7\n         cnt = 0\n         for i in range(N-1,-1,-1):\n             n=A[i]\n             cnt+=d2[target-n]\n             cnt%=MOD\n             for (nn, nncnt) in d1.iteritems():\n                 d2[nn+n]+=nncnt\n\n             d1[n]+=1\n\n         return cnt\n```\n",
                "solutionTags": [],
                "code": "```\n class Solution(object):\n     def threeSumMulti(self, A, target):\n         \"\"\"\n         :type A: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         d1=collections.defaultdict(int)\n         d2=collections.defaultdict(int)\n\n         N=len(A)\n         MOD=10**9+7\n         cnt = 0\n         for i in range(N-1,-1,-1):\n             n=A[i]\n             cnt+=d2[target-n]\n             cnt%=MOD\n             for (nn, nncnt) in d1.iteritems():\n                 d2[nn+n]+=nncnt\n\n             d1[n]+=1\n\n         return cnt\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918476,
                "title": "c-2-pointer-simple-implementation-approach-similar-to-3-sum-problem",
                "content": "\\n```\\n int threeSumMulti(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        // two pointer approach \\n\\t\\t\\n        long long mod=1e9+7;\\n\\t\\t\\n        int n=nums.size();\\n\\t\\t\\n        int ans=0;\\n\\t\\t\\n        long long sum;\\n\\t\\t\\n        for(int i=0;i<n-2;i++)\\n        {\\n            int l=i+1;\\n\\t\\t\\t\\n            int r=n-1;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[i]+nums[r];\\n             \\n                if(sum==target)\\n                {\\n                      int count1=1;\\n                      int count2=1;\\n                    while(l<r && nums[l]==nums[l+1])\\n                    {\\n                        l++;\\n                        count1++;\\n                    }\\n                    \\n                    while(l<r && nums[r]==nums[r-1])\\n                    {\\n                        r--;\\n                        count2++;\\n                    }\\n                                           \\n                    if(l==r)         \\n                    {                                  \\n                        ans = (ans%mod + (count1%mod *(count1-1)%mod)/2)%mod;\\n                    }\\n                    \\n                    if(l!=r)\\n                    {\\n                        ans = (ans%mod + (count1%mod* count2%mod)%mod)%mod;\\t \\n                    }**\\n                    \\n                    l++;\\n                    r--;\\n                }\\n                else\\n                {\\n                    if(sum>target)\\n                    {\\n                        r--;\\n                    }\\n                    else\\n                    {\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n int threeSumMulti(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        // two pointer approach \\n\\t\\t\\n        long long mod=1e9+7;\\n\\t\\t\\n        int n=nums.size();\\n\\t\\t\\n        int ans=0;\\n\\t\\t\\n        long long sum;\\n\\t\\t\\n        for(int i=0;i<n-2;i++)\\n        {\\n            int l=i+1;\\n\\t\\t\\t\\n            int r=n-1;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[i]+nums[r];\\n             \\n                if(sum==target)\\n                {\\n                      int count1=1;\\n                      int count2=1;\\n                    while(l<r && nums[l]==nums[l+1])\\n                    {\\n                        l++;\\n                        count1++;\\n                    }\\n                    \\n                    while(l<r && nums[r]==nums[r-1])\\n                    {\\n                        r--;\\n                        count2++;\\n                    }\\n                                           \\n                    if(l==r)         \\n                    {                                  \\n                        ans = (ans%mod + (count1%mod *(count1-1)%mod)/2)%mod;\\n                    }\\n                    \\n                    if(l!=r)\\n                    {\\n                        ans = (ans%mod + (count1%mod* count2%mod)%mod)%mod;\\t \\n                    }**\\n                    \\n                    l++;\\n                    r--;\\n                }\\n                else\\n                {\\n                    if(sum>target)\\n                    {\\n                        r--;\\n                    }\\n                    else\\n                    {\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181080,
                "title": "java-sorting-solution-o-n-2",
                "content": "The solution is similar to 3Sum problem (https://leetcode.com/submissions/detail/128547721/).\\nThe key is how to skip duplicate numbers:\\nCase 1: ```A[l] == A[r]```, the total possible answer is ```num * (num-1) / 2```, where ```num = r-l+1```.\\nCase 2: ```A[l] != A[r]```, find how many duplicates in the left-hand side (which is ```cntL```) and how many duplicates in the right-hand side (which is ```cntR```). Then, search for the next possible answers.\\n\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int mod = 1000000007;\\n        int ans = 0;\\n        Arrays.sort(A);\\n        for(int i = 0; i < A.length-2; i++) {\\n            long cnt = 0;\\n            int l = i+1, r = A.length-1;\\n            while(l < r) {\\n                if(A[i] + A[l] + A[r] > target) r--;\\n                else if(A[i] + A[l] + A[r] < target) l++;\\n                else {\\n                    if(A[l] != A[r]) {\\n                        long cntL = 1, cntR = 1;\\n                        while(l+1 < r && A[l] == A[l+1]) { cntL++; l++; }\\n                        while(l < r-1 && A[r] == A[r-1]) { cntR++; r--; }\\n                        cnt += (cntL * cntR) % mod;\\n                        l++;\\n                        r--;\\n                    } else {\\n                        long n = r-l+1;\\n                        cnt += (n * (n-1) / 2) % mod;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans = (int) (ans + cnt) % mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nTime complexity: ```O(N^2)```\\nSpace complexity: ```O(1)```",
                "solutionTags": [],
                "code": "```A[l] == A[r]```\n```num * (num-1) / 2```\n```num = r-l+1```\n```A[l] != A[r]```\n```cntL```\n```cntR```\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int mod = 1000000007;\\n        int ans = 0;\\n        Arrays.sort(A);\\n        for(int i = 0; i < A.length-2; i++) {\\n            long cnt = 0;\\n            int l = i+1, r = A.length-1;\\n            while(l < r) {\\n                if(A[i] + A[l] + A[r] > target) r--;\\n                else if(A[i] + A[l] + A[r] < target) l++;\\n                else {\\n                    if(A[l] != A[r]) {\\n                        long cntL = 1, cntR = 1;\\n                        while(l+1 < r && A[l] == A[l+1]) { cntL++; l++; }\\n                        while(l < r-1 && A[r] == A[r-1]) { cntR++; r--; }\\n                        cnt += (cntL * cntR) % mod;\\n                        l++;\\n                        r--;\\n                    } else {\\n                        long n = r-l+1;\\n                        cnt += (n * (n-1) / 2) % mod;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans = (int) (ans + cnt) % mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```O(N^2)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1918886,
                "title": "simple-java-solution-tc-o-n-2-6-lines-of-code-logic-extension-of-3-sum-problem-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        long count = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < n; i++) {\\n            //similar to two sum problem solution\\n            int new_target = target - arr[i];\\n            int start = i + 1;\\n            int end = n;\\n            HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\\n            \\n            for(int j = start; j < end; j++) {\\n                if(hm.get(new_target - arr[j]) != null) \\n                    count += hm.get(new_target - arr[j]);\\n                if(hm.get(arr[j]) != null)\\n                    hm.put(arr[j], hm.get(arr[j])+1);\\n                else\\n                    hm.put(arr[j], 1);\\n            }\\n        }\\n        return (int)(count % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        long count = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < n; i++) {\\n            //similar to two sum problem solution\\n            int new_target = target - arr[i];\\n            int start = i + 1;\\n            int end = n;\\n            HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\\n            \\n            for(int j = start; j < end; j++) {\\n                if(hm.get(new_target - arr[j]) != null) \\n                    count += hm.get(new_target - arr[j]);\\n                if(hm.get(arr[j]) != null)\\n                    hm.put(arr[j], hm.get(arr[j])+1);\\n                else\\n                    hm.put(arr[j], 1);\\n            }\\n        }\\n        return (int)(count % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918460,
                "title": "easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using Unordered map***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\n    long long mod = 1e9 + 7;\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                int need = target - arr[i] - arr[j];\\n                \\n                count += mp[need];\\n            }\\n            \\n            count %= mod;\\n            \\n            mp[arr[i]]++;\\n        }\\n        \\n        return count % mod;\\n    }\\n```\\n\\n* ***Approach 2 : Using Sorting***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\n    long long mod = 1e9 + 7;\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i <= n - 3; i++)\\n        {\\n            int low = i + 1;\\n            \\n            int high = n - 1;\\n            \\n            int need = target - arr[i];\\n            \\n            while(low < high)\\n            {\\n                if(arr[low] + arr[high] < need)\\n                {\\n                    low++;\\n                }\\n                \\n                else if(arr[low] + arr[high] > need)\\n                {\\n                    high--;\\n                }\\n                \\n                else\\n                {\\n                    if(arr[low] != arr[high])\\n                    {\\n                        int left_count = 1;\\n                        \\n                        int right_count = 1;\\n                        \\n                        while(low < high && arr[low] == arr[low + 1])\\n                        {\\n                            left_count++;\\n                            \\n                            low++;\\n                        }\\n                        \\n                        while(high > low && arr[high] == arr[high - 1])\\n                        {\\n                            right_count++;\\n                            \\n                            high--; \\n                        }\\n                        \\n                        count = (count % mod + left_count % mod * right_count % mod) % mod;\\n                        \\n                        low++;\\n                        \\n                        high--;\\n                    }\\n                    \\n                    else\\n                    {\\n                        int total_duplicate = (high - low + 1);\\n                        \\n                        count = (count % mod + (total_duplicate % mod * (total_duplicate - 1) % mod) / 2) % mod;\\n                        \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    long long mod = 1e9 + 7;\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                int need = target - arr[i] - arr[j];\\n                \\n                count += mp[need];\\n            }\\n            \\n            count %= mod;\\n            \\n            mp[arr[i]]++;\\n        }\\n        \\n        return count % mod;\\n    }\\n```\n```\\n    long long mod = 1e9 + 7;\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i <= n - 3; i++)\\n        {\\n            int low = i + 1;\\n            \\n            int high = n - 1;\\n            \\n            int need = target - arr[i];\\n            \\n            while(low < high)\\n            {\\n                if(arr[low] + arr[high] < need)\\n                {\\n                    low++;\\n                }\\n                \\n                else if(arr[low] + arr[high] > need)\\n                {\\n                    high--;\\n                }\\n                \\n                else\\n                {\\n                    if(arr[low] != arr[high])\\n                    {\\n                        int left_count = 1;\\n                        \\n                        int right_count = 1;\\n                        \\n                        while(low < high && arr[low] == arr[low + 1])\\n                        {\\n                            left_count++;\\n                            \\n                            low++;\\n                        }\\n                        \\n                        while(high > low && arr[high] == arr[high - 1])\\n                        {\\n                            right_count++;\\n                            \\n                            high--; \\n                        }\\n                        \\n                        count = (count % mod + left_count % mod * right_count % mod) % mod;\\n                        \\n                        low++;\\n                        \\n                        high--;\\n                    }\\n                    \\n                    else\\n                    {\\n                        int total_duplicate = (high - low + 1);\\n                        \\n                        count = (count % mod + (total_duplicate % mod * (total_duplicate - 1) % mod) / 2) % mod;\\n                        \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497109,
                "title": "python-hashmap-solution-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: HashMap**\\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        n, MOD = len(arr), 10**9+7\\n        ans = 0\\n        seen = defaultdict(int)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                complement = target - arr[i] - arr[j]\\n                if complement in seen:\\n                    ans = (ans + seen[complement]) % MOD\\n            seen[arr[i]] += 1\\n        \\n        return ans\\n```\\nComplexity:\\n- Time: `O(N^2)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        n, MOD = len(arr), 10**9+7\\n        ans = 0\\n        seen = defaultdict(int)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                complement = target - arr[i] - arr[j]\\n                if complement in seen:\\n                    ans = (ans + seen[complement]) % MOD\\n            seen[arr[i]] += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123891,
                "title": "short-easy-w-explanation-o-n-2-o-n-m-2-beats-100",
                "content": "***Solution - I***\\n\\nWe can **sort the array and use a two pointer technique** on the sorted array. For each `i` in the sorted array, find two indices `j` and `k` (i < j < k) using 2-pointer such that `arr[j] + arr[k] = target - arr[i]`. Now, in a sorted array, duplicated `arr[j]` and `arr[k]` would appear consecutively. \\n\\nFor eg. Suppose we have target=4 and we are searching for `j` and `k` in subarray `[1,1,2,2,2,3,3,3]`. We find j can be 1st index and k can be last index. We pick up all elements equal to `arr[j]` (l=2) and `arr[k]` (r=3). A total of `l*r` will be added to the final count.\\n\\nWe also need to take care when `arr[j]` and `arr[k]` are the same element. In this case, a total of `(k-i) * (k-i+1)/2` has to be added. For eg. if we had a subarray `[2,2,2]` and needed to find such that `arr[j] + arr[k] = 4`, we would have 3 total pairs (`{0,1},{0,2},{1,2}`).\\n\\n**Note :** Sorting won\\'t affect our final answer. We just need to make sure that we choose 3 distinct elements from the array and the pair (i,j,k) is counted just once. Check for some array without and with sort and you would get the idea.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time Complexity :** **`O(N^2)`**, \\n**Space Complexity :** **`O(sort)`**, only extra space needed is the implict space used in sort.\\n\\n---------\\n---------\\n\\n***Solution - II***\\n\\nWe can notice that elements of the array can be at max `100`. We can use this to optimise the solution further.\\n\\nInstead of choosing one index and finding the other two indices using two-pointer as done in previous approach, we can choose each number from `0 to 100` and if it exists in array, find other two numbers.\\n\\nWe need to maintain a frequency array to do this efficiently. We will have following cases (here i,j,k denote value of array we are checking, not indices) - \\n\\n* `i = j = k` : Add `freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6` which is nothing but formula of number of ways to choose three distinct elements from n. \\n* `i = j != k` : Add `freq[k] + (freq[i] * (freq[i] - 1))/2` which denotes that number of `k`s and ways to choose 2 distinct elements from freq[i]\\n* `i != j = k` : Similar to above\\n* `i != j != k` : Just multiply all frequency to get the number of triplet possible.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time complexity :** `O(N + MAX^2)`, where `N` is the number of elemetns in `arr` and `MAX` is the maximum element of array.\\n**Space complexity :** `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/78e7c8d4-3227-43a4-a4be-4407041b7a42_1616509984.6405087.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123835,
                "title": "3sum-with-multiplicity-js-python-java-c-efficient-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to attempt all permutations, but that would run up to **2.7e10** attempts. The first important thing to notice is that the range of numbers is very small at **[0,100]**. With that few number options, any large input array (**A**) will have many duplicates, which means we\\'re looking at a **combinatorics** solution.\\n\\nIn order to use the combinatorics shortcut, however, we\\'ll first have to make a **frequency map** of the numbers in **A**. We could always use a standard map for this, but since the range of numbers is so small and **0-indexed**, it makes more sense to use an **array** instead.\\n\\nAfter we\\'ve iterated through **A** and filled our number map (**nmap**) with the number frequencies, we can get down to the real work. The normal approach here would be to figure out the distinct numbers available and use nested loops to attempt every possible permutation. But rather than doing this, which would require many array calls, we can again take advantage of the fact that the number range is so small.\\n\\nWe can iterate through every possible permutation from **[0,100]**, regardless of wheter the numbers are in **A**. Since we\\'ve made a frequency map, those numbers will be represented as **0**\\'s, which will handily prevent anything from being added to our answer (**ans**) for permutations that we can\\'t make, and by using simple math instead of many array calls, we can actually be more performant.\\n\\nStill, there are ways to streamline this process. The basic approach will be to use a **2-pointer system** to find two of our values and then mathematically figure the third, before applying the proper permutation formula to the values.\\n\\nIt should be apparent that our largest value (**k**) can never go above the target (**T**), nor can it obviously go above the max value of **100**, so we can start it out at **min(T, 100)** and decrement from there. Also, since it will always represents the largest of the three values, it can never go below **T / 3**, because then the two smaller numbers would never be able to bring it up to **T**.\\n\\nMoving down to the next value (**j**), we can see that it can never be larger than **k** by definition, nor can it be larger than the remaining amount of space (**rem**) left to **T**, so we should start it at **min(rem, k)**. Similar to **k**, **j** can also never go below **rem / 2**.\\n\\nOnce we have two of the three values, we can check for their frequencies. If any of them are **0**\\'s, then it will automatically make the result of its permutation check a **0** as well. We can also potentially save some processing by checking for **0**\\'s and **continuing** before applying the combinatorics formulas.\\n\\nIf **i == k**, then we know that **i == j == k** because **j** has to be between **i** and **k**, so we\\'ll have to use the **n choose 3** formula. We should also check if any two other values are the same, then we should use **(n choose 2) * (n choose 1)**. Otherwise, we can just use the simple combinations formula.\\n\\nThen it\\'s important to remember to apply the **modulo** before **returning**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript was actually faster with an approach that featured isolating the actual distinct elements, sorting them, and then running efficiently through the combinations, but the code was much longer and more complex. This method is much easier and nearly as fast. In either case, we should use a typed array here for the arraymap.\\n\\nJava was oddly slower at the iteration shortcuts and actually ran faster without the added processes.\\n\\nJava and C++ should use **long** for their **ans** (prior to returning it, at least), and even for **nmap**, otherwise we\\'ll have to cast those values to **long** each time anyway.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 40.5MB** (beats 100% / 80%).\\n```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **60ms / 14.2MB** (beats 100% / 92%).\\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.3MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 10.2MB** (beats 99% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921963,
                "title": "2pointer-hashmap-solution-with-explanations-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Hashmap.***\\n- Here we\\u2019ll put all the possible combinations of pair sum into our hashmap.\\n- We\\u2019ll search for the number of pairs available that form up the target.\\n- Here **Target = arr[i] + sum of 2 numbers in hashmap.**\\n- In count, we\\u2019ll add all the pairs available of our new target (*after reducing current element from the target).*\\n- After adding the pairs to our answer variable count, we\\u2019ll put all the possible combinations of sum in our hashmap.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- Using ***Two pointers approach.***\\n- For this first, we\\u2019ve to sort the array.\\n- After sorting we\\u2019ll fix an index ***i*** and use 2pointers from [start=***i+1***] ******to [end=***n-1***]***.***\\n- While finding the target there could be 3 possible cases:\\n    1. ***The Sum of 2pointers is greater than our new target:*** `arr[start] + arr[end] > temp`\\n        - In this case, we\\u2019ll simply decrement our end pointer.\\n    2. ***The Sum of 2pointers is smaller than our new target:*** `arr[start] + arr[end] < temp`\\n        - In this case, we\\u2019ll simply increment our start pointer.\\n    3. ***The Sum of 2pointers is equal to our new target:*** `arr[start] + arr[end] == temp`\\n        - Here we\\u2019ve to find if any more element is equal to our start or end elements.\\n        - Take 2 variables: start count ***sc*** & end count ***ec.***\\n        - If `arr[start] == arr[start+1]`, we\\u2019ll increment ***sc*** & if `arr[end] == arr[end-1]`, we\\u2019ll increment ***ec.***\\n        - After getting the count for start and end variables if start & end became the same that means every element is similar. In this case, we\\u2019ll do ***nC2.*** 2 elements from n combinations, where n is the count of ***start*** or ***end*** (sc/ec).\\n        - Else, when start and end do not indicate the same element then we\\u2019ll multiply both start and end count and add it to our ans.\\n- **Time complexity:** O(n^2 + nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size(), mod = 1e9+7, count = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<n; i++){\\n            count = (count + mp[target - arr[i]]) % mod;\\n            \\n            for(int j=0; j<i; j++){\\n                mp[arr[i] + arr[j]]++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int start, end, ans = 0, mod = 1e9+7;\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int temp = target - arr[i];\\n            start = i+1; \\n            end = n-1;\\n            \\n            while(start < end){\\n                if(arr[start] + arr[end] == temp){\\n                    long long sc = 1, ec = 1;\\n                    while(start < end && arr[start] == arr[start+1]){\\n                        start++;\\n                        sc++;\\n                    }\\n                    while(start < end && arr[end] == arr[end-1]){\\n                        end--;\\n                        ec++;\\n                    }\\n                    if(start == end){\\n                        long long temp = (sc*(sc-1))/2; //nC2\\n                        ans = (ans + temp) % mod;\\n                    }\\n                    else{\\n                        ans = ans + (sc*ec) % mod;\\n                    }\\n                    start++;\\n                    end--;\\n                } \\n                else if(arr[start] + arr[end] > temp) end--;\\n                else if(arr[start] + arr[end] < temp) start++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size(), mod = 1e9+7, count = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<n; i++){\\n            count = (count + mp[target - arr[i]]) % mod;\\n            \\n            for(int j=0; j<i; j++){\\n                mp[arr[i] + arr[j]]++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int start, end, ans = 0, mod = 1e9+7;\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int temp = target - arr[i];\\n            start = i+1; \\n            end = n-1;\\n            \\n            while(start < end){\\n                if(arr[start] + arr[end] == temp){\\n                    long long sc = 1, ec = 1;\\n                    while(start < end && arr[start] == arr[start+1]){\\n                        start++;\\n                        sc++;\\n                    }\\n                    while(start < end && arr[end] == arr[end-1]){\\n                        end--;\\n                        ec++;\\n                    }\\n                    if(start == end){\\n                        long long temp = (sc*(sc-1))/2; //nC2\\n                        ans = (ans + temp) % mod;\\n                    }\\n                    else{\\n                        ans = ans + (sc*ec) % mod;\\n                    }\\n                    start++;\\n                    end--;\\n                } \\n                else if(arr[start] + arr[end] > temp) end--;\\n                else if(arr[start] + arr[end] < temp) start++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918580,
                "title": "easy-to-understand-with-explanation",
                "content": "\\narr[i] + arr[j] + arr[k] = target\\n(arr[i] + arr[j]) = (target - arr[k])\\nusing this formula we can easly understand \\nonly firslty we store the sum in the map and after we find the   (target - arr[k]) in the map \\nif find than answer +.\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\nif(isHelpfull)\\n(upvote);",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1919422,
                "title": "c-solution-hashmap",
                "content": "```\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                ans += mp[target-arr[i]-arr[j]];\\n            }\\n            ans =ans%1000000007;\\n            mp[arr[i]]++;\\n        }\\n        return ans%1000000007;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                ans += mp[target-arr[i]-arr[j]];\\n            }\\n            ans =ans%1000000007;\\n            mp[arr[i]]++;\\n        }\\n        return ans%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919126,
                "title": "c-100-simple-solution-o-1000",
                "content": "```\\n#define M (1e9 + 7)\\n\\nint threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0};\\n\\n    for (int i = 0; i < arrSize; i++)\\n        hash[arr[i]]++;\\n\\n    for (int i = 0; i <= 100; i++) {\\n        for (int j = i; j <= 100; j++) {\\n            int k = target - i - j;\\n            if (k < 0 || k > 100) \\n                continue;\\n            if (i < j && j < k)\\n                c += hash[i] * hash[j] * hash[k];\\n            else if (i == j && j == k)\\n                c += hash[i] * (hash[i] - 1) * (hash[i] - 2) / 6;\\n            else if (i == j && i != k)\\n                c += hash[i] * (hash[i] - 1) / 2 * hash[k];\\n        }\\n    }\\n    return (int)(c % (int)M);\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define M (1e9 + 7)\\n\\nint threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0};\\n\\n    for (int i = 0; i < arrSize; i++)\\n        hash[arr[i]]++;\\n\\n    for (int i = 0; i <= 100; i++) {\\n        for (int j = i; j <= 100; j++) {\\n            int k = target - i - j;\\n            if (k < 0 || k > 100) \\n                continue;\\n            if (i < j && j < k)\\n                c += hash[i] * hash[j] * hash[k];\\n            else if (i == j && j == k)\\n                c += hash[i] * (hash[i] - 1) * (hash[i] - 2) / 6;\\n            else if (i == j && i != k)\\n                c += hash[i] * (hash[i] - 1) / 2 * hash[k];\\n        }\\n    }\\n    return (int)(c % (int)M);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123543,
                "title": "python-3-steps-o-n-w",
                "content": "# Idea\\nThe idea is to keep counting the number of elements we have seen so far and keep `ones` and `twos` counters, which correspond to the number of ways given values can be constructed (as a sum) using one and two array elements respectively. So, we iterate over an array and do the following three steps as a pipeline:\\n1. Update the total count by looking up the number of two-sums (`twos`) that if you add current value to would give you `target`.\\n2. Update the number of twosums (`twos`) by looking at the numbers that have appeared before (`ones`).\\n3. Update the counts of numbers that have appeared before (`ones`).\\n\\n# Complexity\\nTime: O(NW), where N is the length of the array and W the number of unique numbers in our array (<= 100 in problem definition).\\nMemory: O(W^2) because of twosum dictionary\\n```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n\\ttotal = 0\\n\\tmod = 10 ** 9 + 7\\n\\n\\tones = defaultdict(int)\\n\\ttwos = defaultdict(int)\\n\\n\\tfor t, v in enumerate(arr):  # O(N)\\n\\t\\ttotal = (total + twos[target - v]) % mod\\n\\t\\tfor k, c in ones.items():  # O(W)\\n\\t\\t\\ttwos[k+v] += c\\n\\t\\tones[v] += 1\\n\\n\\treturn total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n\\ttotal = 0\\n\\tmod = 10 ** 9 + 7\\n\\n\\tones = defaultdict(int)\\n\\ttwos = defaultdict(int)\\n\\n\\tfor t, v in enumerate(arr):  # O(N)\\n\\t\\ttotal = (total + twos[target - v]) % mod\\n\\t\\tfor k, c in ones.items():  # O(W)\\n\\t\\t\\ttwos[k+v] += c\\n\\t\\tones[v] += 1\\n\\n\\treturn total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1919905,
                "title": "java-with-full-code-explanation-3-pointers",
                "content": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        \\n        //mod number\\n        int mod = 1000000007;\\n        \\n        //stores the result count\\n        int count = 0;\\n        \\n        //sorting the array\\n        Arrays.sort(arr);\\n        \\n        //outer loop for first element\\n        for (int index = 0; index < arr.length - 2; index++) {\\n            \\n            //second element\\n            int start = index + 1;\\n            \\n            //third element\\n            int end = arr.length - 1;\\n            \\n            //two pointer approach to find a sum\\n            while (start < end) {\\n                \\n                //if target is found\\n                if (arr[start] + arr[end] + arr[index] == target) {\\n                    \\n                    //special case when we are at the ends of the same number\\n                    // Ex: [...1,2,2,2,2,2]\\n                    //           ^       ^\\n                    //for this we calculate the number of all possible combinations we can make to pick 2 elements i.e. nC2\\n                    if (arr[start] == arr[end]) {\\n                        count += nCr(end - start + 1);\\n                        count %= mod;\\n                        \\n                        //we have already evaluated all combinations for this index\\n                        break;\\n                    }\\n                    \\n                    //general case \\n                    // Ex: [...1,2,2,2,3,4,4]\\n                    //           ^         ^\\n                    // we have to find out all possible 2\\'s and 4\\'s we can make \\n                    // we store them as i and j for start and end pointers respectively\\n                    // for above ex, i=3 and j=2\\n                    // hence total combinations are i*j = 6\\n                    int i = 1, j = 1;\\n                    while (start + 1 < end && arr[start] == arr[start + 1]) {\\n                        start++;\\n                        i++;\\n                    }\\n                    while (start + 1 < end && arr[end] == arr[end - 1]) {\\n                        end--;\\n                        j++;\\n                    }\\n                    count += (i * j);\\n                    count %= mod;\\n                    \\n                    //general condition for 2Sum when target is found\\n                    start++;end--;                  \\n                } else if (arr[start] + arr[end] + arr[index] > target) end--;\\n                else start++;\\n            }\\n        }\\n        return count % mod;\\n    }\\n    \\n    // function to return nC2\\n    private static int nCr(int n) {\\n        return n * (n - 1) / 2;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        \\n        //mod number\\n        int mod = 1000000007;\\n        \\n        //stores the result count\\n        int count = 0;\\n        \\n        //sorting the array\\n        Arrays.sort(arr);\\n        \\n        //outer loop for first element\\n        for (int index = 0; index < arr.length - 2; index++) {\\n            \\n            //second element\\n            int start = index + 1;\\n            \\n            //third element\\n            int end = arr.length - 1;\\n            \\n            //two pointer approach to find a sum\\n            while (start < end) {\\n                \\n                //if target is found\\n                if (arr[start] + arr[end] + arr[index] == target) {\\n                    \\n                    //special case when we are at the ends of the same number\\n                    // Ex: [...1,2,2,2,2,2]\\n                    //           ^       ^\\n                    //for this we calculate the number of all possible combinations we can make to pick 2 elements i.e. nC2\\n                    if (arr[start] == arr[end]) {\\n                        count += nCr(end - start + 1);\\n                        count %= mod;\\n                        \\n                        //we have already evaluated all combinations for this index\\n                        break;\\n                    }\\n                    \\n                    //general case \\n                    // Ex: [...1,2,2,2,3,4,4]\\n                    //           ^         ^\\n                    // we have to find out all possible 2\\'s and 4\\'s we can make \\n                    // we store them as i and j for start and end pointers respectively\\n                    // for above ex, i=3 and j=2\\n                    // hence total combinations are i*j = 6\\n                    int i = 1, j = 1;\\n                    while (start + 1 < end && arr[start] == arr[start + 1]) {\\n                        start++;\\n                        i++;\\n                    }\\n                    while (start + 1 < end && arr[end] == arr[end - 1]) {\\n                        end--;\\n                        j++;\\n                    }\\n                    count += (i * j);\\n                    count %= mod;\\n                    \\n                    //general condition for 2Sum when target is found\\n                    start++;end--;                  \\n                } else if (arr[start] + arr[end] + arr[index] > target) end--;\\n                else start++;\\n            }\\n        }\\n        return count % mod;\\n    }\\n    \\n    // function to return nC2\\n    private static int nCr(int n) {\\n        return n * (n - 1) / 2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1919461,
                "title": "python-3-solution-golang-solution-hashmap-3sum-approach",
                "content": "### Python\\n```py\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        mp, res = {}, 0\\n        for i in range(len(arr)-1):\\n            for j in range(i+1, len(arr)):\\n                diff = target - (arr[i] + arr[j])\\n                res += mp[diff] if diff in mp else 0\\n            \\n            mp[arr[i]] = mp.get(arr[i], 0) + 1\\n            \\n        return res % int(1e9 + 7)\\n```\\n\\n### GoLang [Faster than 93%]\\n```go\\nfunc threeSumMulti(arr []int, target int) int {\\n    \\n    var mp map[int]int = map[int]int{0: 0}\\n    var res int\\n    \\n    for i := 0; i < len(arr)-1; i++ {\\n        for j := i+1; j < len(arr); j++ {\\n            diff := target - (arr[i] + arr[j])\\n            res += mp[diff]\\n        }\\n        mp[arr[i]]++\\n    }\\n    return res % int(1e9 + 7)\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```py\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        mp, res = {}, 0\\n        for i in range(len(arr)-1):\\n            for j in range(i+1, len(arr)):\\n                diff = target - (arr[i] + arr[j])\\n                res += mp[diff] if diff in mp else 0\\n            \\n            mp[arr[i]] = mp.get(arr[i], 0) + 1\\n            \\n        return res % int(1e9 + 7)\\n```\n```go\\nfunc threeSumMulti(arr []int, target int) int {\\n    \\n    var mp map[int]int = map[int]int{0: 0}\\n    var res int\\n    \\n    for i := 0; i < len(arr)-1; i++ {\\n        for j := i+1; j < len(arr); j++ {\\n            diff := target - (arr[i] + arr[j])\\n            res += mp[diff]\\n        }\\n        mp[arr[i]]++\\n    }\\n    return res % int(1e9 + 7)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129130,
                "title": "c-identical-to-3-sum-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int MOD=1e9+7;\\n        unordered_map<int,int> um;\\n        long ans=0;\\n        int n=arr.size();\\n        \\n        //Storing frequency in hashtable\\n        for(int i=0;i<n;i++){\\n            um[arr[i]]++;\\n        }\\n        \\n        //Sorting as order won\\'t matter (Think deeply)\\n        sort(arr.begin(),arr.end());\\n        \\n        int i=0;\\n        \\n        while(i<n){ //Will increment i inside loop\\n            int low=i+1,high=n-1;\\n            \\n            while(low<high){\\n                \\n                //Three elements are arr[i] , arr[low] and arr[high]\\n                int sum=arr[i]+arr[low]+arr[high];\\n                \\n                if(sum==target){\\n                   \\n                    //Case 1 : All three elements are same\\n                    if(arr[i]==arr[low] && arr[i]==arr[high]){\\n                        long count=um[arr[i]];\\n                        count=(count)*(count-1)*(count-2)/6;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Case 2 : Any two elements are same \\n                    else if(arr[i]==arr[low]){\\n                        long count=um[arr[i]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[high]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    else if(arr[i]==arr[high]){\\n                        long count=um[arr[i]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[low]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    else if(arr[low]==arr[high]){\\n                        long count=um[arr[low]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[i]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Case 3: All elements are unique\\n                    else{\\n                        long count=((um[arr[i]]*um[arr[low]])%MOD * um[arr[high]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Incrementing low in tricky way to avoid duplication\\n                    low=low+1;\\n                    while(low<high && arr[low]==arr[low-1]){\\n                        low++;\\n                    }\\n                }\\n                else if(sum<target){\\n                    low++;\\n                }\\n                else{\\n                    high--;\\n                }\\n            }\\n\\t\\t\\t\\n            int j=i+1;           //Increment i accordingly\\n            while(j<n && arr[j]==arr[i]){\\n                j++;\\n            }\\n            \\n            i=j;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - O(n^2)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int MOD=1e9+7;\\n        unordered_map<int,int> um;\\n        long ans=0;\\n        int n=arr.size();\\n        \\n        //Storing frequency in hashtable\\n        for(int i=0;i<n;i++){\\n            um[arr[i]]++;\\n        }\\n        \\n        //Sorting as order won\\'t matter (Think deeply)\\n        sort(arr.begin(),arr.end());\\n        \\n        int i=0;\\n        \\n        while(i<n){ //Will increment i inside loop\\n            int low=i+1,high=n-1;\\n            \\n            while(low<high){\\n                \\n                //Three elements are arr[i] , arr[low] and arr[high]\\n                int sum=arr[i]+arr[low]+arr[high];\\n                \\n                if(sum==target){\\n                   \\n                    //Case 1 : All three elements are same\\n                    if(arr[i]==arr[low] && arr[i]==arr[high]){\\n                        long count=um[arr[i]];\\n                        count=(count)*(count-1)*(count-2)/6;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Case 2 : Any two elements are same \\n                    else if(arr[i]==arr[low]){\\n                        long count=um[arr[i]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[high]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    else if(arr[i]==arr[high]){\\n                        long count=um[arr[i]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[low]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    else if(arr[low]==arr[high]){\\n                        long count=um[arr[low]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[i]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Case 3: All elements are unique\\n                    else{\\n                        long count=((um[arr[i]]*um[arr[low]])%MOD * um[arr[high]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Incrementing low in tricky way to avoid duplication\\n                    low=low+1;\\n                    while(low<high && arr[low]==arr[low-1]){\\n                        low++;\\n                    }\\n                }\\n                else if(sum<target){\\n                    low++;\\n                }\\n                else{\\n                    high--;\\n                }\\n            }\\n\\t\\t\\t\\n            int j=i+1;           //Increment i accordingly\\n            while(j<n && arr[j]==arr[i]){\\n                j++;\\n            }\\n            \\n            i=j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123718,
                "title": "c-solution-base-on-3-sum-and-2-sum-approach",
                "content": "For each element we run the two sum approach for remaining elements.\\nTwo sum approach -\\nThe basic idea is to maintain a hash table for each element num in nums, using num as key and its number of times it appear as value. For each num, search for target - num in the hash table. If it is found we add it to the answer.\\n\\nThe code is as follows. Note that each time before we add count of a number to m, we search for target - num first and if it is >=0 then add it to the answer.\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long ans=0;\\n        int n = arr.size();\\n        vector<int> m(305,0);\\n        for(int i=0;i<n;i++){\\n            for(int i=0;i<305;i++) m[i]=0;\\n            for(int j=i+1;j<n;j++){\\n                long req = target - arr[i]-arr[j];\\n                if(req>=0) ans+=m[req];\\n                m[arr[j]]++;\\n            }\\n        }\\n        return (int)(ans%(1000000007));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long ans=0;\\n        int n = arr.size();\\n        vector<int> m(305,0);\\n        for(int i=0;i<n;i++){\\n            for(int i=0;i<305;i++) m[i]=0;\\n            for(int j=i+1;j<n;j++){\\n                long req = target - arr[i]-arr[j];\\n                if(req>=0) ans+=m[req];\\n                m[arr[j]]++;\\n            }\\n        }\\n        return (int)(ans%(1000000007));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920150,
                "title": "python-a-general-solution-dynamic-programming",
                "content": "Given an integer array`arr`, and an integer`target`, return the number of tuples`i, j, k`such that`i < j < k`and`arr[i] + arr[j] + arr[k] == target`.\\n\\nAs the answer can be very large, return it **modulo** `10^9 + 7`.\\n\\n## Violent Solution\\n\\n```python\\nn = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nfor i in range(n - 2):\\n    if arr[i] > target:\\n        continue\\n    for j in range(i + 1, n - 1):\\n        if arr[j] + arr[i] > target:\\n            continue\\n        for k in range(j + 1, n):\\n            if arr[i] + arr[j] + arr[k] == target:\\n                output += 1\\n                \\n    output %= mode\\n    \\nreturn int(output)\\n```\\n\\nViolent solution is the simplest, but the running time exceeds the limit.\\n\\n## Math Solution\\n\\nThe answer of this question is the number of combinations, we can solve it by sampling.\\n\\nFirst, group the array `arr` and sorted.\\n\\n```python\\nfrom collections import Counter\\n\\ngroups = Counter(arr)\\n\\nsorted_group = sorted(groups.items(), key=lambda x: x[0])\\n```\\n\\nThen, get all possible combinations.\\n\\n```python\\nn = len(sorted_group)\\n\\ncombinations = []\\n\\nfor i in range(n):\\n    for j in range(n):\\n        for k in range(n):\\n            if i + j + k == target:\\n                combinations.append((i, j, k))\\n```\\n\\nFinally, get the final result. There are three situations should be considered.\\n\\nSuppose `a`, `b`, `c` is a combination in `combinations`. Suppose `x`, `y`, `z` are corresponding times. We can get:\\n1. if `a == b == c`, we can get $C_{x}^{3}$ tuples;\\n2. if `a == b != c` or `a == c != b` or `b == c != a`, we can get $C_{x}^{2} \\\\cdot z$ or $C_{x}^{2} \\\\cdot y$ or $C_{y}^{2} \\\\cdot x$ tuples;\\n3. if `a != b != c`, we can get $x \\\\cdot y \\\\cdot z$ tuples.\\n\\n```python\\ndef get_solution_num(a, b, c, x, y, z):\\n    # The input has been sorted: a <= b <= c\\n    if a == b:\\n        if b == c:\\n            return x * (x - 1) * (x - 2) / 6\\n        else:\\n            return x * (x - 1) / 2 * z\\n    elif b == c:\\n        return x * y * y / 2\\n    else:\\n        return x * y * z\\n```\\n\\nThe full code of this solution:\\n```python\\nfrom collections import Counter\\n\\nmode = 1e9 + 7\\noutput = 0\\n\\ngroups = Counter(arr)\\nsorted_group = sorted(groups.items(), key=lambda x: x[0])\\n\\nn = len(sorted_group)\\nfor i in range(n):\\n    for j in range(i, n):\\n        sum2 = sorted_group[i][0] + sorted_group[j][0]\\n        remain = target - sum2\\n        for k in range(j, n):\\n            if sorted_group[k][0] == remain:\\n                if i == j:\\n                    if j == k:\\n                        output += sorted_group[i][1] * (sorted_group[i][1] - 1) * (sorted_group[i][1] - 2) / 6\\n                    else:\\n                        output += sorted_group[i][1] * (sorted_group[i][1] - 1) * sorted_group[k][1] / 2\\n                else:\\n                    if j == k:\\n                        output += sorted_group[i][1] * sorted_group[j][1] * (sorted_group[j][1] - 1) / 2\\n                    else:\\n                        output += sorted_group[i][1] * sorted_group[j][1] * sorted_group[k][1]\\n                            \\nreturn int(output % mode)\\n```\\n\\n## General Solution: Dynamic Programming\\n\\nWe can solve this problem in 3 steps.\\n\\n### First - 2Sum - Fixed `a`\\n\\nWe first solve a 2Sum problem. Given a number `a` and target `m`, try to find the frequence of `b` in an array `arr`, which satisfies `a + b = m`.\\n\\nThe solution of this problem is simple:\\n```python\\nb = m - a\\noutput = 0\\n\\nfor i in range(n):\\n    if arr[i] == b:\\n        output += 1\\n        \\nreturn output\\n```\\n\\n### Second - 2Sum - Dynamic `a`\\n\\nThe second problem is: given an array `arr` and target `m`, try to find the number of combinations `(a, b)`, which satisfies `a + b = m`.\\n\\nSuppose the frequence of `a` is `x` when the index is `i`. If the value of index `i + 1` is `b` and `a+b=m`, the number of tuple `(a, b)` is `x` for the array `arr[:i+1]`\\n\\nSo, the solution of this problem can be:\\n```python\\nfrom collections import defaultdict\\n\\ntemp = defaultdict(int)\\noutput = 0\\n\\ntemp[arr[0]] = 1\\nfor i in range(1, n):\\n    for j in temp:\\n        if arr[i] + j == m:\\n            output += temp[j]\\n            break\\n    temp[arr[i]] += 1\\n    \\nreturn output\\n```\\n\\n### Third - 3Sum -Dynamic `a` and `b`\\n\\nFirst, suppose the frequence of `d` is `x` when the index is `i`. If the value of index `i+1` is `c` and `d + c = m`, the number of tuple `(d, c)` is `x` for the array `arr[:i+1]`.\\n\\nThen, the problem become a 2Sum problem: given an array `arr[:i]` and target `d`, try to find the number of tuples `(a, b)`, which satisfies `a + b = d`.\\n\\nSo, the solution of this problem can be:\\n\\n```python\\nfrom collections import defaultdict\\n\\nn = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nl1 = defaultdict(int)\\nl2 = defaultdict(int)\\n\\nfor x in arr:\\n    if x > target:\\n        continue\\n\\n    for z in l2:\\n        if x + z == target:\\n            output += l2[z]\\n            output %= mode\\n\\n    for y in l1:\\n        if x + y > target:\\n            continue\\n\\n        l2[x + y] += l1[y]\\n\\n    l1[x] += 1\\n\\nreturn int(output)\\n```\\n\\n### Extention: n-Sum\\n\\nWe can extend this problem to nSum: Given an integer array `arr` and the `target`, return the number of tuples `a1, a2, ..., an`, such that `a1 + a2 + \\u2026 + an = target` and `a1 < a2 < ... < an`.\\n\\nThe solution can be:\\n```python\\nfrom collections import defaultdict\\n\\ntotal = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nlevels = [defaultdict(int) for _ in range(n - 1)]\\n\\nfor x in arr:\\n    if x > target:\\n        continue\\n        \\n    for i in range(n - 2, 0, -1):\\n        if i == n - 2:\\n            for j in levels[i]:\\n                if x + j == target:\\n                    output += levels[i][j]\\n                    output %= mode\\n        else:\\n            for j in levels[i]:\\n                if x + j > target:\\n                    continue\\n                levels[i + 1][x + j] += levels[i][j]\\n                \\n    levels[0][x] += 1\\n    \\nreturn int(output)\\n```\\n\\nWhen `n=3`, it is also the solution of problem 923 in LeetCode.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nn = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nfor i in range(n - 2):\\n    if arr[i] > target:\\n        continue\\n    for j in range(i + 1, n - 1):\\n        if arr[j] + arr[i] > target:\\n            continue\\n        for k in range(j + 1, n):\\n            if arr[i] + arr[j] + arr[k] == target:\\n                output += 1\\n                \\n    output %= mode\\n    \\nreturn int(output)\\n```\n```python\\nfrom collections import Counter\\n\\ngroups = Counter(arr)\\n\\nsorted_group = sorted(groups.items(), key=lambda x: x[0])\\n```\n```python\\nn = len(sorted_group)\\n\\ncombinations = []\\n\\nfor i in range(n):\\n    for j in range(n):\\n        for k in range(n):\\n            if i + j + k == target:\\n                combinations.append((i, j, k))\\n```\n```python\\ndef get_solution_num(a, b, c, x, y, z):\\n    # The input has been sorted: a <= b <= c\\n    if a == b:\\n        if b == c:\\n            return x * (x - 1) * (x - 2) / 6\\n        else:\\n            return x * (x - 1) / 2 * z\\n    elif b == c:\\n        return x * y * y / 2\\n    else:\\n        return x * y * z\\n```\n```python\\nfrom collections import Counter\\n\\nmode = 1e9 + 7\\noutput = 0\\n\\ngroups = Counter(arr)\\nsorted_group = sorted(groups.items(), key=lambda x: x[0])\\n\\nn = len(sorted_group)\\nfor i in range(n):\\n    for j in range(i, n):\\n        sum2 = sorted_group[i][0] + sorted_group[j][0]\\n        remain = target - sum2\\n        for k in range(j, n):\\n            if sorted_group[k][0] == remain:\\n                if i == j:\\n                    if j == k:\\n                        output += sorted_group[i][1] * (sorted_group[i][1] - 1) * (sorted_group[i][1] - 2) / 6\\n                    else:\\n                        output += sorted_group[i][1] * (sorted_group[i][1] - 1) * sorted_group[k][1] / 2\\n                else:\\n                    if j == k:\\n                        output += sorted_group[i][1] * sorted_group[j][1] * (sorted_group[j][1] - 1) / 2\\n                    else:\\n                        output += sorted_group[i][1] * sorted_group[j][1] * sorted_group[k][1]\\n                            \\nreturn int(output % mode)\\n```\n```python\\nb = m - a\\noutput = 0\\n\\nfor i in range(n):\\n    if arr[i] == b:\\n        output += 1\\n        \\nreturn output\\n```\n```python\\nfrom collections import defaultdict\\n\\ntemp = defaultdict(int)\\noutput = 0\\n\\ntemp[arr[0]] = 1\\nfor i in range(1, n):\\n    for j in temp:\\n        if arr[i] + j == m:\\n            output += temp[j]\\n            break\\n    temp[arr[i]] += 1\\n    \\nreturn output\\n```\n```python\\nfrom collections import defaultdict\\n\\nn = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nl1 = defaultdict(int)\\nl2 = defaultdict(int)\\n\\nfor x in arr:\\n    if x > target:\\n        continue\\n\\n    for z in l2:\\n        if x + z == target:\\n            output += l2[z]\\n            output %= mode\\n\\n    for y in l1:\\n        if x + y > target:\\n            continue\\n\\n        l2[x + y] += l1[y]\\n\\n    l1[x] += 1\\n\\nreturn int(output)\\n```\n```python\\nfrom collections import defaultdict\\n\\ntotal = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nlevels = [defaultdict(int) for _ in range(n - 1)]\\n\\nfor x in arr:\\n    if x > target:\\n        continue\\n        \\n    for i in range(n - 2, 0, -1):\\n        if i == n - 2:\\n            for j in levels[i]:\\n                if x + j == target:\\n                    output += levels[i][j]\\n                    output %= mode\\n        else:\\n            for j in levels[i]:\\n                if x + j > target:\\n                    continue\\n                levels[i + 1][x + j] += levels[i][j]\\n                \\n    levels[0][x] += 1\\n    \\nreturn int(output)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1919678,
                "title": "java-3-pointers-explained",
                "content": "**Idea:**\\n* Find frequency of each num in arr\\n* Create an array of unique nums in arr and sort this array\\n* Now use the same 3 pointers technique used in [LC 15. 3Sum](https://leetcode.com/problems/3sum/discuss/339850/Java-or-Two-pointers-or-Time-beats-100-or-Memory-beats-93)\\n* You\\'ll also need to used the following combinatorial logic for counting the triplets\\n\\n![image](https://assets.leetcode.com/users/images/5475e97e-9af2-4c6e-ac61-fc9a9a78fe3e_1649247866.065716.png)\\n\\n>**T/S:** O(n + w\\xB2)/O(w), where n = size(arr), w = max(arr)\\n```\\nprivate static final int MOD = (int) (1e9 + 7);\\n\\npublic int threeSumMulti(int[] arr, int target) {\\n\\tvar count = getNumToFrequency(arr);\\n\\tvar nums = getUnique(count);\\n\\tvar triplets = 0L;\\n\\n\\tfor (int i = 0, n = nums.length; i < n; i++)\\n\\t\\tfor (int j = i, k = n - 1; j <= k; ) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\tif (i == j && j == k)\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * (count.get(nums[j]) - 1) * (count.get(nums[k]) - 2) / 6;\\n\\t\\t\\t\\telse if (i == j || j == k)\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * (count.get(nums[j]) - 1) * count.get(nums[k]) / 2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * count.get(nums[j]) * count.get(nums[k]);\\n\\n\\t\\t\\t\\ttriplets %= MOD;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn (int) triplets;\\n}\\n\\nprivate Map<Integer, Integer> getNumToFrequency(int[] arr) {\\n\\tvar numToFrequency = new HashMap<Integer, Integer>();\\n\\tfor (var num : arr)\\n\\t\\tnumToFrequency.compute(num, (k, v) -> v == null ? 1 : ++v);\\n\\treturn numToFrequency;\\n}\\n\\nprivate Integer[] getUnique(Map<Integer, Integer> count) {\\n\\tvar nums = count.keySet().toArray(new Integer[0]);\\n\\tArrays.sort(nums);\\n\\treturn nums;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static final int MOD = (int) (1e9 + 7);\\n\\npublic int threeSumMulti(int[] arr, int target) {\\n\\tvar count = getNumToFrequency(arr);\\n\\tvar nums = getUnique(count);\\n\\tvar triplets = 0L;\\n\\n\\tfor (int i = 0, n = nums.length; i < n; i++)\\n\\t\\tfor (int j = i, k = n - 1; j <= k; ) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\tif (i == j && j == k)\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * (count.get(nums[j]) - 1) * (count.get(nums[k]) - 2) / 6;\\n\\t\\t\\t\\telse if (i == j || j == k)\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * (count.get(nums[j]) - 1) * count.get(nums[k]) / 2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * count.get(nums[j]) * count.get(nums[k]);\\n\\n\\t\\t\\t\\ttriplets %= MOD;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn (int) triplets;\\n}\\n\\nprivate Map<Integer, Integer> getNumToFrequency(int[] arr) {\\n\\tvar numToFrequency = new HashMap<Integer, Integer>();\\n\\tfor (var num : arr)\\n\\t\\tnumToFrequency.compute(num, (k, v) -> v == null ? 1 : ++v);\\n\\treturn numToFrequency;\\n}\\n\\nprivate Integer[] getUnique(Map<Integer, Integer> count) {\\n\\tvar nums = count.keySet().toArray(new Integer[0]);\\n\\tArrays.sort(nums);\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919448,
                "title": "c-simple-dynamic-programming-approach",
                "content": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\npublic:\\n    int dp[3002][4][302];\\n    int rec(vector<int>& arr,int idx,int cnt,int target){\\n        if(cnt == 0)    return target == 0;\\n        else if(idx >= arr.size())  return 0;\\n        else if(target < 0) return 0;\\n        else if(dp[idx][cnt][target] != -1) return dp[idx][cnt][target];\\n        \\n        int pick = rec(arr,idx+1,cnt-1,target-arr[idx]);\\n        int notPick = rec(arr,idx+1,cnt,target);\\n        \\n        return dp[idx][cnt][target] = (pick%mod + notPick%mod)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(arr,0,3,target);\\n    }\\n};\\n```\\n\\nTime Complexity Would be : O(n*target*4)\\nSpace Complexity Would be : O(n*target*4)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\npublic:\\n    int dp[3002][4][302];\\n    int rec(vector<int>& arr,int idx,int cnt,int target){\\n        if(cnt == 0)    return target == 0;\\n        else if(idx >= arr.size())  return 0;\\n        else if(target < 0) return 0;\\n        else if(dp[idx][cnt][target] != -1) return dp[idx][cnt][target];\\n        \\n        int pick = rec(arr,idx+1,cnt-1,target-arr[idx]);\\n        int notPick = rec(arr,idx+1,cnt,target);\\n        \\n        return dp[idx][cnt][target] = (pick%mod + notPick%mod)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(arr,0,3,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919227,
                "title": "all-3sum-problems-solved-with-the-same-code-with-slight-modification",
                "content": "All 3sum problems on Leetcode:\\n* [3sum](https://leetcode.com/problems/3sum/)\\n* [3sum with multiplicity](https://leetcode.com/problems/3sum-with-multiplicity)\\n* [3sum closest](https://leetcode.com/problems/3sum-closest/)\\n* [3sum smaller](https://leetcode.com/problems/3sum-smaller/) [\\uD83D\\uDCB2subscription needed!] \\n\\nThis article has solutions to the above first 3 problems, all of which can be solved using **[Two Pointers](https://leetcode.com/tag/two-pointers/)** approach, with just few modifications.\\n\\n<br>\\n\\n**C++ solutions:**\\n\\n**1. 3sum**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 2) return {};\\n        \\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        \\n        for (int i = 0; i < n-2; i++) {\\n            \\n            /* MODIFICATION 1:\\n            Here we add some conditions just to\\n            reduce the time required to search \\n            otherwise you\\'ll get solution, but it\\'s TLE! */\\n            if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {\\n            \\n                int T = 0 - nums[i];\\n                int j = i+1, k = n-1;\\n\\n                while (j < k) {\\n                    if (nums[j] + nums[k] < T)\\n                        j++;\\n                    else if (nums[j] + nums[k] == T) {\\n                        ans.emplace_back(vector<int>{nums[i], nums[j], nums[k]});\\n\\n                        /* MODIFICATION 2:\\n                        Take care of duplicates: */\\n                        while (j < k && nums[j] == nums[j+1]) j++;\\n                        while (j < k && nums[k] == nums[k-1]) k--;\\n\\n                        j++, k--;\\n\\n                    } else if (nums[j] + nums[k] > T)\\n                        k--;\\n                }\\n            \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**2. 3sum closest**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        if (n <= 2) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        int closest_sum = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for (int i = 0; i < n; i++) {\\n\\n            int T = target - nums[i];\\n            int j = i+1, k = n-1;\\n            \\n            while (j < k) {\\n                \\n                /* MODIFICATION: \\n                Keep track of the sum every time,\\n                because we need to find the closest sum\\n                */\\n                int curr_sum = nums[i] + nums[j] + nums[k];\\n                int curr_diff = abs(curr_sum - target);\\n                if (curr_diff < min_diff) {\\n                    closest_sum = curr_sum;\\n                    min_diff = curr_diff;\\n                }\\n                \\n                if (nums[j] + nums[k] < T)\\n                    j++;\\n                else if (nums[j] + nums[k] > T)\\n                    k--;\\n                else if (nums[j] + nums[k] == T) {\\n                    closest_sum = nums[i] + nums[j] + nums[k];\\n                    return closest_sum;\\n                }\\n            }\\n        }\\n        \\n        return closest_sum;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**3. 3sum with multiplicity**\\n\\nSolution with explanation can be found [here](https://leetcode.com/problems/3sum-with-multiplicity/discuss/1918974/Comprehensive-explanation-in-comments-C++-Two-pointer-approach)\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        if (n <= 2) return -1;\\n        \\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n\\n            while (j < k) {\\n                \\n                /* MODIFICATION: \\n                Here we need to handle additional cases\\n                where there are duplicates.\\n                Also, a small modification is that we need\\n                to store the answer as answer%10^9 + 7\\n                */\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    ans += left*right;\\n                    ans %= MOD;\\n                    j++, k--;\\n                } else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```\\n\\n<br>\\n\\nFor all the above solutions:\\nTime complexity: **O(n<sup>2</sup>)**\\nSpace complexity: **O(1)**\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 2) return {};\\n        \\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        \\n        for (int i = 0; i < n-2; i++) {\\n            \\n            /* MODIFICATION 1:\\n            Here we add some conditions just to\\n            reduce the time required to search \\n            otherwise you\\'ll get solution, but it\\'s TLE! */\\n            if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {\\n            \\n                int T = 0 - nums[i];\\n                int j = i+1, k = n-1;\\n\\n                while (j < k) {\\n                    if (nums[j] + nums[k] < T)\\n                        j++;\\n                    else if (nums[j] + nums[k] == T) {\\n                        ans.emplace_back(vector<int>{nums[i], nums[j], nums[k]});\\n\\n                        /* MODIFICATION 2:\\n                        Take care of duplicates: */\\n                        while (j < k && nums[j] == nums[j+1]) j++;\\n                        while (j < k && nums[k] == nums[k-1]) k--;\\n\\n                        j++, k--;\\n\\n                    } else if (nums[j] + nums[k] > T)\\n                        k--;\\n                }\\n            \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        if (n <= 2) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        int closest_sum = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for (int i = 0; i < n; i++) {\\n\\n            int T = target - nums[i];\\n            int j = i+1, k = n-1;\\n            \\n            while (j < k) {\\n                \\n                /* MODIFICATION: \\n                Keep track of the sum every time,\\n                because we need to find the closest sum\\n                */\\n                int curr_sum = nums[i] + nums[j] + nums[k];\\n                int curr_diff = abs(curr_sum - target);\\n                if (curr_diff < min_diff) {\\n                    closest_sum = curr_sum;\\n                    min_diff = curr_diff;\\n                }\\n                \\n                if (nums[j] + nums[k] < T)\\n                    j++;\\n                else if (nums[j] + nums[k] > T)\\n                    k--;\\n                else if (nums[j] + nums[k] == T) {\\n                    closest_sum = nums[i] + nums[j] + nums[k];\\n                    return closest_sum;\\n                }\\n            }\\n        }\\n        \\n        return closest_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        if (n <= 2) return -1;\\n        \\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n\\n            while (j < k) {\\n                \\n                /* MODIFICATION: \\n                Here we need to handle additional cases\\n                where there are duplicates.\\n                Also, a small modification is that we need\\n                to store the answer as answer%10^9 + 7\\n                */\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    ans += left*right;\\n                    ans %= MOD;\\n                    j++, k--;\\n                } else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919075,
                "title": "short-easy-to-read-solution-inspired-in-two-sum",
                "content": "# The idea\\nIn <a href=\"https://leetcode.com/problems/two-sum/\">1. Two Sum</a> we used a hash map to keep track of what numbers we had seen before. For each `i`, we we asked if `target - nums[i]` was a key of that hash map. In that problem we used the hash map to keep track of the indices of the numbers we had seen. This time we\\'ll use it to keep track of how many times we\\'ve seen that value before.\\n\\nWe tried an approach that does not require sorting the list `arr`, which resulted in a solution that takes **O(n<sup>2</sup>)** time.\\n\\n# The algorithm\\nWe have a hash map that counts the ocurrences of each different value in `arr`. The keys of this hash map will represent the numbers `arr[i]` in the sums `arr[i] + arr[j] + arr[k]`. \\n\\nWe initialize our hash map as\\n```\\n        nums = Counter(arr[:1])\\n```\\nso at first it only considers `arr[0]`.\\n\\nFor each `j` in `[1, n - 2]` and for each `k` in `[j + 1, n - 1]` we check if `target - arr[k] - arr[j]` is a key on our hash map. If it is, we add its frequency to our answer (since this frequency tells us how many sums of the form `key + arr[j] + arr[k]` are equal to `target`). Then we update the count of `arr[j]` in our hash map and move on to the next `j`.\\n# The code\\n```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        n = len(arr)\\n        toReturn = 0\\n        \\n        nums = Counter(arr[:1])\\n        for j in range(1, n - 1):\\n            for k in range(j + 1, n):\\n                toReturn = (toReturn + nums[target - arr[k] - arr[j]]) % 1000000007  \\n            nums[arr[j]] += 1\\n\\n        return toReturn\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        nums = Counter(arr[:1])\\n```\n```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        n = len(arr)\\n        toReturn = 0\\n        \\n        nums = Counter(arr[:1])\\n        for j in range(1, n - 1):\\n            for k in range(j + 1, n):\\n                toReturn = (toReturn + nums[target - arr[k] - arr[j]]) % 1000000007  \\n            nums[arr[j]] += 1\\n\\n        return toReturn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125684,
                "title": "simple-solution-with-explanation-o-nxn-hashing-c",
                "content": "**Brute Force Approach:**\\nWe will iterate through 3 loops and find all the triplets satsfying the equation, but this will surely give TLE as O(n^3) solution.\\n```\\n//Pseudocode \\n\\t\\tint ans = 0, n = arr.size(), i,j,k;\\n        for(i = 0; i<n; ++i){\\n            for(j = i+1; j<n; ++j){\\n                for(k = j +1; k<n; ++k){\\n                    if(arr[i] + arr[j] + arr[k] == target)\\n                        ans++;\\n                }\\n            }\\n        }\\n```\\n**Final Sollution Approah O(n^2):**\\nWe can think in a manner like we have to find all the triplets where, \\narr[k] = target - arr[i] - arr[j], by doing we can can minimize the tine complexity to O(n^2).This can be achived using the hashmap.\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        ll i,j,k,n = arr.size();\\n        unordered_map<ll, ll> freq;\\n        ll ans = 0;\\n        for(i = 0; i<n; ++i){\\n            \\n            for(j = i+1; j<n; ++j){\\n                ans+= freq[target - arr[i] - arr[j]];\\n            } \\n            freq[arr[i]]++;\\n        }\\n        \\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```\\n\\nWe will add the arr[i] to hashMap after the inner loop ends, as we have to keep in mind that i<j<k.\\n\\nPlease upvote if this helped you, any suggestion is appreciated :-).",
                "solutionTags": [],
                "code": "```\\n//Pseudocode \\n\\t\\tint ans = 0, n = arr.size(), i,j,k;\\n        for(i = 0; i<n; ++i){\\n            for(j = i+1; j<n; ++j){\\n                for(k = j +1; k<n; ++k){\\n                    if(arr[i] + arr[j] + arr[k] == target)\\n                        ans++;\\n                }\\n            }\\n        }\\n```\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        ll i,j,k,n = arr.size();\\n        unordered_map<ll, ll> freq;\\n        ll ans = 0;\\n        for(i = 0; i<n; ++i){\\n            \\n            for(j = i+1; j<n; ++j){\\n                ans+= freq[target - arr[i] - arr[j]];\\n            } \\n            freq[arr[i]]++;\\n        }\\n        \\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124355,
                "title": "slow-but-easy-n-2-js-ts-solution",
                "content": "Explanation\\n* Make a map with all pair sums.\\n* If ***target - arr[i]*** in map, add count of pair sum.\\n\\n```\\n// JS\\nvar threeSumMulti = function (arr, target) {\\n  const map = new Map();\\n  const mod = 1000000007;\\n  let res = 0;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    res = (res + (map.get(target - arr[i]) || 0)) % mod;\\n\\n    for (let j = 0; j < i; j++) {\\n      let temp = arr[i] + arr[j];\\n      map.set(temp, (map.get(temp) || 0) + 1);\\n    }\\n  }\\n\\n  return res;\\n};\\n```\\n\\n```\\n// TS\\nfunction threeSumMulti(arr: number[], target: number): number {\\n  const map = new Map<number, number>();\\n  const mod = 1000000007;\\n  let res = 0;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    res = (res + (map.get(target - arr[i]) || 0)) % mod;\\n\\n    for (let j = 0; j < i; j++) {\\n      let temp = arr[i] + arr[j];\\n      map.set(temp, (map.get(temp) || 0) + 1);\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// JS\\nvar threeSumMulti = function (arr, target) {\\n  const map = new Map();\\n  const mod = 1000000007;\\n  let res = 0;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    res = (res + (map.get(target - arr[i]) || 0)) % mod;\\n\\n    for (let j = 0; j < i; j++) {\\n      let temp = arr[i] + arr[j];\\n      map.set(temp, (map.get(temp) || 0) + 1);\\n    }\\n  }\\n\\n  return res;\\n};\\n```\n```\\n// TS\\nfunction threeSumMulti(arr: number[], target: number): number {\\n  const map = new Map<number, number>();\\n  const mod = 1000000007;\\n  let res = 0;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    res = (res + (map.get(target - arr[i]) || 0)) % mod;\\n\\n    for (let j = 0; j < i; j++) {\\n      let temp = arr[i] + arr[j];\\n      map.set(temp, (map.get(temp) || 0) + 1);\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124268,
                "title": "c-solution-2-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        int sum = 0;\\n        int ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum = target-arr[i];\\n            \\n            int left = i+1;\\n            int right = n-1;\\n            \\n            while(left < right)\\n            {\\n                if(arr[left]+arr[right] < sum)\\n                    left++;\\n                else if(arr[left]+arr[right] > sum)\\n                    right--;\\n                else\\n                {\\n                    int j = left;\\n                    int k = right;\\n                    int count1 = 0, count2 = 0;\\n                    \\n                    while(j <= right && arr[j] == arr[left])\\n                    {\\n                        count1++;\\n                        j++;\\n                    }\\n                    if(j > right)\\n                    {\\n                        int ans_here = (count1*(count1-1))/2;\\n                        ans = (ans+ans_here)%MOD;\\n                    }\\n                    else\\n                    {\\n                        while(k >= j && arr[k] == arr[right])\\n                        {\\n                            count2++;\\n                            k--;\\n                        }\\n                        ans = (ans+(count1*count2)%MOD)%MOD;\\n                    }\\n                    left = j;\\n                right = k;\\n               }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        int sum = 0;\\n        int ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum = target-arr[i];\\n            \\n            int left = i+1;\\n            int right = n-1;\\n            \\n            while(left < right)\\n            {\\n                if(arr[left]+arr[right] < sum)\\n                    left++;\\n                else if(arr[left]+arr[right] > sum)\\n                    right--;\\n                else\\n                {\\n                    int j = left;\\n                    int k = right;\\n                    int count1 = 0, count2 = 0;\\n                    \\n                    while(j <= right && arr[j] == arr[left])\\n                    {\\n                        count1++;\\n                        j++;\\n                    }\\n                    if(j > right)\\n                    {\\n                        int ans_here = (count1*(count1-1))/2;\\n                        ans = (ans+ans_here)%MOD;\\n                    }\\n                    else\\n                    {\\n                        while(k >= j && arr[k] == arr[right])\\n                        {\\n                            count2++;\\n                            k--;\\n                        }\\n                        ans = (ans+(count1*count2)%MOD)%MOD;\\n                    }\\n                    left = j;\\n                right = k;\\n               }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123865,
                "title": "rust-counting-with-cases-solution",
                "content": "```rust\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn three_sum_multi(arr: Vec<i32>, target: i32) -> i32 {\\n        let mut counts = vec![0_i64; 101];\\n        arr.iter().for_each(|&n| counts[n as usize] += 1);\\n        let mut answer = 0;\\n        for i in 0..=100 {\\n            for j in i..=100 {\\n                let k = target - i - j;\\n                if (j..=100).contains(&k) {\\n                    let (ci, cj, ck) = (counts[i as usize], counts[j as usize], counts[k as usize]);\\n                    answer += match (i == j, j == k) {\\n                        (false, false) => ci * cj * ck,\\n                        (false, true) => ci * cj * (cj - 1) / 2,\\n                        (true, false) => ci * (ci - 1) / 2 * ck,\\n                        (true, true) => ci * (ci - 1) * (ci - 2) / 6,\\n                    };\\n                    answer %= MOD;\\n                }\\n            }\\n        }\\n        answer as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn three_sum_multi(arr: Vec<i32>, target: i32) -> i32 {\\n        let mut counts = vec![0_i64; 101];\\n        arr.iter().for_each(|&n| counts[n as usize] += 1);\\n        let mut answer = 0;\\n        for i in 0..=100 {\\n            for j in i..=100 {\\n                let k = target - i - j;\\n                if (j..=100).contains(&k) {\\n                    let (ci, cj, ck) = (counts[i as usize], counts[j as usize], counts[k as usize]);\\n                    answer += match (i == j, j == k) {\\n                        (false, false) => ci * cj * ck,\\n                        (false, true) => ci * cj * (cj - 1) / 2,\\n                        (true, false) => ci * (ci - 1) / 2 * ck,\\n                        (true, true) => ci * (ci - 1) * (ci - 2) / 6,\\n                    };\\n                    answer %= MOD;\\n                }\\n            }\\n        }\\n        answer as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212882,
                "title": "c-dp-10-line",
                "content": "```\\n    int threeSumMulti(vector<int>& A, int target) {\\n       const long long mod = 1e9 + 7;\\n       vector<vector<long long>> dp(3, vector<long long>(target + 1, 0));\\n       for (auto x : A) {\\n          if(x>target) continue;\\n          for (int i = target - x; i >= 0; i--) {\\n             dp[2][i + x] += dp[1][i]; dp[2][i + x] %= mod;\\n             dp[1][i + x] += dp[0][i]; dp[1][i + x] %= mod;\\n          }\\n          dp[0][x]++;\\n       }\\n       return dp[2][target];\\n    }",
                "solutionTags": [],
                "code": "```\\n    int threeSumMulti(vector<int>& A, int target) {\\n       const long long mod = 1e9 + 7;\\n       vector<vector<long long>> dp(3, vector<long long>(target + 1, 0));\\n       for (auto x : A) {\\n          if(x>target) continue;\\n          for (int i = target - x; i >= 0; i--) {\\n             dp[2][i + x] += dp[1][i]; dp[2][i + x] %= mod;\\n             dp[1][i + x] += dp[0][i]; dp[1][i + x] %= mod;\\n          }\\n          dp[0][x]++;\\n       }\\n       return dp[2][target];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 182417,
                "title": "c-dynamic-programming-is-quick-and-easy-once-you-master-it",
                "content": "Oct. 22, 2018\\nIt is the medium level algorithm in the weekly contest 106. In order to improve the contest performance, I like to learn a few ways to solve the algorithm after the contest. The dynamic programming solution is easy to write and it is quick and fast, I also wrote down my understanding as well. \\n\\nHow to think about the dynamic programming solution?\\nGo over each element in the array, for each sum from 0 to target, consider if current element is counted or not. If it is not counted, then the ways should be previous one, the same value; if it is counted, then the ways should be added by the value of smaller value ```(sum - currentValue)```. \\n\\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// dp[i][j][k] represents number of combinations using k numbers within \\n        /// A[0] ... A[i] with the sum of j.\\n        /// Then dp[n][target][3] is the result. \\n        /// Time complexity: O(n * target)\\n        /// three dimension array, first dimension there is n options, n <= 3000\\n        /// second option, target <= 300, 301 option. \\n        /// \\n        /// The idea is from \\n        /// https://leetcode.com/problems/3sum-with-multiplicity/discuss/181125/Knapsack-O(n-*-target)-or-Straightforward-O(n2)\\n        /// How to think about the dynamic programming solution?\\n        /// Go over each element in the array, for each sum from 0 to target, \\n        /// consider if current element is counted or not. If it is not counted, then the ways \\n        /// should be previous one, the same value; if it is counted, then the ways should be added by the value\\n        /// of smaller value (sum - currentValue). \\n        /// </summary>\\n        /// <param name=\"numbers\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <returns></returns>\\n        public int ThreeSumMulti(int[] numbers, int target)\\n        {\\n            int n = numbers.Length; \\n            int maximum = (int)1e9 + 7;\\n\\n            var dp = new int[n + 1, target + 1, 4]; // n+1, target + 1, 4\\n\\n            for (int i = 0; i <= n; i++) {\\n                dp[i, 0, 0] = 1;  // why?\\n            }\\n\\n            for (int i = 1; i < n + 1; i++) \\n            {\\n                for (int sum = 0; sum <= target; sum++) \\n                {\\n                    for (int k = 1; k <= 3; k++) \\n                    {\\n                        dp[i, sum, k]  = dp[i - 1, sum, k]; // based on the same sum \\n                        dp[i, sum, k] %= maximum;\\n\\n                        var current = numbers[i - 1];\\n\\n                        if (sum >= current)\\n                        {\\n                            var smallerSum = sum - current; // based on the smaller sum\\n\\n                            dp[i, sum, k] += dp[i - 1, smallerSum, k - 1];  // increment the value \\n                            dp[i, sum, k] %= maximum;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return dp[n, target, 3];\\n        }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```(sum - currentValue)```\n```\\npublic class Solution {\\n    /// <summary>\\n        /// dp[i][j][k] represents number of combinations using k numbers within \\n        /// A[0] ... A[i] with the sum of j.\\n        /// Then dp[n][target][3] is the result. \\n        /// Time complexity: O(n * target)\\n        /// three dimension array, first dimension there is n options, n <= 3000\\n        /// second option, target <= 300, 301 option. \\n        /// \\n        /// The idea is from \\n        /// https://leetcode.com/problems/3sum-with-multiplicity/discuss/181125/Knapsack-O(n-*-target)-or-Straightforward-O(n2)\\n        /// How to think about the dynamic programming solution?\\n        /// Go over each element in the array, for each sum from 0 to target, \\n        /// consider if current element is counted or not. If it is not counted, then the ways \\n        /// should be previous one, the same value; if it is counted, then the ways should be added by the value\\n        /// of smaller value (sum - currentValue). \\n        /// </summary>\\n        /// <param name=\"numbers\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <returns></returns>\\n        public int ThreeSumMulti(int[] numbers, int target)\\n        {\\n            int n = numbers.Length; \\n            int maximum = (int)1e9 + 7;\\n\\n            var dp = new int[n + 1, target + 1, 4]; // n+1, target + 1, 4\\n\\n            for (int i = 0; i <= n; i++) {\\n                dp[i, 0, 0] = 1;  // why?\\n            }\\n\\n            for (int i = 1; i < n + 1; i++) \\n            {\\n                for (int sum = 0; sum <= target; sum++) \\n                {\\n                    for (int k = 1; k <= 3; k++) \\n                    {\\n                        dp[i, sum, k]  = dp[i - 1, sum, k]; // based on the same sum \\n                        dp[i, sum, k] %= maximum;\\n\\n                        var current = numbers[i - 1];\\n\\n                        if (sum >= current)\\n                        {\\n                            var smallerSum = sum - current; // based on the smaller sum\\n\\n                            dp[i, sum, k] += dp[i - 1, smallerSum, k - 1];  // increment the value \\n                            dp[i, sum, k] %= maximum;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return dp[n, target, 3];\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907659,
                "title": "java-sorting-two-pointers-no-extra-space",
                "content": "# Please Upvote :D\\n---\\n``` java []\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        long ans = 0;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            int sum = target - arr[i];\\n            int l = i + 1, r = n - 1;\\n\\n            while (l < r) {\\n                if (arr[l] + arr[r] < sum) l++;\\n                else if (arr[l] + arr[r] > sum) r--;\\n                else {\\n                    int count1 = 1, count2 = 1;\\n\\n                    if (arr[l] == arr[r]) {\\n                        int len = r - l + 1;\\n                        ans += (len * (len - 1) / 2);\\n                        break;\\n                    }\\n\\n                    while (l < r && arr[l] == arr[l + 1]) {\\n                        count1++;\\n                        l++;\\n                    }\\n\\n                    while (r > l && arr[r] == arr[r - 1]) {\\n                        count2++;\\n                        r--;\\n                    }\\n\\n                    ans += (count1 * count2);\\n                    l++; r--;\\n                }\\n            }\\n        }\\n\\n        return (int) (ans % 1000000007);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 2) ~ O(n ^ 2)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        long ans = 0;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            int sum = target - arr[i];\\n            int l = i + 1, r = n - 1;\\n\\n            while (l < r) {\\n                if (arr[l] + arr[r] < sum) l++;\\n                else if (arr[l] + arr[r] > sum) r--;\\n                else {\\n                    int count1 = 1, count2 = 1;\\n\\n                    if (arr[l] == arr[r]) {\\n                        int len = r - l + 1;\\n                        ans += (len * (len - 1) / 2);\\n                        break;\\n                    }\\n\\n                    while (l < r && arr[l] == arr[l + 1]) {\\n                        count1++;\\n                        l++;\\n                    }\\n\\n                    while (r > l && arr[r] == arr[r - 1]) {\\n                        count2++;\\n                        r--;\\n                    }\\n\\n                    ans += (count1 * count2);\\n                    l++; r--;\\n                }\\n            }\\n        }\\n\\n        return (int) (ans % 1000000007);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 2) ~ O(n ^ 2)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920634,
                "title": "using-binary-search-3-sum-approach",
                "content": "```\\nint threeSumMulti(vector<int>& arr, int t) \\n    {\\n        \\n        sort(arr.begin() , arr.end());\\n    int n = arr.size();\\n    int count=0;\\n       int mod = 1e9 +7;\\n    \\n\\tfor(int i=0;i<=n-3;i++)\\n         {\\n             int l=i+1 , r= n-1;\\n             \\n             int sm = t-arr[i];\\n             while(l<r)\\n             {\\n                 if(arr[l] + arr[r] == sm)\\n                 {\\n                       int cnt1=1, cnt2=1;\\n                    while (l < r && arr[l] == arr[l+1]) {cnt1++; l++;}\\n                    while (l < r && arr[r] == arr[r-1]) {cnt2++; r--;}\\n                     \\n                      if (l == r) count =(count+cnt1*(cnt1-1)/2)%mod;    // possiblities\\n\\t\\t\\t\\t\\t\\n                    else count = (count +cnt1*cnt2)%mod;\\n                    l++; r--;   \\n                 }\\n                 else if(arr[l] + arr[r] >sm)r--;\\n                 else l++;\\n             }\\n         }\\n    \\n    return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int t) \\n    {\\n        \\n        sort(arr.begin() , arr.end());\\n    int n = arr.size();\\n    int count=0;\\n       int mod = 1e9 +7;\\n    \\n\\tfor(int i=0;i<=n-3;i++)\\n         {\\n             int l=i+1 , r= n-1;\\n             \\n             int sm = t-arr[i];\\n             while(l<r)\\n             {\\n                 if(arr[l] + arr[r] == sm)\\n                 {\\n                       int cnt1=1, cnt2=1;\\n                    while (l < r && arr[l] == arr[l+1]) {cnt1++; l++;}\\n                    while (l < r && arr[r] == arr[r-1]) {cnt2++; r--;}\\n                     \\n                      if (l == r) count =(count+cnt1*(cnt1-1)/2)%mod;    // possiblities\\n\\t\\t\\t\\t\\t\\n                    else count = (count +cnt1*cnt2)%mod;\\n                    l++; r--;   \\n                 }\\n                 else if(arr[l] + arr[r] >sm)r--;\\n                 else l++;\\n             }\\n         }\\n    \\n    return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1920129,
                "title": "java-two-solution-100-faster-easy-understanding",
                "content": "**First solution**\\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        int arrLen = arr.length;\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        long[] count = new long[101];\\n        long result = 0;\\n        \\n        for (int i = 0; i < arrLen; i++) {\\n            count[arr[i]]++;\\n        }\\n        \\n        // when i != j and j != k and i != k\\n        for (int i = 0; i <= 100; i++) {\\n            for (int j = i + 1; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (j < k && k <= 100) {\\n                    result += count[i] * count[j] * count[k];\\n                    result %= modulo;\\n                }\\n            }\\n        }\\n        \\n        // x == y == z\\n        if (target % 3 == 0) {\\n            int i = target / 3;\\n            if (0 <= i && i <= 100) {\\n                result += count[i] * (count[i] - 1) * (count[i] - 2) / 6;\\n                result %= modulo;\\n            }\\n        }\\n            \\n        // x == y != z\\n        for (int i = 0; i <= 100; i++) {\\n            int k = target - 2 * i;\\n            if (i < k && k <= 100) {\\n                result += count[i] * (count[i] - 1) / 2 * count[k];\\n                result %= modulo;\\n            }\\n        }\\n\\n        // x != y == z\\n        for (int i = 0; i <= 100; i++) {\\n            if (target % 2 == i % 2) {\\n                int j = (target - i) / 2;\\n                if (i < j && j <= 100) {\\n                    result += count[i] * count[j] * (count[j] - 1) / 2;\\n                    result %= modulo;\\n                }\\n            }\\n        }\\n\\n        return (int) result;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/0ed6c476-a432-430f-914d-9d6f371c2952_1649259950.9620552.png)\\n\\n\\n\\n**Second solution**\\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int arrLen = arr.length;\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        int result = 0;\\n        \\n        for (int i = 0; i < arrLen; i++) {\\n            \\n            int j = i + 1;\\n            int k = arrLen - 1;\\n            int tmp = target - arr[i];\\n            \\n            while (j < k) {\\n                int sum = arr[j] + arr[k];\\n                \\n                if (sum < tmp) {\\n                    j++;\\n                } else if (sum > tmp) {\\n                    k--;\\n                } else {\\n                    if (arr[j] != arr[k]) {\\n                        int left = 1;\\n                        int right = 1;\\n                        \\n                        while (j + 1 < k && arr[j] == arr[j + 1]) {\\n                            left++;\\n                            j++;\\n                        }\\n                        \\n                        while (k - 1 > j && arr[k] == arr[k - 1]) {\\n                            right++;\\n                            k--;\\n                        }\\n                        \\n                        result += left * right;\\n                        result %= modulo;\\n                        j++;\\n                        k--;\\n                    } else {\\n                        result += (k - j + 1) * (k - j) / 2;\\n                        result %= modulo;\\n                        break;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return result;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/c7636eff-d41b-4479-8e29-0e98e4a9763b_1649251756.2134578.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        int arrLen = arr.length;\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        long[] count = new long[101];\\n        long result = 0;\\n        \\n        for (int i = 0; i < arrLen; i++) {\\n            count[arr[i]]++;\\n        }\\n        \\n        // when i != j and j != k and i != k\\n        for (int i = 0; i <= 100; i++) {\\n            for (int j = i + 1; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (j < k && k <= 100) {\\n                    result += count[i] * count[j] * count[k];\\n                    result %= modulo;\\n                }\\n            }\\n        }\\n        \\n        // x == y == z\\n        if (target % 3 == 0) {\\n            int i = target / 3;\\n            if (0 <= i && i <= 100) {\\n                result += count[i] * (count[i] - 1) * (count[i] - 2) / 6;\\n                result %= modulo;\\n            }\\n        }\\n            \\n        // x == y != z\\n        for (int i = 0; i <= 100; i++) {\\n            int k = target - 2 * i;\\n            if (i < k && k <= 100) {\\n                result += count[i] * (count[i] - 1) / 2 * count[k];\\n                result %= modulo;\\n            }\\n        }\\n\\n        // x != y == z\\n        for (int i = 0; i <= 100; i++) {\\n            if (target % 2 == i % 2) {\\n                int j = (target - i) / 2;\\n                if (i < j && j <= 100) {\\n                    result += count[i] * count[j] * (count[j] - 1) / 2;\\n                    result %= modulo;\\n                }\\n            }\\n        }\\n\\n        return (int) result;\\n    }\\n```\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int arrLen = arr.length;\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        int result = 0;\\n        \\n        for (int i = 0; i < arrLen; i++) {\\n            \\n            int j = i + 1;\\n            int k = arrLen - 1;\\n            int tmp = target - arr[i];\\n            \\n            while (j < k) {\\n                int sum = arr[j] + arr[k];\\n                \\n                if (sum < tmp) {\\n                    j++;\\n                } else if (sum > tmp) {\\n                    k--;\\n                } else {\\n                    if (arr[j] != arr[k]) {\\n                        int left = 1;\\n                        int right = 1;\\n                        \\n                        while (j + 1 < k && arr[j] == arr[j + 1]) {\\n                            left++;\\n                            j++;\\n                        }\\n                        \\n                        while (k - 1 > j && arr[k] == arr[k - 1]) {\\n                            right++;\\n                            k--;\\n                        }\\n                        \\n                        result += left * right;\\n                        result %= modulo;\\n                        j++;\\n                        k--;\\n                    } else {\\n                        result += (k - j + 1) * (k - j) / 2;\\n                        result %= modulo;\\n                        break;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919797,
                "title": "simple-approach-using-two-pointer-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n     \\n    \\n     int solve(vector<int>& arr ,int target ,int i ,vector<int> v,vector<int>& mp){\\n         long long int m = 1e9 + 7 , res = 0;\\n         \\n         for(;i<arr.size();i++){\\n             v[arr[i]]++;\\n             int curr = target - arr[i];\\n             if(curr <= 100 && curr>=0) res = res%m + (mp[curr] - v[curr])%m;\\n         }\\n         \\n         return (int)res%m;\\n     }\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        long long int m = 1e9 + 7 , res = 0;\\n        \\n        vector<int> v(101,0) , mp(101,0);\\n        \\n        for(int i=0;i<arr.size();i++) mp[arr[i]]++;\\n        \\n        for(int i=0;i<n;i++){\\n            v[arr[i]]++;\\n            res = res%m + solve(arr ,target - arr[i] , i+1 ,v,mp) % m;\\n        }\\n        \\n        return (int)res%m;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    \\n     int solve(vector<int>& arr ,int target ,int i ,vector<int> v,vector<int>& mp){\\n         long long int m = 1e9 + 7 , res = 0;\\n         \\n         for(;i<arr.size();i++){\\n             v[arr[i]]++;\\n             int curr = target - arr[i];\\n             if(curr <= 100 && curr>=0) res = res%m + (mp[curr] - v[curr])%m;\\n         }\\n         \\n         return (int)res%m;\\n     }\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        long long int m = 1e9 + 7 , res = 0;\\n        \\n        vector<int> v(101,0) , mp(101,0);\\n        \\n        for(int i=0;i<arr.size();i++) mp[arr[i]]++;\\n        \\n        for(int i=0;i<n;i++){\\n            v[arr[i]]++;\\n            res = res%m + solve(arr ,target - arr[i] , i+1 ,v,mp) % m;\\n        }\\n        \\n        return (int)res%m;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919198,
                "title": "c-3-sum-approach-easy-sort-daily-leetcoding-challenge-april-day-6",
                "content": "**Do Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        // for stroing the frequency of sum pairs \\n        map<int,int> mp;\\n        \\n        // initializing the modulo and result \\n        int mod = 1e9 + 7;\\n        int res = 0;\\n        \\n        // for taking the the 1st vaule out of 3\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            // if (target-arr[i]) is available in my map\\n            // it means we are having a pair that is equal to our target\\n            // so just add the combinations to the result\\n            // arr[i] + arr[j] + arr[k] = target => (arr[i] + arr[j]) = (target - arr[k])\\n            res = (res + mp[target - arr[i]]) % mod;\\n            \\n            // storing all the pair for given value \\n            for(int j=0;j<i;j++)\\n            {\\n                mp[arr[i]+arr[j]]++;\\n            }\\n        }\\n        \\n        // returning the final result\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        // for stroing the frequency of sum pairs \\n        map<int,int> mp;\\n        \\n        // initializing the modulo and result \\n        int mod = 1e9 + 7;\\n        int res = 0;\\n        \\n        // for taking the the 1st vaule out of 3\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            // if (target-arr[i]) is available in my map\\n            // it means we are having a pair that is equal to our target\\n            // so just add the combinations to the result\\n            // arr[i] + arr[j] + arr[k] = target => (arr[i] + arr[j]) = (target - arr[k])\\n            res = (res + mp[target - arr[i]]) % mod;\\n            \\n            // storing all the pair for given value \\n            for(int j=0;j<i;j++)\\n            {\\n                mp[arr[i]+arr[j]]++;\\n            }\\n        }\\n        \\n        // returning the final result\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918781,
                "title": "dp-pick-or-notpick-approach-c",
                "content": "```\\n\\tint mod= 1e9+7;\\n    int dp[3001][301][4];\\n    int solve(int i, int count, vector<int> &arr, int target){\\n      if(count==0 && target==0) return 1;\\n      if(i>=arr.size()) return 0;\\n      if(count==0 | target<0) return 0;\\n      \\n      if(dp[i][target][count]!=-1) return dp[i][target][count];\\n      \\n      int pick=0, notPick= 0;\\n      notPick= solve(i+1, count, arr, target);\\n      pick= arr[i]<=target ? solve(i+1, count-1, arr, target-arr[i]) : 0;\\n      \\n      return dp[i][target][count]=(pick+notPick)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 3, arr, target);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint mod= 1e9+7;\\n    int dp[3001][301][4];\\n    int solve(int i, int count, vector<int> &arr, int target){\\n      if(count==0 && target==0) return 1;\\n      if(i>=arr.size()) return 0;\\n      if(count==0 | target<0) return 0;\\n      \\n      if(dp[i][target][count]!=-1) return dp[i][target][count];\\n      \\n      int pick=0, notPick= 0;\\n      notPick= solve(i+1, count, arr, target);\\n      pick= arr[i]<=target ? solve(i+1, count-1, arr, target-arr[i]) : 0;\\n      \\n      return dp[i][target][count]=(pick+notPick)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 3, arr, target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918550,
                "title": "java-combination-1ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long[] counts = new long[101];\\n        int kMod = 1_000_000_007;\\n        int max = 0;\\n        for (int num: arr) {\\n            counts[num]++;\\n            max = Math.max(max, num);\\n        }\\n        long total = 0;\\n        for(int i = 0; i <= max; i++) {\\n            for(int j = i; j <= max; j++) {\\n                int k = target - i - j;\\n                if (k >= j && k <= max) {\\n                    if (counts[i]== 0 || counts[j] == 0 || counts[k] == 0) continue;\\n                    if (i == j && i == k) {\\n                        total += combination(counts[i], 3);\\n                    } else if (i == j && j != k) {\\n                        total += combination(counts[i], 2) * counts[k];\\n                    } else if (i != j && j == k) {\\n                        total += combination(counts[j], 2) * counts[i];\\n                    } else {\\n                        total += counts[i] * counts[j] * counts[k];\\n                    }\\n                }\\n            }\\n        }\\n        return (int)(total % kMod);\\n    }\\n    private long combination(long x, long y) {\\n        if(x < y) return 0;\\n        if(x == y) return 1;\\n        if(y == 2) return (x * (x - 1) >> 1);            \\n        else return (x * (x - 1) >> 1) * (x - 2) / 3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long[] counts = new long[101];\\n        int kMod = 1_000_000_007;\\n        int max = 0;\\n        for (int num: arr) {\\n            counts[num]++;\\n            max = Math.max(max, num);\\n        }\\n        long total = 0;\\n        for(int i = 0; i <= max; i++) {\\n            for(int j = i; j <= max; j++) {\\n                int k = target - i - j;\\n                if (k >= j && k <= max) {\\n                    if (counts[i]== 0 || counts[j] == 0 || counts[k] == 0) continue;\\n                    if (i == j && i == k) {\\n                        total += combination(counts[i], 3);\\n                    } else if (i == j && j != k) {\\n                        total += combination(counts[i], 2) * counts[k];\\n                    } else if (i != j && j == k) {\\n                        total += combination(counts[j], 2) * counts[i];\\n                    } else {\\n                        total += counts[i] * counts[j] * counts[k];\\n                    }\\n                }\\n            }\\n        }\\n        return (int)(total % kMod);\\n    }\\n    private long combination(long x, long y) {\\n        if(x < y) return 0;\\n        if(x == y) return 1;\\n        if(y == 2) return (x * (x - 1) >> 1);            \\n        else return (x * (x - 1) >> 1) * (x - 2) / 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918473,
                "title": "java-solution-easy-approach",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        HashMap<Integer, Integer> hm=new HashMap<>();\\n        int mod=(int)(1e9+7);\\n        hm.put(arr[0], 1);\\n        int ans=0;\\n        for(int i=1;i<arr.length;i++) {\\n            for(int j=i+1;j<arr.length;j++) {\\n                if(arr[i]+arr[j]>target) \\n                    continue;\\n                else {\\n                    int re=target-(arr[i]+arr[j]);\\n                    if(hm.containsKey(re)) \\n                        ans=(ans%mod+hm.get(re)%mod)%mod;\\n                }\\n            }\\n            if(hm.containsKey(arr[i])) \\n                hm.put(arr[i], hm.get(arr[i])+1);\\n            \\n            else \\n                hm.put(arr[i], 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        HashMap<Integer, Integer> hm=new HashMap<>();\\n        int mod=(int)(1e9+7);\\n        hm.put(arr[0], 1);\\n        int ans=0;\\n        for(int i=1;i<arr.length;i++) {\\n            for(int j=i+1;j<arr.length;j++) {\\n                if(arr[i]+arr[j]>target) \\n                    continue;\\n                else {\\n                    int re=target-(arr[i]+arr[j]);\\n                    if(hm.containsKey(re)) \\n                        ans=(ans%mod+hm.get(re)%mod)%mod;\\n                }\\n            }\\n            if(hm.containsKey(arr[i])) \\n                hm.put(arr[i], hm.get(arr[i])+1);\\n            \\n            else \\n                hm.put(arr[i], 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125653,
                "title": "java-simple-and-easy-to-understand-solution-2-ms-faster-than-97-14-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    \\n    static int MOD = 1_000_000_007; \\n    \\n    public int threeSumMulti(int[] arr, int target) {\\n        long tupleCount = 0;\\n        \\n        long[] counts = new long[101];\\n        for(int num : arr){\\n            counts[num]++;\\n        }\\n        \\n        \\n        //All different, x != y != z\\n        for(int x = 0; x <= 100; x++){\\n            for(int y = x + 1; y <= 100; y++){\\n                int z = target - x - y;\\n                if(z > y && z <= 100){\\n                    tupleCount += (counts[x] * counts[y] * counts[z]);\\n                    tupleCount %= MOD;\\n                }\\n            }\\n        }\\n        \\n        //x == y != z\\n        for(int x = 0; x <= 100; x++){\\n            int z = target - 2 * x;\\n            if(z > x && z <= 100){\\n\\t\\t\\t\\t//selecting two items when there is  counts[y] identical items\\n                tupleCount += ((counts[x] * (counts[x] - 1) / 2) * counts[z]);\\n                tupleCount %= MOD;\\n            }\\n        }\\n        \\n\\t\\t\\n        //x != (y == z)\\n\\t\\tfor(int x = 0; x <= 100; x++){\\n            int yz = target - x;\\n            if(yz % 2 == 0){\\n                int y = yz / 2;\\n                if(y > x && y <= 100){\\n\\t\\t\\t\\t\\t//selecting two items when there is  counts[y] identical items\\n                    tupleCount += (counts[x] * (counts[y] * (counts[y] - 1) / 2) );\\n                    tupleCount %= MOD;\\n                } \\n                \\n            }\\n        }\\n        \\n        \\n        //x == y == z\\n\\t\\t\\n        if(target % 3 == 0){\\n            int x = target / 3;\\n\\t\\t\\t//selective 3 items items when there is counts[x] identical items\\n            tupleCount += (counts[x] * (counts[x] - 1) * (counts[x] - 2)) / 6;\\n            tupleCount %= MOD;\\n        }\\n        \\n        \\n        return (int) tupleCount;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int MOD = 1_000_000_007; \\n    \\n    public int threeSumMulti(int[] arr, int target) {\\n        long tupleCount = 0;\\n        \\n        long[] counts = new long[101];\\n        for(int num : arr){\\n            counts[num]++;\\n        }\\n        \\n        \\n        //All different, x != y != z\\n        for(int x = 0; x <= 100; x++){\\n            for(int y = x + 1; y <= 100; y++){\\n                int z = target - x - y;\\n                if(z > y && z <= 100){\\n                    tupleCount += (counts[x] * counts[y] * counts[z]);\\n                    tupleCount %= MOD;\\n                }\\n            }\\n        }\\n        \\n        //x == y != z\\n        for(int x = 0; x <= 100; x++){\\n            int z = target - 2 * x;\\n            if(z > x && z <= 100){\\n\\t\\t\\t\\t//selecting two items when there is  counts[y] identical items\\n                tupleCount += ((counts[x] * (counts[x] - 1) / 2) * counts[z]);\\n                tupleCount %= MOD;\\n            }\\n        }\\n        \\n\\t\\t\\n        //x != (y == z)\\n\\t\\tfor(int x = 0; x <= 100; x++){\\n            int yz = target - x;\\n            if(yz % 2 == 0){\\n                int y = yz / 2;\\n                if(y > x && y <= 100){\\n\\t\\t\\t\\t\\t//selecting two items when there is  counts[y] identical items\\n                    tupleCount += (counts[x] * (counts[y] * (counts[y] - 1) / 2) );\\n                    tupleCount %= MOD;\\n                } \\n                \\n            }\\n        }\\n        \\n        \\n        //x == y == z\\n\\t\\t\\n        if(target % 3 == 0){\\n            int x = target / 3;\\n\\t\\t\\t//selective 3 items items when there is counts[x] identical items\\n            tupleCount += (counts[x] * (counts[x] - 1) * (counts[x] - 2)) / 6;\\n            tupleCount %= MOD;\\n        }\\n        \\n        \\n        return (int) tupleCount;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125330,
                "title": "c-frequency-table-based-solution-explained-100-time-95-memory",
                "content": "This is an interesting problem that mixes combinatorics and the need to build a frequency map in order to keep things doable; the basic idea is that once you have verified that, say, `ni`, `nj` and `nk` sum up to `target`, there is no need to compute that again, over and over.\\n\\nThere are a few compilications when one or all of those numbers are the same, but that is about it, really!\\n\\nIn order to solve this problem, we will first of all declare externally a `static constexpr` our modulo upper limit, `rem`, as demanded in the specs.\\n\\nIn our main function, we will then declare a few more support variables:\\n* `uniques` is going to store all our unique values in the `0 - 100` range (hence the size of `101`);\\n* `uPos` is both a pointer on where to write in `uniques` next and the number of the currently found unique values;\\n* `freqs` stores the frequencies of each number found, initially all set to `0`;\\n* `res` is our usual accumulator variable for the result, initialised to `0`;\\n* `tmp` is, as the name implies, a temporary variable where we will store the value of each combination we find.\\n\\nNext, time to parse our initial input once and for all, in order to store its information in a more convenient way, so, for each number `n` in `arr`, we will:\\n* `continue` is that number is just too big to be used to reach `target` (I might optimise checking the 2 smallest values first, but not sure it would be convenient);\\n* store it in `uniques` while also increasing `uPos` if it is the first time we encountered it;\\n* increase its matching cell in `freqs`.\\n\\nOnce done, for convenience we will sort all the unique values that we found in order to just explore all the possible combinations that are with a non-decreasing triplet of numbers; sorting now should be relatively cheap, handling at most `101` different elements.\\n\\nThe bigger part of the works comes here and we will start with an external loop, going with `i` from `0` up to `uPos` (excluded) and:\\n* assign the current unique pointed by `i` to `ni`;\\n* compute `ti` as `target - 2 * ni`;\\n* `break` out of the loop if `ni` is too big;\\n* start a nested loop with `j` going from either `i` or `i + 1`, depending on whether or not `freqs[ni] < 2`, still up to `uPos` excluded and:\\n\\t* assign the current unique pointed by `j` to `nj`;\\n\\t* compute `nk` (the missing bit) as `target - ni - nj`;\\n\\t* `break` out of the loop if `nj > nk`, since we again want only combinations in non-decreasing order to avoid repetitions;\\n\\t* `continue` if `nk` is too big (ie: `> 100`, hoping to get a smaller value later, with a bigger `nj`;\\n\\t* provided `nk` exists at least once (ie: `freqs[nk]`), we will then have 3 cases to consider to compute `tmp`:\\n\\t\\t* all 3 numbers are equal, so `tmp` is going to be their frequency choose `3`: `freqs[ni] * (freqs[ni] - 1) * (freqs[ni] - 2) / 6`;\\n\\t\\t* 2 numbers are equal, trickier case, so we:\\n\\t\\t\\t* identify the equal values in `eq` and the different one in `diff`;\\n\\t\\t\\t* compute `tmp` as the product of `freqs[eq]` choose `2` and `freqs[diff]`;\\n\\t\\t* all numbers are different, so we just multiply their respective frequencies to compute `tmp`\\n\\t* finally, we will add `tmp` to `res`.\\n\\nOnce done, we can just return `res % modCut` and be done :)\\n\\nThe code:\\n\\n```cpp\\nstatic constexpr int modCut = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int uniques[101], uPos = 0;\\n        long freqs[101] = {}, res = 0, tmp;\\n        // populating freq\\n        for (int n: arr) {\\n            // ignoring too large numbers\\n            if (n > target) continue;\\n            // storing n if it is the first time we encounter it\\n            if (!freqs[n]) uniques[uPos++] = n;\\n            // increasing its frequency\\n            freqs[n]++;\\n        }\\n        sort(uniques, uniques + uPos);\\n        // computing all the possible combos\\n        for (int i = 0, ni, ti; i < uPos; i++) {\\n            ni = uniques[i];\\n            ti = target - 2 * ni;\\n            // skipping if it is too big\\n            if (ni > ti) break;\\n            for (int j = i + (freqs[ni] < 2), nj, nk, eq, diff; j < uPos; j++) {\\n                nj = uniques[j];\\n                nk = target - nj - ni;\\n                // stopping if it is too big\\n                if (nj > nk) break;\\n                // skipping if it is too big\\n                if (nk > 100) continue;\\n                if (freqs[nk]) {\\n                    if (ni == nj && nj == nk) tmp = freqs[ni] * (freqs[ni] - 1) * (freqs[ni] - 2) / 6;\\n                    else if (ni == nj || ni == nk || nj == nk) {\\n                        eq = ni == nj || ni == nk ? ni : nk;\\n                        diff = ni != nj ? (nj != nk ? nj : ni) : nk;\\n                        tmp = freqs[eq] * (freqs[eq] - 1) / 2 * freqs[diff];\\n                    }\\n                    else tmp = freqs[ni] * freqs[nj] * freqs[nk];\\n                    res += tmp;\\n                }\\n            }\\n        }\\n        return res %= modCut;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics"
                ],
                "code": "```cpp\\nstatic constexpr int modCut = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int uniques[101], uPos = 0;\\n        long freqs[101] = {}, res = 0, tmp;\\n        // populating freq\\n        for (int n: arr) {\\n            // ignoring too large numbers\\n            if (n > target) continue;\\n            // storing n if it is the first time we encounter it\\n            if (!freqs[n]) uniques[uPos++] = n;\\n            // increasing its frequency\\n            freqs[n]++;\\n        }\\n        sort(uniques, uniques + uPos);\\n        // computing all the possible combos\\n        for (int i = 0, ni, ti; i < uPos; i++) {\\n            ni = uniques[i];\\n            ti = target - 2 * ni;\\n            // skipping if it is too big\\n            if (ni > ti) break;\\n            for (int j = i + (freqs[ni] < 2), nj, nk, eq, diff; j < uPos; j++) {\\n                nj = uniques[j];\\n                nk = target - nj - ni;\\n                // stopping if it is too big\\n                if (nj > nk) break;\\n                // skipping if it is too big\\n                if (nk > 100) continue;\\n                if (freqs[nk]) {\\n                    if (ni == nj && nj == nk) tmp = freqs[ni] * (freqs[ni] - 1) * (freqs[ni] - 2) / 6;\\n                    else if (ni == nj || ni == nk || nj == nk) {\\n                        eq = ni == nj || ni == nk ? ni : nk;\\n                        diff = ni != nj ? (nj != nk ? nj : ni) : nk;\\n                        tmp = freqs[eq] * (freqs[eq] - 1) / 2 * freqs[diff];\\n                    }\\n                    else tmp = freqs[ni] * freqs[nj] * freqs[nk];\\n                    res += tmp;\\n                }\\n            }\\n        }\\n        return res %= modCut;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068859,
                "title": "guaranteed-easy-solution-you-can-understand",
                "content": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n    static final int module = 1_000_000_007;\\n\\n    public int threeSumMulti(int[] nums, int target) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        // count frequent of all numbers\\n        for(int n: nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        // remove duplicates and sort\\n        int[] a = map.keySet().stream().mapToInt(i -> i).toArray();\\n        Arrays.sort(a);\\n\\n        Long ans = 0L;\\n        int len = a.length;\\n\\n        for (int first = 0; first < len; first++) {\\n            if(a[first] > target) break;\\n\\n            int remain = target - a[first];\\n            int second = first;\\n            int third = len - 1;\\n\\n            while (second <= third){\\n                if(a[second] + a[third] == remain){\\n\\n                    // three numbers are equal\\n                    if(first == second && second == third) ans += nChooseK(map.get(a[first]), 3);\\n\\n                    // first two numbers are equal\\n                    else if(first == second) ans += nChooseK(map.get(a[first]), 2) * map.get(a[third]);\\n\\n                    // last two numbers are equal\\n                    else if(second == third) ans += map.get(a[first]) * nChooseK(map.get(a[second]), 2);\\n\\n                    //  three numbers are different\\n                    else ans += map.get(a[first]) * map.get(a[second]) * map.get(a[third]);\\n\\n                    if(ans > module) ans %= module;\\n\\n                    second++;\\n                    third--;\\n                }\\n                else if(a[second] + a[third] < remain){\\n                    second++;\\n                }\\n                else {\\n                    third--;\\n                }\\n            }\\n        }\\n        return ans.intValue();\\n    }\\n\\n    private static long nChooseK(long n, long k) {\\n        long numserator = 1;\\n        long denominator = 1;\\n\\n        for (long i = n; i >= (n - k + 1); i--) {\\n            numserator *= i;\\n        }\\n\\n        for (long i = k; i >= 1; i--) {\\n            denominator *= i;\\n        }\\n\\n        return (numserator / denominator);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n    static final int module = 1_000_000_007;\\n\\n    public int threeSumMulti(int[] nums, int target) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        // count frequent of all numbers\\n        for(int n: nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        // remove duplicates and sort\\n        int[] a = map.keySet().stream().mapToInt(i -> i).toArray();\\n        Arrays.sort(a);\\n\\n        Long ans = 0L;\\n        int len = a.length;\\n\\n        for (int first = 0; first < len; first++) {\\n            if(a[first] > target) break;\\n\\n            int remain = target - a[first];\\n            int second = first;\\n            int third = len - 1;\\n\\n            while (second <= third){\\n                if(a[second] + a[third] == remain){\\n\\n                    // three numbers are equal\\n                    if(first == second && second == third) ans += nChooseK(map.get(a[first]), 3);\\n\\n                    // first two numbers are equal\\n                    else if(first == second) ans += nChooseK(map.get(a[first]), 2) * map.get(a[third]);\\n\\n                    // last two numbers are equal\\n                    else if(second == third) ans += map.get(a[first]) * nChooseK(map.get(a[second]), 2);\\n\\n                    //  three numbers are different\\n                    else ans += map.get(a[first]) * map.get(a[second]) * map.get(a[third]);\\n\\n                    if(ans > module) ans %= module;\\n\\n                    second++;\\n                    third--;\\n                }\\n                else if(a[second] + a[third] < remain){\\n                    second++;\\n                }\\n                else {\\n                    third--;\\n                }\\n            }\\n        }\\n        return ans.intValue();\\n    }\\n\\n    private static long nChooseK(long n, long k) {\\n        long numserator = 1;\\n        long denominator = 1;\\n\\n        for (long i = n; i >= (n - k + 1); i--) {\\n            numserator *= i;\\n        }\\n\\n        for (long i = k; i >= 1; i--) {\\n            denominator *= i;\\n        }\\n\\n        return (numserator / denominator);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394422,
                "title": "javascript-time-o-n-2-space-o-u-where-u-unique-values",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @param {number} target\\n * @return {number}\\n */\\n// Time: O(n^2)\\n// Space: O(n)\\nvar threeSumMulti = function(A, target) {\\n    const seen = {};\\n    let tuples = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        for (let j = i + 1; j < A.length; j++) {\\n            const total = A[i] + A[j];\\n\\n            if (seen[target - total]) tuples += seen[target - total];\\n        }\\n\\n        if (!seen[A[i]]) seen[A[i]] = 0;\\n\\n        seen[A[i]]++;\\n    }\\n\\n    return tuples % (Math.pow(10, 9) + 7);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number} target\\n * @return {number}\\n */\\n// Time: O(n^2)\\n// Space: O(n)\\nvar threeSumMulti = function(A, target) {\\n    const seen = {};\\n    let tuples = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        for (let j = i + 1; j < A.length; j++) {\\n            const total = A[i] + A[j];\\n\\n            if (seen[target - total]) tuples += seen[target - total];\\n        }\\n\\n        if (!seen[A[i]]) seen[A[i]] = 0;\\n\\n        seen[A[i]]++;\\n    }\\n\\n    return tuples % (Math.pow(10, 9) + 7);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222517,
                "title": "python-solution",
                "content": "We want to mimic the LC 15. 3Sum algorithm in some way, but here we need to consider all triples together with their multiplicities, so simply using the solutions there is incorrect. For example, consider `A = [1,2,2,2,2]`, `target = 5`. If we initialize three pointers `i = 0, j = 1, k = 4`. Since `A[0] + A[1] + A[4] == 5`, it is a valid triple, we increment the counter by `1`. But then when we do `j += 1` and `k -= 1`, we missed a lot of the duplicate triples, so in total we only count `[1, 2, 2]` twice, whereas in fact the multiplicity of the triple `[1,2,2]` should be `6`. Furthermore, sorting an array with multiplitices could be very inefficient, so that we can first create a counter of the array, and then sort the distinct elements of the array by sorting the keys of the counter.\\n\\nTo address the above problems, we propose the following algorithm:\\n1. We initialize the result `res = 0`, which counts the total number of valid triples with multiplicity. We create a counter `dic` of the array, which maps an element in the array to its number of appearances.\\n2. sort `dic` according its keys. Denote by `A` the list of sorted `key`, `val` pairs in `dic`.\\n3. Let `i` be a pointer iterating in `range(len(A))`, and for each iteration, initialize two pointers `j = i`, `k = len(A)-1`. Now we search for pairs of indices `k >= j >= i`, such that `A[j][0] + A[k][0] == target - A[i][0]`. To do this, while `j <= k`, if `A[j][0]+A[k][0] < target - A[i][0]`, we increment `j` by `1`; Else if `A[j][0]+A[k][0] > target - A[i][0]`, we decrement `k` by `1`; Else when `A[j][0]+A[k][0] == target - A[i][0]`, we count the multiplicity of the triple `(A[i][0], A[j][0], A[k][0])`, and increment the total counter `res` by the multiplicity. Finally, after iterating over `i`, we return `res`.\\n\\nThe multiplicity of the triple `(A[i][0], A[j][0], A[k][0])` depends on if there are duplicate numbers in the triple. If all elements are distinct, then the multiplicity is just `A[i][1]*A[j][1]*A[k][1]`, E.g., if `A = [(1, 2), (2, 4), (3, 3)]` (corresponding to the input list `[1,1,2,2,2,2,3,3,3]`), then the multiplicity of the triple `(1,2,3)` is `2*4*3 = 24`; Else if there are two distinct elements in the triple, WLOG, assume `A[j][0] == A[k][0]`, then the multiplicity is `(A[j][1]*(A[j][1]-1) // 2) * A[i][1]`, E.g., consider the same `A = [(1,2), (2,4), (3,3)]` as in the previous case, the multiplicity of the triple `(1,2,2)` is `(4*3) // 2 * 2 = 12`, because the number of pairs of `(2,2)` that one can get in `[2,2,2,2]` is `4 choose 2 = 4*3 // 2 = 6`; Else if all three numbers in the triple are equal, i.e., `A[i][0] == A[j][0] and A[j][0] == A[k][0]`, then the multiplicity is `A[i][1]*(A[i][1]-1)*(A[i][1]-2) // 6`, E.g., consider the same `A = [(1,2), (2,4), (3,3)]` as in the previous case, the multiplicity of the triple `(2,2,2)` is `4 choose 3 = (4*3*2) // 6 = 4`.\\n\\nTime complexity: `O(n + m**2)`, space complexity: `O(m)`, where `n` is the length of the input array, and `m` is the number of distinct elements in the input array.\\n\\n```\\nclass Solution:\\n    def threeSumMulti(self, A, target):\\n        \"\"\"\\n        :type A: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        bound = 1000000007\\n        dic = collections.Counter(A)\\n        A = sorted(dic.items(), key = lambda x: x[0])\\n        res = 0\\n        for i in range(len(A)):\\n            j = i\\n            k = len(A)-1\\n            new_target = target - A[i][0]\\n            while j <= k:\\n                if A[j][0]+A[k][0] < new_target:\\n                    j += 1\\n                elif A[j][0]+A[k][0] > new_target:\\n                    k -= 1\\n                else:\\n                    if A[i][0] == A[k][0]:\\n                        res = (res + A[i][1]*(A[i][1]-1)*(A[i][1]-2) // 6) % bound\\n                    elif A[i][0] == A[j][0]:\\n                        res = (res + A[k][1]*A[i][1]*(A[i][1]-1)//2) % bound\\n                    elif A[j][0] == A[k][0]:\\n                        res = (res + A[i][1]*A[j][1]*(A[j][1]-1)//2) % bound\\n                    else:\\n                        res = (res + A[i][1]*A[j][1]*A[k][1]) % bound\\n                    j += 1\\n                    k -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, A, target):\\n        \"\"\"\\n        :type A: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        bound = 1000000007\\n        dic = collections.Counter(A)\\n        A = sorted(dic.items(), key = lambda x: x[0])\\n        res = 0\\n        for i in range(len(A)):\\n            j = i\\n            k = len(A)-1\\n            new_target = target - A[i][0]\\n            while j <= k:\\n                if A[j][0]+A[k][0] < new_target:\\n                    j += 1\\n                elif A[j][0]+A[k][0] > new_target:\\n                    k -= 1\\n                else:\\n                    if A[i][0] == A[k][0]:\\n                        res = (res + A[i][1]*(A[i][1]-1)*(A[i][1]-2) // 6) % bound\\n                    elif A[i][0] == A[j][0]:\\n                        res = (res + A[k][1]*A[i][1]*(A[i][1]-1)//2) % bound\\n                    elif A[j][0] == A[k][0]:\\n                        res = (res + A[i][1]*A[j][1]*(A[j][1]-1)//2) % bound\\n                    else:\\n                        res = (res + A[i][1]*A[j][1]*A[k][1]) % bound\\n                    j += 1\\n                    k -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181285,
                "title": "javascript-use-hashmap-divide-possibilities-into-4-situations",
                "content": "### Three Steps\\n1. Store `A` using an array `uni` and a hashmap `count`; `uni` is used to store its value, and `count` is used to store the occurences of the value. (In fact, you can use a hashmap with key `0~100` to store `A`, it will be easier);\\n2. Sort `uni`. (If in the 1st step you used a hashmap with key `0~100`, you can skip this step);\\n3. Calculate the number of permutations of four situations and accumulate the result.\\n\\n--------\\n### Four situations\\n* [left, mid, right];\\n* [left, mid, mid];\\n* [mid, mid, right];\\n* [mid, mid, mid];\\n\\n----------\\n\\n### The math\\nIf `mid` occurs once, then it is easy:\\n```\\nres += count[left] * count[mid] * count[right]\\n```\\nIf `mid` occurs twice, then we divide the result by `2` (`2` is the number of permutations of two `mid`, ie `2!`)(make sure `count[mid]>=2`):\\n```\\nres += count[mid] * (count[mid]-1) * count[left/right] / 2\\n```\\nIf `mid` occurs three times, then we divide the result by `6` (`6` is the number of permutations of three `mid`, ie `3!`)(make sure `count[mid]>=3`):\\n```\\nres += count[mid] * (count[mid-1) * (count[mid]-2) / 6\\n```\\nIf you are still confused, see [Permutations of multisets](https://en.wikipedia.org/wiki/Permutation#Permutations_of_multisets) on Wikipedia. \\n\\n--------\\n\\n### The Code\\n```\\nvar threeSumMulti = function(A, target) {\\n\\tlet mod=1e9+7, res=0;\\n\\tlet count={}, uni=[];\\n\\tfor(let a of A){\\n\\t\\tif(!count[a]){\\n\\t\\t\\tcount[a]=0;\\n\\t\\t\\tuni.push(a);\\n\\t\\t}\\n\\t\\tcount[a]++;\\n\\t}\\n\\tuni.sort((a,b)=>a-b);\\n\\tfor(let i=0; i<uni.length; i++){\\n\\t\\tlet mid=uni[i];\\n\\t\\tif(target-mid-uni[0]<mid) break;\\n\\t\\tfor(let j=0; j<i; j++){\\n\\t\\t\\tlet left=uni[j];\\n\\t\\t\\tif(target-mid-left<mid) break;\\n\\t\\t\\tlet right=target-left-mid;\\n\\t\\t\\tif(right===mid){\\n\\t\\t\\t\\t// situation 1: [left mid mid]\\n\\t\\t\\t\\tres=(res+count[left]*count[mid]*(count[mid]-1)/2)%mod;\\n\\t\\t\\t}\\n\\t\\t\\telse if(count[right]){\\n\\t\\t\\t\\t// situation 2: [left mid right]\\n\\t\\t\\t\\tres=(res+count[left]*count[mid]*count[right])%mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(count[mid]>1){\\n\\t\\t\\tlet right=target-2*mid;\\n\\t\\t\\tif(right>mid && count[right]>0){\\n\\t\\t\\t\\t// situation 3: [mid mid right]\\n\\t\\t\\t\\tres=(res+count[mid]*(count[mid]-1)*count[right]/2)%mod;\\n\\t\\t\\t}\\n\\t\\t\\telse if(right===mid && count[mid]>=3){\\n\\t\\t\\t\\t// situation 4: [mid mid mid]\\n\\t\\t\\t\\tres=(res+count[mid]*(count[mid]-1)*(count[mid]-2)/6)%mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nres += count[left] * count[mid] * count[right]\\n```\n```\\nres += count[mid] * (count[mid]-1) * count[left/right] / 2\\n```\n```\\nres += count[mid] * (count[mid-1) * (count[mid]-2) / 6\\n```\n```\\nvar threeSumMulti = function(A, target) {\\n\\tlet mod=1e9+7, res=0;\\n\\tlet count={}, uni=[];\\n\\tfor(let a of A){\\n\\t\\tif(!count[a]){\\n\\t\\t\\tcount[a]=0;\\n\\t\\t\\tuni.push(a);\\n\\t\\t}\\n\\t\\tcount[a]++;\\n\\t}\\n\\tuni.sort((a,b)=>a-b);\\n\\tfor(let i=0; i<uni.length; i++){\\n\\t\\tlet mid=uni[i];\\n\\t\\tif(target-mid-uni[0]<mid) break;\\n\\t\\tfor(let j=0; j<i; j++){\\n\\t\\t\\tlet left=uni[j];\\n\\t\\t\\tif(target-mid-left<mid) break;\\n\\t\\t\\tlet right=target-left-mid;\\n\\t\\t\\tif(right===mid){\\n\\t\\t\\t\\t// situation 1: [left mid mid]\\n\\t\\t\\t\\tres=(res+count[left]*count[mid]*(count[mid]-1)/2)%mod;\\n\\t\\t\\t}\\n\\t\\t\\telse if(count[right]){\\n\\t\\t\\t\\t// situation 2: [left mid right]\\n\\t\\t\\t\\tres=(res+count[left]*count[mid]*count[right])%mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(count[mid]>1){\\n\\t\\t\\tlet right=target-2*mid;\\n\\t\\t\\tif(right>mid && count[right]>0){\\n\\t\\t\\t\\t// situation 3: [mid mid right]\\n\\t\\t\\t\\tres=(res+count[mid]*(count[mid]-1)*count[right]/2)%mod;\\n\\t\\t\\t}\\n\\t\\t\\telse if(right===mid && count[mid]>=3){\\n\\t\\t\\t\\t// situation 4: [mid mid mid]\\n\\t\\t\\t\\tres=(res+count[mid]*(count[mid]-1)*(count[mid]-2)/6)%mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1920537,
                "title": "c-use-map-to-count-tuples-dlc-april-6",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, long> mpp;\\n        int mod = 1e9+7;\\n        \\n        //store frequencies\\n        for(auto it: arr) mpp[it]++;\\n        \\n        //count touples\\n        long count = 0;\\n        for(auto it1: mpp){\\n            for(auto it2: mpp){\\n                int i= it1.first, j= it2.first;\\n                auto k = target- i- j;\\n                \\n                if(!mpp.count(k)) continue;\\n                if(i < j && j < k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += (mpp[i]*mpp[j]*mpp[k]);\\n                }\\n                    \\n                \\n                else if(i == j && j!=k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += mpp[i]* (mpp[j]-1)/ 2 * mpp[k];\\n                }\\n                    \\n                \\n                else if(i==j && j==k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += mpp[i]* (mpp[j]-1) * (mpp[k]-2) /6;  \\n                }\\n                    \\n                \\n            }\\n        }\\n        \\n        return count % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, long> mpp;\\n        int mod = 1e9+7;\\n        \\n        //store frequencies\\n        for(auto it: arr) mpp[it]++;\\n        \\n        //count touples\\n        long count = 0;\\n        for(auto it1: mpp){\\n            for(auto it2: mpp){\\n                int i= it1.first, j= it2.first;\\n                auto k = target- i- j;\\n                \\n                if(!mpp.count(k)) continue;\\n                if(i < j && j < k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += (mpp[i]*mpp[j]*mpp[k]);\\n                }\\n                    \\n                \\n                else if(i == j && j!=k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += mpp[i]* (mpp[j]-1)/ 2 * mpp[k];\\n                }\\n                    \\n                \\n                else if(i==j && j==k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += mpp[i]* (mpp[j]-1) * (mpp[k]-2) /6;  \\n                }\\n                    \\n                \\n            }\\n        }\\n        \\n        return count % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1920186,
                "title": "java-maps-commented",
                "content": "TLE solution\\n```\\nclass Solution {\\n    private int m = 1000000007; //modulo\\n    public int threeSumMulti(int[] arr, int target) {\\n        int len = arr.length;\\n        long ans = 0; // last test case won\\'t run because ans is int\\n        for(int i = 0; i < len; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int tar = target - arr[i];\\n            for(int j = i+1; j < len; j++) {\\n                if(map.containsKey(tar-arr[j])) {\\n                    ans = ans%m;\\n                    ans = (ans + map.get(tar-arr[j]))%m; //here value after addition can be greater than int range it type should be long\\n                }\\n                map.put(arr[j], map.getOrDefault(arr[j], 0)+1);\\n            }\\n        }\\n        return (int)(ans%m);\\n    }\\n}\\n```\\n\\nTwo pointer AC\\n\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int len = arr.length;\\n        int m = 1_000_000_007;\\n        Arrays.sort(arr);\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            int new_target = target-arr[i];\\n            int j = i+1, k = len-1;\\n            while(j < k) {\\n                if(arr[j]+arr[k] > new_target) {\\n                    k--;\\n                } else if(arr[j]+arr[k] < new_target) {\\n                    j++;\\n                } else if(arr[j] == arr[k]) {\\n                    ans += ((k-j+1)*(k-j))/2;\\n                    ans = ans%m;\\n                    break;\\n                } else {\\n                    int left = 1, right = 1;\\n                    while(j+1<k && arr[j]==arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    \\n                    while(k-1>j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    \\n                    ans += (left*right);\\n                    ans = ans%m;\\n                    j++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    private int m = 1000000007; //modulo\\n    public int threeSumMulti(int[] arr, int target) {\\n        int len = arr.length;\\n        long ans = 0; // last test case won\\'t run because ans is int\\n        for(int i = 0; i < len; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int tar = target - arr[i];\\n            for(int j = i+1; j < len; j++) {\\n                if(map.containsKey(tar-arr[j])) {\\n                    ans = ans%m;\\n                    ans = (ans + map.get(tar-arr[j]))%m; //here value after addition can be greater than int range it type should be long\\n                }\\n                map.put(arr[j], map.getOrDefault(arr[j], 0)+1);\\n            }\\n        }\\n        return (int)(ans%m);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int len = arr.length;\\n        int m = 1_000_000_007;\\n        Arrays.sort(arr);\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            int new_target = target-arr[i];\\n            int j = i+1, k = len-1;\\n            while(j < k) {\\n                if(arr[j]+arr[k] > new_target) {\\n                    k--;\\n                } else if(arr[j]+arr[k] < new_target) {\\n                    j++;\\n                } else if(arr[j] == arr[k]) {\\n                    ans += ((k-j+1)*(k-j))/2;\\n                    ans = ans%m;\\n                    break;\\n                } else {\\n                    int left = 1, right = 1;\\n                    while(j+1<k && arr[j]==arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    \\n                    while(k-1>j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    \\n                    ans += (left*right);\\n                    ans = ans%m;\\n                    j++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919810,
                "title": "90-ms-runtime-beginner-friendly-extend-two-sum-approach-python3",
                "content": "Before delving into the actual working of the algorithm, let\\'s get some basics of combinations for the scope of this answer out of the way.\\n\\n---\\nIf `n` elements are given and we have to select `i` elements from them, then the possible number of ways this could be achieved is in <sup>n</sup>C<sub>i</sub> ways.\\n\\nAnd <sup>n</sup>C<sub>i</sub> = `factorial(n) / (factorial(n-i)*factorial(i))`\\nThis formula could further be simplified into <sup>n</sup>C<sub>i</sub> = `n*(n-1)*(n-2)....*(n-i+1) / factorial(i)`\\n\\nSo, if we had to select 2 elements from 4 values, the possible number of ways is:\\n<sup>4</sup>C<sub>2</sub> = `4 * 3 / 2 * 1` = `6`\\n\\nWith that understood now let\\'s talk about the algo to solve the question.\\n\\n---\\n**Implementation of algorithm**\\n---\\nLet\\'s recall how we used to solve the Two Sum problem. We could have done it by making a hash map or by using two pointers initially referencing the first and last element of the array.\\n\\nCode for two-pointers approach:\\n```\\ngiven target;\\ngiven arr[n]; # sorted array\\n\\ni = 0;\\nj = n-1;\\nans = 0;\\nwhile i<j:\\n\\tvalue1 = arr[i];\\n\\tvalue2 = arr[j];\\n\\tsum = value1 + value2\\n\\tif sum < target:\\n\\t\\t# we need to shift a pointer to next greater element\\n\\t\\ti++;\\n\\telse if sum > target:\\n\\t\\t# we need to shift a pointer to a lower element\\n\\t\\tj--;\\n\\telse:\\n\\t\\t# for the case that sum==target\\n\\t\\tans++\\n\\t\\ti++\\n\\t\\tj--\\n\\nreturn ans\\n```\\n\\n\\nTo solve Three Sum problem, we\\'ll combine the two approaches. We would first store each distinct value with its count in the array in a dictionary.\\n```\\ncount = {}\\nfor x in arr:\\n    if x in count:\\n        count[x] += 1\\n    else:\\n        count[x] = 1\\n        \\nkeys = sorted(count.keys())\\n```\\nThen we\\'ll maintain three pointers `i`,`j` and `k` to correspond with the three values that we want.\\nNow if the sum of values at these three indices is less than the target sum, then we need to shift a pointer to a greater element, and to a lesser element if the sum turns out to be less than target.\\n```\\n\\t\\tans = 0\\n        for i, val0 in enumerate(keys):\\n            sum2 = target - val0\\n            j,k = i, len(keys)-1\\n            while j<=k:\\n                val1, val2 = keys[j], keys[k]\\n                if val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n```\\n\\nIf we manage to find the values being referenced by the three pointers to be equal to the target sum, then we\\'ll compare the positions of the pointers themselves, to determine if they point to distinct values or the same ones.\\n\\nAccordingly, we\\'ll use the concept of combinations mentioned earlier to find out the possible ways to make the target sum from the three values.\\n```\\nif val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n                else:\\n                    # val0 + val1 + val2 == target\\n                    # Now checking if our pointers correspond to counts of keys counted earlier\\n                    if i<j<k:\\n                        # select 1 of each distinct value\\n                        ans += count[val0]*count[val1]*count[val2]\\n                    elif i==j<k:\\n                        # Select 2 of one (nC2) and 1(nC1) of other distinct value\\n                        ans += (count[val0] * (count[val0]-1))//2 * count[val2]\\n                    elif i<j==k:\\n                        # Select 1 of one(nC1) and 2(nC2) of other distinct value\\n                        ans += count[val0] * (count[val1] * (count[val1] - 1))//2\\n                    else:\\n                        # for the case when i=j=k\\n                        \\n                        # This implies that we select 3 of one distinct value\\n                        # to make up for target\\n                        n = count[val0]\\n                        ans += (n * (n-1) * (n-2))//6\\n```\\n\\n---\\n**Complete Python code:**\\n```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n        MOD = 10**9 + 7\\n        count = {}\\n        for x in arr:\\n            if x in count:\\n                count[x] += 1\\n            else:\\n                count[x] = 1\\n        \\n        keys = sorted(count.keys())\\n        \\n        ans = 0\\n        for i, val0 in enumerate(keys):\\n            sum2 = target - val0\\n            j,k = i, len(keys)-1\\n            while j<=k:\\n                val1, val2 = keys[j], keys[k]\\n                if val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n                else:\\n                    # val0 + val1 + val2 == target\\n                    # Now checking if our pointers correspond to counts of keys counted earlier\\n                    if i<j<k:\\n                        # select 1 of each distinct value\\n                        ans += count[val0]*count[val1]*count[val2]\\n                    elif i==j<k:\\n                        # Select 2 of one (nC2) and 1(nC1) of other distinct value\\n                        ans += (count[val0] * (count[val0]-1))//2 * count[val2]\\n                    elif i<j==k:\\n                        # Select 1 of one(nC1) and 2(nC2) of other distinct value\\n                        ans += count[val0] * (count[val1] * (count[val1] - 1))//2\\n                    else:\\n                        # for the case when i=j=k\\n                        \\n                        # This implies that we select 3 of one distinct value\\n                        # to make up for target\\n                        n = count[val0]\\n                        ans += (n * (n-1) * (n-2))//6\\n                    \\n                    j += 1\\n                    k -= 1\\n        \\n        return ans % MOD\\n```\\n\\n**Time Complexity: O(nlogn) for sorting, O(n<sup>2</sup>) for comparing and finding values**\\n**Space Complexity: O(n)**\\n\\n***Please share your learnings if you find a better or more optimised approach to solving this problem. Do upvote if you found the explanation deserving enough. Thanks for reading***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ngiven target;\\ngiven arr[n]; # sorted array\\n\\ni = 0;\\nj = n-1;\\nans = 0;\\nwhile i<j:\\n\\tvalue1 = arr[i];\\n\\tvalue2 = arr[j];\\n\\tsum = value1 + value2\\n\\tif sum < target:\\n\\t\\t# we need to shift a pointer to next greater element\\n\\t\\ti++;\\n\\telse if sum > target:\\n\\t\\t# we need to shift a pointer to a lower element\\n\\t\\tj--;\\n\\telse:\\n\\t\\t# for the case that sum==target\\n\\t\\tans++\\n\\t\\ti++\\n\\t\\tj--\\n\\nreturn ans\\n```\n```\\ncount = {}\\nfor x in arr:\\n    if x in count:\\n        count[x] += 1\\n    else:\\n        count[x] = 1\\n        \\nkeys = sorted(count.keys())\\n```\n```\\n\\t\\tans = 0\\n        for i, val0 in enumerate(keys):\\n            sum2 = target - val0\\n            j,k = i, len(keys)-1\\n            while j<=k:\\n                val1, val2 = keys[j], keys[k]\\n                if val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n```\n```\\nif val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n                else:\\n                    # val0 + val1 + val2 == target\\n                    # Now checking if our pointers correspond to counts of keys counted earlier\\n                    if i<j<k:\\n                        # select 1 of each distinct value\\n                        ans += count[val0]*count[val1]*count[val2]\\n                    elif i==j<k:\\n                        # Select 2 of one (nC2) and 1(nC1) of other distinct value\\n                        ans += (count[val0] * (count[val0]-1))//2 * count[val2]\\n                    elif i<j==k:\\n                        # Select 1 of one(nC1) and 2(nC2) of other distinct value\\n                        ans += count[val0] * (count[val1] * (count[val1] - 1))//2\\n                    else:\\n                        # for the case when i=j=k\\n                        \\n                        # This implies that we select 3 of one distinct value\\n                        # to make up for target\\n                        n = count[val0]\\n                        ans += (n * (n-1) * (n-2))//6\\n```\n```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n        MOD = 10**9 + 7\\n        count = {}\\n        for x in arr:\\n            if x in count:\\n                count[x] += 1\\n            else:\\n                count[x] = 1\\n        \\n        keys = sorted(count.keys())\\n        \\n        ans = 0\\n        for i, val0 in enumerate(keys):\\n            sum2 = target - val0\\n            j,k = i, len(keys)-1\\n            while j<=k:\\n                val1, val2 = keys[j], keys[k]\\n                if val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n                else:\\n                    # val0 + val1 + val2 == target\\n                    # Now checking if our pointers correspond to counts of keys counted earlier\\n                    if i<j<k:\\n                        # select 1 of each distinct value\\n                        ans += count[val0]*count[val1]*count[val2]\\n                    elif i==j<k:\\n                        # Select 2 of one (nC2) and 1(nC1) of other distinct value\\n                        ans += (count[val0] * (count[val0]-1))//2 * count[val2]\\n                    elif i<j==k:\\n                        # Select 1 of one(nC1) and 2(nC2) of other distinct value\\n                        ans += count[val0] * (count[val1] * (count[val1] - 1))//2\\n                    else:\\n                        # for the case when i=j=k\\n                        \\n                        # This implies that we select 3 of one distinct value\\n                        # to make up for target\\n                        n = count[val0]\\n                        ans += (n * (n-1) * (n-2))//6\\n                    \\n                    j += 1\\n                    k -= 1\\n        \\n        return ans % MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1919684,
                "title": "c-10-lines-solution-90-faster",
                "content": "Time Complexity: O(n^2)\\n```\\n int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int>mp;\\n        const unsigned int M = 1000000007;\\n        int n=arr.size(), count=0;\\n        for(int i=2; i<n ; i++){\\n            for(int j=0 ; j<=i-2 ; j++){\\n                mp[arr[j]+arr[i-1]]++;\\n            }\\n            if(mp.count(target-arr[i])==1){\\n                count=count%M;\\n                mp[target-arr[i]]=(mp[target-arr[i]])%M;\\n                count=(((count+mp[target-arr[i]])%M)+ M)%M;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Time Complexity: O(n^2)\\n```\\n int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int>mp;\\n        const unsigned int M = 1000000007;\\n        int n=arr.size(), count=0;\\n        for(int i=2; i<n ; i++){\\n            for(int j=0 ; j<=i-2 ; j++){\\n                mp[arr[j]+arr[i-1]]++;\\n            }\\n            if(mp.count(target-arr[i])==1){\\n                count=count%M;\\n                mp[target-arr[i]]=(mp[target-arr[i]])%M;\\n                count=(((count+mp[target-arr[i]])%M)+ M)%M;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1919417,
                "title": "c-easy-solution",
                "content": "Upvote, if you find it helpful\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int mod = 1e9+7, ans = 0;\\n        int map[101] = {};\\n        \\n        for(auto n: arr)\\n            map[n]++;\\n        \\n        for(int i = 0; i <= 100; i++){\\n            \\n            for( int j = i+1; j <= 100; j++ ){\\n                \\n                for( int k = j+1; k <= 100; k++ ){\\n                    \\n                    if( i+k+j == target && map[i] && map[j] && map[k] ){\\n                        int val = ( map[i] * map[j] * map[k]);\\n                        ans = ( ans + val ) % mod;\\n                    }\\n                    \\n                }\\n                \\n                if( i+i+j == target && map[i] > 1 && map[j] ){  // Consider case : [1,1,1,1,2,2,2,2] and target = 3\\n                    int val = (map[i] * (map[i]-1)) / 2;\\n                    ans =  ( ans + val * map[j] ) % mod;\\n                }\\n                if( i+j+j == target && map[i] && map[j] > 1 ){ // Consider case : [1,1,2,2,2,2] and target = 5\\n                    int val = (map[j] * (map[j]-1)) / 2;\\n                    ans =  ( ans + map[i] * val ) % mod;\\n                }\\n                \\n            }\\n            \\n            if( i*3 == target && map[i] > 2 ) {   // Consider case : [2,2,2,2,2,2] and target = 6\\n                long long int val = map[i] * (map[i]-1);\\n                val = ( val * (map[i]-2)/6 ) % mod;\\n                ans = ( ans + val ) % mod;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int mod = 1e9+7, ans = 0;\\n        int map[101] = {};\\n        \\n        for(auto n: arr)\\n            map[n]++;\\n        \\n        for(int i = 0; i <= 100; i++){\\n            \\n            for( int j = i+1; j <= 100; j++ ){\\n                \\n                for( int k = j+1; k <= 100; k++ ){\\n                    \\n                    if( i+k+j == target && map[i] && map[j] && map[k] ){\\n                        int val = ( map[i] * map[j] * map[k]);\\n                        ans = ( ans + val ) % mod;\\n                    }\\n                    \\n                }\\n                \\n                if( i+i+j == target && map[i] > 1 && map[j] ){  // Consider case : [1,1,1,1,2,2,2,2] and target = 3\\n                    int val = (map[i] * (map[i]-1)) / 2;\\n                    ans =  ( ans + val * map[j] ) % mod;\\n                }\\n                if( i+j+j == target && map[i] && map[j] > 1 ){ // Consider case : [1,1,2,2,2,2] and target = 5\\n                    int val = (map[j] * (map[j]-1)) / 2;\\n                    ans =  ( ans + map[i] * val ) % mod;\\n                }\\n                \\n            }\\n            \\n            if( i*3 == target && map[i] > 2 ) {   // Consider case : [2,2,2,2,2,2] and target = 6\\n                long long int val = map[i] * (map[i]-1);\\n                val = ( val * (map[i]-2)/6 ) % mod;\\n                ans = ( ans + val ) % mod;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919197,
                "title": "c-o-n-2-solution-2-approaches-hashmap-3-pointers-approach",
                "content": "**Approach-1 :** Use hashmap \\n**TC: O(N^2), SC: O(N)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        int count = 0, n = arr.size(), modu = 1e9+7;\\n        //store sum and their frequency\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            //if (target-arr[i]) found in map we add its frequency into the count\\n            count = (count + (mp[target-arr[i]])) % modu;\\n            \\n            //iterate from 0 to i-1 and store the frequency of sum\\n            for(int j=0; j<i; j++)\\n            {\\n                mp[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n\\n**Approach-2 :** Use 3 pointers approach \\n**TC: O(N^2), SC: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n int threeSumMulti(vector<int>& nums, int target) \\n {\\n     sort(nums.begin(), nums.end());\\n     int n=nums.size();\\n     int ans=0, modu=1e9+7;\\n     long long sum;\\n     \\n     for(int i=0; i<n; i++)\\n     {\\n         int s = i+1;\\n         int e = n-1;\\n         \\n         while(s<e)\\n         {\\n             sum = nums[i]+nums[s]+nums[e];\\n             \\n             if(sum == target)\\n             {\\n                \\n                 int count1 = 1; //count same values for start pointer\\n                 int count2 = 1; //count same values for end pointer\\n                 \\n                 //if value of current and next start pointers are equal, we increase count1\\n                 while(s<e && nums[s]==nums[s+1])\\n                 {\\n                     count1++;\\n                     s++;\\n                 }\\n                 \\n                 //if value of current and next end pointers are equal, we increase count2\\n                 while(s<e && nums[e]==nums[e-1])\\n                 {\\n                     count2++;\\n                     e--;\\n                 }\\n                 \\n                 //we use combination formula to find possible tuples\\n                 //if s and e pointers are at same index we use\\n                 // (n*(n-1))/2\\n                 if(s==e)\\n                 {\\n                     ans = (ans + ((count1%modu)*((count1-1)%modu))/2)%modu;\\n                 }\\n                 \\n                 //if s and e pointers are not at same index we use\\n                 // (n*m)\\n                 if(s!=e)\\n                 {\\n                     ans = (ans + (count1%modu)*(count2%modu))%modu;\\n                 }\\n                 \\n                 s++;\\n                 e--;\\n             }\\n             \\n             else if(sum < target)\\n                 s++;\\n             else\\n                 e--;\\n         }\\n     }\\n     return ans;\\n }      \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        int count = 0, n = arr.size(), modu = 1e9+7;\\n        //store sum and their frequency\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            //if (target-arr[i]) found in map we add its frequency into the count\\n            count = (count + (mp[target-arr[i]])) % modu;\\n            \\n            //iterate from 0 to i-1 and store the frequency of sum\\n            for(int j=0; j<i; j++)\\n            {\\n                mp[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n int threeSumMulti(vector<int>& nums, int target) \\n {\\n     sort(nums.begin(), nums.end());\\n     int n=nums.size();\\n     int ans=0, modu=1e9+7;\\n     long long sum;\\n     \\n     for(int i=0; i<n; i++)\\n     {\\n         int s = i+1;\\n         int e = n-1;\\n         \\n         while(s<e)\\n         {\\n             sum = nums[i]+nums[s]+nums[e];\\n             \\n             if(sum == target)\\n             {\\n                \\n                 int count1 = 1; //count same values for start pointer\\n                 int count2 = 1; //count same values for end pointer\\n                 \\n                 //if value of current and next start pointers are equal, we increase count1\\n                 while(s<e && nums[s]==nums[s+1])\\n                 {\\n                     count1++;\\n                     s++;\\n                 }\\n                 \\n                 //if value of current and next end pointers are equal, we increase count2\\n                 while(s<e && nums[e]==nums[e-1])\\n                 {\\n                     count2++;\\n                     e--;\\n                 }\\n                 \\n                 //we use combination formula to find possible tuples\\n                 //if s and e pointers are at same index we use\\n                 // (n*(n-1))/2\\n                 if(s==e)\\n                 {\\n                     ans = (ans + ((count1%modu)*((count1-1)%modu))/2)%modu;\\n                 }\\n                 \\n                 //if s and e pointers are not at same index we use\\n                 // (n*m)\\n                 if(s!=e)\\n                 {\\n                     ans = (ans + (count1%modu)*(count2%modu))%modu;\\n                 }\\n                 \\n                 s++;\\n                 e--;\\n             }\\n             \\n             else if(sum < target)\\n                 s++;\\n             else\\n                 e--;\\n         }\\n     }\\n     return ans;\\n }      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919180,
                "title": "c-two-pointers-and-hash-map-o-n-n",
                "content": "**Divide the problem in 3 separate parts-**\\n* Count the number of triplets that are distinct.\\n* Count the number of triplets in which 2 integers are same and 1 is different.\\n* Count the number of triplets such that all 3 integers are same\\n\\n**Then our answer will be sum of the three cases.**\\nUsing HashMap we will store the key and frequency. Key is the distinct integer and frequency is the frequency of the key.\\n\\n1. We will construct a new Array which consists of unique integers from the given array. We will use 3 sum (Two Pointers Approach) to count the number of distinct integers.\\n2. We will then have all pairs that are distinct and check for these cases.\\n3. We will then calculate for the third case, if the frequency of the key is greater than equal to 3 and 3key==target then we will count it which is f(f-1)(f-2)/6 where f is frequency of the key. This formula is calculated using fC3 which is number of ways to pick 3 elements from a given set of elements (Combinations in Maths).\\n\\n**COMPLEXITY ANALYSIS:**\\n**TIME: O(N*N)**\\n**SPACE: O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    long func(int num1, int num2, long f1, long f2, int target){\\n        if(f1==1)\\n            return 0;\\n        \\n        if(2*num1+num2!=target)\\n            return 0;\\n        \\n        return (f1*(f1-1)*f2/2)%1000000007;        \\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int res=0;\\n        int mod=1e9+7;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        vector<int> nums;\\n        for(auto it:mp){\\n            nums.push_back(it.first);\\n        }\\n        \\n        n=nums.size();\\n        \\n        //counting 3 distint integers\\n        for(int i=0;i<n-2;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                long sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    res=(res+(mp[nums[i]]*mp[nums[l]]*mp[nums[r]])%mod)%mod;\\n                    l++;\\n                    r--;\\n                }else if(sum>target){\\n                    r--;\\n                }else{\\n                    l++;\\n                }\\n            }\\n        }\\n        \\n        //counting 2 same and 1 distinct integers\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int a=func(nums[i],nums[j],mp[nums[i]],mp[nums[j]],target);\\n                int b=func(nums[j],nums[i],mp[nums[j]],mp[nums[i]],target);\\n                res+=(a+b)%mod;\\n            }\\n        }\\n        \\n        //counting 3 same integers\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>=3 and 3*nums[i]==target){\\n                long long f=mp[nums[i]];\\n                long long cnt=(f*(f-1)*(f-2)/6)%mod;\\n                res+=(cnt)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long func(int num1, int num2, long f1, long f2, int target){\\n        if(f1==1)\\n            return 0;\\n        \\n        if(2*num1+num2!=target)\\n            return 0;\\n        \\n        return (f1*(f1-1)*f2/2)%1000000007;        \\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int res=0;\\n        int mod=1e9+7;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        vector<int> nums;\\n        for(auto it:mp){\\n            nums.push_back(it.first);\\n        }\\n        \\n        n=nums.size();\\n        \\n        //counting 3 distint integers\\n        for(int i=0;i<n-2;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                long sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    res=(res+(mp[nums[i]]*mp[nums[l]]*mp[nums[r]])%mod)%mod;\\n                    l++;\\n                    r--;\\n                }else if(sum>target){\\n                    r--;\\n                }else{\\n                    l++;\\n                }\\n            }\\n        }\\n        \\n        //counting 2 same and 1 distinct integers\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int a=func(nums[i],nums[j],mp[nums[i]],mp[nums[j]],target);\\n                int b=func(nums[j],nums[i],mp[nums[j]],mp[nums[i]],target);\\n                res+=(a+b)%mod;\\n            }\\n        }\\n        \\n        //counting 3 same integers\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>=3 and 3*nums[i]==target){\\n                long long f=mp[nums[i]];\\n                long long cnt=(f*(f-1)*(f-2)/6)%mod;\\n                res+=(cnt)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919141,
                "title": "cpp-easy-hashing",
                "content": "```\\n//if u understand then upvote\\nint threeSumMulti(vector<int>& arr, int target) {\\n        int count=0;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<arr.size();++i)\\n            mp[arr[i]]++;\\n    \\n        for(int i=0;i<arr.size()-2;++i)\\n        {\\n            int s=i+1;\\n            int e=arr.size()-1;\\n            mp[arr[i]]--;\\n            int tar=target-arr[i];\\n            while(s<e)\\n            {\\n                if(arr[s]+arr[e]==tar)\\n                {\\n                    if(arr[s]!=arr[e])\\n                        count+=(mp[arr[s]]*mp[arr[e]])%1000000007;\\n                    else\\n                    {\\n                        int p=(mp[arr[s]])%1000000007;\\n                        count+=(p*(p-1)/2)%1000000007;\\n                    }\\n                    int k=arr[s];\\n                    while(s<e && arr[s]==k)\\n                    {\\n                        s++;\\n                    }\\n                    k=arr[e];\\n                    while(s<e && arr[e]==k)\\n                    {\\n                            e--;\\n                    }\\n                    \\n                }\\n                else if(arr[s]+arr[e]<tar)\\n                    s++;\\n                else\\n                    e--;\\n            }\\n            count=count%1000000007;\\n        }\\n        \\n        return count%1000000007;\\n    }\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n//if u understand then upvote\\nint threeSumMulti(vector<int>& arr, int target) {\\n        int count=0;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<arr.size();++i)\\n            mp[arr[i]]++;\\n    \\n        for(int i=0;i<arr.size()-2;++i)\\n        {\\n            int s=i+1;\\n            int e=arr.size()-1;\\n            mp[arr[i]]--;\\n            int tar=target-arr[i];\\n            while(s<e)\\n            {\\n                if(arr[s]+arr[e]==tar)\\n                {\\n                    if(arr[s]!=arr[e])\\n                        count+=(mp[arr[s]]*mp[arr[e]])%1000000007;\\n                    else\\n                    {\\n                        int p=(mp[arr[s]])%1000000007;\\n                        count+=(p*(p-1)/2)%1000000007;\\n                    }\\n                    int k=arr[s];\\n                    while(s<e && arr[s]==k)\\n                    {\\n                        s++;\\n                    }\\n                    k=arr[e];\\n                    while(s<e && arr[e]==k)\\n                    {\\n                            e--;\\n                    }\\n                    \\n                }\\n                else if(arr[s]+arr[e]<tar)\\n                    s++;\\n                else\\n                    e--;\\n            }\\n            count=count%1000000007;\\n        }\\n        \\n        return count%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918998,
                "title": "easy-c-based-on-twosum",
                "content": "```\\n public int ThreeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        \\n        for(int i=0; i<arr.Length-2; i++)\\n        {\\n            var newTarget = target - arr[i];\\n            result += TwoSum(arr, newTarget, i+1);\\n            result %= (int)Math.Pow(10, 9) + 7;\\n        }\\n        \\n        return (int)result;\\n    }\\n    \\n    private int TwoSum(int[] arr, int target, int startIdx)\\n    {\\n        var visited = new Dictionary<int,int>();\\n        int res = 0;\\n        \\n        for(int i=startIdx; i<arr.Length; i++)\\n        {\\n            var curTarget = target - arr[i];\\n            \\n            if(visited.ContainsKey(curTarget))\\n                res+= visited[curTarget];\\n            \\n            if(!visited.ContainsKey(arr[i]))\\n                visited.Add(arr[i], 0);\\n            \\n            visited[arr[i]]++;\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nThe solution is O(n2) time complexity / O(n2) space complexity, so not very optimized",
                "solutionTags": [],
                "code": "```\\n public int ThreeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        \\n        for(int i=0; i<arr.Length-2; i++)\\n        {\\n            var newTarget = target - arr[i];\\n            result += TwoSum(arr, newTarget, i+1);\\n            result %= (int)Math.Pow(10, 9) + 7;\\n        }\\n        \\n        return (int)result;\\n    }\\n    \\n    private int TwoSum(int[] arr, int target, int startIdx)\\n    {\\n        var visited = new Dictionary<int,int>();\\n        int res = 0;\\n        \\n        for(int i=startIdx; i<arr.Length; i++)\\n        {\\n            var curTarget = target - arr[i];\\n            \\n            if(visited.ContainsKey(curTarget))\\n                res+= visited[curTarget];\\n            \\n            if(!visited.ContainsKey(arr[i]))\\n                visited.Add(arr[i], 0);\\n            \\n            visited[arr[i]]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918959,
                "title": "java-solution-with-two-pointer",
                "content": "\\n\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long count=0;\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            \\n            Arrays.sort(arr);\\n            int start = i+1;\\n            int end = arr.length-1;\\n            while(start<end)\\n            {\\n                if(arr[i]+arr[start]+arr[end] == target  && arr[start]!=arr[end]){\\n                    int y=1, x=1;\\n                    int j = start+1, k=end-1;\\n                    while(j < end && arr[start] == arr[j]){\\n                        x++;\\n                        j++;\\n                    }\\n                    while(k > start && arr[end] == arr[k])\\n                    {\\n                        y++;\\n                        k--;\\n                    }\\n                    start = j;\\n                    end = k;\\n                    count += x*y;\\n                }\\n                else if(arr[i]+arr[start]+arr[end] < target)\\n                    start++;\\n                else if(arr[i]+arr[start]+arr[end] > target)\\n                    end--;\\n                else\\n                {\\n                    count += (-start+end+1)*(-start+end)/2;\\n                    break;\\n                }\\n            }\\n        }\\n        // count = count+x;\\n        int ans = (int)(count%(1000000000+7));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long count=0;\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            \\n            Arrays.sort(arr);\\n            int start = i+1;\\n            int end = arr.length-1;\\n            while(start<end)\\n            {\\n                if(arr[i]+arr[start]+arr[end] == target  && arr[start]!=arr[end]){\\n                    int y=1, x=1;\\n                    int j = start+1, k=end-1;\\n                    while(j < end && arr[start] == arr[j]){\\n                        x++;\\n                        j++;\\n                    }\\n                    while(k > start && arr[end] == arr[k])\\n                    {\\n                        y++;\\n                        k--;\\n                    }\\n                    start = j;\\n                    end = k;\\n                    count += x*y;\\n                }\\n                else if(arr[i]+arr[start]+arr[end] < target)\\n                    start++;\\n                else if(arr[i]+arr[start]+arr[end] > target)\\n                    end--;\\n                else\\n                {\\n                    count += (-start+end+1)*(-start+end)/2;\\n                    break;\\n                }\\n            }\\n        }\\n        // count = count+x;\\n        int ans = (int)(count%(1000000000+7));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918731,
                "title": "c",
                "content": "```public class Solution {\\n     private const int MODULO = 1000000007;\\n\\n        public int ThreeSumMulti(int[] nums, int target)\\n        {\\n            checked\\n            {\\n                IDictionary<int, int> val2Count = new Dictionary<int, int>();\\n                foreach (var num in nums)\\n                {\\n                    if (!val2Count.ContainsKey(num))\\n                    {\\n                        val2Count[num] = 0;\\n                    }\\n\\n                    val2Count[num]++;\\n                }\\n\\n                var tuples = val2Count.Select(p => p).ToArray();\\n                Array.Sort(tuples, (t1, t2) => t1.Key.CompareTo(t2.Key));\\n                ulong res = 0;\\n\\n                //distinct numbers\\n                for (int i = 0; i < tuples.Length - 2; i++)\\n                {\\n                    int j = i + 1;\\n                    int k = tuples.Length - 1;\\n\\n                    while (j < k)\\n                    {\\n                        int sum = tuples[i].Key + tuples[j].Key + tuples[k].Key;\\n                        if (sum < target)\\n                        {\\n                            j++;\\n                            continue;\\n                        }\\n\\n                        if (sum > target)\\n                        {\\n                            k--;\\n                            continue;\\n                        }\\n\\n                        res += ((ulong)tuples[i].Value * (ulong)tuples[j].Value * (ulong)tuples[k].Value);\\n                        res = res % MODULO;\\n                        j++;\\n                    }\\n                }\\n\\n\\n                //check duplicates\\n                for (int i = 0; i < tuples.Length; i++)\\n                {\\n                    var num = tuples[i].Key;\\n                    int count = tuples[i].Value;\\n\\n                    if (count < 2)\\n                    {\\n                        continue;\\n                    }\\n\\n                    int third = target - num * 2;\\n                    if (val2Count.ContainsKey(third) && third != num)\\n                    {\\n                        ulong duplicatesCount = ((ulong)(count - 1) * (ulong)count / 2);\\n                        res += (duplicatesCount * (ulong)val2Count[third]);\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n\\n\\n                //check triple\\n                if (target % 3 == 0)\\n                {\\n                    int target3 = target / 3;\\n\\n                    if (val2Count.ContainsKey(target3) && val2Count[target3] >= 3)\\n                    {\\n                        int count = val2Count[target3];\\n                        res += ((ulong)(count - 2) * (ulong)(count - 1) * (ulong)count / 6);\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return (int)res;\\n            }\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```public class Solution {\\n     private const int MODULO = 1000000007;\\n\\n        public int ThreeSumMulti(int[] nums, int target)\\n        {\\n            checked\\n            {\\n                IDictionary<int, int> val2Count = new Dictionary<int, int>();\\n                foreach (var num in nums)\\n                {\\n                    if (!val2Count.ContainsKey(num))\\n                    {\\n                        val2Count[num] = 0;\\n                    }\\n\\n                    val2Count[num]++;\\n                }\\n\\n                var tuples = val2Count.Select(p => p).ToArray();\\n                Array.Sort(tuples, (t1, t2) => t1.Key.CompareTo(t2.Key));\\n                ulong res = 0;\\n\\n                //distinct numbers\\n                for (int i = 0; i < tuples.Length - 2; i++)\\n                {\\n                    int j = i + 1;\\n                    int k = tuples.Length - 1;\\n\\n                    while (j < k)\\n                    {\\n                        int sum = tuples[i].Key + tuples[j].Key + tuples[k].Key;\\n                        if (sum < target)\\n                        {\\n                            j++;\\n                            continue;\\n                        }\\n\\n                        if (sum > target)\\n                        {\\n                            k--;\\n                            continue;\\n                        }\\n\\n                        res += ((ulong)tuples[i].Value * (ulong)tuples[j].Value * (ulong)tuples[k].Value);\\n                        res = res % MODULO;\\n                        j++;\\n                    }\\n                }\\n\\n\\n                //check duplicates\\n                for (int i = 0; i < tuples.Length; i++)\\n                {\\n                    var num = tuples[i].Key;\\n                    int count = tuples[i].Value;\\n\\n                    if (count < 2)\\n                    {\\n                        continue;\\n                    }\\n\\n                    int third = target - num * 2;\\n                    if (val2Count.ContainsKey(third) && third != num)\\n                    {\\n                        ulong duplicatesCount = ((ulong)(count - 1) * (ulong)count / 2);\\n                        res += (duplicatesCount * (ulong)val2Count[third]);\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n\\n\\n                //check triple\\n                if (target % 3 == 0)\\n                {\\n                    int target3 = target / 3;\\n\\n                    if (val2Count.ContainsKey(target3) && val2Count[target3] >= 3)\\n                    {\\n                        int count = val2Count[target3];\\n                        res += ((ulong)(count - 2) * (ulong)(count - 1) * (ulong)count / 6);\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return (int)res;\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918717,
                "title": "cpp-two-pointers-unordered-map-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int mod = pow(10,9)+7;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        unordered_map<int, long long> map;\\n        \\n        for(auto x: arr) map[x]++;\\n                \\n        int k = 0;\\n        \\n        long long res = 0;\\n        \\n        while(k<arr.size()){\\n            \\n            int tbf = target - arr[k];\\n            \\n            int i = k+1, j = arr.size()-1;\\n            \\n            while(i<j){\\n                int sum = arr[i] + arr[j];\\n                if(sum == tbf){\\n                    if(arr[k] == arr[i] && arr[i] == arr[j]){\\n                        long long temp = map[arr[i]];\\n                        long long tba = (temp*(temp-1)*(temp-2))/6;\\n                        res = (res + tba)%mod;\\n                    }\\n                    else if(arr[k] == arr[i]){\\n                        long long temp = (map[arr[i]]*(map[arr[i]]-1))/2;\\n                        temp = (temp*map[arr[j]])%mod;\\n                        res += temp%mod;\\n                    }\\n                    else if(arr[i] == arr[j]){\\n                        long long temp = (map[arr[i]]*(map[arr[i]]-1))/2;\\n                        temp = (temp*map[arr[k]])%mod;\\n                        res += temp%mod;\\n                    }\\n                    else {\\n                        res = (res + (map[arr[k]]*map[arr[i]]*map[arr[j]])%mod)%mod;\\n                    }\\n                    \\n                    //cout << arr[k] << \" \" << arr[i] << \" \" << arr[j] << \" \" << res << endl; \\n                    \\n                    int tempa = arr[i];\\n                    int tempb = arr[j];\\n                    while(i<j && arr[i] == tempa) i++;\\n                    while(i<j && arr[j] == tempb) j--;\\n                }\\n                else if(sum < tbf) i++;\\n                else j--;\\n            }\\n            \\n            int tempc = arr[k];\\n            while(k < arr.size() && arr[k] == tempc) k++;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int mod = pow(10,9)+7;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        unordered_map<int, long long> map;\\n        \\n        for(auto x: arr) map[x]++;\\n                \\n        int k = 0;\\n        \\n        long long res = 0;\\n        \\n        while(k<arr.size()){\\n            \\n            int tbf = target - arr[k];\\n            \\n            int i = k+1, j = arr.size()-1;\\n            \\n            while(i<j){\\n                int sum = arr[i] + arr[j];\\n                if(sum == tbf){\\n                    if(arr[k] == arr[i] && arr[i] == arr[j]){\\n                        long long temp = map[arr[i]];\\n                        long long tba = (temp*(temp-1)*(temp-2))/6;\\n                        res = (res + tba)%mod;\\n                    }\\n                    else if(arr[k] == arr[i]){\\n                        long long temp = (map[arr[i]]*(map[arr[i]]-1))/2;\\n                        temp = (temp*map[arr[j]])%mod;\\n                        res += temp%mod;\\n                    }\\n                    else if(arr[i] == arr[j]){\\n                        long long temp = (map[arr[i]]*(map[arr[i]]-1))/2;\\n                        temp = (temp*map[arr[k]])%mod;\\n                        res += temp%mod;\\n                    }\\n                    else {\\n                        res = (res + (map[arr[k]]*map[arr[i]]*map[arr[j]])%mod)%mod;\\n                    }\\n                    \\n                    //cout << arr[k] << \" \" << arr[i] << \" \" << arr[j] << \" \" << res << endl; \\n                    \\n                    int tempa = arr[i];\\n                    int tempb = arr[j];\\n                    while(i<j && arr[i] == tempa) i++;\\n                    while(i<j && arr[j] == tempb) j--;\\n                }\\n                else if(sum < tbf) i++;\\n                else j--;\\n            }\\n            \\n            int tempc = arr[k];\\n            while(k < arr.size() && arr[k] == tempc) k++;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1918552,
                "title": "easy-explanation-intuitive-explained-100-2-ways-java-cpp-python",
                "content": "\\n\\n```**(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, please upvote this post.)\\n\\nIdea:\\nThe naive approach here would be to attempt all permutations, but that would run up to 2.7e10 attempts. The first important thing to notice is that the range of numbers is very small at [0,100]. With that few number options, any large input array (A) will have many duplicates, which means we\\'re looking at a combinatorics solution.\\n\\nIn order to use the combinatorics shortcut, however, we\\'ll first have to make a frequency map of the numbers in A. We could always use a standard map for this, but since the range of numbers is so small and 0-indexed, it makes more sense to use an array instead.\\n\\nAfter we\\'ve iterated through A and filled our number map (nmap) with the number frequencies, we can get down to the real work. The normal approach here would be to figure out the distinct numbers available and use nested loops to attempt every possible permutation. But rather than doing this, which would require many array calls, we can again take advantage of the fact that the number range is so small.\\n\\nWe can iterate through every possible permutation from [0,100], regardless of wheter the numbers are in A. Since we\\'ve made a frequency map, those numbers will be represented as 0\\'s, which will handily prevent anything from being added to our answer (ans) for permutations that we can\\'t make, and by using simple math instead of many array calls, we can actually be more performant.\\n\\nStill, there are ways to streamline this process. The basic approach will be to use a 2-pointer system to find two of our values and then mathematically figure the third, before applying the proper permutation formula to the values.\\n\\nIt should be apparent that our largest value (k) can never go above the target (T), nor can it obviously go above the max value of 100, so we can start it out at min(T, 100) and decrement from there. Also, since it will always represents the largest of the three values, it can never go below T / 3, because then the two smaller numbers would never be able to bring it up to T.\\n\\nMoving down to the next value (j), we can see that it can never be larger than k by definition, nor can it be larger than the remaining amount of space (rem) left to T, so we should start it at min(rem, k). Similar to k, j can also never go below rem / 2.\\n\\nOnce we have two of the three values, we can check for their frequencies. If any of them are 0\\'s, then it will automatically make the result of its permutation check a 0 as well. We can also potentially save some processing by checking for 0\\'s and continuing before applying the combinatorics formulas.\\n\\nIf i == k, then we know that i == j == k because j has to be between i and k, so we\\'ll have to use the n choose 3 formula. We should also check if any two other values are the same, then we should use (n choose 2) * (n choose 1). Otherwise, we can just use the simple combinations formula.\\n\\nThen it\\'s important to remember to apply the modulo before returning.\\n\\nImplementation:\\nJavascript was actually faster with an approach that featured isolating the actual distinct elements, sorting them, and then running efficiently through the combinations, but the code was much longer and more complex. This method is much easier and nearly as fast. In either case, we should use a typed array here for the arraymap.\\n\\nJava was oddly slower at the iteration shortcuts and actually ran faster without the added processes.\\n\\nJava and C++ should use long for their ans (prior to returning it, at least), and even for nmap, otherwise we\\'ll have to cast those values to long each time anyway.\\n\\nJavascript Code:\\nThe best result for the code below is 68ms / 40.5MB (beats 100% / 80%).\\n\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\nPython Code:\\nThe best result for the code below is 60ms / 14.2MB (beats 100% / 92%).\\n\\n**class Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\nJava Code:\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int res = 0;\\n        int mod = 1000000007;\\n        for (int i = 0; i < arr.length; i++) {\\n            res = (res + map.getOrDefault(target - arr[i], 0)) % mod;\\n            \\n            for (int j = 0; j < i; j++) {\\n                int temp = arr[i] + arr[j];\\n                map.put(temp, map.getOrDefault(temp, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n\\n// 2nd method \\n\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n       int mod=1_000_000_007;\\n        long[] count=new long[101];\\n        int uniq=0;\\n        for(var v:A){\\n            count[v]++;\\n            if(count[v]==1)uniq++;\\n        }\\n        int key[]=new int[uniq];\\n        int t=0;\\n        for(int i=0;i<=100;i++)\\n            if(count[i]>0)key[t++]=i;\\n        long ans=0;\\n        for(int i=0;i<key.length;i++){\\n            int x=key[i];\\n            int T=target-x;\\n            int j=i,k=key.length-1;\\n            while(j<=k){\\n                int y=key[j],z=key[k];\\n                if(y+z<T)j++;\\n                else if(y+z>T)k--;\\n                else{\\n                    if(i<j&&j<k) ans+=count[x]*count[y]*count[z];\\n                    else if(i==j&&j<k) ans+=count[x]*(count[x]-1)/2*count[z];\\n                    else  if(i<j&&j==k)ans+=count[x]*count[y]*(count[y]-1)/2;\\n                    else ans+=count[x]*(count[x]-1)*(count[x]-2)/6;\\n                     ans%=mod;\\n                j++;\\n                k--;\\n                }\\n            }\\n        } return (int) ans;\\n    }\\n}\\n\\n\\n\\n**class Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n\\n\\nC++ Code:\\nThe best result for the code below is 4ms / 10.2MB (beats 99% / 100%).\\n\\n**class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};**\\n\\nReference link provided by my fans in comments... Thankyou :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "class Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\nJava Code:\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int res = 0;\\n        int mod = 1000000007;\\n        for (int i = 0; i < arr.length; i++) {\\n            res = (res + map.getOrDefault(target - arr[i], 0)) % mod;\\n            \\n            for (int j = 0; j < i; j++) {\\n                int temp = arr[i] + arr[j];\\n                map.put(temp, map.getOrDefault(temp, 0) + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1918451,
                "title": "solution-o-n-faster-than-90-and-less-memory-than-75-of-memory-of-c-codes",
                "content": "```\\nclass Solution {\\nprivate:\\n    const int MOD = 1e9 + 7;\\n    // combination 3  nC3\\n    long long c3(long long n) {\\n        return n*(n-1)*(n-2)/6;\\n    }\\n    // combination 2  nC2\\n    long long c2(long long n) {\\n        return n*(n-1)/2;\\n    }\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> nums;\\n        // convert the array to numbers with its frequancy\\n        for (int &i: arr) {\\n            if (!nums.count(i))\\n                nums[i] = 0;\\n            nums[i]++;\\n        }\\n        // get all unique numbers\\n        vector<int> it;\\n        for (auto i : nums) {\\n            it.push_back(i.first);\\n        }\\n        long long ans = 0;\\n        // iterate on all possible solutions\\n        for (int i = 0; i < it.size() ; i++) {\\n            for (int j = i+1; j < it.size() ; j++) {\\n                int needed = target-it[i]-it[j];\\n                if (nums.count(needed)) {\\n                    // make sure it is unique\\n                    if (needed != it[i] && needed != it[j]) {\\n                        ans = (ans + nums[needed]*nums[it[i]]*nums[it[j]])%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        // to remove repeation cause the loop may count the same thing 3 times\\n        ans /= 3;\\n        // get all solution when they are two or more are the same number\\n        for (int & i : it) {\\n            int needed = target - i*2;\\n            if (nums.count(needed)) {\\n                // it 3 of them are the same\\n                if (needed == i) {\\n                    ans = (ans + c3(nums[i]))%MOD;\\n                } else { // if there are only two the same\\n                    ans = (ans + nums[needed]*c2(nums[i]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int MOD = 1e9 + 7;\\n    // combination 3  nC3\\n    long long c3(long long n) {\\n        return n*(n-1)*(n-2)/6;\\n    }\\n    // combination 2  nC2\\n    long long c2(long long n) {\\n        return n*(n-1)/2;\\n    }\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> nums;\\n        // convert the array to numbers with its frequancy\\n        for (int &i: arr) {\\n            if (!nums.count(i))\\n                nums[i] = 0;\\n            nums[i]++;\\n        }\\n        // get all unique numbers\\n        vector<int> it;\\n        for (auto i : nums) {\\n            it.push_back(i.first);\\n        }\\n        long long ans = 0;\\n        // iterate on all possible solutions\\n        for (int i = 0; i < it.size() ; i++) {\\n            for (int j = i+1; j < it.size() ; j++) {\\n                int needed = target-it[i]-it[j];\\n                if (nums.count(needed)) {\\n                    // make sure it is unique\\n                    if (needed != it[i] && needed != it[j]) {\\n                        ans = (ans + nums[needed]*nums[it[i]]*nums[it[j]])%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        // to remove repeation cause the loop may count the same thing 3 times\\n        ans /= 3;\\n        // get all solution when they are two or more are the same number\\n        for (int & i : it) {\\n            int needed = target - i*2;\\n            if (nums.count(needed)) {\\n                // it 3 of them are the same\\n                if (needed == i) {\\n                    ans = (ans + c3(nums[i]))%MOD;\\n                } else { // if there are only two the same\\n                    ans = (ans + nums[needed]*c2(nums[i]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918443,
                "title": "c-simple-approach-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int mod = 1e9+7;\\n        int count = 0;\\n        unordered_map<int,int> m;\\n        for(int i=0; i<arr.size(); i++) {\\n            count = (count + m[target-arr[i]])%mod;\\n            for(int j=0; j<i; j++) {\\n                m[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n:)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int mod = 1e9+7;\\n        int count = 0;\\n        unordered_map<int,int> m;\\n        for(int i=0; i<arr.size(); i++) {\\n            count = (count + m[target-arr[i]])%mod;\\n            for(int j=0; j<i; j++) {\\n                m[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800296,
                "title": "only-few-lines-of-code-c-simple",
                "content": "\\t   inline int threeSumMulti(vector<int>& arr, int target)\\n\\t\\t{\\n        int res=0;\\n        int n=arr.size();\\n        \\n        unordered_map<int,int> hash;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {   \\n            for(int j=i+1;j<n;j++)\\n                    res+=hash[target-arr[i]-arr[j]];\\n         \\n            hash[arr[i]]++; \\n         \\n          res%=int(1e9+7);\\n        }      \\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\t   inline int threeSumMulti(vector<int>& arr, int target)\\n\\t\\t{\\n        int res=0;\\n        int n=arr.size();\\n        \\n        unordered_map<int,int> hash;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {   \\n            for(int j=i+1;j<n;j++)\\n                    res+=hash[target-arr[i]-arr[j]];\\n         \\n            hash[arr[i]]++; \\n         \\n          res%=int(1e9+7);\\n        }      \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1650007,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int e : arr){\\n             long freq = map.getOrDefault(e,0l);\\n             map.put(e,freq+1l);\\n     }\\n        long ans=0l;\\n        for(int e1: map.keySet()){\\n            for(int e2: map.keySet()){\\n                int e3 = target-e1-e2;\\n                if(map.containsKey(e3)){\\n                    long freq1 = map.get(e1);\\n                    long freq2 = map.get(e2);\\n                    long freq3 = map.get(e3);\\n                    if(e1==e2 && e2==e3)\\n                    ans+=((freq1)*(freq2-1)*(freq3-2))/6;\\n                else if(e1==e2 && e1!=e3)\\n                    ans+=((freq1)*(freq2-1))/2*freq3;\\n                else if(e1<e2 && e2<e3)\\n                    ans+=freq1*freq2*freq3;\\n               \\n                }\\n               ans = ans%1000000007; \\n                \\n            }\\n             \\n        }\\n           return (int)ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int e : arr){\\n             long freq = map.getOrDefault(e,0l);\\n             map.put(e,freq+1l);\\n     }\\n        long ans=0l;\\n        for(int e1: map.keySet()){\\n            for(int e2: map.keySet()){\\n                int e3 = target-e1-e2;\\n                if(map.containsKey(e3)){\\n                    long freq1 = map.get(e1);\\n                    long freq2 = map.get(e2);\\n                    long freq3 = map.get(e3);\\n                    if(e1==e2 && e2==e3)\\n                    ans+=((freq1)*(freq2-1)*(freq3-2))/6;\\n                else if(e1==e2 && e1!=e3)\\n                    ans+=((freq1)*(freq2-1))/2*freq3;\\n                else if(e1<e2 && e2<e3)\\n                    ans+=freq1*freq2*freq3;\\n               \\n                }\\n               ans = ans%1000000007; \\n                \\n            }\\n             \\n        }\\n           return (int)ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638822,
                "title": "c-easy-to-understand-brute-force-and-optimized",
                "content": "**Brute force approach**\\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      int n=arr.size();\\n     \\n      long long c=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          vector<int> count(101,0);\\n          \\n          for(int j=i+1;j<n;j++)\\n          {\\n              int k=target-arr[i]-arr[j];\\n              if(k>=0&&k<=100&&count[k]>0)\\n              {\\n                  c+=count[k];\\n                  c%=mod;\\n              }\\n              count[arr[j]]++;\\n          }\\n      }\\n        return (int)c;\\n    }\\n};\\n```\\n**Optimized approach**\\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      int n=arr.size();\\n      vector<long long> c(101,0);\\n        for(int i=0;i<n;i++)\\n        c[arr[i]]++;\\n        long long int result=0;\\n        for(int i = 0; i <= 100; i++) {\\n            for(int j = i; j <= 100; j++) {\\n                int k = target-i-j;\\n                if(k<0 || k >100) continue;\\n                if(i == j && j==k) {\\n                    result+= (c[i] * (c[i]-1) * (c[i]-2) /6);\\n                }\\n                else if(i == j && j != k) {\\n                    result += ((c[i] * (c[i]-1) /2 ) * c[k]);\\n                }\\n                else if(i < j && j < k) {\\n                    result += (c[i] * c[j] * c[k]);\\n                }\\n            }\\n        }\\n        return (int)(result%mod);\\n    }\\n};\\n```\\n**Another optimized approach using map**\\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int,long> mp;\\n        for(int &x:arr)\\n        {\\n            mp[x]++;\\n        }\\n        long long int ans=0;\\n        for(auto &pr:mp)\\n        {\\n            int i=pr.first;\\n            for(auto &pr2:mp)\\n            {\\n                int j=pr2.first;\\n                int k=target-i-j;\\n                if(k<0||k>100||mp.find(k)==mp.end())\\n                continue;\\n                if(i==j&&j==k)\\n                {\\n                    ans+=mp[i]*(mp[i]-1)*(mp[i]-2)/6;\\n                }\\n                else if(i==j&&j!=k)\\n                {\\n                    ans+=mp[k]*mp[i]*(mp[i]-1)/2;\\n                }\\n                else if(i<j&&j<k)\\n                {\\n                    ans+=mp[i]*mp[j]*mp[k];\\n                }\\n            }\\n        }\\n        return (int)(ans%mod);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      int n=arr.size();\\n     \\n      long long c=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          vector<int> count(101,0);\\n          \\n          for(int j=i+1;j<n;j++)\\n          {\\n              int k=target-arr[i]-arr[j];\\n              if(k>=0&&k<=100&&count[k]>0)\\n              {\\n                  c+=count[k];\\n                  c%=mod;\\n              }\\n              count[arr[j]]++;\\n          }\\n      }\\n        return (int)c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      int n=arr.size();\\n      vector<long long> c(101,0);\\n        for(int i=0;i<n;i++)\\n        c[arr[i]]++;\\n        long long int result=0;\\n        for(int i = 0; i <= 100; i++) {\\n            for(int j = i; j <= 100; j++) {\\n                int k = target-i-j;\\n                if(k<0 || k >100) continue;\\n                if(i == j && j==k) {\\n                    result+= (c[i] * (c[i]-1) * (c[i]-2) /6);\\n                }\\n                else if(i == j && j != k) {\\n                    result += ((c[i] * (c[i]-1) /2 ) * c[k]);\\n                }\\n                else if(i < j && j < k) {\\n                    result += (c[i] * c[j] * c[k]);\\n                }\\n            }\\n        }\\n        return (int)(result%mod);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int,long> mp;\\n        for(int &x:arr)\\n        {\\n            mp[x]++;\\n        }\\n        long long int ans=0;\\n        for(auto &pr:mp)\\n        {\\n            int i=pr.first;\\n            for(auto &pr2:mp)\\n            {\\n                int j=pr2.first;\\n                int k=target-i-j;\\n                if(k<0||k>100||mp.find(k)==mp.end())\\n                continue;\\n                if(i==j&&j==k)\\n                {\\n                    ans+=mp[i]*(mp[i]-1)*(mp[i]-2)/6;\\n                }\\n                else if(i==j&&j!=k)\\n                {\\n                    ans+=mp[k]*mp[i]*(mp[i]-1)/2;\\n                }\\n                else if(i<j&&j<k)\\n                {\\n                    ans+=mp[i]*mp[j]*mp[k];\\n                }\\n            }\\n        }\\n        return (int)(ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215507,
                "title": "c-casewise",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mod=1000000007;\\n    int X;\\n    ll unq(vector<ll>&count)\\n    {\\n        ll res=0;\\n        for(int i=0;i<99;i++)\\n        {\\n            int j=i+1,k=100;\\n            while(j<k)\\n            {\\n                int sum=i+j+k;\\n                if(sum==X)\\n                {\\n                    res=(res+count[i]*count[j]*count[k])%mod;\\n                    j++;\\n                    k--;\\n                }\\n                else if(sum<X)\\n                    j++;\\n                else\\n                    k--;\\n            }\\n        }\\n        return res;\\n    }\\n    ll same2(vector<ll>&count)\\n    {\\n        ll res=0;\\n        for(int i=0;i<=100;i++)\\n        {\\n            int req=X-2*i;\\n            if(req>=0 && req!=i && req<=100)\\n                res=(res+count[i]*(count[i]-1)/2*count[req])%mod;\\n        }\\n        return res;\\n    }\\n    ll same3(vector<ll>&count)\\n    {\\n        ll res=0;\\n        if(X%3==0)\\n        {\\n            int x=X/3;\\n            ll n=count[x];\\n            res=(n*(n-1)*(n-2))/6;\\n        }\\n        return res%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        X=target;\\n        vector<ll>count(101,0);\\n        for(auto x:arr)\\n            count[x]++;\\n        ll unique=unq(count);\\n        ll twosame=same2(count);\\n        ll allsame=same3(count);\\n        return (unique+twosame+allsame)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mod=1000000007;\\n    int X;\\n    ll unq(vector<ll>&count)\\n    {\\n        ll res=0;\\n        for(int i=0;i<99;i++)\\n        {\\n            int j=i+1,k=100;\\n            while(j<k)\\n            {\\n                int sum=i+j+k;\\n                if(sum==X)\\n                {\\n                    res=(res+count[i]*count[j]*count[k])%mod;\\n                    j++;\\n                    k--;\\n                }\\n                else if(sum<X)\\n                    j++;\\n                else\\n                    k--;\\n            }\\n        }\\n        return res;\\n    }\\n    ll same2(vector<ll>&count)\\n    {\\n        ll res=0;\\n        for(int i=0;i<=100;i++)\\n        {\\n            int req=X-2*i;\\n            if(req>=0 && req!=i && req<=100)\\n                res=(res+count[i]*(count[i]-1)/2*count[req])%mod;\\n        }\\n        return res;\\n    }\\n    ll same3(vector<ll>&count)\\n    {\\n        ll res=0;\\n        if(X%3==0)\\n        {\\n            int x=X/3;\\n            ll n=count[x];\\n            res=(n*(n-1)*(n-2))/6;\\n        }\\n        return res%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        X=target;\\n        vector<ll>count(101,0);\\n        for(auto x:arr)\\n            count[x]++;\\n        ll unique=unq(count);\\n        ll twosame=same2(count);\\n        ll allsame=same3(count);\\n        return (unique+twosame+allsame)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124713,
                "title": "java-simple-and-easy-to-understand-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    \\n    static int MOD = 1_000_000_007; \\n    \\n    public int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        \\n        long tupleCount = 0;\\n        \\n        \\n        for(int i = 0; i < arr.length; i++){\\n            tupleCount += getCountPairsTwoSum(arr, i + 1, target - arr[i]);\\n            tupleCount %= MOD;\\n        }\\n        \\n        return (int) tupleCount;\\n    }\\n    \\n    private int getCountPairsTwoSum(int[] arr, int startIndex, int target){\\n        int l = startIndex;\\n        int r = arr.length - 1;\\n        \\n        long pairsCount = 0;\\n        \\n        while(l < r){\\n            \\n            \\n            if(arr[l] + arr[r] < target){\\n                l++;\\n            }else if(arr[l] + arr[r] > target){\\n                r--;\\n            }else if(arr[l] != arr[r]){\\n            \\n                int left = 1;\\n                while(l + 1 < r && arr[l] == arr[l + 1]){\\n                    left++;\\n                    l++;\\n                }\\n                \\n                int right = 1;\\n                while(r - 1 > l && arr[r] == arr[r - 1]){\\n                    right++;\\n                    r--;\\n                }\\n                \\n                pairsCount += (left * right);\\n                pairsCount %= MOD;\\n                \\n                l++;\\n                r--;\\n                \\n            }else if(arr[l] == arr[r]){\\n                \\n                int numCount = r - l + 1;\\n                pairsCount += numCount * (numCount - 1) / 2; \\n                \\n                pairsCount %= MOD;\\n                \\n                break;\\n            }\\n            \\n            \\n        }\\n        \\n        return (int)pairsCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int MOD = 1_000_000_007; \\n    \\n    public int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        \\n        long tupleCount = 0;\\n        \\n        \\n        for(int i = 0; i < arr.length; i++){\\n            tupleCount += getCountPairsTwoSum(arr, i + 1, target - arr[i]);\\n            tupleCount %= MOD;\\n        }\\n        \\n        return (int) tupleCount;\\n    }\\n    \\n    private int getCountPairsTwoSum(int[] arr, int startIndex, int target){\\n        int l = startIndex;\\n        int r = arr.length - 1;\\n        \\n        long pairsCount = 0;\\n        \\n        while(l < r){\\n            \\n            \\n            if(arr[l] + arr[r] < target){\\n                l++;\\n            }else if(arr[l] + arr[r] > target){\\n                r--;\\n            }else if(arr[l] != arr[r]){\\n            \\n                int left = 1;\\n                while(l + 1 < r && arr[l] == arr[l + 1]){\\n                    left++;\\n                    l++;\\n                }\\n                \\n                int right = 1;\\n                while(r - 1 > l && arr[r] == arr[r - 1]){\\n                    right++;\\n                    r--;\\n                }\\n                \\n                pairsCount += (left * right);\\n                pairsCount %= MOD;\\n                \\n                l++;\\n                r--;\\n                \\n            }else if(arr[l] == arr[r]){\\n                \\n                int numCount = r - l + 1;\\n                pairsCount += numCount * (numCount - 1) / 2; \\n                \\n                pairsCount %= MOD;\\n                \\n                break;\\n            }\\n            \\n            \\n        }\\n        \\n        return (int)pairsCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123842,
                "title": "python-recursion-memoization",
                "content": "This question shares a lot of similarities with your 0/1 knapsack problem whereby we can think of the number of the number of ways as a sum of including and not including that particular index.  For such questions whereby the bottom up solution is not obvious writing a recursive solution might be more obvious.\\n\\nTime complexity: O(3NK), N is length of arr and K is target value --> we visit each state once so this is time complexity\\nSpace complexity: O(3NK) Since we cache previous results --> same complexity as time complexity\\n\\n```\\nclass Solution:\\n    def recurse(self,arr,index,target,capacity,memo):\\n        MOD = 10**9 + 7\\n        \\n        if capacity == 0:\\n            return 1 if target == 0 else 0\\n\\n        if index < 0:\\n            return 0\\n        \\n        if (index,target,capacity) in memo:\\n            return memo[(index,target,capacity)]\\n        \\n        take = self.recurse(arr,index-1,target-arr[index],capacity-1,memo) # take it\\n        dont_take = self.recurse(arr, index-1,target,capacity,memo )\\n        memo[(index,target,capacity)] = ( take + dont_take ) % MOD\\n        return memo[(index,target,capacity)]\\n        \\n    \\n    \\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        return self.recurse(arr,len(arr)-1,target,3,{})\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recurse(self,arr,index,target,capacity,memo):\\n        MOD = 10**9 + 7\\n        \\n        if capacity == 0:\\n            return 1 if target == 0 else 0\\n\\n        if index < 0:\\n            return 0\\n        \\n        if (index,target,capacity) in memo:\\n            return memo[(index,target,capacity)]\\n        \\n        take = self.recurse(arr,index-1,target-arr[index],capacity-1,memo) # take it\\n        dont_take = self.recurse(arr, index-1,target,capacity,memo )\\n        memo[(index,target,capacity)] = ( take + dont_take ) % MOD\\n        return memo[(index,target,capacity)]\\n        \\n    \\n    \\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        return self.recurse(arr,len(arr)-1,target,3,{})\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123664,
                "title": "python-go-o-n-based-on-3-sum-w-comment",
                "content": "Python O(n) based on 3 sum\\n\\n---\\n\\n**Implementation** based on 3 sum in Python\\n\\n```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        ## dictionary\\n        # key : distinct number\\n        # value : occurrence of distinct number\\n        counts = Counter(arr)\\n        \\n        # total method count, and modulo constant\\n        result, constant = 0, (10 ** 9 + 7)\\n        \\n        \\n        # find the method count where i + j + k = target\\n        # all numbers are bounded in interval [0, 100]\\n        \\n        for i in range(101):\\n            \\n            if counts[i] == 0:\\n                \\n                # number i doesn\\'t show up in input array\\n                continue\\n                \\n            j, k = i, 100\\n            \\n            # find j, k with two-pointers\\n            while j <= k:\\n                \\n                if j + k > target - i:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# j + k is too large, try to make it smaller\\n                    k -= 1\\n                    \\n                elif j + k < target - i:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# j + k is too small, try to make it larger\\n                    j += 1\\n                    \\n                else:\\n                    \\n                    # update result with different combination cases\\n                    \\n                    if i == j == k:\\n                        \\n                        # all repeated: (i, j, k) = (i, i, i)\\n                        result += counts[i] * (counts[i] - 1) * (counts[i] - 2) // 6\\n                        \\n                    elif i == j:\\n                        # i, j repeated: (i, j, k) = (i, i, k)\\n                        result += counts[i] * (counts[i] - 1) * counts[k] // 2\\n                        \\n                    elif j == k:\\n                        # i, k repeated: (i, j, k) = (i, j, j)\\n                        result += counts[i] * counts[j] * (counts[j] - 1) // 2\\n                        \\n                    else:\\n                        # all distinct: (i, j, k)\\n                        result += counts[i] * counts[j] * counts[k]\\n                    \\n                    \\n                    # update two pointers for j, k\\n                    j += 1\\n                    k -= 1\\n                    \\n        return result % constant\\n```\\n\\n---\\n\\n**Implementation** based on 3 sum in Go\\n\\n```\\nfunc threeSumMulti(arr []int, target int) int {\\n    \\n    //// dictionary\\n    // key: distinct number\\n    // value: occurrence of distinct number\\n    counts := genDictionary( arr )\\n    \\n\\n    \\n    // total method count, and modulo constant\\n    result, constant := 0, int(math.Pow10(9)) + 7\\n    \\n    \\n    // find the method count where i + j + k = target\\n    // all numbers are bounded in interval [0, 100]\\n    \\n    for i := 0 ; i <= 100 ; i++{\\n        \\n        if counts[i] == 0{\\n            \\n            // number i doesn\\'t show up in input array\\n            continue\\n        }\\n        \\n        j, k := i, 100\\n        \\n        // find j, k with two-pointers\\n        for j <= k {\\n        \\n            \\n            if (j + k) > (target - i){\\n\\n                // j + k is too large, try to make it smaller\\n                k -= 1\\n\\n            }else if (j + k) < (target - i){\\n\\n                // j + k is too small, try to make it larger\\n                j += 1\\n\\n            }else{\\n                \\n                // update result with difference combination cases\\n                if (i == j) && (j == k) {\\n                         \\n                    // all repeated: (i, j, k) = (i, i, i)\\n                    result += counts[i] * (counts[i] - 1) * (counts[i] - 2) / 6\\n\\n                }else if (i == j){\\n\\n                    // i, j repeated: (i, j, k) = (i, i, k)\\n                    result += counts[i] * (counts[i] - 1) * (counts[k] ) / 2\\n\\n                }else if (j == k){\\n\\n                    // j, k repeated: (i, j, k) = (i, j, j)\\n                    result += counts[i] * (counts[j] ) * (counts[j] - 1) / 2\\n\\n                }else{\\n\\n                    // all distinct: (i, j, k)\\n                    result += counts[i] * counts[j] * counts[k]\\n                    \\n                }\\n                \\n                \\n                // update two-pointers for j, k\\n                j, k = j+1, k-1\\n            }\\n\\n        }\\n        //end of j <= k loop\\n        \\n    }\\n    //end of i loop\\n    \\n    \\n    \\n    return result % constant\\n}\\n\\nfunc genDictionary( arr []int)( number_occ_dict map[int]int) {\\n    \\n    number_occ_dict = make(map[int]int, 101)\\n    \\n    for _, number := range arr{\\n        number_occ_dict[number] += 1\\n    }\\n    return\\n}\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #15  3-Sum](https://leetcode.com/problems/3sum/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about Counter( ... ) ](https://docs.python.org/3/library/collections.html#collections.Counter)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Math",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        ## dictionary\\n        # key : distinct number\\n        # value : occurrence of distinct number\\n        counts = Counter(arr)\\n        \\n        # total method count, and modulo constant\\n        result, constant = 0, (10 ** 9 + 7)\\n        \\n        \\n        # find the method count where i + j + k = target\\n        # all numbers are bounded in interval [0, 100]\\n        \\n        for i in range(101):\\n            \\n            if counts[i] == 0:\\n                \\n                # number i doesn\\'t show up in input array\\n                continue\\n                \\n            j, k = i, 100\\n            \\n            # find j, k with two-pointers\\n            while j <= k:\\n                \\n                if j + k > target - i:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# j + k is too large, try to make it smaller\\n                    k -= 1\\n                    \\n                elif j + k < target - i:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# j + k is too small, try to make it larger\\n                    j += 1\\n                    \\n                else:\\n                    \\n                    # update result with different combination cases\\n                    \\n                    if i == j == k:\\n                        \\n                        # all repeated: (i, j, k) = (i, i, i)\\n                        result += counts[i] * (counts[i] - 1) * (counts[i] - 2) // 6\\n                        \\n                    elif i == j:\\n                        # i, j repeated: (i, j, k) = (i, i, k)\\n                        result += counts[i] * (counts[i] - 1) * counts[k] // 2\\n                        \\n                    elif j == k:\\n                        # i, k repeated: (i, j, k) = (i, j, j)\\n                        result += counts[i] * counts[j] * (counts[j] - 1) // 2\\n                        \\n                    else:\\n                        # all distinct: (i, j, k)\\n                        result += counts[i] * counts[j] * counts[k]\\n                    \\n                    \\n                    # update two pointers for j, k\\n                    j += 1\\n                    k -= 1\\n                    \\n        return result % constant\\n```\n```\\nfunc threeSumMulti(arr []int, target int) int {\\n    \\n    //// dictionary\\n    // key: distinct number\\n    // value: occurrence of distinct number\\n    counts := genDictionary( arr )\\n    \\n\\n    \\n    // total method count, and modulo constant\\n    result, constant := 0, int(math.Pow10(9)) + 7\\n    \\n    \\n    // find the method count where i + j + k = target\\n    // all numbers are bounded in interval [0, 100]\\n    \\n    for i := 0 ; i <= 100 ; i++{\\n        \\n        if counts[i] == 0{\\n            \\n            // number i doesn\\'t show up in input array\\n            continue\\n        }\\n        \\n        j, k := i, 100\\n        \\n        // find j, k with two-pointers\\n        for j <= k {\\n        \\n            \\n            if (j + k) > (target - i){\\n\\n                // j + k is too large, try to make it smaller\\n                k -= 1\\n\\n            }else if (j + k) < (target - i){\\n\\n                // j + k is too small, try to make it larger\\n                j += 1\\n\\n            }else{\\n                \\n                // update result with difference combination cases\\n                if (i == j) && (j == k) {\\n                         \\n                    // all repeated: (i, j, k) = (i, i, i)\\n                    result += counts[i] * (counts[i] - 1) * (counts[i] - 2) / 6\\n\\n                }else if (i == j){\\n\\n                    // i, j repeated: (i, j, k) = (i, i, k)\\n                    result += counts[i] * (counts[i] - 1) * (counts[k] ) / 2\\n\\n                }else if (j == k){\\n\\n                    // j, k repeated: (i, j, k) = (i, j, j)\\n                    result += counts[i] * (counts[j] ) * (counts[j] - 1) / 2\\n\\n                }else{\\n\\n                    // all distinct: (i, j, k)\\n                    result += counts[i] * counts[j] * counts[k]\\n                    \\n                }\\n                \\n                \\n                // update two-pointers for j, k\\n                j, k = j+1, k-1\\n            }\\n\\n        }\\n        //end of j <= k loop\\n        \\n    }\\n    //end of i loop\\n    \\n    \\n    \\n    return result % constant\\n}\\n\\nfunc genDictionary( arr []int)( number_occ_dict map[int]int) {\\n    \\n    number_occ_dict = make(map[int]int, 101)\\n    \\n    for _, number := range arr{\\n        number_occ_dict[number] += 1\\n    }\\n    return\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123455,
                "title": "3sum-with-multiplicity-c-easy-solution-short-and-simple-code-with-explanation",
                "content": "The intuition is pretty simple, there are many approaches to solve this problem, this may not be efficient but quite easy and enough to solve this one.\\nThe idea is we check whether there is two numbers such that their sum equal to `target-arr[i]`. And we store sum every possible pair `arr[i]+arr[j]` such that ` j<i` in a `unordered_map`. \\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n      int res = 0, mod = 1e9+7;\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < arr.size(); i++) {\\n            res = (res + mp[target-arr[i]]) % mod;\\n            for(int j = 0; j < i; j++) mp[arr[i]+arr[j]]++;\\n        }\\n        return res;\\n    }\\n```\\n**Efficient one**:\\nthe idea is  we count the frequency of each number using a unordered_map. \\nwe check if k = target - a-b is possible or not. we need to take care of 3 cases,\\n-> a == b == k   \\n-> a == b != k   \\n-> a < b && b < k \\n\\n**Please upvote** if you find it helpful!!\\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n       unordered_map<int, long> m;\\n        for (int n : arr) m[n]++;\\n        long res = 0;\\n        for (auto it : m)\\n            for (auto it2 : m) {\\n                int a = it.first, b = it2.first;\\n                int k= target - a - b;\\n                if (m.find(k)!=m.end()){\\n                    if (a == b && b == k)\\n                        res += m[a] * (m[a] - 1) * (m[a] - 2) / 6;\\n                    else if (a == b && b != k)\\n                        res += m[a] * (m[a]- 1) / 2 * m[k];\\n                    else if (a < b && b < k)\\n                        res += m[a] * m[b] * m[k];\\n                }\\n            }\\n        return res % 1000000007;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n      int res = 0, mod = 1e9+7;\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < arr.size(); i++) {\\n            res = (res + mp[target-arr[i]]) % mod;\\n            for(int j = 0; j < i; j++) mp[arr[i]+arr[j]]++;\\n        }\\n        return res;\\n    }\\n```\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n       unordered_map<int, long> m;\\n        for (int n : arr) m[n]++;\\n        long res = 0;\\n        for (auto it : m)\\n            for (auto it2 : m) {\\n                int a = it.first, b = it2.first;\\n                int k= target - a - b;\\n                if (m.find(k)!=m.end()){\\n                    if (a == b && b == k)\\n                        res += m[a] * (m[a] - 1) * (m[a] - 2) / 6;\\n                    else if (a == b && b != k)\\n                        res += m[a] * (m[a]- 1) / 2 * m[k];\\n                    else if (a < b && b < k)\\n                        res += m[a] * m[b] * m[k];\\n                }\\n            }\\n        return res % 1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 645510,
                "title": "simple-c-dp-solution-o-n-300-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        int dp[4][305];\\n        int mod = 1000000007;\\n        memset(dp, 0, sizeof(dp));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int k = 3; k >= 1; k--) {\\n                for (int j = 300; j >= A[i]; j--) {\\n                    dp[k][j] = (dp[k][j] + dp[k - 1][j - A[i]]) % mod;\\n                }\\n            }\\n        }\\n        return dp[3][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        int dp[4][305];\\n        int mod = 1000000007;\\n        memset(dp, 0, sizeof(dp));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int k = 3; k >= 1; k--) {\\n                for (int j = 300; j >= A[i]; j--) {\\n                    dp[k][j] = (dp[k][j] + dp[k - 1][j - A[i]]) % mod;\\n                }\\n            }\\n        }\\n        return dp[3][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547336,
                "title": "kotlin-beats-100-space-time-o-n-2",
                "content": "The short explanation: Math. The intuition behind the formulas is all basic combinatorics.\\n\\nThe long explanation:\\n1. Sort the numbers - **O(n log n)**.\\n2. Memoize the counts of each distinct integer - **O(n)**.\\n3. Solve number of solutions for i, j, k using derived formulas = `count(A[i], A[j], A[k])`- **O(log A[x])**. \\n4. Using a loop with binary search, iterate over all distinct integers from left to right, using our `count` function as we go - **O(n^2)**.\\n(*Note: Steps 1 and 2 could be done simultaneosly. An array of distinct values could then be constructed in place by shifting left for better performance on some inputs.*)\\n\\nNotice that after sorting, `A[i] <= A[j] <= A[k]`, which gives 4 possible cases when `A[i] + A[j] + A[k] == target`:\\n*(Note: We don\\'t need to compare A[i] and A[k] explicitly because of transitivity after sorting.)*\\n* `A[i] == A[j],  A[j] == A[k]`\\n* `A[i] == A[j], A[j] != A[k]`\\n* `A[i] != A[j], A[j] == A[k]`\\n* `A[i] != A[j], A[j] != A[k]`\\nFor each of these 4 situations, I\\'ve derived formulas (see comments in code). \\nThree of these are O(1) and one is O(# of A[i]). They use the memoized counts to compute solutions directly.\\n\\nFor our final loop (#4), we\\'ll prove bounds by considering the two extreme inputs, as any other cases hit our O(1) time formulas:\\n1. All numbers are the same and they sum to a solution - **O(log A[x])**\\nSounds the most difficult, but turns out to be the easiest in practice. Since we only consider distinct combinations, there is only 1 case and it can be solved directly.\\nThe bounds come from standard multiplication / division algorithms.\\nExample:\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]\\ntarget: 0\\n\\n2. All numbers are unique and the maximum number of possible solutions exist as subsets - **O(n^2)**.\\n*(A mixture of cases 1 and 2 produces some O(1) situations and some O(n) solutions, so is also O(n)).*\\nThe maximum number of unique subsets sum to the target.\\nExample:\\n[0, 1, 74, 2, 3, 70, 4, 5, 66, 6, 7, 62, 8, 9, 58, 10, 11, 54, 12, 13, 50, 14, 15, 46, 16, 17, 42, 18, 19, 38, 20, 21, 34, 22, 23, 30, 24, 25, 26]\\ntarget: 75\\n\\nThis handmade problem instance has 94 unique solutions for only 39 unique numbers.\\nIn this case, memoization doesn\\'t help us, since there are no duplicates. \\nHowever, sorting does help, since we can use binary search to maintain our worst case O(n^2) bounds.\\nOverall, this algorithm does really well on the average. The number of iterations is usually much less than the size of our input.\\n\\n```\\nclass Solution {\\n    fun threeSumMulti(A: IntArray, target: Int): Int {\\n        A.sort()\\n        val memo = mutableMapOf<Int, Int>().apply { A.forEach { put(it, getOrDefault(it, 0) + 1) } }\\n\\n        // count the total number of solutions for the provided values of A[i], A[j], A[k]\\n        fun count(xi: Int, xj: Int, xk: Int): Long {\\n            val count_xi = memo[xi]!!\\n            var count = 0L\\n\\n            if (xi == xj && xj == xk) {\\n                // target: 3\\n                // 1, 1, 1, 1, 1, 1, 1\\n                // i  j  5\\n                //       j 4\\n                //          j 3\\n                //             j  2\\n                //                j  1\\n                //    i  j  4\\n                //          j 3\\n                //             j  2\\n                //                j  1\\n                //       i  j 3\\n                //             j  2\\n                //                j  1\\n                count += ((count_xi - 2L) * (count_xi - 1L) * count_xi) / 6L\\n            } else if (xi == xj && xj != xk) {\\n                // target: 3\\n                // 1, 1, 1, 1, 2, 2, 2\\n                // i  j        3\\n                //       j     3\\n                //          j  3\\n                //    i  j     3\\n                //          j  3\\n                //       i  j  3\\n                val count_xk = memo[xk]!!\\n                val sum = ((count_xi - 1L) * count_xi) / 2L\\n                count += sum * count_xk\\n            } else if (xi != xj && xj == xk) {\\n                // target: 5\\n                // 1, 1, 1, 2, 2, 2, 2\\n                // i        j  3\\n                //             j  2\\n                //                j  1\\n                //    i     j  3\\n                //             j  2\\n                //                j  1\\n                //       i  j  3\\n                //             j  2\\n                //                j  1\\n                val count_xj = memo[xj]!!\\n                val sum = ((count_xj - 1L) * count_xj) / 2L\\n                count += count_xi * sum\\n            } else { //if (xi != xj && xj != xk)\\n                // target: 5\\n                // 1, 1, 1, 2, 2, 2, 3, 3, 3, 3\\n                // i        j        4\\n                //             j     4\\n                //                j  4\\n                //    i     j        4\\n                //             j     4\\n                //                j  4\\n                //       i  j        4\\n                //             j     4\\n                //                j  4\\n                val count_xj = memo[xj]!!\\n                val count_xk = memo[xk]!!\\n                count += count_xi * count_xj * count_xk\\n            }\\n            \\n            return count\\n        }\\n        \\n        // find the next unique position in A from i\\n        fun nextIndex(i: Int): Int {\\n            val x = A[i]\\n            var ret = i + 1\\n            while (ret < A.size && A[ret] == A[i]) ++ret\\n            return ret\\n        }\\n        // binary search for missing value\\n        fun nextIndex(target: Int, from: Int): Int {\\n            val ret = A.binarySearch(target, from)\\n            return if (ret < 0 || A[ret] != target) A.size else ret\\n        }\\n        \\n        var total = 0L\\n        var i = 0\\n        var j = 1\\n        var k = 2\\n        while (i < A.size-2 && j < A.size-1 && k < A.size) {\\n            // add new solutions to total\\n            val xi = A[i]\\n            val xj = A[j]\\n            val xk = A[k]\\n            if (xi+xj+xk == target) {\\n                total += count(xi, xj, xk)\\n                j = nextIndex(j)\\n                k = j + 1\\n                if (j >= A.size || k >= A.size) {\\n                    i = nextIndex(i)\\n                    j = i + 1\\n                    k = j + 1\\n                }\\n            } else {\\n                k = nextIndex(target - (xi+xj), k+1)\\n                if (k >= A.size) {\\n                    j = nextIndex(j)\\n                    k = j + 1\\n                }\\n                if (j >= A.size-1) {\\n                    i = nextIndex(i)\\n                    j = i + 1\\n                    k = j + 1\\n                }\\n            }\\n        }\\n\\n        return (total % 1_000_000_007L).toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Math",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun threeSumMulti(A: IntArray, target: Int): Int {\\n        A.sort()\\n        val memo = mutableMapOf<Int, Int>().apply { A.forEach { put(it, getOrDefault(it, 0) + 1) } }\\n\\n        // count the total number of solutions for the provided values of A[i], A[j], A[k]\\n        fun count(xi: Int, xj: Int, xk: Int): Long {\\n            val count_xi = memo[xi]!!\\n            var count = 0L\\n\\n            if (xi == xj && xj == xk) {\\n                // target: 3\\n                // 1, 1, 1, 1, 1, 1, 1\\n                // i  j  5\\n                //       j 4\\n                //          j 3\\n                //             j  2\\n                //                j  1\\n                //    i  j  4\\n                //          j 3\\n                //             j  2\\n                //                j  1\\n                //       i  j 3\\n                //             j  2\\n                //                j  1\\n                count += ((count_xi - 2L) * (count_xi - 1L) * count_xi) / 6L\\n            } else if (xi == xj && xj != xk) {\\n                // target: 3\\n                // 1, 1, 1, 1, 2, 2, 2\\n                // i  j        3\\n                //       j     3\\n                //          j  3\\n                //    i  j     3\\n                //          j  3\\n                //       i  j  3\\n                val count_xk = memo[xk]!!\\n                val sum = ((count_xi - 1L) * count_xi) / 2L\\n                count += sum * count_xk\\n            } else if (xi != xj && xj == xk) {\\n                // target: 5\\n                // 1, 1, 1, 2, 2, 2, 2\\n                // i        j  3\\n                //             j  2\\n                //                j  1\\n                //    i     j  3\\n                //             j  2\\n                //                j  1\\n                //       i  j  3\\n                //             j  2\\n                //                j  1\\n                val count_xj = memo[xj]!!\\n                val sum = ((count_xj - 1L) * count_xj) / 2L\\n                count += count_xi * sum\\n            } else { //if (xi != xj && xj != xk)\\n                // target: 5\\n                // 1, 1, 1, 2, 2, 2, 3, 3, 3, 3\\n                // i        j        4\\n                //             j     4\\n                //                j  4\\n                //    i     j        4\\n                //             j     4\\n                //                j  4\\n                //       i  j        4\\n                //             j     4\\n                //                j  4\\n                val count_xj = memo[xj]!!\\n                val count_xk = memo[xk]!!\\n                count += count_xi * count_xj * count_xk\\n            }\\n            \\n            return count\\n        }\\n        \\n        // find the next unique position in A from i\\n        fun nextIndex(i: Int): Int {\\n            val x = A[i]\\n            var ret = i + 1\\n            while (ret < A.size && A[ret] == A[i]) ++ret\\n            return ret\\n        }\\n        // binary search for missing value\\n        fun nextIndex(target: Int, from: Int): Int {\\n            val ret = A.binarySearch(target, from)\\n            return if (ret < 0 || A[ret] != target) A.size else ret\\n        }\\n        \\n        var total = 0L\\n        var i = 0\\n        var j = 1\\n        var k = 2\\n        while (i < A.size-2 && j < A.size-1 && k < A.size) {\\n            // add new solutions to total\\n            val xi = A[i]\\n            val xj = A[j]\\n            val xk = A[k]\\n            if (xi+xj+xk == target) {\\n                total += count(xi, xj, xk)\\n                j = nextIndex(j)\\n                k = j + 1\\n                if (j >= A.size || k >= A.size) {\\n                    i = nextIndex(i)\\n                    j = i + 1\\n                    k = j + 1\\n                }\\n            } else {\\n                k = nextIndex(target - (xi+xj), k+1)\\n                if (k >= A.size) {\\n                    j = nextIndex(j)\\n                    k = j + 1\\n                }\\n                if (j >= A.size-1) {\\n                    i = nextIndex(i)\\n                    j = i + 1\\n                    k = j + 1\\n                }\\n            }\\n        }\\n\\n        return (total % 1_000_000_007L).toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218864,
                "title": "need-help-combination-of-regular-3sums-and-combinatorics-fails-all-zeros-case",
                "content": "just added some codes to count the repetitve ones, fails all 1s and 0s cases. Shouldn\\'t we just need C(3000, 3) to get the answer? Thanks!\\n```\\nimport math\\nclass Solution:\\n    def threeSumMulti(self, A, target):\\n        \"\"\"\\n        :type A: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        maps = {}\\n        for a in A:\\n            if a not in maps:\\n                maps[a] = 1\\n            else:\\n                maps[a] += 1\\n        print(maps)\\n        A.sort()\\n        result = []\\n        count = 0\\n        for i in range(len(A)-2):\\n            if i > 0 and A[i] == A[i-1]:continue\\n            l = i+1\\n            r = len(A) - 1\\n            if [A[i], A[l], A[r]] not in result:\\n                while l < r:\\n                    sum_value = A[i] + A[l] + A[r]\\n                    if sum_value == target:\\n                        result.append([A[i], A[l], A[r]])\\n                        print(count)\\n                        if A[l] == A[r] == A[i]:\\n                            count += math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 3)*6)\\n                        elif A[i] == A[l]:\\n                            count += maps[A[r]] * math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 2)*2)\\n                        elif A[i]== A[r]:\\n                            count += maps[A[l]] * math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 2)*2)\\n                        elif A[l] == A[r]:\\n                            count += maps[A[i]] * math.factorial(maps[A[l]])/(math.factorial(maps[A[l]] - 2)*2)\\n                        else:\\n                            count += maps[A[i]] * maps[A[l]] * maps[A[r]]\\n                        while l < r and A[l] == A[l+1]:\\n                            l += 1\\n                        while l < r and A[r] == A[r-1]:\\n                            r -= 1\\n                        l += 1\\n                        r -= 1\\n                    elif sum_value < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n                    \\n        return int(count)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def threeSumMulti(self, A, target):\\n        \"\"\"\\n        :type A: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        maps = {}\\n        for a in A:\\n            if a not in maps:\\n                maps[a] = 1\\n            else:\\n                maps[a] += 1\\n        print(maps)\\n        A.sort()\\n        result = []\\n        count = 0\\n        for i in range(len(A)-2):\\n            if i > 0 and A[i] == A[i-1]:continue\\n            l = i+1\\n            r = len(A) - 1\\n            if [A[i], A[l], A[r]] not in result:\\n                while l < r:\\n                    sum_value = A[i] + A[l] + A[r]\\n                    if sum_value == target:\\n                        result.append([A[i], A[l], A[r]])\\n                        print(count)\\n                        if A[l] == A[r] == A[i]:\\n                            count += math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 3)*6)\\n                        elif A[i] == A[l]:\\n                            count += maps[A[r]] * math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 2)*2)\\n                        elif A[i]== A[r]:\\n                            count += maps[A[l]] * math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 2)*2)\\n                        elif A[l] == A[r]:\\n                            count += maps[A[i]] * math.factorial(maps[A[l]])/(math.factorial(maps[A[l]] - 2)*2)\\n                        else:\\n                            count += maps[A[i]] * maps[A[l]] * maps[A[r]]\\n                        while l < r and A[l] == A[l+1]:\\n                            l += 1\\n                        while l < r and A[r] == A[r-1]:\\n                            r -= 1\\n                        l += 1\\n                        r -= 1\\n                    elif sum_value < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n                    \\n        return int(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519593,
                "title": "solution",
                "content": "```C++ []\\nstatic const int M = 1e9 + 7, N = 101;\\n\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& a, int target) {\\n        long ans = 0, cnt[N]{};\\n        for (int &x : a) ++cnt[x];\\n        for (int i = 0; i < N; ++i)\\n            for (int j = i + 1; j < N; ++j) {\\n                int k = target - i - j;\\n                if (j < k && k < N)\\n                    (ans += cnt[i] * cnt[j] * cnt[k]) %= M;\\n            }\\n        for (int i = 0; i < N; ++i) {\\n            int k = target - 2 * i;\\n            if (i < k && k < N) (ans += cnt[i] * (cnt[i] - 1) / 2 * cnt[k]) %= M;\\n        }\\n        for (int i = 0; i < N; ++i)\\n            if (target % 2 == i % 2) {\\n                int j = (target - i) / 2;\\n                if (i < j && j < N) (ans += cnt[i] * cnt[j] * (cnt[j] - 1) / 2) %= M;\\n            }\\n        if (target % 3 == 0) {\\n            int i = target / 3;\\n            if (0 <= i && i < N) (ans += (cnt[i] * (cnt[i] - 1) % M) * (cnt[i] - 2) / 6) %= M;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        counts = Counter(arr)\\n        sorted_arr = sorted(set(arr))\\n        res = 0\\n        \\n        for i, num1 in enumerate(sorted_arr):\\n            k, j = i + 1, len(sorted_arr) - 1\\n            \\n            if counts[num1] > 1 and target - num1 * 2 in counts:\\n                if num1 * 3 == target:\\n                    res += math.comb(counts[num1], 3)\\n                else:\\n                    res += ((counts[num1] * (counts[num1] - 1)) // 2) * counts[target - num1 * 2]\\n                \\n            while k < j:\\n                num2, num3 = sorted_arr[k], sorted_arr[j]\\n                total = num1 + num2 + num3\\n                \\n                if total == target:\\n                    res += (counts[num1] * counts[num2] * counts[num3])\\n                    k += 1\\n                    j -= 1\\n                elif total < target:\\n                    k += 1\\n                else:\\n                    j -= 1\\n                    \\n        return res % (10**9 + 7)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstatic const int M = 1e9 + 7, N = 101;\\n\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& a, int target) {\\n        long ans = 0, cnt[N]{};\\n        for (int &x : a) ++cnt[x];\\n        for (int i = 0; i < N; ++i)\\n            for (int j = i + 1; j < N; ++j) {\\n                int k = target - i - j;\\n                if (j < k && k < N)\\n                    (ans += cnt[i] * cnt[j] * cnt[k]) %= M;\\n            }\\n        for (int i = 0; i < N; ++i) {\\n            int k = target - 2 * i;\\n            if (i < k && k < N) (ans += cnt[i] * (cnt[i] - 1) / 2 * cnt[k]) %= M;\\n        }\\n        for (int i = 0; i < N; ++i)\\n            if (target % 2 == i % 2) {\\n                int j = (target - i) / 2;\\n                if (i < j && j < N) (ans += cnt[i] * cnt[j] * (cnt[j] - 1) / 2) %= M;\\n            }\\n        if (target % 3 == 0) {\\n            int i = target / 3;\\n            if (0 <= i && i < N) (ans += (cnt[i] * (cnt[i] - 1) % M) * (cnt[i] - 2) / 6) %= M;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        counts = Counter(arr)\\n        sorted_arr = sorted(set(arr))\\n        res = 0\\n        \\n        for i, num1 in enumerate(sorted_arr):\\n            k, j = i + 1, len(sorted_arr) - 1\\n            \\n            if counts[num1] > 1 and target - num1 * 2 in counts:\\n                if num1 * 3 == target:\\n                    res += math.comb(counts[num1], 3)\\n                else:\\n                    res += ((counts[num1] * (counts[num1] - 1)) // 2) * counts[target - num1 * 2]\\n                \\n            while k < j:\\n                num2, num3 = sorted_arr[k], sorted_arr[j]\\n                total = num1 + num2 + num3\\n                \\n                if total == target:\\n                    res += (counts[num1] * counts[num2] * counts[num3])\\n                    k += 1\\n                    j -= 1\\n                elif total < target:\\n                    k += 1\\n                else:\\n                    j -= 1\\n                    \\n        return res % (10**9 + 7)\\n```\n```Java []\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438894,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int X)\\n     {\\n        int n = arr.size(), mod = 1e9+7, ans = 0;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++) \\n        {\\n            ans = (ans + m[X - arr[i]]) % mod;\\n            for(int j=0; j<i; j++) m[arr[i] + arr[j]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int X)\\n     {\\n        int n = arr.size(), mod = 1e9+7, ans = 0;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++) \\n        {\\n            ans = (ans + m[X - arr[i]]) % mod;\\n            for(int j=0; j<i; j++) m[arr[i] + arr[j]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306878,
                "title": "javascript-923-3sum-with-multiplicity",
                "content": "====\\n\\n1. Two Sum\\nhttps://leetcode.com/problems/two-sum/solutions/3303105/javascript-1-two-sum/\\n167. Two Sum II - Input Array Is Sorted\\nhttps://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solutions/3303938/javascript-167-two-sum-ii-input-array-is-sorted/\\n15. 3Sum\\nhttps://leetcode.com/problems/3sum/solutions/3304382/javascript-15-3sum/\\n923. 3Sum With Multiplicity\\n(( See below ))\\n18. 4Sum\\nhttps://leetcode.com/problems/4sum/solutions/3305939/javascript-18-4sum/\\n\\n====\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nMultiplicity == With duplicates\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nlet MOD = 10 ** 9 + 7;\\nfunction lower_bound_eg(arr, target, L = 0, R = arr.length) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n}\\nfunction upper_bound_g(arr, target, L = 0, R = arr.length) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] <= target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n}\\nfunction equal_range_eg_g(arr, target, L = 0, R = arr.length) {\\n    const LB = lower_bound_eg(arr, target, L, R);\\n    const UB = upper_bound_g(arr, target, L, R);\\n    return [LB, UB];\\n}\\nvar threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    // i + L + R = t\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let L = i + 1; L < n; L++) {\\n            let search = t - (a[i] + a[L]);\\n\\n            let [R, R2] = equal_range_eg_g(a, search, L + 1, n);\\n            if (R !== -Infinity) {\\n                cc += R2 - R;\\n                cc = cc % MOD;\\n            }\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n2\\n```\\nlet MOD = 10 ** 9 + 7;\\nvar threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    // i + L + R = t\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        let search = t - a[i]; //  L + R = t -i\\n\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            let search2 = a[L] + a[R]; // target;\\n\\n            if (search2 === search) {\\n                if (a[L] !== a[R]) {\\n                    let ccleft = 1, // count of equal on left\\n                        ccright = 1; // count of equal on right\\n                    while (L + 1 < R && a[L] == a[L + 1]) ccleft++, L++;\\n                    while (R - 1 > L && a[R] == a[R - 1]) ccright++, R--;\\n                    cc = cc + ccleft * ccright;\\n                    cc = cc % MOD;\\n                    L++;\\n                    R--;\\n                } else {\\n                    let count = R - L;\\n                    cc = cc + (count * (count + 1)) / 2; // pairs\\n                    cc = cc % MOD;\\n                    break;\\n                }\\n            } else if (search2 < search) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n    }\\n\\n    return cc;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet MOD = 10 ** 9 + 7;\\nfunction lower_bound_eg(arr, target, L = 0, R = arr.length) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n}\\nfunction upper_bound_g(arr, target, L = 0, R = arr.length) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] <= target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n}\\nfunction equal_range_eg_g(arr, target, L = 0, R = arr.length) {\\n    const LB = lower_bound_eg(arr, target, L, R);\\n    const UB = upper_bound_g(arr, target, L, R);\\n    return [LB, UB];\\n}\\nvar threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    // i + L + R = t\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let L = i + 1; L < n; L++) {\\n            let search = t - (a[i] + a[L]);\\n\\n            let [R, R2] = equal_range_eg_g(a, search, L + 1, n);\\n            if (R !== -Infinity) {\\n                cc += R2 - R;\\n                cc = cc % MOD;\\n            }\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nlet MOD = 10 ** 9 + 7;\\nvar threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    // i + L + R = t\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        let search = t - a[i]; //  L + R = t -i\\n\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            let search2 = a[L] + a[R]; // target;\\n\\n            if (search2 === search) {\\n                if (a[L] !== a[R]) {\\n                    let ccleft = 1, // count of equal on left\\n                        ccright = 1; // count of equal on right\\n                    while (L + 1 < R && a[L] == a[L + 1]) ccleft++, L++;\\n                    while (R - 1 > L && a[R] == a[R - 1]) ccright++, R--;\\n                    cc = cc + ccleft * ccright;\\n                    cc = cc % MOD;\\n                    L++;\\n                    R--;\\n                } else {\\n                    let count = R - L;\\n                    cc = cc + (count * (count + 1)) / 2; // pairs\\n                    cc = cc % MOD;\\n                    break;\\n                }\\n            } else if (search2 < search) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n    }\\n\\n    return cc;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2759830,
                "title": "c-fast-solution-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        int x,y,z;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            x=arr[i];\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                y=arr[j];\\n                z=target-(x+y);\\n                ans=(ans+mp[z])%mod; \\n            }\\n            mp[x]++;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        int x,y,z;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            x=arr[i];\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                y=arr[j];\\n                z=target-(x+y);\\n                ans=(ans+mp[z])%mod; \\n            }\\n            mp[x]++;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440714,
                "title": "java-o-n-2-with-hashmap-clean-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int n = arr.length;\\n        int res = 0;\\n        int MOD = 1000000007;\\n        for(int i = 0; i < n; i++){\\n            int goal = target - arr[i];\\n            int c = count.getOrDefault(goal, 0);\\n            res = (res % MOD + c % MOD) % MOD;\\n            for(int j = 0; j < i; j++){\\n                int s = arr[i] + arr[j];\\n                count.put(s, count.getOrDefault(s, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int n = arr.length;\\n        int res = 0;\\n        int MOD = 1000000007;\\n        for(int i = 0; i < n; i++){\\n            int goal = target - arr[i];\\n            int c = count.getOrDefault(goal, 0);\\n            res = (res % MOD + c % MOD) % MOD;\\n            for(int j = 0; j < i; j++){\\n                int s = arr[i] + arr[j];\\n                count.put(s, count.getOrDefault(s, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178528,
                "title": "simple-intuition-permutation-combination-c",
                "content": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n        \\n        map<int,long long> m;\\n        long long ans=0;\\n        \\n        for(auto i:m)\\n            m[i]++;\\n                \\n        for(auto it1:m)\\n        {\\n            for(auto it2:m)\\n            {\\n                int i=it1.first,j=it2.first,k=target-i-j;\\n                \\n    //Case 1  all the three are equal--> (n*n-1*n-2)/3! as all the three are same\\n                if(i==j and j==k) \\n                    ans+= (m[i]*(m[i]-1)*(m[i]-2))/6;\\n                \\n     //Case 2  all the three are equal--> (n*n-1)/2! as two of them are same       \\n                else if(i==j and j!=k)\\n                     ans+=(m[i]*(m[i]-1)*m[k])/2;\\n       \\n        //Case 3 all distinct\\n                else if(i<j and j<k)\\n                    ans+=m[i]*m[j]*m[k];\\n            }\\n        }\\n        \\n        return ans%1000000007;\\n    }",
                "solutionTags": [],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n        \\n        map<int,long long> m;\\n        long long ans=0;\\n        \\n        for(auto i:m)\\n            m[i]++;\\n                \\n        for(auto it1:m)\\n        {\\n            for(auto it2:m)\\n            {\\n                int i=it1.first,j=it2.first,k=target-i-j;\\n                \\n    //Case 1  all the three are equal--> (n*n-1*n-2)/3! as all the three are same\\n                if(i==j and j==k) \\n                    ans+= (m[i]*(m[i]-1)*(m[i]-2))/6;\\n                \\n     //Case 2  all the three are equal--> (n*n-1)/2! as two of them are same       \\n                else if(i==j and j!=k)\\n                     ans+=(m[i]*(m[i]-1)*m[k])/2;\\n       \\n        //Case 3 all distinct\\n                else if(i<j and j<k)\\n                    ans+=m[i]*m[j]*m[k];\\n            }\\n        }\\n        \\n        return ans%1000000007;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2178258,
                "title": "java-3sum-template",
                "content": "```\\nclass Solution \\n{\\n    public int threeSumMulti(int[] arr, int target) \\n    {\\n        int mod = (int)1e9+7;\\n        int count = 0;\\n        Arrays.sort(arr);\\n        for(int k = arr.length-1;k>=0;k--)\\n        {\\n            int v1 = arr[k];\\n            int i = 0;\\n            int j = k-1;\\n            \\n            while(i < j)\\n            {\\n                int v2 = arr[i];\\n                int v3 = arr[j];\\n                \\n                if(v1+v2+v3 == target)\\n                {\\n                    if(v2 == v3)\\n                    {\\n                        while(j > i)\\n                        {\\n                            count = (count + (j-i)%mod)%mod;\\n                            j--;\\n                        }\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        int c1 = 1;\\n                        int c2 = 1;\\n                        while(arr[j-1] == arr[j])\\n                        {\\n                            j--;\\n                            c1++;\\n                        }\\n                        while(arr[i+1] == arr[i])\\n                        {\\n                            i++;\\n                            c2++;\\n                        }\\n                        \\n                        count = (count +  ((c1*c2))%mod)%mod;\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n                else if(v1+v2+v3 > target)\\n                {\\n                    j--;\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n        }\\n        return count%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int threeSumMulti(int[] arr, int target) \\n    {\\n        int mod = (int)1e9+7;\\n        int count = 0;\\n        Arrays.sort(arr);\\n        for(int k = arr.length-1;k>=0;k--)\\n        {\\n            int v1 = arr[k];\\n            int i = 0;\\n            int j = k-1;\\n            \\n            while(i < j)\\n            {\\n                int v2 = arr[i];\\n                int v3 = arr[j];\\n                \\n                if(v1+v2+v3 == target)\\n                {\\n                    if(v2 == v3)\\n                    {\\n                        while(j > i)\\n                        {\\n                            count = (count + (j-i)%mod)%mod;\\n                            j--;\\n                        }\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        int c1 = 1;\\n                        int c2 = 1;\\n                        while(arr[j-1] == arr[j])\\n                        {\\n                            j--;\\n                            c1++;\\n                        }\\n                        while(arr[i+1] == arr[i])\\n                        {\\n                            i++;\\n                            c2++;\\n                        }\\n                        \\n                        count = (count +  ((c1*c2))%mod)%mod;\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n                else if(v1+v2+v3 > target)\\n                {\\n                    j--;\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n        }\\n        return count%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145248,
                "title": "python-two-sum-clean-code",
                "content": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        result = 0\\n        arr.sort()\\n        \\n        for index in range(len(arr)):\\n            targetDiff = target - arr[index]\\n            \\n            left = index + 1\\n            right = len(arr) - 1\\n            \\n            while left < right:\\n                complement = arr[left] + arr[right]\\n                \\n                if complement > targetDiff:\\n                    right -= 1\\n                elif complement < targetDiff:\\n                    left += 1\\n                elif arr[left] != arr[right]:\\n                    leftCounter = 1\\n                    rightCounter = 1\\n                    \\n                    while left < right and arr[left] == arr[left + 1]:\\n                        leftCounter += 1\\n                        left += 1\\n                    \\n                    while right > left and arr[right] == arr[right - 1]:\\n                        rightCounter += 1\\n                        right -= 1\\n                        \\n                    result += leftCounter * rightCounter\\n                    result %= 10**9 + 7\\n                    \\n                    left += 1\\n                    right -= 1\\n                else:\\n                    result += (right - left + 1) * (right - left) // 2\\n                    result %= 10**9 + 7\\n                    break\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        result = 0\\n        arr.sort()\\n        \\n        for index in range(len(arr)):\\n            targetDiff = target - arr[index]\\n            \\n            left = index + 1\\n            right = len(arr) - 1\\n            \\n            while left < right:\\n                complement = arr[left] + arr[right]\\n                \\n                if complement > targetDiff:\\n                    right -= 1\\n                elif complement < targetDiff:\\n                    left += 1\\n                elif arr[left] != arr[right]:\\n                    leftCounter = 1\\n                    rightCounter = 1\\n                    \\n                    while left < right and arr[left] == arr[left + 1]:\\n                        leftCounter += 1\\n                        left += 1\\n                    \\n                    while right > left and arr[right] == arr[right - 1]:\\n                        rightCounter += 1\\n                        right -= 1\\n                        \\n                    result += leftCounter * rightCounter\\n                    result %= 10**9 + 7\\n                    \\n                    left += 1\\n                    right -= 1\\n                else:\\n                    result += (right - left + 1) * (right - left) // 2\\n                    result %= 10**9 + 7\\n                    break\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131256,
                "title": "python-sorting-hashmap-two-sum-approach-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        count = 0\\n        for i in range(0, len(arr)-2):\\n            rem_sum = target - arr[i]\\n            hash_map = {}\\n            for j in range(i+1, len(arr)):\\n                if arr[j] > rem_sum:\\n                    break\\n                if rem_sum - arr[j] in hash_map:\\n                    count = count + hash_map[rem_sum-arr[j]]\\n                # update the hash_map\\n                hash_map[arr[j]] = hash_map.get(arr[j], 0) + 1\\n        return count % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        count = 0\\n        for i in range(0, len(arr)-2):\\n            rem_sum = target - arr[i]\\n            hash_map = {}\\n            for j in range(i+1, len(arr)):\\n                if arr[j] > rem_sum:\\n                    break\\n                if rem_sum - arr[j] in hash_map:\\n                    count = count + hash_map[rem_sum-arr[j]]\\n                # update the hash_map\\n                hash_map[arr[j]] = hash_map.get(arr[j], 0) + 1\\n        return count % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085110,
                "title": "c-o-n-2-modified-3sum-approach-beats-97-time-complexity",
                "content": "![image](https://assets.leetcode.com/users/images/e6aef1c6-096f-4eba-9818-47141003f500_1653773309.2855682.png)\\nHere\\'s my easy solution using a *modified 3-SUM approach*:\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long long ret=0;\\n        sort(arr.begin(), arr.end());\\n        vector<int> reducedarr;\\n        unordered_map<int,long long int> count;\\n        for(int i=0; i<arr.size(); i++){\\n            if(count.find(arr[i])==count.end()){\\n                reducedarr.push_back(arr[i]);\\n                count[arr[i]] = 1;\\n            }\\n            else count[arr[i]]++;\\n        }\\n        int m=reducedarr.size();\\n        for(int i=0; i<m; i++){\\n            int j=i, k=m-1;\\n            while(j<=k){\\n                int sum=reducedarr[i]+reducedarr[j]+reducedarr[k];\\n                if(sum==target){\\n                    int x=reducedarr[i], y=reducedarr[j], z=reducedarr[k];\\n                    if(x!=y and y!=z)\\n                        ret = (ret + count[x]*count[y]*count[z])%mod;\\n                    else if(x==y and y!=z)\\n                        ret = (ret + count[x]*(count[x]-1)/2*count[z])%mod;\\n                    else if(x!=y and y==z)\\n                        ret = (ret + count[x]*count[y]*(count[y]-1)/2)%mod;\\n                    else\\n                        ret = (ret + count[x]*(count[x]-1)*(count[x]-2)/6)%mod;\\n                    j++; k--;\\n                }\\n                else if(sum>target) k--;\\n                else j++;\\n            }\\n        }\\n        return (int)ret;\\n    }\\n};\\n```\\n\\nThanks \\uD83D\\uDE01\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long long ret=0;\\n        sort(arr.begin(), arr.end());\\n        vector<int> reducedarr;\\n        unordered_map<int,long long int> count;\\n        for(int i=0; i<arr.size(); i++){\\n            if(count.find(arr[i])==count.end()){\\n                reducedarr.push_back(arr[i]);\\n                count[arr[i]] = 1;\\n            }\\n            else count[arr[i]]++;\\n        }\\n        int m=reducedarr.size();\\n        for(int i=0; i<m; i++){\\n            int j=i, k=m-1;\\n            while(j<=k){\\n                int sum=reducedarr[i]+reducedarr[j]+reducedarr[k];\\n                if(sum==target){\\n                    int x=reducedarr[i], y=reducedarr[j], z=reducedarr[k];\\n                    if(x!=y and y!=z)\\n                        ret = (ret + count[x]*count[y]*count[z])%mod;\\n                    else if(x==y and y!=z)\\n                        ret = (ret + count[x]*(count[x]-1)/2*count[z])%mod;\\n                    else if(x!=y and y==z)\\n                        ret = (ret + count[x]*count[y]*(count[y]-1)/2)%mod;\\n                    else\\n                        ret = (ret + count[x]*(count[x]-1)*(count[x]-2)/6)%mod;\\n                    j++; k--;\\n                }\\n                else if(sum>target) k--;\\n                else j++;\\n            }\\n        }\\n        return (int)ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026211,
                "title": "c-easy-intuitive-code-two-pointers",
                "content": "**Please do upvote if you liked my code ;)**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        long ans=0;\\n        sort(arr.begin(), arr.end());\\n        map<int, long> m, hash;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n            m[arr[i]] = i, ++hash[arr[i]];\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            if(i > 0 and arr[i] == arr[i-1]) continue;\\n            \\n            for(int j=i+1; j<arr.size(); j++)\\n            {\\n                if(j != i+1 and arr[j] == arr[j-1]) continue;\\n                int idx = target-arr[i]-arr[j];\\n                \\n                if(m[idx] > j) \\n                {\\n                    if(arr[i] == arr[j] and arr[j] == idx) \\n                        ans += hash[arr[i]] * (hash[arr[i]]-1) * (hash[arr[i]]-2) / 6;\\n                    else if(arr[i] == arr[j]) \\n                        ans += hash[arr[i]] * (hash[arr[i]]-1)/2 * hash[idx];\\n                    else if(arr[j] == idx) \\n                        ans += hash[idx] * (hash[idx]-1)/2 * hash[arr[i]];\\n                    else \\n                        ans += hash[arr[j]] * hash[idx] * hash[arr[i]];\\n                    \\n                    ans %= 1000000007; \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        long ans=0;\\n        sort(arr.begin(), arr.end());\\n        map<int, long> m, hash;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n            m[arr[i]] = i, ++hash[arr[i]];\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            if(i > 0 and arr[i] == arr[i-1]) continue;\\n            \\n            for(int j=i+1; j<arr.size(); j++)\\n            {\\n                if(j != i+1 and arr[j] == arr[j-1]) continue;\\n                int idx = target-arr[i]-arr[j];\\n                \\n                if(m[idx] > j) \\n                {\\n                    if(arr[i] == arr[j] and arr[j] == idx) \\n                        ans += hash[arr[i]] * (hash[arr[i]]-1) * (hash[arr[i]]-2) / 6;\\n                    else if(arr[i] == arr[j]) \\n                        ans += hash[arr[i]] * (hash[arr[i]]-1)/2 * hash[idx];\\n                    else if(arr[j] == idx) \\n                        ans += hash[idx] * (hash[idx]-1)/2 * hash[arr[i]];\\n                    else \\n                        ans += hash[arr[j]] * hash[idx] * hash[arr[i]];\\n                    \\n                    ans %= 1000000007; \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941649,
                "title": "3-sum-extension",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    #define mod 1e9+7\\n    unordered_map<int,long>mp;//esko long lena bohot zaruri tha\\n    \\n    int tuplecnt(vector<vector<int>>res)\\n    {\\n        int n=res.size();\\n       long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;\\n                if(res[i][j]!=res[i][j+1] &&res[i][j+1]!=res[i][j+2] )\\n                {\\n                  sum+=(mp[res[i][j]]*mp[res[i][j+1]]*mp[res[i][j+2]]);\\n                    // cout<<(mp[res[i][j]]*mp[res[i][j+1]]*mp[res[i][j+2]])<<endl;\\n                    \\n                }\\n           else if(res[i][j]!=res[i][j+1] &&res[i][j+1]==res[i][j+2] )\\n                {\\n                  sum+=(mp[res[i][j]]*((mp[res[i][j+1]])*(mp[res[i][j+1]]-1)/2));\\n               // cout<<mp[res[i][j]]*mp[res[i][j+1]]<<endl;\\n                    \\n                }\\n            else if(res[i][j]==res[i][j+1] &&res[i][j+1]!=res[i][j+2] )\\n                {\\n                   sum+=(mp[res[i][j+2]]*((mp[res[i][j]])*(mp[res[i][j]]-1)/2));\\n                // cout<<mp[res[i][j]]*mp[res[i][j+2]]<<endl;\\n                    \\n                }\\n            else\\n            {\\n                // nC3 select  any 3 from n hence n!/r!(n-r)!\\n                sum+=((mp[res[i][j]]) * (mp[res[i][j]]-1)* (mp[res[i][j]]- 2)/ 6)%int(1e9+7);\\n            }\\n           \\n        }\\n      return  sum % int(1e9 + 7);//int (1e9+7) likna zaruri tha bcz 1e9+7 is in form of double\\n        \\n        \\n    }\\n    \\n    \\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        vector<vector<int>>res;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n       \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && arr[i-1]==arr[i])\\n            {\\n                continue;\\n            }\\n            \\n            int s=i+1;\\n            int e=n-1;\\n            \\n            while(s<e)\\n            {\\n                int sum=arr[s]+arr[e]+arr[i];\\n                \\n                if(sum>target)\\n                {\\n                    e--;\\n                }\\n                else if(sum<target)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                     res.push_back(vector<int> {arr[i], arr[s],arr[e]});\\n                    \\n                    while(s<e &&arr[s]==arr[s+1])\\n                    {\\n                        s++;\\n                    }\\n                    \\n                     while(s<e &&arr[e]==arr[e-1])\\n                    {\\n                        e--;\\n                    }\\n                    s++;\\n                    e--;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n   \\n        }\\n        \\n        //get all combination of 3 to get sum target\\n         for(int i=0;i<res.size();i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                cout<<res[i][j];\\n            }\\n             cout<<endl;\\n        }\\n        \\n        //fnnn to calculate all possibilities of that number to get\\n        int ans=tuplecnt(res);\\n        return ans;\\n\\n    }\\n    \\n    \\n    \\n};```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define mod 1e9+7\\n    unordered_map<int,long>mp;//esko long lena bohot zaruri tha\\n    \\n    int tuplecnt(vector<vector<int>>res)\\n    {\\n        int n=res.size();\\n       long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;\\n                if(res[i][j]!=res[i][j+1] &&res[i][j+1]!=res[i][j+2] )\\n                {\\n                  sum+=(mp[res[i][j]]*mp[res[i][j+1]]*mp[res[i][j+2]]);\\n                    // cout<<(mp[res[i][j]]*mp[res[i][j+1]]*mp[res[i][j+2]])<<endl;\\n                    \\n                }\\n           else if(res[i][j]!=res[i][j+1] &&res[i][j+1]==res[i][j+2] )\\n                {\\n                  sum+=(mp[res[i][j]]*((mp[res[i][j+1]])*(mp[res[i][j+1]]-1)/2));\\n               // cout<<mp[res[i][j]]*mp[res[i][j+1]]<<endl;\\n                    \\n                }\\n            else if(res[i][j]==res[i][j+1] &&res[i][j+1]!=res[i][j+2] )\\n                {\\n                   sum+=(mp[res[i][j+2]]*((mp[res[i][j]])*(mp[res[i][j]]-1)/2));\\n                // cout<<mp[res[i][j]]*mp[res[i][j+2]]<<endl;\\n                    \\n                }\\n            else\\n            {\\n                // nC3 select  any 3 from n hence n!/r!(n-r)!\\n                sum+=((mp[res[i][j]]) * (mp[res[i][j]]-1)* (mp[res[i][j]]- 2)/ 6)%int(1e9+7);\\n            }\\n           \\n        }\\n      return  sum % int(1e9 + 7);//int (1e9+7) likna zaruri tha bcz 1e9+7 is in form of double\\n        \\n        \\n    }\\n    \\n    \\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        vector<vector<int>>res;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n       \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && arr[i-1]==arr[i])\\n            {\\n                continue;\\n            }\\n            \\n            int s=i+1;\\n            int e=n-1;\\n            \\n            while(s<e)\\n            {\\n                int sum=arr[s]+arr[e]+arr[i];\\n                \\n                if(sum>target)\\n                {\\n                    e--;\\n                }\\n                else if(sum<target)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                     res.push_back(vector<int> {arr[i], arr[s],arr[e]});\\n                    \\n                    while(s<e &&arr[s]==arr[s+1])\\n                    {\\n                        s++;\\n                    }\\n                    \\n                     while(s<e &&arr[e]==arr[e-1])\\n                    {\\n                        e--;\\n                    }\\n                    s++;\\n                    e--;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n   \\n        }\\n        \\n        //get all combination of 3 to get sum target\\n         for(int i=0;i<res.size();i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                cout<<res[i][j];\\n            }\\n             cout<<endl;\\n        }\\n        \\n        //fnnn to calculate all possibilities of that number to get\\n        int ans=tuplecnt(res);\\n        return ans;\\n\\n    }\\n    \\n    \\n    \\n};```",
                "codeTag": "C++"
            },
            {
                "id": 1932156,
                "title": "3-sum-with-multiplicitty-29-ms-and-10-9mb-mathematical-approach",
                "content": "# 3 Sum with Multiplicity\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size(),j,k,temp;\\n        unordered_map<int,int> hash ;\\n         for(int i=0; i<n; i++)\\n             hash[arr[i]]++;\\n         long long ans = 0 ,mod = 1e9+7;\\n        \\n        for(int i=0; i<n-2 ;i++ )\\n        {\\n            while(i>0 and  i<n-2 and arr[i-1]==arr[i]) i++; // skipping\\n             j=i+1; k=n-1;\\n                  while(j<k)\\n            {\\n                temp = arr[i]+arr[j]+arr[k];\\n                if(temp==target)\\n                {\\n                    if(arr[i]==arr[j] && arr[j]==arr[k])\\n                    {\\n                        long val=hash[arr[i]];\\n                       long long re=((val*(val-1))*(val-2))/6;\\n                        ans+=re;\\n                    }\\n                    else if(arr[i]==arr[j])\\n                    {\\n                        long val=hash[arr[i]];\\n                       long long re=(val*(val-1))/2;\\n                        ans+=(re*hash[arr[k]]);\\n                    }\\n                    else if(arr[j]==arr[k])\\n                    {\\n                        long val=hash[arr[j]];\\n                       long long re=(val*(val-1))/2;\\n                        ans+=(re*hash[arr[i]]);\\n                    }\\n                    else if(arr[i]!=arr[j] && arr[i]!=arr[k] && arr[j]!=arr[k])\\n                    ans += hash[arr[i]]*hash[arr[j]]*hash[arr[k]];\\n                    ans %= mod;\\n                    \\n                    while(j<k and arr[j+1]==arr[j]) j++;\\n                    while(j<k and arr[k-1]==arr[k]) k--;\\n                      j++; k--;\\n                }\\n                else if(temp > target) k--;\\n                else j++;           \\n            }    \\n        }\\n            return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size(),j,k,temp;\\n        unordered_map<int,int> hash ;\\n         for(int i=0; i<n; i++)\\n             hash[arr[i]]++;\\n         long long ans = 0 ,mod = 1e9+7;\\n        \\n        for(int i=0; i<n-2 ;i++ )\\n        {\\n            while(i>0 and  i<n-2 and arr[i-1]==arr[i]) i++; // skipping\\n             j=i+1; k=n-1;\\n                  while(j<k)\\n            {\\n                temp = arr[i]+arr[j]+arr[k];\\n                if(temp==target)\\n                {\\n                    if(arr[i]==arr[j] && arr[j]==arr[k])\\n                    {\\n                        long val=hash[arr[i]];\\n                       long long re=((val*(val-1))*(val-2))/6;\\n                        ans+=re;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1927632,
                "title": "best-approach-5-line-code-hindi-video",
                "content": "I made a video to explain this approach but that is in hindi .\\nIts an awesome video, I guaranteed you, Please dont forget to upvote this. This easy solution explanation you will not find so please dont forget to upvote this.\\nRemove space between . and com and copy paste url.\\nyoutube. com/watch?v=tdZwvbTXIUU\\n\\n```\\nunordered_map<int,int> mp;\\n        int ans=0;\\n        int mod=pow(10,9)+7;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            ans=(ans+mp[t-arr[i]])%mod;\\n            for(int j=0;j<i;j++){\\n                mp[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<int,int> mp;\\n        int ans=0;\\n        int mod=pow(10,9)+7;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            ans=(ans+mp[t-arr[i]])%mod;\\n            for(int j=0;j<i;j++){\\n                mp[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926743,
                "title": "c-two-pointer-approach",
                "content": "class Solution\\n{\\npublic:\\n    int threeSumMulti(vector<int> &arr, int target)\\n    {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        long long mod = 1e9 + 7;\\n\\n        int count = 0;\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            int l = i + 1;\\n            int r = n - 1;\\n\\n            int a = arr[i];\\n            int req = target - a;\\n\\n            while (l < r)\\n            {\\n\\n                int b = arr[l] + arr[r];\\n\\n                if (b < req)\\n                    l++;\\n                else if (b > req)\\n                    r--;\\n                else\\n                {\\n                    int leftcount = 1;\\n                    int rightcount = 1;\\n\\n                    while (l < r && arr[l] == arr[l + 1])\\n                    {\\n                        leftcount++;\\n                        l++;\\n                    }\\n\\n                    while (l < r && arr[r] == arr[r - 1])\\n                    {\\n                        rightcount++;\\n                        r--;\\n                    }\\n\\n                    if (l == r)\\n                    {\\n                        count = (count % mod + (leftcount % mod * (leftcount - 1) % mod) / 2) % mod; // number of ways of selecting 2 element from n elements\\n                    }\\n                    if (l != r)\\n                    {\\n                        count = (count % mod + (leftcount % mod * rightcount % mod) % mod) % mod;\\n                    }\\n\\n                    l++;\\n                    r--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int threeSumMulti(vector<int> &arr, int target)\\n    {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        long long mod = 1e9 + 7;\\n\\n        int count = 0;\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            int l = i + 1;\\n            int r = n - 1;\\n\\n            int a = arr[i];\\n            int req = target - a;\\n\\n            while (l < r)\\n            {\\n\\n                int b = arr[l] + arr[r];\\n\\n                if (b < req)\\n                    l++;\\n                else if (b > req)\\n                    r--;\\n                else\\n                {\\n                    int leftcount = 1;\\n                    int rightcount = 1;\\n\\n                    while (l < r && arr[l] == arr[l + 1])\\n                    {\\n                        leftcount++;\\n                        l++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1921542,
                "title": "simple-python-o-n2-approach",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        d=Counter(arr)\\n        dk=d.keys()\\n        ans=0\\n        for i in dk:\\n            for j in dk:\\n                el3=target-i-j\\n                if el3 in dk:\\n                    f1=d[i]\\n                    f2=d[j]\\n                    f3=d[el3]\\n                    if i==j==el3:\\n                        ans+=f1*(f1-1)*(f1-2)/6\\n                    elif i==j and i<el3:\\n                        ans+=f1*(f1-1)/2*f3\\n                    elif i<j and j==el3:\\n                        ans+=f1*f2*(f2-1)/2\\n                    elif i<j<el3:\\n                        ans+=f1*f2*f3\\n        return int(ans)%(10**9+7)\\n                        \\n                        \\n                        \\n        ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        d=Counter(arr)\\n        dk=d.keys()\\n        ans=0\\n        for i in dk:\\n            for j in dk:\\n                el3=target-i-j\\n                if el3 in dk:\\n                    f1=d[i]\\n                    f2=d[j]\\n                    f3=d[el3]\\n                    if i==j==el3:\\n                        ans+=f1*(f1-1)*(f1-2)/6\\n                    elif i==j and i<el3:\\n                        ans+=f1*(f1-1)/2*f3\\n                    elif i<j and j==el3:\\n                        ans+=f1*f2*(f2-1)/2\\n                    elif i<j<el3:\\n                        ans+=f1*f2*f3\\n        return int(ans)%(10**9+7)\\n                        \\n                        \\n                        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1920912,
                "title": "golang-o-n-2-time-o-n-space",
                "content": "```go\\nfunc threeSumMulti(arr []int, target int) (res int) {\\n    const mod = 1e9 + 7\\n    \\n    c := make(map[int]int)\\n    for _, num := range arr { c[num]++ }\\n    \\n    arr = arr[:0]\\n    for num := range c { arr = append(arr, num) }\\n    \\n    sort.Ints(arr)\\n    \\n    // search for arr[i] * 3 == target\\n    for _, num := range arr {\\n        if num*3 == target && c[num] >= 2 {\\n            res = (res + c[num] * (c[num]-1) * (c[num]-2) / 6) % mod\\n        }\\n    }\\n    \\n    // search for arr[i]+arr[i]+arr[j] == target\\n    for i := 0; i < len(arr); i++ {\\n        if c[arr[i]] >= 2 {            \\n            for j := 0; j < len(arr); j++ {\\n                if j == i { continue }\\n                \\n                if arr[j] + arr[i]*2 == target {\\n                    res = (res + (c[arr[i]] * (c[arr[i]]-1) / 2) * c[arr[j]]) % mod\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    // search for arr[i]+arr[j]+arr[k] == target\\n    for i := 0; i < len(arr); i++ {\\n        target2 := target - arr[i]\\n        \\n        j, k := i+1, len(arr)-1\\n        for j < k {\\n            if arr[j] + arr[k] == target2 {\\n                res = (res + (c[arr[i]] * c[arr[j]] * c[arr[k]])) % mod\\n                j++; k--\\n            } else if arr[j] + arr[k] < target2 {\\n                j++\\n            } else {\\n                k--\\n            }\\n        }\\n    }\\n    \\n    return\\n}\\n\\n// C(n, 2) = n! / (2! * (n-2)!) = (n * (n-1)) / 2\\n// C(n, 3) = n! / (3! * (n-3)!) = (n * (n-1) * (n-2)) / 6\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc threeSumMulti(arr []int, target int) (res int) {\\n    const mod = 1e9 + 7\\n    \\n    c := make(map[int]int)\\n    for _, num := range arr { c[num]++ }\\n    \\n    arr = arr[:0]\\n    for num := range c { arr = append(arr, num) }\\n    \\n    sort.Ints(arr)\\n    \\n    // search for arr[i] * 3 == target\\n    for _, num := range arr {\\n        if num*3 == target && c[num] >= 2 {\\n            res = (res + c[num] * (c[num]-1) * (c[num]-2) / 6) % mod\\n        }\\n    }\\n    \\n    // search for arr[i]+arr[i]+arr[j] == target\\n    for i := 0; i < len(arr); i++ {\\n        if c[arr[i]] >= 2 {            \\n            for j := 0; j < len(arr); j++ {\\n                if j == i { continue }\\n                \\n                if arr[j] + arr[i]*2 == target {\\n                    res = (res + (c[arr[i]] * (c[arr[i]]-1) / 2) * c[arr[j]]) % mod\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    // search for arr[i]+arr[j]+arr[k] == target\\n    for i := 0; i < len(arr); i++ {\\n        target2 := target - arr[i]\\n        \\n        j, k := i+1, len(arr)-1\\n        for j < k {\\n            if arr[j] + arr[k] == target2 {\\n                res = (res + (c[arr[i]] * c[arr[j]] * c[arr[k]])) % mod\\n                j++; k--\\n            } else if arr[j] + arr[k] < target2 {\\n                j++\\n            } else {\\n                k--\\n            }\\n        }\\n    }\\n    \\n    return\\n}\\n\\n// C(n, 2) = n! / (2! * (n-2)!) = (n * (n-1)) / 2\\n// C(n, 3) = n! / (3! * (n-3)!) = (n * (n-1) * (n-2)) / 6\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1920902,
                "title": "swift-all-combinations-o-n-101",
                "content": "- Maintain `counter` in which `counter[num][i]` represents the occurrences of `num` from index `0 --> i`.\\n- Let\\'s consider each number `b = arr[i]` from index `1 --> arr.count - 2` as the middle number corresponding to index `j`. \\n\\t- For every number `a` from `0-->100` corresponding to index `i`, we can get the occurences of `a` on the left side of `b` in constant time --> `left = counter[a][i - 1]`\\n\\t- Since we already know `a & b`, it\\'s simple to know `c = target - a - b`  coressponding to index `k` and also we\\'re able to get the occurences of `c` on the right side of `b` in constant time --> `right = counter[c][n - 1] - counter[c][i]` \\n\\t- Then increase the result accordingly `res += left * right`\\n\\n```swift\\nclass Solution {\\n  func threeSumMulti(_ arr: [Int], _ target: Int) -> Int {\\n    let n = arr.count\\n    var counter = Array(repeating: Array(repeating: 0, count: n), count: 101)\\n    for i in 0..<n {\\n      for num in 0...100 {\\n        let prev = i == 0 ? 0: counter[num][i - 1]\\n        counter[num][i] = prev\\n      }\\n      \\n      let num = arr[i]\\n      let prev = i == 0 ? 0 : counter[num][i - 1] \\n      counter[num][i] = prev + 1\\n    }\\n    \\n    let mod = 1_000_000_007\\n    var res = 0 \\n    for i in stride(from: 1, to: n - 1, by: 1) {\\n      let b = arr[i]\\n      for a in 0...100 {\\n        let c = target - a - b\\n        if c < 0 || c > 100 { \\n          continue\\n        }\\n        \\n        let left = counter[a][i - 1]\\n        let right = max(0, counter[c][n - 1] - counter[c][i])\\n        res += left * right\\n      }\\n    }\\n    \\n    return res % mod\\n  }\\n}\\n// Time complexity: O(n * 101) \\n// Space complexity: O(n * 101) to store counter\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```swift\\nclass Solution {\\n  func threeSumMulti(_ arr: [Int], _ target: Int) -> Int {\\n    let n = arr.count\\n    var counter = Array(repeating: Array(repeating: 0, count: n), count: 101)\\n    for i in 0..<n {\\n      for num in 0...100 {\\n        let prev = i == 0 ? 0: counter[num][i - 1]\\n        counter[num][i] = prev\\n      }\\n      \\n      let num = arr[i]\\n      let prev = i == 0 ? 0 : counter[num][i - 1] \\n      counter[num][i] = prev + 1\\n    }\\n    \\n    let mod = 1_000_000_007\\n    var res = 0 \\n    for i in stride(from: 1, to: n - 1, by: 1) {\\n      let b = arr[i]\\n      for a in 0...100 {\\n        let c = target - a - b\\n        if c < 0 || c > 100 { \\n          continue\\n        }\\n        \\n        let left = counter[a][i - 1]\\n        let right = max(0, counter[c][n - 1] - counter[c][i])\\n        res += left * right\\n      }\\n    }\\n    \\n    return res % mod\\n  }\\n}\\n// Time complexity: O(n * 101) \\n// Space complexity: O(n * 101) to store counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920759,
                "title": "python-time-o-n-2-with-counter-where-n-of-distinct-elements",
                "content": "# Idea\\nRecap high school math: total ways to choose 3 balls from total n balls is `n!/(3!(n-3)!)`, where `n!` is factorial of `n`.\\n\\nif we have a list of `11` elements with value `2`: [2,2,2, ..., 2], and target value is `6`, what is the 3Sum answer?\\nans = `11!/(3!(11-3)!)` = 165\\n\\nhow about array of [2, 2, 2, ..., 3, 3, 3, ...], target = 7, where there is total m of `2`, and n of `3`?\\nthe only possible 3sum pattern is `2 2 3`,\\nso the ans = `total ways to choose 2 elements from m elements` * `n` = `m!(2!(m-2)!)` *`n`\\nif the target is 8 instead, it is similar: ans = m * `total ways to choose 2 elements from n elements` = `m` * `n!(2!(n-2)!)`\\n\\nTime complixity: O(N^2) where N is the number of distinct numbers\\n\\n# Code\\n```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        # for calculating factorial\\n        factMem = dict()\\n        def fact(n):\\n            if n in factMem:\\n                return factMem[n]\\n            if n <= 1:\\n                factMem[n] = 1\\n                return 1\\n            ans = n * fact(n-1)\\n            factMem[n] = ans\\n            return ans\\n        fact3 = fact(3)\\n        fact2 = fact(2)\\n        \\n        # count the frequency of each element\\n        multiplicity = Counter(arr)\\n        \\n        # create list only contains distinct numbers\\n        nums = []\\n        visited = set()\\n        for n in arr:\\n            if n in visited:\\n                continue\\n            nums.append(n)\\n            visited.add(n)\\n        \\n        # create a postfix set to quickly lookup if a number appears in nums[i:]\\n        postfixNumsSet = []\\n        numsSet = set()\\n        for i in range(len(nums)-1, -1, -1):\\n            numsSet.add(nums[i])\\n            postfixNumsSet.append(numsSet.copy())\\n        postfixNumsSet.reverse()\\n        \\n        bound = 1e9 + 7\\n        ans = 0\\n        for i in range(len(nums)):\\n            freqI = multiplicity[nums[i]]\\n            \\n            # i i i\\n            if multiplicity[nums[i]] >= 3 and nums[i]*3 == target:\\n                count = fact(freqI) // (fact3 * fact(freqI - 3))\\n                ans = (ans + count%bound) % bound\\n            \\n            for j in range(i+1, len(nums)):\\n                freqJ = multiplicity[nums[j]]\\n                \\n                # i i j\\n                if freqI >= 2 and nums[i]*2 + nums[j] == target:\\n                    count = (fact(freqI) // (fact2 * fact(freqI - 2)) ) * freqJ\\n                    ans = (ans + count%bound) % bound\\n                \\n                # j j i\\n                if freqJ >= 2 and nums[i] + nums[j]*2 == target:\\n                    count = (fact(freqJ) // (fact2 * fact(freqJ - 2)) ) * freqI\\n                    ans = (ans + count%bound) % bound\\n                \\n                # i j k\\n                wantedK = target - nums[i] - nums[j]\\n                if j >= len(nums) - 1 or wantedK not in postfixNumsSet[j+1]:\\n                    continue\\n                count = multiplicity[wantedK] * multiplicity[nums[i]] * multiplicity[nums[j]]\\n                ans = (ans + count%bound) % bound\\n        return int(ans)\\n```\\n",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        # for calculating factorial\\n        factMem = dict()\\n        def fact(n):\\n            if n in factMem:\\n                return factMem[n]\\n            if n <= 1:\\n                factMem[n] = 1\\n                return 1\\n            ans = n * fact(n-1)\\n            factMem[n] = ans\\n            return ans\\n        fact3 = fact(3)\\n        fact2 = fact(2)\\n        \\n        # count the frequency of each element\\n        multiplicity = Counter(arr)\\n        \\n        # create list only contains distinct numbers\\n        nums = []\\n        visited = set()\\n        for n in arr:\\n            if n in visited:\\n                continue\\n            nums.append(n)\\n            visited.add(n)\\n        \\n        # create a postfix set to quickly lookup if a number appears in nums[i:]\\n        postfixNumsSet = []\\n        numsSet = set()\\n        for i in range(len(nums)-1, -1, -1):\\n            numsSet.add(nums[i])\\n            postfixNumsSet.append(numsSet.copy())\\n        postfixNumsSet.reverse()\\n        \\n        bound = 1e9 + 7\\n        ans = 0\\n        for i in range(len(nums)):\\n            freqI = multiplicity[nums[i]]\\n            \\n            # i i i\\n            if multiplicity[nums[i]] >= 3 and nums[i]*3 == target:\\n                count = fact(freqI) // (fact3 * fact(freqI - 3))\\n                ans = (ans + count%bound) % bound\\n            \\n            for j in range(i+1, len(nums)):\\n                freqJ = multiplicity[nums[j]]\\n                \\n                # i i j\\n                if freqI >= 2 and nums[i]*2 + nums[j] == target:\\n                    count = (fact(freqI) // (fact2 * fact(freqI - 2)) ) * freqJ\\n                    ans = (ans + count%bound) % bound\\n                \\n                # j j i\\n                if freqJ >= 2 and nums[i] + nums[j]*2 == target:\\n                    count = (fact(freqJ) // (fact2 * fact(freqJ - 2)) ) * freqI\\n                    ans = (ans + count%bound) % bound\\n                \\n                # i j k\\n                wantedK = target - nums[i] - nums[j]\\n                if j >= len(nums) - 1 or wantedK not in postfixNumsSet[j+1]:\\n                    continue\\n                count = multiplicity[wantedK] * multiplicity[nums[i]] * multiplicity[nums[j]]\\n                ans = (ans + count%bound) % bound\\n        return int(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920650,
                "title": "simple-js-solution-o-n-2-o-1-three-pointer-with-explaination",
                "content": "# Idea\\nFor each number in the array we need to find 2 more numbers which eaual to the sum. We can use 2 nested loops.\\n\\n1. Iterate through each number.\\n2. Inside the inner loop, low and high to keep track of the low and high val.\\n\\ti. sum should be equal to low + high\\n\\tii. If sum is greater we move the high pointer left \\n\\tiii. If sum is smaller we move the low pointer to the right\\n\\tiv. If sum is equal we again have 2 cases\\n\\t\\ta. One where arr[low] === arr[high]. In this case we total possible combinations are (n*n-1)/2;\\n\\t\\tb. Otherwise total combinations are count(high) * count(low)\\n\\nExplaination for arr[low] === arr[high] case\\n![image](https://assets.leetcode.com/users/images/ec9024fc-080b-404d-9377-13941580638a_1649272396.3804002.png)\\n\\n```\\n// For modulo\\nconst MOD = Math.pow(10, 9) + 7;\\n\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nconst threeSumMulti = function(arr, target) {\\n  // Step 1: Sort the number O(nlogn)\\n  arr.sort((a, b) => a - b);\\n  \\n  // Step 2: 3 Pointer approach O(n^2)\\n  let total = 0;\\n  for(let i = 0; i < arr.length; i += 1) {\\n    // The current value which is the first value\\n    const curVal = arr[i]; \\n    \\n    // Low and high to keep track of the low and high val\\n    // Idea is that sum should be equal to low + high\\n    // If sum is greater we move the high pointer left\\n    // If sum is smaller we move the low pointer to the right\\n    // If sum is equal we again have 2 cases\\n    // One where arr[low] === arr[high]. In this case we total possible combinations are (n*n-1)/2;\\n    // Otherwise total combinations are count(high) * count(low)\\n    let low = i + 1;\\n    let high = arr.length - 1;\\n    \\n    // Loop is run while low is smaller than high\\n    while(low < high) {\\n      const lowVal = arr[low];\\n      const highVal = arr[high];\\n      const sum = curVal + lowVal + highVal;\\n      \\n      if(sum > target) {\\n        high -= 1;\\n      } else if(sum < target) {\\n        low += 1;\\n      } else if(lowVal === highVal) {\\n        total = (total + ((high-low) * (high-low+1))/2) % MOD;\\n        break;\\n      } else {\\n        let lowCount = 0;\\n        let highCount = 0;\\n        while(arr[low] === lowVal) {\\n          low += 1;\\n          lowCount += 1;\\n        }\\n        while(arr[high] === highVal) {\\n          high -= 1;\\n          highCount += 1;\\n        }\\n        total = total + (lowCount * highCount) % MOD;\\n      }\\n    }\\n  }\\n  \\n  // Return the total\\n  return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// For modulo\\nconst MOD = Math.pow(10, 9) + 7;\\n\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nconst threeSumMulti = function(arr, target) {\\n  // Step 1: Sort the number O(nlogn)\\n  arr.sort((a, b) => a - b);\\n  \\n  // Step 2: 3 Pointer approach O(n^2)\\n  let total = 0;\\n  for(let i = 0; i < arr.length; i += 1) {\\n    // The current value which is the first value\\n    const curVal = arr[i]; \\n    \\n    // Low and high to keep track of the low and high val\\n    // Idea is that sum should be equal to low + high\\n    // If sum is greater we move the high pointer left\\n    // If sum is smaller we move the low pointer to the right\\n    // If sum is equal we again have 2 cases\\n    // One where arr[low] === arr[high]. In this case we total possible combinations are (n*n-1)/2;\\n    // Otherwise total combinations are count(high) * count(low)\\n    let low = i + 1;\\n    let high = arr.length - 1;\\n    \\n    // Loop is run while low is smaller than high\\n    while(low < high) {\\n      const lowVal = arr[low];\\n      const highVal = arr[high];\\n      const sum = curVal + lowVal + highVal;\\n      \\n      if(sum > target) {\\n        high -= 1;\\n      } else if(sum < target) {\\n        low += 1;\\n      } else if(lowVal === highVal) {\\n        total = (total + ((high-low) * (high-low+1))/2) % MOD;\\n        break;\\n      } else {\\n        let lowCount = 0;\\n        let highCount = 0;\\n        while(arr[low] === lowVal) {\\n          low += 1;\\n          lowCount += 1;\\n        }\\n        while(arr[high] === highVal) {\\n          high -= 1;\\n          highCount += 1;\\n        }\\n        total = total + (lowCount * highCount) % MOD;\\n      }\\n    }\\n  }\\n  \\n  // Return the total\\n  return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1920560,
                "title": "python-soln-100-faster-3sum-combinations-o-n-2-comments",
                "content": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\'\\'\\'\\n        T.C := O(n^2)\\n        \\'\\'\\'\\n        freqs = Counter(arr)\\n\\n        #1. sorted unique nums\\n        nums = sorted(freqs)\\n        n = len(nums)\\n        res = 0 # total number of triplet possible (with repeatation allowed from diff pos)\\n        \\n        for i, n1 in enumerate(nums): # first elem := {n1}\\n            t = target - n1 # target for 2 sum\\n            # Find next 2 elem :- 2 Sum Problem\\n            l, r = i, n-1  # NOTE :- here {n1} can repeat in soln so consdering l = i\\n            while l <= r:\\n                n2, n3 = nums[l], nums[r]\\n                n23 = n2 + n3\\n                if n23 < t:\\n                    l += 1\\n                elif n23 > t:\\n                    r -= 1\\n                else: # Triplet May be possible for (i, l, r)   \\n                    # the only thing we need to check is Frequency of num available accordingly\\n                    f1, f2, f3 = freqs[n1], freqs[n2], freqs[n3]\\n\\n                    # 1. All 3 are unique num (ie n1, n2, n3)  (So no freq check require)\\n                    if i < l < r:\\n                        res += f1*f2*f3\\n                    # 2. 2 Uniques (n1, n1, n3) \\n                    elif (i == l) and (l < r):\\n                        # f1_C_2 * n3\\n                        res += (comb(f1, 2) * f3)\\n                    # 3. 2 Unique (n1, n2, n2)\\n                    elif (i < l) and (l == r):\\n                        # f2_C_2 * f1\\n                        res += (f1 * comb(f2, 2))\\n                    # 4. All 3 same (ie n1, n1, n1)\\n                    else:\\n                        res += comb(f1, 3)\\n\\n                    # Explore further Possibilities\\n                    l, r = l+1, r-1   # Eg 2, 3, 4, 5  & t = 7 -> (2,5) | (3,4)\\n        \\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\'\\'\\'\\n        T.C := O(n^2)\\n        \\'\\'\\'\\n        freqs = Counter(arr)\\n\\n        #1. sorted unique nums\\n        nums = sorted(freqs)\\n        n = len(nums)\\n        res = 0 # total number of triplet possible (with repeatation allowed from diff pos)\\n        \\n        for i, n1 in enumerate(nums): # first elem := {n1}\\n            t = target - n1 # target for 2 sum\\n            # Find next 2 elem :- 2 Sum Problem\\n            l, r = i, n-1  # NOTE :- here {n1} can repeat in soln so consdering l = i\\n            while l <= r:\\n                n2, n3 = nums[l], nums[r]\\n                n23 = n2 + n3\\n                if n23 < t:\\n                    l += 1\\n                elif n23 > t:\\n                    r -= 1\\n                else: # Triplet May be possible for (i, l, r)   \\n                    # the only thing we need to check is Frequency of num available accordingly\\n                    f1, f2, f3 = freqs[n1], freqs[n2], freqs[n3]\\n\\n                    # 1. All 3 are unique num (ie n1, n2, n3)  (So no freq check require)\\n                    if i < l < r:\\n                        res += f1*f2*f3\\n                    # 2. 2 Uniques (n1, n1, n3) \\n                    elif (i == l) and (l < r):\\n                        # f1_C_2 * n3\\n                        res += (comb(f1, 2) * f3)\\n                    # 3. 2 Unique (n1, n2, n2)\\n                    elif (i < l) and (l == r):\\n                        # f2_C_2 * f1\\n                        res += (f1 * comb(f2, 2))\\n                    # 4. All 3 same (ie n1, n1, n1)\\n                    else:\\n                        res += comb(f1, 3)\\n\\n                    # Explore further Possibilities\\n                    l, r = l+1, r-1   # Eg 2, 3, 4, 5  & t = 7 -> (2,5) | (3,4)\\n        \\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920555,
                "title": "c-sorting-map-two-pointers-o-n-2-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        unordered_map<int, int> mp;//num, freq\\n        \\n        int count = 0;\\n        int mod = 1000000007;\\n        \\n        for (int i=0; i<arr.size(); i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        for (int i=0; i<arr.size()-2; i++){\\n            \\n            int sum = target - arr[i];\\n            \\n            mp[arr[i]]--;\\n            \\n            int left = i+1;\\n            int right = arr.size()-1;\\n            \\n            while(left < right){\\n                \\n                int mysum = arr[left] + arr[right];\\n                \\n                if (mysum > sum) right -= mp[arr[right]];\\n                else if (mysum < sum) left += mp[arr[left]];\\n                else{\\n                    \\n                    if (arr[left] == arr[right]){\\n                        int n = right - left + 1;\\n                        count = (count + (n*(n-1))/2)%mod;\\n                        break;\\n                    }\\n                    \\n                    count = (count + mp[arr[left]]*mp[arr[right]])%mod;\\n                    left += mp[arr[left]];\\n                    right -= mp[arr[right]];  \\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        unordered_map<int, int> mp;//num, freq\\n        \\n        int count = 0;\\n        int mod = 1000000007;\\n        \\n        for (int i=0; i<arr.size(); i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        for (int i=0; i<arr.size()-2; i++){\\n            \\n            int sum = target - arr[i];\\n            \\n            mp[arr[i]]--;\\n            \\n            int left = i+1;\\n            int right = arr.size()-1;\\n            \\n            while(left < right){\\n                \\n                int mysum = arr[left] + arr[right];\\n                \\n                if (mysum > sum) right -= mp[arr[right]];\\n                else if (mysum < sum) left += mp[arr[left]];\\n                else{\\n                    \\n                    if (arr[left] == arr[right]){\\n                        int n = right - left + 1;\\n                        count = (count + (n*(n-1))/2)%mod;\\n                        break;\\n                    }\\n                    \\n                    count = (count + mp[arr[left]]*mp[arr[right]])%mod;\\n                    left += mp[arr[left]];\\n                    right -= mp[arr[right]];  \\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920307,
                "title": "hashmap-approach-time-o-n-2-and-space-o-n",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> freqMap = new HashMap<>();\\n        for(int element : arr) { // for all the elements in the array \\n            long freq = freqMap.getOrDefault(element, 0l); \\n            // calculating the frequency of all the elements\\n            freqMap.put(element, freq + 1l); \\n            // updating the frequency one higher than the previous one                       \\n        }\\n        long ans = 0;\\n        for(Integer el1 : freqMap.keySet()) {\\n            for(Integer el2 : freqMap.keySet()) {\\n                int el3 = target - el1 - el2;\\n                if(freqMap.containsKey(el3)) {\\n                    long freq1 = freqMap.get(el1);\\n                    long freq2 = freqMap.get(el2);\\n                    long freq3 = freqMap.get(el3);\\n                    if(el1 == el2 && el1 == el3) {\\n                        ans += (freq1 * (freq1 - 1) * (freq1 - 2)) / 6;\\n                    }\\n                    if(el1 == el2 && el1 != el3) {\\n                        ans += ((freq1 * (freq1 - 1)) / 2 * freq3);\\n                    }\\n                    if(el1 < el2 && el2 < el3) {\\n                        ans += (freq1 * freq2 * freq3);\\n                    }\\n                }\\n                ans = ans % 1000000007;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> freqMap = new HashMap<>();\\n        for(int element : arr) { // for all the elements in the array \\n            long freq = freqMap.getOrDefault(element, 0l); \\n            // calculating the frequency of all the elements\\n            freqMap.put(element, freq + 1l); \\n            // updating the frequency one higher than the previous one                       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1920256,
                "title": "approach-using-two-sum-o-n-2-time",
                "content": "\\n    int twosum(vector<int>& arr, int target, int s, int e){\\n        unordered_map<int,long long>m1;\\n        long long ans=0;\\n        for(int i=s;i<=e;i++){\\n            if(m1.find(target-arr[i])!=m1.end())\\n               { ans+=(m1[target-arr[i]])%1000000007;\\n                ans=ans%1000000007;}\\n             m1[arr[i]]++;\\n        }\\n       return ans;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n\\n        long long ans=0;\\n\\n        \\n        int e=arr.size()-1;\\n        for(int i=0;i<arr.size();i++){\\n            int newt=target-arr[i];\\n            ans+=twosum(arr, newt, i+1, e);\\n            ans=ans%1000000007;\\n        }\\n        return ans;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int twosum(vector<int>& arr, int target, int s, int e){\\n        unordered_map<int,long long>m1;\\n        long long ans=0;\\n        for(int i=s;i<=e;i++){\\n            if(m1.find(target-arr[i])!=m1.end())\\n               { ans+=(m1[target-arr[i]])%1000000007;\\n                ans=ans%1000000007;}\\n             m1[arr[i]]++;\\n        }\\n       return ans;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n\\n        long long ans=0;\\n\\n        \\n        int e=arr.size()-1;\\n        for(int i=0;i<arr.size();i++){\\n            int newt=target-arr[i];\\n            ans+=twosum(arr, newt, i+1, e);\\n            ans=ans%1000000007;\\n        }\\n        return ans;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1920202,
                "title": "c-simplest-solution-2-different-approach",
                "content": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n#         T.C. O(N^2) S.C. O(N)\\n\\t\\tlong long ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            ans+=m[target-arr[i]];\\n            ans%=(1000000007);\\n            for(int j=0;j<i;j++){\\n                m[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return ans;\\n#         T.C. O(NLOGN) S.C. O(1) \\n        sort(arr.begin(),arr.end());\\n        long long ans=0;\\n        for(int i=0;i<arr.size();i++){\\n            int l=i+1,r=arr.size()-1;\\n            while(l<r){\\n                if(arr[i]+arr[l]+arr[r]==target){\\n                    int l_cnt=1,r_cnt=1;\\n                    while(l<r && arr[l]==arr[l+1]){\\n                        l_cnt++;\\n                        l++;\\n                    }\\n                     while(l<r && arr[r]==arr[r-1]){\\n                        r_cnt++;\\n                        r--;\\n                    }\\n                    if(r==l){\\n                        long long x=(l_cnt*(l_cnt-1))/2;\\n                        ans+=x;\\n                        ans%=1000000007;\\n                    }else{\\n                        long long x=(l_cnt*r_cnt);\\n                        ans+=(x%1000000007);\\n                        ans%=1000000007;\\n                            \\n                    }\\n                    r--;l++;\\n                    \\n                }\\n                else if(arr[i]+arr[l]+arr[r]>target){\\n                    r--;\\n                }\\n                else if(arr[i]+arr[l]+arr[r]<target){\\n                    l++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n#         T.C. O(N^2) S.C. O(N)\\n\\t\\tlong long ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            ans+=m[target-arr[i]];\\n            ans%=(1000000007);\\n            for(int j=0;j<i;j++){\\n                m[arr[i]+arr[j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1920126,
                "title": "very-easy-o-n-2-solution",
                "content": "Here is my code \\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n         int n = arr.size();\\n         int ans = 0;\\n         int mod = 1e9 + 7;\\n         int sz = 100 * (3000);\\n         sz++;\\n         vector<int> pref(sz , 0);\\n         for(int i=0;i<n;i++)\\n         {\\n             int val = target - (arr[i]);\\n             \\n             if(val >= 0)\\n             {\\n                 ans = (ans + pref[val])%mod;\\n             }\\n             \\n             for(int j=0;j<i;j++)\\n             {\\n                 pref[arr[i] + arr[j]]++;\\n             }\\n         }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n         int n = arr.size();\\n         int ans = 0;\\n         int mod = 1e9 + 7;\\n         int sz = 100 * (3000);\\n         sz++;\\n         vector<int> pref(sz , 0);\\n         for(int i=0;i<n;i++)\\n         {\\n             int val = target - (arr[i]);\\n             \\n             if(val >= 0)\\n             {\\n                 ans = (ans + pref[val])%mod;\\n             }\\n             \\n             for(int j=0;j<i;j++)\\n             {\\n                 pref[arr[i] + arr[j]]++;\\n             }\\n         }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920065,
                "title": "java-not-really-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int mod = (int)1e9 + 7;\\n        long[] count = new long[101];\\n        \\n        for (int a: arr) {\\n            count[a] ++;\\n        }\\n        \\n        long res =0;\\n        \\n        for (int i = 0; i < 101; i ++) {\\n            for (int j = i; j < 101; j++) {\\n                int f = target - i - j;\\n                \\n                if (f < j || f >= 101 || count[i] == 0 || count[j] == 0 || count[f] == 0) {\\n                    continue;\\n                }\\n                long fi = count[i];\\n                long fj = i == j ? count[i] - 1 : count[j];\\n                long ff = j == f ? i == f ? count[i] - 2 : count[j] - 1 : count[f];\\n\\t\\t\\t\\t// 3! == 6, 2! == 2, 1! == 1 :D\\n                int permutation = (j == f && j == i) ? 6 : (j == f || j == i) ? 2 : 1;\\n                if (fi <= 0 || fj <= 0 || ff <= 0) {\\n                    continue;\\n                }\\n                // i use the fomula of Combination with repetition in here\\n                res += (fi * fj * ff / permutation) ; \\n            }\\n        }\\n        \\n        return (int)(res % mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int mod = (int)1e9 + 7;\\n        long[] count = new long[101];\\n        \\n        for (int a: arr) {\\n            count[a] ++;\\n        }\\n        \\n        long res =0;\\n        \\n        for (int i = 0; i < 101; i ++) {\\n            for (int j = i; j < 101; j++) {\\n                int f = target - i - j;\\n                \\n                if (f < j || f >= 101 || count[i] == 0 || count[j] == 0 || count[f] == 0) {\\n                    continue;\\n                }\\n                long fi = count[i];\\n                long fj = i == j ? count[i] - 1 : count[j];\\n                long ff = j == f ? i == f ? count[i] - 2 : count[j] - 1 : count[f];\\n\\t\\t\\t\\t// 3! == 6, 2! == 2, 1! == 1 :D\\n                int permutation = (j == f && j == i) ? 6 : (j == f || j == i) ? 2 : 1;\\n                if (fi <= 0 || fj <= 0 || ff <= 0) {\\n                    continue;\\n                }\\n                // i use the fomula of Combination with repetition in here\\n                res += (fi * fj * ff / permutation) ; \\n            }\\n        }\\n        \\n        return (int)(res % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919977,
                "title": "3-pointer-with-ncr-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    long long nCr(long long n, int r)\\n    {\\n        long long fecAns = 1;\\n        int dif = n - r + 1;\\n        for (int i = n; i >= dif; i--)\\n        {\\n            fecAns = (fecAns * i);\\n        }\\n        long long gT = 1;\\n        for (int i = r; i >= 2; i--)\\n        {\\n            gT = (gT * i);\\n        }\\n        return fecAns / gT;\\n    }\\n    int threeSumMulti(vector<int> &arr, int target)\\n    {\\n        vector<int> count(101, 0);\\n        for (auto i : arr)\\n            count[i]++;\\n        sort(arr.begin(), arr.end());\\n        long long ans = 0;\\n\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            if (i > 0 && arr[i] == arr[i - 1])\\n                continue;\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (j > i + 1 && arr[j] == arr[j - 1])\\n                    continue;\\n                for (int k = j + 1; k < arr.size(); k++)\\n                {\\n                    if (k > j + 1 && arr[k] == arr[k - 1])\\n                        continue;\\n                    if (arr[i] + arr[j] + arr[k] == target)\\n                    {\\n                        if (arr[i] == arr[j] && arr[j] == arr[k])\\n                        {\\n                            long long value = nCr(count[arr[i]], 3);\\n                            ans += value;\\n                        }\\n                        else if (arr[i] == arr[j])\\n                        {\\n                            long long value = nCr(count[arr[i]], 2) * count[arr[k]];\\n                            ans += value;\\n                        }\\n                        else if (arr[j] == arr[k])\\n                        {\\n                            long long value = nCr(count[arr[k]], 2) * count[arr[i]];\\n                            ans += value;\\n                        }\\n                        else\\n                        {\\n                            int value = nCr(count[arr[i]], 1) * nCr(count[arr[j]], 1) * nCr(count[arr[k]], 1);\\n                            ans += value;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long nCr(long long n, int r)\\n    {\\n        long long fecAns = 1;\\n        int dif = n - r + 1;\\n        for (int i = n; i >= dif; i--)\\n        {\\n            fecAns = (fecAns * i);\\n        }\\n        long long gT = 1;\\n        for (int i = r; i >= 2; i--)\\n        {\\n            gT = (gT * i);\\n        }\\n        return fecAns / gT;\\n    }\\n    int threeSumMulti(vector<int> &arr, int target)\\n    {\\n        vector<int> count(101, 0);\\n        for (auto i : arr)\\n            count[i]++;\\n        sort(arr.begin(), arr.end());\\n        long long ans = 0;\\n\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            if (i > 0 && arr[i] == arr[i - 1])\\n                continue;\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (j > i + 1 && arr[j] == arr[j - 1])\\n                    continue;\\n                for (int k = j + 1; k < arr.size(); k++)\\n                {\\n                    if (k > j + 1 && arr[k] == arr[k - 1])\\n                        continue;\\n                    if (arr[i] + arr[j] + arr[k] == target)\\n                    {\\n                        if (arr[i] == arr[j] && arr[j] == arr[k])\\n                        {\\n                            long long value = nCr(count[arr[i]], 3);\\n                            ans += value;\\n                        }\\n                        else if (arr[i] == arr[j])\\n                        {\\n                            long long value = nCr(count[arr[i]], 2) * count[arr[k]];\\n                            ans += value;\\n                        }\\n                        else if (arr[j] == arr[k])\\n                        {\\n                            long long value = nCr(count[arr[k]], 2) * count[arr[i]];\\n                            ans += value;\\n                        }\\n                        else\\n                        {\\n                            int value = nCr(count[arr[i]], 1) * nCr(count[arr[j]], 1) * nCr(count[arr[k]], 1);\\n                            ans += value;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919857,
                "title": "two-pointers",
                "content": "\\nclass Solution {\\n  int mod = 1e9+7;\\npublic:\\n\\n\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n      sort(arr.begin(),arr.end());\\n      long long ans =  0;\\n      int n = arr.size();\\n      for(int i=0;i<n;i++)\\n      {\\n        int k = i+1;\\n        int j = n-1;\\n        int currsum = target-arr[i];\\n        while(k<j)\\n        {\\n          if((arr[k]+arr[j] )== currsum)\\n          {\\n            int l=1,r=1;\\n            while(k<j && arr[k] == arr[k+1])\\n            {\\n              k++;\\n              l++;\\n            } \\n            while(k<j && arr[j] == arr[j-1])\\n            {\\n              j--;\\n              r++;\\n            }\\n            \\n            if(k == j)\\n            {\\n              long long take = (l*(l-1))/2;\\n              ans = (ans+take)%mod;\\n            }else{\\n              ans = (ans + (l*r)%mod)%mod;\\n            }\\n            k++;\\n            j--;\\n          }else if(arr[k]+arr[j] > currsum)\\n          {\\n            j--;\\n          }else{\\n            k++;\\n          }\\n        }\\n      }\\n      return ans>mod ? mod : ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n  int mod = 1e9+7;\\npublic:\\n\\n\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n      sort(arr.begin(),arr.end());\\n      long long ans =  0;\\n      int n = arr.size();\\n      for(int i=0;i<n;i++)\\n      {\\n        int k = i+1;\\n        int j = n-1;\\n        int currsum = target-arr[i];\\n        while(k<j)\\n        {\\n          if((arr[k]+arr[j] )== currsum)\\n          {\\n            int l=1,r=1;\\n            while(k<j && arr[k] == arr[k+1])\\n            {\\n              k++;\\n              l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1919843,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long long int ans = 0;\\n        int n = arr.size(), mx = *max_element(arr.begin(), arr.end()), mod = 1e9+7;\\n        vector <vector<int>> v(n+1, vector<int>(mx+1, 0));\\n        v[0][arr[0]] = 1;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<=mx; j++)\\n                v[i][j] = v[i-1][j];\\n            v[i][arr[i]] +=  1;\\n        }\\n        for(int i=1; i<n-1; i++){\\n            int l = 0, r = target-arr[i];\\n            while(r >= 0){\\n                if(l<=mx && r <= mx)\\n                    ans = (ans + v[i-1][l]*(v[n-1][r]-v[i][r]))%mod;\\n                l += 1;\\n                r -= 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long long int ans = 0;\\n        int n = arr.size(), mx = *max_element(arr.begin(), arr.end()), mod = 1e9+7;\\n        vector <vector<int>> v(n+1, vector<int>(mx+1, 0));\\n        v[0][arr[0]] = 1;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<=mx; j++)\\n                v[i][j] = v[i-1][j];\\n            v[i][arr[i]] +=  1;\\n        }\\n        for(int i=1; i<n-1; i++){\\n            int l = 0, r = target-arr[i];\\n            while(r >= 0){\\n                if(l<=mx && r <= mx)\\n                    ans = (ans + v[i-1][l]*(v[n-1][r]-v[i][r]))%mod;\\n                l += 1;\\n                r -= 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919762,
                "title": "best-solution-with-explanation-c-java-python",
                "content": "***Please Upvote if you Like it!***\\n\\nCount the occurrence of each number.\\nusing hashmap or array up to you.\\n\\nLoop i on all numbers,\\nloop j on all numbers,\\ncheck if k = target - i - j is valid.\\n\\nAdd the number of this combination to result.\\n3 cases covers all possible combination:\\n\\ni == j == k\\ni == j != k\\ni < k && j < k\\nTime Complexity:\\n3 <= A.length <= 3000, so N = 3000\\nBut 0 <= A[i] <= 100\\nSo my solution is O(N + 101 * 101)\\n\\nC++:\\n\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\nJava:\\n\\n    public int threeSumMulti(int[] A, int target) {\\n        long[] c = new long[101];\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (int i = 0; i <= 100; i++)\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k > 100 || k < 0) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return (int)(res % (1e9 + 7));\\n    }\\nPython:\\n\\n    def threeSumMulti(self, A, target):\\n        c = collections.Counter(A)\\n        res = 0\\n        for i, j in itertools.combinations_with_replacement(c, 2):\\n            k = target - i - j\\n            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\\n            elif i == j != k: res += c[i] * (c[i] - 1) / 2 * c[k]\\n            elif k > i and k > j: res += c[i] * c[j] * c[k]\\n        return res % (10**9 + 7)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "***Please Upvote if you Like it!***\\n\\nCount the occurrence of each number.\\nusing hashmap or array up to you.\\n\\nLoop i on all numbers,\\nloop j on all numbers,\\ncheck if k = target - i - j is valid.\\n\\nAdd the number of this combination to result.\\n3 cases covers all possible combination:\\n\\ni == j == k\\ni == j != k\\ni < k && j < k\\nTime Complexity:\\n3 <= A.length <= 3000, so N = 3000\\nBut 0 <= A[i] <= 100\\nSo my solution is O(N + 101 * 101)\\n\\nC++:\\n\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\nJava:\\n\\n    public int threeSumMulti(int[] A, int target) {\\n        long[] c = new long[101];\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (int i = 0; i <= 100; i++)\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k > 100 || k < 0) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return (int)(res % (1e9 + 7));\\n    }\\nPython:\\n\\n    def threeSumMulti(self, A, target):\\n        c = collections.Counter(A)\\n        res = 0\\n        for i, j in itertools.combinations_with_replacement(c, 2):\\n            k = target - i - j\\n            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\\n            elif i == j != k: res += c[i] * (c[i] - 1) / 2 * c[k]\\n            elif k > i and k > j: res += c[i] * c[j] * c[k]\\n        return res % (10**9 + 7)",
                "codeTag": "Python3"
            },
            {
                "id": 1919690,
                "title": "cpp-best-solution",
                "content": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1919657,
                "title": "dp-o-n-2-type-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        \\n        int n=arr.length;\\n        Set<Integer> keys = new HashSet<>();\\n        \\n        int dp[][] = new int[n+1][target+1];\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            keys.add(arr[i]);\\n        }\\n        \\n        for(int value:keys) {\\n            for(int i=arr.length-1;i>=0 && value<=target;i--) {\\n                int count = arr[i]==value?1:0;\\n                dp[i][value]=dp[i+1][value]+count;\\n            }\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                int sum=arr[i]+arr[j];\\n                if(sum>target) {\\n                    continue;\\n                }else {\\n                    int delta = target-sum;\\n                    count=(count+dp[j+1][delta])%1000000007;                    \\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        \\n        int n=arr.length;\\n        Set<Integer> keys = new HashSet<>();\\n        \\n        int dp[][] = new int[n+1][target+1];\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            keys.add(arr[i]);\\n        }\\n        \\n        for(int value:keys) {\\n            for(int i=arr.length-1;i>=0 && value<=target;i--) {\\n                int count = arr[i]==value?1:0;\\n                dp[i][value]=dp[i+1][value]+count;\\n            }\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                int sum=arr[i]+arr[j];\\n                if(sum>target) {\\n                    continue;\\n                }else {\\n                    int delta = target-sum;\\n                    count=(count+dp[j+1][delta])%1000000007;                    \\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919638,
                "title": "c-two-pointer-o-n-2-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++){\\n            int left=target-arr[i];\\n            if(left>=0){\\n                int s=i+1,e=arr.size()-1;\\n                while(s<e){\\n                    if((arr[s]+arr[e])==left){\\n                        int t1=0,t2=0,vals=arr[s],vale=arr[e];\\n                        int sk=s,ek=e;\\n                        if(vals==vale){\\n                            while(sk<=e&&arr[sk]==vals)\\n                            { t1++;sk++;}\\n                            res+=t1*(t1-1)/2;\\n                            s=sk;\\n                            \\n                        }\\n                        else{\\n                          while(sk<e&&arr[sk]==vals)\\n                            { t1++;sk++;}\\n\\n                          while(ek>s&&arr[ek]==vale)\\n                            {  t2++; ek--;}\\n\\n                            res+=t1*t2;\\n                            s=sk; e=ek;\\n                            \\n                        }\\n                        \\n                    }\\n                    else if(left<arr[e]+arr[s])\\n                        e--;\\n                    else if(left>arr[e]+arr[s]) s++;\\n                    \\n                }\\n            }\\n        }\\n        int mod=1000000007;\\n        int res2=res%mod;\\n        return res2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++){\\n            int left=target-arr[i];\\n            if(left>=0){\\n                int s=i+1,e=arr.size()-1;\\n                while(s<e){\\n                    if((arr[s]+arr[e])==left){\\n                        int t1=0,t2=0,vals=arr[s],vale=arr[e];\\n                        int sk=s,ek=e;\\n                        if(vals==vale){\\n                            while(sk<=e&&arr[sk]==vals)\\n                            { t1++;sk++;}\\n                            res+=t1*(t1-1)/2;\\n                            s=sk;\\n                            \\n                        }\\n                        else{\\n                          while(sk<e&&arr[sk]==vals)\\n                            { t1++;sk++;}\\n\\n                          while(ek>s&&arr[ek]==vale)\\n                            {  t2++; ek--;}\\n\\n                            res+=t1*t2;\\n                            s=sk; e=ek;\\n                            \\n                        }\\n                        \\n                    }\\n                    else if(left<arr[e]+arr[s])\\n                        e--;\\n                    else if(left>arr[e]+arr[s]) s++;\\n                    \\n                }\\n            }\\n        }\\n        int mod=1000000007;\\n        int res2=res%mod;\\n        return res2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919555,
                "title": "c-dynamic-programming-easy-pick-not-pick",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[3001][301][4];\\n    int F(vector<int>&arr,int target,int i,int n,int count){\\n        if(count == 0 and target == 0){\\n            return  1;\\n        }\\n        if(i == arr.size()){\\n            return 0;\\n        }\\n        if(count == 0 or target < 0){\\n            return 0;\\n        }\\n        if(dp[i][target][count] != -1){\\n            return dp[i][target][count];\\n        }\\n        int notPick = F(arr,target,i + 1,n,count);\\n        int Pick = arr[i] <= target ? F(arr,target - arr[i],i + 1,n,count - 1) : 0;\\n        return dp[i][target][count] = (notPick + Pick)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return F(arr,target,0,arr.size(),3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[3001][301][4];\\n    int F(vector<int>&arr,int target,int i,int n,int count){\\n        if(count == 0 and target == 0){\\n            return  1;\\n        }\\n        if(i == arr.size()){\\n            return 0;\\n        }\\n        if(count == 0 or target < 0){\\n            return 0;\\n        }\\n        if(dp[i][target][count] != -1){\\n            return dp[i][target][count];\\n        }\\n        int notPick = F(arr,target,i + 1,n,count);\\n        int Pick = arr[i] <= target ? F(arr,target - arr[i],i + 1,n,count - 1) : 0;\\n        return dp[i][target][count] = (notPick + Pick)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return F(arr,target,0,arr.size(),3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919527,
                "title": "kotlin-hashmap-solution-100-100",
                "content": "```\\nclass Solution {\\n    fun threeSumMulti(arr: IntArray, target: Int): Int {\\n        val MOD = 1_000_000_007\\n        val map = mutableMapOf<Int, Long>()\\n        \\n        for (num in arr) {\\n            map.put(num, map.getOrDefault(num, 0) + 1)\\n        }\\n        \\n        var ans: Long = 0\\n\\n        for (i in map.keys) {\\n            for (j in map.keys) {\\n                val k = target - i - j\\n                if (map.containsKey(k)) {\\n                    val ci: Long = map[i]!!\\n                    val cj: Long = map[j]!!\\n                    val ck: Long = map[k]!!\\n                    \\n                    if (i == j && j == k) {\\n                        ans += ci * (ci - 1) * (ci - 2) / 6\\n                    } else if (i == j) {\\n                        ans += ci * (ci - 1) / 2 * ck;\\n                    } else if (i < j && j < k) {\\n                        ans += ci * cj * ck\\n                    }\\n                    ans %= MOD\\n                }\\n            }\\n        }\\n        \\n        return ans.toInt()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun threeSumMulti(arr: IntArray, target: Int): Int {\\n        val MOD = 1_000_000_007\\n        val map = mutableMapOf<Int, Long>()\\n        \\n        for (num in arr) {\\n            map.put(num, map.getOrDefault(num, 0) + 1)\\n        }\\n        \\n        var ans: Long = 0\\n\\n        for (i in map.keys) {\\n            for (j in map.keys) {\\n                val k = target - i - j\\n                if (map.containsKey(k)) {\\n                    val ci: Long = map[i]!!\\n                    val cj: Long = map[j]!!\\n                    val ck: Long = map[k]!!\\n                    \\n                    if (i == j && j == k) {\\n                        ans += ci * (ci - 1) * (ci - 2) / 6\\n                    } else if (i == j) {\\n                        ans += ci * (ci - 1) / 2 * ck;\\n                    } else if (i < j && j < k) {\\n                        ans += ci * cj * ck\\n                    }\\n                    ans %= MOD\\n                }\\n            }\\n        }\\n        \\n        return ans.toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919499,
                "title": "c-3-solutions-w-w-o-sort-w-w-o-map-o-n-2-time",
                "content": "**Approach #1**\\n\\n```\\n    int threeSumMulti(vector<int>& a, int t) {\\n\\t\\n        int n=a.size();\\n        unordered_map<int,long> mp;\\n        int i,m=1e9+7;\\n        long c=0;\\n        \\n        for(i=0;i<n;i++)\\n            mp[a[i]]++;\\n        \\n        for(auto it1:mp)\\n        {\\n            if(it1.first>t)\\n                continue;\\n            \\n            for(auto it2:mp)\\n            {\\n                \\n                int x=it1.first;\\n                int y=it2.first;\\n                int z=t-x-y;\\n                \\n                if(mp.find(z)!=mp.end())\\n                {\\n                    if(x==y && y==z)\\n                        c+=mp[x]*(mp[x]-1)*(mp[x]-2)/6;\\n                    else if(x==y && y!=z)\\n                        c+=mp[x]*(mp[x]-1)/2*mp[z];\\n                    else if(x<y && y<z)\\n                        c+=mp[x]*mp[y]*mp[z];\\n                    \\n                    c=c%m;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```\\n\\n**Approach #2**\\n```\\n    int threeSumMulti(vector<int>& a, int t) \\n    {\\n        int n=a.size();\\n        unordered_map<int,long> mp;\\n        int i,j,m=1e9+7;\\n        long c=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            c+=mp[t-a[i]];\\n            \\n            for(j=0;j<i;j++)\\n                mp[a[i]+a[j]]++;\\n        }\\n        \\n        return c%m;\\n    }\\n```\\n\\n**Approach #3**\\n```\\n    int threeSumMulti(vector<int>& a, int t)\\n    {\\n        int n=a.size();\\n        int i,j,k;\\n        int m=1e9+7;\\n        long c=0;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            if(a[i]>t)\\n                break;\\n            \\n            if(i>0 && a[i]==a[i-1])\\n                continue;\\n            \\n            j=i+1;\\n            k=n-1;\\n            \\n            while(j<k)\\n            {\\n                int s=a[i]+a[j]+a[k];\\n                \\n                if(s<t)\\n                    j++;\\n                else if(s>t)\\n                    k--;\\n                else\\n                {\\n                    long c1=1,c2=1,c3=1;\\n                    \\n                    int i1=i;\\n                    while(i1<n-1 && a[i1]==a[i1+1])\\n                    {\\n                        i1++;\\n                        c1++;\\n                    }\\n                    \\n                    while(j<n-1 && a[j]==a[j+1])\\n                    {\\n                        j++;\\n                        c2++;\\n                    }\\n                    \\n                    while(k>j && a[k]==a[k-1])\\n                    {\\n                        k--;\\n                        c3++;\\n                    }\\n                    \\n                    if(a[i]==a[j] && a[j]==a[k])\\n                        c+=c1*(c1-1)*(c1-2)/6;\\n                    else if(a[i]==a[j])\\n                        c+=c1*(c1-1)/2*c3;\\n                    else if(a[j]==a[k])\\n                        c+=c1*c2*(c2-1)/2;\\n                    else\\n                        c+=c1*c2*c3;\\n                    \\n                    j++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return c%m;\\n    }\\n```\\n\\n**Do share your views && upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\n    int threeSumMulti(vector<int>& a, int t) {\\n\\t\\n        int n=a.size();\\n        unordered_map<int,long> mp;\\n        int i,m=1e9+7;\\n        long c=0;\\n        \\n        for(i=0;i<n;i++)\\n            mp[a[i]]++;\\n        \\n        for(auto it1:mp)\\n        {\\n            if(it1.first>t)\\n                continue;\\n            \\n            for(auto it2:mp)\\n            {\\n                \\n                int x=it1.first;\\n                int y=it2.first;\\n                int z=t-x-y;\\n                \\n                if(mp.find(z)!=mp.end())\\n                {\\n                    if(x==y && y==z)\\n                        c+=mp[x]*(mp[x]-1)*(mp[x]-2)/6;\\n                    else if(x==y && y!=z)\\n                        c+=mp[x]*(mp[x]-1)/2*mp[z];\\n                    else if(x<y && y<z)\\n                        c+=mp[x]*mp[y]*mp[z];\\n                    \\n                    c=c%m;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```\n```\\n    int threeSumMulti(vector<int>& a, int t) \\n    {\\n        int n=a.size();\\n        unordered_map<int,long> mp;\\n        int i,j,m=1e9+7;\\n        long c=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            c+=mp[t-a[i]];\\n            \\n            for(j=0;j<i;j++)\\n                mp[a[i]+a[j]]++;\\n        }\\n        \\n        return c%m;\\n    }\\n```\n```\\n    int threeSumMulti(vector<int>& a, int t)\\n    {\\n        int n=a.size();\\n        int i,j,k;\\n        int m=1e9+7;\\n        long c=0;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            if(a[i]>t)\\n                break;\\n            \\n            if(i>0 && a[i]==a[i-1])\\n                continue;\\n            \\n            j=i+1;\\n            k=n-1;\\n            \\n            while(j<k)\\n            {\\n                int s=a[i]+a[j]+a[k];\\n                \\n                if(s<t)\\n                    j++;\\n                else if(s>t)\\n                    k--;\\n                else\\n                {\\n                    long c1=1,c2=1,c3=1;\\n                    \\n                    int i1=i;\\n                    while(i1<n-1 && a[i1]==a[i1+1])\\n                    {\\n                        i1++;\\n                        c1++;\\n                    }\\n                    \\n                    while(j<n-1 && a[j]==a[j+1])\\n                    {\\n                        j++;\\n                        c2++;\\n                    }\\n                    \\n                    while(k>j && a[k]==a[k-1])\\n                    {\\n                        k--;\\n                        c3++;\\n                    }\\n                    \\n                    if(a[i]==a[j] && a[j]==a[k])\\n                        c+=c1*(c1-1)*(c1-2)/6;\\n                    else if(a[i]==a[j])\\n                        c+=c1*(c1-1)/2*c3;\\n                    else if(a[j]==a[k])\\n                        c+=c1*c2*(c2-1)/2;\\n                    else\\n                        c+=c1*c2*c3;\\n                    \\n                    j++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return c%m;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919447,
                "title": "c-solution-modification-of-3-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size(), cnt = 0, cnt1, cnt2, val, k, left, right;\\n        long mod = 1e9+7;\\n        sort(arr.begin(),arr.end());\\n        for(int i = 0; i < n; ++i)\\n        {\\n            val = arr[i], k = target-val;\\n            left = i+1,right = n-1;\\n            while(left < right)\\n            {\\n                if(arr[left]+arr[right] == k)\\n                {\\n                    cnt1 = 1, cnt2 = 1;\\n                    while(left < right && arr[left] == arr[left+1]) \\n                    {\\n                        left++;\\n                        cnt1++;\\n                    }\\n                    while(left < right && arr[right-1] == arr[right])\\n                    {\\n                        right--;\\n                        cnt2++;\\n                    } \\n                    if(left == right)\\n                    {\\n                        cnt = (cnt%mod+(cnt1%mod*(cnt1-1)%mod)/2)%mod;\\n                    }\\n                    else if(left != right)\\n                    {\\n                        cnt = (cnt%mod+(cnt1%mod*cnt2%mod)%mod)%mod;\\n                    }\\n                    left++;\\n                    right--;\\n                }\\n                else if(arr[left]+arr[right] > k) \\n                    right--;\\n                else if(arr[left]+arr[right] < k) \\n                    left++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size(), cnt = 0, cnt1, cnt2, val, k, left, right;\\n        long mod = 1e9+7;\\n        sort(arr.begin(),arr.end());\\n        for(int i = 0; i < n; ++i)\\n        {\\n            val = arr[i], k = target-val;\\n            left = i+1,right = n-1;\\n            while(left < right)\\n            {\\n                if(arr[left]+arr[right] == k)\\n                {\\n                    cnt1 = 1, cnt2 = 1;\\n                    while(left < right && arr[left] == arr[left+1]) \\n                    {\\n                        left++;\\n                        cnt1++;\\n                    }\\n                    while(left < right && arr[right-1] == arr[right])\\n                    {\\n                        right--;\\n                        cnt2++;\\n                    } \\n                    if(left == right)\\n                    {\\n                        cnt = (cnt%mod+(cnt1%mod*(cnt1-1)%mod)/2)%mod;\\n                    }\\n                    else if(left != right)\\n                    {\\n                        cnt = (cnt%mod+(cnt1%mod*cnt2%mod)%mod)%mod;\\n                    }\\n                    left++;\\n                    right--;\\n                }\\n                else if(arr[left]+arr[right] > k) \\n                    right--;\\n                else if(arr[left]+arr[right] < k) \\n                    left++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919251,
                "title": "why-not-working-o-n-2logn",
                "content": "please! someone crack it...I shoud work on O(n^2logn)\\n```\\nclass Solution {\\npublic:\\n    int countGreater(vector<int>& arr, int n, int k){\\n        int l = 0;\\n        int r = n - 1;\\n        int leftGreater = n;\\n        while (l <= r) {\\n            int m = (r + l) / 2;\\n            if (arr[m] > k) {\\n                leftGreater = m;\\n                r = m - 1;\\n            }\\n            else\\n                l = m + 1;\\n        }\\n \\n        return (n - leftGreater);\\n    } \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,vector<int>> d;\\n        for(int i=0;i<n;i++)\\n            d[arr[i]].push_back(i);\\n        int ans=0;\\n        for(int i=0;i<n-2;i++)\\n            for(int j=i+1;j<n-1;j++){\\n                int bal=target-arr[i]-arr[j];\\n                ans=(ans+countGreater(d[bal],d[bal].size(),j))%1000000007;\\n            }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int countGreater(vector<int>& arr, int n, int k){\\n        int l = 0;\\n        int r = n - 1;\\n        int leftGreater = n;\\n        while (l <= r) {\\n            int m = (r + l) / 2;\\n            if (arr[m] > k) {\\n                leftGreater = m;\\n                r = m - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1919191,
                "title": "simple-solution-no-sorting-no-combination-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int N = arr.size(), ans = 0, MOD = 1\\'000\\'000\\'007;\\n        unordered_map<int, int> m;\\n        for(int i = 0; i < N; ++i){\\n            for(int j = i + 1; j < N; ++j){\\n                int subtarget = target - (arr[i] + arr[j]);\\n                if(m.count(subtarget)){\\n                    ans = (ans + m[subtarget]) % MOD;\\n                }\\n            }\\n            ++m[arr[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int N = arr.size(), ans = 0, MOD = 1\\'000\\'000\\'007;\\n        unordered_map<int, int> m;\\n        for(int i = 0; i < N; ++i){\\n            for(int j = i + 1; j < N; ++j){\\n                int subtarget = target - (arr[i] + arr[j]);\\n                if(m.count(subtarget)){\\n                    ans = (ans + m[subtarget]) % MOD;\\n                }\\n            }\\n            ++m[arr[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919162,
                "title": "java-solution-highly-commented-easy-understanding",
                "content": "```\\n public int threeSumMulti(int[] arr, int target) {\\n       \\n    long[] freq = new long[101];  //This is freq array since number lies from [1,100]\\n        int max = 0;\\n        for (int a : arr) {\\n            freq[a]++;\\n            max = Math.max(max,a);\\n        }\\n        \\n        long ans = 0;\\n        for (int i = 0; i <= max; i++)\\n            for (int j = i; j <= max; j++) {\\n                \\n                int k = target - i - j;  //as (i+j+k==target)\\n                \\n                if(k<0 || k>100)  //to avoid index out of bound in freqArray\\n                    continue;\\n                \\n    /*nC3 (as all same numbers able to meet the target \\n\\tEx: arr [1,1,1,1,1,1,1] , target=3)  Case:{1,1,1} */\\n\\t\\n           if (i == j && j == k)  \\n    ans += freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6; \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t//after simplyfying nc3 you will get this \\n                \\n /*nC2 (as one number is different and 2 are same in contributing to achieve the \\n target Ex: [1,1,1,1,1,2,2,2,2], target = 5) Case:{1,2,2}*/\\n                \\n                else if (i == j && j != k)   \\n            ans += freq[i] * (freq[i] - 1) / 2 * freq[k];  \\n\\t\\t\\t\\n\\t//after simplfying nc2 you will get this * different ones freq have to multiply\\n                \\n/*nC1 (as all number are different in contributing to achieving the target \\nEx: [1,1,1,1,1,3,3,3,4,4,4,4], target=8)  Case:{1,3,4}\\nalso why i am writing this condition (i < j && j < k) because so that you don\\'t add \\nmore answers for cases like permuation of {2,3,4} -> {2,4,3} you just have \\nto add once only*/\\n\\n                else if (i<j && j < k)    \\n                    ans += freq[i] * freq[j] * freq[k];   //after simplfying nc1 you will get this\\n            }\\n        \\n        return (int)(ans % (1e9 + 7));  // taking modulo as mentioned in question\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n public int threeSumMulti(int[] arr, int target) {\\n       \\n    long[] freq = new long[101];  //This is freq array since number lies from [1,100]\\n        int max = 0;\\n        for (int a : arr) {\\n            freq[a]++;\\n            max = Math.max(max,a);\\n        }\\n        \\n        long ans = 0;\\n        for (int i = 0; i <= max; i++)\\n            for (int j = i; j <= max; j++) {\\n                \\n                int k = target - i - j;  //as (i+j+k==target)\\n                \\n                if(k<0 || k>100)  //to avoid index out of bound in freqArray\\n                    continue;\\n                \\n    /*nC3 (as all same numbers able to meet the target \\n\\tEx: arr [1,1,1,1,1,1,1] , target=3)  Case:{1,1,1} */\\n\\t\\n           if (i == j && j == k)  \\n    ans += freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6; \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t//after simplyfying nc3 you will get this \\n                \\n /*nC2 (as one number is different and 2 are same in contributing to achieve the \\n target Ex: [1,1,1,1,1,2,2,2,2], target = 5) Case:{1,2,2}*/\\n                \\n                else if (i == j && j != k)   \\n            ans += freq[i] * (freq[i] - 1) / 2 * freq[k];  \\n\\t\\t\\t\\n\\t//after simplfying nc2 you will get this * different ones freq have to multiply\\n                \\n/*nC1 (as all number are different in contributing to achieving the target \\nEx: [1,1,1,1,1,3,3,3,4,4,4,4], target=8)  Case:{1,3,4}\\nalso why i am writing this condition (i < j && j < k) because so that you don\\'t add \\nmore answers for cases like permuation of {2,3,4} -> {2,4,3} you just have \\nto add once only*/\\n\\n                else if (i<j && j < k)    \\n                    ans += freq[i] * freq[j] * freq[k];   //after simplfying nc1 you will get this\\n            }\\n        \\n        return (int)(ans % (1e9 + 7));  // taking modulo as mentioned in question\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919148,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>&A, int t) {\\n        int n = A.size();\\n        sort(A.begin(),A.end());\\n        int total = 0; \\n        int i = 0;\\n        int mod = 1e9 + 7;\\n        while(i < n - 2)\\n        {\\n            int l = i + 1;\\n            int r = n - 1;\\n            while(l < r)\\n            {\\n                int sum = A[i] + A[l] + A[r];\\n                if(sum == t)\\n                {\\n                    if(A[l] == A[r])\\n                    {\\n                        int n1 = r - l + 1;\\n                        total += ((n1) * (n1 - 1)) / 2;\\n                        total %= mod;\\n                        break;\\n                    }\\n                    l++;\\n                    r--;\\n                    int cl = 1;\\n                    int cr = 1;\\n                    \\n                    while(l <=  r and A[l] == A[l - 1])\\n                    {\\n                        l++;\\n                        cl++;\\n                    }\\n                    while(l <= r and A[r] == A[r + 1])\\n                    {\\n                        r--;\\n                        cr++;\\n                    } \\n                    total += cr * cl;\\n                    total %= mod;\\n                    \\n                }\\n                else if(sum > t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            i++;\\n        }\\n        return total;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>&A, int t) {\\n        int n = A.size();\\n        sort(A.begin(),A.end());\\n        int total = 0; \\n        int i = 0;\\n        int mod = 1e9 + 7;\\n        while(i < n - 2)\\n        {\\n            int l = i + 1;\\n            int r = n - 1;\\n            while(l < r)\\n            {\\n                int sum = A[i] + A[l] + A[r];\\n                if(sum == t)\\n                {\\n                    if(A[l] == A[r])\\n                    {\\n                        int n1 = r - l + 1;\\n                        total += ((n1) * (n1 - 1)) / 2;\\n                        total %= mod;\\n                        break;\\n                    }\\n                    l++;\\n                    r--;\\n                    int cl = 1;\\n                    int cr = 1;\\n                    \\n                    while(l <=  r and A[l] == A[l - 1])\\n                    {\\n                        l++;\\n                        cl++;\\n                    }\\n                    while(l <= r and A[r] == A[r + 1])\\n                    {\\n                        r--;\\n                        cr++;\\n                    } \\n                    total += cr * cl;\\n                    total %= mod;\\n                    \\n                }\\n                else if(sum > t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            i++;\\n        }\\n        return total;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919138,
                "title": "clean-simple-short-code-with-explanation-and-code-comments-o-n-2-tc-o-n-sc",
                "content": "**IDEA** : populate the hashmap with the `[number,frequency_of_number]` and in every loop we try to find `j` in the hashmap (`i` and `k` are pointed by the for loop pointers). Note that the loop direction is used as right to left to ensure the ordering of elements is i < j < k . \\n\\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        \\n        Map<Integer,Integer>hm = new HashMap<>();\\n        long count=0;\\n\\t\\t// so if the code is at a position as shown - then we try to find `j` in map (which is = { {2:3} , {5:1} , {1:1} , {4:1})\\n                                              //           (i)                  (k)\\n        for(int k=arr.length-1;k>=0;k--){     // [ 1 ,2, 2, 3, 4, 5, 2, 1, 2, 2, 7, 3 , 4]\\n            hm.clear();\\n            for(int i=k-1;i>=0;i--){\\n                int toFind = target-arr[k]-arr[i];\\n                if(hm.containsKey(toFind))\\n                    count=(count + hm.get(toFind))%1000000007;\\n                hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\\n            }\\n        }\\n        \\n        return (int)count;\\n}\\n\\t\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        \\n        Map<Integer,Integer>hm = new HashMap<>();\\n        long count=0;\\n\\t\\t// so if the code is at a position as shown - then we try to find `j` in map (which is = { {2:3} , {5:1} , {1:1} , {4:1})\\n                                              //           (i)                  (k)\\n        for(int k=arr.length-1;k>=0;k--){     // [ 1 ,2, 2, 3, 4, 5, 2, 1, 2, 2, 7, 3 , 4]\\n            hm.clear();\\n            for(int i=k-1;i>=0;i--){\\n                int toFind = target-arr[k]-arr[i];\\n                if(hm.containsKey(toFind))\\n                    count=(count + hm.get(toFind))%1000000007;\\n                hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\\n            }\\n        }\\n        \\n        return (int)count;\\n}\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919098,
                "title": "three-pointer-approach-with-comments-for-understanding",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        \\n        //answer is long bcz we may cross beyond int value range limit\\n        long answer = 0;\\n        \\n        //mod is used here as per question to avoid answer overflow\\n        long mod = 1000000007;\\n        Arrays.sort(arr);\\n        \\n        //We are using 3 pointer technique here, take 1st element subtract with target and\\n        //do a two pointer approach to find the triplet with new target to find (target-arr[i]) \\n        \\n        for(int i=0;i<arr.length;i++){\\n            \\n            //value to find after subtracting\\n            int findValue = target - arr[i];\\n            \\n            //we started with i, so our range should start from i+1\\n            int j = i+1;\\n            int k = arr.length-1;\\n            \\n            while(j<k){\\n                \\n                //move pointers based on sum value\\n                if(arr[j]+arr[k]<findValue)\\n                    j++;\\n                \\n                else if(arr[j]+arr[k]>findValue)\\n                    k--;\\n                \\n                //if sum equals to target, check whether both values are same or not\\n                else if(arr[j]!=arr[k]){\\n                    \\n                    //if not, lets start counting whether there are duplicates of a[j] && a[k]\\n                    int leftNumCount = 1, rightNumCount=1;\\n                    \\n                    \\n                    //count leftNum a[j]\\n                    while(j+1<k && arr[j]==arr[j+1]){\\n                        leftNumCount++;\\n                        j++;\\n                    }\\n                    \\n                    ////count rightNum a[k]\\n                    while(k-1>j && arr[k]==arr[k-1]){\\n                        rightNumCount++;\\n                        k--;\\n                    }\\n                    \\n                    //calculate the answer and find mod of it as per question\\n                    answer = answer + (rightNumCount * leftNumCount);\\n                    answer = answer%mod;\\n                    \\n                    //move both pointers\\n                    j++;\\n                    k--;\\n                }\\n                \\n                //if both values are same, available combination should be\\n                // n*(n+1)/2\\n                // here n is (k-j)\\n                else\\n                {\\n                    answer = answer + (k-j)*(k-j+1)/2;\\n                    answer = answer%mod;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int) answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        \\n        //answer is long bcz we may cross beyond int value range limit\\n        long answer = 0;\\n        \\n        //mod is used here as per question to avoid answer overflow\\n        long mod = 1000000007;\\n        Arrays.sort(arr);\\n        \\n        //We are using 3 pointer technique here, take 1st element subtract with target and\\n        //do a two pointer approach to find the triplet with new target to find (target-arr[i]) \\n        \\n        for(int i=0;i<arr.length;i++){\\n            \\n            //value to find after subtracting\\n            int findValue = target - arr[i];\\n            \\n            //we started with i, so our range should start from i+1\\n            int j = i+1;\\n            int k = arr.length-1;\\n            \\n            while(j<k){\\n                \\n                //move pointers based on sum value\\n                if(arr[j]+arr[k]<findValue)\\n                    j++;\\n                \\n                else if(arr[j]+arr[k]>findValue)\\n                    k--;\\n                \\n                //if sum equals to target, check whether both values are same or not\\n                else if(arr[j]!=arr[k]){\\n                    \\n                    //if not, lets start counting whether there are duplicates of a[j] && a[k]\\n                    int leftNumCount = 1, rightNumCount=1;\\n                    \\n                    \\n                    //count leftNum a[j]\\n                    while(j+1<k && arr[j]==arr[j+1]){\\n                        leftNumCount++;\\n                        j++;\\n                    }\\n                    \\n                    ////count rightNum a[k]\\n                    while(k-1>j && arr[k]==arr[k-1]){\\n                        rightNumCount++;\\n                        k--;\\n                    }\\n                    \\n                    //calculate the answer and find mod of it as per question\\n                    answer = answer + (rightNumCount * leftNumCount);\\n                    answer = answer%mod;\\n                    \\n                    //move both pointers\\n                    j++;\\n                    k--;\\n                }\\n                \\n                //if both values are same, available combination should be\\n                // n*(n+1)/2\\n                // here n is (k-j)\\n                else\\n                {\\n                    answer = answer + (k-j)*(k-j+1)/2;\\n                    answer = answer%mod;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int) answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919044,
                "title": "easy-and-simple-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumMulti = function(arr, target) {\\n    let count=0\\n    arr.sort((a,b)=>a-b)\\n    for(let i=0;i<arr.length-2;i++){\\n        let j=i+1,k=arr.length-1\\n        while(j<k){\\n            let sum=arr[i]+arr[j]+arr[k]\\n            if(sum<target){\\n                j++\\n            }\\n            else if(sum>target){\\n                k--\\n            }\\n            else{\\n                if(arr[j]!==arr[k]){\\n                    let j1=j,k1=k\\n                    while(arr[j]===arr[j1]){\\n                        j1++\\n                    }\\n                    while(arr[k]===arr[k1]){\\n                        k1--\\n                    }\\n                    count+=((j1-j)*(k-k1))\\n                    j=j1\\n                    k=k1 \\n                }\\n                else{\\n                    for(let n=1;n<=k-j;n++){\\n                        count+=n\\n                    }\\n                    break\\n                }              \\n            }\\n        }\\n    }\\n    return count% (10**9 + 7)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumMulti = function(arr, target) {\\n    let count=0\\n    arr.sort((a,b)=>a-b)\\n    for(let i=0;i<arr.length-2;i++){\\n        let j=i+1,k=arr.length-1\\n        while(j<k){\\n            let sum=arr[i]+arr[j]+arr[k]\\n            if(sum<target){\\n                j++\\n            }\\n            else if(sum>target){\\n                k--\\n            }\\n            else{\\n                if(arr[j]!==arr[k]){\\n                    let j1=j,k1=k\\n                    while(arr[j]===arr[j1]){\\n                        j1++\\n                    }\\n                    while(arr[k]===arr[k1]){\\n                        k1--\\n                    }\\n                    count+=((j1-j)*(k-k1))\\n                    j=j1\\n                    k=k1 \\n                }\\n                else{\\n                    for(let n=1;n<=k-j;n++){\\n                        count+=n\\n                    }\\n                    break\\n                }              \\n            }\\n        }\\n    }\\n    return count% (10**9 + 7)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919004,
                "title": "java-easy-solution-in-o-n",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t//Couting the occurrence of each number\\n        for(int i: arr) count[i]++;\\n        \\n        for(int i=0;i<101;i++){\\n            for(int j=i;j<101;j++){\\n                int k = target - i -j;\\n                if(k<0 || k>100)\\n                    continue;\\n\\t\\t\\t\\t// if all number are same than use nC3\\n                if(i==j && j==k){\\n                    result += (count[i]*(count[i]-1)*(count[i]-2))/6;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if first two are same than use nC2 * occurence of k\\n                else if(i==j && j!=k){\\n                    result += ((count[i]*(count[i]-1))/2)*count[k];\\n                }\\n\\t\\t\\t\\t//Last condition if all number ar different\\n\\t\\t\\t\\telse if(i<j && j<k){\\n                    result += (count[i]*count[j]*count[k]);\\n                }\\n                result %= mod;\\n            }\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t//Couting the occurrence of each number\\n        for(int i: arr) count[i]++;\\n        \\n        for(int i=0;i<101;i++){\\n            for(int j=i;j<101;j++){\\n                int k = target - i -j;\\n                if(k<0 || k>100)\\n                    continue;\\n\\t\\t\\t\\t// if all number are same than use nC3\\n                if(i==j && j==k){\\n                    result += (count[i]*(count[i]-1)*(count[i]-2))/6;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if first two are same than use nC2 * occurence of k\\n                else if(i==j && j!=k){\\n                    result += ((count[i]*(count[i]-1))/2)*count[k];\\n                }\\n\\t\\t\\t\\t//Last condition if all number ar different\\n\\t\\t\\t\\telse if(i<j && j<k){\\n                    result += (count[i]*count[j]*count[k]);\\n                }\\n                result %= mod;\\n            }\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919002,
                "title": "python-3sum-tweak-o-1-space",
                "content": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        count = 0\\n        for i in range(len(arr)-2):\\n            low = i+1\\n            high = len(arr)-1\\n            while(low<high):\\n                cur = arr[i] + arr[low] + arr[high]\\n                if(cur==target):\\n                    if(arr[low]!=arr[high]):\\n                        multi_i = 1\\n                        multi_j = 1\\n                        while(low+1<high and arr[low]==arr[low+1]):\\n                            multi_i += 1\\n                            low += 1\\n                        while(low<high-1 and arr[high]==arr[high-1]):\\n                            multi_j += 1\\n                            high -= 1\\n                        count += (multi_i*multi_j) \\n                    else:\\n                        rep = high-low\\n                        count += (rep*(rep+1))//2\\n                        break\\n                    low+=1\\n                    high-=1\\n                elif(cur<target):\\n                    low+=1\\n                else:\\n                    high-=1\\n        return count%(10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        count = 0\\n        for i in range(len(arr)-2):\\n            low = i+1\\n            high = len(arr)-1\\n            while(low<high):\\n                cur = arr[i] + arr[low] + arr[high]\\n                if(cur==target):\\n                    if(arr[low]!=arr[high]):\\n                        multi_i = 1\\n                        multi_j = 1\\n                        while(low+1<high and arr[low]==arr[low+1]):\\n                            multi_i += 1\\n                            low += 1\\n                        while(low<high-1 and arr[high]==arr[high-1]):\\n                            multi_j += 1\\n                            high -= 1\\n                        count += (multi_i*multi_j) \\n                    else:\\n                        rep = high-low\\n                        count += (rep*(rep+1))//2\\n                        break\\n                    low+=1\\n                    high-=1\\n                elif(cur<target):\\n                    low+=1\\n                else:\\n                    high-=1\\n        return count%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918988,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\npublic int threeSumMulti(int[] a, int t) {\\n        long b[]=new long[101];\\n        for(int k:a)\\n        {\\n            b[k]++;\\n        }\\n        long c=0,s=1000000007;\\n        for(int i=0;i<=100;i++)\\n        {\\n            for(int j=i;j<=100;j++)\\n            {\\n                int k=t-i-j;\\n                if(k<0||k>100)\\n                    continue;\\n                if(i==j&&j==k)\\n                {\\n                    c+=b[i]*(b[i]-1)*(b[i]-2)/6;\\n                }\\n                else if(i==j&&j!=k)\\n                {\\n                    c+=b[i]*(b[i]-1)/2*b[k];\\n                }\\n                else if(i<j&&j<k)\\n                {\\n                    c+=b[i]*b[j]*b[k];\\n                }\\n            }\\n        }\\n        return (int)(c%s);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "class Solution {\\npublic int threeSumMulti(int[] a, int t) {\\n        long b[]=new long[101];\\n        for(int k:a)\\n        {\\n            b[k]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1918974,
                "title": "comprehensive-explanation-in-comments-c-two-pointer-approach",
                "content": "Comments are sometimes the best way to understand a program, as they explain just what each line in the program does.\\n\\nHere, we use \\n* the [Two Pointers](https://leetcode.com/tag/two-pointers/) technique (used in [Two Sum problem](https://leetcode.com/problems/two-sum/)) \\n* to solve this Three Sum problem\\n* while taking care of duplicates!\\n\\n**C++ solution:**\\n\\n**1. With comments:**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n\\t\\t// Can\\'t make a 3-sum with less than two numbers \\uD83D\\uDE05 \\n        if (n <= 2) return -1;\\n        \\n        // A neat trick to write numbers with seperator\\n        // is to use a tick (\\') between digits\\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        \\n        // sort it, so that we can apply our \\n\\t\\t// binary-search inspired two-pointers technique\\n        sort(arr.begin(), arr.end());\\n        \\n        // Binary search works for 2-sum problems\\n        // So how do we handle 3-sum problem ?\\n        // the *third-sum* integer is basically hidden in the target\\n        // because the new target is target - c\\n        // given that target = a + b + c\\n        // Now we only need to find a and b to satisfy\\n        // a + b = target - c\\n        // So here we go\\n        for (int i = 0; i < n; i++) {\\n            \\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n            \\n            // once we find our target T\\n            // the problem has been reduced to 2-sum problem\\n            // But lookout for unique cases!\\n            // because this is not just a 3-sum problem, \\n            // it\\'s a 3-sum with multiplicity problem,\\n            // which means there are multiple numbers which can give a 3-sum\\n            // also the numbers could be repeated, so we gotta handle that too!\\n            // Don\\'t worry though, there are just 4 cases:\\n            while (j < k) {\\n                \\n                // CASE 1\\uFE0F\\u20E3:\\n                // a + b < target - c\\n                // --OR--\\n                // a + b < T\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                \\n                // CASE 2\\uFE0F\\u20E3:\\n                // a + b > target - c\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                \\n                // CASE 3\\uFE0F\\u20E3:\\n                // a + b = target - c (Hurray!)\\n                // BUT! a != b\\n                // Also, since duplicate numbers are present, \\n                // we need to count the duplicates a and b too\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    \\n                    // count duplicate \\'a\\'s\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    \\n                    // count duplicate \\'b\\'s\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    \\n                    // the total number of \\'a\\'s and \\'b\\'s which\\n                    // add up to \\'target-c\\' is equal to\\n                    // number_of_a * number_of_b\\n                    ans += left*right;\\n                    // MOD as per the question\\'s requirement\\n                    ans %= MOD;\\n                    j++;\\n                    k--;\\n                }\\n                \\n                // CASE 4\\uFE0F\\u20E3:\\n                // a + b = target - c (Hurray again!)\\n                // BUT! a = b\\n                // so we got to find how many times we can use\\n                // the duplicates a (or b) to get the sum \\'target-c\\'\\n                else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    \\n                    // break, because all combinations between j and k \\n                    // have been tried\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```\\n\\n<br>\\n\\n**2. Without comments:**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        if (n <= 2) return -1;\\n        \\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n\\n            while (j < k) {\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    ans += left*right;\\n                    ans %= MOD;\\n                    j++, k--;\\n                } else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```\\n\\n<br>\\n\\nTime complexity: **O(n<sup>2</sup>)**\\nSpace complexity: **O(1)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n\\t\\t// Can\\'t make a 3-sum with less than two numbers \\uD83D\\uDE05 \\n        if (n <= 2) return -1;\\n        \\n        // A neat trick to write numbers with seperator\\n        // is to use a tick (\\') between digits\\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        \\n        // sort it, so that we can apply our \\n\\t\\t// binary-search inspired two-pointers technique\\n        sort(arr.begin(), arr.end());\\n        \\n        // Binary search works for 2-sum problems\\n        // So how do we handle 3-sum problem ?\\n        // the *third-sum* integer is basically hidden in the target\\n        // because the new target is target - c\\n        // given that target = a + b + c\\n        // Now we only need to find a and b to satisfy\\n        // a + b = target - c\\n        // So here we go\\n        for (int i = 0; i < n; i++) {\\n            \\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n            \\n            // once we find our target T\\n            // the problem has been reduced to 2-sum problem\\n            // But lookout for unique cases!\\n            // because this is not just a 3-sum problem, \\n            // it\\'s a 3-sum with multiplicity problem,\\n            // which means there are multiple numbers which can give a 3-sum\\n            // also the numbers could be repeated, so we gotta handle that too!\\n            // Don\\'t worry though, there are just 4 cases:\\n            while (j < k) {\\n                \\n                // CASE 1\\uFE0F\\u20E3:\\n                // a + b < target - c\\n                // --OR--\\n                // a + b < T\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                \\n                // CASE 2\\uFE0F\\u20E3:\\n                // a + b > target - c\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                \\n                // CASE 3\\uFE0F\\u20E3:\\n                // a + b = target - c (Hurray!)\\n                // BUT! a != b\\n                // Also, since duplicate numbers are present, \\n                // we need to count the duplicates a and b too\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    \\n                    // count duplicate \\'a\\'s\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    \\n                    // count duplicate \\'b\\'s\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    \\n                    // the total number of \\'a\\'s and \\'b\\'s which\\n                    // add up to \\'target-c\\' is equal to\\n                    // number_of_a * number_of_b\\n                    ans += left*right;\\n                    // MOD as per the question\\'s requirement\\n                    ans %= MOD;\\n                    j++;\\n                    k--;\\n                }\\n                \\n                // CASE 4\\uFE0F\\u20E3:\\n                // a + b = target - c (Hurray again!)\\n                // BUT! a = b\\n                // so we got to find how many times we can use\\n                // the duplicates a (or b) to get the sum \\'target-c\\'\\n                else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    \\n                    // break, because all combinations between j and k \\n                    // have been tried\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        if (n <= 2) return -1;\\n        \\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n\\n            while (j < k) {\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    ans += left*right;\\n                    ans %= MOD;\\n                    j++, k--;\\n                } else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918954,
                "title": "simple-and-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int MOD = 1e9+7;\\n        long ans = 0;\\n        vector<long> count(101, 0);\\n        for (int x : arr)    count[x]++;\\n\\n        for (int i = 0; i <= 100; i++) {\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k < 0 || k > 100)    continue;\\n                else if (i == j && j == k)        ans += (count[i] * (count[i] - 1) * (count[i] - 2) / 6);\\n                else if (i == j && j != k)   ans += ((count[i] * (count[i] - 1) / 2) * count[k]);\\n                else if (i < j && j < k)     ans += (count[i] * count[j] * count[k]);\\n            }\\n        }\\n        return (int)(ans % MOD);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int MOD = 1e9+7;\\n        long ans = 0;\\n        vector<long> count(101, 0);\\n        for (int x : arr)    count[x]++;\\n\\n        for (int i = 0; i <= 100; i++) {\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k < 0 || k > 100)    continue;\\n                else if (i == j && j == k)        ans += (count[i] * (count[i] - 1) * (count[i] - 2) / 6);\\n                else if (i == j && j != k)   ans += ((count[i] * (count[i] - 1) / 2) * count[k]);\\n                else if (i < j && j < k)     ans += (count[i] * count[j] * count[k]);\\n            }\\n        }\\n        return (int)(ans % MOD);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918944,
                "title": "why-getting-tle",
                "content": "I am experiencing this 4th time while problem solving that as per constraints my solution should pass but after submission it shows **TLE** for some cases.\\n\\nWeird thing is like it gives **TLE** on different cases after every new submission and on running code on those test cases in sample one it passes.\\n\\n**Plssss let me know if I am wrong in my observation of complexities of my soln.**\\n\\nBelow code for this problem :\\n\\n**Time Complexity (as per my inderstanding) : O(n^2*log(n))**\\n**and constraint is n <= 10^3**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        // unordered_map<int,int> mp;\\n        int res = 0;\\n        int mod = 1e9+7;\\n        sort(arr.begin(), arr.end());\\n        \\n        // for(auto x : arr)\\n        //     mp[x]++;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int k = arr[i] + arr[j];\\n                int rq = target-k;\\n                \\n                int lb = lower_bound(arr.begin(), arr.end(), rq) - arr.begin();\\n                int ub = upper_bound(arr.begin(), arr.end(), rq) - arr.begin();\\n                \\n                if(lb == n)\\n                    continue;\\n                \\n                if(lb <= j)\\n                {\\n                    if(j < n-1 && arr[j+1] == rq)\\n                        lb = j+1;\\n                    else \\n                        continue;\\n                }\\n                \\n                res = (res%mod + (ub-lb)%mod)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        // unordered_map<int,int> mp;\\n        int res = 0;\\n        int mod = 1e9+7;\\n        sort(arr.begin(), arr.end());\\n        \\n        // for(auto x : arr)\\n        //     mp[x]++;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int k = arr[i] + arr[j];\\n                int rq = target-k;\\n                \\n                int lb = lower_bound(arr.begin(), arr.end(), rq) - arr.begin();\\n                int ub = upper_bound(arr.begin(), arr.end(), rq) - arr.begin();\\n                \\n                if(lb == n)\\n                    continue;\\n                \\n                if(lb <= j)\\n                {\\n                    if(j < n-1 && arr[j+1] == rq)\\n                        lb = j+1;\\n                    else \\n                        continue;\\n                }\\n                \\n                res = (res%mod + (ub-lb)%mod)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918917,
                "title": "java-o-n-2-solution",
                "content": "\\n\\n        \\n        int mod=1000000007;\\n        long ans=0;\\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            int j=i+1,k=arr.length-1;\\n            while(j<k)\\n            {\\n                int tmp=arr[i]+arr[j]+arr[k];\\n                if(tmp==target)\\n                {\\n                    if(arr[j]==arr[k])\\n                    {\\n                        int n=k-j+1;\\n                        int m=n*(n-1);\\n                        m/=2;\\n                        ans+=m;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        int re=0,le=0,n=arr[j],m=arr[k];\\n                        while(j<=k &&arr[j]==n)\\n                        {\\n                            le++;\\n                            j++;\\n                        }\\n                        while(k>=j && m==arr[k])\\n                        {\\n                            re++;\\n                            k--;\\n                        }\\n                        int tmpans=re*le;\\n                        ans+=tmpans;\\n                    }\\n                }\\n                else if(tmp<target)\\n                {\\n                   j++; \\n                }\\n                else\\n                {\\n                    k--;\\n                }\\n            }\\n        }\\n        ans=ans%mod;\\n        return (int)ans;\\n \\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "\\n\\n        \\n        int mod=1000000007;\\n        long ans=0;\\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            int j=i+1,k=arr.length-1;\\n            while(j<k)\\n            {\\n                int tmp=arr[i]+arr[j]+arr[k];\\n                if(tmp==target)\\n                {\\n                    if(arr[j]==arr[k])\\n                    {\\n                        int n=k-j+1;\\n                        int m=n*(n-1);\\n                        m/=2;\\n                        ans+=m;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        int re=0,le=0,n=arr[j],m=arr[k];\\n                        while(j<=k &&arr[j]==n)\\n                        {\\n                            le++;\\n                            j++;\\n                        }\\n                        while(k>=j && m==arr[k])\\n                        {\\n                            re++;\\n                            k--;\\n                        }\\n                        int tmpans=re*le;\\n                        ans+=tmpans;\\n                    }\\n                }\\n                else if(tmp<target)\\n                {\\n                   j++; \\n                }\\n                else\\n                {\\n                    k--;\\n                }\\n            }\\n        }\\n        ans=ans%mod;\\n        return (int)ans;\\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1918904,
                "title": "python-hashmap-traveersing",
                "content": "```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n        count=0\\n        result=0\\n        mod=10**9+7\\n        for i in range(len(arr)):\\n            hashmap={}\\n            for j in range(i+1,len(arr)):\\n                k=target-(arr[i]+arr[j])\\n                if(k>=0 and k<=100 and k in hashmap ):\\n                    result+=hashmap[k]\\n                    result%=mod\\n                if(arr[j] not in hashmap):\\n                    hashmap[arr[j]]=0\\n                hashmap[arr[j]]+=1\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n        count=0\\n        result=0\\n        mod=10**9+7\\n        for i in range(len(arr)):\\n            hashmap={}\\n            for j in range(i+1,len(arr)):\\n                k=target-(arr[i]+arr[j])\\n                if(k>=0 and k<=100 and k in hashmap ):\\n                    result+=hashmap[k]\\n                    result%=mod\\n                if(arr[j] not in hashmap):\\n                    hashmap[arr[j]]=0\\n                hashmap[arr[j]]+=1\\n                    \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1918790,
                "title": "beginner-friendly-two-pointer-solution",
                "content": "Steps:\\n1) Sort the given array to use two pointer approach. We keep the first element fixed and then find the other two using two-pointer.\\n2) When we find the left and right pointer which matches our target requirement, there can be two cases: i) Both the left and right pointers are holding the same array values\\n          ii) Left and right hold unique values.\\n3) For case (i), we just need to count the number of same values and use the combination formula of nC2 to get the formula, (ctr*(ctr-1))/2\\n4) For case (ii), simply count the number of same left values going left to right, and same right values moving right to left. The product of those gives the number of possible combinations.\\n```\\n int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());//Sort the array to use the two pointer approach\\n        const int modulo = 1000000007;\\n        long long count = 0;\\n        for(int i = 0;i < arr.size()-2;i++){\\n            int current = arr[i]; //Pick a first value and then other 2 values using 2-pointer\\n            int left = i+1;\\n            int right = arr.size()-1;\\n            while(left<right){\\n                if((arr[left]+arr[right])>(target-current))\\n                    right--;\\n                else if((arr[left]+arr[right])<(target-current))\\n                    left++;\\n                else{\\n                    //There are two cases when we find the two values\\n                    if(arr[left]==arr[right]){//Considering both left and right arr values are same\\n                        int ctr = 0;\\n                        while(left<=right)\\n                            left++,ctr++;//Counting the total number of elements\\n                        long long ans = (ctr*(ctr-1))/2;//Derived formula from nC2-combinations\\n                        count+=(ans%modulo);\\n                    }\\n                    else{//Left and right values are unique here\\n                    int leftCounter = 1;//Count the same left values\\n                    int rightCounter = 1;//Count the same right values\\n                    while(left+1<right && arr[left+1]==arr[left])\\n                       { \\n                        leftCounter++;\\n                        left++;\\n                       }\\n                    while(right-1>left && arr[right-1]==arr[right])\\n                       {\\n                        rightCounter++;\\n                        right--;\\n                        }\\n                    count+=((leftCounter*rightCounter)%modulo);//Multiply left and right counters to get total\\n                    left++;                                     //combinations possible\\n                    }    \\n                 \\n                }\\n            }\\n        }\\n        return (int)(count%modulo);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());//Sort the array to use the two pointer approach\\n        const int modulo = 1000000007;\\n        long long count = 0;\\n        for(int i = 0;i < arr.size()-2;i++){\\n            int current = arr[i]; //Pick a first value and then other 2 values using 2-pointer\\n            int left = i+1;\\n            int right = arr.size()-1;\\n            while(left<right){\\n                if((arr[left]+arr[right])>(target-current))\\n                    right--;\\n                else if((arr[left]+arr[right])<(target-current))\\n                    left++;\\n                else{\\n                    //There are two cases when we find the two values\\n                    if(arr[left]==arr[right]){//Considering both left and right arr values are same\\n                        int ctr = 0;\\n                        while(left<=right)\\n                            left++,ctr++;//Counting the total number of elements\\n                        long long ans = (ctr*(ctr-1))/2;//Derived formula from nC2-combinations\\n                        count+=(ans%modulo);\\n                    }\\n                    else{//Left and right values are unique here\\n                    int leftCounter = 1;//Count the same left values\\n                    int rightCounter = 1;//Count the same right values\\n                    while(left+1<right && arr[left+1]==arr[left])\\n                       { \\n                        leftCounter++;\\n                        left++;\\n                       }\\n                    while(right-1>left && arr[right-1]==arr[right])\\n                       {\\n                        rightCounter++;\\n                        right--;\\n                        }\\n                    count+=((leftCounter*rightCounter)%modulo);//Multiply left and right counters to get total\\n                    left++;                                     //combinations possible\\n                    }    \\n                 \\n                }\\n            }\\n        }\\n        return (int)(count%modulo);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918739,
                "title": "lengthy-but-simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int m = 1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> st;\\n        unordered_map<int,int> mp;\\n        for(auto x: arr){\\n            mp[x]++;\\n        }\\n        getTriplets(st, arr, target);\\n        // for(auto x: st){\\n        //     cout<< x[0]<<\" \"<<x[1]<<\" \"<<x[2]<<endl;\\n        // }\\n        int ans = 0;\\n        for(auto x: st){\\n            int a = x[0];\\n            int b = x[1];\\n            int c = x[2];\\n            int temp;\\n            if(a==b and b==c ){\\n                temp = multiply(mp[a], mp[a]-1, mp[a]-2);\\n                \\n            }\\n            else if(a==b or b==c or a==c){\\n                if(a==b){\\n                    temp = multiply2(mp[a], mp[a]-1, mp[c]);\\n                    \\n                }\\n                else if(b==c){\\n                    temp = multiply2(mp[b], mp[b]-1, mp[a]);\\n                    \\n                }\\n                else{\\n                    temp = multiply2(mp[a], mp[a]-1, mp[b]);\\n                    \\n                }\\n            }\\n            else{\\n                temp = multiply3(mp[a], mp[b], mp[c]);\\n            }\\n            \\n            ans+=temp;\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n    \\n    void getTriplets(set<vector<int>> &st, vector<int> &arr, int target){\\n        int i = 0,j = 1,k = 2;\\n        int n = arr.size();\\n        while(i<=n-3){\\n            int val = arr[i];\\n            int newTarget = target - val;\\n            j = i+1;\\n            k = n-1;\\n            while(j<k){\\n                if(arr[k]+arr[j]==newTarget){\\n                    \\n                    st.insert({arr[i],arr[j],arr[k]});\\n                    skip_j(j, arr);\\n                    skip_k(k, arr);\\n                }\\n                else if(arr[k]+arr[j]<newTarget){\\n                    skip_j(j, arr);\\n                }\\n                else{\\n                    skip_k(k, arr);\\n                }\\n            }\\n            skip_j(i, arr);\\n        }\\n            \\n        \\n        \\n    }\\n    void skip_j(int &j, vector<int> &arr){\\n        int val = arr[j];\\n        int n = arr.size();\\n        while(j<n and arr[j]==val)j++;\\n    }\\n    void skip_k(int &k, vector<int> &arr){\\n        int val = arr[k];\\n        while(k>=0 and arr[k]==val)k--;\\n    }\\n    int multiply(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z)/6)%m;\\n    }\\n    int multiply2(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z)/2)%m;\\n    }int multiply3(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z))%m;\\n    }\\n    \\n   \\n};\\n```\\n\\n**Do upvote, it really helps !**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> st;\\n        unordered_map<int,int> mp;\\n        for(auto x: arr){\\n            mp[x]++;\\n        }\\n        getTriplets(st, arr, target);\\n        // for(auto x: st){\\n        //     cout<< x[0]<<\" \"<<x[1]<<\" \"<<x[2]<<endl;\\n        // }\\n        int ans = 0;\\n        for(auto x: st){\\n            int a = x[0];\\n            int b = x[1];\\n            int c = x[2];\\n            int temp;\\n            if(a==b and b==c ){\\n                temp = multiply(mp[a], mp[a]-1, mp[a]-2);\\n                \\n            }\\n            else if(a==b or b==c or a==c){\\n                if(a==b){\\n                    temp = multiply2(mp[a], mp[a]-1, mp[c]);\\n                    \\n                }\\n                else if(b==c){\\n                    temp = multiply2(mp[b], mp[b]-1, mp[a]);\\n                    \\n                }\\n                else{\\n                    temp = multiply2(mp[a], mp[a]-1, mp[b]);\\n                    \\n                }\\n            }\\n            else{\\n                temp = multiply3(mp[a], mp[b], mp[c]);\\n            }\\n            \\n            ans+=temp;\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n    \\n    void getTriplets(set<vector<int>> &st, vector<int> &arr, int target){\\n        int i = 0,j = 1,k = 2;\\n        int n = arr.size();\\n        while(i<=n-3){\\n            int val = arr[i];\\n            int newTarget = target - val;\\n            j = i+1;\\n            k = n-1;\\n            while(j<k){\\n                if(arr[k]+arr[j]==newTarget){\\n                    \\n                    st.insert({arr[i],arr[j],arr[k]});\\n                    skip_j(j, arr);\\n                    skip_k(k, arr);\\n                }\\n                else if(arr[k]+arr[j]<newTarget){\\n                    skip_j(j, arr);\\n                }\\n                else{\\n                    skip_k(k, arr);\\n                }\\n            }\\n            skip_j(i, arr);\\n        }\\n            \\n        \\n        \\n    }\\n    void skip_j(int &j, vector<int> &arr){\\n        int val = arr[j];\\n        int n = arr.size();\\n        while(j<n and arr[j]==val)j++;\\n    }\\n    void skip_k(int &k, vector<int> &arr){\\n        int val = arr[k];\\n        while(k>=0 and arr[k]==val)k--;\\n    }\\n    int multiply(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z)/6)%m;\\n    }\\n    int multiply2(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z)/2)%m;\\n    }int multiply3(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z))%m;\\n    }\\n    \\n   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1918734,
                "title": "remembering-class-11th-chapter-p-c-o-n-101-101",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        // TC - O(n + 101*101) SC - O(101)\\n        long ans = 0;\\n        int MOD = 1_000_000_007;\\n        long[] c = new long[101];\\n        for(int i : arr) c[i]++;  // count occurrences \\n        \\n        for(int i = 0; i < 101; i++) {\\n            for(int j = i; j < 101; j++) {\\n                int k = target - i - j;\\n                if(k < 0 || k > 100) continue;\\n                if(i == j && j == k) \\n                    ans += (c[i] * (c[i] - 1) * (c[i] - 2) / 6); // nC3\\n                else if(i == j && j != k)  \\n                    ans += (c[i] * (c[i] - 1) / 2) * c[k]; // (nC2)*(nC1)\\n                else if(i < j && j < k) \\n                    ans += (c[i] * c[j] * c[k]);    // (nC1)(nC1)(nC1)\\n            }\\n        }\\n        return (int)(ans % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        // TC - O(n + 101*101) SC - O(101)\\n        long ans = 0;\\n        int MOD = 1_000_000_007;\\n        long[] c = new long[101];\\n        for(int i : arr) c[i]++;  // count occurrences \\n        \\n        for(int i = 0; i < 101; i++) {\\n            for(int j = i; j < 101; j++) {\\n                int k = target - i - j;\\n                if(k < 0 || k > 100) continue;\\n                if(i == j && j == k) \\n                    ans += (c[i] * (c[i] - 1) * (c[i] - 2) / 6); // nC3\\n                else if(i == j && j != k)  \\n                    ans += (c[i] * (c[i] - 1) / 2) * c[k]; // (nC2)*(nC1)\\n                else if(i < j && j < k) \\n                    ans += (c[i] * c[j] * c[k]);    // (nC1)(nC1)(nC1)\\n            }\\n        }\\n        return (int)(ans % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918701,
                "title": "java-o-n-2",
                "content": "\\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        final int MAX = 1_000_000_007;\\n        int[] ijsum = new int[301];\\n        int ans = 0;\\n        \\n        for (int j = n - 2; j > 0; j--) {\\n            if (target >= arr[j + 1]) ijsum[target - arr[j + 1]]++;\\n            for (int i = 0; i < j; i++) {\\n                ans += ijsum[arr[i] + arr[j]];\\n                ans %= MAX;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        final int MAX = 1_000_000_007;\\n        int[] ijsum = new int[301];\\n        int ans = 0;\\n        \\n        for (int j = n - 2; j > 0; j--) {\\n            if (target >= arr[j + 1]) ijsum[target - arr[j + 1]]++;\\n            for (int i = 0; i < j; i++) {\\n                ans += ijsum[arr[i] + arr[j]];\\n                ans %= MAX;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918697,
                "title": "python-dfs-with-memoization",
                "content": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        @lru_cache(None)\\n        def dfs(i, k, t):\\n            if k == 0 and t == 0:\\n                    return 1\\n            if k == 0 and t != 0 or i == len(arr):\\n                return 0\\n            return (dfs(i+1, k, t) + (dfs(i+1, k-1, t-arr[i]) if t >= arr[i] else 0))%(10**9+7)\\n        return dfs(0, 3, target)\\n  ```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        @lru_cache(None)\\n        def dfs(i, k, t):\\n            if k == 0 and t == 0:\\n                    return 1\\n            if k == 0 and t != 0 or i == len(arr):\\n                return 0\\n            return (dfs(i+1, k, t) + (dfs(i+1, k-1, t-arr[i]) if t >= arr[i] else 0))%(10**9+7)\\n        return dfs(0, 3, target)\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1918661,
                "title": "c-less-memory-than-100-with-combination-solution",
                "content": "![image](https://assets.leetcode.com/users/images/6fe71f69-68a1-4e31-8d59-c1dc7da6b98b_1649218855.3043642.png)\\n\\n```\\nint countInArr(int *arr, int size, int n)\\n{\\n    int num = 0;\\n    for(int i = 0;i < size;i++)\\n    {\\n        if (arr[i] == n)\\n            num++;\\n    }\\n    return num;\\n}\\n\\nint threeSumMulti(int* arr, int arrSize, int target){\\n    long sum = 0;\\n    long a, b, c;\\n    \\n    for(int i = 0;i <= target;i++)\\n    {\\n        for(int j = i;j <= target;j++)\\n        {\\n            for(int k = j;k <= target;k++)\\n            {\\n                if (i + j + k == target)\\n                {\\n                    a = countInArr(arr, arrSize, i);\\n                    b = countInArr(arr, arrSize, j);\\n                    c = countInArr(arr, arrSize, k);\\n\\n                    if (a != 0 && b != 0 && c != 0)\\n                    {\\n                        if (i != j && i != k && j != k)\\n                            sum += a * b * c;\\n                        else if (i == j && j == k)\\n                            sum += (a * (a - 1) * (a - 2)) / 6;\\n\\n                        else if (i == j)\\n                            sum += ((a * (a - 1)) / 2) * c;\\n \\n                        else if (i == k)\\n                            sum += ((a * (a - 1)) / 2) * b;\\n\\n                        else if (j == k)\\n                            sum += ((b * (b - 1)) / 2) * a;\\n\\n                        sum = sum % 1000000007;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return (int)sum;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nint countInArr(int *arr, int size, int n)\\n{\\n    int num = 0;\\n    for(int i = 0;i < size;i++)\\n    {\\n        if (arr[i] == n)\\n            num++;\\n    }\\n    return num;\\n}\\n\\nint threeSumMulti(int* arr, int arrSize, int target){\\n    long sum = 0;\\n    long a, b, c;\\n    \\n    for(int i = 0;i <= target;i++)\\n    {\\n        for(int j = i;j <= target;j++)\\n        {\\n            for(int k = j;k <= target;k++)\\n            {\\n                if (i + j + k == target)\\n                {\\n                    a = countInArr(arr, arrSize, i);\\n                    b = countInArr(arr, arrSize, j);\\n                    c = countInArr(arr, arrSize, k);\\n\\n                    if (a != 0 && b != 0 && c != 0)\\n                    {\\n                        if (i != j && i != k && j != k)\\n                            sum += a * b * c;\\n                        else if (i == j && j == k)\\n                            sum += (a * (a - 1) * (a - 2)) / 6;\\n\\n                        else if (i == j)\\n                            sum += ((a * (a - 1)) / 2) * c;\\n \\n                        else if (i == k)\\n                            sum += ((a * (a - 1)) / 2) * b;\\n\\n                        else if (j == k)\\n                            sum += ((b * (b - 1)) / 2) * a;\\n\\n                        sum = sum % 1000000007;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return (int)sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918593,
                "title": "c-easy-understanding-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int result = 0;\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < arr.size() - 2; i++){\\n            \\n            int j = i + 1;\\n            int k = arr.size() - 1;\\n            \\n            while(j < k){\\n                \\n                if(arr[i] + arr[j] + arr[k] == target){\\n                    int j_num = 0;\\n                    int k_num = 0;\\n                    \\n                    if(arr[j] == arr[k]){\\n                        result = (result + (k - j)*(k + 1 - j)/2)%mod;\\n                        j = k;\\n                    }\\n                    \\n                    else{\\n                        while(arr[j] == arr[j + 1]){\\n                            j++;\\n                            j_num++;\\n                        }\\n                        j++;\\n                        j_num++;\\n                        \\n                        while(arr[k] == arr[k - 1]){\\n                            k--;\\n                            k_num++;\\n                        }\\n                        k--;\\n                        k_num++;\\n                        \\n                        result = (result + (j_num * k_num))%mod;\\n                    }\\n                }\\n                \\n                else if(arr[i] + arr[j] + arr[k] < target){\\n                    j++;\\n                }\\n                \\n                else{\\n                    k--;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int result = 0;\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < arr.size() - 2; i++){\\n            \\n            int j = i + 1;\\n            int k = arr.size() - 1;\\n            \\n            while(j < k){\\n                \\n                if(arr[i] + arr[j] + arr[k] == target){\\n                    int j_num = 0;\\n                    int k_num = 0;\\n                    \\n                    if(arr[j] == arr[k]){\\n                        result = (result + (k - j)*(k + 1 - j)/2)%mod;\\n                        j = k;\\n                    }\\n                    \\n                    else{\\n                        while(arr[j] == arr[j + 1]){\\n                            j++;\\n                            j_num++;\\n                        }\\n                        j++;\\n                        j_num++;\\n                        \\n                        while(arr[k] == arr[k - 1]){\\n                            k--;\\n                            k_num++;\\n                        }\\n                        k--;\\n                        k_num++;\\n                        \\n                        result = (result + (j_num * k_num))%mod;\\n                    }\\n                }\\n                \\n                else if(arr[i] + arr[j] + arr[k] < target){\\n                    j++;\\n                }\\n                \\n                else{\\n                    k--;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918590,
                "title": "c-easy-solution-two-pointer-approach-o-1-space",
                "content": "```\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long mod=1e9+7;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            int p1=i+1;\\n            int p2=n-1;\\n            int rem=target-arr[i];\\n            while(p1<p2){\\n                if(arr[p1]+arr[p2]<rem)\\n                    p1++;\\n                else if(arr[p1]+arr[p2]>rem)\\n                    p2--;\\n                else\\n                {\\n                   if(arr[p1]==arr[p2])\\n                   {\\n                       int l=p2-p1+1;\\n                       ans+=(l)*(l-1)/2;\\n                       break;\\n                   }\\n                    int v1=arr[p1];\\n                    int v2=arr[p2];\\n                    int c1=0,c2=0;\\n                    while(arr[p1]==v1)\\n                    {\\n                        p1++;\\n                        c1++;\\n                    }\\n                    while(arr[p2]==v2)\\n                    {\\n                        p2--;\\n                        c2++;\\n                    }\\n                    ans+=c1*c2;\\n                }\\n                    \\n            }\\n        }\\n        return ans%mod;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long mod=1e9+7;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            int p1=i+1;\\n            int p2=n-1;\\n            int rem=target-arr[i];\\n            while(p1<p2){\\n                if(arr[p1]+arr[p2]<rem)\\n                    p1++;\\n                else if(arr[p1]+arr[p2]>rem)\\n                    p2--;\\n                else\\n                {\\n                   if(arr[p1]==arr[p2])\\n                   {\\n                       int l=p2-p1+1;\\n                       ans+=(l)*(l-1)/2;\\n                       break;\\n                   }\\n                    int v1=arr[p1];\\n                    int v2=arr[p2];\\n                    int c1=0,c2=0;\\n                    while(arr[p1]==v1)\\n                    {\\n                        p1++;\\n                        c1++;\\n                    }\\n                    while(arr[p2]==v2)\\n                    {\\n                        p2--;\\n                        c2++;\\n                    }\\n                    ans+=c1*c2;\\n                }\\n                    \\n            }\\n        }\\n        return ans%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918489,
                "title": "javascript-hashmap",
                "content": "```\\nvar threeSumMulti = function(arr, target) {\\n    let map={},count=0;\\n    for(let i=0;i<arr.length;i++){\\n        if(map[arr[i]]===undefined){\\n            map[arr[i]]=[];\\n        }\\n        map[arr[i]].push(i);\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        for(let j=i+1;j<arr.length;j++){\\n            let a = arr[i]+arr[j];\\n            let x = target - a;\\n            if(map[x]!==undefined){\\n                let k = binarySearch(map[x],j);\\n                if(k!==-1){\\n                    let n = map[x].length-k;\\n                    count+=n;\\n                    count = count%1000000007;\\n                }\\n            }\\n        }\\n    }\\n    \\n    function binarySearch(arr,key){\\n        let start=0,end=arr.length-1,mid,ans=-1;\\n        while(start<=end){\\n            let mid = start + Math.floor((end-start)/2);\\n            if(arr[mid]>key){\\n                ans = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumMulti = function(arr, target) {\\n    let map={},count=0;\\n    for(let i=0;i<arr.length;i++){\\n        if(map[arr[i]]===undefined){\\n            map[arr[i]]=[];\\n        }\\n        map[arr[i]].push(i);\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        for(let j=i+1;j<arr.length;j++){\\n            let a = arr[i]+arr[j];\\n            let x = target - a;\\n            if(map[x]!==undefined){\\n                let k = binarySearch(map[x],j);\\n                if(k!==-1){\\n                    let n = map[x].length-k;\\n                    count+=n;\\n                    count = count%1000000007;\\n                }\\n            }\\n        }\\n    }\\n    \\n    function binarySearch(arr,key){\\n        let start=0,end=arr.length-1,mid,ans=-1;\\n        while(start<=end){\\n            let mid = start + Math.floor((end-start)/2);\\n            if(arr[mid]>key){\\n                ans = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918456,
                "title": "java-bucket-sort-navigate-the-middle-number-time-o-100-2",
                "content": "Define the 3 numbers: left <= mid <= right, left + mid + right = target\\n```\\n    public int threeSumMulti(int[] arr, int target) {\\n        int max = Math.min(100, target);\\n        int[] count = new int[101];\\n        for (int i : arr)\\n        \\tcount[i]++;\\n        long res = 0;\\n        for (int mid = 0; mid <= max; mid++)\\n        \\tfor (int left = 0, right = target - left - mid; left <= mid && right >= mid; left++, right--)\\n        \\t\\tif (right > max || count[left] == 0 || count[right] == 0)\\n        \\t\\t\\tcontinue;\\n        \\t\\telse if (left == right)\\n        \\t\\t\\tres += (long)count[mid] * (count[mid] - 1) * (count[mid] - 2) / 6 % 1000000007;\\n        \\t\\telse if (left == mid)\\n        \\t\\t\\tres += (long)count[right] * count[mid] * (count[mid] - 1) / 2 % 1000000007;\\n        \\t\\telse if (right == mid)\\n        \\t\\t\\tres += (long)count[left] * count[mid] * (count[mid] - 1) / 2 % 1000000007;\\n        \\t\\telse\\n        \\t\\t\\tres += (long)count[left] * count[mid] * count[right] % 1000000007;\\n        return (int)(res % 1000000007);\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "Define the 3 numbers: left <= mid <= right, left + mid + right = target\\n```\\n    public int threeSumMulti(int[] arr, int target) {\\n        int max = Math.min(100, target);\\n        int[] count = new int[101];\\n        for (int i : arr)\\n        \\tcount[i]++;\\n        long res = 0;\\n        for (int mid = 0; mid <= max; mid++)\\n        \\tfor (int left = 0, right = target - left - mid; left <= mid && right >= mid; left++, right--)\\n        \\t\\tif (right > max || count[left] == 0 || count[right] == 0)\\n        \\t\\t\\tcontinue;\\n        \\t\\telse if (left == right)\\n        \\t\\t\\tres += (long)count[mid] * (count[mid] - 1) * (count[mid] - 2) / 6 % 1000000007;\\n        \\t\\telse if (left == mid)\\n        \\t\\t\\tres += (long)count[right] * count[mid] * (count[mid] - 1) / 2 % 1000000007;\\n        \\t\\telse if (right == mid)\\n        \\t\\t\\tres += (long)count[left] * count[mid] * (count[mid] - 1) / 2 % 1000000007;\\n        \\t\\telse\\n        \\t\\t\\tres += (long)count[left] * count[mid] * count[right] % 1000000007;\\n        return (int)(res % 1000000007);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1918436,
                "title": "c-solution-with-explanation",
                "content": "**Optimal Approach**\\n\\n1. We create unordered_map to store the frequency of sums ie. (arr[i] + arr[j]) [i != j]\\n2. We\\'ll iterate through the whole array entering two elements sum as key and \\n3. Whenever we get target - arr[i] in the map we store the mapping into result\\n4. arr[i] + arr[j] + arr[k] = target\\n=> (arr[i] + arr[j]) = (target - arr[k]) \\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Time - O(N^2)\\nSpace - O(1)**",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918426,
                "title": "java-easy-solution-using-map",
                "content": "\\'\\'\\' \\n class Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int e : arr){\\n             long freq = map.getOrDefault(e,0l);\\n             map.put(e,freq+1l);\\n     }\\n        long ans=0l;\\n        for(int e1: map.keySet()){\\n            for(int e2: map.keySet()){\\n                int e3 = target-e1-e2;\\n                if(map.containsKey(e3)){\\n                    long freq1 = map.get(e1);\\n                    long freq2 = map.get(e2);\\n                    long freq3 = map.get(e3);\\n                    if(e1==e2 && e2==e3)\\n                    ans+=((freq1)*(freq2-1)*(freq3-2))/6;\\n                else if(e1==e2 && e1!=e3)\\n                    ans+=((freq1)*(freq2-1))/2*freq3;\\n                else if(e1<e2 && e2<e3)\\n                    ans+=freq1*freq2*freq3;\\n               \\n                }\\n               ans = ans%1000000007; \\n                \\n            }\\n             \\n        }\\n           return (int)ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int e : arr){\\n             long freq = map.getOrDefault(e,0l);\\n             map.put(e,freq+1l);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 1918336,
                "title": "c-o-n-100-2-easy-to-understand",
                "content": "With i < j < k, we consider 4 case:\\n\\t+ i * 3 == target;\\n\\t+ i * 2 + j == target;\\n\\t+ i + j * 2 == target\\n\\t+ i + j + k == target;\\nBacause 0 <= arr[i] <= 100, we don\\'t need sort array.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint threeSumMulti(vector<int>& arr, int target) {\\n\\t\\t\\tvector<long long> map(105);\\n\\t\\t\\tfor(auto& i : arr) map[i]++;\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(int i = 0; i <= 100; i++) {\\n\\t\\t\\t\\tif(i * 3 == target)\\n\\t\\t\\t\\t\\tans += (map[i] * (map[i] - 1) * (map[i] - 2)) / 6;\\n\\t\\t\\t\\tfor(int j = i + 1; j <= 100 ; j++) {\\n\\t\\t\\t\\t\\tint k = target - i - j;\\n\\t\\t\\t\\t\\tif (target == i * 2 + j) \\n\\t\\t\\t\\t\\t\\tans += (map[i] * (map[i] - 1)) / 2 * map[j];\\n\\t\\t\\t\\t\\telse if (target == i + j * 2) \\n\\t\\t\\t\\t\\t\\tans += (map[j] * (map[j] - 1)) / 2 * map[i];\\n\\t\\t\\t\\t\\telse if (k > j && k <= 100) \\n\\t\\t\\t\\t\\t\\tans += map[i] * map[j] * map[k]; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans %= 1000000007;\\n\\t\\t\\t}\\n\\t\\t\\treturn int(ans);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint threeSumMulti(vector<int>& arr, int target) {\\n\\t\\t\\tvector<long long> map(105);\\n\\t\\t\\tfor(auto& i : arr) map[i]++;\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(int i = 0; i <= 100; i++) {\\n\\t\\t\\t\\tif(i * 3 == target)\\n\\t\\t\\t\\t\\tans += (map[i] * (map[i] - 1) * (map[i] - 2)) / 6;\\n\\t\\t\\t\\tfor(int j = i + 1; j <= 100 ; j++) {\\n\\t\\t\\t\\t\\tint k = target - i - j;\\n\\t\\t\\t\\t\\tif (target == i * 2 + j) \\n\\t\\t\\t\\t\\t\\tans += (map[i] * (map[i] - 1)) / 2 * map[j];\\n\\t\\t\\t\\t\\telse if (target == i + j * 2) \\n\\t\\t\\t\\t\\t\\tans += (map[j] * (map[j] - 1)) / 2 * map[i];\\n\\t\\t\\t\\t\\telse if (k > j && k <= 100) \\n\\t\\t\\t\\t\\t\\tans += map[i] * map[j] * map[k]; \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1824831,
                "title": "c-easy-solution-hashmap",
                "content": "class Solution {\\npublic:\\n    \\n\\tint threeSumMulti(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int c = 0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                c+=(m[target-nums[i]-nums[j]]);\\n            }\\n            m[nums[i]]++;\\n            c%=(1000000007);\\n        }\\n        return (c%1000000007);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint threeSumMulti(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int c = 0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                c+=(m[target-nums[i]-nums[j]]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1661663,
                "title": "java-easy-solution-3-sum",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        long result=0;\\n        for(int i=0;i<arr.length-2;i++){\\n            int required=target-arr[i];\\n            int j=i+1;\\n            int k=arr.length-1;\\n            while(j<k){\\n                if(arr[j]+arr[k]==required){\\n                    int count1=1,count2=1;\\n                    if(arr[j]==arr[k]) {\\n                        long n=(k-j+1);\\n                        result+=(n*(n-1))/2;\\n                        break;\\n                    }\\n                    \\n                    while(j+1<k&&arr[j]==arr[j+1])\\n                    {\\n                        count1++;\\n                        j++;\\n                    }\\n                    while(k-1>j&&arr[k]==arr[k-1])\\n                    {\\n                        count2++;\\n                        k--;\\n                    }\\n                    j++;\\n                    k--;\\n                    result+=(count1*count2);\\n                }\\n                else if(arr[j]+arr[k]>required)  k--;\\n                else j++;\\n    \\n            } \\n          \\n            \\n        }\\n        return (int)(result%1_00_00_00_00_7);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        long result=0;\\n        for(int i=0;i<arr.length-2;i++){\\n            int required=target-arr[i];\\n            int j=i+1;\\n            int k=arr.length-1;\\n            while(j<k){\\n                if(arr[j]+arr[k]==required){\\n                    int count1=1,count2=1;\\n                    if(arr[j]==arr[k]) {\\n                        long n=(k-j+1);\\n                        result+=(n*(n-1))/2;\\n                        break;\\n                    }\\n                    \\n                    while(j+1<k&&arr[j]==arr[j+1])\\n                    {\\n                        count1++;\\n                        j++;\\n                    }\\n                    while(k-1>j&&arr[k]==arr[k-1])\\n                    {\\n                        count2++;\\n                        k--;\\n                    }\\n                    j++;\\n                    k--;\\n                    result+=(count1*count2);\\n                }\\n                else if(arr[j]+arr[k]>required)  k--;\\n                else j++;\\n    \\n            } \\n          \\n            \\n        }\\n        return (int)(result%1_00_00_00_00_7);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565648,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1570379,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1572249,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1576585,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 2016239,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1964151,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1897078,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            }
        ]
    }
]