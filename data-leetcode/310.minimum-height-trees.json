[
    {
        "title": "Range Sum Query 2D - Mutable",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1572079,
                "content": [
                    {
                        "username": "invkrh",
                        "content": "According to the top voted posts, I find there are two good solutions.\\n\\nTime complexity:\\n\\nOne uses BIT\\nupdate => O(log(n) * log(m))\\nrangeSum => O(log(n) * log(m))\\n\\nThe other maintains a presum array for each row\\nupdate => O(m)\\nrangeSum => O(n)\\n\\nHowever I can not tell which complexity is better O(m + n) or O(log(n) * log(m)) ?\\nAny help is highly appreciated"
                    },
                    {
                        "username": "AlexSavo",
                        "content": "[@sumukh14](/sumukh14) You\\'re right! Also log(n) * log(m) = log(m + n), so you compare (m + n) vs log(m + n)"
                    },
                    {
                        "username": "sumukh14",
                        "content": "O(log(n) * log(m)) is better.\\nlog functions don\\'t grow nearly at the rate of linear functions."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "why sum range[0,0,0,0]should be 0 instead of the value of matrix[0][0]\ncuz the sum range [1,1,1,1] is the value of matrix[1][1] and this works for the other parameter other than [0,0,0,0]"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Similar to 307 but needs to implement a 2D segment tree.\\nIt took me 2 hours to write a solution and debug it."
                    },
                    {
                        "username": "omaewamou",
                        "content": "The input size constraints for this problem are misleading. The problem statement states that the input matrix size (both N and M) are bounded by 200 (the max size). However, \"Test Case 15\" input matrix has 225 rows, which exceeds the problem statement constraints. Please fix."
                    }
                ]
            },
            {
                "id": 1986488,
                "content": [
                    {
                        "username": "invkrh",
                        "content": "According to the top voted posts, I find there are two good solutions.\\n\\nTime complexity:\\n\\nOne uses BIT\\nupdate => O(log(n) * log(m))\\nrangeSum => O(log(n) * log(m))\\n\\nThe other maintains a presum array for each row\\nupdate => O(m)\\nrangeSum => O(n)\\n\\nHowever I can not tell which complexity is better O(m + n) or O(log(n) * log(m)) ?\\nAny help is highly appreciated"
                    },
                    {
                        "username": "AlexSavo",
                        "content": "[@sumukh14](/sumukh14) You\\'re right! Also log(n) * log(m) = log(m + n), so you compare (m + n) vs log(m + n)"
                    },
                    {
                        "username": "sumukh14",
                        "content": "O(log(n) * log(m)) is better.\\nlog functions don\\'t grow nearly at the rate of linear functions."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "why sum range[0,0,0,0]should be 0 instead of the value of matrix[0][0]\ncuz the sum range [1,1,1,1] is the value of matrix[1][1] and this works for the other parameter other than [0,0,0,0]"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Similar to 307 but needs to implement a 2D segment tree.\\nIt took me 2 hours to write a solution and debug it."
                    },
                    {
                        "username": "omaewamou",
                        "content": "The input size constraints for this problem are misleading. The problem statement states that the input matrix size (both N and M) are bounded by 200 (the max size). However, \"Test Case 15\" input matrix has 225 rows, which exceeds the problem statement constraints. Please fix."
                    }
                ]
            },
            {
                "id": 1837874,
                "content": [
                    {
                        "username": "invkrh",
                        "content": "According to the top voted posts, I find there are two good solutions.\\n\\nTime complexity:\\n\\nOne uses BIT\\nupdate => O(log(n) * log(m))\\nrangeSum => O(log(n) * log(m))\\n\\nThe other maintains a presum array for each row\\nupdate => O(m)\\nrangeSum => O(n)\\n\\nHowever I can not tell which complexity is better O(m + n) or O(log(n) * log(m)) ?\\nAny help is highly appreciated"
                    },
                    {
                        "username": "AlexSavo",
                        "content": "[@sumukh14](/sumukh14) You\\'re right! Also log(n) * log(m) = log(m + n), so you compare (m + n) vs log(m + n)"
                    },
                    {
                        "username": "sumukh14",
                        "content": "O(log(n) * log(m)) is better.\\nlog functions don\\'t grow nearly at the rate of linear functions."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "why sum range[0,0,0,0]should be 0 instead of the value of matrix[0][0]\ncuz the sum range [1,1,1,1] is the value of matrix[1][1] and this works for the other parameter other than [0,0,0,0]"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Similar to 307 but needs to implement a 2D segment tree.\\nIt took me 2 hours to write a solution and debug it."
                    },
                    {
                        "username": "omaewamou",
                        "content": "The input size constraints for this problem are misleading. The problem statement states that the input matrix size (both N and M) are bounded by 200 (the max size). However, \"Test Case 15\" input matrix has 225 rows, which exceeds the problem statement constraints. Please fix."
                    }
                ]
            },
            {
                "id": 1737555,
                "content": [
                    {
                        "username": "invkrh",
                        "content": "According to the top voted posts, I find there are two good solutions.\\n\\nTime complexity:\\n\\nOne uses BIT\\nupdate => O(log(n) * log(m))\\nrangeSum => O(log(n) * log(m))\\n\\nThe other maintains a presum array for each row\\nupdate => O(m)\\nrangeSum => O(n)\\n\\nHowever I can not tell which complexity is better O(m + n) or O(log(n) * log(m)) ?\\nAny help is highly appreciated"
                    },
                    {
                        "username": "AlexSavo",
                        "content": "[@sumukh14](/sumukh14) You\\'re right! Also log(n) * log(m) = log(m + n), so you compare (m + n) vs log(m + n)"
                    },
                    {
                        "username": "sumukh14",
                        "content": "O(log(n) * log(m)) is better.\\nlog functions don\\'t grow nearly at the rate of linear functions."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "why sum range[0,0,0,0]should be 0 instead of the value of matrix[0][0]\ncuz the sum range [1,1,1,1] is the value of matrix[1][1] and this works for the other parameter other than [0,0,0,0]"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Similar to 307 but needs to implement a 2D segment tree.\\nIt took me 2 hours to write a solution and debug it."
                    },
                    {
                        "username": "omaewamou",
                        "content": "The input size constraints for this problem are misleading. The problem statement states that the input matrix size (both N and M) are bounded by 200 (the max size). However, \"Test Case 15\" input matrix has 225 rows, which exceeds the problem statement constraints. Please fix."
                    }
                ]
            }
        ]
    },
    {
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "question_content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n\n<ul>\n\t<li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</li>\n</ul>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,0,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> transactions = [buy, sell, cooldown, buy, sell]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 75928,
                "title": "share-my-dp-solution-by-state-machine-thinking",
                "content": "Hi,\\n\\nI just come across this problem, and it\\'s very frustating since I\\'m bad at DP.\\n\\nSo I just draw all the actions that can be done.\\n\\nHere is the drawing (Feel like an elementary ...)\\n\\n![image](https://assets.leetcode.com/users/npvinhphat/image_1560663201.png)\\n\\n[Original image](https://imgur.com/wvR4TN8)\\n\\nThere are three states, according to the action that you can take.\\n\\nHence, from there, you can now the profit at a state at time i as:\\n\\n    s0[i] = max(s0[i - 1], s2[i - 1]); // Stay at s0, or rest from s2\\n    s1[i] = max(s1[i - 1], s0[i - 1] - prices[i]); // Stay at s1, or buy from s0\\n    s2[i] = s1[i - 1] + prices[i]; // Only one way from s1\\n\\nThen, you just find the maximum of s0[n] and s2[n], since they will be the maximum profit we need (No one can buy stock and left with more profit that sell right :) )\\n\\nDefine base case:\\n\\n    s0[0] = 0; // At the start, you don\\'t have any stock if you just rest\\n    s1[0] = -prices[0]; // After buy, you should have -prices[0] profit. Be positive!\\n    s2[0] = INT_MIN; // Lower base case\\n\\nHere is the code :D\\n\\n    class Solution {\\n    public:\\n    \\tint maxProfit(vector<int>& prices){\\n    \\t\\tif (prices.size() <= 1) return 0;\\n    \\t\\tvector<int> s0(prices.size(), 0);\\n    \\t\\tvector<int> s1(prices.size(), 0);\\n    \\t\\tvector<int> s2(prices.size(), 0);\\n    \\t\\ts1[0] = -prices[0];\\n    \\t\\ts0[0] = 0;\\n    \\t\\ts2[0] = INT_MIN;\\n    \\t\\tfor (int i = 1; i < prices.size(); i++) {\\n    \\t\\t\\ts0[i] = max(s0[i - 1], s2[i - 1]);\\n    \\t\\t\\ts1[i] = max(s1[i - 1], s0[i - 1] - prices[i]);\\n    \\t\\t\\ts2[i] = s1[i - 1] + prices[i];\\n    \\t\\t}\\n    \\t\\treturn max(s0[prices.size() - 1], s2[prices.size() - 1]);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint maxProfit(vector<int>& prices){\\n    \\t\\tif (prices.size() <= 1) return 0;\\n    \\t\\tvector<int> s0(prices.size(), 0);\\n    \\t\\tvector<int> s1(prices.size(), 0);\\n    \\t\\tvector<int> s2(prices.size(), 0);\\n    \\t\\ts1[0] = -prices[0];\\n    \\t\\ts0[0] = 0;\\n    \\t\\ts2[0] = INT_MIN;\\n    \\t\\tfor (int i = 1; i < prices.size(); i++) {\\n    \\t\\t\\ts0[i] = max(s0[i - 1], s2[i - 1]);\\n    \\t\\t\\ts1[i] = max(s1[i - 1], s0[i - 1] - prices[i]);\\n    \\t\\t\\ts2[i] = s1[i - 1] + prices[i];\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 75927,
                "title": "share-my-thinking-process",
                "content": "The series of problems are typical dp. The key for dp is to find the variables to represent the states and deduce the transition function.\\n\\nOf course one may come up with a O(1) space solution directly, but I think it is better to be generous when you think and be greedy when you implement.\\n\\nThe natural states for this problem is the 3 possible transactions : `buy`, `sell`, `rest`. Here `rest` means no transaction on that day (aka cooldown).\\n\\nThen the transaction sequences can end with any of these three states.\\n\\nFor each of them we make an array, `buy[n]`, `sell[n]` and `rest[n]`. \\n\\n`buy[i]` means before day `i` what is the maxProfit for any sequence end with `buy`.\\n\\n`sell[i]` means before day `i` what is the maxProfit for any sequence end with `sell`.\\n\\n`rest[i]` means before day `i` what is the maxProfit for any sequence end with `rest`.\\n\\nThen we want to deduce the transition functions for `buy` `sell` and `rest`. By definition we have:\\n\\n    buy[i]  = max(rest[i-1]-price, buy[i-1]) \\n    sell[i] = max(buy[i-1]+price, sell[i-1])\\n    rest[i] = max(sell[i-1], buy[i-1], rest[i-1])\\n\\t\\nWhere `price` is the price of day `i`. All of these are very straightforward. They simply represents : \\n\\n    (1) We have to `rest` before we `buy` and \\n    (2) we have to `buy` before we `sell`\\n\\nOne tricky point is how do you make sure you `sell` before you `buy`, since from the equations it seems that `[buy, rest, buy]` is entirely possible.\\n\\nWell, the answer lies within the fact that `buy[i] <= rest[i]` which means `rest[i] = max(sell[i-1], rest[i-1])`. That made sure `[buy, rest, buy]` is never occurred.\\n\\nA further observation is that  and `rest[i] <= sell[i]` is also true therefore\\n\\n    rest[i] = sell[i-1]\\n\\t\\nSubstitute this in to `buy[i]` we now have 2 functions instead of 3:\\n    \\n\\tbuy[i] = max(sell[i-2]-price, buy[i-1])\\n\\tsell[i] = max(buy[i-1]+price, sell[i-1])\\n\\t\\nThis is better than 3, but \\n\\n**we can do even better**\\n\\nSince states of day `i` relies only on `i-1` and `i-2` we can reduce the O(n) space to O(1). And here we are at  our final solution:\\n\\n**Java**\\n\\n    public int maxProfit(int[] prices) {\\n        int sell = 0, prev_sell = 0, buy = Integer.MIN_VALUE, prev_buy;\\n        for (int price : prices) {\\n            prev_buy = buy;\\n            buy = Math.max(prev_sell - price, prev_buy);\\n            prev_sell = sell;\\n            sell = Math.max(prev_buy + price, prev_sell);\\n        }\\n        return sell;\\n    }\\n\\n**C++**\\n\\n    int maxProfit(vector<int> &prices) {\\n        int buy(INT_MIN), sell(0), prev_sell(0), prev_buy;\\n        for (int price : prices) {\\n            prev_buy = buy;\\n            buy = max(prev_sell - price, buy);\\n            prev_sell = sell;\\n            sell = max(prev_buy + price, sell);\\n        }\\n        return sell;\\n    }\\n\\nFor this problem it is ok to use `INT_MIN` as initial value, but in general we would like to avoid this. We can do the same as the following python:\\n\\t\\n**Python**\\n\\n    def maxProfit(self, prices):\\n        if len(prices) < 2:\\n            return 0\\n        sell, buy, prev_sell, prev_buy = 0, -prices[0], 0, 0\\n        for price in prices:\\n            prev_buy = buy\\n            buy = max(prev_sell - price, prev_buy)\\n            prev_sell = sell\\n            sell = max(prev_buy + price, prev_sell)\\n        return sell",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "The series of problems are typical dp. The key for dp is to find the variables to represent the states and deduce the transition function.\\n\\nOf course one may come up with a O(1) space solution directly, but I think it is better to be generous when you think and be greedy when you implement.\\n\\nThe natural states for this problem is the 3 possible transactions : `buy`, `sell`, `rest`. Here `rest` means no transaction on that day (aka cooldown).\\n\\nThen the transaction sequences can end with any of these three states.\\n\\nFor each of them we make an array, `buy[n]`, `sell[n]` and `rest[n]`. \\n\\n`buy[i]` means before day `i` what is the maxProfit for any sequence end with `buy`.\\n\\n`sell[i]` means before day `i` what is the maxProfit for any sequence end with `sell`.\\n\\n`rest[i]` means before day `i` what is the maxProfit for any sequence end with `rest`.\\n\\nThen we want to deduce the transition functions for `buy` `sell` and `rest`. By definition we have:\\n\\n    buy[i]  = max(rest[i-1]-price, buy[i-1]) \\n    sell[i] = max(buy[i-1]+price, sell[i-1])\\n    rest[i] = max(sell[i-1], buy[i-1], rest[i-1])\\n\\t\\nWhere `price` is the price of day `i`. All of these are very straightforward. They simply represents : \\n\\n    (1) We have to `rest` before we `buy` and \\n    (2) we have to `buy` before we `sell`\\n\\nOne tricky point is how do you make sure you `sell` before you `buy`, since from the equations it seems that `[buy, rest, buy]` is entirely possible.\\n\\nWell, the answer lies within the fact that `buy[i] <= rest[i]` which means `rest[i] = max(sell[i-1], rest[i-1])`. That made sure `[buy, rest, buy]` is never occurred.\\n\\nA further observation is that  and `rest[i] <= sell[i]` is also true therefore\\n\\n    rest[i] = sell[i-1]\\n\\t\\nSubstitute this in to `buy[i]` we now have 2 functions instead of 3:\\n    \\n\\tbuy[i] = max(sell[i-2]-price, buy[i-1])\\n\\tsell[i] = max(buy[i-1]+price, sell[i-1])\\n\\t\\nThis is better than 3, but \\n\\n**we can do even better**\\n\\nSince states of day `i` relies only on `i-1` and `i-2` we can reduce the O(n) space to O(1). And here we are at  our final solution:\\n\\n**Java**\\n\\n    public int maxProfit(int[] prices) {\\n        int sell = 0, prev_sell = 0, buy = Integer.MIN_VALUE, prev_buy;\\n        for (int price : prices) {\\n            prev_buy = buy;\\n            buy = Math.max(prev_sell - price, prev_buy);\\n            prev_sell = sell;\\n            sell = Math.max(prev_buy + price, prev_sell);\\n        }\\n        return sell;\\n    }\\n\\n**C++**\\n\\n    int maxProfit(vector<int> &prices) {\\n        int buy(INT_MIN), sell(0), prev_sell(0), prev_buy;\\n        for (int price : prices) {\\n            prev_buy = buy;\\n            buy = max(prev_sell - price, buy);\\n            prev_sell = sell;\\n            sell = max(prev_buy + price, sell);\\n        }\\n        return sell;\\n    }\\n\\nFor this problem it is ok to use `INT_MIN` as initial value, but in general we would like to avoid this. We can do the same as the following python:\\n\\t\\n**Python**\\n\\n    def maxProfit(self, prices):\\n        if len(prices) < 2:\\n            return 0\\n        sell, buy, prev_sell, prev_buy = 0, -prices[0], 0, 0\\n        for price in prices:\\n            prev_buy = buy\\n            buy = max(prev_sell - price, prev_buy)\\n            prev_sell = sell\\n            sell = max(prev_buy + price, prev_sell)\\n        return sell",
                "codeTag": "Python3"
            },
            {
                "id": 75924,
                "title": "most-consistent-ways-of-dealing-with-the-series-of-stock-problems",
                "content": "(**Note**: I have a repost of the same topic [here](https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems) which includes more useful discussions and comments. I would recommend you refer to that one if possible.)\\n\\nUp to this point, I believe you have finished the following series of stock problems: \\n1. [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description)\\n2. [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/#/description)\\n3. [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/#/description)\\n4. [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/#/description)\\n5. [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/#/description)\\n6. [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/contest/leetcode-weekly-contest-55/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n\\nFor each problem, we've got a couple of excellent posts explaining how to approach it. However, most of the posts failed to identify the connections among these problems and made it hard to develop a consistent way of dealing with this series of problems. Here I will introduce the most generalized solution applicable to all of these problems, and its specialization to each of the six problems above.\\n \\n---\\n**`I -- General cases`**\\n\\nThe idea begins with the following question: **Given an array representing the price of stock on each day, what determines the maximum profit we can obtain?**\\n\\nMost of you can quickly come up with answers like \"it depends on which day we are and how many transactions we are allowed to complete\". Sure, those are important factors as they manifest themselves in the requirements of the first four problems. But there is a hidden factor that is not so obvious but vital in determining the maximum profit, which is elaborated below.\\n\\nFirst let's spell out the notations to streamline our analyses. Let `prices` be the stock price array with length `n`, `i` denote the `i-th` day (`i` will go from `0` to `n-1`), `k` denote the maximum number of transactions allowed to complete, `T[i][k]` be the maximum profit that could be gained on the `i-th` day with at most `k` transactions. Apparently we have base cases: `T[-1][k] = T[i][0] = 0`, that is, no stock or no transaction yield no profit (note the first day has `i = 0` so `i = -1` means no stock). Now if we can somehow relate `T[i][k]` to its subproblems like `T[i-1][k], T[i][k-1], T[i-1][k-1], ...`, we will have a working recurrence relation and the problem can be solved recursively. So how do we achieve that?\\n\\nThe most straightforward way would be looking at actions taken on the `i-th` day. How many options do we have? The answer is three: **buy**, **sell**, **rest**. Which one should we take? The answer is: we don't really know, but to find out which one is easy. We can try each option and then choose the one that maximizes our profit, provided there are no other restrictions. However, we do have an extra restriction saying no multiple transactions are allowed at the same time, meaning if we decide to **buy** on the `i-th` day, there should be `0` stock held in our hand; if we decide to **sell** on the `i-th` day, there should be exactly `1` stock held in our hand. The number of stocks held in our hand is the hidden factor mentioned above that will affect the action on the `i-th` day and thus affect the maximum profit.\\n\\nTherefore our definition of `T[i][k]` should really be split into two: `T[i][k][0]` and `T[i][k][1]`, where the **former** denotes the maximum profit on the `i-th` day with at most `k` transactions and with `0` stock in our hand after taking the action, while the **latter** denotes the maximum profit on the `i-th` day with at most `k` transactions and with `1` stock in our hand after taking the action. Now the base cases and the recurrence relation can be written as:\\n\\n1. Base cases:\\n`T[-1][k][0] = 0, T[-1][k][1] = -Infinity`\\n`T[i][0][0] = 0, T[i][0][1] = -Infinity`\\n\\n2. Recurrence relation:\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])`\\n\\nFor the base cases, `T[-1][k][0] = T[i][0][0] = 0` has the same meaning as before while `T[-1][k][1] = T[i][0][1] = -Infinity` emphasizes the fact that it is impossible for us to have `1` stock in hand if there is no stock available or no transactions are allowed.\\n\\nFor `T[i][k][0]` in the recurrence relations, the actions taken on the `i-th` day can only be **rest** and **sell**, since we have `0` stock in our hand at the end of the day. `T[i-1][k][0]` is the maximum profit if action **rest** is taken, while `T[i-1][k][1] + prices[i]` is the maximum profit if action **sell** is taken. Note that the maximum number of allowable transactions remains the same, due to the fact that a transaction consists of two actions coming as a pair -- **buy** and **sell**. Only action **buy** will change the maximum number of transactions allowed.\\n\\nFor `T[i][k][1]` in the recurrence relations, the actions taken on the `i-th` day can only be **rest** and **buy**, since we have `1` stock in our hand at the end of the day. `T[i-1][k][1]` is the maximum profit if action **rest** is taken, while `T[i-1][k-1][0] - prices[i]` is the maximum profit if action **buy** is taken. Note that the maximum number of allowable transactions decreases by one, since buying on the `i-th` day will use one transaction, as explained above.\\n\\nTo find the maximum profit at the end of the last day, we can simply loop through the `prices` array and update `T[i][k][0]` and `T[i][k][1]` according to the recurrence relations above. The final answer will be `T[i][k][0]` (we always have larger profit if we end up with `0` stock in hand).\\n\\n---\\n**`II -- Applications to specific cases`**\\n\\nThe aforementioned six stock problems are classified by the value of `k`, which is the maximum number of allowable transactions (the last two also has additional requirements such as \"cooldown\" or \"transaction fee\"). I will apply the general solution to each of them one by one.\\n\\n**Case I: `k = 1`**\\n\\nFor this case, we really have two unknown variables on each day: `T[i][1][0]` and `T[i][1][1]`, and the recurrence relations say:\\n\\n`T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])`\\n`T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i])`\\n\\nwhere we have taken advantage of the base case`T[i][0][0] = 0` for the second equation.\\n\\nIt is straightforward to write the `O(n)` time and `O(n)` space solution, based on the two equations above. However, if you notice that maximum profits on the `i-th` day actually only depend on those on the `(i-1)-th` day, the space can be cut down to `O(1)`. Here is the space-optimized solution:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i10;\\n}\\n```\\nNow let's try to gain some insight of the solution above. If we examine the part inside the loop more carefully, `T_i11` really just represents the maximum value of the negative of all stock prices up to the `i-th` day, or equivalently the minimum value of all the stock prices. As for `T_i10`, we just need to decide which action yields a higher profit, sell or rest. And if action sell is taken, the price at which we bought the stock is `T_i11`, i.e., the minimum value before the `i-th` day. This is exactly what we would do in reality if we want to gain maximum profit. I should point out that this is not the only way of solving the problem for this case. You may find some other nice solutions [here](https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input).\\n\\n**Case II: `k = +Infinity`**\\n\\nIf `k` is positive infinity, then there isn't really any difference between `k` and `k - 1`, which implies `T[i-1][k-1][0] = T[i-1][k][0]` and `T[i-1][k-1][1] = T[i-1][k][1]`. Therefore, we still have two unknown variables on each day: `T[i][k][0]` and `T[i][k][1]` with `k = +Infinity`, and the recurrence relations say:\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nwhere we have taken advantage of the fact that `T[i-1][k-1][0] = T[i-1][k][0]` for the second equation. The `O(n)` time and `O(1)` space solution is as follows:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n    \\n    return T_ik0;\\n}\\n```\\nThis solution suggests a greedy strategy of gaining maximum profit: as long as possible, buy stock at each local minimum and sell at the immediately followed local maximum. This is equivalent to finding increasing subarrays in `prices` (the stock price array), and buying at the beginning price of each subarray while selling at its end price. It's easy to show that this is the same as accumulating profits as long as it is profitable to do so, as demonstrated in this [post](https://discuss.leetcode.com/topic/726/is-this-question-a-joke).\\n\\n**Case III: `k = 2`**\\n\\nSimilar to the case where `k = 1`, except now we have four variables instead of two on each day: `T[i][1][0]`, `T[i][1][1]`, `T[i][2][0]`, `T[i][2][1]`, and the recurrence relations are:\\n\\n`T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i])`\\n`T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i])`\\n`T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])`\\n`T[i][1][1] = max(T[i-1][1][1], -prices[i])`\\n\\nwhere again we have taken advantage of the base case`T[i][0][0] = 0` for the last equation. The `O(n)` time and `O(1)` space solution is as follows:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE, T_i20 = 0, T_i21 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i20 = Math.max(T_i20, T_i21 + price);\\n        T_i21 = Math.max(T_i21, T_i10 - price);\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i20;\\n}\\n```\\nwhich is essentially the same as the one given [here](https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1).\\n\\n**Case IV: `k is arbitrary`**\\n\\nThis is the most general case so on each day we need to update all the maximum profits with different `k` values corresponding to `0` or `1` stocks in hand at the end of the day. However, there is a minor optimization we can do if `k` exceeds some critical value, beyond which the maximum profit will no long depend on the number of allowable transactions but instead will be bound by the number of available stocks (length of the `prices` array). Let's figure out what this critical value will be.\\n\\nA profitable transaction takes at least two days (buy at one day and sell at the other, provided the buying price is less than the selling price). If the length of the `prices` array is `n`, the maximum number of profitable transactions is `n/2` (integer division). After that no profitable transaction is possible, which implies the maximum profit will stay the same. Therefore the critical value of `k` is `n/2`. If the given `k` is no less than this value, i.e., `k >= n/2`, we can extend `k` to positive infinity and the problem is equivalent to **`Case II`**.\\n\\nThe following is the `O(kn)` time and `O(k)` space solution. Without the optimization, the code will be met with TLE for large `k` values.\\n\\n```\\npublic int maxProfit(int k, int[] prices) {\\n    if (k >= prices.length >>> 1) {\\n        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n        for (int price : prices) {\\n            int T_ik0_old = T_ik0;\\n            T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n            T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n        }\\n    \\n        return T_ik0;\\n    }\\n        \\n    int[] T_ik0 = new int[k + 1];\\n    int[] T_ik1 = new int[k + 1];\\n    Arrays.fill(T_ik1, Integer.MIN_VALUE);\\n        \\n    for (int price : prices) {\\n        for (int j = k; j > 0; j--) {\\n            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);\\n            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);\\n        }\\n    }\\n        \\n    return T_ik0[k];\\n}\\n```\\n\\nThe solution is similar to the one found in this [post](https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java).\\n\\n**Case V: `k = +Infinity but with cooldown`**\\n\\nThis case resembles **`Case II`** very much due to the fact that they have the same `k` value, except now the recurrence relations have to be modified slightly to account for the \"**cooldown**\" requirement. The original recurrence relations for **`Case II`** are given by\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nBut with \"cooldown\", we cannot buy on the `i-th` day if a stock is sold on the `(i-1)-th` day. Therefore, in the second equation above, instead of `T[i-1][k][0]`, we should actually use `T[i-2][k][0]` if we intend to buy on the `i-th` day. Everything else remains the same and the new recurrence relations are\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])`\\n\\nAnd here is the `O(n)` time and `O(1)` space solution:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);\\n        T_ik0_pre = T_ik0_old;\\n    }\\n    \\n    return T_ik0;\\n}\\n```\\n\\n[dietpepsi](https://discuss.leetcode.com/user/dietpepsi) shared a very nice solution [here](https://discuss.leetcode.com/topic/30421/share-my-thinking-process) with thinking process, which turns out to be the same as the one above.\\n\\n**Case VI: `k = +Infinity but with transaction fee`**\\n\\nAgain this case resembles **`Case II`** very much as they have the same `k` value, except now the recurrence relations need to be modified slightly to account for the \"**transaction fee**\" requirement. The original recurrence relations for **`Case II`** are given by\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nSince now we need to pay some fee (denoted as `fee`) for each transaction made, the profit after selling the stock on the `i-th` day should be subtracted by this amount, therefore the new recurrence relations will be\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee)`.\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nNote only the first equation was modified. This is because (as I mentioned above) each transaction is characterized by two actions coming as a pair -- **buy and sell**, and the fee will be paid only after the whole transaction is complete, i.e., after we sell the stock. The following is the `O(n)` time and `O(1)` space solution, where I used long variables for the profits to avoid possible overflow.\\n\\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        long T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n        \\n    return (int)T_ik0;\\n}\\n```\\n---\\n**`III -- Summary`**\\n\\nIn summary, the most general case of the stock problem can be characterized by three factors, the ordinal of the day `i`, the maximum number of allowable transactions `k` and the number of stocks in our hand at the end of the day. I have shown the recurrence relations for the maximum profits and their termination conditions, which leads to the `O(nk)` time and `O(k)` space solution. The results are then applied to each of the six cases, with the last two using slightly modified recurrence relations due to the additional requirements. I should mention that [peterleetcode](https://discuss.leetcode.com/user/peterleetcode) also introduced a nice solution [here](https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions) which generalizes to arbitrary `k` values. If you have a taste, take a look.\\n\\nHope this helps and happy coding!",
                "solutionTags": [],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i10;\\n}\\n```\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n    \\n    return T_ik0;\\n}\\n```\n```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE, T_i20 = 0, T_i21 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i20 = Math.max(T_i20, T_i21 + price);\\n        T_i21 = Math.max(T_i21, T_i10 - price);\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i20;\\n}\\n```\n```\\npublic int maxProfit(int k, int[] prices) {\\n    if (k >= prices.length >>> 1) {\\n        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n        for (int price : prices) {\\n            int T_ik0_old = T_ik0;\\n            T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n            T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n        }\\n    \\n        return T_ik0;\\n    }\\n        \\n    int[] T_ik0 = new int[k + 1];\\n    int[] T_ik1 = new int[k + 1];\\n    Arrays.fill(T_ik1, Integer.MIN_VALUE);\\n        \\n    for (int price : prices) {\\n        for (int j = k; j > 0; j--) {\\n            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);\\n            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);\\n        }\\n    }\\n        \\n    return T_ik0[k];\\n}\\n```\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);\\n        T_ik0_pre = T_ik0_old;\\n    }\\n    \\n    return T_ik0;\\n}\\n```\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        long T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n        \\n    return (int)T_ik0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75931,
                "title": "easiest-java-solution-with-explanations",
                "content": "Here I share my no brainer weapon when it comes to this kind of problems.\\n\\n<hr>\\n\\n**1. Define States**\\n\\nTo represent the decision at index i:\\n\\n- `buy[i]`: Max profit till index i. The series of transaction is ending with a **buy**.\\n- `sell[i]`: Max profit till index i. The series of transaction is ending with a **sell**.\\n\\nTo clarify:\\n\\n- Till index `i`, the **buy / sell** action must happen and must be the **last action**. It may not happen at index `i`. It may happen at `i - 1, i - 2, ... 0`.\\n- In the end `n - 1`, return `sell[n - 1]`. Apparently we cannot finally end up with a buy. In that case, we would rather take a rest at `n - 1`.\\n- For special case no transaction at all, classify it as `sell[i]`, so that in the end, we can still return `sell[n - 1]`.  Thanks @alex153 @kennethliaoke  @anshu2. \\n<hr>\\n\\n**2. Define Recursion**\\n\\n- `buy[i]`: To make a decision whether to buy at `i`, we either take a rest, by just using the old decision at `i - 1`, or sell at/before `i - 2`, then buy at `i`, We cannot sell at `i - 1`, then buy at `i`, because of **cooldown**.\\n- `sell[i]`: To make a decision whether to sell at `i`, we either take a rest, by just using the old decision at `i - 1`, or buy at/before `i - 1`, then sell at `i`.\\n\\nSo we get the following formula:\\n\\n    buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);   \\n    sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);\\n\\n<hr>\\n\\n**3. Optimize to O(1) Space**\\n\\nDP solution only depending on `i - 1` and `i - 2` can be optimized using O(1) space.\\n\\n- Let `b2, b1, b0` represent `buy[i - 2], buy[i - 1], buy[i]`\\n- Let `s2, s1, s0` represent `sell[i - 2], sell[i - 1], sell[i]`\\n\\nThen arrays turn into Fibonacci like recursion:\\n\\n    b0 = Math.max(b1, s2 - prices[i]);\\n    s0 = Math.max(s1, b1 + prices[i]);\\n\\n<hr>\\n\\n**4. Write Code in 5 Minutes**\\n\\nFirst we define the initial states at `i = 0`:\\n\\n- We can buy. The max profit at `i = 0` ending with a **buy** is `-prices[0]`.\\n- We cannot sell. The max profit at `i = 0` ending with a **sell** is `0`.\\n\\n<hr>\\n\\nHere is my solution. Hope it helps!    \\n\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length <= 1) return 0;\\n      \\n        int b0 = -prices[0], b1 = b0;\\n        int s0 = 0, s1 = 0, s2 = 0;\\n     \\n        for(int i = 1; i < prices.length; i++) {\\n        \\tb0 = Math.max(b1, s2 - prices[i]);\\n        \\ts0 = Math.max(s1, b1 + prices[i]);\\n        \\tb1 = b0; s2 = s1; s1 = s0; \\n        }\\n        return s0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Here I share my no brainer weapon when it comes to this kind of problems.\\n\\n<hr>\\n\\n**1. Define States**\\n\\nTo represent the decision at index i:\\n\\n- `buy[i]`: Max profit till index i. The series of transaction is ending with a **buy**.\\n- `sell[i]`: Max profit till index i. The series of transaction is ending with a **sell**.\\n\\nTo clarify:\\n\\n- Till index `i`, the **buy / sell** action must happen and must be the **last action**. It may not happen at index `i`. It may happen at `i - 1, i - 2, ... 0`.\\n- In the end `n - 1`, return `sell[n - 1]`. Apparently we cannot finally end up with a buy. In that case, we would rather take a rest at `n - 1`.\\n- For special case no transaction at all, classify it as `sell[i]`, so that in the end, we can still return `sell[n - 1]`.  Thanks @alex153 @kennethliaoke  @anshu2. \\n<hr>\\n\\n**2. Define Recursion**\\n\\n- `buy[i]`: To make a decision whether to buy at `i`, we either take a rest, by just using the old decision at `i - 1`, or sell at/before `i - 2`, then buy at `i`, We cannot sell at `i - 1`, then buy at `i`, because of **cooldown**.\\n- `sell[i]`: To make a decision whether to sell at `i`, we either take a rest, by just using the old decision at `i - 1`, or buy at/before `i - 1`, then sell at `i`.\\n\\nSo we get the following formula:\\n\\n    buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);   \\n    sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);\\n\\n<hr>\\n\\n**3. Optimize to O(1) Space**\\n\\nDP solution only depending on `i - 1` and `i - 2` can be optimized using O(1) space.\\n\\n- Let `b2, b1, b0` represent `buy[i - 2], buy[i - 1], buy[i]`\\n- Let `s2, s1, s0` represent `sell[i - 2], sell[i - 1], sell[i]`\\n\\nThen arrays turn into Fibonacci like recursion:\\n\\n    b0 = Math.max(b1, s2 - prices[i]);\\n    s0 = Math.max(s1, b1 + prices[i]);\\n\\n<hr>\\n\\n**4. Write Code in 5 Minutes**\\n\\nFirst we define the initial states at `i = 0`:\\n\\n- We can buy. The max profit at `i = 0` ending with a **buy** is `-prices[0]`.\\n- We cannot sell. The max profit at `i = 0` ending with a **sell** is `0`.\\n\\n<hr>\\n\\nHere is my solution. Hope it helps!    \\n\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length <= 1) return 0;\\n      \\n        int b0 = -prices[0], b1 = b0;\\n        int s0 = 0, s1 = 0, s2 = 0;\\n     \\n        for(int i = 1; i < prices.length; i++) {\\n        \\tb0 = Math.max(b1, s2 - prices[i]);\\n        \\ts0 = Math.max(s1, b1 + prices[i]);\\n        \\tb1 = b0; s2 = s1; s1 = s0; \\n        }\\n        return s0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 240097,
                "title": "come-on-in-you-will-not-regret-most-general-java-code-like-all-other-dp-solutions",
                "content": "**Data Structure**\\n\\nDP 1D array: `int[] M = new int[n]` where `M[i]` represents the max profit ending at day `i`\\n\\n---\\n**Logic**\\n\\nWe will focus on current day `i`, what kind of day it is? 3 cases: \\n1. buy day\\n2. cooldown day\\n3. sell day\\n\\nWe will discuss each one of them\\n1. If it is a buy day, then we cannot make any profit at current day, so the max profit is the max profit we have made previously, i.e. yesterday, `M[i] = M[i - 1]`    \\n2. If It is a cooldown day, then same as above, we cannot make profit at current day =>`M[i] = M[i - 1](1)` \\n3. If It is a sell day, then which day is the buy day? The `buy day` could be any days before day `i`(exclusive, i.e. `0` to `i - 1`). Let\\'s denote it as `j`, then the profit we get = `+ previous day\\'s profit + nums[i] - nums[j]`. The problem becomes what is the  `previous days\\' profit`? To figure it out, ask youself what about the day `j - 1`?\\n3.1. `j - 1` **cannot** be a buy day. Since you cannot have 2 continuous days(`j - 1` and `j`) as the `buy day`, you must sell the stock before you buy again as required.\\n3.2. `j - 1` **cannot** be a sell day as well, because if it is, day `j` must be a cooldown day.\\n3.3. Thus, day `j - 1` must be a cooldown day. If it is a cooldown day, then the max profit we can get at day `j - 1` is `M[j - 2]`\\nAbove all, **`M[i] = Math.max(M[j - 2] + nums[i] - nums[j]) for j = 0 to i - 1 (2)`**\\n\\nWith **(1)** and **(2)**, we know that:\\n`M[i] = max(M[i - 1], Math.max(M[j - 2] + nums[i] - nums[j]) for j = 0 to i - 1)`\\n\\n---\\n**Naive solution** (DP: linear scan backwards)\\n\\ntime complexity: `O(n^2)`\\nspace complexity: `O(n)`\\n\\n**Final Code**\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        \\n        int n = prices.length;\\n        int[] M = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(i == 0) M[0] = 0;\\n            else if(i == 1) M[1] = Math.max(prices[1] - prices[0], 0);\\n            else{\\n                M[i] = M[i - 1];\\n                // linear scan\\n                for(int j = 0; j < i; j++){\\n                    int prev = j >= 2 ? M[j - 2] : 0;\\n                    M[i] = Math.max(M[i], prev + prices[i] - prices[j]);\\n                }\\n            }\\n        }\\n                \\n        return M[n - 1];\\n    }\\n}\\n```\\n\\n---\\n\\n**Optimized Solution**\\n\\ntime complexity: `O(n)`\\nspace complexity: `O(n)`\\n\\nIf you notice that: **`M[i] = max(M[i - 1], Math.max(M[j - 2] + nums[i] - nums[j]) for j = 0 to i - 1)`(3)**\\n\\n`M[j - 2] + nums[i] - nums[j]` can be transformed `(M[j - 2] - nums[j]) + nums[i]`, and `M[j - 2] - nums[j]` is the only variable changing. Then if we keep a varible(`maxDiff`) to keep track of the max of it, **(3)** can be changed to **`M[i] = max(M[i - 1], maxDiff + nums[i]) for j = 0 to i - 1)`(4)**\\n\\n**Final Code**\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        \\n        int n = prices.length;\\n        int[] M = new int[n];\\n        int maxDiff = Integer.MIN_VALUE; // M[j - 2] - prices[j]\\n        for(int i = 0; i < n; i++){\\n            if(i < 2) maxDiff = Math.max(maxDiff, -prices[i]);\\n            if(i == 0) M[0] = 0;\\n            else if(i == 1) M[1] = Math.max(prices[1] - prices[0], 0);\\n            else{\\n                M[i] = Math.max(M[i - 1], maxDiff + prices[i]);\\n                maxDiff = Math.max(maxDiff, M[i - 2] - prices[i]);\\n            }\\n        }\\n                \\n        return M[n - 1];\\n    }\\n}\\n```\\n\\n---\\n**One more thing**\\n\\nIf you have any confusion or any opinion on the desciption, please comment. I will insist on updating it for **at least 100 years**.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        \\n        int n = prices.length;\\n        int[] M = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(i == 0) M[0] = 0;\\n            else if(i == 1) M[1] = Math.max(prices[1] - prices[0], 0);\\n            else{\\n                M[i] = M[i - 1];\\n                // linear scan\\n                for(int j = 0; j < i; j++){\\n                    int prev = j >= 2 ? M[j - 2] : 0;\\n                    M[i] = Math.max(M[i], prev + prices[i] - prices[j]);\\n                }\\n            }\\n        }\\n                \\n        return M[n - 1];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        \\n        int n = prices.length;\\n        int[] M = new int[n];\\n        int maxDiff = Integer.MIN_VALUE; // M[j - 2] - prices[j]\\n        for(int i = 0; i < n; i++){\\n            if(i < 2) maxDiff = Math.max(maxDiff, -prices[i]);\\n            if(i == 0) M[0] = 0;\\n            else if(i == 1) M[1] = Math.max(prices[1] - prices[0], 0);\\n            else{\\n                M[i] = Math.max(M[i - 1], maxDiff + prices[i]);\\n                maxDiff = Math.max(maxDiff, M[i - 2] - prices[i]);\\n            }\\n        }\\n                \\n        return M[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75930,
                "title": "very-easy-to-understand-one-pass-o-n-solution-with-no-extra-space",
                "content": "The idea is as follows:\\n\\nFirst, think about what we can do on day `i`? You either have one stock or you don't on day `i`. For each case, you have two options, making a total of four possible actions on day `i`:\\n\\n 1. you have 1 stock and you sell it\\n 2. you have 1 stock and you do nothing\\n 3. you have 0 stock and you buy stock `i`\\n 4. you have 0 stock and you do nothing\\n\\nAs you can imagine, these four actions are correlated between day `i-1` and day `i`. For example, if you take action 1 on day `i`, you then have either taken action 2 or 3 on day `i-1` but not 1 or 4. In precise, two consecutive days are related as follows:\\n\\n 1. if you take action 1 on day `i` ==> you have either taken action 2 or 3 on day `i-1`\\n 2. if you take action 2 on day `i` ==> you have either taken action 2 or 3 on day `i-1`\\n 3. if you take action 3 on day `i` ==> you must have taken action 4 on day `i-1` (you can not sell on day `i-1` due to cool down)\\n 4. if you take action 4 on day `i` ==> you have either taken action 1 or 4 on day `i-1`\\n\\nNow you want to maximize your total profit, but you don't know what action to take on day `i` such that you get the total maximum profit, so `you try all 4 actions on every day`. Suppose you take action 1 on day `i`, since there are two possible actions on day `i-1`, namely actions 2 and 3, you would definitely choose the one that makes your profit on day `i` more. Same thing for actions 2 and 4. So we now have an iterative algorithm.\\n\\nBefore coding, one detail to emphasize is that the initial value on day `0` is important. You basically cannot take action 1, so the corresponding profits should be 0. You cannot take action 2 in practice, but you cannot set up the profit to 0, because that means you don't have a stock to sell on day `1`. Therefore, the initial profit should be negative value of the first stock. You can also think of it as you buy the stock on day `-1` and do nothing on day `0`.\\n\\nHere comes the code in Java:\\n\\n    public int maxProfit(int[] prices) {\\n    \\tint L = prices.length;\\n    \\tif(L < 2) return 0;\\n\\n    \\tint has1_doNothing = -prices[0];\\n    \\tint has1_Sell = 0;\\n    \\tint has0_doNothing = 0;\\n    \\tint has0_Buy = -prices[0];\\n    \\tfor(int i=1; i<L; i++) {\\n    \\t\\thas1_doNothing = has1_doNothing > has0_Buy ? has1_doNothing : has0_Buy;\\n    \\t\\thas0_Buy = -prices[i] + has0_doNothing;\\n    \\t\\thas0_doNothing = has0_doNothing > has1_Sell ? has0_doNothing : has1_Sell;\\n    \\t\\thas1_Sell = prices[i] + has1_doNothing;\\n    \\t}\\n    \\treturn has1_Sell > has0_doNothing ? has1_Sell : has0_doNothing;\\n    }\\n\\nPlease leave your comment if any question.\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n\\n\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java",
                "solutionTags": [],
                "code": "The idea is as follows:\\n\\nFirst, think about what we can do on day `i`? You either have one stock or you don't on day `i`. For each case, you have two options, making a total of four possible actions on day `i`:\\n\\n 1. you have 1 stock and you sell it\\n 2. you have 1 stock and you do nothing\\n 3. you have 0 stock and you buy stock `i`\\n 4. you have 0 stock and you do nothing\\n\\nAs you can imagine, these four actions are correlated between day `i-1` and day `i`. For example, if you take action 1 on day `i`, you then have either taken action 2 or 3 on day `i-1` but not 1 or 4. In precise, two consecutive days are related as follows:\\n\\n 1. if you take action 1 on day `i` ==> you have either taken action 2 or 3 on day `i-1`\\n 2. if you take action 2 on day `i` ==> you have either taken action 2 or 3 on day `i-1`\\n 3. if you take action 3 on day `i` ==> you must have taken action 4 on day `i-1` (you can not sell on day `i-1` due to cool down)\\n 4. if you take action 4 on day `i` ==> you have either taken action 1 or 4 on day `i-1`\\n\\nNow you want to maximize your total profit, but you don't know what action to take on day `i` such that you get the total maximum profit, so `you try all 4 actions on every day`. Suppose you take action 1 on day `i`, since there are two possible actions on day `i-1`, namely actions 2 and 3, you would definitely choose the one that makes your profit on day `i` more. Same thing for actions 2 and 4. So we now have an iterative algorithm.\\n\\nBefore coding, one detail to emphasize is that the initial value on day `0` is important. You basically cannot take action 1, so the corresponding profits should be 0. You cannot take action 2 in practice, but you cannot set up the profit to 0, because that means you don't have a stock to sell on day `1`. Therefore, the initial profit should be negative value of the first stock. You can also think of it as you buy the stock on day `-1` and do nothing on day `0`.\\n\\nHere comes the code in Java:\\n\\n    public int maxProfit(int[] prices) {\\n    \\tint L = prices.length;\\n    \\tif(L < 2) return 0;\\n\\n    \\tint has1_doNothing = -prices[0];\\n    \\tint has1_Sell = 0;\\n    \\tint has0_doNothing = 0;\\n    \\tint has0_Buy = -prices[0];\\n    \\tfor(int i=1; i<L; i++) {\\n    \\t\\thas1_doNothing = has1_doNothing > has0_Buy ? has1_doNothing : has0_Buy;\\n    \\t\\thas0_Buy = -prices[i] + has0_doNothing;\\n    \\t\\thas0_doNothing = has0_doNothing > has1_Sell ? has0_doNothing : has1_Sell;\\n    \\t\\thas1_Sell = prices[i] + has1_doNothing;\\n    \\t}\\n    \\treturn has1_Sell > has0_doNothing ? has1_Sell : has0_doNothing;\\n    }\\n\\nPlease leave your comment if any question.\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n\\n\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java",
                "codeTag": "Unknown"
            },
            {
                "id": 75942,
                "title": "4-line-python-solution-52-ms",
                "content": "The key is 3 states and 5 edges for state transition. 3 states are `notHold (stock)`, `hold (stock)`,  and `notHold_cooldown`. The initial values of the latter two are negative infinity since they are meaningless, i.e. you won't hold stocks at first and there's no cooldown at first. The 5 edges:\\n\\n`hold` -----do nothing----->`hold`\\n\\n`hold` -----sell----->`notHold_cooldown`\\n\\n`notHold` -----do nothing -----> `notHold`\\n\\n`notHold` -----buy-----> `hold`\\n\\n`notHold_cooldown` -----do nothing----->`notHold`\\n\\n    def maxProfit(self, prices):\\n        notHold, notHold_cooldown, hold = 0, float('-inf'), float('-inf')\\n        for p in prices:\\n            hold, notHold, notHold_cooldown = max(hold, notHold - p), max(notHold, notHold_cooldown), hold + p\\n        return max(notHold, notHold_cooldown)",
                "solutionTags": [
                    "Python"
                ],
                "code": "The key is 3 states and 5 edges for state transition. 3 states are `notHold (stock)`, `hold (stock)`,  and `notHold_cooldown`. The initial values of the latter two are negative infinity since they are meaningless, i.e. you won't hold stocks at first and there's no cooldown at first. The 5 edges:\\n\\n`hold` -----do nothing----->`hold`\\n\\n`hold` -----sell----->`notHold_cooldown`\\n\\n`notHold` -----do nothing -----> `notHold`\\n\\n`notHold` -----buy-----> `hold`\\n\\n`notHold_cooldown` -----do nothing----->`notHold`\\n\\n    def maxProfit(self, prices):\\n        notHold, notHold_cooldown, hold = 0, float('-inf'), float('-inf')\\n        for p in prices:\\n            hold, notHold, notHold_cooldown = max(hold, notHold - p), max(notHold, notHold_cooldown), hold + p\\n        return max(notHold, notHold_cooldown)",
                "codeTag": "Python3"
            },
            {
                "id": 75929,
                "title": "7-line-java-only-consider-sell-and-cooldown",
                "content": "Define:\\n\\n    profit1[i] = max profit on day i if I sell\\n\\n    profit2[i] = max profit on day i if I do nothing\\n\\nHow will those profits on day i+1 relate to profits on day i ?\\n\\n\\n    1. profit1[i+1] means I must sell on day i+1, and there are 2 cases:\\n    \\n    a. If I just sold on day i, then I have to buy again on day i and sell on day i+1\\n    \\n    b. If I did nothing on day i, then I have to buy today and sell today \\n    \\n    Taking both cases into account, profit1[i+1] = max(profit1[i]+prices[i+1]-prices[i], profit2[i])\\n    \\n    2. profit2[i+1] means I do nothing on day i+1, so it will be max(profit1[i], profit2[i])\\n\\nAnd the code:\\n\\n    public int maxProfit(int[] prices) {\\n        int profit1=0, profit2=0;   \\n        for(int i=1; i<prices.length; i++){\\n            int copy=profit1;\\n            profit1=Math.max(profit1+prices[i]-prices[i-1], profit2);\\n            profit2=Math.max(copy, profit2);\\n        }\\n        return Math.max(profit1, profit2);\\n    }",
                "solutionTags": [],
                "code": "Define:\\n\\n    profit1[i] = max profit on day i if I sell\\n\\n    profit2[i] = max profit on day i if I do nothing\\n\\nHow will those profits on day i+1 relate to profits on day i ?\\n\\n\\n    1. profit1[i+1] means I must sell on day i+1, and there are 2 cases:\\n    \\n    a. If I just sold on day i, then I have to buy again on day i and sell on day i+1\\n    \\n    b. If I did nothing on day i, then I have to buy today and sell today \\n    \\n    Taking both cases into account, profit1[i+1] = max(profit1[i]+prices[i+1]-prices[i], profit2[i])\\n    \\n    2. profit2[i+1] means I do nothing on day i+1, so it will be max(profit1[i], profit2[i])\\n\\nAnd the code:\\n\\n    public int maxProfit(int[] prices) {\\n        int profit1=0, profit2=0;   \\n        for(int i=1; i<prices.length; i++){\\n            int copy=profit1;\\n            profit1=Math.max(profit1+prices[i]-prices[i-1], profit2);\\n            profit2=Math.max(copy, profit2);\\n        }\\n        return Math.max(profit1, profit2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 761981,
                "title": "python-go-java-js-c-o-n-by-dp-and-state-machine-w-visualization",
                "content": "O(n) by DP and state machine\\n\\n---\\n\\n**State Diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/e43caa0d-25b6-4dad-904a-71a3916ac243_1596022953.885539.png)\\n\\n---\\n\\n**cool_down** denotes the max profit of current Day_i, with either do nothing, or just sell out on previous day and enter cooling on Day_i\\n\\n**sell** denotes the max profit of current Day_i, with selling stock with price quote of Day_i\\n\\n**hold** denotes the max profit of current Day_i, with keep holding or buy and hold on Day_i\\n\\n---\\n\\n**Implementation** in bottom-up DP:\\n<iframe src=\"https://leetcode.com/playground/SYsUqp7j/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock I](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "O(n) by DP and state machine\\n\\n---\\n\\n**State Diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/e43caa0d-25b6-4dad-904a-71a3916ac243_1596022953.885539.png)\\n\\n---\\n\\n**cool_down** denotes the max profit of current Day_i, with either do nothing, or just sell out on previous day and enter cooling on Day_i\\n\\n**sell** denotes the max profit of current Day_i, with selling stock with price quote of Day_i\\n\\n**hold** denotes the max profit of current Day_i, with keep holding or buy and hold on Day_i\\n\\n---\\n\\n**Implementation** in bottom-up DP:\\n<iframe src=\"https://leetcode.com/playground/SYsUqp7j/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock I](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)",
                "codeTag": "Unknown"
            },
            {
                "id": 1521820,
                "title": "c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space",
                "content": "# Approach : \\n* ###  We just to need to build the recursive solution after that *recursive -> iterative conversion* and *optimisations* can be done easily.\\n* ### Everyday, We have two choices : Buy/Sell this stock *OR* ignore and move to the next one. \\n* ### Along with day, we also need to maintain a buy variable which will tell us that if we want to do a transaction today it will be of which type (Buy or Sell) and According to that we will make recursive calls and calculate the answer \\n* ### // No transaction today : \\n```\\n\\tans1 = solve(day + 1, buy); \\n```\\n\\n* ### // transaction today : \\n```\\n\\tif(buy == true) {\\n\\t\\tans2 = -prices[day] + solve(day + 1, false);\\n\\t}else{\\n\\t\\tans2 = prices[day] + solve(day + 2, true);\\n\\t}\\n```\\n\\n* ### Now Choosing the best one among them and returning the required answer.\\n\\n* ### We will stop the recursion when *day >= prices.size()* and *return 0.* \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Recursive Soltion\\n    // Time : O(2^N)\\n    // Space : O(N)\\n    \\n    int solveRec(vector<int>& prices, int day, bool buy){\\n        \\n        if(day >= prices.size()){\\n            return 0;\\n        }\\n        \\n        // First Choice\\n        int ans1 = solveRec(prices, day + 1, buy); // no transaction this day\\n        \\n        \\n        // Second Choice\\n        int ans2 = 0;\\n        // doing the required transaction this day\\n        if(buy){\\n            ans2 = -prices[day] + solveRec(prices, day + 1, false);\\n        }else{\\n            ans2 = prices[day] + solveRec(prices, day + 2, true);\\n        }\\n        \\n        return max(ans1, ans2);\\n        \\n    }\\n    \\n    \\n    // Memoization Soltion\\n    // Time : O(N)\\n    // Space : O(N)\\n   \\n    int solveMemo(vector<int>& prices, int day, bool buy, vector<vector<int>> &memo){\\n        \\n        if(day >= prices.size()){\\n            return 0;\\n        }\\n        \\n        int &ans = memo[day][buy];\\n        \\n        if(ans != -1){\\n            return ans;\\n        }\\n        \\n        // First Choice\\n        int ans1 = solveMemo(prices, day + 1, buy, memo); // no transaction this day\\n        \\n        \\n        // Second Choice\\n        int ans2 = 0;\\n        // doing the required transaction this day\\n        if(buy){\\n            ans2 = -prices[day] + solveMemo(prices, day + 1, false, memo);\\n        }else{\\n            ans2 = prices[day] + solveMemo(prices, day + 2, true, memo);\\n        }\\n        \\n        return ans = max(ans1, ans2);\\n        \\n    }\\n    \\n    \\n    // Dynamic Programming Solution \\n    // Time : O(N)\\n    // Space : O(N)\\n    \\n    int solveDP1(vector<int> &prices){ \\n        \\n         int dp[prices.size() + 2][2];\\n        \\n\\n        for(int day = (int)prices.size() + 1;day >= 0;day--){\\n            for(int buy = 0;buy <= 1;buy++){\\n                \\n    \\n                int &ans = dp[day][buy];\\n                \\n                if(day >= prices.size()){\\n                    ans = 0;\\n                }else{\\n                    \\n                    // First Choice\\n                    int ans1 = dp[day + 1][buy]; // no transaction this say\\n                \\n                    \\n                    // Second Choice\\n                    int ans2 = 0; // doing the required transaction this day\\n                    \\n                    if(buy){\\n                        ans2 = -prices[day] + dp[day + 1][0];\\n                    }else{\\n                        ans2 = prices[day] + dp[day + 2][1];\\n                    }\\n                    \\n                    ans = max(ans1, ans2);\\n                    \\n                }\\n            }\\n        }\\n        \\n        return dp[0][1];\\n        \\n        \\n    }\\n    \\n    // Dynamic Programming Solution \\n    // Time : O(N)\\n    // Space : O(1)\\n    \\n     int solveDP2(vector<int> &prices){ \\n        \\n         int dp[3][2];\\n        \\n        for(int i = 0;i <= 2;i++){\\n                for(int j = 0;j <= 1;j++){\\n                    dp[i][j] = 0;\\n                }\\n        }\\n        \\n        for(int day = (int)prices.size() - 1;day >= 0;day--){\\n            for(int buy = 0;buy <= 1;buy++){\\n                \\n    \\n                int &ans = dp[day % 3][buy];\\n                \\n                    \\n                // First Choice\\n                int ans1 = dp[(day + 1) % 3][buy]; // no transaction this say\\n                \\n                    \\n                // Second Choice\\n                int ans2 = 0; // doing the required transaction this day\\n                    \\n                if(buy){\\n                    ans2 = -prices[day] + dp[(day + 1) % 3][0];\\n                }else{\\n                    ans2 = prices[day] + dp[(day + 2) % 3][1];\\n                }\\n                    \\n                ans = max(ans1, ans2);\\n                    \\n            }\\n        }\\n        \\n        return dp[0][1];\\n        \\n        \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n       int ans = 0; \\n        \\n       // Recursive Solution \\n       // ans = solveRec(prices, 0, true);\\n        \\n       // Memoization Solution\\n       // vector<vector<int>> memo(prices.size() + 2, vector<int>(2, -1));\\n       // ans = solveMemo(prices, 0, true, memo);\\n       \\n        // DP solution with O(N) space\\n       // ans = solveDP1(prices);\\n        \\n       // DP solution with O(1) space\\n       ans = solveDP2(prices); \\n       \\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tans1 = solve(day + 1, buy); \\n```\n```\\n\\tif(buy == true) {\\n\\t\\tans2 = -prices[day] + solve(day + 1, false);\\n\\t}else{\\n\\t\\tans2 = prices[day] + solve(day + 2, true);\\n\\t}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // Recursive Soltion\\n    // Time : O(2^N)\\n    // Space : O(N)\\n    \\n    int solveRec(vector<int>& prices, int day, bool buy){\\n        \\n        if(day >= prices.size()){\\n            return 0;\\n        }\\n        \\n        // First Choice\\n        int ans1 = solveRec(prices, day + 1, buy); // no transaction this day\\n        \\n        \\n        // Second Choice\\n        int ans2 = 0;\\n        // doing the required transaction this day\\n        if(buy){\\n            ans2 = -prices[day] + solveRec(prices, day + 1, false);\\n        }else{\\n            ans2 = prices[day] + solveRec(prices, day + 2, true);\\n        }\\n        \\n        return max(ans1, ans2);\\n        \\n    }\\n    \\n    \\n    // Memoization Soltion\\n    // Time : O(N)\\n    // Space : O(N)\\n   \\n    int solveMemo(vector<int>& prices, int day, bool buy, vector<vector<int>> &memo){\\n        \\n        if(day >= prices.size()){\\n            return 0;\\n        }\\n        \\n        int &ans = memo[day][buy];\\n        \\n        if(ans != -1){\\n            return ans;\\n        }\\n        \\n        // First Choice\\n        int ans1 = solveMemo(prices, day + 1, buy, memo); // no transaction this day\\n        \\n        \\n        // Second Choice\\n        int ans2 = 0;\\n        // doing the required transaction this day\\n        if(buy){\\n            ans2 = -prices[day] + solveMemo(prices, day + 1, false, memo);\\n        }else{\\n            ans2 = prices[day] + solveMemo(prices, day + 2, true, memo);\\n        }\\n        \\n        return ans = max(ans1, ans2);\\n        \\n    }\\n    \\n    \\n    // Dynamic Programming Solution \\n    // Time : O(N)\\n    // Space : O(N)\\n    \\n    int solveDP1(vector<int> &prices){ \\n        \\n         int dp[prices.size() + 2][2];\\n        \\n\\n        for(int day = (int)prices.size() + 1;day >= 0;day--){\\n            for(int buy = 0;buy <= 1;buy++){\\n                \\n    \\n                int &ans = dp[day][buy];\\n                \\n                if(day >= prices.size()){\\n                    ans = 0;\\n                }else{\\n                    \\n                    // First Choice\\n                    int ans1 = dp[day + 1][buy]; // no transaction this say\\n                \\n                    \\n                    // Second Choice\\n                    int ans2 = 0; // doing the required transaction this day\\n                    \\n                    if(buy){\\n                        ans2 = -prices[day] + dp[day + 1][0];\\n                    }else{\\n                        ans2 = prices[day] + dp[day + 2][1];\\n                    }\\n                    \\n                    ans = max(ans1, ans2);\\n                    \\n                }\\n            }\\n        }\\n        \\n        return dp[0][1];\\n        \\n        \\n    }\\n    \\n    // Dynamic Programming Solution \\n    // Time : O(N)\\n    // Space : O(1)\\n    \\n     int solveDP2(vector<int> &prices){ \\n        \\n         int dp[3][2];\\n        \\n        for(int i = 0;i <= 2;i++){\\n                for(int j = 0;j <= 1;j++){\\n                    dp[i][j] = 0;\\n                }\\n        }\\n        \\n        for(int day = (int)prices.size() - 1;day >= 0;day--){\\n            for(int buy = 0;buy <= 1;buy++){\\n                \\n    \\n                int &ans = dp[day % 3][buy];\\n                \\n                    \\n                // First Choice\\n                int ans1 = dp[(day + 1) % 3][buy]; // no transaction this say\\n                \\n                    \\n                // Second Choice\\n                int ans2 = 0; // doing the required transaction this day\\n                    \\n                if(buy){\\n                    ans2 = -prices[day] + dp[(day + 1) % 3][0];\\n                }else{\\n                    ans2 = prices[day] + dp[(day + 2) % 3][1];\\n                }\\n                    \\n                ans = max(ans1, ans2);\\n                    \\n            }\\n        }\\n        \\n        return dp[0][1];\\n        \\n        \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n       int ans = 0; \\n        \\n       // Recursive Solution \\n       // ans = solveRec(prices, 0, true);\\n        \\n       // Memoization Solution\\n       // vector<vector<int>> memo(prices.size() + 2, vector<int>(2, -1));\\n       // ans = solveMemo(prices, 0, true, memo);\\n       \\n        // DP solution with O(N) space\\n       // ans = solveDP1(prices);\\n        \\n       // DP solution with O(1) space\\n       ans = solveDP2(prices); \\n       \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75957,
                "title": "an-8ms-c-dp-solution-easy-to-understand",
                "content": "I think my solution is not very difficult to understand.\\n\\nDefine `buy[i]` as the max profit when you buy the stock at day i. `sell[i]` as the max profit when you sell the stock at day i. Therefore set `buy[0] = -prices[0]`, that if you buy the stock at first day, the profit is -prices[0], also set `sell[0] = 0`, that you do nothing in the first day.\\n\\n    sell[i]=max(buy[i-1]+prices[i], sell[i-1]-prices[i-1]+prices[i]);\\n\\n`buy[i-1]+prices[i]` represents buy the stock on day i-1 and sell it on day i; `sell[i-1]-prices[i-1]+prices[i]` represents you didn't sell the stock on day i-1 but sell it on day i (bought stock back and sell it on day i).\\n\\n    buy[i]=max(sell[i-2]-prices[i], buy[i-1]+prices[i-1]-prices[i]);\\n\\n`sell[i-2]-prices[i]` means sold the stock on day i-2 and buy it on day i (day i-1 is cooldown). `buy[i-1]+prices[i-1]-prices[i]` means you didn't buy the stock on day i-1 but buy it on day i.\\n\\nNo doubt that the max profit would appear in sell[i].\\n\\n    int maxProfit(vector<int>& p) \\n    {\\n    \\tif (p.size() < 2)\\n    \\t\\treturn 0;\\n    \\tint i, sz = p.size();\\n    \\tint ret = 0;\\n    \\tvector<int> buy(sz, 0);\\n    \\tvector<int> sell(sz, 0);\\n    \\tbuy[0] = -p[0];\\n    \\tfor (i = 1; i < sz; ++i)\\n    \\t{\\n    \\t\\tsell[i] = max(buy[i - 1] + p[i], sell[i - 1] - p[i - 1] + p[i]);\\n    \\t\\tif (ret < sell[i]) //record the max sell[i]\\n    \\t\\t\\tret = sell[i];\\n    \\t\\tif (1 == i)\\n    \\t\\t\\tbuy[i] = buy[0] + p[0] - p[1];\\n    \\t\\telse\\n    \\t\\t\\tbuy[i] = max(sell[i - 2] - p[i], buy[i - 1] + p[i - 1] - p[i]);\\n    \\t}\\n    \\treturn ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "I think my solution is not very difficult to understand.\\n\\nDefine `buy[i]` as the max profit when you buy the stock at day i. `sell[i]` as the max profit when you sell the stock at day i. Therefore set `buy[0] = -prices[0]`, that if you buy the stock at first day, the profit is -prices[0], also set `sell[0] = 0`, that you do nothing in the first day.\\n\\n    sell[i]=max(buy[i-1]+prices[i], sell[i-1]-prices[i-1]+prices[i]);\\n\\n`buy[i-1]+prices[i]` represents buy the stock on day i-1 and sell it on day i; `sell[i-1]-prices[i-1]+prices[i]` represents you didn't sell the stock on day i-1 but sell it on day i (bought stock back and sell it on day i).\\n\\n    buy[i]=max(sell[i-2]-prices[i], buy[i-1]+prices[i-1]-prices[i]);\\n\\n`sell[i-2]-prices[i]` means sold the stock on day i-2 and buy it on day i (day i-1 is cooldown). `buy[i-1]+prices[i-1]-prices[i]` means you didn't buy the stock on day i-1 but buy it on day i.\\n\\nNo doubt that the max profit would appear in sell[i].\\n\\n    int maxProfit(vector<int>& p) \\n    {\\n    \\tif (p.size() < 2)\\n    \\t\\treturn 0;\\n    \\tint i, sz = p.size();\\n    \\tint ret = 0;\\n    \\tvector<int> buy(sz, 0);\\n    \\tvector<int> sell(sz, 0);\\n    \\tbuy[0] = -p[0];\\n    \\tfor (i = 1; i < sz; ++i)\\n    \\t{\\n    \\t\\tsell[i] = max(buy[i - 1] + p[i], sell[i - 1] - p[i - 1] + p[i]);\\n    \\t\\tif (ret < sell[i]) //record the max sell[i]\\n    \\t\\t\\tret = sell[i];\\n    \\t\\tif (1 == i)\\n    \\t\\t\\tbuy[i] = buy[0] + p[0] - p[1];\\n    \\t\\telse\\n    \\t\\t\\tbuy[i] = max(sell[i - 2] - p[i], buy[i - 1] + p[i - 1] - p[i]);\\n    \\t}\\n    \\treturn ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 761720,
                "title": "python-dp-o-n-solution-using-differences-explained",
                "content": "For all this buy and sell stocks problems I prefer to use **differences** array. For example, if you have `[1,2,3,1,4]`, then we have `[1, 1, -2, 3]` differences. Then the goal is to take as many of subarrays (with adjacent elements) with biggest sum, such that there is not gap with size `1`. For example, for given differences, we **can not** take `[1,1]` and `[3]`, but we can take `[1]` and `[3]`, so the answer will be `4`.\\n\\nLet `n` be number of elements in `prices`, than there will be `n-1` elements in `diff` array. Let us create `dp` and `dp_max` arrays with `n+1` elements, that is two extra elements, such that \\n\\n1. `dp[i]` is maximum gain for first `i` elements of `diff`, where we use `i`-th element\\n2. `dp_max[i]` is maximum gain for first `i` elements of `diff` (we can use `i` and we can not use it).\\n\\nNow, we can do the following steps:\\n\\n1. `dp[i] = diff[i] + max(dp_max[i-3], dp[i-1])`, because, first of all we need to use `i`, so we take `diff[i]`. Now we have two options: skip `2` elements and take `dp_max[i-3]`, or do not skip anything and take `dp[i-1]`.\\n2. Update `dp_max[i] = max(dp_max[i-1], dp[i])`, standard way to update maximum.\\n3. Finally, we added `2` extra elements to `dp` and `dp_max`, so instead of `dp_max[-1]` we need to return `dp_max[-3]`.\\n\\n**Complexity**: both time and space complexity is `O(n)`. Space complexity can be improved to `O(1)`, because we look only `3` elements to the back.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        if n <= 1: return 0\\n        \\n        diff = [prices[i+1] - prices[i] for i in range(n-1)]\\n        dp, dp_max = [0]*(n + 1), [0]*(n + 1)\\n        for i in range(n-1):\\n            dp[i] = diff[i] + max(dp_max[i-3], dp[i-1])\\n            dp_max[i] = max(dp_max[i-1], dp[i])\\n            \\n        return dp_max[-3]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        if n <= 1: return 0\\n        \\n        diff = [prices[i+1] - prices[i] for i in range(n-1)]\\n        dp, dp_max = [0]*(n + 1), [0]*(n + 1)\\n        for i in range(n-1):\\n            dp[i] = diff[i] + max(dp_max[i-3], dp[i-1])\\n            dp_max[i] = max(dp_max[i-1], dp[i])\\n            \\n        return dp_max[-3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75940,
                "title": "5-lines-python-o-n-time-o-1-space",
                "content": "    def maxProfit(self, prices):\\n        free = 0\\n        have = cool = float('-inf')\\n        for p in prices:\\n            free, have, cool = max(free, cool), max(have, free - p), have + p\\n        return max(free, cool)\\n\\n`free` is the maximum profit I can have while being free to buy.  \\n`have` is the maximum profit I can have while having stock.  \\n`cool` is the maximum profit I can have while cooling down.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def maxProfit(self, prices):\\n        free = 0\\n        have = cool = float('-inf')\\n        for p in prices:\\n            free, have, cool = max(free, cool), max(have, free - p), have + p\\n        return max(free, cool)\\n\\n`free` is the maximum profit I can have while being free to buy.  \\n`have` is the maximum profit I can have while having stock.  \\n`cool` is the maximum profit I can have while cooling down.",
                "codeTag": "Python3"
            },
            {
                "id": 404998,
                "title": "all-in-one-o-n-time-o-1-space-python-solution",
                "content": "This set of problems can be solved using state machine with similar code.\\n\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n![image](https://assets.leetcode.com/users/charliedu/image_1571065776.png)\\n\\ns1 is the profit after buying \\ns2 is the profit after selling\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0      \\n        s1 = -prices[0]   # profit after buying\\n        s2 = 0            # profit after selling\\n        for p in prices:\\n            s1 = max(s1, -p)\\n            s2 = max(s2, s1 + p)\\n        return s2\\n```\\n\\n\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n![image](https://assets.leetcode.com/users/charliedu/image_1571065959.png)\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        s1 = -prices[0]   # profit after buying\\n        s2 = 0            # profit after selling\\n        for p in prices:\\n            s1 = max(s1, s2 - p)\\n            s2 = max(s2, s1 + p)\\n        return s2\\n```\\n\\n\\n[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n![image](https://assets.leetcode.com/users/charliedu/image_1571066283.png)\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        # s1: profit after 1st buying s2: profit after 1st selling\\n        # s3: profit after 2nd buying s4: profit after 2nd selling \\n        s1, s2, s3, s4 = -prices[0], 0, -prices[0], 0\\n        for p in prices:\\n            s1 = max(s1, -p)\\n            s2 = max(s2, s1 + p)\\n            s3 = max(s3, s2 - p)\\n            s4 = max(s4, s3 + p)             \\n        return max(s2, s4)\\n```\\n\\n\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n![image](https://assets.leetcode.com/users/charliedu/image_1571066141.png)\\n\\n```\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        # unlimited transactions\\n        if k >= len(prices) // 2:\\n            s1, s2 = -prices[0], 0\\n            for p in prices:\\n                s1 = max(s1, s2 - p)\\n                s2 = max(s2, s1 + p)\\n            return s2\\n        # s[0] is dummy head\\n        # s[2*j+1]: profit after jth buying s[2*j+2]: profit after jth selling\\n        s = [0] + [-prices[0], 0]*k \\n        for p in prices:\\n            for j in range(k):\\n                s[2*j+1] = max(s[2*j+1], s[2*j] - p)\\n                s[2*j+2] = max(s[2*j+2], s[2*j+1] + p)     \\n        return max(s[::2])\\n```\\n\\n\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n![image](https://assets.leetcode.com/users/charliedu/image_1571066399.png)\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        s1 = -prices[0]     # profit after buying\\n        s2 = 0              # profit after selling\\n        s0 = [0, 0]         # cooldown profit using a queue\\n        for p in prices:\\n            s1 = max(s1, s0[1] - p)\\n            s2 = max(s2, s1 + p)\\n            s0 = [s2, s0[0]]\\n        return s2\\n```\\n\\n\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n![image](https://assets.leetcode.com/users/charliedu/image_1573782081.png)\\n\\n```\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        s1 = -prices[0]   # profit after buying\\n        s2 = 0            # profit after selling\\n        for p in prices:\\n            s1 = max(s1, s2 - p)\\n            s2 = max(s2, s1 + p - fee)\\n        return s2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0      \\n        s1 = -prices[0]   # profit after buying\\n        s2 = 0            # profit after selling\\n        for p in prices:\\n            s1 = max(s1, -p)\\n            s2 = max(s2, s1 + p)\\n        return s2\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        s1 = -prices[0]   # profit after buying\\n        s2 = 0            # profit after selling\\n        for p in prices:\\n            s1 = max(s1, s2 - p)\\n            s2 = max(s2, s1 + p)\\n        return s2\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        # s1: profit after 1st buying s2: profit after 1st selling\\n        # s3: profit after 2nd buying s4: profit after 2nd selling \\n        s1, s2, s3, s4 = -prices[0], 0, -prices[0], 0\\n        for p in prices:\\n            s1 = max(s1, -p)\\n            s2 = max(s2, s1 + p)\\n            s3 = max(s3, s2 - p)\\n            s4 = max(s4, s3 + p)             \\n        return max(s2, s4)\\n```\n```\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        # unlimited transactions\\n        if k >= len(prices) // 2:\\n            s1, s2 = -prices[0], 0\\n            for p in prices:\\n                s1 = max(s1, s2 - p)\\n                s2 = max(s2, s1 + p)\\n            return s2\\n        # s[0] is dummy head\\n        # s[2*j+1]: profit after jth buying s[2*j+2]: profit after jth selling\\n        s = [0] + [-prices[0], 0]*k \\n        for p in prices:\\n            for j in range(k):\\n                s[2*j+1] = max(s[2*j+1], s[2*j] - p)\\n                s[2*j+2] = max(s[2*j+2], s[2*j+1] + p)     \\n        return max(s[::2])\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        s1 = -prices[0]     # profit after buying\\n        s2 = 0              # profit after selling\\n        s0 = [0, 0]         # cooldown profit using a queue\\n        for p in prices:\\n            s1 = max(s1, s0[1] - p)\\n            s2 = max(s2, s1 + p)\\n            s0 = [s2, s0[0]]\\n        return s2\\n```\n```\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        s1 = -prices[0]   # profit after buying\\n        s2 = 0            # profit after selling\\n        for p in prices:\\n            s1 = max(s1, s2 - p)\\n            s2 = max(s2, s1 + p - fee)\\n        return s2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 181359,
                "title": "python-o-n-time-and-o-1-space-detailed-introduction-of-how-the-idea-was-built-essentially",
                "content": "  I am sharing my step-by-step process of how the idea is built up.\\n\\n  We know we have to make a choice on `day[i]`, so we can think from the perspective of what determines the option of choices we have on `day[i]`.\\n\\n  On `day[i]`, we can choose `cooldown`, `buy`, or `sell`:\\n1. Under what condition we can choose to `cooldown` on `day[i]`?\\n     It is obvious, there is not requirement. We can choose to cooldown on anyday.\\n2. Under what condition we can choose to `buy` a stock on `day[i]`?\\n    The answer is we need make sure that we do `not own` any stock at end of `day[i-2]` because there is one day `cooldown` requirement.\\n3. Under what condition we can choose to `sell` a stock on `day[i]`?\\n    The answer is we must `own` a stock at the end of `day[i-1]`.\\n\\nNow we can see the factors that determine the options of choices we have on `day[i]` is the status of  `whether we owned` a stock previously. So, let `own[i]` represents the maximum profit for the first i days if we `own` a stock at the end of `day[i]`. `not_own[i]` represents the maximum profit for the first i days if we do `not own` a stock at the end of `day[i]`.\\n\\nLuckily, knowing `own[i]` and `not_own[i]` are enough because\\n    1: The maximum profit can be derived from the two status because we either `own` or `not own` a stock at end of one day.\\n    2: We can derive the the current status on `day[i]` if we know the previous status.\\n\\nFinally, we can write up the equations:\\n    `own[i]` = `max`(`own[i-1]`, `not_own[i-2]` - `prices[i]`)\\n    `not_own[i]` = `max`(`not_own[i-1]`, `own[i-1]` + `prices[i]`)\\nIn fact, the equations are the same of the idea of buy and sell, but I think the process to come up with the idea could be better understood by my approach.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        own_last = -prices[0]\\n        not_own_last2 = 0\\n        not_own_last = 0\\n        for i in range(1, len(prices)):\\n            own = max(own_last, not_own_last2 - prices[i])\\n            not_own = max(not_own_last, own_last + prices[i])\\n\\n            not_own_last2 = not_own_last\\n            own_last = own\\n            not_own_last = not_own\\n            res = max(res, max(own, not_own))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        own_last = -prices[0]\\n        not_own_last2 = 0\\n        not_own_last = 0\\n        for i in range(1, len(prices)):\\n            own = max(own_last, not_own_last2 - prices[i])\\n            not_own = max(not_own_last, own_last + prices[i])\\n\\n            not_own_last2 = not_own_last\\n            own_last = own\\n            not_own_last = not_own\\n            res = max(res, max(own, not_own))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239452,
                "title": "c-dp-easy-solution-faster-than-100-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int n=prices.size();\\n        if(prices.size()==1){\\n            return 0;\\n        }\\n      //initialise two vector for storing the value after buying and selling stock...\\n      vector<int>buy(n,0);\\n      vector<int>sell(n,0);\\n      //we bought first stock 0n very first day\\n      buy[0]=-prices[0];\\n      //no profit on first day\\n      sell[0]=0;\\n      //on  second day check ehich day will give you more profit on buying stock 1st day/2nd day\\n      buy[1]=max(-prices[0],-prices[1]);\\n      //check if you can sell your stock on 2nd day or not with some profit\\n      sell[1]=max(0,-prices[0]+prices[1]);\\n      for(int i=2;i<n;i++)\\n      {\\n        //you have to make desicion either you can buy stock or not i.e you have to sell i-2th item to buy ith item . so you need to choose wisely that if you can make more profit on buying ith stock or not.\\n        buy[i]=max(buy[i-1],sell[i-2]-prices[i]);\\n        //simillarly you need to check on which day to sell the stock to make more profit\\n        sell[i]=max(sell[i-1],buy[i-1]+prices[i]);\\n      }//return profit after selling nth item.\\n        return sell[n-1];\\n    }\\n}; do upvote if you find it useful..............\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int n=prices.size();\\n        if(prices.size()==1){\\n            return 0;\\n        }\\n      //initialise two vector for storing the value after buying and selling stock...\\n      vector<int>buy(n,0);\\n      vector<int>sell(n,0);\\n      //we bought first stock 0n very first day\\n      buy[0]=-prices[0];\\n      //no profit on first day\\n      sell[0]=0;\\n      //on  second day check ehich day will give you more profit on buying stock 1st day/2nd day\\n      buy[1]=max(-prices[0],-prices[1]);\\n      //check if you can sell your stock on 2nd day or not with some profit\\n      sell[1]=max(0,-prices[0]+prices[1]);\\n      for(int i=2;i<n;i++)\\n      {\\n        //you have to make desicion either you can buy stock or not i.e you have to sell i-2th item to buy ith item . so you need to choose wisely that if you can make more profit on buying ith stock or not.\\n        buy[i]=max(buy[i-1],sell[i-2]-prices[i]);\\n        //simillarly you need to check on which day to sell the stock to make more profit\\n        sell[i]=max(sell[i-1],buy[i-1]+prices[i]);\\n      }//return profit after selling nth item.\\n        return sell[n-1];\\n    }\\n}; do upvote if you find it useful..............\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451736,
                "title": "python-top-down-dp-clean-concise",
                "content": "**Idea**\\n- Same with problem [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/259375) except if we sell on `i`th day, we only can buy on `i+2`th day (skip `i+1`th day).\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        @lru_cache(None)\\n        def dp(i, canBuy):\\n            if i >= len(prices):\\n                return 0\\n            ans = dp(i+1, canBuy)  # Skip\\n            if canBuy:\\n                ans = max(ans, dp(i+1, False) - prices[i])  # Buy\\n            else:\\n                ans = max(ans, dp(i+2, True) + prices[i])  # Sell\\n            return ans\\n                \\n        return dp(0, True)\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        @lru_cache(None)\\n        def dp(i, canBuy):\\n            if i >= len(prices):\\n                return 0\\n            ans = dp(i+1, canBuy)  # Skip\\n            if canBuy:\\n                ans = max(ans, dp(i+1, False) - prices[i])  # Buy\\n            else:\\n                ans = max(ans, dp(i+2, True) + prices[i])  # Sell\\n            return ans\\n                \\n        return dp(0, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293789,
                "title": "python-o-n-dp-i-believe-my-state-is-easier-to-understand",
                "content": "Use DP to solve this problem. It is obviously to come up with DP, because this is a \"stage-decision-problem\", every day we decide buy/sell/rest. \\n\\nThe state is defined as below\\n\\n1. `dp(n, 0)` -> The max profix we get on day n, if we **rest** on day n. \\n2. `dp(n, 1)` -> The max profix we get on day n, if we **buy** on day n. \\n3. `dp(n, 2)` -> The max profix we get on day n, if we **sell** on day n. \\n\\nBelow is the state transition function\\n\\n1. `dp(n, 0) = max{ dp(n-1, 1), dp(n-1, 0), dp(n-1, 2) }`, if we rest on day n, we do not really care about what we have done on day `n-1`, you can do whatever you want, and we just take the max profit from day n-1\\n2. `dp(n, 1) = dp[n-1][0] - prices[n]`, if we buy on day n, we cannot  buy on day n-1, because double-buy is by natural disallowed in the \"Stock\" Series. We cannot sell on day n-1, because of the new cool-down policy. So in day n-1, we can only rest. \\n3. `dp(n, 2) = max {dp(0, 1), dp(1, 1), ...., dp(n-1, 1)} + prices[n]`, if we sell on day n, we need to make sure we buy the stock before in one of `(0...n-1)`. For example, if you rest on the first 2 days, there is **NOTHING** for you to sell on the 3rd day. Among all the possible \"buy-day\", we pick the one with max-profix \\n\\nNow, you might think: hmmmm, this is an O(N^2) DP because of `3.`, we need to get max from a list of values in each iteration. Not really, you can keep track of the max of the past `dp(n, 1)`. In the following solution, I use the var `bought` to keep track. \\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        dp = [[0 for _ in range(3)] for _ in range(len(prices))]\\n        \\n        dp[0][0] = 0\\n        dp[0][1] = -prices[0]\\n        dp[0][2] = float(\\'-inf\\')\\n        bought = dp[0][1]\\n        \\n        n = len(prices)\\n        for i in range(1, n):\\n            dp[i][0] = max([dp[i-1][0], dp[i-1][2], dp[i-1][1]])\\n            dp[i][1] = dp[i-1][0] - prices[i]\\n            dp[i][2] = bought + prices[i]\\n            \\n            bought = max(bought, dp[i][1])\\n            #print(\"buy\", bought)\\n            \\n        #print(dp)\\n            \\n        return max(dp[n-1])\\n```\\n\\nAnd of course, you can optimize my code with the rolling-array trick to Space O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        dp = [[0 for _ in range(3)] for _ in range(len(prices))]\\n        \\n        dp[0][0] = 0\\n        dp[0][1] = -prices[0]\\n        dp[0][2] = float(\\'-inf\\')\\n        bought = dp[0][1]\\n        \\n        n = len(prices)\\n        for i in range(1, n):\\n            dp[i][0] = max([dp[i-1][0], dp[i-1][2], dp[i-1][1]])\\n            dp[i][1] = dp[i-1][0] - prices[i]\\n            dp[i][2] = bought + prices[i]\\n            \\n            bought = max(bought, dp[i][1])\\n            #print(\"buy\", bought)\\n            \\n        #print(dp)\\n            \\n        return max(dp[n-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761797,
                "title": "c-i-came-up-with-4-solution-pick-up-best-one",
                "content": "### 1. Brute Force Recursive Solution \\n```\\nTime  Complexcity - exponential     Give You TLE\\nSpace Complexcity - O(1)\\n```\\n```\\nclass Solution {\\npublic:\\n    int findMaxProfit(vector<int>&prices,bool f,int day){\\n        if(day>=prices.size())return 0;\\n        if(!f){\\n            int x = findMaxProfit(prices,!f,day+1) - prices[day];\\n            int y = findMaxProfit(prices,f,day+1);\\n            return max(x,y);\\n        }\\n\\t\\t\\tint x  = prices[day] + findMaxProfit(prices,!f,day+2);\\n\\t\\t\\tint y  = findMaxProfit(prices,f,day+1);\\n        return max(x,y); \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return findMaxProfit(prices,false,0);\\n    }\\n};\\n```\\n### 2. Recoursion With Memo Solution | Top Down DP \\n```\\nTime  Complexcity - O(N)\\nSpace Complexcity - O(N)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxProfit(vector<int>&prices,bool f,int day,vector<vector<int>>&dp){\\n        if(day>=prices.size())return 0;\\n        if(dp[f][day]!=-1)return dp[f][day];\\n        if(!f){\\n            int x = findMaxProfit(prices,!f,day+1,dp) - prices[day];\\n            int y = findMaxProfit(prices,f,day+1,dp);\\n            return dp[f][day] = max(x,y);\\n        }\\n\\t\\t\\tint x  = prices[day] + findMaxProfit(prices,!f,day+2,dp);\\n\\t\\t\\tint y  = findMaxProfit(prices,f,day+1,dp);\\n        return dp[f][day] = max(x,y); \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(2,vector<int>(prices.size(),-1));\\n        return findMaxProfit(prices,false,0,dp);\\n    }\\n};\\n```\\n\\n### 3. Bottom Up DP \\n```\\nTime  Complexcity - O(N)\\nSpace Complexcity - O(N)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n\\tint maxProfit(vector<int>& prices){\\n     int n = prices.size();\\n\\t\\tif( n<= 1) return 0;\\n\\t\\tvector<int> buy(n, 0),cd(n, 0),sell(n, 0);\\n\\t\\tcd[0] = -prices[0],buy[0] = 0,sell[0] = INT_MIN;\\n        \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tbuy[i]  = max(buy[i - 1], sell[i - 1]);\\n\\t\\t\\tcd[i]   = max(cd[i - 1], buy[i - 1] - prices[i]);\\n\\t\\t\\tsell[i] = cd[i - 1] + prices[i];\\n\\t\\t}\\n\\t\\treturn max(buy[n-1], sell[n-1]);\\n\\t}\\n};\\n\\n```\\n### 4. Bottom Up DP || Less Memory\\n```\\nTime  Complexcity - O(N)\\nSpace Complexcity - O(1)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {     \\n    int b = INT_MIN,s = 0,p_sell = 0,p_buy;\\n        for(int stock : prices){\\n            p_buy = b;\\n            b = max(b, p_sell - stock);\\n            p_sell = s;\\n            s = max(s, p_buy + stock);  \\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **upvote** If You Like It\\n**Happy Coding :)**",
                "solutionTags": [],
                "code": "```\\nTime  Complexcity - exponential     Give You TLE\\nSpace Complexcity - O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxProfit(vector<int>&prices,bool f,int day){\\n        if(day>=prices.size())return 0;\\n        if(!f){\\n            int x = findMaxProfit(prices,!f,day+1) - prices[day];\\n            int y = findMaxProfit(prices,f,day+1);\\n            return max(x,y);\\n        }\\n\\t\\t\\tint x  = prices[day] + findMaxProfit(prices,!f,day+2);\\n\\t\\t\\tint y  = findMaxProfit(prices,f,day+1);\\n        return max(x,y); \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return findMaxProfit(prices,false,0);\\n    }\\n};\\n```\n```\\nTime  Complexcity - O(N)\\nSpace Complexcity - O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxProfit(vector<int>&prices,bool f,int day,vector<vector<int>>&dp){\\n        if(day>=prices.size())return 0;\\n        if(dp[f][day]!=-1)return dp[f][day];\\n        if(!f){\\n            int x = findMaxProfit(prices,!f,day+1,dp) - prices[day];\\n            int y = findMaxProfit(prices,f,day+1,dp);\\n            return dp[f][day] = max(x,y);\\n        }\\n\\t\\t\\tint x  = prices[day] + findMaxProfit(prices,!f,day+2,dp);\\n\\t\\t\\tint y  = findMaxProfit(prices,f,day+1,dp);\\n        return dp[f][day] = max(x,y); \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(2,vector<int>(prices.size(),-1));\\n        return findMaxProfit(prices,false,0,dp);\\n    }\\n};\\n```\n```\\nTime  Complexcity - O(N)\\nSpace Complexcity - O(N)\\n```\n```\\nclass Solution {\\npublic:\\n\\tint maxProfit(vector<int>& prices){\\n     int n = prices.size();\\n\\t\\tif( n<= 1) return 0;\\n\\t\\tvector<int> buy(n, 0),cd(n, 0),sell(n, 0);\\n\\t\\tcd[0] = -prices[0],buy[0] = 0,sell[0] = INT_MIN;\\n        \\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tbuy[i]  = max(buy[i - 1], sell[i - 1]);\\n\\t\\t\\tcd[i]   = max(cd[i - 1], buy[i - 1] - prices[i]);\\n\\t\\t\\tsell[i] = cd[i - 1] + prices[i];\\n\\t\\t}\\n\\t\\treturn max(buy[n-1], sell[n-1]);\\n\\t}\\n};\\n\\n```\n```\\nTime  Complexcity - O(N)\\nSpace Complexcity - O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {     \\n    int b = INT_MIN,s = 0,p_sell = 0,p_buy;\\n        for(int stock : prices){\\n            p_buy = b;\\n            b = max(b, p_sell - stock);\\n            p_sell = s;\\n            s = max(s, p_buy + stock);  \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533754,
                "title": "i-believe-my-solution-is-the-most-intuitive-with-pictures-2-variables-to-keep-track-of",
                "content": "At a given day, we should take the maximum between:\\n* profit today + profit yesterday (assuming our stock grows well)\\n* profit the day before yesterday (assuming our stock has dropped, so the better idea might be to sell it the day before yesterday and have a cooldown yesterday).\\n\\nYou can also think of it as being greedy until you get in trouble. Then you travel back in time and sell it for a better price.\\n\\nThere are four key cases pictured below.\\n\\n1. The stock grows well, so we take profits day-to-day:\\n![image](https://assets.leetcode.com/users/yelizarov/image_1583717359.png)\\n2. The stock dropped, so we look back for a better deal:\\n![image](https://assets.leetcode.com/users/yelizarov/image_1583717442.png)\\n3. The stock dropped, so we look back for a better deal, but there\\'s none of them:\\n![image](https://assets.leetcode.com/users/yelizarov/image_1583717532.png)\\n4. The stock has dropped on the last trading day. This is the case to explain the need of the last `return Max` statement, so we take the previous day\\'s profit (3), not the last one (2):\\n![image](https://assets.leetcode.com/users/yelizarov/image_1583717826.png)\\n\\nHere\\'s a pretty self-explanatory code:\\n```\\n    public int MaxProfit(int[] prices) \\n    {\\n      if (prices == null)\\n      {\\n        return 0;\\n      }\\n      \\n      int profitYesterday = 0;\\n      int profitBeforeYesterday = 0;\\n      \\n      for (int i = 1; i < prices.Length; i++)\\n      {\\n        var priceToday = prices[i];\\n        var priceYesterday = prices[i - 1];\\n        var profitToday = priceToday - priceYesterday;\\n        var maxProfitToday = Math.Max(profitToday + profitYesterday, profitBeforeYesterday);\\n        \\n        profitBeforeYesterday = Math.Max(profitYesterday, profitBeforeYesterday);\\n        profitYesterday = maxProfitToday;\\n      }\\n      \\n      return Math.Max(profitYesterday, profitBeforeYesterday);\\n    }\\n```\\nI hope this helped someone!",
                "solutionTags": [],
                "code": "```\\n    public int MaxProfit(int[] prices) \\n    {\\n      if (prices == null)\\n      {\\n        return 0;\\n      }\\n      \\n      int profitYesterday = 0;\\n      int profitBeforeYesterday = 0;\\n      \\n      for (int i = 1; i < prices.Length; i++)\\n      {\\n        var priceToday = prices[i];\\n        var priceYesterday = prices[i - 1];\\n        var profitToday = priceToday - priceYesterday;\\n        var maxProfitToday = Math.Max(profitToday + profitYesterday, profitBeforeYesterday);\\n        \\n        profitBeforeYesterday = Math.Max(profitYesterday, profitBeforeYesterday);\\n        profitYesterday = maxProfitToday;\\n      }\\n      \\n      return Math.Max(profitYesterday, profitBeforeYesterday);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76005,
                "title": "o-n-java-solution-3ms",
                "content": "Basically for day i there are three types of action we can consider: sell, buy and cooldown.\\n\\nIf we want to buy, then i-1 day must be cooldown, so after buy today our portfolio value should be cooldown-prices[i]. if this number is small than buy itself, then we don't buy today.\\n\\nIf we want to cooldown, then i-1 day must be cooldown or sell. So we take the max of these two.\\n\\nIf we want to sell, then before day i, we must have position, so after sell our portfolio value should be day i-1's buy+prices[i]. if this value is smaller than sell itself, then we don't sell today.\\n    \\t\\n\\n              if (prices.length<2) return 0;\\n    \\tint buy = -prices[0], sell = 0, cooldown = 0;\\n    \\tfor(int i=1; i<prices.length; i++) {\\n    \\t\\tint temp = buy;\\n    \\t\\tbuy = Math.max(buy, cooldown-prices[i]);\\n    \\t\\tcooldown = Math.max(sell, cooldown);\\n    \\t\\tsell = Math.max(sell, temp+prices[i]);    \\t\\t\\n    \\t}\\n    \\treturn sell>cooldown?sell:cooldown;",
                "solutionTags": [],
                "code": "Basically for day i there are three types of action we can consider: sell, buy and cooldown.\\n\\nIf we want to buy, then i-1 day must be cooldown, so after buy today our portfolio value should be cooldown-prices[i]. if this number is small than buy itself, then we don't buy today.\\n\\nIf we want to cooldown, then i-1 day must be cooldown or sell. So we take the max of these two.\\n\\nIf we want to sell, then before day i, we must have position, so after sell our portfolio value should be day i-1's buy+prices[i]. if this value is smaller than sell itself, then we don't sell today.\\n    \\t\\n\\n              if (prices.length<2) return 0;\\n    \\tint buy = -prices[0], sell = 0, cooldown = 0;\\n    \\tfor(int i=1; i<prices.length; i++) {\\n    \\t\\tint temp = buy;\\n    \\t\\tbuy = Math.max(buy, cooldown-prices[i]);\\n    \\t\\tcooldown = Math.max(sell, cooldown);\\n    \\t\\tsell = Math.max(sell, temp+prices[i]);    \\t\\t\\n    \\t}\\n    \\treturn sell>cooldown?sell:cooldown;",
                "codeTag": "Unknown"
            },
            {
                "id": 804130,
                "title": "clean-explanation-state-machine-python-code",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n      \\n        \"\"\"\\n        We have three states:\\n            - s0: starting state, no stock, can rest or buy\\n            - s1: just bought stock, can rest or sell\\n            - s2: just sold stock, must rest\\n        \\n        The reason state s2 exists is that we want to force a rest between leaving s1 (previous sell) and s0 (next buy).\\n        \\n        Each state has the following actions:\\n            - s0:\\n                - s0 -> s0: no stock, rest\\n                - s0 -> s1: buy new stock\\n            - s1:\\n                - s1 -> s1: hold stock, rest\\n                - s1 -> s2: sell stock\\n            - s2:\\n                - s2 -> s0: forced rest\\n            \\n        Let sk[j], k = {0, 1, 2}, j = {0, 1, ..., n}, denote the profit at state sk on day j\\n        (e.g., s1[2] is the profit on day 2 if we happened to be there).\\n        \\n        We have the following ways to enter each state:\\n            - Entering s0[i]:\\n                - From s0[i-1]: rest on day i, so profit remains the same as s0[i-1]\\n                - From s2[i-1]: forced rest on day i, so profit remains the same as s2[i-1]\\n            - Entering s1[i]:\\n                - From s1[i-1]: rest on day i, so profit remains the same as s1[i-1]\\n                - From s0[i-1]: bought stocks on day i, so profit is updated to (s0[i-1]-profits[i])\\n            - Entering s2[i]:\\n                - From s1[i-1]: sold stock on day i, so profit is updated to (s1[i-1]+profits[i])\\n            \\n        Initial states:\\n            - s[0] = 0: you start with 0 profit on day 0\\n            - s1[0] = -prices[0]: if you bought stock on day 0, ur profit is -prices[0] \\n            - s2[0] = X: dummy state as you need two days to buy and sell\\n        \"\"\"\\n\\n        \\n        n = len(prices)\\n        if not n: \\n            return 0\\n        \\n        s0, s1, s2 = [0] * n, [0] * n, [0] * n \\n        \\n        s0[0] = 0\\n        s1[0] = -prices[0] \\n        s2[0] = 0 # dummy\\n        \\n        for i in range(1, n):\\n            s0[i] = max(s0[i-1], s2[i-1])\\n            s1[i] = max(s1[i-1], s0[i-1] - prices[i])\\n            s2[i] = s1[i-1] + prices[i]\\n        \\n        return max(s0[-1], s2[-1])\\n```\\n\\nLet me know if you have any questions. I\\'ll reply asap.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n      \\n        \"\"\"\\n        We have three states:\\n            - s0: starting state, no stock, can rest or buy\\n            - s1: just bought stock, can rest or sell\\n            - s2: just sold stock, must rest\\n        \\n        The reason state s2 exists is that we want to force a rest between leaving s1 (previous sell) and s0 (next buy).\\n        \\n        Each state has the following actions:\\n            - s0:\\n                - s0 -> s0: no stock, rest\\n                - s0 -> s1: buy new stock\\n            - s1:\\n                - s1 -> s1: hold stock, rest\\n                - s1 -> s2: sell stock\\n            - s2:\\n                - s2 -> s0: forced rest\\n            \\n        Let sk[j], k = {0, 1, 2}, j = {0, 1, ..., n}, denote the profit at state sk on day j\\n        (e.g., s1[2] is the profit on day 2 if we happened to be there).\\n        \\n        We have the following ways to enter each state:\\n            - Entering s0[i]:\\n                - From s0[i-1]: rest on day i, so profit remains the same as s0[i-1]\\n                - From s2[i-1]: forced rest on day i, so profit remains the same as s2[i-1]\\n            - Entering s1[i]:\\n                - From s1[i-1]: rest on day i, so profit remains the same as s1[i-1]\\n                - From s0[i-1]: bought stocks on day i, so profit is updated to (s0[i-1]-profits[i])\\n            - Entering s2[i]:\\n                - From s1[i-1]: sold stock on day i, so profit is updated to (s1[i-1]+profits[i])\\n            \\n        Initial states:\\n            - s[0] = 0: you start with 0 profit on day 0\\n            - s1[0] = -prices[0]: if you bought stock on day 0, ur profit is -prices[0] \\n            - s2[0] = X: dummy state as you need two days to buy and sell\\n        \"\"\"\\n\\n        \\n        n = len(prices)\\n        if not n: \\n            return 0\\n        \\n        s0, s1, s2 = [0] * n, [0] * n, [0] * n \\n        \\n        s0[0] = 0\\n        s1[0] = -prices[0] \\n        s2[0] = 0 # dummy\\n        \\n        for i in range(1, n):\\n            s0[i] = max(s0[i-1], s2[i-1])\\n            s1[i] = max(s1[i-1], s0[i-1] - prices[i])\\n            s2[i] = s1[i-1] + prices[i]\\n        \\n        return max(s0[-1], s2[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653875,
                "title": "python-3-dp-thought-process-clear-explanation-with-dp-array-for-each-state",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP - STATE MACHINE PATTERN ##\\n        ## LOGIC ##\\n        \\n        \"\"\"\\n        1. In general dynamic programming concept, we store maxprofit found till that index in dp[i], but this problem has many states i) buy ii) sell iii) cooldown \\n        \\n        2. if in case of multiple states, what we do in (say DP state machine pattern) is we store maximum for all the possible states i.e\\n            a) max profit with state = buy,      on day i\\n            b) max profit with state = cooldown, on day i\\n            c) max profit with state = sell,     on day i\\n        \\n        3. For this problem\\n            a) dp_buy[i] = we are buying on that day. But as per question you can only buy when previous day is cooldown. so only consider dp_cooldown[i-1] and also buying on day i, will cost you some money i.e price[i]. can be written as:\\n                ``` dp_buy[i] = dp_cooldown[i-1] - price[i] ```\\n            b) dp_cooldown[i] = we are doing nothing, so whatever you have done on previous day doesn\\'t matter. so take maximum of all previous states\\n                ``` dp_cooldown[i] = max( dp_cooldown[i-1], dp_buy[i-1], dp_sell[i-1] )  ```\\n            c) dp_sell[i] = before selling you have to buy, so we have to get max of previous_buy value from o to i. Instead of looping 0 to i, we can simply keep a max_prev_buy variable and keep track of it. And also by selling you are getting money i.e prices[i] so add prices[i] to max_prev_buy\\n                dp_sell[i] = (max profit you got before by buying stocks) + ( profit by selling this stock )\\n                ``` dp_sell[i] = max_prev_buy + prices[i]   ```\\n        \"\"\"\\n        \\n        if len(prices) < 2 : return 0\\n                \\n        n               = len(prices)\\n        dp_buy          = [0 for _ in range(n)]\\n        dp_cooldown     = [0 for _ in range(n)]\\n        dp_sell         = [0 for _ in range(n)]\\n        \\n        dp_cooldown[0]  = 0\\n        dp_buy[0]       = -prices[0]\\n        dp_sell[0]      = float(\\'-inf\\')\\n        max_prev_buy    = dp_buy[0]\\n        \\n        for i in range(1, n):\\n            dp_cooldown[i]  = max( dp_cooldown[i-1], dp_buy[i-1], dp_sell[i-1] )\\n            dp_buy[i]       = dp_cooldown[i-1] - prices[i]\\n            dp_sell[i]      = max_prev_buy + prices[i]\\n            \\n            max_prev_buy    = max( max_prev_buy, dp_buy[i] )\\n            \\n        return max( dp_cooldown[-1], dp_sell[-1] )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP - STATE MACHINE PATTERN ##\\n        ## LOGIC ##\\n        \\n        \"\"\"\\n        1. In general dynamic programming concept, we store maxprofit found till that index in dp[i], but this problem has many states i) buy ii) sell iii) cooldown \\n        \\n        2. if in case of multiple states, what we do in (say DP state machine pattern) is we store maximum for all the possible states i.e\\n            a) max profit with state = buy,      on day i\\n            b) max profit with state = cooldown, on day i\\n            c) max profit with state = sell,     on day i\\n        \\n        3. For this problem\\n            a) dp_buy[i] = we are buying on that day. But as per question you can only buy when previous day is cooldown. so only consider dp_cooldown[i-1] and also buying on day i, will cost you some money i.e price[i]. can be written as:\\n                ```\n```\\n            b) dp_cooldown[i] = we are doing nothing, so whatever you have done on previous day doesn\\'t matter. so take maximum of all previous states\\n                ```\n```\\n            c) dp_sell[i] = before selling you have to buy, so we have to get max of previous_buy value from o to i. Instead of looping 0 to i, we can simply keep a max_prev_buy variable and keep track of it. And also by selling you are getting money i.e prices[i] so add prices[i] to max_prev_buy\\n                dp_sell[i] = (max profit you got before by buying stocks) + ( profit by selling this stock )\\n                ```\n```\\n        \"\"\"\\n        \\n        if len(prices) < 2 : return 0\\n                \\n        n               = len(prices)\\n        dp_buy          = [0 for _ in range(n)]\\n        dp_cooldown     = [0 for _ in range(n)]\\n        dp_sell         = [0 for _ in range(n)]\\n        \\n        dp_cooldown[0]  = 0\\n        dp_buy[0]       = -prices[0]\\n        dp_sell[0]      = float(\\'-inf\\')\\n        max_prev_buy    = dp_buy[0]\\n        \\n        for i in range(1, n):\\n            dp_cooldown[i]  = max( dp_cooldown[i-1], dp_buy[i-1], dp_sell[i-1] )\\n            dp_buy[i]       = dp_cooldown[i-1] - prices[i]\\n            dp_sell[i]      = max_prev_buy + prices[i]\\n            \\n            max_prev_buy    = max( max_prev_buy, dp_buy[i] )\\n            \\n        return max( dp_cooldown[-1], dp_sell[-1] )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521889,
                "title": "easy-c-solution",
                "content": "```\\nint maxProfit(vector<int> &prices) {\\n    int buy(INT_MIN), sell(0), prev_sell(0), prev_buy;\\n    for (int price : prices) {\\n        prev_buy = buy;\\n        buy = max(prev_sell - price, buy);\\n        prev_sell = sell;\\n        sell = max(prev_buy + price, sell);\\n    }\\n    return sell;\\n}\\n```\\n\\nIf you like this plz upvote this",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int> &prices) {\\n    int buy(INT_MIN), sell(0), prev_sell(0), prev_buy;\\n    for (int price : prices) {\\n        prev_buy = buy;\\n        buy = max(prev_sell - price, buy);\\n        prev_sell = sell;\\n        sell = max(prev_buy + price, sell);\\n    }\\n    return sell;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75995,
                "title": "10-line-constant-space-o-n-complexity-dp-solution-in-c-4ms-added-explanation",
                "content": "Four states are used for the dp: buy, sell, coolDown and noOp, where noOp happens between buy and sell, coolDown happens between sell and buy.\\n\\nIt is actually much more straight forward if you use O(n) space. \\n\\nbuy[i] -- buy stock i\\n\\nsell[i] -- sell stock i\\n\\nnoOp[i] -- no operation for stock i, but have one stock at hand\\n\\ncoolDown[i] -- no operation for stock i, and have no stock at hand.\\n\\n\\nThen the update works as buy[i] = coolDown[i-1]-prices[i], coolDown[i] = max(coolDown[i-1], sell[i-1]), noOp[i] = max[noOp[i-1], buy[i-1]]] and sell[i] = max(noOp[i-1], buy[i-1]) + prices[i].\\n\\nThe constant space solution readily follows this since current states for price i only depends on previous states for price i-1.\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int buy = INT_MIN, noOp = INT_MIN;\\n            int coolDown = 0, sell = 0;\\n            for (int p : prices) {\\n                noOp = max(noOp, buy);\\n                buy = coolDown - p;\\n                coolDown = max(coolDown, sell);\\n                sell = noOp + p;\\n            }\\n            return max(coolDown, sell);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int buy = INT_MIN, noOp = INT_MIN;\\n            int coolDown = 0, sell = 0;\\n            for (int p : prices) {\\n                noOp = max(noOp, buy);\\n                buy = coolDown - p;\\n                coolDown = max(coolDown, sell);\\n                sell = noOp + p;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2941150,
                "title": "simple-dp",
                "content": "No state machine, only simple DP\\n\\n`b[i]` is the max profit until i while last action is BUY\\n`s[i]` is the max profit until i while last action is SELL\\n\\n# Code\\n```py\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n == 1: return 0\\n        b = [-10 ** 9] * n\\n        s = [0] * n\\n        for i in range(n):\\n            s[i] = max(s[i - 1], prices[i] + b[i - 1])\\n            b[i] = max(b[i - 1], s[i - 2] - prices[i])\\n        return s[-1]\\n```\\nSpace optimized\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        b = -10 ** 9\\n        s = 0\\n        s2 = 0      # s[i - 2]\\n        for i in range(len(prices)):\\n            b = max(b, s2 - prices[i])\\n            s2 = s  # update s[i - 2] for next iteration\\n            s = max(s, b + prices[i])\\n        return s\\n```\\nnote that \\n`s[i] = max(s[i - 1], b[i] + prices[i])`\\n`s[i] = max(s[i - 1], b[i - 1] + prices[i])`\\nwon\\'t affect the result.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n == 1: return 0\\n        b = [-10 ** 9] * n\\n        s = [0] * n\\n        for i in range(n):\\n            s[i] = max(s[i - 1], prices[i] + b[i - 1])\\n            b[i] = max(b[i - 1], s[i - 2] - prices[i])\\n        return s[-1]\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        b = -10 ** 9\\n        s = 0\\n        s2 = 0      # s[i - 2]\\n        for i in range(len(prices)):\\n            b = max(b, s2 - prices[i])\\n            s2 = s  # update s[i - 2] for next iteration\\n            s = max(s, b + prices[i])\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306235,
                "title": "different-dp-python-solutions-with-thinking-process",
                "content": "Please see and vote for my different solutions with thinking process.\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/306438/Python-O(n)-solution-with-thinking-process)\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/306427/Different-O(n)-Python-solutions-with-thinking-process)\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/306235/Different-DP-Python-solutions-with-thinking-process)\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/306282/Different-DP-Python-solutions-with-thinking-process)\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/444413/Different-Python-solutions-with-thinking-process-to-solve-the-series-of-stock-problems)\\n\\n**Method 1: DP algorithm with O(n) time and O(1) space**\\n\\nFor each day, there are 3 possible actions: buy, sell, nothing. Let us define\\nbuy[i] = maxProfit of prices[:i+1] with the action buy at day i,\\nsell[i] = maxProfit of prices[:i+1] with the action sell at day i,\\nnothing[i] = maxProfit of prices[:i+1] with the action nothing at day i.\\n\\nThe base cases are buy[0] = -prices[0], sell[0] = nothing[0] = 0. \\nThe recursive relationships are \\nbuy[i]  = max(nothing[i-1] - prices[i], buy[i-1])  # if buy at day i then the action at day i-1 must be nothing\\nsell[i] = max(buy[i-1]+prices[i], sell[i-1])\\nnothing[i] = max(sell[i-1], buy[i-1], nothing[i-1]).\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        prev_buy, prev_sell, prev_nothing = -prices[0], 0, 0\\n        for i in range(1, n):\\n            buy  = max(prev_nothing - prices[i], prev_buy) \\n            sell = max(prev_buy + prices[i], prev_sell)\\n            nothing = max(prev_sell, prev_buy, prev_nothing)\\n            prev_buy, prev_sell, prev_nothing = buy, sell, nothing\\n        return max(sell, nothing)\\n```\\n\\n**Method 2: DP algorithm with O(n^2) time and O(n) space**\\nLet dp[i] = maxProfit of prices[:i+1], the base cases and recursive relationship are\\n(i) dp[i] = 0 if i <= 0\\n(ii) dp[i] = max(dp[i-1], prices[i] - prices[j] + dp[j-2] for j from 0 to i-1)\\nBecause we have two choices at day i: (1) do nothing at day i, (2) maxProfit of prices[:j-1], cooldown at day j-1, buy at day j, sell at day i.\\n\\nSolution 2: bottom-up approach with a table (Beat 5.04% )\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1]\\n            for j in range(i):\\n                tmp = prices[i] - prices[j]\\n                tmp += dp[j-2] if j > 1 else 0\\n                dp[i] = max(dp[i], tmp)\\n        return dp[n-1]\\n```\\n\\nSolution 3:  top-down approach with memoization (Time Limit Exceeded, 210 / 211 test cases passed.)\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def recursive(i):\\n            if i <= 0:\\n                return 0\\n            if i in mp:\\n                return mp[i]\\n            max_profit = recursive(i - 1)\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] + recursive(j - 2)\\n                max_profit = max(max_profit, tmp)\\n            mp[i] = max_profit\\n            return mp[i]\\n        \\n        mp = {}\\n        return recursive(len(prices) - 1)\\n```\\n\\n**Method 3: DP algorithm with O(n^2) time and O(n) space** (Beat 22.67%)\\nLet dp[i] = maxProfit of prices[:i+1], the base cases and recursive relationship are\\n(i) dp[i] = 0 if i <= 0\\n(ii) dp[i] = max(dp[i-1], prices[i] - prices[j] + dp[j-2] for j from 0 to i-1)\\n**We can further use DP to get local_max = - prices[j] + dp[j-2] for j from 0 to i-1.**\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        local_max = -prices[0]\\n        for i in range(1, n):\\n            dp[i] = max(dp[i-1], prices[i] + local_max)\\n            local_max = max(local_max, dp[i-2] - prices[i])\\n        return dp[n-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        prev_buy, prev_sell, prev_nothing = -prices[0], 0, 0\\n        for i in range(1, n):\\n            buy  = max(prev_nothing - prices[i], prev_buy) \\n            sell = max(prev_buy + prices[i], prev_sell)\\n            nothing = max(prev_sell, prev_buy, prev_nothing)\\n            prev_buy, prev_sell, prev_nothing = buy, sell, nothing\\n        return max(sell, nothing)\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1]\\n            for j in range(i):\\n                tmp = prices[i] - prices[j]\\n                tmp += dp[j-2] if j > 1 else 0\\n                dp[i] = max(dp[i], tmp)\\n        return dp[n-1]\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def recursive(i):\\n            if i <= 0:\\n                return 0\\n            if i in mp:\\n                return mp[i]\\n            max_profit = recursive(i - 1)\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] + recursive(j - 2)\\n                max_profit = max(max_profit, tmp)\\n            mp[i] = max_profit\\n            return mp[i]\\n        \\n        mp = {}\\n        return recursive(len(prices) - 1)\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        local_max = -prices[0]\\n        for i in range(1, n):\\n            dp[i] = max(dp[i-1], prices[i] + local_max)\\n            local_max = max(local_max, dp[i-2] - prices[i])\\n        return dp[n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 700298,
                "title": "simple-explanation-recursive-memo-iterative",
                "content": "Let\\'s make an recursive solution first..\\nso... for each transaction we have two option...\\n1: We can sell the stock \\n\\t\\t\\tIf we sell the stock then we can\\'t buy the stock just next day cause of cooldown \\n2: or buy\\n\\t\\t\\tWe can buy stock if and only if there is no onGoing transaction..\\nSo let\\'s have a look of recursive solution\\n\\n```\\nint maxProfit(vector<int> &price ,unsigned int len=0 , bool onGoing=false){\\n\\tif(len>=price.size())\\treturn 0;\\n\\tint ans=0;\\n\\tif(onGoing){\\n\\t\\t//then we have two choice either i can sell the current running stock or not\\n\\t\\tint sell=maxProfit(price , len+2 , false)+price[len];\\n\\t\\tint notSell=maxProfit(price , len+1 , onGoing);\\n\\t\\tans=max(sell , notSell);\\n\\t}else{\\n\\t\\t//we have two choice either we can perchase a new stock or not\\n\\t\\tint perchased=maxProfit(price  , len+1 ,true)-price[len];\\n\\t\\tint notPerchased=maxProfit(price , len+1 , false);\\n\\t\\tans=max(perchased , notPerchased);\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nNow if we look carefully in our recursive solution then we would find that there are only two variable\\ni.e.\\n1. Len (Remaining stock days)\\n2. OnGoing Transaction\\nBecause for each transaction it is possible that either an onGoing transaction or not...\\nSo apply memoization on two variable len,onGoing\\n```\\nint maxProfit(vector<int> & price){\\n\\tint **dp=new int*[2];\\n\\t//size 2 cause on each stock price we have two condition weather any onGoing transaction or nots\\n\\tdp[0]=new int[price.size()];\\n\\tdp[1]=new int[price.size()];\\n\\tfor(unsigned int i=0 ; i <price.size() ; i++)\\n\\t{\\n\\t\\tdp[0][i]=-1;\\n\\t\\tdp[1][i]=-1;\\n\\t}\\n\\tint ans=solve(price,dp);\\n\\t//we have created the memory on heap so we should release that memory before returning the function\\n\\tdelete []dp[0];\\n\\tdelete []dp[1];\\n\\treturn ans;\\n}\\nint solve(vector<int> &price ,int **dp ,unsigned int len=0  , bool onGoing=false){\\n\\tif(len>=price.size()) return 0;//we can\\'t make money further\\n\\t//before calling the function we should check weather we have any solution for that or not\\n\\tif(dp[onGoing][len]!=-1) return dp[onGoing][len];\\n\\tint ans=0;\\n\\tif(onGoing){\\n\\t\\t//we have two choice \\n\\t\\t//either we can sell the stock\\n\\t\\tint sell=solve(price , dp , len+2 , false)+price[len];//if we sell,we get the money of current price\\n\\t\\t//or not\\n\\t\\tint notSell=solve(price ,dp ,len+1 , onGoing);\\n\\t\\tans=max(sell , notSell);\\n\\t}else{\\n\\t\\t//we have two choice either we can buy or not\\n\\t\\tint buy=solve(price  , dp , len+1 , true)-price[len];//if we perchase then have to pay\\n\\t\\tint notBuy=solve(price , dp , len+1 ,false);\\n\\t\\tans=max(buy , notBuy);\\n\\t}\\n\\t//store the ans for current onGoing and len for future use to stop duplicates calls\\n\\tdp[onGoing][len]=ans;\\n\\treturn ans;\\n}\\n```\\nAnd now turn comes to very conceptual part..\\nMake our recursive solution as iterative..\\nSo have a look how the array was feeling in recursive solution with memoization and let\\'s try to feel as a iterative..And rest of thing my comment would make clear\\n```\\nint maxProfit(vector<int> & price){\\n\\tif(price.size()<2) return 0;//for avoid heap buffer error for null price list\\n\\tint **dp=new int*[2];\\n\\tdp[0]=new int[price.size()];// no ongoing transaction\\n\\tdp[1]=new int[price.size()];//Yes OnGoing transaction\\n\\tdp[0][0]=0;//cause no sell ,no buy , no profit\\n\\tdp[1][0]=-price[0];//cause have bought one stock and did not yet sell.. so profit will be -price[0]\\n\\tdp[0][1]=max(0,dp[1][0]+price[1]);//we sell first stock just next day\\n\\tdp[1][1]=max(dp[1][0],-price[1]);//max of(we make a new transaction with first stock price,or same as before)\\n\\n\\tfor(unsigned int i =2 ; i<price.size() ; i++){\\n\\t\\tdp[0][i]=max(dp[0][i-1] , dp[1][i-1]+price[i]);\\n\\t\\t//i.e. max of(skip the current stock , or make a transaction)\\n\\t\\tdp[1][i]=max(dp[0][i-2]-price[i] ,dp[1][i-1]);\\n\\t\\t//i.e. max of(make a transaction from i-2 as a cool down with 0(no ongoing transaction) , or let this transaction as onGoing)\\n\\t}\\n\\tint ans=max(dp[0][price.size()-1] , dp[1][price.size()-1]);\\n\\t//since we have created memory on heap so before returning the function we should clear it..\\n\\tdelete []dp;\\n\\treturn ans;\\n}\\n```\\nHope you got my point..\\nHappy Coding....",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint maxProfit(vector<int> &price ,unsigned int len=0 , bool onGoing=false){\\n\\tif(len>=price.size())\\treturn 0;\\n\\tint ans=0;\\n\\tif(onGoing){\\n\\t\\t//then we have two choice either i can sell the current running stock or not\\n\\t\\tint sell=maxProfit(price , len+2 , false)+price[len];\\n\\t\\tint notSell=maxProfit(price , len+1 , onGoing);\\n\\t\\tans=max(sell , notSell);\\n\\t}else{\\n\\t\\t//we have two choice either we can perchase a new stock or not\\n\\t\\tint perchased=maxProfit(price  , len+1 ,true)-price[len];\\n\\t\\tint notPerchased=maxProfit(price , len+1 , false);\\n\\t\\tans=max(perchased , notPerchased);\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nint maxProfit(vector<int> & price){\\n\\tint **dp=new int*[2];\\n\\t//size 2 cause on each stock price we have two condition weather any onGoing transaction or nots\\n\\tdp[0]=new int[price.size()];\\n\\tdp[1]=new int[price.size()];\\n\\tfor(unsigned int i=0 ; i <price.size() ; i++)\\n\\t{\\n\\t\\tdp[0][i]=-1;\\n\\t\\tdp[1][i]=-1;\\n\\t}\\n\\tint ans=solve(price,dp);\\n\\t//we have created the memory on heap so we should release that memory before returning the function\\n\\tdelete []dp[0];\\n\\tdelete []dp[1];\\n\\treturn ans;\\n}\\nint solve(vector<int> &price ,int **dp ,unsigned int len=0  , bool onGoing=false){\\n\\tif(len>=price.size()) return 0;//we can\\'t make money further\\n\\t//before calling the function we should check weather we have any solution for that or not\\n\\tif(dp[onGoing][len]!=-1) return dp[onGoing][len];\\n\\tint ans=0;\\n\\tif(onGoing){\\n\\t\\t//we have two choice \\n\\t\\t//either we can sell the stock\\n\\t\\tint sell=solve(price , dp , len+2 , false)+price[len];//if we sell,we get the money of current price\\n\\t\\t//or not\\n\\t\\tint notSell=solve(price ,dp ,len+1 , onGoing);\\n\\t\\tans=max(sell , notSell);\\n\\t}else{\\n\\t\\t//we have two choice either we can buy or not\\n\\t\\tint buy=solve(price  , dp , len+1 , true)-price[len];//if we perchase then have to pay\\n\\t\\tint notBuy=solve(price , dp , len+1 ,false);\\n\\t\\tans=max(buy , notBuy);\\n\\t}\\n\\t//store the ans for current onGoing and len for future use to stop duplicates calls\\n\\tdp[onGoing][len]=ans;\\n\\treturn ans;\\n}\\n```\n```\\nint maxProfit(vector<int> & price){\\n\\tif(price.size()<2) return 0;//for avoid heap buffer error for null price list\\n\\tint **dp=new int*[2];\\n\\tdp[0]=new int[price.size()];// no ongoing transaction\\n\\tdp[1]=new int[price.size()];//Yes OnGoing transaction\\n\\tdp[0][0]=0;//cause no sell ,no buy , no profit\\n\\tdp[1][0]=-price[0];//cause have bought one stock and did not yet sell.. so profit will be -price[0]\\n\\tdp[0][1]=max(0,dp[1][0]+price[1]);//we sell first stock just next day\\n\\tdp[1][1]=max(dp[1][0],-price[1]);//max of(we make a new transaction with first stock price,or same as before)\\n\\n\\tfor(unsigned int i =2 ; i<price.size() ; i++){\\n\\t\\tdp[0][i]=max(dp[0][i-1] , dp[1][i-1]+price[i]);\\n\\t\\t//i.e. max of(skip the current stock , or make a transaction)\\n\\t\\tdp[1][i]=max(dp[0][i-2]-price[i] ,dp[1][i-1]);\\n\\t\\t//i.e. max of(make a transaction from i-2 as a cool down with 0(no ongoing transaction) , or let this transaction as onGoing)\\n\\t}\\n\\tint ans=max(dp[0][price.size()-1] , dp[1][price.size()-1]);\\n\\t//since we have created memory on heap so before returning the function we should clear it..\\n\\tdelete []dp;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761742,
                "title": "java-dp-explained-in-detail-1-ms",
                "content": "If you found the solution helpful, kindly upvote or like. :)\\n\\n**MAIN IDEA**\\n1. We already have a stock on day i : stored in dp[i][1] (we will select max of the 2)\\n    \\t a. We already have it from previous day: dp[i-1][1]\\n    \\t  \\tb. We bought it today: dp[i-2][0]-prices[i] \\n    \\t  \\t\\t\\tWe do dp[i-2] because, one day is left for cooldown \\n2. We have no stock on day i : stored in dp[i][0] (we will select max of the 2)\\n    \\t   a. We sell it today : dp[i-1][1] + prices[i]\\n    \\t  \\tb. We did not have a stock earlier too : dp[i-1][0]\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length<=1) return 0;\\n    \\t//As you saw in the idea, we need to first compute the values for first 2 days\\n    \\tif(prices.length==2)\\n    \\t\\treturn prices[0]>prices[1] ? 0: prices[1]-prices[0];\\n    \\t\\t\\n    \\tint[][] dp= new int[prices.length][2];\\n    \\t//Evaluating the values for the first 2 days\\n    \\tdp[0][0]=0;\\n    \\tdp[0][1]=-prices[0];\\t//If we buy on first day, we need to pay the prices\\n    \\tdp[1][0]=Math.max(dp[0][1]+prices[1], dp[0][0]);\\n    \\tdp[1][1] = Math.max(dp[0][0]-prices[1], dp[0][1]);\\n    \\t\\n    \\t\\n    \\tfor(int i=2; i<prices.length; i++)\\n    \\t{\\n    \\t\\tdp[i][0]=Math.max(dp[i-1][1]+prices[i], dp[i-1][0]);\\n        \\tdp[i][1] = Math.max(dp[i-2][0]-prices[i], dp[i-1][1]);\\n    \\t}\\n    \\treturn dp[prices.length-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length<=1) return 0;\\n    \\t//As you saw in the idea, we need to first compute the values for first 2 days\\n    \\tif(prices.length==2)\\n    \\t\\treturn prices[0]>prices[1] ? 0: prices[1]-prices[0];\\n    \\t\\t\\n    \\tint[][] dp= new int[prices.length][2];\\n    \\t//Evaluating the values for the first 2 days\\n    \\tdp[0][0]=0;\\n    \\tdp[0][1]=-prices[0];\\t//If we buy on first day, we need to pay the prices\\n    \\tdp[1][0]=Math.max(dp[0][1]+prices[1], dp[0][0]);\\n    \\tdp[1][1] = Math.max(dp[0][0]-prices[1], dp[0][1]);\\n    \\t\\n    \\t\\n    \\tfor(int i=2; i<prices.length; i++)\\n    \\t{\\n    \\t\\tdp[i][0]=Math.max(dp[i-1][1]+prices[i], dp[i-1][0]);\\n        \\tdp[i][1] = Math.max(dp[i-2][0]-prices[i], dp[i-1][1]);\\n    \\t}\\n    \\treturn dp[prices.length-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522223,
                "title": "c-recursive-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[5002][2];\\n    int solve(vector<int>& prices, int idx, bool hold){\\n        if(idx>=prices.size()) return 0;\\n        if(dp[idx][hold]!=-1) return dp[idx][hold];\\n        \\n        if(!hold){\\n            int buy = solve(prices,idx+1,true)-prices[idx];\\n            int notbuy = solve(prices,idx+1,false);\\n            return dp[idx][hold] = max(buy,notbuy);\\n        }else{\\n             int sell = solve(prices,idx+2,false)+prices[idx];\\n             int notsell = solve(prices,idx+1,true);\\n            return dp[idx][hold] = max(sell,notsell);\\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,false);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5002][2];\\n    int solve(vector<int>& prices, int idx, bool hold){\\n        if(idx>=prices.size()) return 0;\\n        if(dp[idx][hold]!=-1) return dp[idx][hold];\\n        \\n        if(!hold){\\n            int buy = solve(prices,idx+1,true)-prices[idx];\\n            int notbuy = solve(prices,idx+1,false);\\n            return dp[idx][hold] = max(buy,notbuy);\\n        }else{\\n             int sell = solve(prices,idx+2,false)+prices[idx];\\n             int notsell = solve(prices,idx+1,true);\\n            return dp[idx][hold] = max(sell,notsell);\\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521733,
                "title": "python-linear-dp-w-brief-explanation-of-state",
                "content": "If we end up with no stock at the end of the day, but we didn\\'t end in cooldown, then we didn\\'t own stock yesterday (may have sold it yesterday or not).\\n\\nIf we own stock at the end of the day, then either we owned stock yesterday, or we just bought it.\\n\\nIf we are in cooldown at the end of the day, then we must have sold stock today.\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        #dp[day][0] = max profit could have if we don\\'t own stock at end of day\\n        #dp[day][1] = max profit could have if we own stock at end of day\\n        #dp[day][2] = max profit could have if we are in cooldown at end of day\\n        dp = [[0 for _ in range(3)] for _ in range(len(prices))]\\n        dp[0][1] -= prices[0]\\n        for i in range(1, len(prices)):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][2])\\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n            dp[i][2] = dp[i-1][1] + prices[i]\\n\\n        return max(dp[-1])\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        #dp[day][0] = max profit could have if we don\\'t own stock at end of day\\n        #dp[day][1] = max profit could have if we own stock at end of day\\n        #dp[day][2] = max profit could have if we are in cooldown at end of day\\n        dp = [[0 for _ in range(3)] for _ in range(len(prices))]\\n        dp[0][1] -= prices[0]\\n        for i in range(1, len(prices)):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][2])\\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n            dp[i][2] = dp[i-1][1] + prices[i]\\n\\n        return max(dp[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 762176,
                "title": "intuition-to-recursion-to-memoization-to-dp",
                "content": "Well, I am not much expert in DP, just got enthusiastic and interested in learning DSA for last 5-6 months or so. After some practice in DP, I was very confident. So, when I saw the question I tried to design DP table and try to build a formula, but that cooldown time condition always pushed me back to think from beginning, so finally decided to go in old school way, i.e. to think of a recursive approach first by intuition, then definitely top-down/bottom-up gonna be piece of cake.\\nSo, here how I thought of it -\\nlets d1 and d2 be the days of buying and selling stock respectively (obs. d1 < d2), now have following things to consider:\\n1. if price on d1 is less than price on d2, then\\n\\tprofit at d2 = prices[d2] - prices[d1] + (profit on the days which are greater than d2 + cooldown)\\n2. Okay, so even we can sell the stock on the other day if it can bring more profit.\\n3. if price on d1 is greater than price on d2, then,\\n\\t\\twe will take next day of d1 and restart the process. Here, someone can argue that why don\\'t we choose another day to sell when stock price is more. Well, this condition is already covered in step 2, so we will pick next buying day instead.\\n\\nSo, here\\'s the recursive sudo code (assuming recursive function getMaxProfit(buyIdx, sellIdx)):\\nif(prices[buyIdx] < prices[sellIdx]):\\n\\tmaxProfit = max of {prices[sellIdx] - prices[buyIdx] + getMaxProfit(sellIdx + 2, sellIdx + 3)[if we sell stock on sellIdx, next transaction must happen from index **sellIdx + 2** (next to sellIdx + **1** for cooldown]} and {getMaxProfit(buyIdx, sellIdx + 1)} (condition 1, 2)\\nelse:\\nmaxProfit = getMaxProfit(buyIdx + 1, buyIdx + 2) (condition 3)\\n\\nComplete Code:\\n```\\nint getMaxProfit(int[] prices, int bIdx, int sIdx){        \\n        if(bIdx >= prices.length || sIdx >= prices.length) return 0; \\n        if(prices[sIdx] > prices[bIdx])\\n            return Math.max(prices[sIdx] - prices[bIdx] + \\n                                  getMaxProfit(prices, sIdx + 2, sIdx + 3), \\n                                  getMaxProfit(prices, bIdx, sIdx + 1));\\n        else\\n            return getMaxProfit(prices, bIdx + 1, bIdx + 2);    \\n    }\\n```\\nNow, if the solution is correct it will definitely throw TLE, as runtime complexity is exponential - O(2^n). Well it did so but made me happy, as memoization approach is opened after that -\\n```\\nint getMaxProfit(int[] prices, int bIdx, int sIdx, int[][] memo){        \\n        if(bIdx >= prices.length || sIdx >= prices.length) return 0;        \\n        if(memo[bIdx][sIdx] != 0) return memo[bIdx][sIdx];\\n        if(prices[sIdx] > prices[bIdx])\\n            memo[bIdx][sIdx] = Math.max(prices[sIdx] - prices[bIdx] + \\n                                  getMaxProfit(prices, sIdx + 2, sIdx + 3, memo), \\n                                  getMaxProfit(prices, bIdx, sIdx + 1, memo));\\n        else\\n            memo[bIdx][sIdx] = getMaxProfit(prices, bIdx + 1, bIdx + 2, memo);\\n        \\n        return memo[bIdx][sIdx];\\n    }\\n```\\nAwesome, so we have our O(n) runtime working solution. So, lets take it further and build our bottom-up solution:\\n```\\n\\t\\tint[][] dp = new int[prices.length][prices.length];\\n        for(int i = dp.length - 2; i >= 0; i--){\\n            for(int j = dp.length - 1; j > i; j--){\\n                if(prices[j] > prices[i])\\n                    dp[i][j] = Math.max(dpUtil(dp, i, j + 1), \\n                                        prices[j] - prices[i] + dpUtil(dp, j + 2, j + 3));\\n                else\\n                    dp[i][j] = dpUtil(dp, i + 1, i + 2);\\n            }\\n        }        \\n        return dp[0][1];\\n```\\nwhere dpUtil is to check valid index -\\n```\\nint dpUtil(int[][] dp, int i, int j){\\n        if(i >= dp.length || j >= dp.length) return 0;\\n        return dp[i][j];\\n    }\\n```\\n\\n**Note:** We can sell from index 1 only, hence dp[0][1] will have our final answer.\\n\\nFull working code:\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length < 2) return 0;\\n        //-----Bottom-Up DP start-----\\n        int[][] dp = new int[prices.length][prices.length];\\n        for(int i = dp.length - 2; i >= 0; i--){\\n            for(int j = dp.length - 1; j > i; j--){\\n                if(prices[j] > prices[i])\\n                    dp[i][j] = Math.max(dpUtil(dp, i, j + 1), \\n                                        prices[j] - prices[i] + dpUtil(dp, j + 2, j + 3));\\n                else\\n                    dp[i][j] = dpUtil(dp, i + 1, i + 2);\\n            }\\n        }        \\n        return dp[0][1];\\n        //-----Bottom-Up DP end------\\n        \\n        //int[][] memo = new int[prices.length][prices.length];\\n        //return getMaxProfit(prices, 0, 1, memo);\\n    }\\n    \\n    //Check whether index is valid\\n    int dpUtil(int[][] dp, int i, int j){\\n        if(i >= dp.length || j >= dp.length) return 0;\\n        return dp[i][j];\\n    }\\n    \\n    //Top-Down DP\\n    int getMaxProfit(int[] prices, int bIdx, int sIdx, int[][] memo){        \\n        if(bIdx >= prices.length || sIdx >= prices.length) return 0;        \\n        if(memo[bIdx][sIdx] != 0) return memo[bIdx][sIdx];\\n        if(prices[sIdx] > prices[bIdx])\\n            memo[bIdx][sIdx] = Math.max(prices[sIdx] - prices[bIdx] + \\n                                  getMaxProfit(prices, sIdx + 2, sIdx + 3, memo), \\n                                  getMaxProfit(prices, bIdx, sIdx + 1, memo));\\n        else\\n            memo[bIdx][sIdx] = getMaxProfit(prices, bIdx + 1, bIdx + 2, memo);\\n        \\n        return memo[bIdx][sIdx];\\n    }\\n}\\n```\\n\\nFurther optimization or suggestion are higly welcomed. Hope it helps a beginner like me :)",
                "solutionTags": [],
                "code": "```\\nint getMaxProfit(int[] prices, int bIdx, int sIdx){        \\n        if(bIdx >= prices.length || sIdx >= prices.length) return 0; \\n        if(prices[sIdx] > prices[bIdx])\\n            return Math.max(prices[sIdx] - prices[bIdx] + \\n                                  getMaxProfit(prices, sIdx + 2, sIdx + 3), \\n                                  getMaxProfit(prices, bIdx, sIdx + 1));\\n        else\\n            return getMaxProfit(prices, bIdx + 1, bIdx + 2);    \\n    }\\n```\n```\\nint getMaxProfit(int[] prices, int bIdx, int sIdx, int[][] memo){        \\n        if(bIdx >= prices.length || sIdx >= prices.length) return 0;        \\n        if(memo[bIdx][sIdx] != 0) return memo[bIdx][sIdx];\\n        if(prices[sIdx] > prices[bIdx])\\n            memo[bIdx][sIdx] = Math.max(prices[sIdx] - prices[bIdx] + \\n                                  getMaxProfit(prices, sIdx + 2, sIdx + 3, memo), \\n                                  getMaxProfit(prices, bIdx, sIdx + 1, memo));\\n        else\\n            memo[bIdx][sIdx] = getMaxProfit(prices, bIdx + 1, bIdx + 2, memo);\\n        \\n        return memo[bIdx][sIdx];\\n    }\\n```\n```\\n\\t\\tint[][] dp = new int[prices.length][prices.length];\\n        for(int i = dp.length - 2; i >= 0; i--){\\n            for(int j = dp.length - 1; j > i; j--){\\n                if(prices[j] > prices[i])\\n                    dp[i][j] = Math.max(dpUtil(dp, i, j + 1), \\n                                        prices[j] - prices[i] + dpUtil(dp, j + 2, j + 3));\\n                else\\n                    dp[i][j] = dpUtil(dp, i + 1, i + 2);\\n            }\\n        }        \\n        return dp[0][1];\\n```\n```\\nint dpUtil(int[][] dp, int i, int j){\\n        if(i >= dp.length || j >= dp.length) return 0;\\n        return dp[i][j];\\n    }\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length < 2) return 0;\\n        //-----Bottom-Up DP start-----\\n        int[][] dp = new int[prices.length][prices.length];\\n        for(int i = dp.length - 2; i >= 0; i--){\\n            for(int j = dp.length - 1; j > i; j--){\\n                if(prices[j] > prices[i])\\n                    dp[i][j] = Math.max(dpUtil(dp, i, j + 1), \\n                                        prices[j] - prices[i] + dpUtil(dp, j + 2, j + 3));\\n                else\\n                    dp[i][j] = dpUtil(dp, i + 1, i + 2);\\n            }\\n        }        \\n        return dp[0][1];\\n        //-----Bottom-Up DP end------\\n        \\n        //int[][] memo = new int[prices.length][prices.length];\\n        //return getMaxProfit(prices, 0, 1, memo);\\n    }\\n    \\n    //Check whether index is valid\\n    int dpUtil(int[][] dp, int i, int j){\\n        if(i >= dp.length || j >= dp.length) return 0;\\n        return dp[i][j];\\n    }\\n    \\n    //Top-Down DP\\n    int getMaxProfit(int[] prices, int bIdx, int sIdx, int[][] memo){        \\n        if(bIdx >= prices.length || sIdx >= prices.length) return 0;        \\n        if(memo[bIdx][sIdx] != 0) return memo[bIdx][sIdx];\\n        if(prices[sIdx] > prices[bIdx])\\n            memo[bIdx][sIdx] = Math.max(prices[sIdx] - prices[bIdx] + \\n                                  getMaxProfit(prices, sIdx + 2, sIdx + 3, memo), \\n                                  getMaxProfit(prices, bIdx, sIdx + 1, memo));\\n        else\\n            memo[bIdx][sIdx] = getMaxProfit(prices, bIdx + 1, bIdx + 2, memo);\\n        \\n        return memo[bIdx][sIdx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602694,
                "title": "javascript-dp-with-state-machine-t-o-n-s-o-1",
                "content": "**Idea:**\\n1. At the end of every day, we have 3 diffent state: HOLD, SOLD, REST\\n\\n* HOLD: we bought a stock today. Or, we had a stock already, and we did nothing today;\\n* SOLD: we sold a stock today.\\n* REST: we cooled down one day after we sold a stock. Or, we just did noting today.\\n![image](https://assets.leetcode.com/users/andrewlin618/image_1588138111.png)\\n*(every arrow in the diagram means the possible operation between states)*\\n\\n2. Today\\'s state is transfered from yesterday\\'s state;\\n* today: Hold    =>   yesterday: Hold  or  Rest;\\n* today: Sold    =>   yesterday: Hold;\\n* today: Rest    =>   yesterday: Sold or Rest;\\n\\n**Solution:**\\n1. We can use 3 variables : hold, sold, rest to represent the max possible profit under different state;\\n2. We can also use array to track every day\\'s state, but because today\\'s state is only related to yesterday\\'s state, we use integer to save some space.\\n3. Time: O(N); Space: O(1);\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let hold = -Infinity, sold = 0, rest = 0;\\n    for (let i = 0; i < prices.length; i++) {\\n        let nextHold = Math.max(hold, rest - prices[i]);\\n        let nextSold = hold + prices[i];\\n        let nextRest = Math.max(rest, sold);\\n        hold = nextHold;\\n        sold = nextSold;\\n        rest = nextRest;\\n    }\\n    return Math.max(sold, rest);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let hold = -Infinity, sold = 0, rest = 0;\\n    for (let i = 0; i < prices.length; i++) {\\n        let nextHold = Math.max(hold, rest - prices[i]);\\n        let nextSold = hold + prices[i];\\n        let nextRest = Math.max(rest, sold);\\n        hold = nextHold;\\n        sold = nextSold;\\n        rest = nextRest;\\n    }\\n    return Math.max(sold, rest);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76000,
                "title": "easy-understand-java-dp-solution-with-comments",
                "content": "O(n) time and O(2n) space\\n\\n    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            if(prices == null || prices.length < 2){\\n                return 0;\\n            }\\n            int len = prices.length;\\n            int[] sell = new int[len]; //sell[i] means must sell at day i\\n            int[] cooldown = new int[len]; //cooldown[i] means day i is cooldown day\\n            sell[1] = prices[1] - prices[0];\\n            for(int i = 2; i < prices.length; ++i){\\n                cooldown[i] = Math.max(sell[i - 1], cooldown[i - 1]);\\n                sell[i] = prices[i] - prices[i - 1] + Math.max(sell[i - 1], cooldown[i - 2]);\\n            }\\n            return Math.max(sell[len - 1], cooldown[len - 1]);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            if(prices == null || prices.length < 2){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 740050,
                "title": "easy-100-speed-o-1-space-python-c-java-javascript",
                "content": "**Easy Code | 100% Speed | O(n) time, O(1) space | Python, C++, Java, JavaScript**\\n\\nSuper Easy solution for the problem of buying stocks with cooldown. The inspiration behind the code is the following:\\n* To make profits, we need to find the best buying and selling points.\\n* If we were to create an array of buying points, and scan for the best profits, we would notice that \"late\" buying points can be \"subsidized\" by profits previously made. So for example, if we make a profit of 17 between \"prices[0:12]\", then our buying point at \"prices[14]=20\" would be \"20-17=3\".\\n* The previous point gives us a way to compare the worth of different buying points in our array, and pick the best value. It also allows us to keep track of prior profits (without extra effort). For each point in prices[i], we say that our profits are \"prices[i] - best_buy\", where \"best_buy\" can even be a negative value due to large prior profits.\\n* Of course, our latest profit calculations could be lower than before if the stock fell, so our final formula must be: \"profits = max( last_profits, x - best_buy)\".\\n* Since we only need the two previous values of our highest profits (to respect the cooldown), we can add two exta variables and still use O(1) space.\\n\\nThat\\'s pretty much how the code works. I hope the story makes sense, I developed the code around those lines. Cheers,\\n\\n**A) Python**\\n```\\nclass Solution:\\n    Inf = float(\\'inf\\')\\n    def maxProfit(self, prices):\\n        buy           = self.Inf\\n        free,last,now = 0,0,0 # profit values (before the cooldown, in our last step, and now)\\n        for x in prices:\\n            now = max(last ,  x - buy )\\n            buy = min(buy  ,  x - free )\\n            free,last = last,now\\n        return now\\n```\\n\\n**B) C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy = INT_MAX ;\\n        int pfree = 0 , last = 0, now = 0;\\n        int x;\\n        for(int i = 0; i < prices.size(); i++) {\\n            x = prices[i];\\n            now   = max( last , x - buy);\\n            buy   = min( buy  , x - pfree);\\n            pfree = last;\\n            last  = now;\\n        };\\n        return now;\\n    }\\n};\\n```\\n\\n**C) Java**\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) { \\n    int buy = 2147483647; // 2^31 - 1\\n    int pfree = 0, last = 0, now = 0;\\n    for (int x : prices) {\\n        now = Math.max( last , x -  buy);\\n        buy = Math.min( buy , x - pfree);\\n        pfree = last;\\n        last  = now;\\n    };\\n    return now;  \\n    }\\n}\\n```\\n\\n**D) Javascript**\\n\\n```\\nvar maxProfit = function(prices) {\\n    var buy = 2147483647; // 2^31 - 1\\n    var free = 0, last = 0, now = 0;\\n    prices.forEach( x => {\\n            now = Math.max( last , x - buy);\\n            buy = Math.min( buy , x - free);\\n            free = last;\\n            last = now;\\n    });\\n    return now;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    Inf = float(\\'inf\\')\\n    def maxProfit(self, prices):\\n        buy           = self.Inf\\n        free,last,now = 0,0,0 # profit values (before the cooldown, in our last step, and now)\\n        for x in prices:\\n            now = max(last ,  x - buy )\\n            buy = min(buy  ,  x - free )\\n            free,last = last,now\\n        return now\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy = INT_MAX ;\\n        int pfree = 0 , last = 0, now = 0;\\n        int x;\\n        for(int i = 0; i < prices.size(); i++) {\\n            x = prices[i];\\n            now   = max( last , x - buy);\\n            buy   = min( buy  , x - pfree);\\n            pfree = last;\\n            last  = now;\\n        };\\n        return now;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) { \\n    int buy = 2147483647; // 2^31 - 1\\n    int pfree = 0, last = 0, now = 0;\\n    for (int x : prices) {\\n        now = Math.max( last , x -  buy);\\n        buy = Math.min( buy , x - pfree);\\n        pfree = last;\\n        last  = now;\\n    };\\n    return now;  \\n    }\\n}\\n```\n```\\nvar maxProfit = function(prices) {\\n    var buy = 2147483647; // 2^31 - 1\\n    var free = 0, last = 0, now = 0;\\n    prices.forEach( x => {\\n            now = Math.max( last , x - buy);\\n            buy = Math.min( buy , x - free);\\n            free = last;\\n            last = now;\\n    });\\n    return now;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940895,
                "title": "recursive-memoised-code-c",
                "content": "# Intuition\\nYou have to maximize stuff , so i think dp and constraints are 5 * 1000 so an N^2 approach could work\\n\\n# Approach\\nWe have to check for 3 things :\\n1. If we buy , then we sernd the next turn to either selling or if we didn\\'t buy we do nothing\\n2. If we bought last , then we can either sell today or leave today and hold till we get a good day to sell\\n3. If we sold last , then we only have one choice of a cooldown for the next turn \\n\\n# Complexity\\n- Time complexity: O(N * turn)\\n\\n- Space complexity: O(N * turn)\\n\\n# Recursive code\\n```\\nclass Solution {\\npublic:\\n    /*\\n    1. 3 options a day buy sell or leave\\n    2. If bought , then only sell or leave (until you sell)\\n    3. If sold , then only buy or leave (until you sell)\\n    4. If left , then buy or sell (if you have any)\\n    */\\n    int dfs(int i , int turn , vector<int>& prices){\\n        if(i >= prices.size()) return 0;\\n        // 0 for buy\\n        // 1 for sell \\n        // 2 for last day sold\\n        if(turn == 0){\\n            return max(-prices[i] + dfs(i + 1 , 1 , prices) , dfs(i + 1 , 0 , prices));\\n        }\\n        else if(turn == 1){\\n            return max(prices[i] + dfs(i + 1 , 2 , prices) , dfs(i + 1 , 1 , prices)) ;\\n        }\\n        else{\\n            return dfs(i + 1 , 0 , prices);\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return dfs(0 , 0 , prices);\\n    }\\n};\\n\\n```\\n\\n# Memoised Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n    1. 3 options a day buy sell or leave\\n    2. If bought , then only sell or leave (until you sell)\\n    3. If sold , then only buy or leave (until you sell)\\n    4. If left , then buy or sell (if you have any)\\n    */\\n    int dfs(int i , int turn , vector<int>& prices , vector<vector<int>>& dp){\\n        if(i >= prices.size()) return 0;\\n        // 0 for buy\\n        // 1 for sell \\n        // 2 for last day sold\\n        if(dp[i][turn] != -1){\\n            return dp[i][turn];\\n        }\\n        if(turn == 0){\\n            return dp[i][turn] = max(-prices[i] + dfs(i + 1 , 1 , prices , dp) , dfs(i + 1 , 0 , prices , dp));\\n        }\\n        else if(turn == 1){\\n            return dp[i][turn] = max(prices[i] + dfs(i + 1 , 2 , prices , dp) , dfs(i + 1 , 1 , prices , dp));\\n        }\\n        else{\\n            return dp[i][turn] = dfs(i + 1 , 0 , prices , dp);\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1 , vector<int>(3 , -1));\\n        return dfs(0 , 0 , prices , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    1. 3 options a day buy sell or leave\\n    2. If bought , then only sell or leave (until you sell)\\n    3. If sold , then only buy or leave (until you sell)\\n    4. If left , then buy or sell (if you have any)\\n    */\\n    int dfs(int i , int turn , vector<int>& prices){\\n        if(i >= prices.size()) return 0;\\n        // 0 for buy\\n        // 1 for sell \\n        // 2 for last day sold\\n        if(turn == 0){\\n            return max(-prices[i] + dfs(i + 1 , 1 , prices) , dfs(i + 1 , 0 , prices));\\n        }\\n        else if(turn == 1){\\n            return max(prices[i] + dfs(i + 1 , 2 , prices) , dfs(i + 1 , 1 , prices)) ;\\n        }\\n        else{\\n            return dfs(i + 1 , 0 , prices);\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return dfs(0 , 0 , prices);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    /*\\n    1. 3 options a day buy sell or leave\\n    2. If bought , then only sell or leave (until you sell)\\n    3. If sold , then only buy or leave (until you sell)\\n    4. If left , then buy or sell (if you have any)\\n    */\\n    int dfs(int i , int turn , vector<int>& prices , vector<vector<int>>& dp){\\n        if(i >= prices.size()) return 0;\\n        // 0 for buy\\n        // 1 for sell \\n        // 2 for last day sold\\n        if(dp[i][turn] != -1){\\n            return dp[i][turn];\\n        }\\n        if(turn == 0){\\n            return dp[i][turn] = max(-prices[i] + dfs(i + 1 , 1 , prices , dp) , dfs(i + 1 , 0 , prices , dp));\\n        }\\n        else if(turn == 1){\\n            return dp[i][turn] = max(prices[i] + dfs(i + 1 , 2 , prices , dp) , dfs(i + 1 , 1 , prices , dp));\\n        }\\n        else{\\n            return dp[i][turn] = dfs(i + 1 , 0 , prices , dp);\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1 , vector<int>(3 , -1));\\n        return dfs(0 , 0 , prices , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75998,
                "title": "very-simple-explanation-based-basic-math-no-state-machine-etc-o-n-dp-code-attached",
                "content": "**Define** `profit[i]` - maximum profit can be made on day i following the cool down rule\\n\\n`profit[i] = Max(prices[i]-prices[j] + profit[j-2])` for `all j < i`  **(1)**\\n\\n - `prices[i]-prices[j]` buying on j and sell on i **(1.1)**\\n - `profit[j-2]` accumulated profit from 0 to j-2 **(1.2)**\\n\\nAbove calculation would lead to O(N^2) complexity, let's **simplify using linearity**\\n\\n`profit[i] = Max(prices[i]) + Max(profit[j-2]-prices[j])`  for all `j<i` **(2)**\\n\\n - `Max( prices[i] ) = prices[i]` is O(1) calculation\\n - `Max(profit[j-2]-prices[j])`  for `all j<i` is O(1) calculation\\n\\nThis is O(N), below is the code\\n\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if(n<=1) return 0;\\n        int[] dp = new int[n + 1];\\n        int max = -prices[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i + 1] = Math.max(dp[i], max + prices[i]);\\n            max = Math.max(dp[i - 1] - prices[i], max);\\n        }\\n    \\n        return dp[n];\\n    }\\n\\nOf course this post is here to illustrate the concept of DP, the space can further be optimized into O(1). Plus, if you read the other posts with state machines and buy,sell,cool down states, it's all reduces into this format. The only difference if how you explain the variables you define in each case.",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Define** `profit[i]` - maximum profit can be made on day i following the cool down rule\\n\\n`profit[i] = Max(prices[i]-prices[j] + profit[j-2])` for `all j < i`  **(1)**\\n\\n - `prices[i]-prices[j]` buying on j and sell on i **(1.1)**\\n - `profit[j-2]` accumulated profit from 0 to j-2 **(1.2)**\\n\\nAbove calculation would lead to O(N^2) complexity, let's **simplify using linearity**\\n\\n`profit[i] = Max(prices[i]) + Max(profit[j-2]-prices[j])`  for all `j<i` **(2)**\\n\\n - `Max( prices[i] ) = prices[i]` is O(1) calculation\\n - `Max(profit[j-2]-prices[j])`  for `all j<i` is O(1) calculation\\n\\nThis is O(N), below is the code\\n\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if(n<=1) return 0;\\n        int[] dp = new int[n + 1];\\n        int max = -prices[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i + 1] = Math.max(dp[i], max + prices[i]);\\n            max = Math.max(dp[i - 1] - prices[i], max);\\n        }\\n    \\n        return dp[n];\\n    }\\n\\nOf course this post is here to illustrate the concept of DP, the space can further be optimized into O(1). Plus, if you read the other posts with state machines and buy,sell,cool down states, it's all reduces into this format. The only difference if how you explain the variables you define in each case.",
                "codeTag": "Unknown"
            },
            {
                "id": 1326828,
                "title": "complete-explanation-of-the-buy-and-sell-stock-problems-using-dp",
                "content": "I will be going over what I have learned while trying to solve these problems. I was initially using `Kadane\\'s algorithm` to do these problems. Infact, completed the first, second, and third **Buy and Sell Stock problems** using Kadane\\'s but the fourth problem gave me a concussion so, I embarked on a journey to learn a framework using which I can solve the complete set of these problems and handle any tweaks that an interviewer might throw at me in the future. I visited a number of resources, watched a number of videos and here is the culmination of everything I have picked so far.\\n\\nThese are all the problems we have in the Buy and Sell Stock set.\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n4. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n5. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n6. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n\\nFirst, we will see how we can come up with a framework which we can apply for all the above problems. A framework which is flexible enough to accomodate any tweaks an interviewer might throw at us in the future. *A framework which exhausts all the possible outcomes and then come up with the best solution*. A recursive solution would be exhaustive but we will use \"states\" for exhaustion in these problems. **We will consider each day and see how many possible \"states\" do we have for each day and then find \"choices\" corresponding to each state.**\\n\\n**Let\\'s talk about the constraints first.**\\n1. `Sell` must be after `Buy`.\\n2. `Buy` must be after `Sell`.\\n3.  Limit on the number of transaction(k), `k>0`.\\n\\n**For each day we have three choices.**\\n1. `Buy`.\\n2. `Sell`.\\n3. `Rest`. Which further has two states.\\n\\t a. `Rest after buy`. Here we are holding the stock. We are not selling or buying. We are just resting.\\n\\t b. `Rest after selling`. Here we are not holding any stocks. We are not selling or buying. We are just resting.\\n\\n**Let\\'s talk about the states now.**\\n1. The day we are on i.e `i`.\\n2. The maximum number of allowed transactions i.e `k`.\\n3. The holding state i.e the resting state we talked about before. This is either `1(holding stock)` or `0(not holding stock)`.\\n\\nNow, we can put all the combinations of these states in a 3D matrix like so :\\n\\n```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\\n\\n\\n***For every problem we have to find the `dp[n-1][k][0]`, which is the maximum profit for the maximum number of transactions allowed on the last day.***\\n\\nOne important observation. Why didn\\'t we say **`dp[n-1][k][1]`** instead of saying **`dp[n-1][k][0]`**? because if the resting state `S` is 1, it means we are still holding a stock and the profit cannot be maximum until and unless we are done selling all the stocks we have.\\n\\n\\n\\n\\nNow, let\\'s think about what choices do we have for each state and how we can update the \"state\". Let\\'s write our state transition equations. They will be something like this.\\n\\n`dp[i][k][0] = Max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) // prices is the array of stocks`\\n\\n***This equation corresponds to when you are not holding a stock. You are not holding a stock today because perhaps you didn\\'t have any stocks yesterday which we could sell today or maybe you have stocks that you want to sell today, so at the end of the day we will not be holding any stocks.***\\n\\n`dp[i][k][1] = Max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`\\n\\n***This equation corresponds to when you are holding a stock. You are holding a stock today because perhaps you had stocks yesterday or maybe you want to buy stocks today, so at the end of the day we will be holding stocks.***\\n\\n***This explanation should be clear. If you buy, you need to subtract prices[i] from the profit, and if you sell, you need to increase prices[i] to the profit.***\\n\\n\\nNow, let\\'s talk about the base cases.\\n\\n1. `dp[-1][k][0]  = 0`     **// Because the day starts with 0 and here i is -1**\\n2. `dp[-1][k][1] = -Infinity`  **// Because we can\\'t hold any stocks before the first day**\\n3. `dp[i][0][0] = 0`  **// Because k = 0. There won\\'t be any transactions so the profit will be zero** \\n4. `dp[i][0][1] = -Infinity`  **// Because k = 0. We can\\'t hold any stocks without starting a transaction** \\n\\n\\nSo, to summarize the above base conditions and state transition equations\\n\\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\\n\\n\\nNow, let\\'s begin with the problems.\\n\\n1. ***When k = 1***\\n\\nWe will put k = 1 directly in the state transition equations and see for ourselves.\\n\\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\\n\\nWe can also see that the presence of k when it is 1 does not change the state in any way so, we can simply ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\\n\\nWe can write the solution for it like so:\\n\\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\\n\\n***We can reduce the Space complexity to 0(1) by not constructing the DP matrix as the new state is only related to an adjacent state. So, instead of the DP matrix we can store the states in a single variable. One variable for not holding and one for holding.***\\n\\nCode for that would look something like :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\\n\\n2. ***When k = + Infinity***\\n\\nWhen k is Infinity, k and k-1 are practically the same. We will use that in our state transition equations.\\n\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\\n\\nSince, the presence of k is not really impacting the states, we will ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\\n\\nAnd the solution would look like this : \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n3. ***When k = 2***\\n\\nNow, we need to exhaust the value of k as well. Before this we were ignoring k because it was not impacting our states. We need to hold the states for the second transaction as well along with the first transaction. \\n\\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\\n\\nThe solution would look like this :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\\n\\n\\n4. ***When k = + interger***\\n\\n**Important observation** : A transaction consists of buying and selling, which takes atleast 2 days. Therefore, the effective limit k should not exceed n/2( n is the number of days). If it exceeds, there is no contraint effect which makes k equivalent to +Infinity.\\n\\nThis is the only problem from this set which is a little difficult.\\n\\nSolution would look like this \\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\\n\\n5. ***When k = +Infinity with cooldown***\\n\\nWe must wait one day after selling a stock to continue trading. We can write the state transition equations as :\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\\n\\nCode would look like \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n\\n6. ***When k = +Infinity with transaction fee***\\n\\nSince now we need to pay some fee for each transaction made, the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\\n\\nCode can we written as  :\\n\\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\nI hope you enjoyed this post.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494171,
                "title": "most-general-solutions-for-the-series-of-stock-problems",
                "content": "This summary is inspired by <https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75924/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems>, thanks @fun4LeetCode\\n\\nI rewrtie the notation to make it easier to understand for the following series of stock problems:\\n\\n121. Best Time to Buy and Sell Stock\\n122. Best Time to Buy and Sell Stock II\\n123. Best Time to Buy and Sell Stock III\\n188. Best Time to Buy and Sell Stock IV\\n309. Best Time to Buy and Sell Stock with Cooldown\\n714. Best Time to Buy and Sell Stock with Transaction Fee\\n\\n\\n## I General cases\\n\\n\\nLet `prices` be the stock price array with length `n`, `k` denote the maximum number of transactions allowed to complete. Note that a transaction consists of two actions coming as a pair -- `buy` and `sell`. Only action `buy` will change the maximum number of transactions allowed.\\n\\nThere are only two cases: no hold stock and hold `1` stock, `no_hold[i][k]` and `hold[i][k]`to be the maximum profit that could be gained on the `i-th` day (i >= 1) with at most `k` transactions (k >= 1). `i` and `k` are `1-index`. Apparently we have base cases: `no_hold[0][k] = 0` and  `no_hold[i][0] = 0`, `i = 0` means the day before the first day in `prices`, `k = 0` means no transaction, both of them yield no profit.\\n\\nNow consider the state transition, we have three actions: `buy`, `sell` and `rest` (do nothing). \\n\\nThere is an extra restriction saying no multiple transactions are allowed at the same time, meaning if we decide to `buy` on the `i-th` day, there should be `0` stock held in our hand, which means state transition from `no_hold[i][k-1]` to `hold[i][k]`, note that `buy` will change the transaction number.\\n\\nIf we decide to `sell` on the `i-th` day, there should be exactly `1` stock held in our hand, which means state transition from `hold[i][k]` to `no_hold[i][k]`, note that `sell` doesn\\'t change the transaction number.\\n\\nThe number of stocks held in our hand is the hidden factor mentioned above that will affect the action on the `i-th` day and thus affect the maximum profit.\\n\\nNow the base cases and state transition can be written as:\\n\\n1. Base cases:\\n\\n`no_hold[0][k] = 0, hold[0][k] = INT_MIN`\\n\\n`no_hold[i][0] = 0, hold[i][0] = INT_MIN`\\n\\n2. State transition equations:\\n\\n`no_hold[i][k] = max(no_hold[i-1][k], hold[i-1][k] + prices[i-1])`\\n\\n`hold[i][k] = max(hold[i-1][k], no_hold[i-1][k-1] - prices[i-1])`\\n\\n\\nFor the base cases, `no_hold[0][k] = no_hold[i][0] = 0` has the same meaning as before,  while `hold[0][k] = hold[i][0] = INT_MIN` emphasizes the fact that it is impossible to have `1` stock in hand if there is no stock available or no transactions are allowed.\\n\\nFor `no_hold[i][k]` in the state transition, the actions taken on the `i-th` day can only be `rest` and `sell`, and we have `0` stock in our hand at the end of `i-th` day. `no_hold[i-1][k]` is the maximum profit if action `rest` is taken, while `hold[i-1][k] + prices[i-1]` is the maximum profit if action `sell` is taken. Note that the maximum number of allowable transactions remains the same. `prices[i-1]` means that the stock price of `i-th` day, `prices` array is 0-index.\\n\\nFor `hold[i][k]` in the state transition, the actions taken on the `i-th` day can only be `rest` and `buy`, and we have `1` stock in our hand at the end of the day. `hold[i-1][k]` is the maximum profit if action `rest` is taken, while `no_hold[i-1][k-1] - prices[i-1]` is the maximum profit if action `buy` is taken. Note that the maximum number of allowable transactions decreases by one, since buying on the `i-th` day will use one transaction.\\n\\nTo find the maximum profit at the end of the last day, we can simply loop through the `prices` array and update `no_hold[i][k]` and `hold[i][k]`. The final answer will be `no_hold[i][k]` (we always have larger profit if we end up with `0` stock in hand).\\n\\n\\n\\n## Applications \\n\\nThe aforementioned six stock problems are classified by the value of `k`, which is the maximum number of allowable transactions (the last two also has additional requirements such as \"cooldown\" or \"transaction fee\").\\n\\n### Case I: k = 1\\n\\n> 121. Best Time to Buy and Sell Stock\\n\\nState transition equations:\\n\\n`no_hold[i][1] = max(no_hold[i-1][1], hold[i-1][1] + prices[i-1])`\\n\\n`hold[i][1] = max(hold[i-1][1], no_hold[i-1][0] - prices[i-1]) = max(hold[i-1][1], - prices[i-1])`\\n\\nwhere we have taken advantage of the base case `no_hold[i-1][0] = 0` for the second equation. Continue to write as:\\n\\n`no_hold[i] = max(no_hold[i-1], hold[i-1] + prices[i-1])`\\n\\n`hold[i] = max(hold[i-1], - prices[i-1])`\\n\\nIt is straightforward to write the `O(n)` time and `O(n)` space solution, based on the two equations above, define two vectors for `no_hold` and `hold`.  However, notice that maximum profits on the `i-th` day actually only depend on those on the `(i-1)-th day`, the space can be cut down to `O(1)`. Here is the space-optimized solution:\\n\\n```c++\\nint maxProfit(vector<int>& prices) {\\n    int no_hold = 0, hold = INT_MIN;\\n        \\n    for (int price : prices) {\\n        no_hold = max(no_hold, hold + price);\\n        hold = max(hold, -price);\\n    }\\n        \\n    return no_hold;\\n}\\n```\\n\\nYou may find some other nice solutions:\\n<https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/kadanes-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input>\\n\\n### Case II: k = +Infinity\\n\\n> 122. Best Time to Buy and Sell Stock II\\n\\nIf `k` is positive infinity, then there isn\\'t really any difference between `k` and `k - 1`, which implies `no_hold[i-1][k-1] = no_hold[i-1][k]` and `hold[i-1][k-1] = hold[i-1][k]`. we can just ignore `k`:\\n\\n`no_hold[i] = max(no_hold[i-1], hold[i-1] + prices[i-1])`\\n\\n`hold[i] = max(hold[i-1], no_hold[i-1] - prices[i-1])`\\n\\nThe maximum profits on the `i-th` day actually only depend on those on the `(i-1)-th` day, the space can be cut down to O(1) as follows:\\n\\n```c++\\nint maxProfit(vector<int>& prices) {\\n    int no_hold = 0, hold = INT_MIN;\\n        \\n    for (int price : prices) {\\n    \\tint no_hold_old = no_hold;\\n        no_hold = max(no_hold, hold + price);\\n        hold = max(hold, no_hold_old - price);\\n    }\\n        \\n    return no_hold;\\n}\\n```\\n\\n### Case III: k = 2\\n\\n> 123. Best Time to Buy and Sell Stock III\\n\\nSimilar to the case where `k = 1`, except now we have four variables instead of two on each day: `no_hold[i][1], hold[i][1], no_hold[i][2], hold[i][2]`, and state transition equations are:\\n\\n```\\nno_hold[i][2] = max(no_hold[i-1][2], hold[i-1][2] + prices[i-1])\\nhold[i][2] = max(hold[i-1][2], no_hold[i-1][1] - prices[i-1]) \\nno_hold[i][1] = max(no_hold[i-1][1], hold[i-1][1] + prices[i-1])\\nhold[i][1] = max(hold[i-1][1], -prices[i-1]) \\n```\\n\\nwhere again we have taken advantage of the base case `no_hold[i-1][0] = 0` for the last equation. The O(n) time and O(1) space solution is as follows:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int no_hold_1 = 0, hold_1 = INT_MIN, no_hold_2 = 0, hold_2 = INT_MIN;\\n        for (int price : prices) {\\n            no_hold_2 = max(no_hold_2, hold_2 + price);\\n            hold_2 = max(hold_2, no_hold_1 - price);\\n            no_hold_1 = max(no_hold_1, hold_1 + price);\\n            hold_1 = max(hold_1, -price);\\n        }\\n        return no_hold_2;\\n    }\\n};\\n```\\nwhich is essentially the same as:\\n<https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39611/is-it-best-solution-with-on-o1>\\n\\n\\n### Case IV: k is arbitrary\\n\\n> https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\\n\\nThis is the most general case so on each day we need to update all the maximum profits with different `k` values corresponding to 0 or 1 stocks in hand at the end of the day. However, there is a minor optimization we can do if `k` exceeds some critical value, beyond which the maximum profit will no long depend on the number of allowable transactions but instead will be bound by the number of available stocks (length of the prices array). \\n\\nIf the length of the prices array is `n`, the maximum number of profitable transactions is `n/2` (integer division). After that no profitable transaction is possible, which implies the maximum profit will stay the same. If the given `k` is no less than this value, i.e., `k >= n/2`, we can extend `k` to positive infinity and the problem is equivalent to `Case II`.\\n\\nNotice that maximum profits on the `i-th` day actually only depend on those on the `(i-1)-th day`, the space can be cut down to O(k). 1D vector `no_hold` and `hold`. Note that j loop need to be from `k` to 0, `hold[i][k] = max(hold[i-1][k], no_hold[i-1][k-1] - prices[i-1])`. Use previous `i-1` to update current `i`. The following is the O(kn) time and O(k) space solution. \\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if (k >= n / 2) {\\n            int no_hold = 0, hold = INT_MIN;\\n            for (int price : prices) {\\n                int no_hold_old = no_hold;\\n                no_hold = max(no_hold, hold + price);\\n                hold = max(hold, no_hold_old - price);\\n            }\\n            return no_hold;\\n        }\\n        vector<int> no_hold(k + 1, 0), hold(k + 1, INT_MIN);\\n        for (int price : prices) {\\n            for (int j = k; j > 0; --j) {\\n                no_hold[j] = max(no_hold[j], hold[j] + price);\\n                hold[j] = max(hold[j], no_hold[j - 1] - price);\\n            }\\n        }\\n        return no_hold[k];\\n    }\\n};\\n```\\n\\nSimilar to: <https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54113/a-concise-dp-solution-in-java>\\n\\n\\n### Case V: k = +Infinity but with cooldown\\n\\n> https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\\n\\nThis case resembles `Case II` very much due to the fact that they have the Infinity k value, except now state transition equations have to be modified slightly to account for the \"cooldown\" requirement. The original state transition equations for `Case II` are given by\\n\\n`no_hold[i] = max(no_hold[i-1], hold[i-1] + prices[i-1])`\\n\\n`hold[i] = max(hold[i-1], no_hold[i-1] - prices[i-1])`\\n\\nBut with \"cooldown\", we cannot buy on the `i-th` day if a stock is sold on the `(i-1)-th` day. Therefore, in the second equation above, instead of `no_hold[i-1]`, we should actually use `no_hold[i-2]` if we intend to buy on the `i-th` day. Everything else remains the same and the new state transition equations are\\n\\n`no_hold[i] = max(no_hold[i-1], hold[i-1] + prices[i-1])`\\n\\n`hold[i] = max(hold[i-1], no_hold[i-2] - prices[i-1])`\\n\\nNotice that maximum profits on the `i-th` day actually depend on those on the `(i-1)-th day` and `(i-2)-th day`, the space still can be cut down to O(1).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int no_hold_pre_pre = 0, no_hold = 0, hold = INT_MIN;\\n        for (int price : prices) {\\n            int no_hold_pre = no_hold;\\n            no_hold = max(no_hold, hold + price);\\n            hold = max(hold, no_hold_pre_pre - price);\\n            no_hold_pre_pre = no_hold_pre;\\n        }\\n        return no_hold;\\n    }\\n};\\n```\\n\\nSimilar to: <https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/share-my-thinking-process>\\n\\n\\n### Case VI: k = +Infinity but with transaction fee\\n\\n> https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\\n\\n\\nThis case resembles `Case II` very much due to the fact that they have the Infinity k value, except now state transition equations have to be modified slightly to account for the \"transaction fee\" requirement. The original state transition equations for `Case II` are given by\\n\\n`no_hold[i] = max(no_hold[i-1], hold[i-1] + prices[i-1])`\\n\\n`hold[i] = max(hold[i-1], no_hold[i-1] - prices[i-1])`\\n\\nSince now we need to pay some fee (denoted as `fee`) for each transaction made, the profit after selling the stock on the `i-th` day should be subtracted by this amount, therefore the new state transition equations will be\\n\\n`no_hold[i] = max(no_hold[i-1], hold[i-1] + prices[i-1]) - fee`\\n\\n`hold[i] = max(hold[i-1], no_hold[i-1] - prices[i-1])`\\n\\nNote only the first equation was modified. This is because  each transaction is characterized by two actions coming as a pair -- `buy` and `sell`, and the `fee` will be paid only after the whole transaction is complete, i.e., after we `sell` the stock. The following is the `O(n)` time and `O(1)` space solution, where I used `long` variables for the profits to avoid possible overflow.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        long no_hold = 0, hold = INT_MIN;\\n        for (int price : prices) {\\n            long no_hold_pre = no_hold;\\n            no_hold = max(no_hold, hold + price - fee);\\n            hold = max(hold, no_hold_pre - price);\\n        }\\n        return (int)no_hold;\\n    }\\n};\\n```\\n\\n### Summary\\n\\nIn summary, the most general case of the stock problem can be characterized by three factors, the ordinal of the day `i`, the maximum number of allowable transactions `k` and the number of stocks in our hand at the end of the day.",
                "solutionTags": [],
                "code": "```c++\\nint maxProfit(vector<int>& prices) {\\n    int no_hold = 0, hold = INT_MIN;\\n        \\n    for (int price : prices) {\\n        no_hold = max(no_hold, hold + price);\\n        hold = max(hold, -price);\\n    }\\n        \\n    return no_hold;\\n}\\n```\n```c++\\nint maxProfit(vector<int>& prices) {\\n    int no_hold = 0, hold = INT_MIN;\\n        \\n    for (int price : prices) {\\n    \\tint no_hold_old = no_hold;\\n        no_hold = max(no_hold, hold + price);\\n        hold = max(hold, no_hold_old - price);\\n    }\\n        \\n    return no_hold;\\n}\\n```\n```\\nno_hold[i][2] = max(no_hold[i-1][2], hold[i-1][2] + prices[i-1])\\nhold[i][2] = max(hold[i-1][2], no_hold[i-1][1] - prices[i-1]) \\nno_hold[i][1] = max(no_hold[i-1][1], hold[i-1][1] + prices[i-1])\\nhold[i][1] = max(hold[i-1][1], -prices[i-1]) \\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int no_hold_1 = 0, hold_1 = INT_MIN, no_hold_2 = 0, hold_2 = INT_MIN;\\n        for (int price : prices) {\\n            no_hold_2 = max(no_hold_2, hold_2 + price);\\n            hold_2 = max(hold_2, no_hold_1 - price);\\n            no_hold_1 = max(no_hold_1, hold_1 + price);\\n            hold_1 = max(hold_1, -price);\\n        }\\n        return no_hold_2;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n = prices.size();\\n        if (k >= n / 2) {\\n            int no_hold = 0, hold = INT_MIN;\\n            for (int price : prices) {\\n                int no_hold_old = no_hold;\\n                no_hold = max(no_hold, hold + price);\\n                hold = max(hold, no_hold_old - price);\\n            }\\n            return no_hold;\\n        }\\n        vector<int> no_hold(k + 1, 0), hold(k + 1, INT_MIN);\\n        for (int price : prices) {\\n            for (int j = k; j > 0; --j) {\\n                no_hold[j] = max(no_hold[j], hold[j] + price);\\n                hold[j] = max(hold[j], no_hold[j - 1] - price);\\n            }\\n        }\\n        return no_hold[k];\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int no_hold_pre_pre = 0, no_hold = 0, hold = INT_MIN;\\n        for (int price : prices) {\\n            int no_hold_pre = no_hold;\\n            no_hold = max(no_hold, hold + price);\\n            hold = max(hold, no_hold_pre_pre - price);\\n            no_hold_pre_pre = no_hold_pre;\\n        }\\n        return no_hold;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        long no_hold = 0, hold = INT_MIN;\\n        for (int price : prices) {\\n            long no_hold_pre = no_hold;\\n            no_hold = max(no_hold, hold + price - fee);\\n            hold = max(hold, no_hold_pre - price);\\n        }\\n        return (int)no_hold;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761804,
                "title": "simple-recursive-solution-with-memoization-c-and-explanation",
                "content": "The recursion state is simple, here we decide whether to buy or sell stock on ith day or just ignore the current day for stock trading. This makes two different recursive calls and we take maximum among them. If you want to sell the stock then skip the next day (currIndex+2) for trading. Also for n day cooldown period just make (currIndex+n) in (!buyIt) recursive call.\\nThis base recursive solution will give you tle, then apply memoization (by looking at the parameters that you are changing in recursive calls).\\nFor applying memoization I used map of pair which is slightly slower as compared to a 2d array that can be used in this case (int dp[n][2]).\\n```\\nmap<pair<int,bool>,int> mp;\\n\\nint earnMaxProfit(vector<int>& prices,int currIndex,int n,bool buyIt){\\n    \\n    if(currIndex >= n)  return 0;\\n    \\n    if(mp.find(make_pair(currIndex,buyIt)) != mp.end()) return mp[make_pair(currIndex,buyIt)];\\n    \\n    int opt1 = 0;\\n    int opt2 = 0;\\n    \\n    if(buyIt){\\n        opt1 = -1*prices[currIndex] + earnMaxProfit(prices,currIndex+1,n,false);    \\n    }else{\\n        opt1 = prices[currIndex] + earnMaxProfit(prices,currIndex+2,n,true); \\n    }    \\n        \\n    opt2 = earnMaxProfit(prices,currIndex+1,n,buyIt);\\n        \\n    \\n    return mp[make_pair(currIndex,buyIt)] = max(opt1,opt2);\\n}\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        if(n == 0 || n == 1)    return 0;\\n        \\n        mp.clear();\\n        return earnMaxProfit(prices,0,n,true);\\n        \\n    }\\n};\\n```\\n***UPVOTE IF IT HELPS!!!***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nmap<pair<int,bool>,int> mp;\\n\\nint earnMaxProfit(vector<int>& prices,int currIndex,int n,bool buyIt){\\n    \\n    if(currIndex >= n)  return 0;\\n    \\n    if(mp.find(make_pair(currIndex,buyIt)) != mp.end()) return mp[make_pair(currIndex,buyIt)];\\n    \\n    int opt1 = 0;\\n    int opt2 = 0;\\n    \\n    if(buyIt){\\n        opt1 = -1*prices[currIndex] + earnMaxProfit(prices,currIndex+1,n,false);    \\n    }else{\\n        opt1 = prices[currIndex] + earnMaxProfit(prices,currIndex+2,n,true); \\n    }    \\n        \\n    opt2 = earnMaxProfit(prices,currIndex+1,n,buyIt);\\n        \\n    \\n    return mp[make_pair(currIndex,buyIt)] = max(opt1,opt2);\\n}\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        if(n == 0 || n == 1)    return 0;\\n        \\n        mp.clear();\\n        return earnMaxProfit(prices,0,n,true);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302806,
                "title": "easy-solution-recursive-method-dp-method-c-beats-100",
                "content": "# Intuition\\nFirst I have solved the problem with normal recursive method. Later on I have used dp to reduce the time complexity. \\n\\n# Approach\\nIn the question it is clearly given that you can buy and sell the stocks multiple times but there is cool down time.\\n\\nSo we take two things into consideration. \\n1) Whether a stock is bought.\\n2) Cool Down Time.\\n\\nLet us make a flag variable which determines whether we hold a stock. If we hold the stock flag is 1 else it is 0. \\n\\nIf we do not hold a stack, we have two ways either buy the stock or just do not buy. We need to pick the maximum from both the cases. In the case considering that you buy the stock update the flag as 1. As you buy the stoct your money is debited so we subtract the money. In the case considering that you donot buy the stock update nothing.\\n\\nIf we do hold a stack, we have two ways either sell the stock or just do not sell. We need to pick the maximum from both the cases. In the case considering that you sell the stock update the flag as 0 but if we sell the stock we need to wait for one day to be cooled down so we update idx to idx+2 after selling the stock. As you sell the stoct your money is credited so we add the money. In the case considering that you donot sell the stock update nothing.\\n\\nThe terminating Case would be index is greater than size.\\n\\n# Complexity\\n- Time complexity:\\n O(2^N) for normal recursion\\n O(N) for dp method\\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\n//Normal recursive method\\n\\nclass Solution {\\npublic:\\nint soln(vector<int>&prices,int idx,int flag){\\n    if(idx>=prices.size()){\\n        return 0;\\n    }\\n    int ans = INT_MIN;\\n    if(!flag){\\n        ans = max(ans,soln(prices,idx+1,1)-prices[idx]);\\n        ans = max(ans,soln(prices,idx+1,0));\\n    }else{\\n        ans = max(ans,soln(prices,idx+2,0)+prices[idx]);\\n        ans = max(ans,soln(prices,idx+1,1));\\n    }\\n    return ans;\\n}\\n    int maxProfit(vector<int>& prices) {\\n        return soln(prices,0,0);\\n    }\\n};\\n\\n//Using dp\\n\\nclass Solution {\\npublic:\\nint soln(vector<vector<int>>&dp,vector<int>&prices,int idx,int flag){\\n    if(idx>=prices.size()){\\n        return 0;\\n    }\\n    if(dp[idx][flag] != -1){\\n        return dp[idx][flag];\\n    }\\n    int ans = INT_MIN;\\n    if(!flag){\\n        ans = max(ans,soln(dp,prices,idx+1,1)-prices[idx]);\\n        ans = max(ans,soln(dp,prices,idx+1,0));\\n    }else{\\n        ans = max(ans,soln(dp,prices,idx+2,0)+prices[idx]);\\n        ans = max(ans,soln(dp,prices,idx+1,1));\\n    }\\n    return dp[idx][flag] = ans;\\n}\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n        return soln(dp,prices,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Normal recursive method\\n\\nclass Solution {\\npublic:\\nint soln(vector<int>&prices,int idx,int flag){\\n    if(idx>=prices.size()){\\n        return 0;\\n    }\\n    int ans = INT_MIN;\\n    if(!flag){\\n        ans = max(ans,soln(prices,idx+1,1)-prices[idx]);\\n        ans = max(ans,soln(prices,idx+1,0));\\n    }else{\\n        ans = max(ans,soln(prices,idx+2,0)+prices[idx]);\\n        ans = max(ans,soln(prices,idx+1,1));\\n    }\\n    return ans;\\n}\\n    int maxProfit(vector<int>& prices) {\\n        return soln(prices,0,0);\\n    }\\n};\\n\\n//Using dp\\n\\nclass Solution {\\npublic:\\nint soln(vector<vector<int>>&dp,vector<int>&prices,int idx,int flag){\\n    if(idx>=prices.size()){\\n        return 0;\\n    }\\n    if(dp[idx][flag] != -1){\\n        return dp[idx][flag];\\n    }\\n    int ans = INT_MIN;\\n    if(!flag){\\n        ans = max(ans,soln(dp,prices,idx+1,1)-prices[idx]);\\n        ans = max(ans,soln(dp,prices,idx+1,0));\\n    }else{\\n        ans = max(ans,soln(dp,prices,idx+2,0)+prices[idx]);\\n        ans = max(ans,soln(dp,prices,idx+1,1));\\n    }\\n    return dp[idx][flag] = ans;\\n}\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n        return soln(dp,prices,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175674,
                "title": "probably-the-most-intuitive-and-easy-to-understand-code-with-explanation",
                "content": "Just ask yourself what are you trying to do here.\\n\\n1. If I don\\'t have a stock today, then I either sold a stock today or I am not buying any today.\\n\\t* If I am not buying,  `profitWithoutStock = profitWithoutStockYesterday`\\n\\t* If I sold a stock, `profitWithoutStock = profitWithStockYesterday + prices[i]`\\n\\t* So `profitWithoutStock = Math.Max(profitWithoutStockYesterday, profitWithStockYesterday+prices[i]);` \\n\\t\\n2. I have a stock today, then either I am holding my stock from yesterday or I bought a stock today.\\n\\t* If I am holding, `profitWithStock = profitWithStockYesterday`\\n\\t* If I bought a stock, then because of the 1-day cooldown,  `profitWithStock = profitWithoutStockDayBeforeYesterday - prices[i]`\\n\\t* So `profitWithStock = Math.Max(profitWithStockYesterday, profitWithoutStockDayBeforeYesterday-prices[i]);`\\n\\nOn the first day, `profitWithStock = -prices[0]` and `profitWithoutStock = 0`\\n\\nThe final result is `profitWithoutStock`.\\n\\nAll the lines above translated into code below :)\\n\\n``` csharp\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int n = prices.Length;\\n\\t\\t\\n\\t\\tvar profitWithoutStock = 0;\\n        var profitWithoutStockYesterday = 0;\\n        var profitWithoutStockDayBeforeYesterday = 0;\\n\\t\\t\\n        var profitWithStock = 0;\\n        var profitWithStockYesterday = -prices[0];\\n                \\n        for(int i=1; i<n; i++){\\n\\t\\t\\t// As expained in 1 and 2\\n            profitWithoutStock = Math.Max(profitWithoutStockYesterday, profitWithStockYesterday+prices[i]);\\n            profitWithStock = Math.Max(profitWithStockYesterday, profitWithoutStockDayBeforeYesterday-prices[i]);\\n            \\n\\t\\t\\t// Reassign variables for the next iteration\\n            profitWithoutStockDayBeforeYesterday = profitWithoutStockYesterday;\\n            profitWithoutStockYesterday = profitWithoutStock;\\n            profitWithStockYesterday = profitWithStock;\\n        }\\n        \\n        return profitWithoutStock;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int n = prices.Length;\\n\\t\\t\\n\\t\\tvar profitWithoutStock = 0;\\n        var profitWithoutStockYesterday = 0;\\n        var profitWithoutStockDayBeforeYesterday = 0;\\n\\t\\t\\n        var profitWithStock = 0;\\n        var profitWithStockYesterday = -prices[0];\\n                \\n        for(int i=1; i<n; i++){\\n\\t\\t\\t// As expained in 1 and 2\\n            profitWithoutStock = Math.Max(profitWithoutStockYesterday, profitWithStockYesterday+prices[i]);\\n            profitWithStock = Math.Max(profitWithStockYesterday, profitWithoutStockDayBeforeYesterday-prices[i]);\\n            \\n\\t\\t\\t// Reassign variables for the next iteration\\n            profitWithoutStockDayBeforeYesterday = profitWithoutStockYesterday;\\n            profitWithoutStockYesterday = profitWithoutStock;\\n            profitWithStockYesterday = profitWithStock;\\n        }\\n        \\n        return profitWithoutStock;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347053,
                "title": "dp-with-explaination-easy-to-understand",
                "content": "NOTICE:\\n1.Each day we can have 3 operations : buy, sell or cooldown(do nothing)\\n2.We can only sell after buy\\n3.Must be a cooldown after sell\\n\\nTo sovle this problem with DP, we can give 2 definition :\\n1.buy[i], means the max profit we can get if the status **end with buy([buy,cooldown,cooldown] also means end with buy)** at i-th day(i=0,1,2...)\\n2.sell[i], means the max profit we can get if the status **end with sell([sell,cooldown,cooldown] also means end with sell)** at i-th day(i=0,1,2...)\\n**(Understand end with buy(sell) is important)**\\n\\nObviously,  buy[i] >= buy[i-1] >= ...... buy[1] >=buy[0] and sell[i] >= sell[i-1] >= ...... sell[1] >=sell[0]\\n\\nWe don\\'t need to define cooldown[i] which means the max profit we can get if status end with cooldown at i-th day(i=0,1,2...).Because if give any 2 variables of { buy, sell, cooldown } , and the last variable can be fixed.\\n\\nTo calculate buy[i]:\\n1.If we choose to buy at i-th day, then buy[i] = sell[i-2]-prices[i]. Because the i-1-th day must be cooldown, and we spend prices[i] to buy.\\n2.If we choose to cooldown at i-th day,  then buy[i] = buy[i-1].Notice this also means end with buy.\\nSo buy[i] = max(sell[i-2]-prices[i],buy[i-1])\\n\\nTo calculate sell[i]:\\n1.If we choose to sell at i-th day, then sell[i] = buy[i-1]+prices[i]. \\n2.If we choose to cooldown at i-th day,  then sell[i] = sell[i-1].\\nSo sell[i] = max(buy[i-1]+prices[i],sell[i-1])\\n\\nFinally, the max profit we can get is sell[len-1] (len = prices.size()). Because sell always after buy.\\n\\nThere is my simple C++ code:\\n```\\nint maxProfit(vector<int>& prices) {\\n        int len = prices.size();\\n        if(len < 2)\\n            return 0;\\n        vector<int> buy(len),sell(len);\\n        buy[0] = -prices[0];\\n        buy[1] = max(buy[0],-prices[1]);\\n        sell[1] = max(0,prices[1]-prices[0]);\\n        for(int i=2;i<len;++i){\\n            buy[i] = max(buy[i-1],sell[i-2]-prices[i]);\\n            sell[i] = max(buy[i-1]+prices[i],sell[i-1]);\\n        }\\n        return sell[len-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n        int len = prices.size();\\n        if(len < 2)\\n            return 0;\\n        vector<int> buy(len),sell(len);\\n        buy[0] = -prices[0];\\n        buy[1] = max(buy[0],-prices[1]);\\n        sell[1] = max(0,prices[1]-prices[0]);\\n        for(int i=2;i<len;++i){\\n            buy[i] = max(buy[i-1],sell[i-2]-prices[i]);\\n            sell[i] = max(buy[i-1]+prices[i],sell[i-1]);\\n        }\\n        return sell[len-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240277,
                "title": "java-solution-in-chinese",
                "content": "\\u8FD9\\u662F\\u4E00\\u4E2A\\u6570\\u7EC4\\u7C7B\\u95EE\\u9898\\uFF0C\\u9996\\u5148\\u8003\\u8651\\u7684\\u662F\\u52A8\\u6001\\u89C4\\u5212\\u662F\\u5426\\u80FD\\u89E3\\u51B3\\u95EE\\u9898\\u3002\\u672C\\u9898\\u6709\\u4E09\\u4E2A\\u52A8\\u4F5C\\uFF1Abuy\\u3001sell \\u548C cooldown\\uFF0C\\u7136\\u540E\\u770B\\u4E00\\u4E0B\\u6761\\u4EF6\\uFF1A\\n\\n1.  sell \\u9700\\u8981\\u53D1\\u751F\\u5728 buy \\u540E\\n2.  sell \\u540E\\u9700\\u8981\\u8DDF\\u4E00\\u4E2A cooldown\\n\\n\\u6309\\u7406\\u6765\\u8BF4\\uFF0C\\u8FD9\\u4E09\\u4E2A\\u52A8\\u4F5C\\u662F\\u53EF\\u4EE5\\u53D1\\u751F\\u5728\\u6574\\u4E2A\\u6570\\u7EC4\\u7684\\u4EFB\\u4F55\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u7684\\uFF0C\\u4E0D\\u8FC7\\u8FD8\\u6709\\u4E00\\u4E0B\\u6761\\u4EF6\\uFF1A\\n\\n1.  buy\\n    \\u56E0\\u4E3A buy \\u4E0E sell \\u9700\\u8981\\u4EA4\\u66FF\\u51FA\\u73B0\\uFF0C\\u90A3\\u4E48\\u5F53\\u67D0\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u53EF\\u4EE5\\u9009\\u62E9 buy \\u52A8\\u4F5C\\u7684\\u65F6\\u5019\\uFF0C\\u5728\\u5B83\\u7684\\u524D\\u9762\\u51FA\\u73B0\\u7684\\u5E94\\u8BE5\\u662F sell \\uFF0C\\u5E76\\u4E14\\u4ED6\\u7684\\u4E0A\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u4E0D\\u80FD\\u662F sell\\uFF08\\u6761\\u4EF62\\uFF09\\n2.  sell\\n    \\u5728\\u4ED6\\u7684\\u524D\\u9762\\u51FA\\u73B0\\u7684\\u5E94\\u8BE5\\u662F buy\\n3.  cooldown\\n    \\u6CA1\\u6709\\u6761\\u4EF6\\n\\n\\u672C\\u9898\\u8981\\u6C42\\u7684\\u662F\\u4E00\\u8FDE\\u4E32\\u4E70\\u5356\\u4E4B\\u540E\\u7684\\u5229\\u6DA6\\uFF0C\\u90A3\\u4E48\\u5982\\u679C\\u5047\\u8BBE\\u4E00\\u4E2A\\u4EBA\\u6700\\u5F00\\u59CB\\u62E5\\u6709\\u7684\\u94B1\\u662F 0 \\uFF08\\u53EF\\u4EE5\\u4E3A\\u8D1F\\uFF09\\uFF0C\\u90A3\\u4E48\\u6700\\u7EC8\\u8FD9\\u4E2A\\u4EBA\\u624B\\u91CC\\u7684\\u94B1\\u5C31\\u662F\\u4ED6\\u7684\\u5229\\u6DA6\\u3002\\u5982\\u679C\\u4F7F\\u7528\\u52A8\\u6001\\u89C4\\u5212\\u7684\\u8BDD\\uFF0C\\u9700\\u8981\\u58F0\\u660E\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u8FD9\\u4E2A\\u6570\\u7EC4\\u4F4D\\u7F6E i \\u7684\\u503C\\uFF0C\\u5C31\\u662F\\u5230 i \\u4E3A\\u6B62\\uFF0C\\u8FD9\\u4E2A\\u4EBA\\u624B\\u4E2D\\u7684\\u94B1\\uFF0C\\u4E5F\\u5C31\\u662F\\u4ED6\\u7684\\u5229\\u6DA6\\u3002\\u4F46\\u662F\\u5728\\u672C\\u9898\\u4E2D\\uFF0C\\u67D0\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u9700\\u8981\\u5224\\u65AD\\u7684\\u6709\\u4E24\\u79CD\\u60C5\\u51B5\\uFF0Cbuy \\u6216\\u8005 sell \\uFF08cooldown \\u53EF\\u770B\\u4F5C\\u662F\\u65E0\\u52A8\\u4F5C\\uFF0C\\u76F4\\u63A5\\u7EE7\\u627F\\u524D\\u4E00\\u4F4D\\u7F6E\\u5373\\u53EF\\uFF09\\u3002\\u5E76\\u4E14\\u56E0\\u4E3A sell \\u4E0E buy \\u662F\\u4EA4\\u66FF\\u51FA\\u73B0\\u7684\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u5F53\\u524D\\u4F4D\\u7F6E\\u5982\\u679C\\u662F buy \\uFF0C\\u90A3\\u4E48\\u9700\\u8981\\u524D\\u9762\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u52A8\\u4F5C\\u4E3A sell \\u7684\\u7ED3\\u679C\\u4F5C\\u4E3A\\u4F9D\\u8D56\\uFF0C\\u76F8\\u53CD\\uFF0C\\u5982\\u679C\\u5F53\\u524D\\u4F4D\\u7F6E\\u9009\\u62E9 sell \\u52A8\\u4F5C\\uFF0C\\u9700\\u8981\\u524D\\u9762\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u52A8\\u4F5C\\u4E3A buy \\u7684\\u7ED3\\u679C\\u4F5C\\u4E3A\\u4F9D\\u8D56\\u3002\\u5982\\u6B64\\u4E00\\u6765\\uFF0C\\u6BCF\\u4E2A\\u4F4D\\u7F6E\\u9700\\u8981\\u4E24\\u4E2A\\u6570\\uFF0C\\u5206\\u522B\\u4FDD\\u5B58\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E3A buy \\u548C sell \\u7684\\u7ED3\\u679C\\u3002\\u4E5F\\u5C31\\u662F\\u8BF4\\u6574\\u4E2A\\u89E3\\u9898\\u8FC7\\u7A0B\\u9700\\u8981\\u4E24\\u4E2A\\u6570\\u7EC4\\u4FDD\\u5B58\\u8FD9\\u4E9B\\u7ED3\\u679C\\u3002\\n\\n\\u90A3\\u4E48\\uFF0C\\u4FBF\\u6709\\u5982\\u4E0B\\u516C\\u5F0F\\uFF1A\\n\\n    buy[i] = max(buy[i-1], sell[i-2] - prices[i]);\\n    sell[i] = max(sell[i-1], buy[i-1] + prices[i]);\\n\\n\\u6216\\u8005\\u5C06\\u5176\\u5206\\u5F00\\u6765\\u770B\\uFF0C\\u5BF9\\u4E8E\\u4F4D\\u7F6E\\u4E3A i \\u7684\\u89E3\\uFF1A\\n\\n1.  \\u5982\\u679C\\u8FD9\\u4E00\\u4F4D\\u7F6E\\u9009\\u62E9 buy\\n    \\u9700\\u8981\\u5728\\u4E0A\\u4E00\\u4E2A sell \\u7684\\u57FA\\u7840\\u4E0A\\u6267\\u884C buy \\u52A8\\u4F5C\\uFF0C\\u53C8\\u56E0\\u4E3A\\u6761\\u4EF6 1 \\uFF0C\\u9700\\u8981\\u518D\\u9694\\u4E00\\u4E2A\\u4F4D\\u7F6E\\uFF1Abuy[i] = sell[i-2] - prices[i]\\n2.  \\u5982\\u679C\\u8FD9\\u4E00\\u4F4D\\u7F6E\\u9009\\u62E9 sell\\n    \\u9700\\u8981\\u5728\\u4E0A\\u4E00\\u4E2A buy \\u7684\\u57FA\\u7840\\u4E0A\\u6267\\u884C sell \\u52A8\\u4F5C\\uFF0C\\u5219sell[i] = buy[i-1] + prices[i]\\n3.  \\u5982\\u679C\\u9009\\u62E9 cooldown\\n    \\u76F4\\u63A5\\u7EE7\\u627F\\u4E0A\\u4E00\\u4F4D\\u7F6E\\u89E3\\uFF0C\\u5373buy[i] = buy[i-1], sell[i] = sell[i-1]\\n\\n\\u4E3A\\u4E86\\u6C42\\u6700\\u4F18\\u89E3\\uFF0Cbuy \\u548C sell \\u4E24\\u4E2A\\u6570\\u7EC4\\u90FD\\u8981\\u4FDD\\u5B58\\u8FD9\\u4E09\\u79CD\\u60C5\\u51B5\\u4E2D\\u6570\\u503C\\u6700\\u5927\\u7684\\u89E3\\uFF08\\u5373\\u624B\\u4E2D\\u7684\\u94B1\\u6700\\u591A\\uFF0C\\u4E5F\\u5C31\\u662F\\u5229\\u6DA6\\u6700\\u591A\\uFF09\\u3002\\u6240\\u4EE5\\uFF0C\\u5C06\\u5176\\u6574\\u7406\\u4E3A\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n    private static int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) return 0;\\n        int[] buy = new int[prices.length];\\n        int[] sell = new int[prices.length];\\n        buy[0] = -prices[0];\\n        sell[0] = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            buy[i] = Math.max(buy[i-1], (i > 1 ? sell[i - 2] : 0) - prices[i]);\\n            sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i]);\\n        }\\n        return sell[prices.length-1];\\n    }\\n\\n\\u53E6\\u5916\\uFF0C\\u56E0\\u4E3A\\u53EA\\u6709\\u5B8C\\u6210\\u4E86\\u5B8C\\u6574 buy-sell \\u52A8\\u4F5C\\uFF0C\\u624D\\u80FD\\u7B97\\u4F5C\\u662F\\u5229\\u6DA6\\uFF0C\\u6240\\u4EE5\\uFF0C\\u6700\\u7EC8\\u4EE3\\u8868\\u5229\\u6DA6\\u7684\\u5E94\\u8BE5\\u662F sell \\u6570\\u7EC4\\u7684\\u6700\\u540E\\u4E00\\u4F4D\\u3002\\n",
                "solutionTags": [],
                "code": "\\u8FD9\\u662F\\u4E00\\u4E2A\\u6570\\u7EC4\\u7C7B\\u95EE\\u9898\\uFF0C\\u9996\\u5148\\u8003\\u8651\\u7684\\u662F\\u52A8\\u6001\\u89C4\\u5212\\u662F\\u5426\\u80FD\\u89E3\\u51B3\\u95EE\\u9898\\u3002\\u672C\\u9898\\u6709\\u4E09\\u4E2A\\u52A8\\u4F5C\\uFF1Abuy\\u3001sell \\u548C cooldown\\uFF0C\\u7136\\u540E\\u770B\\u4E00\\u4E0B\\u6761\\u4EF6\\uFF1A\\n\\n1.  sell \\u9700\\u8981\\u53D1\\u751F\\u5728 buy \\u540E\\n2.  sell \\u540E\\u9700\\u8981\\u8DDF\\u4E00\\u4E2A cooldown\\n\\n\\u6309\\u7406\\u6765\\u8BF4\\uFF0C\\u8FD9\\u4E09\\u4E2A\\u52A8\\u4F5C\\u662F\\u53EF\\u4EE5\\u53D1\\u751F\\u5728\\u6574\\u4E2A\\u6570\\u7EC4\\u7684\\u4EFB\\u4F55\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u7684\\uFF0C\\u4E0D\\u8FC7\\u8FD8\\u6709\\u4E00\\u4E0B\\u6761\\u4EF6\\uFF1A\\n\\n1.  buy\\n    \\u56E0\\u4E3A buy \\u4E0E sell \\u9700\\u8981\\u4EA4\\u66FF\\u51FA\\u73B0\\uFF0C\\u90A3\\u4E48\\u5F53\\u67D0\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u53EF\\u4EE5\\u9009\\u62E9 buy \\u52A8\\u4F5C\\u7684\\u65F6\\u5019\\uFF0C\\u5728\\u5B83\\u7684\\u524D\\u9762\\u51FA\\u73B0\\u7684\\u5E94\\u8BE5\\u662F sell \\uFF0C\\u5E76\\u4E14\\u4ED6\\u7684\\u4E0A\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u4E0D\\u80FD\\u662F sell\\uFF08\\u6761\\u4EF62\\uFF09\\n2.  sell\\n    \\u5728\\u4ED6\\u7684\\u524D\\u9762\\u51FA\\u73B0\\u7684\\u5E94\\u8BE5\\u662F buy\\n3.  cooldown\\n    \\u6CA1\\u6709\\u6761\\u4EF6\\n\\n\\u672C\\u9898\\u8981\\u6C42\\u7684\\u662F\\u4E00\\u8FDE\\u4E32\\u4E70\\u5356\\u4E4B\\u540E\\u7684\\u5229\\u6DA6\\uFF0C\\u90A3\\u4E48\\u5982\\u679C\\u5047\\u8BBE\\u4E00\\u4E2A\\u4EBA\\u6700\\u5F00\\u59CB\\u62E5\\u6709\\u7684\\u94B1\\u662F 0 \\uFF08\\u53EF\\u4EE5\\u4E3A\\u8D1F\\uFF09\\uFF0C\\u90A3\\u4E48\\u6700\\u7EC8\\u8FD9\\u4E2A\\u4EBA\\u624B\\u91CC\\u7684\\u94B1\\u5C31\\u662F\\u4ED6\\u7684\\u5229\\u6DA6\\u3002\\u5982\\u679C\\u4F7F\\u7528\\u52A8\\u6001\\u89C4\\u5212\\u7684\\u8BDD\\uFF0C\\u9700\\u8981\\u58F0\\u660E\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u8FD9\\u4E2A\\u6570\\u7EC4\\u4F4D\\u7F6E i \\u7684\\u503C\\uFF0C\\u5C31\\u662F\\u5230 i \\u4E3A\\u6B62\\uFF0C\\u8FD9\\u4E2A\\u4EBA\\u624B\\u4E2D\\u7684\\u94B1\\uFF0C\\u4E5F\\u5C31\\u662F\\u4ED6\\u7684\\u5229\\u6DA6\\u3002\\u4F46\\u662F\\u5728\\u672C\\u9898\\u4E2D\\uFF0C\\u67D0\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u9700\\u8981\\u5224\\u65AD\\u7684\\u6709\\u4E24\\u79CD\\u60C5\\u51B5\\uFF0Cbuy \\u6216\\u8005 sell \\uFF08cooldown \\u53EF\\u770B\\u4F5C\\u662F\\u65E0\\u52A8\\u4F5C\\uFF0C\\u76F4\\u63A5\\u7EE7\\u627F\\u524D\\u4E00\\u4F4D\\u7F6E\\u5373\\u53EF\\uFF09\\u3002\\u5E76\\u4E14\\u56E0\\u4E3A sell \\u4E0E buy \\u662F\\u4EA4\\u66FF\\u51FA\\u73B0\\u7684\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u5F53\\u524D\\u4F4D\\u7F6E\\u5982\\u679C\\u662F buy \\uFF0C\\u90A3\\u4E48\\u9700\\u8981\\u524D\\u9762\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u52A8\\u4F5C\\u4E3A sell \\u7684\\u7ED3\\u679C\\u4F5C\\u4E3A\\u4F9D\\u8D56\\uFF0C\\u76F8\\u53CD\\uFF0C\\u5982\\u679C\\u5F53\\u524D\\u4F4D\\u7F6E\\u9009\\u62E9 sell \\u52A8\\u4F5C\\uFF0C\\u9700\\u8981\\u524D\\u9762\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u52A8\\u4F5C\\u4E3A buy \\u7684\\u7ED3\\u679C\\u4F5C\\u4E3A\\u4F9D\\u8D56\\u3002\\u5982\\u6B64\\u4E00\\u6765\\uFF0C\\u6BCF\\u4E2A\\u4F4D\\u7F6E\\u9700\\u8981\\u4E24\\u4E2A\\u6570\\uFF0C\\u5206\\u522B\\u4FDD\\u5B58\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E3A buy \\u548C sell \\u7684\\u7ED3\\u679C\\u3002\\u4E5F\\u5C31\\u662F\\u8BF4\\u6574\\u4E2A\\u89E3\\u9898\\u8FC7\\u7A0B\\u9700\\u8981\\u4E24\\u4E2A\\u6570\\u7EC4\\u4FDD\\u5B58\\u8FD9\\u4E9B\\u7ED3\\u679C\\u3002\\n\\n\\u90A3\\u4E48\\uFF0C\\u4FBF\\u6709\\u5982\\u4E0B\\u516C\\u5F0F\\uFF1A\\n\\n    buy[i] = max(buy[i-1], sell[i-2] - prices[i]);\\n    sell[i] = max(sell[i-1], buy[i-1] + prices[i]);\\n\\n\\u6216\\u8005\\u5C06\\u5176\\u5206\\u5F00\\u6765\\u770B\\uFF0C\\u5BF9\\u4E8E\\u4F4D\\u7F6E\\u4E3A i \\u7684\\u89E3\\uFF1A\\n\\n1.  \\u5982\\u679C\\u8FD9\\u4E00\\u4F4D\\u7F6E\\u9009\\u62E9 buy\\n    \\u9700\\u8981\\u5728\\u4E0A\\u4E00\\u4E2A sell \\u7684\\u57FA\\u7840\\u4E0A\\u6267\\u884C buy \\u52A8\\u4F5C\\uFF0C\\u53C8\\u56E0\\u4E3A\\u6761\\u4EF6 1 \\uFF0C\\u9700\\u8981\\u518D\\u9694\\u4E00\\u4E2A\\u4F4D\\u7F6E\\uFF1Abuy[i] = sell[i-2] - prices[i]\\n2.  \\u5982\\u679C\\u8FD9\\u4E00\\u4F4D\\u7F6E\\u9009\\u62E9 sell\\n    \\u9700\\u8981\\u5728\\u4E0A\\u4E00\\u4E2A buy \\u7684\\u57FA\\u7840\\u4E0A\\u6267\\u884C sell \\u52A8\\u4F5C\\uFF0C\\u5219sell[i] = buy[i-1] + prices[i]\\n3.  \\u5982\\u679C\\u9009\\u62E9 cooldown\\n    \\u76F4\\u63A5\\u7EE7\\u627F\\u4E0A\\u4E00\\u4F4D\\u7F6E\\u89E3\\uFF0C\\u5373buy[i] = buy[i-1], sell[i] = sell[i-1]\\n\\n\\u4E3A\\u4E86\\u6C42\\u6700\\u4F18\\u89E3\\uFF0Cbuy \\u548C sell \\u4E24\\u4E2A\\u6570\\u7EC4\\u90FD\\u8981\\u4FDD\\u5B58\\u8FD9\\u4E09\\u79CD\\u60C5\\u51B5\\u4E2D\\u6570\\u503C\\u6700\\u5927\\u7684\\u89E3\\uFF08\\u5373\\u624B\\u4E2D\\u7684\\u94B1\\u6700\\u591A\\uFF0C\\u4E5F\\u5C31\\u662F\\u5229\\u6DA6\\u6700\\u591A\\uFF09\\u3002\\u6240\\u4EE5\\uFF0C\\u5C06\\u5176\\u6574\\u7406\\u4E3A\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n    private static int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) return 0;\\n        int[] buy = new int[prices.length];\\n        int[] sell = new int[prices.length];\\n        buy[0] = -prices[0];\\n        sell[0] = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            buy[i] = Math.max(buy[i-1], (i > 1 ? sell[i - 2] : 0) - prices[i]);\\n            sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i]);\\n        }\\n        return sell[prices.length-1];\\n    }\\n\\n\\u53E6\\u5916\\uFF0C\\u56E0\\u4E3A\\u53EA\\u6709\\u5B8C\\u6210\\u4E86\\u5B8C\\u6574 buy-sell \\u52A8\\u4F5C\\uFF0C\\u624D\\u80FD\\u7B97\\u4F5C\\u662F\\u5229\\u6DA6\\uFF0C\\u6240\\u4EE5\\uFF0C\\u6700\\u7EC8\\u4EE3\\u8868\\u5229\\u6DA6\\u7684\\u5E94\\u8BE5\\u662F sell \\u6570\\u7EC4\\u7684\\u6700\\u540E\\u4E00\\u4F4D\\u3002\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2538849,
                "title": "dp-solution-and-thinking-process-beats-93-with-memory-optimization",
                "content": "## Definition\\n\\nDefine `dp[i][state]` as the max profit at the end of day `i`, where the first dimension is the index of the day, and the second denotes its state **at the end of day `i`**:\\n\\n- 0: we currently have one share of the stock, so we can sell or hold (do nothing) on the next day\\n- 1: we currently don\\u2019t have any share of the stock and are stamped with a \\u201Ccooldown\\u201D mark (meaning must cooldown next day), so we can do nothing on the next day\\n- 2: we currently don\\u2019t have any share of the stock and are not stamped with a \\u201Ccooldown\\u201D mark, so we can buy or hold on the next day\\n\\n## State Transition\\n\\n1. `dp[i][0]`\\n    \\n    The stock on hand at the end of day `i`could be:\\n    \\n    1. already owned on day `i-1`\\n    2. bought on day `i`, which means we have no stock and are stamped with \\u201Ccooldown\\u201D on day `i-1`\\n    \\n    so, `dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])`\\n    \\n2. `dp[i][1]`\\n    \\n    We currently have no stock and are stamped with \\u201Ccooldown\\u201D, which means we sold a share of the stock on day `i` and we must hold one share on day `i-1`. So, `dp[i][1] = dp[i-1][0] + prices[i]`\\n    \\n3. `dp[i][2]`\\n    \\n    Have no stock and are not stamped with \\u201Ccooldown\\u201D, which means we have no stock on day `i-1`. So, the state of day `i-1` could be either marked as cooldown or not. So, `dp[i][2] = max(dp[i-1][1], dp[i-1][2])`\\n    \\n\\nThe max profit during a n-day period is `max(dp[n][0], dp[n][1], dp[n][2])`. Notice that having any share of the stock at the end of day `n` is not wise if we want to get the maximum profit, so the result is `max(dp[n][1], dp[n][2])`\\n\\n## Initialization\\n\\n1. `dp[0][0] = -prices[0]`, the stock on hand at the end of the first day could only be bought on this day\\n2. `dp[0][1] = 0`. Even though we couldn\\u2019t be stamped as cooldown on the first day, it will be harmless to initialize it as 0. Because`dp[0][1]` only affects `dp[1][2]` and `dp[1][2] = max(dp[0][1], dp[0][2])`, `dp[1][2]` must be `dp[0][2]`, so as long as `dp[0][1] <= dp[0][2]`, it does not affect the result.\\n3. `dp[0][2] = 0`, which is obvious\\n\\n## Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        dp = [[0, 0, 0] for _ in xrange(n)]\\n        dp[0][0] = -prices[0]\\n        \\n        for i in xrange(1, n):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])\\n            dp[i][1] = dp[i-1][0] + prices[i]\\n            dp[i][2] = max(dp[i-1][1], dp[i-1][2])\\n        return max(dp[-1][1], dp[-1][2])\\n```\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n![image](https://assets.leetcode.com/users/images/1b2c0661-a44c-4197-b93b-afac8d485b12_1662450361.6423895.png)\\n\\n## Optimization of Memory\\n\\nNotice that the states on day `i` depend only on those on day `i-1`, so we don\\u2019t have to store the information before day `i-1`. So, we just need to store `dp[i-1][0]`, `dp[i-1][1]`, and `dp[i-1][2]`, and use them to update states on day `i`.\\n\\n## Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        state0, state1, state2 = -prices[0], 0, 0\\n        \\n        for i in xrange(1, n):\\n            state00 = max(state0, state2 - prices[i])\\n            state11 = state0 + prices[i]\\n            state22 = max(state1, state2)\\n            state0, state1, state2 = state00, state11, state22\\n        return max(state1, state2)\\n```\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n![image](https://assets.leetcode.com/users/images/36c8159a-6db6-429e-b61c-e3d7098185b2_1662450417.0745394.png)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        dp = [[0, 0, 0] for _ in xrange(n)]\\n        dp[0][0] = -prices[0]\\n        \\n        for i in xrange(1, n):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])\\n            dp[i][1] = dp[i-1][0] + prices[i]\\n            dp[i][2] = max(dp[i-1][1], dp[i-1][2])\\n        return max(dp[-1][1], dp[-1][2])\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        state0, state1, state2 = -prices[0], 0, 0\\n        \\n        for i in xrange(1, n):\\n            state00 = max(state0, state2 - prices[i])\\n            state11 = state0 + prices[i]\\n            state22 = max(state1, state2)\\n            state0, state1, state2 = state00, state11, state22\\n        return max(state1, state2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438447,
                "title": "java-0ms-100-naive-dp-to-state-machine-tc-o-n-sc-o-1",
                "content": "# Naive DP\\n1. Everyday, we either buy, sell or do nothing.\\n2. Because after sell we have to wait for at least 1 day to buy, so every buy should come from sell 2 days before\\n```java\\nclass Solution {\\n   public int maxProfit(int[] p) {\\n      int n = p.length;\\n      if (n < 2) return 0;\\n\\n      int[] hold = new int[n + 1]; // after buy\\n      int[] sell = new int[n + 1]; // after sell\\n      hold[1] = -p[0];\\n      for (int i = 2; i <= n; i++) {\\n         hold[i] = Math.max(hold[i - 1], sell[i - 2] - p[i - 1]);\\n         sell[i] = Math.max(sell[i - 1], hold[i - 1] + p[i - 1]);\\n      }\\n      return sell[n];\\n   }\\n}\\n```\\n# Optimize space to O(1)\\nYou might realize this is the state machine solution everybody has been talking about.\\nh: max balance after buy\\ns: max profit after sell\\nc: cooldown (basically 1 day delayed sell price)\\n\\nSo on any day you can chose\\n\\n1. to buy from cooldown or do nothing\\n2. sell from buy\\n3. Cooldown is always 1 day delayed profit after sell\\n\\n```java\\nclass Solution {\\n   public int maxProfit(int[] p) {\\n      int n = p.length;\\n      if (n < 2) return 0;\\n      int h = -p[0], s = 0, c = 0; // state after buy(h for hold), sell, cool down\\n\\n      for (int x : p) {\\n         h = Math.max(h, c - x);\\n         c = s;\\n         s = Math.max(s, h + x);\\n      }\\n\\n      return s;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n   public int maxProfit(int[] p) {\\n      int n = p.length;\\n      if (n < 2) return 0;\\n\\n      int[] hold = new int[n + 1]; // after buy\\n      int[] sell = new int[n + 1]; // after sell\\n      hold[1] = -p[0];\\n      for (int i = 2; i <= n; i++) {\\n         hold[i] = Math.max(hold[i - 1], sell[i - 2] - p[i - 1]);\\n         sell[i] = Math.max(sell[i - 1], hold[i - 1] + p[i - 1]);\\n      }\\n      return sell[n];\\n   }\\n}\\n```\n```java\\nclass Solution {\\n   public int maxProfit(int[] p) {\\n      int n = p.length;\\n      if (n < 2) return 0;\\n      int h = -p[0], s = 0, c = 0; // state after buy(h for hold), sell, cool down\\n\\n      for (int x : p) {\\n         h = Math.max(h, c - x);\\n         c = s;\\n         s = Math.max(s, h + x);\\n      }\\n\\n      return s;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718950,
                "title": "java-simple-recursive-dp-memo",
                "content": "The solution is pretty intuitive. \\nThink of solving the problem top down. The recursive function `maxProfit (index, stock, prices, dp)` will give max profit from `index` to `n-1` \\n\\nThere are always two choices possible at an index.  From the below two cases choosing max(A, B) will give us the answer.\\n\\n**Case 1 :** Possible to Buy Stock\\nA - Reduce profit by `prices[index]` and flip to Case 2 \\nB -  Do nothing - cooldown\\n\\n**Case 2 :** Possible to Sell Stock\\nA -  Increase profit by `prices[index]` and flip to Case 1 (special case increment index by 2)\\nB - Do nothing - cooldown\\n\\n\\n```\\nclass Solution {\\n    private int maxProfit(int index, int stock, int[] prices, int[][] dp) {\\n        if (index >= prices.length) {\\n            return 0;\\n        }\\n        \\n        if (dp[stock][index] != -1) {\\n            return dp[stock][index];\\n        }\\n        \\n        if (stock == 0) {\\n            dp[stock][index] = Math.max(\\n                maxProfit(index + 1, 1, prices, dp) - prices[index],\\n                maxProfit(index + 1, 0, prices, dp)\\n            );\\n        } else {\\n            dp[stock][index] = Math.max(\\n                maxProfit(index + 2, 0, prices, dp) + prices[index],\\n                maxProfit(index + 1, 1, prices, dp)\\n            );\\n        }\\n        return dp[stock][index];\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        int[][] dp = new int[2][prices.length];\\n        for(int[] arr : dp) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return maxProfit(0, 0, prices, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private int maxProfit(int index, int stock, int[] prices, int[][] dp) {\\n        if (index >= prices.length) {\\n            return 0;\\n        }\\n        \\n        if (dp[stock][index] != -1) {\\n            return dp[stock][index];\\n        }\\n        \\n        if (stock == 0) {\\n            dp[stock][index] = Math.max(\\n                maxProfit(index + 1, 1, prices, dp) - prices[index],\\n                maxProfit(index + 1, 0, prices, dp)\\n            );\\n        } else {\\n            dp[stock][index] = Math.max(\\n                maxProfit(index + 2, 0, prices, dp) + prices[index],\\n                maxProfit(index + 1, 1, prices, dp)\\n            );\\n        }\\n        return dp[stock][index];\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        int[][] dp = new int[2][prices.length];\\n        for(int[] arr : dp) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return maxProfit(0, 0, prices, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540909,
                "title": "java-4-state-dp-easy-to-understand",
                "content": "The state can be classified as the following four, according to **what we do at each day**:\\n1. rest today **with stock**\\n2. rest today **without stock**\\n3. buy today\\n4. sell today\\n\\nLet\\'s examine transitions to each state one by one.\\n1. To rest today with stock, then on yesterday, we can only have two possibilities:\\n\\t1. we rested yesterday with stock, so we can do another rest today\\n\\t2. we bought stock yesterday, so we can rest today with stock\\n\\tAnd we can check that if we are in other two states yesterday (rest without stock, or sold yesterday), we cannot rest today **with stock**\\n2. To rest today without stock, we can be in following states yesterday:\\n\\t1. We rested yesterday without stock\\n\\t2. We sold our stock yesterday\\n3. To buy today, we must have **NO stock** before today, and did not sold, so yesterday we can only in:\\n\\t1. Rest without stock\\n4. To sell today, we can be in the following two states yesterday:\\n\\t1. Rest with stock\\n\\t2. bought stock yesterday \\n\\nThe transitions can be viewed as:\\n\\n![image](https://assets.leetcode.com/users/yyfyifan/image_1584317744.png)\\n\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n        \\n        int n = prices.length;\\n\\t\\t// 0: rest without stock\\n\\t\\t// 1: rest with stock\\n\\t\\t// 2: buy\\n\\t\\t// 3: sell\\n        int[][] dp = new int[n + 1][4];\\n\\t\\t// Initial values before the 0th day\\n        dp[0][0] = 0;\\n        dp[0][1] = Integer.MIN_VALUE / 2;\\n        dp[0][2] = Integer.MIN_VALUE / 2;\\n        dp[0][3] = 0;\\n        \\n\\t\\t// (i - 1)th day --> fill dp[i]\\n        for (int i = 1; i <= n; i++) {\\n            // 1. \\u6CA1\\u6709\\u80A1\\u7968+\\u4ECA\\u5929\\u4F11\\u606F\\uFF1A\\u53EF\\u80FD\\u6628\\u5929\\u5C31\\u662F\\u8FD9\\u4E2A\\u72B6\\u6001\\uFF0C\\u6216\\u8005\\u6628\\u5929\\u521A\\u5356\\n\\t\\t\\t// 1. Rest today + no stock:  same as yesterday, or just sold stock yesterday\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][3]);\\n            // 2. \\u6709\\u80A1\\u7968+\\u4ECA\\u5929\\u4F11\\u606F\\uFF1A\\u672C\\u6765\\u5C31\\u8FD9\\u6837\\uFF0C\\u6216\\u8005\\u6628\\u5929\\u624D\\u4E70\\n\\t\\t\\t// 2. Rest today + with stock: same as yesterday, or just bought stock yesterday\\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2]);\\n            // 3. \\u4ECA\\u5929\\u8981\\u4E70\\u4E86: \\u524D\\u4E00\\u5929\\u4F11\\u606F\\uFF0C\\u6CA1\\u6709\\u80A1\\u7968\\n\\t\\t\\t// 3. Buy today: Only situation is we rested without stock yesterday\\n            dp[i][2] = dp[i - 1][0] - prices[i - 1];\\n            // 4. \\u4ECA\\u5929\\u8981\\u5356\\u4E86\\uFF1A \\u524D\\u4E00\\u5929\\u4E70\\u4E86\\uFF0C\\u6216\\u8005\\u524D\\u4E00\\u5929\\u6709\\u80A1\\u7968\\u4F11\\u606F\\n\\t\\t\\t// 4. Sell today:  we bought stock yesterday, or we rest with stock yesterday.\\n            dp[i][3] = Math.max(dp[i - 1][2], dp[i - 1][1]) + prices[i - 1];\\n        }\\n        int max = 0;\\n        for (int i = 0; i < 4; i++) {\\n            max = Math.max(max, dp[n][i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n        \\n        int n = prices.length;\\n\\t\\t// 0: rest without stock\\n\\t\\t// 1: rest with stock\\n\\t\\t// 2: buy\\n\\t\\t// 3: sell\\n        int[][] dp = new int[n + 1][4];\\n\\t\\t// Initial values before the 0th day\\n        dp[0][0] = 0;\\n        dp[0][1] = Integer.MIN_VALUE / 2;\\n        dp[0][2] = Integer.MIN_VALUE / 2;\\n        dp[0][3] = 0;\\n        \\n\\t\\t// (i - 1)th day --> fill dp[i]\\n        for (int i = 1; i <= n; i++) {\\n            // 1. \\u6CA1\\u6709\\u80A1\\u7968+\\u4ECA\\u5929\\u4F11\\u606F\\uFF1A\\u53EF\\u80FD\\u6628\\u5929\\u5C31\\u662F\\u8FD9\\u4E2A\\u72B6\\u6001\\uFF0C\\u6216\\u8005\\u6628\\u5929\\u521A\\u5356\\n\\t\\t\\t// 1. Rest today + no stock:  same as yesterday, or just sold stock yesterday\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][3]);\\n            // 2. \\u6709\\u80A1\\u7968+\\u4ECA\\u5929\\u4F11\\u606F\\uFF1A\\u672C\\u6765\\u5C31\\u8FD9\\u6837\\uFF0C\\u6216\\u8005\\u6628\\u5929\\u624D\\u4E70\\n\\t\\t\\t// 2. Rest today + with stock: same as yesterday, or just bought stock yesterday\\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2]);\\n            // 3. \\u4ECA\\u5929\\u8981\\u4E70\\u4E86: \\u524D\\u4E00\\u5929\\u4F11\\u606F\\uFF0C\\u6CA1\\u6709\\u80A1\\u7968\\n\\t\\t\\t// 3. Buy today: Only situation is we rested without stock yesterday\\n            dp[i][2] = dp[i - 1][0] - prices[i - 1];\\n            // 4. \\u4ECA\\u5929\\u8981\\u5356\\u4E86\\uFF1A \\u524D\\u4E00\\u5929\\u4E70\\u4E86\\uFF0C\\u6216\\u8005\\u524D\\u4E00\\u5929\\u6709\\u80A1\\u7968\\u4F11\\u606F\\n\\t\\t\\t// 4. Sell today:  we bought stock yesterday, or we rest with stock yesterday.\\n            dp[i][3] = Math.max(dp[i - 1][2], dp[i - 1][1]) + prices[i - 1];\\n        }\\n        int max = 0;\\n        for (int i = 0; i < 4; i++) {\\n            max = Math.max(max, dp[n][i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392142,
                "title": "9-line-c-o-n-time-o-1-space-detailed-explanation",
                "content": "Definitions: \\n* `buy[i]`: the max profit **up to** day `i` with `buy` as last action;\\n* `sell[i]`: the max profit **up to** day `i` with `sell` as last action.\\n\\nThen we have transfer equations:\\n```\\nbuy[i] = max(sell[i-2]-price[i], buy[i-1])\\nsell[i] = max(buy[i-1]+price[i], sell[i-1])\\n```\\n\\nNote that `rest` is **not** considered as an action, and the last action could happen in **any** day up to day `i`. Therefore, for `buy[i]`, there can only be two cases: \\n- if the last `buy` didn\\'t happen on day `i`, max profit `buy[i]` is simply `buy[i-1]`; \\n- otherwise, a `sell` must happen at least **2** days ago (and no actions in between), so `buy[i] = sell[i-2]-price[i]`.\\n\\n```cpp\\n    int maxProfit(vector<int>& prices) {\\n      int buy /*buy[i]*/, buyPre = INT_MIN /*buy[i-1]*/;\\n      int sell = 0 /*sell[i]*/, sellPre1 = 0 /*sell[i-1]*/, sellPre2 = 0 /*sell[i-2]*/;\\n      \\n      for (int p : prices) {\\n\\t    // transfer equations\\n        buy = max(buyPre, sellPre2 - p);\\n        sell = max(sellPre1, buyPre + p);\\n        \\n\\t\\t// update for next iteration\\n        buyPre = buy;\\n        sellPre2 = sellPre1;\\n        sellPre1 = sell;\\n      }\\n      \\n      return sell;\\n    }\\n```\\n\\nComment: If we generalize the problem to have `k` cool down days:\\n```\\nbuy[i] = max(sell[i-k-1]-price, buy[i-1])\\nsell[i] = max(buy[i-1]+price, sell[i-1])\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbuy[i] = max(sell[i-2]-price[i], buy[i-1])\\nsell[i] = max(buy[i-1]+price[i], sell[i-1])\\n```\n```cpp\\n    int maxProfit(vector<int>& prices) {\\n      int buy /*buy[i]*/, buyPre = INT_MIN /*buy[i-1]*/;\\n      int sell = 0 /*sell[i]*/, sellPre1 = 0 /*sell[i-1]*/, sellPre2 = 0 /*sell[i-2]*/;\\n      \\n      for (int p : prices) {\\n\\t    // transfer equations\\n        buy = max(buyPre, sellPre2 - p);\\n        sell = max(sellPre1, buyPre + p);\\n        \\n\\t\\t// update for next iteration\\n        buyPre = buy;\\n        sellPre2 = sellPre1;\\n        sellPre1 = sell;\\n      }\\n      \\n      return sell;\\n    }\\n```\n```\\nbuy[i] = max(sell[i-k-1]-price, buy[i-1])\\nsell[i] = max(buy[i-1]+price, sell[i-1])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76001,
                "title": "share-my-greedy-and-c-solution-o-n-time-o-1-space",
                "content": "Generally this problem cannot be directly solved by greedy algorithm because the total value of the strategy you make on day 'i' will have an influence on the future because of the cool down, and that means a locally optimal plan is not necessarily a globally optimal plan.\\n\\nTo be greedy, we need to divide the problem into 2 sets and maybe on each set we can implement the greedy algorithm! Because we don't want the current operation to influence the future(which will result in a situation where a globally optimal plans don't include a locally optimal optimal plan). The influence to future is dependent on whether you have the stock at the beginning of day i. Thus you use two variables to represent the best profit on day i. Variable 'have' means you have the stock at the beginning of day i. Variable 'non' you don't have it at the beginning of that day. So in this way, variable 'have' will always take the risk of price change , but 'non' won't. so the price part is fixed, we need to be greedy on past. The greedy choice for 'have' on day i is the larger one of the 2 variables: 'have' on day i-1 or 'non' on day i-2. And the greedy choice for 'non' on day i is the larger one of 'have' on day i-1 or 'non' on day i-1. And the best plan is the larger one of the two variables on day n. \\n\\n\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            if(prices.size()<=1) return 0;\\n            int i,j,c=prices.size();\\n            int have=prices[1]-prices[0],non=0,nonn=0,temp;\\n            for(i=2;i<c;i++){\\n                temp=have;\\n                have=max(have,nonn)+prices[i]-prices[i-1];\\n                nonn=non;\\n                non=max(temp,non);\\n            }\\n            return max(have,non);\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            if(prices.size()<=1) return 0;\\n            int i,j,c=prices.size();\\n            int have=prices[1]-prices[0],non=0,nonn=0,temp;\\n            for(i=2;i<c;i++){\\n                temp=have;\\n                have=max(have,nonn)+prices[i]-prices[i-1];\\n                nonn=non;\\n                non=max(temp,non);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1698035,
                "title": "clean-recursive-memo-proper-variable-name",
                "content": "The code itself is well written, so there is not much to explain, its all choice based\\n```\\n\\tint dp[5001][2];\\n\\t\\n    int helper(vector<int> &prices, int curr, int n, bool hadBought){\\n        if(curr>=n){\\n            return 0;\\n        }\\n        if(dp[curr][hadBought]!=-1){\\n            return dp[curr][hadBought];\\n        }\\n        int profit=0;\\n        \\n        if(hadBought==false){\\n            int BUY=(-prices[curr])+helper(prices,curr+1,n,true);  // -ve price because buying takes money out of pocket\\n            int NOT_BUY=helper(prices,curr+1,n,hadBought);\\n            profit=max(BUY,NOT_BUY);\\n        }\\n        \\n        else{\\n            int SELL=prices[curr]+helper(prices,curr+2,n,false);\\n            int NOT_SELL=helper(prices,curr+1,n,hadBought);\\n            profit=max(SELL,NOT_SELL);\\n        }\\n        return dp[curr][hadBought]=profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices){\\n        memset(dp,-1,sizeof(dp));\\n        int n=prices.size();\\n        return helper(prices,0,n,false);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint dp[5001][2];\\n\\t\\n    int helper(vector<int> &prices, int curr, int n, bool hadBought){\\n        if(curr>=n){\\n            return 0;\\n        }\\n        if(dp[curr][hadBought]!=-1){\\n            return dp[curr][hadBought];\\n        }\\n        int profit=0;\\n        \\n        if(hadBought==false){\\n            int BUY=(-prices[curr])+helper(prices,curr+1,n,true);  // -ve price because buying takes money out of pocket\\n            int NOT_BUY=helper(prices,curr+1,n,hadBought);\\n            profit=max(BUY,NOT_BUY);\\n        }\\n        \\n        else{\\n            int SELL=prices[curr]+helper(prices,curr+2,n,false);\\n            int NOT_SELL=helper(prices,curr+1,n,hadBought);\\n            profit=max(SELL,NOT_SELL);\\n        }\\n        return dp[curr][hadBought]=profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices){\\n        memset(dp,-1,sizeof(dp));\\n        int n=prices.size();\\n        return helper(prices,0,n,false);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008431,
                "title": "java-recursive-memoization-2d-bottom-up-1d-bottom-up",
                "content": "```\\n- We have three possible states \\'buy, sell, cooldown\\'\\n\\t- When we are currently at \\'buy\\' state\\n\\t\\t- We will have two choices\\n\\t\\t\\t- We can buy the current stock or skip the current stock\\n\\t\\t\\t- We will pick the choice that will give us a higher profit\\n\\t- When we are currently at \\'sell\\' state\\n\\t\\t- We will have two choices\\n\\t\\t\\t- We can sell at the current stock or skip the current stock\\n\\t\\t\\t- We will pick the choice that will give us a higher profit\\n\\t- When we are current at \\'cooldown\\' state\\n\\t\\t- We will need to skip the current stock and change our state to \\'buy\\'\\n- We can indicate the three states using three integers\\n\\t- 0, buy\\n\\t- 1, sell\\n\\t- 2, cooldown\\n```\\n```\\npublic class BestTimeToBuyAndSellStockWithCooldownRecursiveApproach {\\n    public int maxProfit(int[] prices) {\\n        return maxProfit(0, 0, prices);\\n    }\\n\\n    private int maxProfit(int i, int state, int[] prices) {\\n        if (i >= prices.length) return 0;\\n        if (state == 2) return maxProfit(i + 1, 0, prices);\\n\\n        return state == 0?\\n            Math.max(maxProfit(i + 1, 1, prices) - prices[i],\\n                     maxProfit(i + 1, state, prices)) :\\n            Math.max(maxProfit(i + 1, 2, prices) + prices[i],\\n                     maxProfit(i + 1, state, prices));\\n    }\\n}\\n```\\n```\\npublic class BestTimeToBuyAndSellStockWithCooldownMemoizationApproach {\\n    public int maxProfit(int[] prices) {\\n        int[][] memo = new int[prices.length][3];\\n\\n        for (int r = 0; r < memo.length; r++) {\\n            Arrays.fill(memo[r], -1);\\n        }\\n\\n        return maxProfit(0, 0, prices, memo);\\n    }\\n\\n    private int maxProfit(int i, int state, int[] prices, int[][] memo) {\\n        if (i >= prices.length) return 0;\\n        if (state == 2) return maxProfit(i + 1, 0, prices, memo);\\n        if (memo[i][state] != -1) return memo[i][state];\\n\\n        return memo[i][state] = state == 0?\\n            Math.max(maxProfit(i + 1, 1, prices, memo) - prices[i],\\n                     maxProfit(i + 1, state, prices, memo)) :\\n            Math.max(maxProfit(i + 1, 2, prices, memo) + prices[i],\\n                     maxProfit(i + 1, state, prices, memo));\\n    }\\n}\\n```\\n```\\npublic class BestTimeToBuyAndSellStockWithCooldownBottomUp2DApproach {\\n    public int maxProfit(int[] prices) {\\n        int[][] profit = new int[prices.length + 1][3];\\n\\n        for (int i = prices.length - 1; i >= 0; i--) {\\n            for (int state = 2; state >= 0; state--) {\\n                if (state == 2) {\\n                    profit[i][state] = profit[i + 1][0];\\n                    continue;\\n                }\\n\\n                profit[i][state] = (state == 0) ?\\n                    Math.max(profit[i + 1][1] - prices[i], profit[i + 1][state]) :\\n                    Math.max(profit[i + 1][2] + prices[i], profit[i + 1][state]);\\n            }\\n        }\\n\\n        return profit[0][0];\\n    }\\n}\\n```\\n```\\npublic class BestTimeToBuyAndSellStockWithCooldownBottomUp1DApproach {\\n    public int maxProfit(int[] prices) {\\n        int[] profit = new int[3];\\n\\n        for (int i = prices.length - 1; i >= 0; i--) {\\n            int prev = 0;\\n\\n            for (int state = 2; state >= 0; state--) {\\n                if (state == 2) {\\n                    prev = profit[state];\\n                    profit[state] = profit[0];\\n                    continue;\\n                }\\n\\n                int cur = profit[state];\\n\\n                profit[state] = (state == 0) ?\\n                        Math.max(prev - prices[i], profit[state]) :\\n                        Math.max(prev + prices[i], profit[state]);\\n\\n                prev = cur;\\n            }\\n        }\\n\\n        return profit[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- We have three possible states \\'buy, sell, cooldown\\'\\n\\t- When we are currently at \\'buy\\' state\\n\\t\\t- We will have two choices\\n\\t\\t\\t- We can buy the current stock or skip the current stock\\n\\t\\t\\t- We will pick the choice that will give us a higher profit\\n\\t- When we are currently at \\'sell\\' state\\n\\t\\t- We will have two choices\\n\\t\\t\\t- We can sell at the current stock or skip the current stock\\n\\t\\t\\t- We will pick the choice that will give us a higher profit\\n\\t- When we are current at \\'cooldown\\' state\\n\\t\\t- We will need to skip the current stock and change our state to \\'buy\\'\\n- We can indicate the three states using three integers\\n\\t- 0, buy\\n\\t- 1, sell\\n\\t- 2, cooldown\\n```\n```\\npublic class BestTimeToBuyAndSellStockWithCooldownRecursiveApproach {\\n    public int maxProfit(int[] prices) {\\n        return maxProfit(0, 0, prices);\\n    }\\n\\n    private int maxProfit(int i, int state, int[] prices) {\\n        if (i >= prices.length) return 0;\\n        if (state == 2) return maxProfit(i + 1, 0, prices);\\n\\n        return state == 0?\\n            Math.max(maxProfit(i + 1, 1, prices) - prices[i],\\n                     maxProfit(i + 1, state, prices)) :\\n            Math.max(maxProfit(i + 1, 2, prices) + prices[i],\\n                     maxProfit(i + 1, state, prices));\\n    }\\n}\\n```\n```\\npublic class BestTimeToBuyAndSellStockWithCooldownMemoizationApproach {\\n    public int maxProfit(int[] prices) {\\n        int[][] memo = new int[prices.length][3];\\n\\n        for (int r = 0; r < memo.length; r++) {\\n            Arrays.fill(memo[r], -1);\\n        }\\n\\n        return maxProfit(0, 0, prices, memo);\\n    }\\n\\n    private int maxProfit(int i, int state, int[] prices, int[][] memo) {\\n        if (i >= prices.length) return 0;\\n        if (state == 2) return maxProfit(i + 1, 0, prices, memo);\\n        if (memo[i][state] != -1) return memo[i][state];\\n\\n        return memo[i][state] = state == 0?\\n            Math.max(maxProfit(i + 1, 1, prices, memo) - prices[i],\\n                     maxProfit(i + 1, state, prices, memo)) :\\n            Math.max(maxProfit(i + 1, 2, prices, memo) + prices[i],\\n                     maxProfit(i + 1, state, prices, memo));\\n    }\\n}\\n```\n```\\npublic class BestTimeToBuyAndSellStockWithCooldownBottomUp2DApproach {\\n    public int maxProfit(int[] prices) {\\n        int[][] profit = new int[prices.length + 1][3];\\n\\n        for (int i = prices.length - 1; i >= 0; i--) {\\n            for (int state = 2; state >= 0; state--) {\\n                if (state == 2) {\\n                    profit[i][state] = profit[i + 1][0];\\n                    continue;\\n                }\\n\\n                profit[i][state] = (state == 0) ?\\n                    Math.max(profit[i + 1][1] - prices[i], profit[i + 1][state]) :\\n                    Math.max(profit[i + 1][2] + prices[i], profit[i + 1][state]);\\n            }\\n        }\\n\\n        return profit[0][0];\\n    }\\n}\\n```\n```\\npublic class BestTimeToBuyAndSellStockWithCooldownBottomUp1DApproach {\\n    public int maxProfit(int[] prices) {\\n        int[] profit = new int[3];\\n\\n        for (int i = prices.length - 1; i >= 0; i--) {\\n            int prev = 0;\\n\\n            for (int state = 2; state >= 0; state--) {\\n                if (state == 2) {\\n                    prev = profit[state];\\n                    profit[state] = profit[0];\\n                    continue;\\n                }\\n\\n                int cur = profit[state];\\n\\n                profit[state] = (state == 0) ?\\n                        Math.max(prev - prices[i], profit[state]) :\\n                        Math.max(prev + prices[i], profit[state]);\\n\\n                prev = cur;\\n            }\\n        }\\n\\n        return profit[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738240,
                "title": "one-pass-dp-solution-in-4ms",
                "content": "Let dp[i] stand for the maximum profit of 0...i.\\nFor every single i, it can choose **not to sell at i**(dp[i-1]), or to **buy at j and sell at i**(prices[i] - prices[j] + dp[j-2]). (j < i)\\nThus **dp[i] = max(dp[i-1], prices[i] - prices[j] + dp[j-2]) = max(dp[i-1], prices[i] + max(dp[j-2] - prices[j])), 0 <= j < i**\\nBecause of dp[j-2], we need to manually initialize dp[0] & dp[1] and start from i==2.\\nObviously dp[0]=0. And dp[1] = max(dp[0], prices[1] - prices[0]) (To sell or not to sell).\\nlocal_max is the larger (-prices[i]) for i=0, 1.\\nAfter that, we can continuously compute dp[i] and update local_max.\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n < 2) return 0;\\n        int dp[n];\\n        memset(dp, 0, sizeof(dp));\\n        // dp[0] = 0;\\n        dp[1] = max(0, prices[1] - prices[0]);\\n        int local_max = max(-prices[0], -prices[1]);\\n        for (int i = 2; i < n; i++) {\\n            dp[i] = max(dp[i-1], prices[i] + local_max);\\n            local_max = max(local_max, dp[i-2] - prices[i]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\nAnother version avoiding manual initialization for i==1:\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n < 2) return 0;\\n        int dp[n];\\n        memset(dp, 0, sizeof(dp));\\n        // dp[0] = 0;\\n        int local_max = -prices[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = max(dp[i-1], prices[i] + local_max);\\n            if (i < 2) local_max = max(local_max, -prices[i]);\\n            else local_max = max(local_max, dp[i-2] - prices[i]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n < 2) return 0;\\n        int dp[n];\\n        memset(dp, 0, sizeof(dp));\\n        // dp[0] = 0;\\n        dp[1] = max(0, prices[1] - prices[0]);\\n        int local_max = max(-prices[0], -prices[1]);\\n        for (int i = 2; i < n; i++) {\\n            dp[i] = max(dp[i-1], prices[i] + local_max);\\n            local_max = max(local_max, dp[i-2] - prices[i]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n < 2) return 0;\\n        int dp[n];\\n        memset(dp, 0, sizeof(dp));\\n        // dp[0] = 0;\\n        int local_max = -prices[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = max(dp[i-1], prices[i] + local_max);\\n            if (i < 2) local_max = max(local_max, -prices[i]);\\n            else local_max = max(local_max, dp[i-2] - prices[i]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492344,
                "title": "100-java-with-comments-using-cash-in-hand",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        if(prices==null || prices.length<=1)return 0;\\n        \\n        int n=prices.length;\\n        int[] p = new int[n];\\n        int cash = 0; // how much cash do i have on hand\\n        \\n        p[0]=0; // no profit on day one\\n        cash = -prices[0]; // buy stock day one -> cash depleted, since i bought stock\\n        p[1]= Math.max(0, prices[1]-prices[0]); // can i already make profit by selling on day 2?\\n        cash = Math.max(cash,-prices[1]); // is the stock lower to day to buy ?\\n        \\n        //we have already valuated for first 2 days stock\\n        for(int i=2;i<n;i++){\\n            //will i get more profit if i sell my stock today ?\\n            // if not , cool down -> take the profit from previous day\\n            p[i] = Math.max(p[i-1], cash+prices[i]);\\n            \\n            //can i buy the stock today ? --> ONLY if its a cool down yesterday\\n            // if i buy my stock, mean previous day was cooldown\\n            // get the profit from day before to calculate the cash\\n            // profit - today\\'s price --> gives total cash in hand\\n            // buy only if it works out better ( increases cash in hand)\\n            cash = Math.max(cash, p[i-2]-prices[i]);\\n        }\\n        \\n        return p[n-1];        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        if(prices==null || prices.length<=1)return 0;\\n        \\n        int n=prices.length;\\n        int[] p = new int[n];\\n        int cash = 0; // how much cash do i have on hand\\n        \\n        p[0]=0; // no profit on day one\\n        cash = -prices[0]; // buy stock day one -> cash depleted, since i bought stock\\n        p[1]= Math.max(0, prices[1]-prices[0]); // can i already make profit by selling on day 2?\\n        cash = Math.max(cash,-prices[1]); // is the stock lower to day to buy ?\\n        \\n        //we have already valuated for first 2 days stock\\n        for(int i=2;i<n;i++){\\n            //will i get more profit if i sell my stock today ?\\n            // if not , cool down -> take the profit from previous day\\n            p[i] = Math.max(p[i-1], cash+prices[i]);\\n            \\n            //can i buy the stock today ? --> ONLY if its a cool down yesterday\\n            // if i buy my stock, mean previous day was cooldown\\n            // get the profit from day before to calculate the cash\\n            // profit - today\\'s price --> gives total cash in hand\\n            // buy only if it works out better ( increases cash in hand)\\n            cash = Math.max(cash, p[i-2]-prices[i]);\\n        }\\n        \\n        return p[n-1];        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825458,
                "title": "true-dp-solution-python-o-n-5-lines-with-explanation-full-thought-process",
                "content": "### I\\'m going go over my complete thought process for this problem. \\n\\n# **Problem Requirements:**\\n1. If you sell on a particular day, you must **cooldown and can\\'t buy for the next day.**\\n2. You can\\'t sell the stock if you haven\\'t bought the stock yet. \\n3. You can only keep one stock.\\n\\n# The Drawing\\n\\nWe have **two cases**: buying or sell a stock at a particular day. So, I decided to draw a descision tree for the problem. \\n\\n![image](https://assets.leetcode.com/users/images/3b0c8143-29c6-408e-aa0d-5dd956cee69c_1668723326.442367.png)\\n\\n# Drawing Analysis\\n\\nIf we decide to buy, we can\\'t buy again until we sell because of **requirement #3**. The opposite is true as well (if we sell we can\\'t sell until we buy again). I decided to that we have **two states**: a buying and selling state. \\n\\nIf you think about it, we also have to option to wait as well. For example, you aren\\'t forced to sell the day after you buy a stock. Smart people would wait for the prices to increase before selling so they can make a profit. The opposite is also true for buying as you can wait to buy when it\\'s cheaper.\\n\\n1. For the buy state, you can either buy now and look to sell or buy later (wait). \\n2. For the sell state, you can either sell now and look to buy after you skip one day (requirement #1) before buying again or sell later (wait).\\n\\n# Brute Force Solution\\n##### I decided to have a nested DFS function that takes 3 parameters: The current index, the current state (buy or sell), and the total profit.\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:    \\n        res = 0\\n        \\n        def dfs(i, state, profit):\\n            nonlocal res\\n            if i >= len(prices):\\n\\t\\t\\t\\t# Keep track of the maximum profit\\n                res = max(profit, res)\\n                return\\n            \\n\\t\\t\\t# STATE: We don\\'t have a stock and need to buy one\\n            if state == \\'b\\':\\n\\t\\t\\t\\t# DECISION #1 \\n\\t\\t\\t\\t# Set state to \\'s\\' because we bought a stock and are looking to sell\\n\\t\\t\\t\\t# Our profit decreases because we spent money to buy the stock\\n                dfs(i + 1, \\'s\\', profit - prices[i])\\n\\t\\t\\t\\t# DECISION #2\\n\\t\\t\\t\\t# This spot might be too expensive\\n\\t\\t\\t\\t# Let\\'s buy a stock the next day instead\\n                dfs(i + 1, \\'b\\', profit)\\n            else: # STATE: We already bought a stock and are looking to sell\\n\\t\\t\\t\\t# DECISION #3\\n\\t\\t\\t\\t# Set state to \\'b\\'. We sold our stock and we are looking to buy again\\n\\t\\t\\t\\t# Our profit increases \\n\\t\\t\\t\\t# Remember Requirement #1!!! \\n\\t\\t\\t\\t# We have to skip the next day so we set i + 2 instead of i + 1\\n                dfs(i + 2, \\'b\\', profit + prices[i])\\n\\t\\t\\t\\t# DECISION #4\\n\\t\\t\\t\\t# The stock might be too cheap today, let\\'s wait to sell the next day\\n\\t\\t\\t\\t# Note we remain on the sell state\\n                dfs(i + 1, \\'s\\', profit)\\n\\t\\t# Initially we HAVE TO BUY, we don\\'t have a stock yet\\n        dfs(0, \\'b\\', 0)\\n        return res\\n```\\n\\n##### Now we have our Brute force solution from our drawing analysis. \\n### Time: O(2^n)\\n\\n##### It\\'s working for a brute force solution but how can we make this into a dynamic programming solution. First, I have to find a way to BUILD UP the solution using the brute force method. \\n\\n\\n# Brute Force Solution (Building Up Answer)\\nWe will always be returning the **maximum profit**. \\n\\n### Base Case: \\n1. The maximum profit would be zero if there are no stocks to buy/sell.\\n### Recursive Case: \\n1. We will reuse the states from the previous solution. The only difference is how we can **return the solution** to the parent. \\n2. Remember we want **TO RETURN THE MAXIMUM RESULT**.\\n3. Depending on the state we are currently in, we want to know what is the maximum profit we can make for their 2 descisions.\\n\\n### What is the subproblem? \\n#### What is the maximum profit we can make from some day i if we are looking to sell?\\n#### What is the maximum profit we can make from some day i if we are looking to buy?\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:    \\n\\t\\t# The two recursive calls in the past are now combined.\\n        def dfs(i, state):\\n            if i >= len(prices):\\n                return 0\\n            \\n            if state == \\'b\\':\\n\\t\\t\\t\\t# Recursive Call #1\\n\\t\\t\\t\\t# Profit loss for buying now + max profit we can make by looking to sell next day\\n\\t\\t\\t\\t# Recursive Call #2\\n\\t\\t\\t\\t# Profit for waiting to buy later\\n\\t\\t\\t\\t# Which choice would give us the most profit?\\n                return max(dfs(i + 1, \\'s\\') - prices[i], dfs(i + 1, \\'b\\'))\\n            else:\\n\\t\\t\\t\\t# Recursive Call #1\\n\\t\\t\\t\\t# Profit gain for selling now + max profit we can make by looking to buy after skipping a day\\n\\t\\t\\t\\t# Recursive Call #2\\n\\t\\t\\t\\t# Profit gain for waiting till the next day to sell\\n\\t\\t\\t\\t# Which choice gives us the most profit?\\n                return max(prices[i] + dfs(i + 2, \\'b\\'), dfs(i + 1, \\'s\\'))\\n        return dfs(0, \\'b\\')\\n```\\n\\n### Time O(2^n)\\n#### We have the same efficiency but from this, we can turn the solution into a DP one.\\n\\n# DP Solution\\n### What if we start with Bottom-up DP and build our solution upwards from the last day to the first day?\\n\\n### Ex: prices = [1, 2, 3, 0, 2]\\n##### Question: What is the maximum profit from the last day? Index = 4?\\nRemember, we could have two states. We could either be looking to buy a stock at day 4 or looking to sell a stock at day 4. **We need to account for both cases. **\\n\\nFor each state, we need to consider both choices and cache the maximum in a dp array.\\n### Buying state \\n1. Buy now and look to sell later = **-2 profit**\\n\\ta. 1st recursive call: dfs(4 + 1, \\'s\\') - prices[4] = 0 (base case - OOB) - 2 (price) = **-2**\\n2. Buy later = **0 profit** \\n\\ta. 2nd recursive call: dfs(4 + 1, \\'b\\') = 0 (base Case OOB) = **0**\\n\\t\\n### Selling state\\n1. Sell now and look to buy after skipping a day = **2 profit**\\n\\ta. 1st Recursive Call: dfs(4 + 2, \\'b\\') + prices[4] = 0 (base case - OOB) + 2 = **2**\\n2. Wait to sell later = **0 profit**\\n\\ta. 2nd Recursive Call: dfs(4 + 1, \\'s\\') = 0 (base call - OOB) = **0** \\n\\t\\n### Result\\n##### Max profit buying at day 4: 0\\n##### Max profit selling at day 4: 2\\n\\n### Here\\'s a picture of the results after we calculate the last day\\n\\n![image](https://assets.leetcode.com/users/images/b2ff8811-258c-49b0-a5ed-bb9be96d6b56_1668726730.2580383.png)\\n\\n\\n\\n##### Question #2: What is the maximum profit from the 2nd to last day? Index = 3?\\n\\n### Buying state \\n1. Buy now and look to sell later\\n\\ta. 1st Recursive Call: dfs(3 + 1, \\'s\\') - prices[3]\\n\\tb. **HEY! DIDN\\'T WE SOLVE WHAT THE MAXIMUM IT WAS TO LOOK TO SELL AT DAY 4????**\\n\\tc. = 2 (solved day 4, sell already) - 0 = **0**\\n2. Buy later = **0 profit** \\n\\ta. 2nd recursive call: dfs(3 + 1, \\'b\\') = 0 (base Case OOB) = **0**\\n\\tb. **HEY! WE SOLVED THE MAXIMUM FOR LOOKING TO BUY AT DAY 4!!!**\\n\\t\\n### Selling state (Same thing. We already solved the recursive call)\\n\\n![image](https://assets.leetcode.com/users/images/e7782575-8e22-4c4e-b2e1-54abe7721510_1668727191.982658.png)\\n\\n\\n### Now we discovered how to calculate the dp at index i.\\n#### We need a 2d array where row 0 keeps track of maximum in buy state and row 1 tracks maximum in sell state (like the picture)\\n\\n### dp[0][i] = max(dp[1][i + 1] - prices[i], dp[0][i + 1])\\n### dp[1][i] = max(dp[0][i + 2] + prices[i], dp[1][i + 1])\\n\\n# DP Solution Code\\n```\\n    def maxProfit(self, prices: List[int]) -> int:    \\n        dp = [[0 for i in range(len(prices) + 2)] for x in range(2)]\\n        \\n\\t\\t# Bottom Up so start from last day to first\\n        for i in range(len(prices) - 1, -1, -1):\\n\\t\\t\\t# Use our DP Formulas !!!!!\\n            dp[0][i] = max(-prices[i] + dp[1][i + 1], dp[0][i + 1])\\n            dp[1][i] = max(prices[i] + dp[0][i + 2], dp[1][i + 1])\\n\\t\\t# We want to return the max for BUYING at Day 0\\n\\t\\t# We can\\'t sell if we haven\\'t bought a stock yet. (Requirement #2)\\n        return dp[0][0]\\n```\\n\\n### Time: O(n)\\n### Space: O(2n) --> O(n)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    def maxProfit(self, prices: List[int]) -> int:    \\n        res = 0\\n        \\n        def dfs(i, state, profit):\\n            nonlocal res\\n            if i >= len(prices):\\n\\t\\t\\t\\t# Keep track of the maximum profit\\n                res = max(profit, res)\\n                return\\n            \\n\\t\\t\\t# STATE: We don\\'t have a stock and need to buy one\\n            if state == \\'b\\':\\n\\t\\t\\t\\t# DECISION #1 \\n\\t\\t\\t\\t# Set state to \\'s\\' because we bought a stock and are looking to sell\\n\\t\\t\\t\\t# Our profit decreases because we spent money to buy the stock\\n                dfs(i + 1, \\'s\\', profit - prices[i])\\n\\t\\t\\t\\t# DECISION #2\\n\\t\\t\\t\\t# This spot might be too expensive\\n\\t\\t\\t\\t# Let\\'s buy a stock the next day instead\\n                dfs(i + 1, \\'b\\', profit)\\n            else: # STATE: We already bought a stock and are looking to sell\\n\\t\\t\\t\\t# DECISION #3\\n\\t\\t\\t\\t# Set state to \\'b\\'. We sold our stock and we are looking to buy again\\n\\t\\t\\t\\t# Our profit increases \\n\\t\\t\\t\\t# Remember Requirement #1!!! \\n\\t\\t\\t\\t# We have to skip the next day so we set i + 2 instead of i + 1\\n                dfs(i + 2, \\'b\\', profit + prices[i])\\n\\t\\t\\t\\t# DECISION #4\\n\\t\\t\\t\\t# The stock might be too cheap today, let\\'s wait to sell the next day\\n\\t\\t\\t\\t# Note we remain on the sell state\\n                dfs(i + 1, \\'s\\', profit)\\n\\t\\t# Initially we HAVE TO BUY, we don\\'t have a stock yet\\n        dfs(0, \\'b\\', 0)\\n        return res\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:    \\n\\t\\t# The two recursive calls in the past are now combined.\\n        def dfs(i, state):\\n            if i >= len(prices):\\n                return 0\\n            \\n            if state == \\'b\\':\\n\\t\\t\\t\\t# Recursive Call #1\\n\\t\\t\\t\\t# Profit loss for buying now + max profit we can make by looking to sell next day\\n\\t\\t\\t\\t# Recursive Call #2\\n\\t\\t\\t\\t# Profit for waiting to buy later\\n\\t\\t\\t\\t# Which choice would give us the most profit?\\n                return max(dfs(i + 1, \\'s\\') - prices[i], dfs(i + 1, \\'b\\'))\\n            else:\\n\\t\\t\\t\\t# Recursive Call #1\\n\\t\\t\\t\\t# Profit gain for selling now + max profit we can make by looking to buy after skipping a day\\n\\t\\t\\t\\t# Recursive Call #2\\n\\t\\t\\t\\t# Profit gain for waiting till the next day to sell\\n\\t\\t\\t\\t# Which choice gives us the most profit?\\n                return max(prices[i] + dfs(i + 2, \\'b\\'), dfs(i + 1, \\'s\\'))\\n        return dfs(0, \\'b\\')\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:    \\n        dp = [[0 for i in range(len(prices) + 2)] for x in range(2)]\\n        \\n\\t\\t# Bottom Up so start from last day to first\\n        for i in range(len(prices) - 1, -1, -1):\\n\\t\\t\\t# Use our DP Formulas !!!!!\\n            dp[0][i] = max(-prices[i] + dp[1][i + 1], dp[0][i + 1])\\n            dp[1][i] = max(prices[i] + dp[0][i + 2], dp[1][i + 1])\\n\\t\\t# We want to return the max for BUYING at Day 0\\n\\t\\t# We can\\'t sell if we haven\\'t bought a stock yet. (Requirement #2)\\n        return dp[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 76046,
                "title": "two-states-dp-c-code",
                "content": "f(i, 0) is the max profit with one stock in hand. f(i, 1) is the max profit with no stock in hand.\\n\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            vector<vector<int>> f;\\n            int n = prices.size();\\n            if (n <= 1) {\\n                return 0;\\n            } else if (n == 2) {\\n                return max(0, prices[1] - prices[0]);\\n            }\\n        \\n            f = vector<vector<int>>(n, vector<int>(2));\\n            \\n            f[0][0] = -prices[0];\\n            f[0][1] = 0;\\n            f[1][0] = max(-prices[0], -prices[1]);\\n            f[1][1] = max(0, prices[1] - prices[0]);\\n            \\n            for (int i = 2; i < n; i++) {\\n                f[i][0] = max(f[i - 1][0], f[i - 2][1] - prices[i]);\\n                f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i]);\\n            }\\n            \\n            return f[n - 1][1];\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            vector<vector<int>> f;\\n            int n = prices.size();\\n            if (n <= 1) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76048,
                "title": "c-o-n-time-o-1-space-dp-solution-with-comments",
                "content": "    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            vector<int> full(2, INT_MIN), empty(2, 0), sell(2, 0);\\n            for (int i = 0; i < prices.size(); i++) {\\n                full[i % 2] = max(full[1 - i % 2], empty[1 - i % 2] - prices[i]);  \\n                    // had bought before OR buy today (pay prices[i])\\n                sell[i % 2] = full[1 - i % 2] + prices[i];  \\n                    // sell today (get prices[i])\\n                empty[i % 2] = max(empty[1 - i % 2], sell[1 - i % 2]);  \\n                    // had sold before yesterday OR sold yesterday\\n            }\\n            return max(empty[1 - prices.size() % 2], sell[1 - prices.size() % 2]);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            vector<int> full(2, INT_MIN), empty(2, 0), sell(2, 0);\\n            for (int i = 0; i < prices.size(); i++) {\\n                full[i % 2] = max(full[1 - i % 2], empty[1 - i % 2] - prices[i]);  \\n                    // had bought before OR buy today (pay prices[i])\\n                sell[i % 2] = full[1 - i % 2] + prices[i];  \\n                    // sell today (get prices[i])\\n                empty[i % 2] = max(empty[1 - i % 2], sell[1 - i % 2]);  \\n                    // had sold before yesterday OR sold yesterday\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2940561,
                "title": "python-3-4-lines-w-example-t-m-94-98",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:         # Example: prices = [1,2,3,0,2]\\n                                                           #\\n        nostock, stock, cool = 0,-prices[0],0              #   p   nostock   stock    cool \\n                                                           #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n        for p in prices[1:]:                               #   1      0       -1        0\\n                                                           #   2      0       -1        1\\n            nostock, stock, cool = (max(nostock,cool),     #   3      1       -1        2\\n                                    max(stock,nostock-p),  #   0      2        1       -1\\n                                    stock+p)               #   2      2        1        3 <\\u2013\\u2013\\u2013 return\\n \\n        return max(nostock, stock, cool)                                             \\n```\\n[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/submissions/863991664/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:         # Example: prices = [1,2,3,0,2]\\n                                                           #\\n        nostock, stock, cool = 0,-prices[0],0              #   p   nostock   stock    cool \\n                                                           #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n        for p in prices[1:]:                               #   1      0       -1        0\\n                                                           #   2      0       -1        1\\n            nostock, stock, cool = (max(nostock,cool),     #   3      1       -1        2\\n                                    max(stock,nostock-p),  #   0      2        1       -1\\n                                    stock+p)               #   2      2        1        3 <\\u2013\\u2013\\u2013 return\\n \\n        return max(nostock, stock, cool)                                             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442705,
                "title": "java-naive-dp-to-o-1-state-machine",
                "content": "# Naive DP\\n1. Everyday, we either buy, sell or do nothing.\\n2. Because after sell we have to wait for at least 1 day to buy, so every buy should come from sell 2 days before\\n```java\\nclass Solution {\\n   public int maxProfit(int[] p) {\\n      int n = p.length;\\n      if (n < 2) return 0;\\n\\n      int[] hold = new int[n + 1]; // after buy\\n      int[] sell = new int[n + 1]; // after sell\\n      hold[1] = -p[0];\\n      for (int i = 2; i <= n; i++) {\\n         hold[i] = Math.max(hold[i - 1], sell[i - 2] - p[i - 1]);\\n         sell[i] = Math.max(sell[i - 1], hold[i - 1] + p[i - 1]);\\n      }\\n      return sell[n];\\n   }\\n}\\n```\\n# Optimize space to O(1)\\nYou might realize this is the state machine solution everybody has been talking about.\\n```java\\nclass Solution {\\n   public int maxProfit(int[] p) {\\n      int n = p.length;\\n      if (n < 2) return 0;\\n      int h = -p[0], s = 0, c = 0; // state after buy(h for hold), sell, cool down\\n\\n      for (int x : p) {\\n         h = Math.max(h, c - x);\\n         c = s;\\n         s = Math.max(s, h + x);\\n      }\\n\\n      return s;\\n   }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n   public int maxProfit(int[] p) {\\n      int n = p.length;\\n      if (n < 2) return 0;\\n\\n      int[] hold = new int[n + 1]; // after buy\\n      int[] sell = new int[n + 1]; // after sell\\n      hold[1] = -p[0];\\n      for (int i = 2; i <= n; i++) {\\n         hold[i] = Math.max(hold[i - 1], sell[i - 2] - p[i - 1]);\\n         sell[i] = Math.max(sell[i - 1], hold[i - 1] + p[i - 1]);\\n      }\\n      return sell[n];\\n   }\\n}\\n```\n```java\\nclass Solution {\\n   public int maxProfit(int[] p) {\\n      int n = p.length;\\n      if (n < 2) return 0;\\n      int h = -p[0], s = 0, c = 0; // state after buy(h for hold), sell, cool down\\n\\n      for (int x : p) {\\n         h = Math.max(h, c - x);\\n         c = s;\\n         s = Math.max(s, h + x);\\n      }\\n\\n      return s;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829755,
                "title": "java-1ms-no-space-explained-with-dry-run",
                "content": "If you like the explanation, do **UpVote** :) \\n\\n### \\tApproach\\n\\tAs per the question, we will always either - buy stock, or sell stock, or stay in cooldown (no stock in hand) for atleast one day.\\n    \\n    So, each day We will have 3 states:\\n        a. noStock  (or day when you have Cooldown)\\n        b. in-Hand  (or day when you buy)\\n        c. sold     (or day when you sell)\\n    \\n    For each of these states, we will calculate maximum profit. \\n\\n    Try to understand below: \\n    a. noStock = maximum of (previous noStock, previous  sold) \\n    b. inHand  = maximum of (previous inHand, previous noStock - price on current day)\\n    c. sold  =  previous inHand + price on current day\\n    \\n    We will use above 3 formulas to calculate maximum profit in each state, everyday.\\n\\n### Dry-Run:\\n\\t\\t\\ti =      0      1       2       3       4 \\n    \\n\\t  prices =      [1,     2,      3,      0,      2]           // value of a stock on each day starting at index 0\\n            \\n\\t  noStock =     0       0       1       2       2 \\n\\t  inHand  =    -1      -1      -1       1       1\\n\\t  sold    =     0       1       2      -1       3\\n  \\n\\t  => max Profit = maximum of (2, 3)     // we compare only 2 & 3 and not 2,1,3. Because there is no point to consider profit value from inHand state. \\n \\n###  Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(1)   // because instead of creating 3 arrays for noStock, inHand & sold, we just used 3 variables.\\n\\n\\n### Code:\\n\\n\\tclass Solution {\\n\\t\\tpublic int maxProfit(int[] prices) {\\n\\t\\t\\tint n=prices.length;\\n\\t\\t\\tif(n < 2) return 0;        \\n\\n\\t\\t\\tint noStock = 0, inHand = 0 - prices[0], sold = 0;                               // initialize these 3 variables\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tint temp_noStock = Math.max(noStock, sold);                                //  Check code explanation under \"Approach\"  \\n\\t\\t\\t\\tint temp_inHand  = Math.max(inHand, noStock - prices[i]);\\n\\t\\t\\t\\tint temp_sold  =  inHand + prices[i];\\n\\n\\t\\t\\t\\tnoStock = temp_noStock; \\n\\t\\t\\t\\tinHand = temp_inHand; \\n\\t\\t\\t\\tsold  = temp_sold;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn Math.max(noStock, sold);                      \\n\\t\\t}\\n\\n\\t}\\n\\t\\nIf you like the explanation, do **UpVote** :) \\nIf you need more explanation or have any suggestions, let me know.\\t",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int maxProfit(int[] prices) {\\n\\t\\t\\tint n=prices.length;\\n\\t\\t\\tif(n < 2) return 0;        \\n\\n\\t\\t\\tint noStock = 0, inHand = 0 - prices[0], sold = 0;                               // initialize these 3 variables\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tint temp_noStock = Math.max(noStock, sold);                                //  Check code explanation under \"Approach\"  \\n\\t\\t\\t\\tint temp_inHand  = Math.max(inHand, noStock - prices[i]);\\n\\t\\t\\t\\tint temp_sold  =  inHand + prices[i];\\n\\n\\t\\t\\t\\tnoStock = temp_noStock; \\n\\t\\t\\t\\tinHand = temp_inHand; \\n\\t\\t\\t\\tsold  = temp_sold;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1521962,
                "title": "python-explained-one-pass-o-1-space-1-2-lines-faster-than-99-4",
                "content": "Please feel free to ask questions or give suggestions. Please **upvote** if you like the solution.\\n**Idea**:\\n* At the end of each day, there are 3 scenarios:\\n\\t* We do not own a stock and are not in cooldown\\n\\t* We own a stock\\n\\t* We are in cooldown\\n* The ways we could end up at each scenario respectively are:\\n\\t* We did not own a stock and were not in cooldown, or were in cooldown after selling a stock\\n\\t* We owned a stock, or we didn\\'t own one, weren\\'t in cooldown, and bought one\\n\\t* We owned a stock and just sold it\\n* For each scenario, we keep the max profit we could have made while ending up that way. We iterate through the prices list keeping track of these 3 for the last day seen so far.\\n\\n**Recommended Solution**: One-pass, O(1) space, and readable\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tdef next_day(a, price):\\n\\t\\t\"\"\" Returns max profits at the end of next day for the 3 scenarios in order\\n\\t\\ta is (max_when_not_own_not_cool, max_when_own, max_when_cooldown) for previous day\\n\\t\\tprice is the price on this day\\n\\t\\t\"\"\"\\n\\n\\t\\t# (not owned = max(not owned and not on cooldown, on cooldown), owned = max(owned, just bought), cooldown = owned and just sold)\\n\\t\\treturn (max(a[0], a[2]), max(a[1], a[0]-price), a[1]+price)\\n\\n\\t# Start with (0, -prices[0], 0) and iterate through prices keeping track of max profit accumulated in each scenario, then return max of these\\n\\treturn max(reduce(next_day, prices, (0, -prices[0], 0)))\\n```\\n**One-line**: Faster than 99.4%, and constant space, not recommended because not very readable\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\t# Start with (0, -prices[0], 0) and iterate through prices keeping track of max profit accumulated in each scenario, then return max of these\\n\\treturn max(reduce(lambda a, b: (max(a[0], a[2]), max(a[1], a[0]-b), a[1]+b), prices, (0, -prices[0], 0)))\\n```\\nIf you don\\'t know what reduce does, do check the docs: https://docs.python.org/3/library/functools.html.\\n**Equivalent unoptimized code**:\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tnot_own_not_cool, own, cool = 0, -prices[0], 0\\n\\n\\t# Move forward day by day\\n\\tfor price in prices:\\n\\t\\t# alternatively, appropriate call to function next_day\\n\\t\\tnot_own_not_cool, own, cool = max(not_own_not_cool, cool), max(own, not_own_not_cool-price), own+price\\n\\n\\treturn max(not_own_not_cool, own, cool)\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tdef next_day(a, price):\\n\\t\\t\"\"\" Returns max profits at the end of next day for the 3 scenarios in order\\n\\t\\ta is (max_when_not_own_not_cool, max_when_own, max_when_cooldown) for previous day\\n\\t\\tprice is the price on this day\\n\\t\\t\"\"\"\\n\\n\\t\\t# (not owned = max(not owned and not on cooldown, on cooldown), owned = max(owned, just bought), cooldown = owned and just sold)\\n\\t\\treturn (max(a[0], a[2]), max(a[1], a[0]-price), a[1]+price)\\n\\n\\t# Start with (0, -prices[0], 0) and iterate through prices keeping track of max profit accumulated in each scenario, then return max of these\\n\\treturn max(reduce(next_day, prices, (0, -prices[0], 0)))\\n```\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\t# Start with (0, -prices[0], 0) and iterate through prices keeping track of max profit accumulated in each scenario, then return max of these\\n\\treturn max(reduce(lambda a, b: (max(a[0], a[2]), max(a[1], a[0]-b), a[1]+b), prices, (0, -prices[0], 0)))\\n```\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tnot_own_not_cool, own, cool = 0, -prices[0], 0\\n\\n\\t# Move forward day by day\\n\\tfor price in prices:\\n\\t\\t# alternatively, appropriate call to function next_day\\n\\t\\tnot_own_not_cool, own, cool = max(not_own_not_cool, cool), max(own, not_own_not_cool-price), own+price\\n\\n\\treturn max(not_own_not_cool, own, cool)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1167128,
                "title": "c-solution-to-all-the-stock-problems-using-dynamic-programming",
                "content": "## Related Questions\\n\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n4. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n5. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n6. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n\\n#### Best Time to Buy and Sell Stock\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy[prices.size()], sell[prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1],-prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock II\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock with Transaction Fee\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1] - fee);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock with Cooldown ( Generalised for k cooldown period )\\nO(N) Time, O(N) Space\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int cooldown = 1) {\\n        int buy[prices.size()];\\n        int sell[prices.size()];\\n        memset(buy, 0, sizeof(buy));\\n        memset(sell, 0, sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1], (i-cooldown-1 >= 0 ? sell[i-cooldown-1] : 0) - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(sell[prices.size()-1], buy[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock III ( Generalised for atmost k transactions )\\nO(Nk) Time, O(Nk) Space ( Can be made O(k) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int transactions = 2) {\\n        if(transactions == 0) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock IV\\nO(Nk) Time, O(Nk) Space ( Can be made O(k) Space by tracking only the previous buy sell values )\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int transactions, vector<int>& prices) {\\n        if(transactions == 0 || prices.size() <= 1) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy[prices.size()], sell[prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1],-prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1] - fee);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int cooldown = 1) {\\n        int buy[prices.size()];\\n        int sell[prices.size()];\\n        memset(buy, 0, sizeof(buy));\\n        memset(sell, 0, sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1], (i-cooldown-1 >= 0 ? sell[i-cooldown-1] : 0) - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(sell[prices.size()-1], buy[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int transactions = 2) {\\n        if(transactions == 0) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int transactions, vector<int>& prices) {\\n        if(transactions == 0 || prices.size() <= 1) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978264,
                "title": "java-thinking-process-from-o-2-n-to-o-n",
                "content": "You must be very confused how the most votes answers came up with the method with `O(n)` time complexity. Those guys must be genius! \\nBut I guess the first answer occured in their mind was probably straighforward and rough. \\n\\nFollow this answer, you will learn the thinking process step by step from the straighforward method to the intelligent one.\\n\\n\\nFirst, probably most of you can come up with an `O(2^n)` method:\\n```java\\n// O(2^n)\\npublic int maxProfitRange(int[] prices, int start, int end) {\\n\\t\\t// start: start day, end: end day\\n        if(start >= end) return 0;\\n        int res = 0;\\n\\t\\t// Profit(start, end) = Max(Profit(buy on day start, end), Profit(not buy on day start, end))\\n        res = Math.max(res, maxProfitRange(prices, start+1, end));\\n        for(int i = start+1; i<end;i++){\\n            res = Math.max(res, prices[i]-prices[start] + maxProfitRange(prices, i+2, end));\\n        }\\n        return res;\\n    }\\n\\tpublic int maxProfit(int[] prices) {\\n\\t\\treturn maxProfitRange(prices, 0, prices.length);\\n\\t}\\n```\\n\\nLet me explain a little bit here. On each day, you have many choices, buy or not buy, sell or not sell. We should split this problem into two subproblems: 1. buy on that day. 2. not buy on that day. That is `Profit(start, end) = Max(Profit(buy on day start, end), Profit(not buy on day start, end))`\\n\\nIt is easy to know that `Profit(not buy on day start, end)) = Profit(start+1, end) `.\\n\\nFor `Profit(buy on day start, end)`, the problem becomes to decide which day to sell will make the profit max. Let\\'s iterate every day after the buy day and check whether sell on this day will be best. That is `Profit(buy on day start, end) = for each day i>start, find the max(prices[i]-prices[start] + Profit(start+2, end))` (start+2 since we need cooldown 1 day)\\n\\nThe time complexity of this answer is `O(2^n)`. Because we calculate the same value many times. Let\\'s use Dynamic Programming to reduce the time complexity to `O(n^2)`\\n\\n```java\\n// O(n^2)\\npublic int maxProfit(int[] prices) {\\n        int length = prices.length;\\n        int[] dp = new int[prices.length+2];\\n        for(int start = length-1; start>=0;start--){\\n\\t\\t\\t// Profit(start, end) = Max(Profit(buy on day start, end), Profit(not buy on day start, end))\\n            dp[start] = dp[start+1];\\n\\t\\t\\t// redundant\\n            for(int sell=start+1;sell<length;sell++){\\n                dp[start] = Math.max(dp[start], prices[sell]-prices[start]+dp[sell+2]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\\n\\nThe idea is that we save the calculated value into an dp array, so next time we don\\'t need to calculate it again but only loop up the array.\\n\\nBut there are still some redundant calculations. For example, for every start day, we need to calculate  `Math.max(dp[start], prices[sell]-prices[start]+dp[sell+2]);` Why not just save the max `prices[sell] + dp[sell+2])`, and update this `max_sell` every time? If we do this, the code becomes:\\n\\n```java\\n// O(n)\\npublic int maxProfit(int[] prices) {\\n        int length = prices.length;\\n        int[] dp = new int[prices.length+2];\\n        int max_sell = 0;\\n        for(int start = length-1; start>=0;start--){\\n            dp[start] = Math.max(dp[start+1], max_sell - prices[start]);\\n            max_sell = Math.max(max_sell, prices[start]+dp[start+2]);\\n        }\\n        return dp[0];\\n    }\\n```\\n\\nThe time complexity is reduced to `O(n)`, but the space complexity is also `O(n)`. Can we reduce the space complexity to `O(1)`?\\nYes, just use another variable `res_prev` to store the dp[start+2] and update it every time.\\n\\n```java\\npublic int maxProfit(int[] prices) {\\n        int max_sell = 0, res = 0, res_prev = 0;\\n        for(int start = prices.length-1; start>=0;start--){\\n            max_sell = Math.max(max_sell, prices[start]+res_prev);\\n            res_prev = res;\\n            res = Math.max(res, max_sell - prices[start]);\\n        }\\n        return res;\\n    }\\n```\\n\\nDone!\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\n// O(2^n)\\npublic int maxProfitRange(int[] prices, int start, int end) {\\n\\t\\t// start: start day, end: end day\\n        if(start >= end) return 0;\\n        int res = 0;\\n\\t\\t// Profit(start, end) = Max(Profit(buy on day start, end), Profit(not buy on day start, end))\\n        res = Math.max(res, maxProfitRange(prices, start+1, end));\\n        for(int i = start+1; i<end;i++){\\n            res = Math.max(res, prices[i]-prices[start] + maxProfitRange(prices, i+2, end));\\n        }\\n        return res;\\n    }\\n\\tpublic int maxProfit(int[] prices) {\\n\\t\\treturn maxProfitRange(prices, 0, prices.length);\\n\\t}\\n```\n```java\\n// O(n^2)\\npublic int maxProfit(int[] prices) {\\n        int length = prices.length;\\n        int[] dp = new int[prices.length+2];\\n        for(int start = length-1; start>=0;start--){\\n\\t\\t\\t// Profit(start, end) = Max(Profit(buy on day start, end), Profit(not buy on day start, end))\\n            dp[start] = dp[start+1];\\n\\t\\t\\t// redundant\\n            for(int sell=start+1;sell<length;sell++){\\n                dp[start] = Math.max(dp[start], prices[sell]-prices[start]+dp[sell+2]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\n```java\\n// O(n)\\npublic int maxProfit(int[] prices) {\\n        int length = prices.length;\\n        int[] dp = new int[prices.length+2];\\n        int max_sell = 0;\\n        for(int start = length-1; start>=0;start--){\\n            dp[start] = Math.max(dp[start+1], max_sell - prices[start]);\\n            max_sell = Math.max(max_sell, prices[start]+dp[start+2]);\\n        }\\n        return dp[0];\\n    }\\n```\n```java\\npublic int maxProfit(int[] prices) {\\n        int max_sell = 0, res = 0, res_prev = 0;\\n        for(int start = prices.length-1; start>=0;start--){\\n            max_sell = Math.max(max_sell, prices[start]+res_prev);\\n            res_prev = res;\\n            res = Math.max(res, max_sell - prices[start]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906693,
                "title": "dp-easy-understand-and-less-code-beat-88",
                "content": "* the max profit of hold is either from previous bought stock or the stock that bought today\\n* the max profit of unhold is either from previous sold stock or the stock that sold today\\n* the max profit of cooldown is either from previous cooldown or unhold\\n\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        size = len(prices)\\n        if size < 2: return 0\\n        hold, unhold, cooldown = float(\\'-inf\\'),0,0\\n        for price in prices:\\n            hold=max(hold,cooldown-price)\\n            cooldown = max(cooldown, unhold)\\n            unhold=max(unhold,hold+price)\\n        return unhold\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        size = len(prices)\\n        if size < 2: return 0\\n        hold, unhold, cooldown = float(\\'-inf\\'),0,0\\n        for price in prices:\\n            hold=max(hold,cooldown-price)\\n            cooldown = max(cooldown, unhold)\\n            unhold=max(unhold,hold+price)\\n        return unhold\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762060,
                "title": "5-line-o-n-time-o-1-space-c-solution",
                "content": "```\\nint maxProfit(vector<int>& prices) {\\n\\tconst int n = prices.size();\\n\\tint empty = 0, hold = INT_MIN, cooldown = 0;\\n\\tfor (int i = 0; i < n; ++i)\\n\\t\\ttie(empty, hold, cooldown) = make_tuple(max(empty, cooldown), max(hold, empty - prices[i]), hold + prices[i]);\\n\\treturn max(empty, cooldown);\\n}\\n```\\n\\nThe idea is just state machine.\\nTo become `empty` today, you either were `empty` yesterday, or you were `cooldown` and turned `empty` today.\\nTo become `hold` today, you either were `hold` yesterday, or you buy today.\\nTo become `cooldown` today, you have to sell today.\\n",
                "solutionTags": [],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n\\tconst int n = prices.size();\\n\\tint empty = 0, hold = INT_MIN, cooldown = 0;\\n\\tfor (int i = 0; i < n; ++i)\\n\\t\\ttie(empty, hold, cooldown) = make_tuple(max(empty, cooldown), max(hold, empty - prices[i]), hold + prices[i]);\\n\\treturn max(empty, cooldown);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 143564,
                "title": "python-4-lines-dp-solution-w-explanation-40-ms-beats-100",
                "content": "* Firstly on any given day we have 2 conditions:\\n\\t* Having stock \\n\\t* Or not\\n* And we also have 2 more conditions:\\n\\t* Having cooldown\\n\\t* Or not\\n* In total we assume 2 * 2 = 4 possible conditions on any given day:\\n\\t* 0 stock(cool), 0 stock(no-cool), 1 stock(cool), 1 stock(no-cool)\\n* However, we can\\'t have 1 stock(cool) condition, both cooldown(selling) and still having stock.\\n* Let\\'s consider DP for 3 conditions.\\n\\t* For 0 stock(cool), we should sell previous day stock = > 1 stock(no-cool)\\n\\t* For 0 stock(no-cool), we shouldn\\'t sell anything and have no stock = > 0 stock(cool) or 0 stock(no-cool)\\n\\t* For 1 stock(no-cool), we can continue with previous day having 1 stock or buying from 0 stock(no-cool) = > 0 stock(no-cool) or 1 stock(no-cool)\\n* Furthermore, we must initialize start conditions prior to DP like setting 1 stock(no-cool) to minus inifinity for not profiting from fake stock and others to zero.\\n*  We should return last day DP conditions without any stock holding for the result.\\n```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        # dp1, dp2, dp3 = 0 stock(cool), 0 stock(no-cool), 1 stock(no-cool)\\n        dp1, dp2, dp3 = 0, 0, -float(\"inf\")\\n        for p in prices:\\n            dp1, dp2, dp3 = dp3 + p, max(dp1, dp2), max(dp2 - p, dp3)\\n        return max(dp1, dp2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        # dp1, dp2, dp3 = 0 stock(cool), 0 stock(no-cool), 1 stock(no-cool)\\n        dp1, dp2, dp3 = 0, 0, -float(\"inf\")\\n        for p in prices:\\n            dp1, dp2, dp3 = dp3 + p, max(dp1, dp2), max(dp2 - p, dp3)\\n        return max(dp1, dp2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75925,
                "title": "java-2-different-dp-easy-understanding-solutions",
                "content": "1. dp[i][0/1/2] the max value gained on Day-i on which you must do sell/buy/cooldown;\\n```\\npublic int maxProfit(int[] prices){\\n        int len=prices.length;\\n        if(len==0)return 0;\\n        int[][] dp=new int[prices.length][3];\\n        dp[0][0]=dp[0][2]=0;\\n        dp[0][1]=-prices[0];\\n        int min_buy=dp[0][1];\\n        for(int i=1;i<len;i++){\\n            dp[i][0]=min_buy+prices[i];// sell\\n            dp[i][1]=dp[i-1][2]-prices[i];// buy\\n            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][0]);\\n            min_buy=Math.max(min_buy, dp[i][1]);\\n        }\\n        return Math.max(dp[len-1][0],dp[len-1][2]);\\n    }\\n```\\ndo the space optimization:\\n```\\npublic int maxProfit(int[] prices){\\n        int len=prices.length;\\n        if(len==0)return 0;\\n        int sell=0, buy=-prices[0], cool=0, min_buy=buy, tmp=sell;\\n        for(int i=1;i<len;i++){\\n            sell=min_buy+prices[i];// sell\\n            buy=cool-prices[i];// buy\\n            cool=Math.max(cool,tmp);\\n            tmp=sell;\\n            min_buy=Math.max(min_buy, buy);\\n        }\\n        return Math.max(sell,cool);\\n    }\\n```\\n2. dp[i][0/1/2] the max value gained on Day-i ending with status of sell/buy/cool down;\\n```\\npublic int maxProfit(int[] prices){\\n        int len=prices.length;\\n        if(len==0)return 0;\\n        int dp[][]=new int[len][3]; // dp[i][0/1/2]--> end with sell/buy/cooldown on/before day i\\n        dp[0][0]=0;\\n        dp[0][1]=-prices[0];\\n        dp[0][2]=0;\\n        for(int i=1;i<len;i++){\\n            dp[i][0]=Math.max(dp[i-1][1]+prices[i], dp[i-1][0]);// sell\\n            dp[i][1]=Math.max(dp[i-1][2]-prices[i], dp[i-1][1]);// buy\\n            dp[i][2]=Math.max(Math.max(dp[i-1][0],dp[i-1][1]),dp[i-1][2]);// cool down\\n        }\\n        return Math.max(Math.max(dp[len-1][0],dp[len-1][1]),dp[len-1][2]);\\n    }\\n```\\ndo the space optimization:\\n```\\npublic int maxProfit(int[] prices){\\n        int len=prices.length;\\n        if(len==0)return 0;\\n        int sell=0, buy=-prices[0], cooldown=0;\\n        for(int i=1;i<len;i++){\\n            int pre_sell=sell, prev_cooldown=cooldown;\\n            sell=Math.max(buy+prices[i], sell);// sell\\n            cooldown=Math.max(Math.max(pre_sell,buy),cooldown);// cool down\\n            buy=Math.max(prev_cooldown-prices[i], buy);// buy\\n        }\\n        return Math.max(Math.max(sell,buy),cooldown);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfit(int[] prices){\\n        int len=prices.length;\\n        if(len==0)return 0;\\n        int[][] dp=new int[prices.length][3];\\n        dp[0][0]=dp[0][2]=0;\\n        dp[0][1]=-prices[0];\\n        int min_buy=dp[0][1];\\n        for(int i=1;i<len;i++){\\n            dp[i][0]=min_buy+prices[i];// sell\\n            dp[i][1]=dp[i-1][2]-prices[i];// buy\\n            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][0]);\\n            min_buy=Math.max(min_buy, dp[i][1]);\\n        }\\n        return Math.max(dp[len-1][0],dp[len-1][2]);\\n    }\\n```\n```\\npublic int maxProfit(int[] prices){\\n        int len=prices.length;\\n        if(len==0)return 0;\\n        int sell=0, buy=-prices[0], cool=0, min_buy=buy, tmp=sell;\\n        for(int i=1;i<len;i++){\\n            sell=min_buy+prices[i];// sell\\n            buy=cool-prices[i];// buy\\n            cool=Math.max(cool,tmp);\\n            tmp=sell;\\n            min_buy=Math.max(min_buy, buy);\\n        }\\n        return Math.max(sell,cool);\\n    }\\n```\n```\\npublic int maxProfit(int[] prices){\\n        int len=prices.length;\\n        if(len==0)return 0;\\n        int dp[][]=new int[len][3]; // dp[i][0/1/2]--> end with sell/buy/cooldown on/before day i\\n        dp[0][0]=0;\\n        dp[0][1]=-prices[0];\\n        dp[0][2]=0;\\n        for(int i=1;i<len;i++){\\n            dp[i][0]=Math.max(dp[i-1][1]+prices[i], dp[i-1][0]);// sell\\n            dp[i][1]=Math.max(dp[i-1][2]-prices[i], dp[i-1][1]);// buy\\n            dp[i][2]=Math.max(Math.max(dp[i-1][0],dp[i-1][1]),dp[i-1][2]);// cool down\\n        }\\n        return Math.max(Math.max(dp[len-1][0],dp[len-1][1]),dp[len-1][2]);\\n    }\\n```\n```\\npublic int maxProfit(int[] prices){\\n        int len=prices.length;\\n        if(len==0)return 0;\\n        int sell=0, buy=-prices[0], cooldown=0;\\n        for(int i=1;i<len;i++){\\n            int pre_sell=sell, prev_cooldown=cooldown;\\n            sell=Math.max(buy+prices[i], sell);// sell\\n            cooldown=Math.max(Math.max(pre_sell,buy),cooldown);// cool down\\n            buy=Math.max(prev_cooldown-prices[i], buy);// buy\\n        }\\n        return Math.max(Math.max(sell,buy),cooldown);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75934,
                "title": "share-my-6ms-c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n < 2) return 0;\\n        vector<int>buy(n), sell(n), rest(n);\\n        buy[0] = -prices[0];\\n        sell[0] = 0;\\n        rest[0] = 0;\\n        for(int i = 1; i < n; i++){\\n            buy[i] = max(buy[i - 1], rest[i - 1] - prices[i]);\\n            sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]);\\n            rest[i] = max(rest[i - 1], sell[i - 1]);\\n        }\\n        return max(rest[n - 1], sell[n - 1]);\\n    }\\n};\\n```\\n***\\nSince day `i` relies only on `i-1`, we can reduce the O(n) space to O(1). \\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n < 2) return 0;\\n        int buy = -prices[0], sell = 0, rest = 0, preBuy, preSell;\\n        for(int i = 1; i < n; i++){\\n            preBuy = buy;\\n            preSell = sell;\\n            buy = max(buy, rest - prices[i]);\\n            sell = max(sell, preBuy + prices[i]);\\n            rest = max(rest, preSell);\\n        }\\n        return max(rest, sell);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n < 2) return 0;\\n        vector<int>buy(n), sell(n), rest(n);\\n        buy[0] = -prices[0];\\n        sell[0] = 0;\\n        rest[0] = 0;\\n        for(int i = 1; i < n; i++){\\n            buy[i] = max(buy[i - 1], rest[i - 1] - prices[i]);\\n            sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]);\\n            rest[i] = max(rest[i - 1], sell[i - 1]);\\n        }\\n        return max(rest[n - 1], sell[n - 1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n < 2) return 0;\\n        int buy = -prices[0], sell = 0, rest = 0, preBuy, preSell;\\n        for(int i = 1; i < n; i++){\\n            preBuy = buy;\\n            preSell = sell;\\n            buy = max(buy, rest - prices[i]);\\n            sell = max(sell, preBuy + prices[i]);\\n            rest = max(rest, preSell);\\n        }\\n        return max(rest, sell);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76017,
                "title": "share-my-c-dp-solution",
                "content": "> profitNoBlock[i] means the maximum profit you have && you have no\\n> stock at the end of day i. profitHasBlock[i] means the maximum\\n> profit you have && you have stock at the end of day i.\\n> profitNoBlock[i] = max(profitNoBlock[i-1], profitHasBlock[i-1] +\\n> prices[i]).\\n> \\n> profitHasBlock[i] = max(profitHasBlock[i-1], profitNoBlock[i-2] -\\n> prices[i]).\\n> \\n> profitNoBlock[-1] = 0.\\n\\n***space complexity:O(n)***\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int n = prices.size();\\n            if (n == 0 || n == 1)\\n                return 0;        \\n            \\n            vector<int> profitNoBlock(n, 0);\\n            vector<int> profitHasBlock(n, 0); \\n            int i = 0;\\n            \\n            //day 0\\n            profitNoBlock[0] = 0;\\n            profitHasBlock[0] = -prices[0];\\n    \\n            //day 1\\n            profitNoBlock[1] = max(profitNoBlock[0], profitHasBlock[0] + prices[1]);\\n            profitHasBlock[1] = max(profitHasBlock[0], 0 - prices[1]);\\n            \\n            for (i = 2; i < n; ++i)\\n            {\\n                profitNoBlock[i] = max(profitNoBlock[i-1], profitHasBlock[i-1] + prices[i]);\\n                profitHasBlock[i] = max(profitHasBlock[i-1], profitNoBlock[i-2] - prices[i]);\\n            }\\n            \\n            return profitNoBlock[n-1];\\n        }\\n    };\\n\\n\\n***space complexity:O(1)***\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int n = prices.size();\\n            if (n == 0 || n == 1)\\n                return 0;\\n                \\n            int curNo = 0;\\n            int preNo = 0;\\n            int curHas = 0; \\n            int i = 0, temp = 0;\\n            \\n            //day 0\\n            curNo = 0;\\n            preNo = 0;\\n            curHas = -prices[0];\\n            \\n            //day 1\\n            preNo = curNo;\\n            curNo = max(curNo, curHas + prices[1]);\\n            curHas = max(curHas, 0 - prices[1]);\\n            \\n            for (i = 2; i < n; ++i)\\n            {\\n                temp = curNo;\\n                curNo = max(curNo, curHas + prices[i]);\\n                curHas = max(curHas, preNo - prices[i]);\\n                preNo = temp;\\n            }\\n            \\n            return curNo;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int n = prices.size();\\n            if (n == 0 || n == 1)\\n                return 0;        \\n            \\n            vector<int> profitNoBlock(n, 0);\\n            vector<int> profitHasBlock(n, 0); \\n            int i = 0;\\n            \\n            //day 0\\n            profitNoBlock[0] = 0;\\n            profitHasBlock[0] = -prices[0];\\n    \\n            //day 1\\n            profitNoBlock[1] = max(profitNoBlock[0], profitHasBlock[0] + prices[1]);\\n            profitHasBlock[1] = max(profitHasBlock[0], 0 - prices[1]);\\n            \\n            for (i = 2; i < n; ++i)\\n            {\\n                profitNoBlock[i] = max(profitNoBlock[i-1], profitHasBlock[i-1] + prices[i]);\\n                profitHasBlock[i] = max(profitHasBlock[i-1], profitNoBlock[i-2] - prices[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3240505,
                "title": "309-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a similar approach to the previous solution, but uses a cache variable to store the current sell value so it can be used in the next iteration\\'s hold calculation. This allows the code to be more concise and avoids the need for an extra array to store previous sell values.\\n\\n# Complexity\\n- Time complexity:\\n71.15%\\n\\n- Space complexity:\\n61.93%\\n\\n# Code\\n```\\nclass Solution:\\n  def maxProfit(self, prices: List[int]) -> int:\\n    # Initialize variables for sell (maximum profit with no stock held), \\n    # hold (maximum profit with stock held), and prev (previous sell value)\\n    sell = 0\\n    hold = -math.inf\\n    prev = 0\\n\\n    # Loop through each price in the prices array\\n    for price in prices:\\n      # Cache the current sell value to be used for the next iteration\\'s hold calculation\\n      cache = sell\\n      # Update the sell value to be the maximum between the current sell value and \\n      # the maximum profit that can be made by selling at the current price, given \\n      # the maximum profit that can be made by holding the stock from the previous day\\n      sell = max(sell, hold + price)\\n      # Update the hold value to be the maximum between the current hold value and \\n      # the maximum profit that can be made by holding the stock from the previous day, \\n      # given the maximum profit that can be made by selling two days ago (prev - price)\\n      hold = max(hold, prev - price)\\n      # Update the previous sell value to be the cached sell value from the beginning \\n      # of the iteration\\n      prev = cache\\n\\n    # Return the final sell value, which represents the maximum profit that can be made\\n    return sell\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def maxProfit(self, prices: List[int]) -> int:\\n    # Initialize variables for sell (maximum profit with no stock held), \\n    # hold (maximum profit with stock held), and prev (previous sell value)\\n    sell = 0\\n    hold = -math.inf\\n    prev = 0\\n\\n    # Loop through each price in the prices array\\n    for price in prices:\\n      # Cache the current sell value to be used for the next iteration\\'s hold calculation\\n      cache = sell\\n      # Update the sell value to be the maximum between the current sell value and \\n      # the maximum profit that can be made by selling at the current price, given \\n      # the maximum profit that can be made by holding the stock from the previous day\\n      sell = max(sell, hold + price)\\n      # Update the hold value to be the maximum between the current hold value and \\n      # the maximum profit that can be made by holding the stock from the previous day, \\n      # given the maximum profit that can be made by selling two days ago (prev - price)\\n      hold = max(hold, prev - price)\\n      # Update the previous sell value to be the cached sell value from the beginning \\n      # of the iteration\\n      prev = cache\\n\\n    # Return the final sell value, which represents the maximum profit that can be made\\n    return sell\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115114,
                "title": "tc-o-n-sc-const-o-6-recursive-memoization-tabulation-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(n) for Space Optimization Method\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: Constant O(6) for Space Optimization Method\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n**-> RECURSION METHOD**\\n\\nclass Solution {\\npublic:\\n    int f(int ind,int buy,vector<int>&price)\\n    {\\n        if(ind>=price.size()) return 0;\\n        if(buy==1)\\n        {\\n            return max(-price[ind]+f(ind+1,0,price),0+f(ind+1,1,price));\\n        }\\n        return max(price[ind]+f(ind+2,1,price),0+f(ind+1,0,price));\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n       return f(0,1,prices);\\n    }\\n};\\n\\n//----------------------------------------------------------------------------------------\\n **-> MEMOIZATION METHOD**\\n\\nclass Solution {\\npublic:\\n    int f(int ind,int buy,vector<int>&price,vector<vector<int>>&dp)\\n    {\\n        if(ind>=price.size()) return 0;\\n        if(dp[ind][buy]!=-1) return dp[ind][buy];\\n        if(buy==1)\\n        {\\n            return dp[ind][buy]=max(-price[ind]+f(ind+1,0,price,dp),0+f(ind+1,1,price,dp));\\n        }\\n        return dp[ind][buy]=max(price[ind]+f(ind+2,1,price,dp),0+f(ind+1,0,price,dp));\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        return f(0,1,prices,dp);\\n    }\\n};\\n    \\n//------------------------------------------------------------------------------------------\\n**-> TABULATION METHOD**\\nclass Solution {\\npublic:\\n     int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+2,vector<int>(2,0));\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int buy=0;buy<=1;buy++)\\n            {\\n                if(buy==1)\\n                {\\n                    dp[ind][buy]=max(-prices[ind]+dp[ind+1][0],0+dp[ind+1][1]);\\n                }\\n                else\\n                     dp[ind][buy]=max(prices[ind]+dp[ind+2][1],0+dp[ind+1][0]);\\n            }\\n        }\\n        return dp[0][1];\\n     }\\n};\\n           \\n//-----------------------------------------------------------------------------------------------\\n**-> MORE OPTIMIZED TABULATION METHOD**\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+2,vector<int>(2,0));\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            dp[ind][1]=max(-prices[ind]+dp[ind+1][0],0+dp[ind+1][1]);\\n            dp[ind][0]=max(prices[ind]+dp[ind+2][1],0+dp[ind+1][0]);\\n        }\\n        return dp[0][1];\\n    }\\n};\\n\\n//------------------------------------------------------------------------------------------------\\n**-> SPACE OPTIMIZATION USING 3 VECTORS**\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       int n=prices.size();\\n        vector<int>front2(2,0);\\n        vector<int>front1(2,0);\\n        vector<int>curr(2,0);\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            curr[1]=max(-prices[ind]+front1[0],0+front1[1]);\\n            curr[0]=max(prices[ind]+front2[1],0+front1[0]);\\n\\n            front2=front1;\\n            front1=curr;\\n        }\\n        return curr[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n**-> RECURSION METHOD**\\n\\nclass Solution {\\npublic:\\n    int f(int ind,int buy,vector<int>&price)\\n    {\\n        if(ind>=price.size()) return 0;\\n        if(buy==1)\\n        {\\n            return max(-price[ind]+f(ind+1,0,price),0+f(ind+1,1,price));\\n        }\\n        return max(price[ind]+f(ind+2,1,price),0+f(ind+1,0,price));\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n       return f(0,1,prices);\\n    }\\n};\\n\\n//----------------------------------------------------------------------------------------\\n **-> MEMOIZATION METHOD**\\n\\nclass Solution {\\npublic:\\n    int f(int ind,int buy,vector<int>&price,vector<vector<int>>&dp)\\n    {\\n        if(ind>=price.size()) return 0;\\n        if(dp[ind][buy]!=-1) return dp[ind][buy];\\n        if(buy==1)\\n        {\\n            return dp[ind][buy]=max(-price[ind]+f(ind+1,0,price,dp),0+f(ind+1,1,price,dp));\\n        }\\n        return dp[ind][buy]=max(price[ind]+f(ind+2,1,price,dp),0+f(ind+1,0,price,dp));\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        return f(0,1,prices,dp);\\n    }\\n};\\n    \\n//------------------------------------------------------------------------------------------\\n**-> TABULATION METHOD**\\nclass Solution {\\npublic:\\n     int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+2,vector<int>(2,0));\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int buy=0;buy<=1;buy++)\\n            {\\n                if(buy==1)\\n                {\\n                    dp[ind][buy]=max(-prices[ind]+dp[ind+1][0],0+dp[ind+1][1]);\\n                }\\n                else\\n                     dp[ind][buy]=max(prices[ind]+dp[ind+2][1],0+dp[ind+1][0]);\\n            }\\n        }\\n        return dp[0][1];\\n     }\\n};\\n           \\n//-----------------------------------------------------------------------------------------------\\n**-> MORE OPTIMIZED TABULATION METHOD**\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+2,vector<int>(2,0));\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            dp[ind][1]=max(-prices[ind]+dp[ind+1][0],0+dp[ind+1][1]);\\n            dp[ind][0]=max(prices[ind]+dp[ind+2][1],0+dp[ind+1][0]);\\n        }\\n        return dp[0][1];\\n    }\\n};\\n\\n//------------------------------------------------------------------------------------------------\\n**-> SPACE OPTIMIZATION USING 3 VECTORS**\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       int n=prices.size();\\n        vector<int>front2(2,0);\\n        vector<int>front1(2,0);\\n        vector<int>curr(2,0);\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            curr[1]=max(-prices[ind]+front1[0],0+front1[1]);\\n            curr[0]=max(prices[ind]+front2[1],0+front1[0]);\\n\\n            front2=front1;\\n            front1=curr;\\n        }\\n        return curr[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941420,
                "title": "java-recursion-memoization-tabulation-space-optimized-4-solution",
                "content": "\\uD83D\\uDD25\\uD83D\\uDD25Please Upvote\\u2B06\\uFE0F and give a \\u2B50 if you like the solution. \\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 1.Recursion Solution\\n# Intuition\\nEvery day, we will have two choices, either to do nothing and move to the next day or to buy/sell(also check for cooldown period) and find out the profit.Therefore we have to try each and every possible choices , so we use **Recursion** .\\n\\n# Approach\\n1. Express the problem in term of index.\\n2. Try out all possible ways at the given index.\\n   - To either buy/sell \\n   - To do nothing and move to next day\\n   \\n3. Now if we can buy the stock(buy = 1) we have two choices:\\n   -  buy the stock and move to next day with condition that we have to first sell the stock(buy = 0).In this net profit will be **-prices[ind]**\\n   - Do not buy the stock and move to next day(buy = 1)\\n4. Now for sell condition(buy = 0):\\n   - Sell the stock and then move to next of next day(because if we sell at day i, then cooldown will be at i+1 day so we can buy the stock at i+2 day only).Here the net profit will be **prices[ind]**. \\n   - Don\\'t sell the sock and move to next day.\\n   \\n>NOTE: here `buy == 1` means we are allowed to buy, and `buy == 0` means we are allowed to sell the stock.\\n>Recursion Solution will give you TLE.\\n\\n<!-- # Complexity\\n- Time complexity:\\nAdd your time complexity here, e.g. $$O(n)$$\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //recursion solution\\n    public int maxProfit(int[] prices) {\\n        return solve(0 , 1 , prices);\\n    }\\n    private int solve(int index , int buy , int prices[]){\\n        if(index >= prices.length){\\n            return 0;\\n        }\\n\\n        if(buy == 1){\\n            return Math.max( -prices[index]  + solve(index + 1 , 0 , prices) , \\n                               0 + solve(index + 1 , 1 , prices));\\n        }\\n        return Math.max( prices[index] + solve(index + 2 , 1 , prices) , \\n                           0 + solve(index + 1 , 0 , prices) );\\n    }\\n}\\n```\\n\\n\\n\\n# 2.Memoized Solution\\n\\n# Steps:\\n1. In memoized solution we just have to take a dp array of size[n][2].\\n2. Initialize it with -1.\\n3. Then change the recursion solution to memoized one , by storing the state into the dp array.\\n\\n# Complexity:\\n - Time Complexity: O(n*2)\\n - Space Complexity: O(n*2) \\n\\n\\n# Code\\n```\\nclass Solution {\\n    //memoized solution\\n    public int maxProfit(int[] prices) {\\n        int dp[][] = new int[prices.length][2];\\n        for(int temp[] : dp){\\n            Arrays.fill(temp , -1);\\n        }\\n        return solve(0 , 1 , prices , dp);\\n    }\\n    private int solve(int index , int buy , int prices[] , int dp[][]){\\n        if(index >= prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buy] != -1) return dp[index][buy];\\n        if(buy == 1){\\n            return dp[index][buy] = Math.max( -prices[index]  + solve(index + 1 , 0 , prices , dp) , \\n                               0 + solve(index + 1 , 1 , prices , dp));\\n        }\\n        return dp[index][buy] = Math.max( prices[index] + solve(index + 2 , 1 , prices , dp) , \\n                           0 + solve(index + 1 , 0 , prices , dp) );\\n    }\\n}\\n```\\n\\n# 3.Tabulation Solution\\n\\n\\n# Steps:\\n1. To convert the memoization approach to a tabulation one, create a dp array with the same size as done in memoization.\\n2. Declare dp array with 0(zero) value.\\n3. Next, run two loops, the outer loop moves from `n-1` to `0` and the inner loop run from `0` to `1` for buy variable.\\n\\n\\n# Complexity:\\n- Time Complexity: O(n*2)\\n- Space complexity: O(n*2)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    //Tabulation solution\\n    public int maxProfit(int[] prices) {\\n        \\n        int n = prices.length;\\n        int dp[][] = new int[n+2][2];\\n\\n        for(int index = n-1;index >= 0;index--){\\n            for(int buy = 0;buy <= 1;buy++){\\n                if(buy == 1){\\n                    dp[index][buy] = Math.max( -prices[index] + dp[index + 1][0] , \\n                                                  0 + dp[index +1][1]);\\n                }\\n                else{\\n                    dp[index][buy] = Math.max(prices[index] + dp[index + 2][1] , \\n                                                 0 + dp[index + 1][0]);\\n                }\\n            }\\n        }\\n\\n        return dp[0][1];\\n    }\\n}\\n```\\n\\n# 4.Space Optimized Solution\\n\\nIf we closely look the relation,\\n\\n`dp[index][buy] = max( dp[index+1][buy])` ,\\n`dp[index][buy] = max( dp[index+2][!buy])`\\n\\nWe see that to calculate a value of a cell of the dp array, we need only the next two column values. So, we don\\u2019t need to store an entire 2-D array. Hence we can space optimize it.\\n\\n# Complexity\\n- Time Complexity : O(n)\\n- Space complexity : O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    //Space optimized solution\\n    public int maxProfit(int[] prices) {\\n        \\n        int n = prices.length;\\n        int index2[] = new int[2];\\n        int index1[] = new int[2];\\n        int curr[] = new int[2];\\n\\n        for(int index = n-1;index >= 0;index--){\\n            \\n            curr[1] = Math.max( -prices[index] + index1[0] , 0 + index1[1]);\\n            \\n            curr[0] = Math.max( prices[index] + index2[1] ,  0 + index1[0]);\\n\\n            index2 = (int [])(index1.clone());\\n            index1 = (int [])(curr.clone());\\n\\n        }\\n\\n        return curr[1];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    //recursion solution\\n    public int maxProfit(int[] prices) {\\n        return solve(0 , 1 , prices);\\n    }\\n    private int solve(int index , int buy , int prices[]){\\n        if(index >= prices.length){\\n            return 0;\\n        }\\n\\n        if(buy == 1){\\n            return Math.max( -prices[index]  + solve(index + 1 , 0 , prices) , \\n                               0 + solve(index + 1 , 1 , prices));\\n        }\\n        return Math.max( prices[index] + solve(index + 2 , 1 , prices) , \\n                           0 + solve(index + 1 , 0 , prices) );\\n    }\\n}\\n```\n```\\nclass Solution {\\n    //memoized solution\\n    public int maxProfit(int[] prices) {\\n        int dp[][] = new int[prices.length][2];\\n        for(int temp[] : dp){\\n            Arrays.fill(temp , -1);\\n        }\\n        return solve(0 , 1 , prices , dp);\\n    }\\n    private int solve(int index , int buy , int prices[] , int dp[][]){\\n        if(index >= prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buy] != -1) return dp[index][buy];\\n        if(buy == 1){\\n            return dp[index][buy] = Math.max( -prices[index]  + solve(index + 1 , 0 , prices , dp) , \\n                               0 + solve(index + 1 , 1 , prices , dp));\\n        }\\n        return dp[index][buy] = Math.max( prices[index] + solve(index + 2 , 1 , prices , dp) , \\n                           0 + solve(index + 1 , 0 , prices , dp) );\\n    }\\n}\\n```\n```\\nclass Solution {\\n    //Tabulation solution\\n    public int maxProfit(int[] prices) {\\n        \\n        int n = prices.length;\\n        int dp[][] = new int[n+2][2];\\n\\n        for(int index = n-1;index >= 0;index--){\\n            for(int buy = 0;buy <= 1;buy++){\\n                if(buy == 1){\\n                    dp[index][buy] = Math.max( -prices[index] + dp[index + 1][0] , \\n                                                  0 + dp[index +1][1]);\\n                }\\n                else{\\n                    dp[index][buy] = Math.max(prices[index] + dp[index + 2][1] , \\n                                                 0 + dp[index + 1][0]);\\n                }\\n            }\\n        }\\n\\n        return dp[0][1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    //Space optimized solution\\n    public int maxProfit(int[] prices) {\\n        \\n        int n = prices.length;\\n        int index2[] = new int[2];\\n        int index1[] = new int[2];\\n        int curr[] = new int[2];\\n\\n        for(int index = n-1;index >= 0;index--){\\n            \\n            curr[1] = Math.max( -prices[index] + index1[0] , 0 + index1[1]);\\n            \\n            curr[0] = Math.max( prices[index] + index2[1] ,  0 + index1[0]);\\n\\n            index2 = (int [])(index1.clone());\\n            index1 = (int [])(curr.clone());\\n\\n        }\\n\\n        return curr[1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706342,
                "title": "recursive-approach-is-most-intuitive-c-memoization-189ms",
                "content": "**if you like my approach please hit the upvote button ! : )**\\n```\\n    // Recursive approach is very intuitive\\n    \\n    // In this problem extra constraint is given that is cooldown = > After you sell your stock, you cannot \\n    // buy stock on the next day (i.e., cooldown one day).\\n    \\n    int findMax(vector<int>& prices, int curr, int n, vector<int>&dp)\\n    {\\n        if(curr>=n)\\n            return 0;\\n        \\n        if(dp[curr]!=-1)\\n            return dp[curr];\\n        \\n        //Now find all the positions where we can sell the stock\\n        int maxVal = 0;\\n        for(int i=curr+1;i<n;++i)\\n            if(prices[curr]<prices[i])  // We can try to sell on ith day\\n                //We have 2 choices\\n                //1.We can sell the stock at ith day and findMax from (i+2)th day\\n                //2.We don\\'t sell the stock on ith day\\n                maxVal = max(maxVal, (prices[i]-prices[curr])+findMax(prices, i+2, n, dp));//(i+1)th day is cooldown\\n        \\n        maxVal = max(maxVal, findMax(prices,curr+1,n,dp)); // Exclude current element\\n        dp[curr] = maxVal;\\n        return maxVal;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        vector<int>dp(n+1,-1);\\n        return findMax(prices,0,n,dp);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    // Recursive approach is very intuitive\\n    \\n    // In this problem extra constraint is given that is cooldown = > After you sell your stock, you cannot \\n    // buy stock on the next day (i.e., cooldown one day).\\n    \\n    int findMax(vector<int>& prices, int curr, int n, vector<int>&dp)\\n    {\\n        if(curr>=n)\\n            return 0;\\n        \\n        if(dp[curr]!=-1)\\n            return dp[curr];\\n        \\n        //Now find all the positions where we can sell the stock\\n        int maxVal = 0;\\n        for(int i=curr+1;i<n;++i)\\n            if(prices[curr]<prices[i])  // We can try to sell on ith day\\n                //We have 2 choices\\n                //1.We can sell the stock at ith day and findMax from (i+2)th day\\n                //2.We don\\'t sell the stock on ith day\\n                maxVal = max(maxVal, (prices[i]-prices[curr])+findMax(prices, i+2, n, dp));//(i+1)th day is cooldown\\n        \\n        maxVal = max(maxVal, findMax(prices,curr+1,n,dp)); // Exclude current element\\n        dp[curr] = maxVal;\\n        return maxVal;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        vector<int>dp(n+1,-1);\\n        return findMax(prices,0,n,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522403,
                "title": "c-dp-with-image-explanation",
                "content": "# Image explanation \\n### before we start:\\n* `buy` means the best day to buy, so the day which the price is lowest,  **after cooldown** (remember that we can\\'t buy after we sold a stock)\\n* `sell` means the profit that we can get the current day after we sell the stock bought previously (the stock we bought is the the stock with lowest price that we can get from cooldown day to the current day, so it is `buy`)\\n* `cooldown`  max profit we can get between selling the stock and and the prev_cooldown (so, if the current day is the best day to sell the stock)\\n\\n### Ex. ` prices = [1,2,3,0,2]`\\nwe initialize `buy` `sell` `cooldown`. `buy = INT_MIN` because in the first day the best day to but is that day, so setting `buy = INT_MIN` means that there isn\\'t a better option to buy stocks before the first day. `sell = 0` because we can\\'t sell anything in the first day, so the profit of the first day = 0,   `cooldown =0` because in the first day the max profit is 0 (since we haven\\'t sell or buy any stock yet)\\n![image](https://assets.leetcode.com/users/images/814e52dd-e9cf-4fe2-95b5-d2ec43324c4e_1634295768.4670546.png)\\nthe best day to buy for now (from cooldown day to first day) is the first day.\\n![image](https://assets.leetcode.com/users/images/888871d9-b090-4852-839f-5435093b755a_1634296706.60576.png)\\n`sell = imp` because we haven\\'t bought stocks yet, so we can\\'t sell anything, in our code isntead of impossible we say `INT_MIN - 1`\\n![image](https://assets.leetcode.com/users/images/a7125324-36eb-4103-8df2-6661f54d54d9_1634296879.384528.png)\\n`cooldown = max(prev_sell,prev_cooldown)` \\n![image](https://assets.leetcode.com/users/images/94a759e5-ad9c-47e5-92b4-5b511dcdd29f_1634296893.5155323.png)\\nIn the second day the best day to `buy` stock (lowest price) is still the first day,  `sell = prev_buy - price`, `cooldown = max(prev_sell,prev_cooldown)` \\n![image](https://assets.leetcode.com/users/images/e5b761c8-3132-428d-b009-e12bc6360946_1634297362.8268251.png)  ![image](https://assets.leetcode.com/users/images/88580c2f-b420-4b6a-8925-f080adbfc565_1634297338.8870075.png) ![image](https://assets.leetcode.com/users/images/50a1d169-1f10-45a1-ba0a-aefb74f6436f_1634297394.6282141.png)\\ncheck for each day\\n![image](https://assets.leetcode.com/users/images/8371f5e5-731f-445c-b3f6-60e26c81e333_1634297444.9803815.png)\\nfind the max between last cooldown and sell (in this case the max is sell, but in other case it could be cooldown)\\n\\n### Another example\\n![image](https://assets.leetcode.com/users/images/0944d047-531c-40a8-97c2-5cde238851a7_1634297745.5832272.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t//INITIALIZE\\n        int buy = INT_MIN, sell = 0, cooldown = 0;\\n\\n\\t\\t//check for every day (price)\\n        for (auto price : prices) {\\n\\t\\t\\t//to see how it works check images above \\n            int prev_buy = buy, prev_sell = sell, prev_cooldown = cooldown;\\n\\n            buy = max(prev_buy, prev_cooldown - price);\\n            sell = prev_buy + price;\\n            cooldown = max(prev_sell, prev_cooldown);\\n        }\\n        return max(sell, cooldown);\\n    }\\n};\\n```\\nplease upvote if you found it usefull",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t//INITIALIZE\\n        int buy = INT_MIN, sell = 0, cooldown = 0;\\n\\n\\t\\t//check for every day (price)\\n        for (auto price : prices) {\\n\\t\\t\\t//to see how it works check images above \\n            int prev_buy = buy, prev_sell = sell, prev_cooldown = cooldown;\\n\\n            buy = max(prev_buy, prev_cooldown - price);\\n            sell = prev_buy + price;\\n            cooldown = max(prev_sell, prev_cooldown);\\n        }\\n        return max(sell, cooldown);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802013,
                "title": "c-3-vectors-dp-with-explanation",
                "content": "At each timestamp `i`, there are 3 states: \\n(1) you have stock in hands;\\n(2) you just sold at `i` and  cannot buy at `i+1`; \\n(3) you don\\'t have stock and can buy at `i+1`.\\n\\nThe next step is to find their relationship:\\n(1) you can buy this stock at `i` or before `i`, which corresponds to `dp[i-1][2]-prices[i]` and `dp[i-1][0]` respectively. (Buying is viewed as a negative profit)\\n(2) You own stock at `i-1` and sell at `i`, so now you have `dp[i-1][0] + prices[i]`.\\n(3) You sold your stock at `i-1` or before, which corresponds to `dp[i-1][1]` and `dp[i-1][2]` respectively.\\n\\nFinally, just return the max of `dp.back()[1]` and `dp.back()[2]` since you can\\'t get maximum profit if you still have stock in hands.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<vector<int>> dp(prices.size(), vector<int>(3, -INT_MAX));\\n        dp[0][0] = -prices[0];\\n        dp[0][2] = 0;\\n        for (int i = 1; i < prices.size(); i++) {\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i]); // have stock in hands\\n            dp[i][1] = dp[i-1][0] + prices[i]; // just sold stock at i\\n            dp[i][2] = max(dp[i-1][1], dp[i-1][2]); // don\\'t have stock, able to buy at i+1\\n        }\\n        return max(dp.back()[1], dp.back()[2]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<vector<int>> dp(prices.size(), vector<int>(3, -INT_MAX));\\n        dp[0][0] = -prices[0];\\n        dp[0][2] = 0;\\n        for (int i = 1; i < prices.size(); i++) {\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i]); // have stock in hands\\n            dp[i][1] = dp[i-1][0] + prices[i]; // just sold stock at i\\n            dp[i][2] = max(dp[i-1][1], dp[i-1][2]); // don\\'t have stock, able to buy at i+1\\n        }\\n        return max(dp.back()[1], dp.back()[2]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645210,
                "title": "well-commented-and-very-intuitive-solution-states-dp",
                "content": "Hello, after struggling nearly a day with this problem, I have finally managed to solve it. Understanding this problem was very difficult for me, so I wrote the solution below on a step by step basis, just the way I understood it. As a matter of fact, I wrote the comments first so that I could formulate the whole process of what is happening.\\n\\nThe trick in this problem is that at a specific day i, we can get three different values of profit because simply on day i, we can either buy, sell or hold the stock. The key is to keep that in mind, and solve for all possible actions (buy, sell hold) for a given day of the problem.\\n\\nYou may want to draw this [state transition image](https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown.jpg) on a page and work your way through the problem by hand at first.\\n\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length == 0) {return 0;}\\n        int [] buy = new int [prices.length];\\n        int [] sell = new int [prices.length];\\n        int [] rest = new int [prices.length];\\n        \\n        // on day 0, default cases are:\\n        //   (i).   buy -> profit after buying stock on day 0 for prices[0]\\n        //   (ii).  sell -> profit after selling stock on day 0; since we may only buy on day 0, it is not possible to sell on day 0\\n        //   (iii). rest -> profit after not opting to buy/sell on day 0; hence, profit is 0\\n        buy[0] = - prices[0]; // when we BUY, our profit is decreased by the price of the stock on that day\\n        sell[0] = 0; // when we SELL, our profit is increased by the price of stock on that day\\n        rest[0] = 0; // when we REST, our profit is the same as the previous day\\'s profit after resting, or the previous day\\'s profit after selling\\n        \\n        \\n        // i -> day [1 ... N]\\n        // price[i] -> price we buy/sell/hold/dontHold at day i\\n        for (int i = 1; i < prices.length; i++) {\\n            \\n            // let\\'s say we have a stock in hand on day i\\n            // there are two ways to achieve that -> buying the stock on day i, or having bought the stock on a previous day\\n            // therefore, possible state transitions are: rest -> buy [on BUY] OR buy -> buy [on REST, that is holding the stock]\\n            // in the latter, no changes were made to the stock in hand\\n            buy[i] = Math.max(rest[i - 1] - prices[i], buy[i - 1]);\\n            \\n            // let\\'s say we sold the stock in hand on day i\\n            // only one possible state transition of achieving that: buy -> sell [on SELL]\\n            sell[i] = buy[i - 1] + prices[i];\\n            \\n            // let\\'s say we are in cooldown on day i\\n            // important point to note here is that, a day on cooldown means I can buy the stock the next day\\n\\t\\t\\t// this means, I need to maintain previous day\\'s rest records here\\n            // once again, there are two ways of attaining that: \\n            //   (i).  rest on day i after selling on previous day, i.e. day [i - 1]\\n            //   (ii). rest on day i by waiting multiple days after selling, i.e. having sold on a day BEFORE day [i - 1]\\n            // therefore, the transitions are: sell -> rest [on SELL] OR rest -> rest [on REST]\\n            rest[i] = Math.max(rest[i - 1], sell[i - 1]);\\n        }\\n        \\n        // After days [0 ... N] has elapsed, I want to find the maximum profit\\n        // So the final action that I must have taken may either be SELL or REST\\n        // If the final action has been a BUY, then my profit will only decrease.\\n        return Math.max(rest[prices.length - 1], sell[prices.length - 1]);\\n    }\\n}\\n```\\n\\nLast but not the least, I have learned a lot from this discussion forum and without it, I would not have been able to develop the thought-process involving different states or actions. Hence, this is my way of returning the favor. **Feedbacks and constructive criticism are welcome :)**\\n\\n\\nIf you look closely, you can notice that we only need the ith and (i-1)th index in the array. To save space, you can replace them with current and old variables instead of the arrays for each state as a means of optimization. But if you were struggling like me, you may want to go with the following method at first.\\n\\nThe image above has been taken from [this comment](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking)/79232).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length == 0) {return 0;}\\n        int [] buy = new int [prices.length];\\n        int [] sell = new int [prices.length];\\n        int [] rest = new int [prices.length];\\n        \\n        // on day 0, default cases are:\\n        //   (i).   buy -> profit after buying stock on day 0 for prices[0]\\n        //   (ii).  sell -> profit after selling stock on day 0; since we may only buy on day 0, it is not possible to sell on day 0\\n        //   (iii). rest -> profit after not opting to buy/sell on day 0; hence, profit is 0\\n        buy[0] = - prices[0]; // when we BUY, our profit is decreased by the price of the stock on that day\\n        sell[0] = 0; // when we SELL, our profit is increased by the price of stock on that day\\n        rest[0] = 0; // when we REST, our profit is the same as the previous day\\'s profit after resting, or the previous day\\'s profit after selling\\n        \\n        \\n        // i -> day [1 ... N]\\n        // price[i] -> price we buy/sell/hold/dontHold at day i\\n        for (int i = 1; i < prices.length; i++) {\\n            \\n            // let\\'s say we have a stock in hand on day i\\n            // there are two ways to achieve that -> buying the stock on day i, or having bought the stock on a previous day\\n            // therefore, possible state transitions are: rest -> buy [on BUY] OR buy -> buy [on REST, that is holding the stock]\\n            // in the latter, no changes were made to the stock in hand\\n            buy[i] = Math.max(rest[i - 1] - prices[i], buy[i - 1]);\\n            \\n            // let\\'s say we sold the stock in hand on day i\\n            // only one possible state transition of achieving that: buy -> sell [on SELL]\\n            sell[i] = buy[i - 1] + prices[i];\\n            \\n            // let\\'s say we are in cooldown on day i\\n            // important point to note here is that, a day on cooldown means I can buy the stock the next day\\n\\t\\t\\t// this means, I need to maintain previous day\\'s rest records here\\n            // once again, there are two ways of attaining that: \\n            //   (i).  rest on day i after selling on previous day, i.e. day [i - 1]\\n            //   (ii). rest on day i by waiting multiple days after selling, i.e. having sold on a day BEFORE day [i - 1]\\n            // therefore, the transitions are: sell -> rest [on SELL] OR rest -> rest [on REST]\\n            rest[i] = Math.max(rest[i - 1], sell[i - 1]);\\n        }\\n        \\n        // After days [0 ... N] has elapsed, I want to find the maximum profit\\n        // So the final action that I must have taken may either be SELL or REST\\n        // If the final action has been a BUY, then my profit will only decrease.\\n        return Math.max(rest[prices.length - 1], sell[prices.length - 1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508001,
                "title": "javascript-dp-solution-with-comments",
                "content": "This one took me a while to wrap my head around. I\\'ve added comments for the core logic of each piece of this and tried to use meaningful variable names for each piece, hopefully it helps you understand what\\'s going on!\\n\\n```\\nvar maxProfit = function(prices) {\\n    // buy will keep track of the max profit on each day where the last thing we did was buy\\n    // sell will keep track of the max profit on each day where the last thing we did was sell\\n    let buy = new Array(prices.length);\\n    let sell = new Array(prices.length);\\n    \\n    // Assume we buy on day 1, so buy starts off negative (unless first price is 0)\\n    buy[0] = 0 - prices[0]\\n    // Can\\'t sell on day 1 (need to buy first), so sell starts off at 0\\n    sell[0] = 0;\\n    \\n    for (let i = 1; i < prices.length; i++) {\\n        // Compare keeping the previous buy with buying today. If we buy today it means we keep\\n        // the max profit from selling 2 days ago (since we need a cooldown day before buying today)\\n        // and subtract the price of the buy to get our current profit with this buy. The `|| 0` is \\n        // to account for when i = 1, and sell[i-2] is undefined.\\n        let prevBuy = buy[i-1];\\n        let buyNow = (sell[i-2] || 0) - prices[i];\\n        buy[i] = Math.max(prevBuy, buyNow); \\n        \\n        // Compare keeping the previous sell with selling today. If we sell today, it means we keep \\n        // the max profit from buying one day ago (must buy before sell) and add the sell price. This\\n        // works because when we add profit to the buy array we subtract the price of the buy, so we \\n        // have effectively accounted for the difference in buy & sell price & profit stays accurate\\n        let prevSell = sell[i-1];\\n        let sellNow = prices[i] + buy[i-1];\\n        sell[i] = Math.max(prevSell, sellNow);\\n    }\\n    \\n    // Return the max profit from sell on last day (we\\'ll never be better off having last\\n    // transaction be a buy assuming prices are reasonable and will never be negative).\\n\\t// Note this doesn\\'t necessarily mean we sold on the last day, but rather that on the  \\n\\t// last day, the most recent action we had taken was to sell (potentially on a previous \\n\\t// day with no further action afterwards).\\n    return sell[sell.length-1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxProfit = function(prices) {\\n    // buy will keep track of the max profit on each day where the last thing we did was buy\\n    // sell will keep track of the max profit on each day where the last thing we did was sell\\n    let buy = new Array(prices.length);\\n    let sell = new Array(prices.length);\\n    \\n    // Assume we buy on day 1, so buy starts off negative (unless first price is 0)\\n    buy[0] = 0 - prices[0]\\n    // Can\\'t sell on day 1 (need to buy first), so sell starts off at 0\\n    sell[0] = 0;\\n    \\n    for (let i = 1; i < prices.length; i++) {\\n        // Compare keeping the previous buy with buying today. If we buy today it means we keep\\n        // the max profit from selling 2 days ago (since we need a cooldown day before buying today)\\n        // and subtract the price of the buy to get our current profit with this buy. The `|| 0` is \\n        // to account for when i = 1, and sell[i-2] is undefined.\\n        let prevBuy = buy[i-1];\\n        let buyNow = (sell[i-2] || 0) - prices[i];\\n        buy[i] = Math.max(prevBuy, buyNow); \\n        \\n        // Compare keeping the previous sell with selling today. If we sell today, it means we keep \\n        // the max profit from buying one day ago (must buy before sell) and add the sell price. This\\n        // works because when we add profit to the buy array we subtract the price of the buy, so we \\n        // have effectively accounted for the difference in buy & sell price & profit stays accurate\\n        let prevSell = sell[i-1];\\n        let sellNow = prices[i] + buy[i-1];\\n        sell[i] = Math.max(prevSell, sellNow);\\n    }\\n    \\n    // Return the max profit from sell on last day (we\\'ll never be better off having last\\n    // transaction be a buy assuming prices are reasonable and will never be negative).\\n\\t// Note this doesn\\'t necessarily mean we sold on the last day, but rather that on the  \\n\\t// last day, the most recent action we had taken was to sell (potentially on a previous \\n\\t// day with no further action afterwards).\\n    return sell[sell.length-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482121,
                "title": "python-intuitive-dp-explanation-28ms-o-n",
                "content": "Key observation is that at day *i* you can either **buy**, **sell** or **rest** and the max profit at day *i* is defined by:\\n\\n```\\nmaxProfit(i) = maxProfit(i-1) + max(buy_or_not(i), sell_or_not(i))\\n```\\n\\nWhere buy_or_not(i), sell_or_not(i) are the profit of the day whether you buy, sell or don\\'t do anything. \\nThere are two conditions we need to handle: \\n* The buy action is conditioned on whether the previous day was a rest day.\\n* The sell action is conditioned on whether we own a stock.\\n\\nSo we can express these two actions as:\\n```\\nbuy_or_not(i) = max(rest(i-1) - price(i), buy_or_not(i-1))\\nsell_or_not(i) = max(buy(i-1) + price(i), sell_or_not(i-1))\\n```\\nWhere rest(i-1) is the maximum profit at day i-1 if we were to rest, and we easily can see that rest(i-1) = sell_or_not(i-2). So the above can be written:\\n```\\nbuy_or_not(i) = max(sell_or_not(i-2) - price(i), buy_or_not(i-1))\\nsell_or_not(i) = max(buy(i-1) + price(i), sell_or_not(i-1))\\n```\\n\\nNow that we have our update step we see that we need to keep state for 3 things at each iteration:\\n* buy_or_not(i-1)\\n* sell_or_not(i-1)\\n* sell_or_not(i-2)\\n\\nIn Python this translates to:\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        prev_rest = prev_sell = 0\\n        prev_buy = -prices[0]\\n        \\n        for p in prices[1:]:\\n            buy = max(prev_rest - p, prev_buy)\\n            sell = max(prev_buy + p, prev_sell)\\n            prev_buy = buy\\n            prev_rest = prev_sell\\n            prev_sell = sell\\n            \\n        return max([prev_rest, prev_sell])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nmaxProfit(i) = maxProfit(i-1) + max(buy_or_not(i), sell_or_not(i))\\n```\n```\\nbuy_or_not(i) = max(rest(i-1) - price(i), buy_or_not(i-1))\\nsell_or_not(i) = max(buy(i-1) + price(i), sell_or_not(i-1))\\n```\n```\\nbuy_or_not(i) = max(sell_or_not(i-2) - price(i), buy_or_not(i-1))\\nsell_or_not(i) = max(buy(i-1) + price(i), sell_or_not(i-1))\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        prev_rest = prev_sell = 0\\n        prev_buy = -prices[0]\\n        \\n        for p in prices[1:]:\\n            buy = max(prev_rest - p, prev_buy)\\n            sell = max(prev_buy + p, prev_sell)\\n            prev_buy = buy\\n            prev_rest = prev_sell\\n            prev_sell = sell\\n            \\n        return max([prev_rest, prev_sell])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446609,
                "title": "java-easy-understand-dp-beat-100",
                "content": "For each day, there are 3 kinds of state: rest, hold, sold.\\n\\nAt the first day, we are at rest state, then the other day we have 2 choices:\\n\\t1. not buy stock => rest state \\n\\t2. buy stock => hold state\\n\\nIf we are in hold state, then the other day we have 2 choices:\\n\\t1. not sell stock => hold state\\n\\t2. sell stock => sold state\\n\\nIf we are in sold state, the other day we have only one choice, that is rest (since we must cool down after selling).\\n\\nSo:\\ni in range (1, prices.length)\\nhold[i] = max(hold[i-1], rest[i-1]-prices[i-1])\\nrest[i] = max(rest[i-1], sold[i-1])\\nsold[i] = hold[i-1] + prices[i-1]\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int day = prices.length+1;\\n        int rest[] = new int[day];\\n        int hold[] = new int[day];\\n        int sold[] = new int[day];\\n        \\n        rest[0] = 0;\\n        sold[0] = 0;\\n        hold[0] = Integer.MIN_VALUE;\\n        \\n        for(int i=1;i<day;i++){\\n            sold[i] = hold[i-1]+prices[i-1];\\n            rest[i] = Math.max(rest[i-1],sold[i-1]);\\n            hold[i] = Math.max(hold[i-1],rest[i-1]-prices[i-1]);\\n        }\\n        \\n\\t\\t//hold[day-1] must be smaller than rest[day-1]\\n        return Math.max(rest[day-1],sold[day-1]);\\n    }\\n}\\n```\\n\\nRuntime: 1 ms, faster than 73.44% of Java online submissions for Best Time to Buy and Sell Stock with Cooldown.\\nMemory Usage: 36.3 MB, less than 100.00% of Java online submissions for Best Time to Buy and Sell Stock with Cooldown.\\n\\nImprove by replacing array with single integer:\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sold = 0;\\n        int rest = 0;\\n        int hold = Integer.MIN_VALUE;\\n        \\n        for(int price:prices){\\n            int prev_sold = sold;\\n            sold = hold + price;\\n            hold = Math.max(hold,rest-price);\\n            rest = Math.max(rest,prev_sold);\\n        }\\n        return Math.max(rest,sold);\\n    }\\n}\\n```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Best Time to Buy and Sell Stock with Cooldown.\\nMemory Usage: 36.2 MB, less than 100.00% of Java online submissions for Best Time to Buy and Sell Stock with Cooldown.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int day = prices.length+1;\\n        int rest[] = new int[day];\\n        int hold[] = new int[day];\\n        int sold[] = new int[day];\\n        \\n        rest[0] = 0;\\n        sold[0] = 0;\\n        hold[0] = Integer.MIN_VALUE;\\n        \\n        for(int i=1;i<day;i++){\\n            sold[i] = hold[i-1]+prices[i-1];\\n            rest[i] = Math.max(rest[i-1],sold[i-1]);\\n            hold[i] = Math.max(hold[i-1],rest[i-1]-prices[i-1]);\\n        }\\n        \\n\\t\\t//hold[day-1] must be smaller than rest[day-1]\\n        return Math.max(rest[day-1],sold[day-1]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sold = 0;\\n        int rest = 0;\\n        int hold = Integer.MIN_VALUE;\\n        \\n        for(int price:prices){\\n            int prev_sold = sold;\\n            sold = hold + price;\\n            hold = Math.max(hold,rest-price);\\n            rest = Math.max(rest,prev_sold);\\n        }\\n        return Math.max(rest,sold);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327906,
                "title": "explanation-by-someone-who-struggled-followed-by-java-o-n-time-o-1-space",
                "content": "So, I was struggling with this problem for a while. Initially I did a naive implementation that did not work and started getting frustrated. Finally I ran into [this post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75931/Easiest-JAVA-solution-with-explanations). This is a very good post (which I encourage you to read in case you think mine is too long) but still it took me a while to figure out what is going on. Finally I decided to write my own little explanation, I hope this helps other people.\\n\\nIn this problem, there are two different states that you can be in: **bought** or **sold**. Every day you can transition to the other state (by selling if you\\'re bought or by buying if you\\'re sold) or remaining in the same state, either because of a cooldown or by choice. In a day where you buy a stock you need to subtract the price of the stock that day from your current purse of money (i.e. profits up to that day). When you sell the stock, you add the price of the stock that day back to your purse.\\n\\nSo the question is, how do we maximize our profits on the last day? Let\\'s call last day \"d\". Let\\'s also define two functions: `bought(d)` and `sold(d)`. `bought(d)` returns your profits or purse of money if you were to finish day \"d\" in state \"bought\". Likewise, function `sold(d)` returns your profits if you were to finish day \"d\" in state \"sold\". Our profit in day \"d\" can be defined as the maximum of these two possibilities:\\n\\n```\\nprofit(d) = max(bought(d), sold(d))\\n```\\n\\nNow, how do we calculate `bought(d)`?\\n\\nHere we need look at what happened in the past. To be able to buy on day \"d\" (and finish the day \"bought\") it means either 1) the day before we were already bought, in which case we simply keep the same profits as what we had the day before or 2) we have been in the sold state for at least two days (because of the mandatory cooldown) and then buy on day d. In this second case we take the all our profits up to day \"d - 2\" and subtract the price today to be able to buy the stock. Given these two possibilities, the one we take is the one that maximizes the profits, hence we derive our final formula:\\n\\n```\\nbought(d) = max(bought(d - 1), sold(d - 2) - price(d))\\n```\\n\\nAnd what about `sold(d)`?\\n\\nSimilarly, either the day before we were already sold and we just remain in the same state today (in which case we copy the purse of money/max profits into today) or the day before we were bought and today we sell the stock. In this case, whatever price the stock has we add it to our purse of money. Again, we want to take the scenario that maximizes the purse of money so again our final formula will be a max:\\n\\n```\\nsold(d) = max(sold(d - 1), bought(d - 1) + price(d))\\n```\\n\\nAt this point we can see the recursive nature of the solution and why dynamic programming helps here. What we can see in most of the O(1) space solutions that people post is that, in order to calculate the profits on day \"d\" we only need to \"remember\" the value for 3 variables:\\n* bought(d - 1)\\n* sold(d - 2)\\n* sold(d - 1)\\n\\nFinally, here goes my implementation. I will try to make this as clear as possible:\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) { return 0; }\\n\\n\\t\\t// if we were to end day 0 bought, we would actually owe money at this point\\n        int boughtDMinus1 = -prices[0];\\n\\n\\t\\t// if we were to end day 0 sold, our purse would still be empty\\n\\t\\tint soldDMinus1 = 0;\\t\\t// purse is still empty\\n        int soldDMinus2 = 0;\\t\\t// purse is still empty\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            int bDM1 = boughtDMinus1;\\n            boughtDMinus1 = Math.max(\\n                boughtDMinus1, soldDMinus2 - prices[i]);\\n            soldDMinus2 = soldDMinus1;\\n            soldDMinus1 = Math.max(\\n                soldDMinus1, bDM1 + prices[i]);\\n        }\\n\\n        return Math.max(boughtDMinus1, soldDMinus1);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nprofit(d) = max(bought(d), sold(d))\\n```\n```\\nbought(d) = max(bought(d - 1), sold(d - 2) - price(d))\\n```\n```\\nsold(d) = max(sold(d - 1), bought(d - 1) + price(d))\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) { return 0; }\\n\\n\\t\\t// if we were to end day 0 bought, we would actually owe money at this point\\n        int boughtDMinus1 = -prices[0];\\n\\n\\t\\t// if we were to end day 0 sold, our purse would still be empty\\n\\t\\tint soldDMinus1 = 0;\\t\\t// purse is still empty\\n        int soldDMinus2 = 0;\\t\\t// purse is still empty\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            int bDM1 = boughtDMinus1;\\n            boughtDMinus1 = Math.max(\\n                boughtDMinus1, soldDMinus2 - prices[i]);\\n            soldDMinus2 = soldDMinus1;\\n            soldDMinus1 = Math.max(\\n                soldDMinus1, bDM1 + prices[i]);\\n        }\\n\\n        return Math.max(boughtDMinus1, soldDMinus1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75992,
                "title": "4ms-c-dp-beat-84",
                "content": "\\n    // 3 values to update each step:\\n    //  the most money choosing buy: b;\\n    //  the most money choosing sell: s0;\\n    //  the most money doing nothing: s1; \\n    \\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            if(prices.size()<=1) return 0;\\n            int s0=0, s1=0, b=-prices[0];\\n            for(int i=1; i<prices.size(); i++) {\\n                int tmp = max(s0, s1);\\n                s0 = b+prices[i];\\n                b = max(s0,s1)-prices[i];\\n                s1 = tmp;\\n            }\\n            return max(s0, s1);\\n            \\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            if(prices.size()<=1) return 0;\\n            int s0=0, s1=0, b=-prices[0];\\n            for(int i=1; i<prices.size(); i++) {\\n                int tmp = max(s0, s1);\\n                s0 = b+prices[i];\\n                b = max(s0,s1)-prices[i];\\n                s1 = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76036,
                "title": "my-c-o-n-dp-algorithm-8ms-finite-state-machine-based",
                "content": "The basic idea is to define a finite state machine (FSM) to describe the state at each step\\nS_BUY (nothing to sell, but can buy), S_SELL (can sell, but can not buy), S_COOL (in cooldown mode, i.e. previous operation is SELL). S_BUY can go to S_BUY (do nothing at this step) or S_SELL (i.e. buy at this step); S_SELL can go to S_SELL(do nothing at this step) or S_COOL (SELL at this step); S_COOL can only move to S_BUY (do nothing at this step). With such FSM defined, one can move forward step by step to update the state array, which describes the profits at each possible state. Complexity is O(3*N)\\n\\n    class Solution {\\n    private:\\n        const int STATE_NUM =3, STEP_NUM = 2, S_BUY=0, S_SELL=1, S_COOL=2;\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int state[STATE_NUM][STEP_NUM], i, j, steps = prices.size(),cur=0, next=1;\\n            fill_n(&state[0][0], STATE_NUM*STEP_NUM, INT_MIN);\\n            for(i=0,state[0][0]=0;i<steps;++i, swap(cur, next))\\n            {\\n                state[S_BUY][next]  = max(state[S_BUY][cur], state[S_COOL][cur]);\\n                state[S_SELL][next] = max(state[S_BUY][cur]-prices[i], state[S_SELL][cur]);\\n                state[S_COOL][next] = state[S_SELL][cur] + prices[i];\\n            }\\n            return max(state[S_BUY][cur], state[S_COOL][cur]);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        const int STATE_NUM =3, STEP_NUM = 2, S_BUY=0, S_SELL=1, S_COOL=2;\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int state[STATE_NUM][STEP_NUM], i, j, steps = prices.size(),cur=0, next=1;\\n            fill_n(&state[0][0], STATE_NUM*STEP_NUM, INT_MIN);\\n            for(i=0,state[0][0]=0;i<steps;++i, swap(cur, next))\\n            {\\n                state[S_BUY][next]  = max(state[S_BUY][cur], state[S_COOL][cur]);\\n                state[S_SELL][next] = max(state[S_BUY][cur]-prices[i], state[S_SELL][cur]);\\n                state[S_COOL][next] = state[S_SELL][cur] + prices[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76040,
                "title": "share-my-python-solution-with-explanation",
                "content": "DP\\uff0cwe can create two array, buy and sell. buy[i] means we buy a stock at day i , and sell[i] means we sell a stock at day i.\\n\\nso, we have two equations :\\n\\n - buy[i] = max(buy[i-1] , sell[i-2] - prices[i])  // So we should use sell[i-2] means we cooldown one day. \\n - sell[i] = max(sell[i-1],buy[i-1] + prices[i])\\n\\nfinally, return the max(buy[n-1] , sell[n-1])  \\uff08it is obvious that sell[n-1] >= buy[n-1] ,so we return sell[n-1]\\uff09\\n\\nif you want to see more about it, you can visit my blog : [Best Time to Buy and Sell Stock with Cooldown][1]\\n\\n    class Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not prices or len(prices) < 2: return 0\\n        n = len(prices)\\n        buy, sell = [0] * n, [0] * n\\n        buy[0] = -prices[0]\\n        buy[1] = max(-prices[0], -prices[1])\\n        sell[1] = max(0, prices[1] - prices[0])\\n        for i in xrange(2, n):\\n            buy[i] = max(sell[i - 2] - prices[i], buy[i - 1])\\n            sell[i] = max(buy[i - 1] + prices[i], sell[i - 1])\\n    \\n        return sell[n - 1]\\n\\n\\n  [1]: http://www.hrwhisper.me/leetcode-best-time-to-buy-and-sell-stock-with-cooldown/",
                "solutionTags": [
                    "Python"
                ],
                "code": "DP\\uff0cwe can create two array, buy and sell. buy[i] means we buy a stock at day i , and sell[i] means we sell a stock at day i.\\n\\nso, we have two equations :\\n\\n - buy[i] = max(buy[i-1] , sell[i-2] - prices[i])  // So we should use sell[i-2] means we cooldown one day. \\n - sell[i] = max(sell[i-1],buy[i-1] + prices[i])\\n\\nfinally, return the max(buy[n-1] , sell[n-1])  \\uff08it is obvious that sell[n-1] >= buy[n-1] ,so we return sell[n-1]\\uff09\\n\\nif you want to see more about it, you can visit my blog : [Best Time to Buy and Sell Stock with Cooldown][1]\\n\\n    class Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not prices or len(prices) < 2: return 0\\n        n = len(prices)\\n        buy, sell = [0] * n, [0] * n\\n        buy[0] = -prices[0]\\n        buy[1] = max(-prices[0], -prices[1])\\n        sell[1] = max(0, prices[1] - prices[0])\\n        for i in xrange(2, n):\\n            buy[i] = max(sell[i - 2] - prices[i], buy[i - 1])\\n            sell[i] = max(buy[i - 1] + prices[i], sell[i - 1])\\n    \\n        return sell[n - 1]\\n\\n\\n  [1]: http://www.hrwhisper.me/leetcode-best-time-to-buy-and-sell-stock-with-cooldown/",
                "codeTag": "Java"
            },
            {
                "id": 3430492,
                "title": "c-top-down-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n=p.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        dp[1][1]=-1*p[0];\\n        for(int i=2;i<=n;i++){\\n            for(int j=0;j<2;j++){\\n                if(j){\\n                    dp[i][j]=max(-1*p[i-1]+dp[i-2][0] , dp[i-1][1]);\\n                }\\n                else {\\n                    dp[i][j]=max(p[i-1]+dp[i-1][1],dp[i-1][0]);\\n                }\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/25bf8db6-100d-4a5d-b8cc-f52664fc48ce_1681813046.8204837.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n=p.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        dp[1][1]=-1*p[0];\\n        for(int i=2;i<=n;i++){\\n            for(int j=0;j<2;j++){\\n                if(j){\\n                    dp[i][j]=max(-1*p[i-1]+dp[i-2][0] , dp[i-1][1]);\\n                }\\n                else {\\n                    dp[i][j]=max(p[i-1]+dp[i-1][1],dp[i-1][0]);\\n                }\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943718,
                "title": "dp-python-both-o-n-2-and-o-n-solution",
                "content": "# Intuition\\nThis is problem is a typical DP problem. I will first give a naive O(n^2) solution, then optimize it to O(n)\\n\\n# Approach\\n**Subproblem** definition: dp[i] is the maximum profit by the i th day.\\n**Equation**: dp[i] = max(no-sell[i], sell[i]), where\\nno-sell[i] = dp[i-1]\\nsell[i] = max(dp[j-2] + prices[i] - prices[j])), 0 <= j < i\\n\\nWe see that are i and j, so naivly it is O(n^2). But we can remove j.\\n\\nThe observation is that prices[i] is a constant during max(), thus can be moved out of the max()\\nmax(dp[j-2] + prices[i] - prices[j]), 0 <= j < i \\n==> prices[i] + max(dp[j-2] - prices[j]), 0 <= j < i\\n\\nSo, we only need to compute **max(dp[j-2] - prices[j])**, and we **don\\'t need to iterate j starting from 0 for each i**\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n\\n```\\nclass Solution:\\n    \\'\\'\\'O(n^2)\\n       subproblem: dp[i] is the max profit by the i th day.\\n    \\'\\'\\'\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [0] * n\\n        for i in range(1, n):      # the i th day\\n            dp[i] = dp[i-1]        # no sell at i th day\\n            for j in range(i):     # buy at j-th day, sell at i th day\\n                subprob = dp[j-2] if j >= 2 else 0\\n                dp[i] = max(dp[i], subprob + prices[i] - prices[j])\\n        return dp[-1]\\n```\\n\\n```\\nclass Solution:\\n    \\'\\'\\'optimizing the time complexity to O(n)\\n           max(subprob + prices[i] - prices[j]), 0 <= j < i \\n       ==> prices[i] + max(subprob - prices[j]), 0 <= j < i\\n    \\'\\'\\'\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [0] * n\\n        maxx = float(\\'-inf\\')\\n        for i in range(1, n):                       # the i th day\\n            subprob = dp[i-3] if i >= 3 else 0\\n            maxx = max(maxx, subprob - prices[i-1]) # buy at i-1 th day\\n            dp[i] = max(dp[i-1], prices[i] + maxx)  # no sell at i th day, sell at i-th day\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \\'\\'\\'O(n^2)\\n       subproblem: dp[i] is the max profit by the i th day.\\n    \\'\\'\\'\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [0] * n\\n        for i in range(1, n):      # the i th day\\n            dp[i] = dp[i-1]        # no sell at i th day\\n            for j in range(i):     # buy at j-th day, sell at i th day\\n                subprob = dp[j-2] if j >= 2 else 0\\n                dp[i] = max(dp[i], subprob + prices[i] - prices[j])\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    \\'\\'\\'optimizing the time complexity to O(n)\\n           max(subprob + prices[i] - prices[j]), 0 <= j < i \\n       ==> prices[i] + max(subprob - prices[j]), 0 <= j < i\\n    \\'\\'\\'\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [0] * n\\n        maxx = float(\\'-inf\\')\\n        for i in range(1, n):                       # the i th day\\n            subprob = dp[i-3] if i >= 3 else 0\\n            maxx = max(maxx, subprob - prices[i-1]) # buy at i-1 th day\\n            dp[i] = max(dp[i-1], prices[i] + maxx)  # no sell at i th day, sell at i-th day\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940576,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "\\n```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int fun(int idx,int buy,vector<int> &prices,vector<vector<int>> &dp)\\n    {\\n        if(idx>=prices.size())\\n            return 0;\\n        int profit=0;\\n        if(dp[idx][buy]!=-1) return dp[idx][buy];\\n        if(buy)\\n        {\\n            profit=max(-prices[idx]+fun(idx+1,0,prices,dp),0+fun(idx+1,1,prices,dp));\\n        }\\n        else\\n        {\\n            profit=max(prices[idx]+fun(idx+2,1,prices,dp),0+fun(idx+1,0,prices,dp));\\n        }\\n        return dp[idx][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(),vector<int> (2,-1));\\n        return fun(0,1,prices,dp);\\n    }\\n};\\n```\\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n\\n int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size()+2,vector<int> (2,0));\\n        int n=prices.size();\\n        for(int idx=n-1;idx>=0;idx--)\\n        {\\n            for(int buy=0;buy<=1;buy++)\\n            {\\n                if(buy)\\n                {\\n                    dp[idx][buy]=max(-prices[idx]+dp[idx+1][0],0+dp[idx+1][1]);\\n                }\\n                else\\n                {\\n                    dp[idx][buy]=max(prices[idx]+dp[idx+2][1],0+dp[idx+1][0]);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int fun(int idx,int buy,vector<int> &prices,vector<vector<int>> &dp)\\n    {\\n        if(idx>=prices.size())\\n            return 0;\\n        int profit=0;\\n        if(dp[idx][buy]!=-1) return dp[idx][buy];\\n        if(buy)\\n        {\\n            profit=max(-prices[idx]+fun(idx+1,0,prices,dp),0+fun(idx+1,1,prices,dp));\\n        }\\n        else\\n        {\\n            profit=max(prices[idx]+fun(idx+2,1,prices,dp),0+fun(idx+1,0,prices,dp));\\n        }\\n        return dp[idx][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(),vector<int> (2,-1));\\n        return fun(0,1,prices,dp);\\n    }\\n};\\n```\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n\\n int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size()+2,vector<int> (2,0));\\n        int n=prices.size();\\n        for(int idx=n-1;idx>=0;idx--)\\n        {\\n            for(int buy=0;buy<=1;buy++)\\n            {\\n                if(buy)\\n                {\\n                    dp[idx][buy]=max(-prices[idx]+dp[idx+1][0],0+dp[idx+1][1]);\\n                }\\n                else\\n                {\\n                    dp[idx][buy]=max(prices[idx]+dp[idx+2][1],0+dp[idx+1][0]);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571292,
                "title": "optimized-c-o-n-time-o-1-space",
                "content": "By working backwards, to determine the profit at index i we really only need the max profit from 3 places: \\n1. if we buy at i + 1 (buy1)\\n2. if we sell at i + 1 (sell1)\\n3. if we buy at i + 2 (buy2) - because if we sell at i, we would need to cooldown on i + 1\\n\\nUsing these, we can determine the max profit if we buy at i, ```buyi``` as the max of 2 cases:\\n1. we could choose not to buy at i, and just take the profit from buy1 (buying at or after i + 1)\\n2. if we do buy at i, we can gain the profit from sell1 (which means selling at or after i + 1) at the cost of buying at i, hence we subtract prices[i]\\n\\nSimilarly, by selling at i, we choose the max of these 2 cases for ```selli```:\\n1. we could not sell at i, and defer to sell1\\n2. if we do sell at i, we can gain prices[i], but we cannot look to i+1 because there must be a cooldown. So we take buy2\\n\\nAt the end, we simply return buy1, because this stores the max profit of all transactions buying at or after the first price.\\n\\nPlease upvote if it helps!\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int buy1 = 0, sell1 = prices[n-1], buy2 = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            int buyi = max(buy1, sell1 - prices[i]);\\n            int selli = max(sell1, buy2 + prices[i]);\\n            buy2 = buy1; buy1 = buyi; sell1 = selli;\\n        }\\n        return buy1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```buyi```\n```selli```",
                "codeTag": "Unknown"
            },
            {
                "id": 2218587,
                "title": "java-in-depth-solution-intuitive-solution-for-human",
                "content": "To be honest, I actually feel this problem is really hard so I would try to solve the problem with **brute force** which is more intuitive.\\n  \\n  **Data Structure**\\n  \\n  We have a `int[ ] profit = new int[n]` which represents the max profit on `day i`.\\n  \\n  **Logic**\\n  \\n  We have three possibilities on `day i`\\n  \\n  1. \\u2714\\uFE0F buy day \\n  2. \\u2714\\uFE0F cooldown day \\n  3. \\u2714\\uFE0F sell day \\n\\nLet\\'s go through all the possibilities.\\n\\n1. If `day i` is a **buy** day, then we won\\'t be able to make profit on `day i` so the max profit is same as the previous day which is `profit[i] = profit[i-1]`\\n2. If `day i` is a **cooldown** day, we also won\\'t be able to make profit on `day i` so the max profit is also `profit[i] = profit[i-1]`\\n3. If `day i` is a **sell** day, then we need to figure out which day is a buy day. `buy day` could be `[0, i-1]` which is any day before `i`. Let\\'s denote `buy day` as `day j` so `profit[i] = Math.max(profit[i], prevous max profit + prices[i] - prices[j])`. Therefore, how do we find out `previous max profit`?  \\n  (1) `day j` is a buy day so `day j - 1` **cannot** be buy day. We must sell the stock before we buy another one.\\n  (2) `day j` is a buy day so `day j - 1` **cannot** be sell day. There\\'s a cooldown day between sell day and buy day.\\n  (3) Therefore, `day j - 1` **must be** `cooldown day`. Refer to 2, the max profit of today is `profit[j-2]`.\\n  \\nHere is my Solution in **Java**\\n\\n```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices)\\n    {\\n        // O(n^2) time | O(n) space\\n        if(prices == null || prices.length <= 1) return 0;\\n        \\n        int n = prices.length;\\n        int[] profit = new int[n];\\n        profit[0] = 0;\\n        profit[1] = Math.max(0, prices[1] - prices[0]);\\n        \\n        for(int i = 2; i < n; i++)\\n        {\\n            // if day i is a buy/ cooldown day, the profit is same as previous day\\n            profit[i] = profit[i - 1];\\n            \\n            for(int j = 0; j < i; j++)\\n            {\\n                // if day i is a sell day, [0, j] all could be buy day. Hence, we need to look for profit of day j-1\\n                // day j-1 must be a cooldown day so previous profit of j-1 is day j-2\\n                // we simply try all the combination to see which one we can have max profit\\n                int prev_profit = j >= 2 ? profit[j - 2] : 0;\\n                profit[i] = Math.max(profit[i], prev_profit + prices[i] - prices[j]);\\n            }\\n        }\\n        return profit[n - 1];\\n    }\\n}\\n```\\n\\nAgain, I personally think it is a hard problem so coming up w/ a solution during the interview is pretty good enough. However, we can do better if the interviewer asks whether we can drop the time/space complexity. Actually, we can solve the problem with a for-loop to drop the time complexity to O(n). In my past interview experience, we don\\'t need to actually implement it. We just need to explain our thoughts and solution to the interviewer how we optimize it. \\nBut anyways, I still provide it below as a reference.\\n\\n```\\nclass Solution \\n{\\n    public int maxProfit(int[] prices)\\n    {\\n        if(prices == null || prices.length <= 1)    return 0;\\n        \\n        // proft[i] represents the max profit on day i\\n        int n = prices.length;\\n        int[] profit = new int[n];\\n        profit[0] = 0;\\n        profit[1] = Math.max(prices[1] - prices[0], 0);\\n        \\n        // profit[j-2] + nums[i] - nums[j]\\n        // diff = (profit[j-2] - nums[j])\\n        int diff = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < 2)   \\n                diff = Math.max(diff, -prices[i]);\\n            else\\n            {\\n                profit[i] = Math.max(profit[i-1], diff + prices[i]);\\n                diff = Math.max(diff, profit[i-2] - prices[i]);\\n            }\\n        }\\n        return profit[n-1];\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices)\\n    {\\n        // O(n^2) time | O(n) space\\n        if(prices == null || prices.length <= 1) return 0;\\n        \\n        int n = prices.length;\\n        int[] profit = new int[n];\\n        profit[0] = 0;\\n        profit[1] = Math.max(0, prices[1] - prices[0]);\\n        \\n        for(int i = 2; i < n; i++)\\n        {\\n            // if day i is a buy/ cooldown day, the profit is same as previous day\\n            profit[i] = profit[i - 1];\\n            \\n            for(int j = 0; j < i; j++)\\n            {\\n                // if day i is a sell day, [0, j] all could be buy day. Hence, we need to look for profit of day j-1\\n                // day j-1 must be a cooldown day so previous profit of j-1 is day j-2\\n                // we simply try all the combination to see which one we can have max profit\\n                int prev_profit = j >= 2 ? profit[j - 2] : 0;\\n                profit[i] = Math.max(profit[i], prev_profit + prices[i] - prices[j]);\\n            }\\n        }\\n        return profit[n - 1];\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int maxProfit(int[] prices)\\n    {\\n        if(prices == null || prices.length <= 1)    return 0;\\n        \\n        // proft[i] represents the max profit on day i\\n        int n = prices.length;\\n        int[] profit = new int[n];\\n        profit[0] = 0;\\n        profit[1] = Math.max(prices[1] - prices[0], 0);\\n        \\n        // profit[j-2] + nums[i] - nums[j]\\n        // diff = (profit[j-2] - nums[j])\\n        int diff = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < 2)   \\n                diff = Math.max(diff, -prices[i]);\\n            else\\n            {\\n                profit[i] = Math.max(profit[i-1], diff + prices[i]);\\n                diff = Math.max(diff, profit[i-2] - prices[i]);\\n            }\\n        }\\n        return profit[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859813,
                "title": "simple-4-lines-o-n-dp-in-python",
                "content": "Basically 3 status:\\n- 0: got no stock\\n- 1: holding stock\\n- 2: cooldown \\n\\n![image](https://assets.leetcode.com/users/images/474658bb-d733-41d4-88a0-f63abd5fa924_1647583266.9832807.png)\\n\\nWe can get to status 0 from 0(still dont buy) or 2(finish cooldown), get to status 1 from 0(buy new stock) or 1(still holding stock), get to status 2 from 1(sell a stock).\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        dp0, dp1, dp2 = 0, -prices[0], 0\\n        for p in prices:\\n            dp0, dp1, dp2 = max(dp0, dp2), max(dp1, dp0 - p), dp1 + p\\n        return max(dp0, dp2)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        dp0, dp1, dp2 = 0, -prices[0], 0\\n        for p in prices:\\n            dp0, dp1, dp2 = max(dp0, dp2), max(dp1, dp0 - p), dp1 + p\\n        return max(dp0, dp2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610347,
                "title": "7-line-java-code-easy-solution",
                "content": "We have three states: hold, sold and rest\\n**A question to ask**: How to get to each state and have maximum balance?\\n**Hold:** 1. holdi-1 ->(rest) holdi 2. resti-1 ->(buy stock) holdi\\nthus balance: max(holdi-1, resti-1 - pricei)\\n\\n**Sold:** 1. holdi-1 ->(sell stock)soldi \\nthus balance: holdi-1 + pricei\\n\\n**Rest:** 1. soldi-1 ->(cool down)resti 2. resti-1->(rest) resti\\nthus balance: max(soldi-1, resti-1)\\n\\nThe process by the end has to be stoped at a **Rest** state\\nSo **result is just max(sold, rest)**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sold = 0, rest=0, hold = rest-prices[0];\\n        for(int price: prices){\\n            int pre_sold =sold;\\n            sold = hold + price;\\n            hold = Math.max(hold, rest-price);\\n            rest = Math.max(rest,pre_sold);\\n        }\\n        return Math.max(rest, sold);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sold = 0, rest=0, hold = rest-prices[0];\\n        for(int price: prices){\\n            int pre_sold =sold;\\n            sold = hold + price;\\n            hold = Math.max(hold, rest-price);\\n            rest = Math.max(rest,pre_sold);\\n        }\\n        return Math.max(rest, sold);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590015,
                "title": "c-dp-o-n-o-1",
                "content": "We need to track our profits in three states, `empty` means we are not holding any stock, `hold` means we hold stock, `cool` means we just sold the stock that day. \\n\\nIf today is `hold` state, then yesterday we may still in `hold` state and we did not change anything, or we just bought stock today so we change state from `empty` to `hold`, and we pay the price `i`\\n\\nIf today is `empty`, then yesterday we probably had the same state, or yesterday we were actually in `cool` state. We do nothing.\\n\\nIf today is `cool` state, It means today we sold our stock for price `i` and we change from `hold` to `cool`. \\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n\\tint empty = 0, hold = INT_MIN, cool = INT_MIN;\\n\\tfor (int i : prices) {\\n\\t\\thold = max(hold, empty - i);\\n\\t\\tempty = max(empty, cool); \\n\\t\\tcool = hold + i;\\n\\t}\\n\\treturn max(empty, cool);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxProfit(vector<int>& prices) {\\n\\tint empty = 0, hold = INT_MIN, cool = INT_MIN;\\n\\tfor (int i : prices) {\\n\\t\\thold = max(hold, empty - i);\\n\\t\\tempty = max(empty, cool); \\n\\t\\tcool = hold + i;\\n\\t}\\n\\treturn max(empty, cool);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566910,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nNote: similar to [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/1586778/The-ART-of-Dynamic-Programming), this is one of the most difficult DP problems to \"turn upside down\", since we are *not* following the recursive stack unwinding.  Instead the bottom-up solution tracks previous best states to formulate current best states per the following state machine.\\n\\n![image](https://assets.leetcode.com/users/images/eea00a68-0964-4531-a75f-114b7ac1bb3e_1636394391.5816202.png)\\n\\n`none` = we do *not* `have` any stock, so we can either hold or buy\\n`have` = we own the stock we `have` bought, so we can either hold or sell\\n`sold` = we sold the stock we `have` bought, so we must cooldown (ie. go to `none` for at least 1 turn)\\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, NONE: Int = -1): Int {\\n        var N = A.size\\n        fun go(i: Int = 0, have: Int = NONE): Int {\\n            if (N <= i)\\n                return 0\\n            var buy  = if (have == NONE) go(i + 1, A[i]) else 0\\n            var sell = if (have != NONE) go(i + 2, NONE) + A[i] - have else 0\\n            var hold = go(i + 1, have)\\n            return listOf(buy, sell, hold).max()!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, NONE: Int = -1): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = NONE): Int {\\n            if (N <= i)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var buy  = if (have == NONE) go(i + 1, A[i]) else 0\\n                var sell = if (have != NONE) go(i + 2, NONE) + A[i] - have else 0\\n                var hold = go(i + 1, have)\\n                m[k] = listOf(buy, sell, hold).max()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, INF: Int = 1001): Int {\\n        var N = A.size\\n        var none = IntArray(N + 1) { 0 }\\n        var have = IntArray(N + 1) { 0 }\\n        var sold = IntArray(N + 1) { 0 }\\n        have[0] = -INF  // to consider buy for A[0]\\n        for (i in 1..N) {\\n            var x = A[i - 1]\\n            none[i] = Math.max(none[i - 1], sold[i - 1])      // implicit hold when none[i] = none[i - 1]\\n            have[i] = Math.max(have[i - 1], none[i - 1] - x)  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            sold[i] = have[i - 1] + x                         // +x because we sell at price x\\n        }\\n        return listOf(none[N], have[N], sold[N]).max()!!\\n    }\\n}\\n```\\n\\n4. Memory optimization O(N) \\uD83D\\uDC49 O(1) since we only need the previous solutions to formulate current solutions\\n```\\ndata class State(var none: Int, var have: Int, var sold: Int)\\nclass Solution {\\n    fun maxProfit(A: IntArray, INF: Int = 1001): Int {\\n        var N = A.size\\n        var cur = State(0, -INF, 0)  // have = -INF to consider buy for A[0]\\n        for (x in A) {\\n            var pre = State(cur.none, cur.have, cur.sold)\\n            cur.none = Math.max(pre.none, pre.sold)      // implicit hold when none[i] = none[i - 1]\\n            cur.have = Math.max(pre.have, pre.none - x)  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            cur.sold = pre.have + x                      // +x because we sell at price x\\n        }\\n        return listOf(cur.none, cur.have, cur.sold).max()!!\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet maxProfit = (A, NONE = -1) => {\\n    let N = A.length;\\n    let go = (i = 0, have = NONE) => {\\n        if (N <= i)\\n            return 0;\\n        let buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n            sell = have != NONE ? go(i + 2, NONE) + A[i] - have : 0,\\n            hold = go(i + 1, have);\\n        return Math.max(buy, sell, hold);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet maxProfit = (A, m = new Map(), NONE = -1) => {\\n    let N = A.length;\\n    let go = (i = 0, have = NONE) => {\\n        if (N <= i)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n                sell = have != NONE ? go(i + 2, NONE) + A[i] - have : 0,\\n                hold = go(i + 1, have);\\n            m.set(k, Math.max(buy, sell, hold));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet maxProfit = (A, INF = 1001) => {\\n    let N = A.length;\\n    let none = Array(N + 1).fill(0),\\n        have = Array(N + 1).fill(0),\\n        sold = Array(N + 1).fill(0);\\n    have[0] = -INF; // to consider buy for A[0]\\n    for (let i = 1; i <= N; ++i) {\\n        let x = A[i - 1];\\n        none[i] = Math.max(none[i - 1], sold[i - 1]);      // implicit hold when none[i] = none[i - 1]\\n        have[i] = Math.max(have[i - 1], none[i - 1] - x);  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n        sold[i] = have[i - 1] + x;                         // +x because we sell at price x\\n    }\\n    return Math.max(none[N], have[N], sold[N]);\\n};\\n```\\n\\n4. Memory optimization O(N) \\uD83D\\uDC49 O(1) since we only need the previous solutions to formulate current solutions\\n```\\nlet maxProfit = (A, INF = 1001) => {\\n    let N = A.length;\\n    let cur = {\\n        none: 0,\\n        have: -INF, // to consider buy for A[0]\\n        sold: 0,\\n    };\\n    for (let x of A) {\\n        let pre = _.cloneDeep(cur);\\n        cur.none = Math.max(pre.none, pre.sold);      // implicit hold when none[i] = none[i - 1]\\n        cur.have = Math.max(pre.have, pre.none - x);  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n        cur.sold = pre.have + x;                      // +x because we sell at price x\\n    }\\n    return Math.max(cur.none, cur.have, cur.sold);\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], NONE = -1) -> int:\\n        N = len(A)\\n        def go(i = 0, have = NONE):\\n            if N <= i:\\n                return 0\\n            buy  = go(i + 1, A[i]) if have == NONE else 0\\n            sell = go(i + 2, NONE) + A[i] - have if have != NONE else 0\\n            hold = go(i + 1, have)\\n            return max(buy, sell, hold)\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], NONE = -1) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0, have = NONE):\\n            if N <= i:\\n                return 0\\n            buy  = go(i + 1, A[i]) if have == NONE else 0\\n            sell = go(i + 2, NONE) + A[i] - have if have != NONE else 0\\n            hold = go(i + 1, have)\\n            return max(buy, sell, hold)\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], INF = 1001) -> int:\\n        N = len(A)\\n        none = [0] * (N + 1)\\n        have = [0] * (N + 1)\\n        sold = [0] * (N + 1)\\n        have[0] = -INF  # to consider buy A[0]\\n        for i in range(1, N + 1):\\n            x = A[i - 1]\\n            none[i] = max(none[i - 1], sold[i - 1])      # implicit hold when none[i] = none[i - 1]\\n            have[i] = max(have[i - 1], none[i - 1] - x)  # implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            sold[i] = have[i - 1] + x                    # +x because we sell at price x\\n        return max(none[N], have[N], sold[N])\\n```\\n\\n4. Memory optimization O(N) \\uD83D\\uDC49 O(1) since we only need the previous solutions to formulate current solutions\\n```\\nclass State:\\n    def __init__(self, none = 0, have = 0, sold = 0):\\n        self.none = none\\n        self.have = have\\n        self.sold = sold\\nclass Solution:\\n    def maxProfit(self, A: List[int], INF = 1001) -> int:\\n        N = len(A)\\n        cur = State(0, -INF, 0)  # have = -INF to consider buy A[0]\\n        for x in A:\\n            pre = deepcopy(cur)\\n            cur.none = max(pre.none, pre.sold)      # implicit hold when none[i] = none[i - 1]\\n            cur.have = max(pre.have, pre.none - x)  # implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            cur.sold = pre.have + x                 # +x because we sell at price x\\n        return max(cur.none, cur.have, cur.sold)\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int maxProfit(VI& A, int NONE = -1) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto have) {\\n            if (N <= i)\\n                return 0;\\n            auto buy = have == NONE ? go(i + 1, A[i]) : 0,\\n                 sell = have != NONE ? go(i + 2, NONE) + A[i] - have : 0,\\n                 keep = go(i + 1, have);\\n            return max({ buy, sell, keep });\\n        };\\n        return go(0, NONE);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maxProfit(VI& A, Map m = {}, int NONE = -1) {\\n        int N = A.size();\\n        auto key = [](auto i, auto k) {\\n            stringstream ss; ss << i << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (N <= i)\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto buy = have == NONE ? go(i + 1, A[i]) : 0,\\n                     sell = have != NONE ? go(i + 2, NONE) + A[i] - have : 0,\\n                     keep = go(i + 1, have);\\n                m[k] = max({ buy, sell, keep });\\n            }\\n            return m[k];\\n        };\\n        return go(0, NONE);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int INF = 1001) {\\n        int N = A.size();\\n        VI none(N + 1),\\n           have(N + 1),\\n           sold(N + 1);\\n        have[0] = -INF; // to consider buying A[0]\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            auto x = A[i - 1];\\n            none[i] = max(none[i - 1], sold[i - 1]);      // implicit hold when none[i] = none[i - 1]\\n            have[i] = max(have[i - 1], none[i - 1] - x);  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            sold[i] = x + have[i - 1];                    // +x because we sell at price x\\n        }\\n        return max({ none[N], have[N], sold[N] });\\n    }\\n};\\n```\\n\\n4. Memory optimization O(N) \\uD83D\\uDC49 O(1) since we only need the previous solutions to formulate current solutions\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    struct State {\\n        int none, have, sold;\\n    };\\n    int maxProfit(VI& A, State cur = {}, int INF = 1001) {\\n        cur.have = -INF; // to consider buying A[0]\\n        int N = A.size();\\n        for (auto x: A) {\\n            State pre{ cur };\\n            cur.none = max(cur.none, pre.sold);      // implicit hold when none[i] = none[i - 1]\\n            cur.have = max(cur.have, pre.none - x);  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            cur.sold = x + pre.have;                 // +x because we sell at price x\\n        }\\n        return max({ cur.none, cur.have, cur.sold });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfit(A: IntArray, NONE: Int = -1): Int {\\n        var N = A.size\\n        fun go(i: Int = 0, have: Int = NONE): Int {\\n            if (N <= i)\\n                return 0\\n            var buy  = if (have == NONE) go(i + 1, A[i]) else 0\\n            var sell = if (have != NONE) go(i + 2, NONE) + A[i] - have else 0\\n            var hold = go(i + 1, have)\\n            return listOf(buy, sell, hold).max()!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, NONE: Int = -1): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = NONE): Int {\\n            if (N <= i)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var buy  = if (have == NONE) go(i + 1, A[i]) else 0\\n                var sell = if (have != NONE) go(i + 2, NONE) + A[i] - have else 0\\n                var hold = go(i + 1, have)\\n                m[k] = listOf(buy, sell, hold).max()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, INF: Int = 1001): Int {\\n        var N = A.size\\n        var none = IntArray(N + 1) { 0 }\\n        var have = IntArray(N + 1) { 0 }\\n        var sold = IntArray(N + 1) { 0 }\\n        have[0] = -INF  // to consider buy for A[0]\\n        for (i in 1..N) {\\n            var x = A[i - 1]\\n            none[i] = Math.max(none[i - 1], sold[i - 1])      // implicit hold when none[i] = none[i - 1]\\n            have[i] = Math.max(have[i - 1], none[i - 1] - x)  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            sold[i] = have[i - 1] + x                         // +x because we sell at price x\\n        }\\n        return listOf(none[N], have[N], sold[N]).max()!!\\n    }\\n}\\n```\n```\\ndata class State(var none: Int, var have: Int, var sold: Int)\\nclass Solution {\\n    fun maxProfit(A: IntArray, INF: Int = 1001): Int {\\n        var N = A.size\\n        var cur = State(0, -INF, 0)  // have = -INF to consider buy for A[0]\\n        for (x in A) {\\n            var pre = State(cur.none, cur.have, cur.sold)\\n            cur.none = Math.max(pre.none, pre.sold)      // implicit hold when none[i] = none[i - 1]\\n            cur.have = Math.max(pre.have, pre.none - x)  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            cur.sold = pre.have + x                      // +x because we sell at price x\\n        }\\n        return listOf(cur.none, cur.have, cur.sold).max()!!\\n    }\\n}\\n```\n```\\nlet maxProfit = (A, NONE = -1) => {\\n    let N = A.length;\\n    let go = (i = 0, have = NONE) => {\\n        if (N <= i)\\n            return 0;\\n        let buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n            sell = have != NONE ? go(i + 2, NONE) + A[i] - have : 0,\\n            hold = go(i + 1, have);\\n        return Math.max(buy, sell, hold);\\n    };\\n    return go();\\n};\\n```\n```\\nlet maxProfit = (A, m = new Map(), NONE = -1) => {\\n    let N = A.length;\\n    let go = (i = 0, have = NONE) => {\\n        if (N <= i)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n                sell = have != NONE ? go(i + 2, NONE) + A[i] - have : 0,\\n                hold = go(i + 1, have);\\n            m.set(k, Math.max(buy, sell, hold));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet maxProfit = (A, INF = 1001) => {\\n    let N = A.length;\\n    let none = Array(N + 1).fill(0),\\n        have = Array(N + 1).fill(0),\\n        sold = Array(N + 1).fill(0);\\n    have[0] = -INF; // to consider buy for A[0]\\n    for (let i = 1; i <= N; ++i) {\\n        let x = A[i - 1];\\n        none[i] = Math.max(none[i - 1], sold[i - 1]);      // implicit hold when none[i] = none[i - 1]\\n        have[i] = Math.max(have[i - 1], none[i - 1] - x);  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n        sold[i] = have[i - 1] + x;                         // +x because we sell at price x\\n    }\\n    return Math.max(none[N], have[N], sold[N]);\\n};\\n```\n```\\nlet maxProfit = (A, INF = 1001) => {\\n    let N = A.length;\\n    let cur = {\\n        none: 0,\\n        have: -INF, // to consider buy for A[0]\\n        sold: 0,\\n    };\\n    for (let x of A) {\\n        let pre = _.cloneDeep(cur);\\n        cur.none = Math.max(pre.none, pre.sold);      // implicit hold when none[i] = none[i - 1]\\n        cur.have = Math.max(pre.have, pre.none - x);  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n        cur.sold = pre.have + x;                      // +x because we sell at price x\\n    }\\n    return Math.max(cur.none, cur.have, cur.sold);\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], NONE = -1) -> int:\\n        N = len(A)\\n        def go(i = 0, have = NONE):\\n            if N <= i:\\n                return 0\\n            buy  = go(i + 1, A[i]) if have == NONE else 0\\n            sell = go(i + 2, NONE) + A[i] - have if have != NONE else 0\\n            hold = go(i + 1, have)\\n            return max(buy, sell, hold)\\n        return go()\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], NONE = -1) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0, have = NONE):\\n            if N <= i:\\n                return 0\\n            buy  = go(i + 1, A[i]) if have == NONE else 0\\n            sell = go(i + 2, NONE) + A[i] - have if have != NONE else 0\\n            hold = go(i + 1, have)\\n            return max(buy, sell, hold)\\n        return go()\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], INF = 1001) -> int:\\n        N = len(A)\\n        none = [0] * (N + 1)\\n        have = [0] * (N + 1)\\n        sold = [0] * (N + 1)\\n        have[0] = -INF  # to consider buy A[0]\\n        for i in range(1, N + 1):\\n            x = A[i - 1]\\n            none[i] = max(none[i - 1], sold[i - 1])      # implicit hold when none[i] = none[i - 1]\\n            have[i] = max(have[i - 1], none[i - 1] - x)  # implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            sold[i] = have[i - 1] + x                    # +x because we sell at price x\\n        return max(none[N], have[N], sold[N])\\n```\n```\\nclass State:\\n    def __init__(self, none = 0, have = 0, sold = 0):\\n        self.none = none\\n        self.have = have\\n        self.sold = sold\\nclass Solution:\\n    def maxProfit(self, A: List[int], INF = 1001) -> int:\\n        N = len(A)\\n        cur = State(0, -INF, 0)  # have = -INF to consider buy A[0]\\n        for x in A:\\n            pre = deepcopy(cur)\\n            cur.none = max(pre.none, pre.sold)      # implicit hold when none[i] = none[i - 1]\\n            cur.have = max(pre.have, pre.none - x)  # implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            cur.sold = pre.have + x                 # +x because we sell at price x\\n        return max(cur.none, cur.have, cur.sold)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int maxProfit(VI& A, int NONE = -1) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto have) {\\n            if (N <= i)\\n                return 0;\\n            auto buy = have == NONE ? go(i + 1, A[i]) : 0,\\n                 sell = have != NONE ? go(i + 2, NONE) + A[i] - have : 0,\\n                 keep = go(i + 1, have);\\n            return max({ buy, sell, keep });\\n        };\\n        return go(0, NONE);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maxProfit(VI& A, Map m = {}, int NONE = -1) {\\n        int N = A.size();\\n        auto key = [](auto i, auto k) {\\n            stringstream ss; ss << i << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (N <= i)\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto buy = have == NONE ? go(i + 1, A[i]) : 0,\\n                     sell = have != NONE ? go(i + 2, NONE) + A[i] - have : 0,\\n                     keep = go(i + 1, have);\\n                m[k] = max({ buy, sell, keep });\\n            }\\n            return m[k];\\n        };\\n        return go(0, NONE);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int INF = 1001) {\\n        int N = A.size();\\n        VI none(N + 1),\\n           have(N + 1),\\n           sold(N + 1);\\n        have[0] = -INF; // to consider buying A[0]\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            auto x = A[i - 1];\\n            none[i] = max(none[i - 1], sold[i - 1]);      // implicit hold when none[i] = none[i - 1]\\n            have[i] = max(have[i - 1], none[i - 1] - x);  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            sold[i] = x + have[i - 1];                    // +x because we sell at price x\\n        }\\n        return max({ none[N], have[N], sold[N] });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    struct State {\\n        int none, have, sold;\\n    };\\n    int maxProfit(VI& A, State cur = {}, int INF = 1001) {\\n        cur.have = -INF; // to consider buying A[0]\\n        int N = A.size();\\n        for (auto x: A) {\\n            State pre{ cur };\\n            cur.none = max(cur.none, pre.sold);      // implicit hold when none[i] = none[i - 1]\\n            cur.have = max(cur.have, pre.none - x);  // implicit hold when have[i] = have[i - 1], -x because we buy at price x\\n            cur.sold = x + pre.have;                 // +x because we sell at price x\\n        }\\n        return max({ cur.none, cur.have, cur.sold });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531184,
                "title": "python-dp-recursion-memoization",
                "content": "Here, everyday, we have 3 main choices: sell, buy or cooldown.\\nBut here, if we sell today, then tomorrow has to be a cooldown day, and also we cannot sell if we havent bought.\\nSo, I\\'m using a boolean \\'bought\\' to keep track of my buy/sell actions.\\nHere, it is absolutely essential to keep the memoization key as (pos, bought) because the choice we make at any position is dependant on our previous buy/sell choice. \\nFor example, we could arrive at index 3 in the prices array after either a buy or sell action, and the choices we make to proceed are different for buy and sell actions.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        N = len(prices)\\n        memo = {}\\n        \\n        def memoize(pos=0, bought = False):\\n            \\n            if pos >= N:        # If we go out of bounds, return 0 because we can\\'t have any profit.\\n                return 0\\n            \\n            if (pos, bought) in memo:\\n                return memo[(pos,bought)]     \\n\\t\\t\\t\\n\\t\\t\\t\\n            if bought:\\n                sell = memoize(pos+2, not bought) + prices[pos]  \\n                cool = memoize(pos+1, bought)\\n                memo[(pos, bought)] = max(sell, cool)\\n\\t\\t\\t\\t# If we have already bought, then our choices are sell or cooldown. \\n            \\n            else:\\n                buy = memoize(pos+1, not bought) - prices[pos]\\n                cool = memoize(pos+1, bought)\\n                memo[(pos, bought)] = max(buy, cool)\\n\\t\\t\\t\\t# if we haven\\'t bought, then our choices are buy or cooldown.\\n            \\n            return memo[(pos,bought)]\\n        \\n        return memoize()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        N = len(prices)\\n        memo = {}\\n        \\n        def memoize(pos=0, bought = False):\\n            \\n            if pos >= N:        # If we go out of bounds, return 0 because we can\\'t have any profit.\\n                return 0\\n            \\n            if (pos, bought) in memo:\\n                return memo[(pos,bought)]     \\n\\t\\t\\t\\n\\t\\t\\t\\n            if bought:\\n                sell = memoize(pos+2, not bought) + prices[pos]  \\n                cool = memoize(pos+1, bought)\\n                memo[(pos, bought)] = max(sell, cool)\\n\\t\\t\\t\\t# If we have already bought, then our choices are sell or cooldown. \\n            \\n            else:\\n                buy = memoize(pos+1, not bought) - prices[pos]\\n                cool = memoize(pos+1, bought)\\n                memo[(pos, bought)] = max(buy, cool)\\n\\t\\t\\t\\t# if we haven\\'t bought, then our choices are buy or cooldown.\\n            \\n            return memo[(pos,bought)]\\n        \\n        return memoize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527568,
                "title": "detailed-explanation-faster-than-100-c-simple-fast",
                "content": ">Let `dp[i]` is the maximum profit you can get from `i`th day to the last day ( i.e in the subarray `{i,i+1,..n-1}`) \\n\\n        \\n **SIMPLE AND DETAILED EXPLANATION OF THE LOGIC BEHIND THE IMPLEMENTATION**\\n        \\nThe main idea behind this is that, when you are at `i`th day, since you want to find the maximum profit you can make from the subarray `{i,i+1,..n-1}`, so there are two possibilites in this, \\n>In calculation of `dp[i]` it is not necessary that I buy the stock on `i`th day. There are two possibilities\\n>1) you don\\'t buy the stock on the ith day\\n>2) You buy the stock on the ith day\\n\\nFor the 1st case, `dp[i]` will be equal to `dp[i+1]`.\\n\\nFor the 2nd case, when you buy the stock on `i`th day, you will sell it on some `j`th day, then the profit you will make is `prices[j] + dp[j+2] - prices[i]`. \\n    \\nBut we don\\'t quite already know on which day to sell it, so for every `j>=i` we want to know maximum of `prices[j] + dp[j+2]`.\\n    \\nSo when you are at `i`, instead of finding this value for every `j`, you could maintain this value in one variable called `maxi` then for the 2nd case, the answer will be `maxi-prices[i]`.\\n    \\n**So out of the two cases, we want the maximum one, so dp[i]=max(dp[i+1], maxi-prices[i])**\\nFinally `dp[0]` is our answer\\n\\n```\\nint n=prices.size();\\nint dp[n];    \\ndp[n-1]=0; // There is only one possibility. you buy it and sell it on the same day\\nint maxi=prices[n-1]; // maxi stores the maximum of prices[j]+dp[j+2] for all j>=i\\nfor(int i=n-2;i>=0;i--)\\n{\\n\\tmaxi=max(maxi,prices[i]+(i+2<n? dp[i+2]: 0));\\n\\tdp[i]=max(dp[i+1], maxi-prices[i]);\\n}\\nreturn dp[0];\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint n=prices.size();\\nint dp[n];    \\ndp[n-1]=0; // There is only one possibility. you buy it and sell it on the same day\\nint maxi=prices[n-1]; // maxi stores the maximum of prices[j]+dp[j+2] for all j>=i\\nfor(int i=n-2;i>=0;i--)\\n{\\n\\tmaxi=max(maxi,prices[i]+(i+2<n? dp[i+2]: 0));\\n\\tdp[i]=max(dp[i+1], maxi-prices[i]);\\n}\\nreturn dp[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1515698,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profitOne = 0, profitTwo = 0;\\n        for(int i=1; i<prices.length; i++){\\n            int temp = profitOne;\\n            profitOne = Math.max(profitOne + prices[i] - prices[i-1] , profitTwo);\\n            profitTwo = Math.max(temp , profitTwo);\\n        }\\n        return Math.max(profitOne, profitTwo);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profitOne = 0, profitTwo = 0;\\n        for(int i=1; i<prices.length; i++){\\n            int temp = profitOne;\\n            profitOne = Math.max(profitOne + prices[i] - prices[i-1] , profitTwo);\\n            profitTwo = Math.max(temp , profitTwo);\\n        }\\n        return Math.max(profitOne, profitTwo);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762934,
                "title": "easy-to-understand-java-recursive-accepted-solution",
                "content": "**Ituition:** Start at index 0 and consider all options of buying at respective position and store max profit\\nalso consider skipping to buy at pos 0 and continuing  with next position. \\n\\n\\tpublic int maxProfit(int[] prices) {\\n\\t\\t\\tif(prices.length<2){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n        \\n        int[] dp = new int[prices.length];\\n        Arrays.fill(dp, -1);\\n        return getMaxProfit(prices, 0, dp);\\n    }\\n    \\n    private int getMaxProfit(int[] prices, int pos, int[] dp){\\n        if(pos>=prices.length){\\n            return 0;\\n        }\\n        \\n        //if already calculated, just return\\n        if(dp[pos]!=-1){\\n            return dp[pos];\\n        }\\n        \\n        int maxProfit = 0;\\n        for(int i=pos+1;i<prices.length;i++){\\n            int diff = prices[i]-prices[pos];\\n            if(diff>0){\\n                //Selling the stock bought at pos\\n                int profit = getMaxProfit(prices, i+2, dp)+diff;\\n                maxProfit=Math.max(maxProfit, profit);\\n            }\\n        }\\n        \\n        //skip buying stock at pos\\n        int profit = getMaxProfit(prices, pos+1, dp);\\n        maxProfit=Math.max(maxProfit, profit);\\n        dp[pos]=maxProfit;\\n        \\n        return maxProfit;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "**Ituition:** Start at index 0 and consider all options of buying at respective position and store max profit\\nalso consider skipping to buy at pos 0 and continuing  with next position. \\n\\n\\tpublic int maxProfit(int[] prices) {\\n\\t\\t\\tif(prices.length<2){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n        \\n        int[] dp = new int[prices.length];\\n        Arrays.fill(dp, -1);\\n        return getMaxProfit(prices, 0, dp);\\n    }\\n    \\n    private int getMaxProfit(int[] prices, int pos, int[] dp){\\n        if(pos>=prices.length){\\n            return 0;\\n        }\\n        \\n        //if already calculated, just return\\n        if(dp[pos]!=-1){\\n            return dp[pos];\\n        }\\n        \\n        int maxProfit = 0;\\n        for(int i=pos+1;i<prices.length;i++){\\n            int diff = prices[i]-prices[pos];\\n            if(diff>0){\\n                //Selling the stock bought at pos\\n                int profit = getMaxProfit(prices, i+2, dp)+diff;\\n                maxProfit=Math.max(maxProfit, profit);\\n            }\\n        }\\n        \\n        //skip buying stock at pos\\n        int profit = getMaxProfit(prices, pos+1, dp);\\n        maxProfit=Math.max(maxProfit, profit);\\n        dp[pos]=maxProfit;\\n        \\n        return maxProfit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 762858,
                "title": "python-dp-solution-explained-o-n-time-o-1-space",
                "content": "The key is to realize that there are three possible states at the start of each day.\\n\\n1. You have stock.\\n2. You have no stock, but did not sell the previous day\\n3. You have no stock, because you sold it the previous day.\\n\\nBy recording the maximum profit in each state at the end of each day, you can find the max profits for the next day. At the end of the day: \\n\\n1. If you have stock, then either you kept the stock you already have or you bought today.\\n```\\nmax_w_stock = max(max_w_stock, max_no_stock_no_sell - price)\\n```\\n2. If you have no stock and you didn\\'t sell today, then either you sold it the previous day or earlier.\\n```\\nmax_no_stock_no_sell = max(max_w_sell, max_no_stock_no_sell)\\n```\\n3. If you have no stock because you sold it today, then you had stock and sold it today.\\n```\\nmax_w_sell = max_w_stock + price\\n```\\nThen at the end of the list of prices you return the maximum of selling on the last day or selling earlier (you would never end with stock since you can just sell it to increase your profit). \\n\\nThe time complexity is O(n) since you loop through the list of prices only once, and do constant work in each loop.\\nThe space complexity is O(1) since you only need to keep track of three variables.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int: \\n        if not prices:\\n            return 0\\n        \\n        max_w_stock = -prices[0]\\n        max_no_stock_no_sell = max_w_sell = 0\\n        \\n        for p in prices:\\n            max_w_stock, max_no_stock_no_sell, max_w_sell = \\\\\\n                (max(max_w_stock, max_no_stock_no_sell - p), \\n                 max(max_no_stock_no_sell, max_w_sell),\\n                 max_w_stock + p)\\n            \\n        return max(max_no_stock_no_sell, max_w_sell)\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nmax_w_stock = max(max_w_stock, max_no_stock_no_sell - price)\\n```\n```\\nmax_no_stock_no_sell = max(max_w_sell, max_no_stock_no_sell)\\n```\n```\\nmax_w_sell = max_w_stock + price\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int: \\n        if not prices:\\n            return 0\\n        \\n        max_w_stock = -prices[0]\\n        max_no_stock_no_sell = max_w_sell = 0\\n        \\n        for p in prices:\\n            max_w_stock, max_no_stock_no_sell, max_w_sell = \\\\\\n                (max(max_w_stock, max_no_stock_no_sell - p), \\n                 max(max_no_stock_no_sell, max_w_sell),\\n                 max_w_stock + p)\\n            \\n        return max(max_no_stock_no_sell, max_w_sell)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 762801,
                "title": "python3-dp",
                "content": "The \"buy low & sell high\"\" approach could be used to solve all problems in this series. \\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/695515/Python3-two-approaches)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = inf, 0\\n        for x in prices:\\n            buy = min(buy, x)\\n            sell = max(sell, x - buy)\\n        return sell\\n```\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/565654/Python3-greedy-and-dp)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = inf, 0\\n        for x in prices: \\n            buy = min(buy, x - sell)\\n            sell = max(sell, x - buy)\\n        return sell\\n```\\n[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/702602/Python3-two-approaches)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/702612/Python3-two-approaches)\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\\n        buy, sell = [inf]*k, [0]*k\\n        for x in prices:\\n            for i in range(k):\\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[-1] if k and prices else 0\\n```\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/762801/Python3-dp)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, cooldown, sell = inf, 0, 0\\n        for x in prices: \\n            buy = min(buy, x - cooldown)\\n            cooldown = sell \\n            sell = max(sell, x - buy)\\n        return sell\\n```\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/1532323/Python3-dp)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        buy, sell = inf, 0\\n        for x in prices: \\n            buy = min(buy, x - sell)\\n            sell = max(sell, x - buy - fee)\\n        return sell \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = inf, 0\\n        for x in prices:\\n            buy = min(buy, x)\\n            sell = max(sell, x - buy)\\n        return sell\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = inf, 0\\n        for x in prices: \\n            buy = min(buy, x - sell)\\n            sell = max(sell, x - buy)\\n        return sell\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\\n        buy, sell = [inf]*k, [0]*k\\n        for x in prices:\\n            for i in range(k):\\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[-1] if k and prices else 0\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, cooldown, sell = inf, 0, 0\\n        for x in prices: \\n            buy = min(buy, x - cooldown)\\n            cooldown = sell \\n            sell = max(sell, x - buy)\\n        return sell\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        buy, sell = inf, 0\\n        for x in prices: \\n            buy = min(buy, x - sell)\\n            sell = max(sell, x - buy - fee)\\n        return sell \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762314,
                "title": "java-recursive-memoization",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n      int[][] memo = new int[2][prices.length];  \\n      return helper(prices , 0 , 0 , memo);  \\n    }\\n    \\n    \\n    private int helper(int[]prices, int index, int flag , int[][]memo){\\n        \\n        if(index >= prices.length)return 0;\\n        \\n        if(memo[flag][index] != 0){\\n            return memo[flag][index];\\n        }\\n        \\n         int profit = 0 , buy = 0 , noBuy = 0 , sell = 0 , noSell = 0;\\n        \\n        if(flag == 0){\\n             buy = helper(prices , index + 1 , 1 , memo) - prices[index];\\n             noBuy = helper(prices , index + 1 , 0 , memo);\\n        }else{\\n             sell = helper(prices , index + 2 , 0 , memo) + prices[index];\\n             noSell = helper(prices , index + 1 , 1 , memo);\\n        }\\n        profit = Math.max(Math.max(buy,noBuy),Math.max(sell,noSell));\\n        memo[flag][index] = profit;\\n       return profit; \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n      int[][] memo = new int[2][prices.length];  \\n      return helper(prices , 0 , 0 , memo);  \\n    }\\n    \\n    \\n    private int helper(int[]prices, int index, int flag , int[][]memo){\\n        \\n        if(index >= prices.length)return 0;\\n        \\n        if(memo[flag][index] != 0){\\n            return memo[flag][index];\\n        }\\n        \\n         int profit = 0 , buy = 0 , noBuy = 0 , sell = 0 , noSell = 0;\\n        \\n        if(flag == 0){\\n             buy = helper(prices , index + 1 , 1 , memo) - prices[index];\\n             noBuy = helper(prices , index + 1 , 0 , memo);\\n        }else{\\n             sell = helper(prices , index + 2 , 0 , memo) + prices[index];\\n             noSell = helper(prices , index + 1 , 1 , memo);\\n        }\\n        profit = Math.max(Math.max(buy,noBuy),Math.max(sell,noSell));\\n        memo[flag][index] = profit;\\n       return profit; \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720091,
                "title": "python3-dp-solution-best-time-to-buy-and-sell-stock-with-cooldown",
                "content": "Inspired by https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/\\n\\nEffectively a translation of Case V in https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/most-consistent-ways-of-dealing-with-the-series-of-stock-problems\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        prev_cash, cash, hold = 0, 0, float(\\'-inf\\')\\n        for i in range(len(prices)):\\n            prev_cash, cash, hold = cash, max(cash, hold + prices[i]), max(hold, prev_cash - prices[i])\\n        return cash\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        prev_cash, cash, hold = 0, 0, float(\\'-inf\\')\\n        for i in range(len(prices)):\\n            prev_cash, cash, hold = cash, max(cash, hold + prices[i]), max(hold, prev_cash - prices[i])\\n        return cash\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684871,
                "title": "cpp-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(),i;\\n        if(n < 2) return 0;\\n        //dp[i][0] --> we have zero stock in hand (cases: (we dont buy today and we have sell all) or (we sell today what we have bought))\\n        //dp[i][1] --> we have one stock in hand (cases: (we keep what we had on i-1) or (we buy today with amount we had on i-2 th day because of cool down one day gap(i-1)))\\n        vector<vector<int>> dp(n,vector<int>(2,0));\\n        dp[0][0] = 0; dp[0][1] = -prices[0];\\n        dp[1][0] = max(0,dp[0][1]+prices[1]); dp[1][1] = max(dp[0][1],-prices[1]);\\n        for(i = 2; i < n; i++){\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n            //max of not buying today or selling the previous one today\\n            dp[i][1] = max(dp[i-2][0]-prices[i], dp[i-1][1]);\\n            //buy today making yesterday a cooldown period or keep the one bought yesterday\\n        }\\n        \\n        return max(dp[n-1][0], dp[n-1][1]);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(),i;\\n        if(n < 2) return 0;\\n        //dp[i][0] --> we have zero stock in hand (cases: (we dont buy today and we have sell all) or (we sell today what we have bought))\\n        //dp[i][1] --> we have one stock in hand (cases: (we keep what we had on i-1) or (we buy today with amount we had on i-2 th day because of cool down one day gap(i-1)))\\n        vector<vector<int>> dp(n,vector<int>(2,0));\\n        dp[0][0] = 0; dp[0][1] = -prices[0];\\n        dp[1][0] = max(0,dp[0][1]+prices[1]); dp[1][1] = max(dp[0][1],-prices[1]);\\n        for(i = 2; i < n; i++){\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n            //max of not buying today or selling the previous one today\\n            dp[i][1] = max(dp[i-2][0]-prices[i], dp[i-1][1]);\\n            //buy today making yesterday a cooldown period or keep the one bought yesterday\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 666482,
                "title": "dp-solution-with-detailed-description-and-time-complexity-0-n-constant-space",
                "content": "Please refer this video for detailed description - \\n \\n [https://youtu.be/w6xk5Po-DX0 ](http://)\\n \\n Time complexity - O(n)\\nSpace Complexity - 0(n) \\n**Here we are using 2D array (row = no. of elements in given array i.e n , column = 2 ) . So we can treat space complexity as O(n).**. \\n\\nWe can solve this in constant space by using variables to store last days DP values.\\n\\n /*\\ncase 1: We have a stock on day i, dp[i][1] max of the below:\\n- I bought it today\\n    dp[i-2][0] - prices[i]\\n- I am carry forwarding\\n    dp[i-1][1]\\n\\ncase 2: We have no stock on day i, dp[i][0] max of the below:\\n- I sold it today\\n    dp[i-1][1] + prices[i]\\n- I am carry forwarding, doing nothing\\n    dp[i-1][0]\\n*/\\n \\n `\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int len = prices.length;\\n        if(len <= 1)\\n            return 0;    \\n        if(len == 2 && prices[1] > prices[0])\\n            return prices[1]-prices[0];\\n        else if(len == 2 && prices[0] > prices[1])\\n            return 0;\\n        \\n        int[][] dp = new int[len][2];\\n        \\n        dp[0][0] = 0;\\n        dp[0][1] = -prices[0];\\n        dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]);\\n        dp[1][1] = Math.max(dp[0][1], dp[0][0]-prices[1]);\\n        \\n        for(int i=2; i<len; i++){\\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);\\n        }\\n        \\n        return dp[len-1][0];\\n    }\\n}`",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int len = prices.length;\\n        if(len <= 1)\\n            return 0;    \\n        if(len == 2 && prices[1] > prices[0])\\n            return prices[1]-prices[0];\\n        else if(len == 2 && prices[0] > prices[1])\\n            return 0;\\n        \\n        int[][] dp = new int[len][2];\\n        \\n        dp[0][0] = 0;\\n        dp[0][1] = -prices[0];\\n        dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]);\\n        dp[1][1] = Math.max(dp[0][1], dp[0][0]-prices[1]);\\n        \\n        for(int i=2; i<len; i++){\\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 516864,
                "title": "c-finite-state-solution-faster-than-100-in-time-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\\n    \\n    There are 3 states, each state actually also tells about the profit for that state:\\n    \\n    (Cooldown)-----buy------->(Bought)\\n    ^                            |        \\n    |                            sell\\n    --------cooldown----(Sold)<--|\\n    \\n            OR\\n    (Bought)-----sell------->(Sold)\\n    ^                            |        \\n    |                            cooldown\\n    --------buy----(Cooldown)<--|\\n    \\n    Also for states Cooldown and Bought, if we can decide not to do anything and be on that state,\\n    but for state Sold, we need to go to Cooldown state.\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() <= 0)\\n            return 0; \\n        // Since nothing is done intially\\n        int cooldown = 0, cooldown_prev = 0;\\n        // Buying first item gives us no profit value initially\\n        int bought = -1 * prices[0], bought_prev = -prices[0];\\n        // Buying and selling on the first day gives profit of 0\\n        int sold = 0, sold_prev = 0;        \\n        \\n        for(int i = 1; i < prices.size(); i++) {\\n            // State 1\\n            bought = max(bought_prev, cooldown_prev - prices[i]);\\n            // State 2\\n            sold = bought_prev + prices[i];\\n            // State 3\\n            cooldown = max(cooldown_prev, sold_prev);\\n            \\n            // update previous values\\n            bought_prev = bought, sold_prev = sold, cooldown_prev = cooldown;\\n        }\\n        \\n        return max(cooldown, sold);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\\n    \\n    There are 3 states, each state actually also tells about the profit for that state:\\n    \\n    (Cooldown)-----buy------->(Bought)\\n    ^                            |        \\n    |                            sell\\n    --------cooldown----(Sold)<--|\\n    \\n            OR\\n    (Bought)-----sell------->(Sold)\\n    ^                            |        \\n    |                            cooldown\\n    --------buy----(Cooldown)<--|\\n    \\n    Also for states Cooldown and Bought, if we can decide not to do anything and be on that state,\\n    but for state Sold, we need to go to Cooldown state.\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() <= 0)\\n            return 0; \\n        // Since nothing is done intially\\n        int cooldown = 0, cooldown_prev = 0;\\n        // Buying first item gives us no profit value initially\\n        int bought = -1 * prices[0], bought_prev = -prices[0];\\n        // Buying and selling on the first day gives profit of 0\\n        int sold = 0, sold_prev = 0;        \\n        \\n        for(int i = 1; i < prices.size(); i++) {\\n            // State 1\\n            bought = max(bought_prev, cooldown_prev - prices[i]);\\n            // State 2\\n            sold = bought_prev + prices[i];\\n            // State 3\\n            cooldown = max(cooldown_prev, sold_prev);\\n            \\n            // update previous values\\n            bought_prev = bought, sold_prev = sold, cooldown_prev = cooldown;\\n        }\\n        \\n        return max(cooldown, sold);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480960,
                "title": "my-dp-solution-in-python-with-detailed-explanation",
                "content": "My implementaiton that beats 98% accepted submissions in python with detailed explanation\\n\\n```python\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n\\t\\t\\n\\t\\t# sell[i]: max profit achievable if the transaction on day i is sell\\n\\t\\t# buy[i]: max profit achievable if the transaction on day i is buy\\n\\t\\t# cool[i]: max profit achievable if the transaction on day i is cooldown\\n        sell = [0 for _ in range(len(prices))]\\n        buy  = [0 for _ in range(len(prices))]\\n        cool = [0 for _ in range(len(prices))]\\n        \\n        for i in range(len(prices)):\\n\\t\\t   # if the transaction is `sell`, then the transaction on the previous day must be buy, \\n\\t\\t   # so take the max profit on previous day (from buy array) and plus the price of current day. \\n\\t\\t   # Note that buy[i-1] already took into account the cost you have to pay on day i-1, so the price\\n\\t\\t   # on day i will be the new profit\\n            sell[i] = buy[i-1] + prices[i] if i > 0 else \\n\\t\\t\\t\\n\\t\\t\\t# if the transaction is buy, then it can keep the buy state from previous day (i.e., buy[i-1])\\n\\t\\t\\t# or the previous day must be a cool down day, then take the max profit from the two values\\n\\t\\t\\t# note that the previous day cannot be a sell day\\n            buy[i]  = max(buy[i-1], cool[i-1]-prices[i]) if i > 0 else -prices[i]\\n\\t\\t\\t\\n\\t\\t\\t# if the transaction is cooldown, then nothing can be down today, then get the max profit you can get from \\n\\t\\t\\t# the previous day\\n            cool[i] = max(max(cool[i-1], buy[i-1]), sell[i-1]) if i > 0 else 0\\n\\t\\t\\t\\n\\t\\t\\t# update the max profit\\n            max_profit = max(max(sell[i], buy[i]), cool[i])\\n        return max_profit\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n\\t\\t\\n\\t\\t# sell[i]: max profit achievable if the transaction on day i is sell\\n\\t\\t# buy[i]: max profit achievable if the transaction on day i is buy\\n\\t\\t# cool[i]: max profit achievable if the transaction on day i is cooldown\\n        sell = [0 for _ in range(len(prices))]\\n        buy  = [0 for _ in range(len(prices))]\\n        cool = [0 for _ in range(len(prices))]\\n        \\n        for i in range(len(prices)):\\n\\t\\t   # if the transaction is `sell`, then the transaction on the previous day must be buy, \\n\\t\\t   # so take the max profit on previous day (from buy array) and plus the price of current day. \\n\\t\\t   # Note that buy[i-1] already took into account the cost you have to pay on day i-1, so the price\\n\\t\\t   # on day i will be the new profit\\n            sell[i] = buy[i-1] + prices[i] if i > 0 else \\n\\t\\t\\t\\n\\t\\t\\t# if the transaction is buy, then it can keep the buy state from previous day (i.e., buy[i-1])\\n\\t\\t\\t# or the previous day must be a cool down day, then take the max profit from the two values\\n\\t\\t\\t# note that the previous day cannot be a sell day\\n            buy[i]  = max(buy[i-1], cool[i-1]-prices[i]) if i > 0 else -prices[i]\\n\\t\\t\\t\\n\\t\\t\\t# if the transaction is cooldown, then nothing can be down today, then get the max profit you can get from \\n\\t\\t\\t# the previous day\\n            cool[i] = max(max(cool[i-1], buy[i-1]), sell[i-1]) if i > 0 else 0\\n\\t\\t\\t\\n\\t\\t\\t# update the max profit\\n            max_profit = max(max(sell[i], buy[i]), cool[i])\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456719,
                "title": "sharing-my-thought-process-thanks-to-npvinhphat-s-state-machine-thinking-solution",
                "content": "Note: Idea is taken from [npvinhphat\\'s solution](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking)). That solution requires **O(n)** space. I\\'m just sharing my thought on modifying it to **O(1)**.\\n\\n![image](https://assets.leetcode.com/users/prasunkantidey/image_1576880722.png)\\n\\nThe key idea is shown in the figure. We have 3 states for this problem.\\n\\n**s0:** We are resting. At this state, we can either continue to rest or buy (we will move to **s1**).\\n**s1:** We already bought a stock, now waiting (resting) for the suitable price to sell. If we sell, we *should* go back to `s0`, the resting state. But, this is can\\'t happen. Why?\\n- We have to make sure we are not buying another stock immediately after we just sold one.\\n- But if we go back to `s0` directly, we can either buy or rest. If we rest, that\\'s good, but we can buy, right? To prevent this, we need another state.\\n\\n**s2:** This is just a (temp) state. Sole purpose of this state is to go to state `s0` with one rest.\\n\\nNow, the values of these states in each iteration of prices:\\n`s0`: either *previous s0* or *value of s2*, which ever is higher. `max(s0, s2`)\\n`s1`: either *previous s1* or *previous state\\'s s0 - buying price*. `max(s1, previous state\\'s s0 - price)`\\n`s2`: *s1 + selling price*. `s1 + price`\\n\\n**Note:** we need `s0` while calculating `s1`, but `s0` is already changed. So, we keep a `previous_state_s0` to hold *previous state\\'s* `s0` value while we update the *current* `s0` value.\\n\\nFor base case,\\n`s0 = 0`\\n`s1 = - prices[0]`. # This is because, we came at this state after buying the stock.\\n`s2 = 0`\\n\\nFinally, we return, `max(s0, s2)`. We can either at already resting state after selling the stock (`s0`), or, we just sold the stock (using the last price) and came to the `s2`.\\n\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not prices or len(prices) < 2:\\n            return 0\\n        \\n        s0 = 0\\n        s1 = -prices[0]\\n        s2 = 0\\n        \\n        for price in prices:\\n            previous_state_s0 = s0\\n            s0 = max(s0, s2)\\n            s1 = max(s1, previous_state_s0 - price)\\n            s2 = s1 + price\\n        \\n        return max(s0, s2)\\n\\nHope these help.",
                "solutionTags": [],
                "code": "Note: Idea is taken from [npvinhphat\\'s solution](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking)). That solution requires **O(n)** space. I\\'m just sharing my thought on modifying it to **O(1)**.\\n\\n![image](https://assets.leetcode.com/users/prasunkantidey/image_1576880722.png)\\n\\nThe key idea is shown in the figure. We have 3 states for this problem.\\n\\n**s0:** We are resting. At this state, we can either continue to rest or buy (we will move to **s1**).\\n**s1:** We already bought a stock, now waiting (resting) for the suitable price to sell. If we sell, we *should* go back to `s0`, the resting state. But, this is can\\'t happen. Why?\\n- We have to make sure we are not buying another stock immediately after we just sold one.\\n- But if we go back to `s0` directly, we can either buy or rest. If we rest, that\\'s good, but we can buy, right? To prevent this, we need another state.\\n\\n**s2:** This is just a (temp) state. Sole purpose of this state is to go to state `s0` with one rest.\\n\\nNow, the values of these states in each iteration of prices:\\n`s0`: either *previous s0* or *value of s2*, which ever is higher. `max(s0, s2`)\\n`s1`: either *previous s1* or *previous state\\'s s0 - buying price*. `max(s1, previous state\\'s s0 - price)`\\n`s2`: *s1 + selling price*. `s1 + price`\\n\\n**Note:** we need `s0` while calculating `s1`, but `s0` is already changed. So, we keep a `previous_state_s0` to hold *previous state\\'s* `s0` value while we update the *current* `s0` value.\\n\\nFor base case,\\n`s0 = 0`\\n`s1 = - prices[0]`. # This is because, we came at this state after buying the stock.\\n`s2 = 0`\\n\\nFinally, we return, `max(s0, s2)`. We can either at already resting state after selling the stock (`s0`), or, we just sold the stock (using the last price) and came to the `s2`.\\n\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not prices or len(prices) < 2:\\n            return 0\\n        \\n        s0 = 0\\n        s1 = -prices[0]\\n        s2 = 0\\n        \\n        for price in prices:\\n            previous_state_s0 = s0\\n            s0 = max(s0, s2)\\n            s1 = max(s1, previous_state_s0 - price)\\n            s2 = s1 + price\\n        \\n        return max(s0, s2)\\n\\nHope these help.",
                "codeTag": "Python3"
            },
            {
                "id": 261656,
                "title": "dfs-memo",
                "content": "```\\nclass Solution {\\n    int [][] memo;\\n    public int maxProfit(int[] prices) {\\n        memo = new int[prices.length][2];\\n        for (int []m : memo) {\\n            Arrays.fill(m, -1);\\n        }\\n        int r = 0;\\n        for (int i=0; i<prices.length; i++) {\\n            r = Math.max(r, dfs(prices, i, false));\\n        }\\n        return r;\\n        \\n    }\\n    \\n    \\n    int dfs(int[] prices, int pos, boolean buy) {\\n        if(pos >= prices.length) {\\n            return 0;\\n        }\\n        int b = buy ? 0 : 1;\\n        if(memo[pos][b] != -1) {\\n            return memo[pos][b];\\n        }\\n        if(buy) {\\n            int sell = dfs(prices, pos + 2, false) + prices[pos];\\n            int notSell = dfs(prices, pos + 1, true);\\n        \\n            memo[pos][b] = Math.max(sell, notSell);\\n        }\\n        else {\\n            int tobuy = dfs(prices, pos +1, true) - prices[pos];\\n            int notBuy = dfs(prices, pos + 1, false);\\n            memo[pos][b] = Math.max(tobuy, notBuy);\\n        }\\n        \\n        return memo[pos][b];\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [][] memo;\\n    public int maxProfit(int[] prices) {\\n        memo = new int[prices.length][2];\\n        for (int []m : memo) {\\n            Arrays.fill(m, -1);\\n        }\\n        int r = 0;\\n        for (int i=0; i<prices.length; i++) {\\n            r = Math.max(r, dfs(prices, i, false));\\n        }\\n        return r;\\n        \\n    }\\n    \\n    \\n    int dfs(int[] prices, int pos, boolean buy) {\\n        if(pos >= prices.length) {\\n            return 0;\\n        }\\n        int b = buy ? 0 : 1;\\n        if(memo[pos][b] != -1) {\\n            return memo[pos][b];\\n        }\\n        if(buy) {\\n            int sell = dfs(prices, pos + 2, false) + prices[pos];\\n            int notSell = dfs(prices, pos + 1, true);\\n        \\n            memo[pos][b] = Math.max(sell, notSell);\\n        }\\n        else {\\n            int tobuy = dfs(prices, pos +1, true) - prices[pos];\\n            int notBuy = dfs(prices, pos + 1, false);\\n            memo[pos][b] = Math.max(tobuy, notBuy);\\n        }\\n        \\n        return memo[pos][b];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75938,
                "title": "python-straight-forward-dp-o-n-time-o-1-space",
                "content": "```\\n    def maxProfit(self, prices):\\n\\n        \"\"\"\\n        # We must rest for a single term before buying. \\n        # Thus maximum obtainable from buying today is the max of:\\n        #   1. Buying (Max obtainable from selling 2 periods ago - stock price at i)\\n        #   2. Not Buying (max from previous)\\n        #\\n        # Therefore:\\n        #   buy[i] = max(sell[i-2]-price, buy[i-1])\\n        #\\n        #\\n        # Selling is straight forward. We either sell or not\\n        # Thus maximum from selling is the max of:\\n        #   1. Selling (Max obtainable from buying a day ago + stock price at i)\\n        #   2. Not Selling (max from previous)\\n        #\\n        # Therefore:\\n        #   sell[i] = max(buy[i-1]+price, sell[i-1])\\n        \\n        \"\"\"\\n        \\n        if len(prices) < 2: return 0\\n        prev_sell, sell, buy = 0, 0, -prices[0] # buy initialized to buying a stock at i=0\\n        for i in range(1, len(prices)): \\n            prev_sell, sell, buy = sell, max(buy+prices[i], sell), max(prev_sell-prices[i], buy) \\n        return max(sell, buy)\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfit(self, prices):\\n\\n        \"\"\"\\n        # We must rest for a single term before buying. \\n        # Thus maximum obtainable from buying today is the max of:\\n        #   1. Buying (Max obtainable from selling 2 periods ago - stock price at i)\\n        #   2. Not Buying (max from previous)\\n        #\\n        # Therefore:\\n        #   buy[i] = max(sell[i-2]-price, buy[i-1])\\n        #\\n        #\\n        # Selling is straight forward. We either sell or not\\n        # Thus maximum from selling is the max of:\\n        #   1. Selling (Max obtainable from buying a day ago + stock price at i)\\n        #   2. Not Selling (max from previous)\\n        #\\n        # Therefore:\\n        #   sell[i] = max(buy[i-1]+price, sell[i-1])\\n        \\n        \"\"\"\\n        \\n        if len(prices) < 2: return 0\\n        prev_sell, sell, buy = 0, 0, -prices[0] # buy initialized to buying a stock at i=0\\n        for i in range(1, len(prices)): \\n            prev_sell, sell, buy = sell, max(buy+prices[i], sell), max(prev_sell-prices[i], buy) \\n        return max(sell, buy)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 75966,
                "title": "o-n-time-o-1-space-java-dp-solution-not-state-machine-very-detailed-explanation",
                "content": "**DP states definition**\\n```sell[i]``` as maximum profit we will obtain at time ```i``` if I force selling at ```price[i]```.\\n```rest[i]``` as maximum profit we will obtain at time ```i``` at which we must compromise on cooldown.\\nNote that we don't have to memorize any ```buy[i]``` states, since we are assuming that we will buy stocks at ```i+1``` moment after cooldown```rest[i]```. \\n\\n**Formula**\\n```\\nsell[i] = max ( sell[i-1] + profit, rest[i-2] + profit, 0 );\\nrest[i] = max ( sell[i-1], rest[i-1]);\\n```\\n**1. Sell**\\nAt moment```i```, profit is defined as ```profit = price[i] - price[i-1]```. \\nMaximum profit force selling at ```i``` is \\n```\\nsell[i] = max ( sell[i-1] + profit, rest[i-2] + profit, 0 );\\n```\\n- Holding stocks and selling them all at moment ```i ```. \\n```sell[i-1] + profit ```\\n- We've already sold off all the shares before moment ```i-2``` and paid off cooldown penalty at ```i-2```. \\nSo that we can purchase at ```price[i-1]``` and sell them at ```price[i] ```. \\n```rest[i-2] + profit```.\\n- We will lose money whatsoever, rollbacking all previous transaction. In this case, it implies that we start a fresh new trade with zero profit.\\n```0```.\\n\\n**2. Rest**\\nAt moment```i```, we're either in cooldown or in rest. So our maximum profit could be obtained by \\n- Selling stocks at ```i-1```. So max profit could be ```sell[i-1]```\\n- Inherited from previous rest moment. Max profit could be   ```rest[i-1]```\\n```\\nrest[i] = max ( sell[i-1], rest[i-1]);\\n```\\n\\nIt takes me hours to tackle this problem, from a brute force recursion solution to ```O(n^2)``` Time ```O(n)``` Space.\\nAfter several optimizations, I finally came up with the code here. Instead of interpreting the buy and sell as state machines, my solution focus more on intuitive bottom-up DP.\\n\\n```O(n)``` Time and ```O(n)``` Space, with ```sell``` and ```rest``` memorizing states\\n```\\npublic class Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length < 2) return 0;\\n        int n = prices.length, max;\\n        int[] sell = new int[n];\\n        int[] rest = new int[n];\\n        \\n        sell[0] = 0;\\n        sell[1] = Math.max(prices[1] - prices[0], 0);\\n        for(int i = 2; i < sell.length; i++){            \\n            int profit = prices[i]-prices[i-1];\\n            sell[i] = Math.max(Math.max( sell[i-1], rest[i-2] ) + profit, 0);\\n            rest[i] = Math.max(sell[i-1], rest[i-1]);\\n        }\\n        return  Math.max(sell[n-1], rest[n-1]);\\n    }\\n}\\n```\\n\\n```O(n)``` Time and ```O(1)``` Space.\\n```\\n    public int maxProfit(int[] prices) {\\n        if(prices.length < 2) return 0;\\n        \\n        for(int i = prices.length-1; i > 0; i--) \\n            prices[i] = prices[i] - prices[i-1];\\n        \\n        int sell = 0, prevSell = Math.max(prices[1], 0), cooldown = 0, prevCooldown = 0;  \\n\\n        for(int i = 2; i < prices.length; i++){            \\n            int close = prices[i];\\n            sell = Math.max( prevSell, prevCooldown) + close;\\n            sell = Math.max( sell, 0);\\n            \\n            prevCooldown = cooldown;\\n            cooldown = Math.max(prevSell, cooldown);\\n            prevSell = sell;\\n        }\\n        return Math.max(prevSell, cooldown);\\n    }\\n```\\n\\n\\n\\n**Below are my very beginning thoughts on this problem. Feel free to skip it if you already understand my idea above.**\\n\\nMy first thought was to try every possible combination of ```rest``` and ```profit``` that sells at ```i``` which take ```O(n^2)``` time. \\n(*Note that ```profit[1 - 2] = price[2] - price[1]```*)\\n```\\nsell[0] = 0; \\nsell[1] = max ( profit[0 - 1], 0);\\nsell[2] = max ( profit[0 - 2], rest[0] + profit[1 - 2]);\\nsell[3] = max ( profit[0 - 3], rest[0] + profit[1 - 3], rest[1] + profit[2 - 3]);\\nsell[4] = max ( profit[0 - 4], rest[0] + profit[1 - 4], rest[1] + profit[2 - 4], rest[2] + profit[3 - 4]);\\n...\\nsell[i] = max ( profit[0 - i], rest[0] + profit[1 - i], rest[1] + profit[2 - i], ..., rest[i-1] + profit[i-1 - i]);\\n```\\nAs you might have observed, there are connections between those ```sell[i]```.\\n\\nLets take ```sell[2]``` and ```sell[3]``` as example,\\n```\\nsell[2] = max ( profit[0 - 2], rest[0] + profit[1 - 2]);\\n```\\n```\\nsell[3] = max ( profit[0 - 3], rest[0] + profit[1 - 3], rest[1] + profit[2 - 3] ) \\n        = max ( profit[0 - 2] + profit[2 - 3], rest[0] + profit[1 - 2] + profit[2 - 3], rest[1] + profit[2 - 3]\\n```\\n- The first two terms in ```sell[3]```: \\n```profit[0 - 2] + profit[2 - 3], rest[0] + profit[1 - 2] + profit[2 - 3]``` can be reduce to \\n```sell[2] + profit[2 - 3]```. \\n- Hence, ```sell[3]``` can be rewritten as: \\n``` max ( sell[2] + profit[2 - 3], rest[1] + profit[2 - 3] ) ```\\n- By factoring ```profit[2 - 3]``` out of the equation we will have:\\n ``` max ( sell[2] , rest[1] ) + profit[2 - 3] );```\\n- Generalizing this pattern: \\n```sell[i] = max ( sell[i-1], rest[i-2] ) + profit[i-1 - i] );```\\n- One more case to consider: In selling cases that will leads to negative profit, for example ```[5, 1] ```, because by definition ```sell[i]``` represent the max profit that force selling at ```i``` moment, maximum profit ```sell[i]``` can only be ```0```.\\n- Adding all cases up:\\n```sell[i] = max ( sell[i-1], rest[i-2] ) + profit[i-1 - i], 0)```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```sell[i]```\n```i```\n```price[i]```\n```rest[i]```\n```i```\n```buy[i]```\n```i+1```\n```rest[i]```\n```\\nsell[i] = max ( sell[i-1] + profit, rest[i-2] + profit, 0 );\\nrest[i] = max ( sell[i-1], rest[i-1]);\\n```\n```i```\n```profit = price[i] - price[i-1]```\n```i```\n```\\nsell[i] = max ( sell[i-1] + profit, rest[i-2] + profit, 0 );\\n```\n```i ```\n```sell[i-1] + profit ```\n```i-2```\n```i-2```\n```price[i-1]```\n```price[i] ```\n```rest[i-2] + profit```\n```0```\n```i```\n```i-1```\n```sell[i-1]```\n```rest[i-1]```\n```\\nrest[i] = max ( sell[i-1], rest[i-1]);\\n```\n```O(n^2)```\n```O(n)```\n```O(n)```\n```O(n)```\n```sell```\n```rest```\n```\\npublic class Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length < 2) return 0;\\n        int n = prices.length, max;\\n        int[] sell = new int[n];\\n        int[] rest = new int[n];\\n        \\n        sell[0] = 0;\\n        sell[1] = Math.max(prices[1] - prices[0], 0);\\n        for(int i = 2; i < sell.length; i++){            \\n            int profit = prices[i]-prices[i-1];\\n            sell[i] = Math.max(Math.max( sell[i-1], rest[i-2] ) + profit, 0);\\n            rest[i] = Math.max(sell[i-1], rest[i-1]);\\n        }\\n        return  Math.max(sell[n-1], rest[n-1]);\\n    }\\n}\\n```\n```O(n)```\n```O(1)```\n```\\n    public int maxProfit(int[] prices) {\\n        if(prices.length < 2) return 0;\\n        \\n        for(int i = prices.length-1; i > 0; i--) \\n            prices[i] = prices[i] - prices[i-1];\\n        \\n        int sell = 0, prevSell = Math.max(prices[1], 0), cooldown = 0, prevCooldown = 0;  \\n\\n        for(int i = 2; i < prices.length; i++){            \\n            int close = prices[i];\\n            sell = Math.max( prevSell, prevCooldown) + close;\\n            sell = Math.max( sell, 0);\\n            \\n            prevCooldown = cooldown;\\n            cooldown = Math.max(prevSell, cooldown);\\n            prevSell = sell;\\n        }\\n        return Math.max(prevSell, cooldown);\\n    }\\n```\n```rest```\n```profit```\n```i```\n```O(n^2)```\n```profit[1 - 2] = price[2] - price[1]```\n```\\nsell[0] = 0; \\nsell[1] = max ( profit[0 - 1], 0);\\nsell[2] = max ( profit[0 - 2], rest[0] + profit[1 - 2]);\\nsell[3] = max ( profit[0 - 3], rest[0] + profit[1 - 3], rest[1] + profit[2 - 3]);\\nsell[4] = max ( profit[0 - 4], rest[0] + profit[1 - 4], rest[1] + profit[2 - 4], rest[2] + profit[3 - 4]);\\n...\\nsell[i] = max ( profit[0 - i], rest[0] + profit[1 - i], rest[1] + profit[2 - i], ..., rest[i-1] + profit[i-1 - i]);\\n```\n```sell[i]```\n```sell[2]```\n```sell[3]```\n```\\nsell[2] = max ( profit[0 - 2], rest[0] + profit[1 - 2]);\\n```\n```\\nsell[3] = max ( profit[0 - 3], rest[0] + profit[1 - 3], rest[1] + profit[2 - 3] ) \\n        = max ( profit[0 - 2] + profit[2 - 3], rest[0] + profit[1 - 2] + profit[2 - 3], rest[1] + profit[2 - 3]\\n```\n```sell[3]```\n```profit[0 - 2] + profit[2 - 3], rest[0] + profit[1 - 2] + profit[2 - 3]```\n```sell[2] + profit[2 - 3]```\n```sell[3]```\n``` max ( sell[2] + profit[2 - 3], rest[1] + profit[2 - 3] ) ```\n```profit[2 - 3]```\n``` max ( sell[2] , rest[1] ) + profit[2 - 3] );```\n```sell[i] = max ( sell[i-1], rest[i-2] ) + profit[i-1 - i] );```\n```[5, 1] ```\n```sell[i]```\n```i```\n```sell[i]```\n```0```\n```sell[i] = max ( sell[i-1], rest[i-2] ) + profit[i-1 - i], 0)```",
                "codeTag": "Java"
            },
            {
                "id": 76006,
                "title": "concise-c-solution",
                "content": "    public class Solution {\\n        public int MaxProfit(int[] prices) {\\n            int[] result = new int[prices.Length];\\n            int[] sell = new int[prices.Length];\\n    \\n            for(int i = 1; i < prices.Length; i++) {\\n                var diff = prices[i] - prices[i-1];\\n                sell[i] = diff + Math.Max(sell[i-1], i > 2 ? result[i-3] : 0);\\n                result[i] = Math.Max(sell[i], result[i-1]);\\n            }\\n                \\n            return result.Length == 0 ? 0 : result[result.Length-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int MaxProfit(int[] prices) {\\n            int[] result = new int[prices.Length];\\n            int[] sell = new int[prices.Length];\\n    \\n            for(int i = 1; i < prices.Length; i++) {\\n                var diff = prices[i] - prices[i-1];\\n                sell[i] = diff + Math.Max(sell[i-1], i > 2 ? result[i-3] : 0);\\n                result[i] = Math.Max(sell[i], result[i-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 75950,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static int maxProfit(int[] prices) {\\n\\t\\tif (prices == null || prices.length == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint len = prices.length;\\n\\t\\tint[] sell = new int[len];\\n\\t\\tint[] coolDown = new int[len];\\n\\t\\tsell[0] = 0;\\n\\t\\tcoolDown[0] = 0;\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tsell[i] = Integer.max(sell[i - 1] + prices[i] - prices[i - 1], coolDown[i - 1]);\\n\\t\\t\\tcoolDown[i] = Integer.max(sell[i - 1], coolDown[i - 1]);\\n\\t\\t}\\n\\t\\treturn Integer.max(sell[len - 1], coolDown[len - 1]);\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static int maxProfit(int[] prices) {\\n\\t\\tif (prices == null || prices.length == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint len = prices.length;\\n\\t\\tint[] sell = new int[len];\\n\\t\\tint[] coolDown = new int[len];\\n\\t\\tsell[0] = 0;\\n\\t\\tcoolDown[0] = 0;\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tsell[i] = Integer.max(sell[i - 1] + prices[i] - prices[i - 1], coolDown[i - 1]);\\n\\t\\t\\tcoolDown[i] = Integer.max(sell[i - 1], coolDown[i - 1]);\\n\\t\\t}\\n\\t\\treturn Integer.max(sell[len - 1], coolDown[len - 1]);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3932192,
                "title": "python-95-30-faster-dp-memoization-tabulation",
                "content": "```\\n#Recursion \\n#Time Complexity: O(2^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def solve(ind,buy):\\n            if ind>=n:\\n                return 0\\n            profit=0\\n            if buy==0: #buy a stock\\n                take=-prices[ind]+solve(ind+1,1) \\n                not_take=0+solve(ind+1,0)\\n                profit=max(take,not_take)\\n            else:\\n                take=prices[ind]+solve(ind+2,0) # +2 for cooldown\\n                not_take=0+solve(ind+1,1)\\n                profit=max(take,not_take)\\n            return profit\\n        n=len(prices)\\n        return solve(0,0)\\n            \\n#Memoization (Top-Down)\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(n*2) + O(n)\\nclass Solution2:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def solve(ind,buy):\\n            if ind>=n:\\n                return 0\\n            if dp[ind][buy]!=-1:\\n                return dp[ind][buy]\\n            profit=0\\n            if buy==0: #buy a stock\\n                take=-prices[ind]+solve(ind+1,1) \\n                not_take=0+solve(ind+1,0)\\n                profit=max(take,not_take)\\n            else:\\n                take=prices[ind]+solve(ind+2,0) # +2 for cooldown\\n                not_take=0+solve(ind+1,1)\\n                profit=max(take,not_take)\\n            dp[ind][buy]=profit\\n            return dp[ind][buy]\\n        n=len(prices)\\n        dp=[[-1,-1] for i in range(n)]\\n        return solve(0,0)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(n*2)\\nclass Solution3:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[0,0] for i in range(n+2)]\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                profit=0\\n                if buy==0: #buy a stock\\n                    take=-prices[ind]+dp[ind+1][1] \\n                    not_take=0+dp[ind+1][0]\\n                    profit=max(take,not_take)\\n                else:\\n                    take=prices[ind]+dp[ind+2][0] # +2 for cooldown\\n                    not_take=0+dp[ind+1][1]\\n                    profit=max(take,not_take)\\n                dp[ind][buy]=profit\\n        return dp[0][0]\\n    \\n#Space Optimization\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        ahead=[0]*2\\n        ahead2=[0]*2\\n        curr=[0]*2\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                profit=0\\n                if buy==0: #buy a stock\\n                    take=-prices[ind]+ahead[1] \\n                    not_take=0+ahead[0]\\n                    profit=max(take,not_take)\\n                else:\\n                    take=prices[ind]+ahead2[0] # +2 for cooldown\\n                    not_take=0+ahead[1]\\n                    profit=max(take,not_take)\\n                curr[buy]=profit\\n            ahead2=ahead[:]\\n            ahead=curr[:]\\n        return curr[0]\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(2^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def solve(ind,buy):\\n            if ind>=n:\\n                return 0\\n            profit=0\\n            if buy==0: #buy a stock\\n                take=-prices[ind]+solve(ind+1,1) \\n                not_take=0+solve(ind+1,0)\\n                profit=max(take,not_take)\\n            else:\\n                take=prices[ind]+solve(ind+2,0) # +2 for cooldown\\n                not_take=0+solve(ind+1,1)\\n                profit=max(take,not_take)\\n            return profit\\n        n=len(prices)\\n        return solve(0,0)\\n            \\n#Memoization (Top-Down)\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(n*2) + O(n)\\nclass Solution2:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def solve(ind,buy):\\n            if ind>=n:\\n                return 0\\n            if dp[ind][buy]!=-1:\\n                return dp[ind][buy]\\n            profit=0\\n            if buy==0: #buy a stock\\n                take=-prices[ind]+solve(ind+1,1) \\n                not_take=0+solve(ind+1,0)\\n                profit=max(take,not_take)\\n            else:\\n                take=prices[ind]+solve(ind+2,0) # +2 for cooldown\\n                not_take=0+solve(ind+1,1)\\n                profit=max(take,not_take)\\n            dp[ind][buy]=profit\\n            return dp[ind][buy]\\n        n=len(prices)\\n        dp=[[-1,-1] for i in range(n)]\\n        return solve(0,0)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(n*2)\\nclass Solution3:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[0,0] for i in range(n+2)]\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                profit=0\\n                if buy==0: #buy a stock\\n                    take=-prices[ind]+dp[ind+1][1] \\n                    not_take=0+dp[ind+1][0]\\n                    profit=max(take,not_take)\\n                else:\\n                    take=prices[ind]+dp[ind+2][0] # +2 for cooldown\\n                    not_take=0+dp[ind+1][1]\\n                    profit=max(take,not_take)\\n                dp[ind][buy]=profit\\n        return dp[0][0]\\n    \\n#Space Optimization\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        ahead=[0]*2\\n        ahead2=[0]*2\\n        curr=[0]*2\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                profit=0\\n                if buy==0: #buy a stock\\n                    take=-prices[ind]+ahead[1] \\n                    not_take=0+ahead[0]\\n                    profit=max(take,not_take)\\n                else:\\n                    take=prices[ind]+ahead2[0] # +2 for cooldown\\n                    not_take=0+ahead[1]\\n                    profit=max(take,not_take)\\n                curr[buy]=profit\\n            ahead2=ahead[:]\\n            ahead=curr[:]\\n        return curr[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667551,
                "title": "c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int k,vector<vector<int>> &dp){\\n        if(i>=n)return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans1 = solve(i+1,n,v,k,dp);\\n        int ans2 = 0;\\n        if(k){\\n            ans2 = -v[i]+solve(i+1,n,v,0,dp);\\n        }else{\\n            ans2 = v[i]+solve(i+2,n,v,1,dp);\\n        }\\n        return dp[i][k] = max(ans1,ans2);\\n    }\\n    int maxProfit(vector<int>& v) {\\n        int n = v.size();\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        int ans =  solve(0,n,v,1,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int k,vector<vector<int>> &dp){\\n        if(i>=n)return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans1 = solve(i+1,n,v,k,dp);\\n        int ans2 = 0;\\n        if(k){\\n            ans2 = -v[i]+solve(i+1,n,v,0,dp);\\n        }else{\\n            ans2 = v[i]+solve(i+2,n,v,1,dp);\\n        }\\n        return dp[i][k] = max(ans1,ans2);\\n    }\\n    int maxProfit(vector<int>& v) {\\n        int n = v.size();\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        int ans =  solve(0,n,v,1,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667549,
                "title": "memoization-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int k,vector<vector<int>> &dp){\\n        if(i>=n)return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans1 = solve(i+1,n,v,k,dp);\\n        int ans2 = 0;\\n        if(k){\\n            ans2 = -v[i]+solve(i+1,n,v,0,dp);\\n        }else{\\n            ans2 = v[i]+solve(i+2,n,v,1,dp);\\n        }\\n        return dp[i][k] = max(ans1,ans2);\\n    }\\n    int maxProfit(vector<int>& v) {\\n        int n = v.size();\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        int ans =  solve(0,n,v,1,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int k,vector<vector<int>> &dp){\\n        if(i>=n)return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans1 = solve(i+1,n,v,k,dp);\\n        int ans2 = 0;\\n        if(k){\\n            ans2 = -v[i]+solve(i+1,n,v,0,dp);\\n        }else{\\n            ans2 = v[i]+solve(i+2,n,v,1,dp);\\n        }\\n        return dp[i][k] = max(ans1,ans2);\\n    }\\n    int maxProfit(vector<int>& v) {\\n        int n = v.size();\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        int ans =  solve(0,n,v,1,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370602,
                "title": "best-o-n-solution",
                "content": "# Approach \\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, vector<vector<int>>& dp, int n) {\\n        if (idx >= n)\\n            return 0;\\n        if (dp[idx][buy] != -1)\\n            return dp[idx][buy];    \\n        if (buy == 1) \\n            return dp[idx][buy] = max (-prices[idx] + solve(idx+1, 0, prices, dp, n), \\n                                       0 + solve(idx+1, 1, prices, dp, n));\\n        return dp[idx][buy] = max (prices[idx] + solve(idx+2, 1, prices, dp, n), \\n                                   0 + solve(idx+1, 0, prices, dp, n));\\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return solve(0, 1, prices, dp, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, vector<vector<int>>& dp, int n) {\\n        if (idx >= n)\\n            return 0;\\n        if (dp[idx][buy] != -1)\\n            return dp[idx][buy];    \\n        if (buy == 1) \\n            return dp[idx][buy] = max (-prices[idx] + solve(idx+1, 0, prices, dp, n), \\n                                       0 + solve(idx+1, 1, prices, dp, n));\\n        return dp[idx][buy] = max (prices[idx] + solve(idx+2, 1, prices, dp, n), \\n                                   0 + solve(idx+1, 0, prices, dp, n));\\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return solve(0, 1, prices, dp, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942156,
                "title": "c-dp-new-easy-and-best-approach",
                "content": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n\\n# Approach\\nMade 4 types of states : Buy, Sell, Cooldown & Break.\\nType 0 - Buy\\n--- When it is buy then in next chance it can be sell or break only.\\n\\nType 1 - Sell\\n--- When it is sell then in next chance it can cooldown only.\\n\\nType 2 - Cooldown\\n--- When it is cooldown then in next chance it can cooldown or buy only.\\n\\nType 3 - Break\\n--- When it is break then in next chance it can sell or break only.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\n    int n;\\n    int dfs(int i, int type, vector<int>& prices){\\n        if(i >= n)\\n            return 0;\\n        \\n        if(dp[i][type] != -1)\\n            return dp[i][type];\\n\\n        if(type == 0)  // Buy\\n            dp[i][type] = max(dfs(i+1, 1, prices), dfs(i+1,3, prices)) - prices[i];\\n        else if(type == 1) // Sell\\n            dp[i][type] = dfs(i+1, 2, prices) + prices[i];\\n        else if(type == 2)  // CoolDown\\n            dp[i][type] = max(dfs(i+1, 0, prices), dfs(i+1, 2, prices));\\n        else                // Break\\n            dp[i][type] = max(dfs(i+1, 1, prices), dfs(i+1, 3, prices));\\n        \\n        return dp[i][type];\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        n = prices.size();\\n        dp = vector<vector<int>>(n, vector<int>(4, -1));\\n\\n        return max(dfs(0, 0, prices), dfs(0, 2, prices));\\n    }\\n};\\n```\\n\\n---\\n\\n\\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\n    int n;\\n    int dfs(int i, int type, vector<int>& prices){\\n        if(i >= n)\\n            return 0;\\n        \\n        if(dp[i][type] != -1)\\n            return dp[i][type];\\n\\n        if(type == 0)  // Buy\\n            dp[i][type] = max(dfs(i+1, 1, prices), dfs(i+1,3, prices)) - prices[i];\\n        else if(type == 1) // Sell\\n            dp[i][type] = dfs(i+1, 2, prices) + prices[i];\\n        else if(type == 2)  // CoolDown\\n            dp[i][type] = max(dfs(i+1, 0, prices), dfs(i+1, 2, prices));\\n        else                // Break\\n            dp[i][type] = max(dfs(i+1, 1, prices), dfs(i+1, 3, prices));\\n        \\n        return dp[i][type];\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        n = prices.size();\\n        dp = vector<vector<int>>(n, vector<int>(4, -1));\\n\\n        return max(dfs(0, 0, prices), dfs(0, 2, prices));\\n    }\\n};\\n```\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941112,
                "title": "easy-c-solution-best-solution",
                "content": "# Intuition\\nDefine buy[i] as the max profit when you buy the stock at day i. sell[i] as the max profit when you sell the stock at day i. Therefore set buy[0] = -prices[0], that if you buy the stock at first day, the profit is -prices[0], also set sell[0] = 0\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        if(prices.size()==1){\\n            return 0;\\n        }\\n        \\n        vector<int>buy(n,0);\\n        vector<int>sell(n,0);\\n        \\n        buy[0]=-prices[0];\\n        sell[0]=0;\\n        buy[1]=max(-prices[0],-prices[1]);\\n        sell[1]=max(0,-prices[0]+prices[1]);\\n        \\n        for(int i=2;i<n;i++)\\n      {\\n        buy[i]=max(buy[i-1],sell[i-2]-prices[i]);\\n        sell[i]=max(sell[i-1],buy[i-1]+prices[i]);\\n      }\\n        return sell[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        if(prices.size()==1){\\n            return 0;\\n        }\\n        \\n        vector<int>buy(n,0);\\n        vector<int>sell(n,0);\\n        \\n        buy[0]=-prices[0];\\n        sell[0]=0;\\n        buy[1]=max(-prices[0],-prices[1]);\\n        sell[1]=max(0,-prices[0]+prices[1]);\\n        \\n        for(int i=2;i<n;i++)\\n      {\\n        buy[i]=max(buy[i-1],sell[i-2]-prices[i]);\\n        sell[i]=max(sell[i-1],buy[i-1]+prices[i]);\\n      }\\n        return sell[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941079,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy = INT_MIN, noop = INT_MIN;\\n        int cooldown = 0, sell = 0;\\n        for(int p: prices) {\\n            noop = max(noop, buy);\\n            buy = cooldown - p;\\n            cooldown = max(cooldown, sell);\\n            sell = noop + p;\\n        }\\n        return max(cooldown, sell);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy = INT_MIN, noop = INT_MIN;\\n        int cooldown = 0, sell = 0;\\n        for(int p: prices) {\\n            noop = max(noop, buy);\\n            buy = cooldown - p;\\n            cooldown = max(cooldown, sell);\\n            sell = noop + p;\\n        }\\n        return max(cooldown, sell);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480511,
                "title": "python-easy-solution-best-approch",
                "content": "# Recursive & Memoisation\\n```\\nclass Solution:\\n    def f(self,ind,buy,n,price,dp):\\n        if ind>=n:\\n            return 0\\n        if dp[ind][buy]!=-1:\\n            return dp[ind][buy]\\n        \\n        if (buy==1):\\n            dp[ind][buy]=max(-price[ind]+self.f(ind+1,0,n,price,dp),0+self.f(ind+1,1,n,price,dp))\\n            \\n        else:    #if ind=n-1 so ind+2 will go out of bound base case is if ind>=n: return 0\\n            dp[ind][buy]=max(price[ind]+self.f(ind+2,1,n,price,dp),0+self.f(ind+1,0,n,price,dp))\\n            \\n        return dp[ind][buy]\\n    \\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[-1 for i in range(2)]for j in range(n)]\\n        return self.f(0,1,n,prices,dp)\\n```\\n\\n# Tabulation :\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[0 for i in range(2)]for j in range(n+2)]\\n        \\n        dp[n][0]=0\\n        dp[n][1]=0\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                if (buy):\\n                    dp[ind][buy]=max(-prices[ind]+dp[ind+1][0] , 0+dp[ind+1][1])\\n                else:\\n                    dp[ind][buy]=max(prices[ind]+dp[ind+2][1],0+dp[ind+1][0])\\n                    \\n        return dp[0][1]\\n```\\n\\n# Time Optimised :\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[0 for i in range(2)]for j in range(n+2)]\\n        \\n        dp[n][0]=0      #Base case 1\\n        dp[n][1]=0      #Base case 2\\n        for ind in range(n-1,-1,-1):\\n            dp[ind][1]=max(-prices[ind]+dp[ind+1][0] , 0+dp[ind+1][1])\\n            dp[ind][0]=max(prices[ind]+dp[ind+2][1],0+dp[ind+1][0])\\n                    \\n        return dp[0][1]\\n```\\n# Time and Space Both Optimised :)  TC O(N) SC O(1)\\n```\\n        n=len(prices)\\n        \\n        front1=[0]*2\\n        front2=[0]*2\\n        curr=[0]*2\\n        \\n        curr[0]=0      #Base case 1\\n        curr[1]=0      #Base case 2\\n        \\n        for ind in range(n-1,-1,-1):\\n            curr=[0]*2\\n            curr[1]=max(-prices[ind] + front1[0] , 0 + front1[1])\\n            curr[0]=max(prices[ind] + front2[1],   0 + front1[0])\\n            front2=front1\\n            front1=curr\\n        return curr[1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,ind,buy,n,price,dp):\\n        if ind>=n:\\n            return 0\\n        if dp[ind][buy]!=-1:\\n            return dp[ind][buy]\\n        \\n        if (buy==1):\\n            dp[ind][buy]=max(-price[ind]+self.f(ind+1,0,n,price,dp),0+self.f(ind+1,1,n,price,dp))\\n            \\n        else:    #if ind=n-1 so ind+2 will go out of bound base case is if ind>=n: return 0\\n            dp[ind][buy]=max(price[ind]+self.f(ind+2,1,n,price,dp),0+self.f(ind+1,0,n,price,dp))\\n            \\n        return dp[ind][buy]\\n    \\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[-1 for i in range(2)]for j in range(n)]\\n        return self.f(0,1,n,prices,dp)\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[0 for i in range(2)]for j in range(n+2)]\\n        \\n        dp[n][0]=0\\n        dp[n][1]=0\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                if (buy):\\n                    dp[ind][buy]=max(-prices[ind]+dp[ind+1][0] , 0+dp[ind+1][1])\\n                else:\\n                    dp[ind][buy]=max(prices[ind]+dp[ind+2][1],0+dp[ind+1][0])\\n                    \\n        return dp[0][1]\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[0 for i in range(2)]for j in range(n+2)]\\n        \\n        dp[n][0]=0      #Base case 1\\n        dp[n][1]=0      #Base case 2\\n        for ind in range(n-1,-1,-1):\\n            dp[ind][1]=max(-prices[ind]+dp[ind+1][0] , 0+dp[ind+1][1])\\n            dp[ind][0]=max(prices[ind]+dp[ind+2][1],0+dp[ind+1][0])\\n                    \\n        return dp[0][1]\\n```\n```\\n        n=len(prices)\\n        \\n        front1=[0]*2\\n        front2=[0]*2\\n        curr=[0]*2\\n        \\n        curr[0]=0      #Base case 1\\n        curr[1]=0      #Base case 2\\n        \\n        for ind in range(n-1,-1,-1):\\n            curr=[0]*2\\n            curr[1]=max(-prices[ind] + front1[0] , 0 + front1[1])\\n            curr[0]=max(prices[ind] + front2[1],   0 + front1[0])\\n            front2=front1\\n            front1=curr\\n        return curr[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355094,
                "title": "c-recursion-dp",
                "content": "Do attempt all the Buy & Sell stock questions in sequence, here\\'s the [link to the list.](https://leetcode.com/list/e7alj8k6)\\n\\n***1. Recursive Solution*** (TLE for 2 testcases)\\n```\\nclass Solution {\\npublic:\\n    int recur(int i, vector<int>& p, bool buy){\\n        if(i>=p.size()) return 0;\\n        int profit=0;\\n        if(buy) profit = max(-p[i]+recur(i+1, p, false), recur(i+1, p, true));\\n        else profit = max(p[i]+recur(i+2, p, true), recur(i+1, p, false));\\n        return profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        return recur(0, prices, true);\\n    }\\n};\\n```\\n\\n***2. DP***\\n```\\nclass Solution {\\npublic:\\n    int recur(int i, vector<int>& p, bool buy, vector<vector<int>>& dp){\\n        if(i>=p.size()) return 0;\\n        if(dp[i][buy]!=-1) return dp[i][buy]; \\n        int profit=0;\\n        if(buy) profit = max(-p[i]+recur(i+1, p, false, dp), recur(i+1, p, true, dp));\\n        else profit = max(p[i]+recur(i+2, p, true, dp), recur(i+1, p, false, dp));\\n        return dp[i][buy] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\\n        return recur(0, prices, true, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i, vector<int>& p, bool buy){\\n        if(i>=p.size()) return 0;\\n        int profit=0;\\n        if(buy) profit = max(-p[i]+recur(i+1, p, false), recur(i+1, p, true));\\n        else profit = max(p[i]+recur(i+2, p, true), recur(i+1, p, false));\\n        return profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        return recur(0, prices, true);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int recur(int i, vector<int>& p, bool buy, vector<vector<int>>& dp){\\n        if(i>=p.size()) return 0;\\n        if(dp[i][buy]!=-1) return dp[i][buy]; \\n        int profit=0;\\n        if(buy) profit = max(-p[i]+recur(i+1, p, false, dp), recur(i+1, p, true, dp));\\n        else profit = max(p[i]+recur(i+2, p, true, dp), recur(i+1, p, false, dp));\\n        return dp[i][buy] = profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\\n        return recur(0, prices, true, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257702,
                "title": "dp-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int ind , int buy, vector<int> &values,int n, vector<vector<int>>&dp)\\n{\\n        // buy =1 ; if the value of buy is 1 we have to buy a stock\\n        // buy =0 ; if the value of buy is 0 we have to sell a stock\\n    if(ind>=n) return 0;\\n        \\n    if(dp[ind][buy]!=-1) return dp[ind][buy];\\n    int profit =0;\\n        \\n    \\n    if(buy)\\n    {\\n        // We can either pick that stock to buy or notPick\\n        // In case of notPick add 0 to profit and move to next index\\n        // In case of pick,  Profit value is reduced by values[ind] and we move to the next index.\\n        profit = max(0+f(ind+1,1,values,n,dp), -values[ind] + f(ind+1,0,values,n,dp));\\n    }else{\\n        \\n         // We can either pick that stock to sell or notPick\\n        // In case of notPick add 0 to profit and move to next index\\n        // In case of pick profit value is increased by values[ind] and skip the next index as we cannot have any transaction on the next day and we shall move to index+2;\\n        profit = max(values[ind] + f(ind+2,1,values,n,dp), 0 + f(ind+1,0,values,n,dp));\\n    }\\n    \\n    return dp[ind][buy] =  profit;\\n}\\n    \\n    int maxProfit(vector<int>& prices) {\\n         int n = prices.size();\\n    vector<vector<int>>dp(n+1,vector<int>(2,-1));\\n    return f(0,1,prices,n,dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int f(int ind , int buy, vector<int> &values,int n, vector<vector<int>>&dp)\\n{\\n        // buy =1 ; if the value of buy is 1 we have to buy a stock\\n        // buy =0 ; if the value of buy is 0 we have to sell a stock\\n    if(ind>=n) return 0;\\n        \\n    if(dp[ind][buy]!=-1) return dp[ind][buy];\\n    int profit =0;\\n        \\n    \\n    if(buy)\\n    {\\n        // We can either pick that stock to buy or notPick\\n        // In case of notPick add 0 to profit and move to next index\\n        // In case of pick,  Profit value is reduced by values[ind] and we move to the next index.\\n        profit = max(0+f(ind+1,1,values,n,dp), -values[ind] + f(ind+1,0,values,n,dp));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2157431,
                "title": "python3-solution-o-n-time-complexity",
                "content": "**O(n) Space**\\n```\\nclass Solution:\\n    def maxProfit(self, A):\\n        n = len(A)\\n        dp = [0] * (n+2)\\n        cmax = 0\\n        for i in reversed(range(n-1)):\\n            cmax = max(cmax,A[i+1] + dp[i+3])\\n            dp[i] = max(dp[i+1],cmax - A[i])\\n        return dp[0]\\n```\\n**O(1) Spcae**\\n```\\nclass Solution:\\n    def maxProfit(self, A):\\n        a,b,c,cmax = 0,0,0,0\\n        for i in reversed(range(len(A)-1)):\\n            cmax = max(cmax,A[i+1] + c)\\n            a,b,c = max(a,cmax - A[i]),a,b\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, A):\\n        n = len(A)\\n        dp = [0] * (n+2)\\n        cmax = 0\\n        for i in reversed(range(n-1)):\\n            cmax = max(cmax,A[i+1] + dp[i+3])\\n            dp[i] = max(dp[i+1],cmax - A[i])\\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A):\\n        a,b,c,cmax = 0,0,0,0\\n        for i in reversed(range(len(A)-1)):\\n            cmax = max(cmax,A[i+1] + c)\\n            a,b,c = max(a,cmax - A[i]),a,b\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132119,
                "title": "python-easy-dp",
                "content": "\\n**Recursion -> TLE\\nTime Complexity: O(N*2)\\nSpace Complexity: O(N)**\\n\\n```\\ndef f(ind,buy,prices):\\n\\n    if(ind >= len(prices)):\\n        return 0\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices), 0 + f(ind+1,1,prices))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+2,1,prices), 0 + f(ind+1,0,prices))\\n\\t\\t\\n    return profit\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        return f(0,1,prices)\\n```\\n\\n**Memoization\\nTime Complexity: O(N*2)\\nSpace Complexity: O(N*2) + O(N)**\\n\\n```\\ndef f(ind,buy,prices,dp):\\n\\n    if(ind >= len(prices)):\\n        return 0\\n    \\n    if(dp[ind][buy] != -1):\\n        return dp[ind][buy]\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,dp), 0 + f(ind+1,1,prices,dp))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+2,1,prices,dp), 0 + f(ind+1,0,prices,dp))\\n        \\n    dp[ind][buy] = profit\\n    return dp[ind][buy]\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n)]\\n\\t\\t\\n        return f(0,1,prices,dp)\\n```\\n\\n**Tabulation\\nTime Complexity: O(N*2)\\nSpace Complexity: O(N*2)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [[0 for i in range(2)] for i in range(n+2)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + dp[ind+2][1], 0 + dp[ind+1][0])\\n                    \\n                dp[ind][buy] = profit\\n\\t\\t\\t\\t\\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]\\n```\\n\\n**Tabulation II\\nTime Complexity: O(N*2)\\nSpace Complexity: O(N*2)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [[0 for i in range(2)] for i in range(n+2)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n            \\n            dp[ind][1] = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\\n            \\n            dp[ind][0] = max(prices[ind] + dp[ind+2][1], 0 + dp[ind+1][0])\\n                    \\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]\\n```\\n\\n**Please upvote if you find it useful !!!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef f(ind,buy,prices):\\n\\n    if(ind >= len(prices)):\\n        return 0\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices), 0 + f(ind+1,1,prices))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+2,1,prices), 0 + f(ind+1,0,prices))\\n\\t\\t\\n    return profit\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        return f(0,1,prices)\\n```\n```\\ndef f(ind,buy,prices,dp):\\n\\n    if(ind >= len(prices)):\\n        return 0\\n    \\n    if(dp[ind][buy] != -1):\\n        return dp[ind][buy]\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,dp), 0 + f(ind+1,1,prices,dp))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+2,1,prices,dp), 0 + f(ind+1,0,prices,dp))\\n        \\n    dp[ind][buy] = profit\\n    return dp[ind][buy]\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n)]\\n\\t\\t\\n        return f(0,1,prices,dp)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [[0 for i in range(2)] for i in range(n+2)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + dp[ind+2][1], 0 + dp[ind+1][0])\\n                    \\n                dp[ind][buy] = profit\\n\\t\\t\\t\\t\\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [[0 for i in range(2)] for i in range(n+2)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n            \\n            dp[ind][1] = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\\n            \\n            dp[ind][0] = max(prices[ind] + dp[ind+2][1], 0 + dp[ind+1][0])\\n                    \\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110608,
                "title": "simple-recursion-c",
                "content": "```\\nclass Solution\\n{\\n\\tint dp[5001][2];\\n\\npublic:\\n\\tint rec(vector<int> pr, int i, bool bos)\\n\\t{\\n\\t\\tif (i >= pr.size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[i][bos] != -1)\\n\\t\\t\\treturn dp[i][bos];\\n\\t\\tint profit = 0;\\n\\t\\tif (bos == 1) // buy\\n\\t\\t{\\n\\t\\t\\tint buy = +rec(pr, i + 1, 0) - pr[i];\\n\\t\\t\\tint notbuy = rec(pr, i + 1, 1);\\n\\t\\t\\tprofit = max(buy, notbuy);\\n\\t\\t}\\n\\t\\tif (bos == 0) // sell\\n\\t\\t{\\n\\t\\t\\tint sell = rec(pr, i + 2, 1) + pr[i];\\n\\t\\t\\tint notsell = rec(pr, i + 1, 0);\\n\\t\\t\\tprofit = max(sell, notsell);\\n\\t\\t}\\n\\t\\treturn dp[i][bos] = profit;\\n\\t}\\n\\tint maxProfit(vector<int> &prices)\\n\\t{\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\treturn rec(prices, 0, 1);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tint dp[5001][2];\\n\\npublic:\\n\\tint rec(vector<int> pr, int i, bool bos)\\n\\t{\\n\\t\\tif (i >= pr.size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[i][bos] != -1)\\n\\t\\t\\treturn dp[i][bos];\\n\\t\\tint profit = 0;\\n\\t\\tif (bos == 1) // buy\\n\\t\\t{\\n\\t\\t\\tint buy = +rec(pr, i + 1, 0) - pr[i];\\n\\t\\t\\tint notbuy = rec(pr, i + 1, 1);\\n\\t\\t\\tprofit = max(buy, notbuy);\\n\\t\\t}\\n\\t\\tif (bos == 0) // sell\\n\\t\\t{\\n\\t\\t\\tint sell = rec(pr, i + 2, 1) + pr[i];\\n\\t\\t\\tint notsell = rec(pr, i + 1, 0);\\n\\t\\t\\tprofit = max(sell, notsell);\\n\\t\\t}\\n\\t\\treturn dp[i][bos] = profit;\\n\\t}\\n\\tint maxProfit(vector<int> &prices)\\n\\t{\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\treturn rec(prices, 0, 1);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809037,
                "title": "c-bottom-up-dp-state-based-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& p) {\\n\\t\\t\\tint i,j;\\n\\t\\t\\tvector<vector<int>>m(s+1,vector<int>(2));\\n\\t\\t\\tp.insert(p.begin(),0);  // insert additional element at front\\n\\n\\t\\t\\t/* m[day][state] */\\t\\n\\t\\t\\tm[0][0]=-p[1];   // 0 represents sold state( next action is buy ) in column space\\n\\t\\t\\t\\tm[0][1]=0;    //1 represent bought state (next action is sell ) in column space\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tm[1][0]=-p[1]; \\n\\t\\t\\tm[1][1]=0; \\n\\t\\t\\t\\n\\t\\t\\t\\tfor(i=2;i<p.size();i++){\\n\\t\\t\\t\\tm[i][0]=max(m[i-1][0],m[i-2][1]-p[i]);          //options: hold or buy\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tm[i][1]=max(m[i-1][1],m[i-1][0]+p[i]);         // options: hold or sell\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\treturn m[p.size()-1][1];\\n\\n\\t\\t}\\n\\t};\\n\\t\\n___________________________________________________________________________________________\\n**please upvote if you liked it  :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& p) {\\n\\t\\t\\tint i,j;\\n\\t\\t\\tvector<vector<int>>m(s+1,vector<int>(2));\\n\\t\\t\\tp.insert(p.begin(),0);  // insert additional element at front\\n\\n\\t\\t\\t/* m[day][state] */\\t\\n\\t\\t\\tm[0][0]=-p[1];   // 0 represents sold state( next action is buy ) in column space\\n\\t\\t\\t\\tm[0][1]=0;    //1 represent bought state (next action is sell ) in column space\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tm[1][0]=-p[1]; \\n\\t\\t\\tm[1][1]=0; \\n\\t\\t\\t\\n\\t\\t\\t\\tfor(i=2;i<p.size();i++){\\n\\t\\t\\t\\tm[i][0]=max(m[i-1][0],m[i-2][1]-p[i]);          //options: hold or buy\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tm[i][1]=max(m[i-1][1],m[i-1][0]+p[i]);         // options: hold or sell\\t\\t\\t\\t\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1633080,
                "title": "python-dp-memoization-tabulation-simple-solution-with-explanation",
                "content": "## Logic:\\n1. This problem can be solved using dynamic programming.\\n2. Let create a dp array (dp[i][k][a])in which the i-th position will tell the maximum profit at the end of i-th day with atmost k transaction. \\n\\t- dp[i][a], **i** denotes the day and **a** denotes whether we have sold or buyes the stocks at the end of the ith day. For example,\\n\\t\\t- dp[i][0] will tell the maximum profit at i-th day such that on i-th day we have sold the stocks.\\n\\t\\t-  dp[i][1] will tell the maximum profit at i-th day such that on i-th day we have bought the stocks.\\n3. Base cases:\\n\\t- dp[0][0] = 0 => because on 0th day we don\\'t have any stock.\\n\\t- dp[0][1] = -infinity => since we don\\'t have any stocks on 0th day so we can\\'t buy any stock\\n4. DP state:\\n\\t- dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i-1])\\n\\t\\t- Since **a** is 0 which means the action taken on ith day is either **Rest** or **Sell**. Therefore the max profit would be the max of **Rest** action(dp[i-1][0]) and **Sell** action(dp[i-1][1]+prices[i-1]). Note: To sell a stock we must have buyed a stock before.\\n\\t- dp[i][1] = \\n\\t\\t- When i == 1: max(dp[i-1][1], -prices[i-1]) Since we can\\'t buy a stock on ith day untill and unless it is sold on i-2th day\\n\\t\\t- When i > 1: max(dp[i-1][1], dp[i-2][0]-prices[i-1])\\n\\t\\t- Since **a** is 1 which means the action taken on ith day is either **Rest** or **Buy**. Therefore the max profit would be the max of **Rest** action(dp[i-1][1]) and **Buy** action(dp[i-1][0]-prices[i-1]).\\n5. At last, we have to return dp[-1][0] because if we don\\'t hold any stock at the end then only we can have the maximum profit.\\n\\n## Solution 1 (Memoiztion)\\n```\\nclass Solution:\\n    def dp(self, prices, currentDay, holding, lookup):\\n        # Return 0 if there are no more stocks.\\n        if currentDay >= len(prices):\\n            return 0\\n        if not lookup[currentDay][holding]:\\n            if holding:\\n                # Return max(did nothing on current day, sold all the stocks on current day and moved to next date after cooldown day).\\n                lookup[currentDay][holding] = max(self.dp(prices, currentDay+1, holding, lookup), prices[currentDay] + self.dp(prices, currentDay+2, 0, lookup))\\n            else:\\n                # Return max(did nothing on current day, bought all the stocks on current day).\\n                lookup[currentDay][holding] = max(self.dp(prices, currentDay+1, holding, lookup), -prices[currentDay] + self.dp(prices, currentDay+1, 1, lookup))\\n        return lookup[currentDay][holding]\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        return self.dp(prices, 0, 0, [[None for _ in range(2)] for _ in range(len(prices))])\\n```\\n\\n## Solution 2 (Tabulation)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        days = len(prices)\\n        dp = [[None for j in range(2)] for i in range(days+1)]\\n        \\n        dp[0][0] = 0\\n        dp[0][1] = -sys.maxsize\\n        \\n        for i in range(1, days+1):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i-1])\\n            if i == 1:\\n                dp[i][1] = max(dp[i-1][1], -prices[i-1])\\n            else:\\n                dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i-1])\\n        \\n        return dp[-1][0]\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, prices, currentDay, holding, lookup):\\n        # Return 0 if there are no more stocks.\\n        if currentDay >= len(prices):\\n            return 0\\n        if not lookup[currentDay][holding]:\\n            if holding:\\n                # Return max(did nothing on current day, sold all the stocks on current day and moved to next date after cooldown day).\\n                lookup[currentDay][holding] = max(self.dp(prices, currentDay+1, holding, lookup), prices[currentDay] + self.dp(prices, currentDay+2, 0, lookup))\\n            else:\\n                # Return max(did nothing on current day, bought all the stocks on current day).\\n                lookup[currentDay][holding] = max(self.dp(prices, currentDay+1, holding, lookup), -prices[currentDay] + self.dp(prices, currentDay+1, 1, lookup))\\n        return lookup[currentDay][holding]\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        return self.dp(prices, 0, 0, [[None for _ in range(2)] for _ in range(len(prices))])\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        days = len(prices)\\n        dp = [[None for j in range(2)] for i in range(days+1)]\\n        \\n        dp[0][0] = 0\\n        dp[0][1] = -sys.maxsize\\n        \\n        for i in range(1, days+1):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i-1])\\n            if i == 1:\\n                dp[i][1] = max(dp[i-1][1], -prices[i-1])\\n            else:\\n                dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i-1])\\n        \\n        return dp[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619013,
                "title": "java-backtrack-memo-bottom-up-tabulation-explained",
                "content": "**Backtrack without memoization:**\\n\\nTC: O(2^n). On each day, we consider three possible actions; buy,sell, rest. However, depending on whether we\\'re holding stock or not on a given day, we can only take 2/3 of those mentioned actions; if we\\'re not holding stock, we can\\'t sell. If we\\'re holding stock, we can\\'t buy. Either way, we can maintain the status quo and just \\'rest\\'.\\nIf we choose to sell stock on a given day, the next day when we could consider a \\'buy\\' or \\'rest\\' action, is 2 days away. This is a constraint defined in the problem, and so our code has to consider it. Consider all possible combinations. **This gives TLE.**\\n\\nSC: O(1) aux space, O(n) maximum recursion stack depth (if we rested each day).\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        return backtrack(prices,0,false);\\n    }\\n    \\n    private int backtrack(int[] prices, int day, boolean holding){\\n        if(day>=prices.length) return 0;\\n        \\n        int buy=0,sell=0,rest=0;\\n        if(holding) sell= backtrack(prices,day+2,false)+prices[day];\\n        else if(!holding) buy= backtrack(prices,day+1,true)-prices[day];\\n        rest= backtrack(prices,day+1,holding);\\n        \\n        return Math.max(rest,Math.max(buy,sell));\\n        \\n    }\\n}\\n```\\n\\n**Top-down recursion (backtrack), with 2D memoization:**\\n\\nTC: O(n). We still consider what our max profit would look on each day, if we: bought, sold, or rested. However, we remember what the \\'best choice\\' was for each day. For example, when we calculate the \\'buy\\' decision for day \\'i\\', this calculates the \\'sell\\' and \\'rest\\' decisions for day \\'i+1\\'. In the same stack frame we later calculate the \\'rest\\' decision for day \\'i\\', in which case we move into day \\'i+1\\' having held stock: so for day \\'i+1\\', the \\'sell\\' and \\'rest\\' decisions are again calculated, but already remembered the answer, from when we considered the earlier \\'buy\\' decision.\\n\\nSC: O(n).\\n\\n```\\nclass Solution {\\n    int[][] memo;\\n    public int maxProfit(int[] prices) {\\n        memo= new int[prices.length][2];\\n        return backtrack(prices,0,false);\\n    }\\n    \\n    private int backtrack(int[] prices, int day, boolean holding){\\n        if(day>=prices.length) return 0;\\n        \\n        if(memo[day][holding==true?1:0]!=0) return memo[day][holding==true?1:0];\\n        \\n        int buy=0,sell=0,rest=0;\\n        if(holding) sell= backtrack(prices,day+2,false)+prices[day];\\n        else if(!holding) buy= backtrack(prices,day+1,true)-prices[day];\\n        rest= backtrack(prices,day+1,holding);\\n        \\n        memo[day][holding==true?1:0]= Math.max(rest,Math.max(buy,sell));\\n        return memo[day][holding==true?1:0];\\n        \\n    }\\n}\\n```\\n\\n**Bottom-Up tabulation**\\n\\nTC: O(n). \\n\\ntab\\\\[ i ][ 0 ] means, on day \\'i\\', if I want to end up with no stock, what\\'s the most profit I could make?\\nIt means we\\'d have to have no stock on day \\'i-1\\' and just rested, or we\\'d have to have had stock on day \\'i-1\\', and decided to liquidate it on day \\'i\\'.\\n\\ntab\\\\[ i ][ 1 ] means, on day \\'i\\', if I want to be holding stock, what\\'s the most profit I could make?\\nWe\\'d either have had to be holding stock on day \\'i-1\\' and rested, or, we\\'d had to have SOLD stock 2 days prior \\'i-2\\', waited for the cooldown to finish \\'i-1\\', and THEN bought stock on day \\'i\\'.\\n\\nSC: O(n).\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int[][] tab= new int[prices.length+1][2];\\n        tab[0][0]= 0; tab[1][0]= 0;\\n        tab[0][1]= Integer.MIN_VALUE; tab[1][1]= -prices[0];\\n        \\n        for (int i=2; i<=prices.length; i++){\\n            tab[i][0]= Math.max(tab[i-1][0],tab[i-1][1]+prices[i-1]);\\n            tab[i][1]= Math.max(tab[i-1][1],tab[i-2][0]-prices[i-1]);\\n        }\\n        \\n        return Math.max(tab[prices.length][0],tab[prices.length][1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        return backtrack(prices,0,false);\\n    }\\n    \\n    private int backtrack(int[] prices, int day, boolean holding){\\n        if(day>=prices.length) return 0;\\n        \\n        int buy=0,sell=0,rest=0;\\n        if(holding) sell= backtrack(prices,day+2,false)+prices[day];\\n        else if(!holding) buy= backtrack(prices,day+1,true)-prices[day];\\n        rest= backtrack(prices,day+1,holding);\\n        \\n        return Math.max(rest,Math.max(buy,sell));\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[][] memo;\\n    public int maxProfit(int[] prices) {\\n        memo= new int[prices.length][2];\\n        return backtrack(prices,0,false);\\n    }\\n    \\n    private int backtrack(int[] prices, int day, boolean holding){\\n        if(day>=prices.length) return 0;\\n        \\n        if(memo[day][holding==true?1:0]!=0) return memo[day][holding==true?1:0];\\n        \\n        int buy=0,sell=0,rest=0;\\n        if(holding) sell= backtrack(prices,day+2,false)+prices[day];\\n        else if(!holding) buy= backtrack(prices,day+1,true)-prices[day];\\n        rest= backtrack(prices,day+1,holding);\\n        \\n        memo[day][holding==true?1:0]= Math.max(rest,Math.max(buy,sell));\\n        return memo[day][holding==true?1:0];\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int[][] tab= new int[prices.length+1][2];\\n        tab[0][0]= 0; tab[1][0]= 0;\\n        tab[0][1]= Integer.MIN_VALUE; tab[1][1]= -prices[0];\\n        \\n        for (int i=2; i<=prices.length; i++){\\n            tab[i][0]= Math.max(tab[i-1][0],tab[i-1][1]+prices[i-1]);\\n            tab[i][1]= Math.max(tab[i-1][1],tab[i-2][0]-prices[i-1]);\\n        }\\n        \\n        return Math.max(tab[prices.length][0],tab[prices.length][1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522708,
                "title": "python-3-bottom-up-dp-memoization-o-n-time-and-space-code-comments",
                "content": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        # Bottom-up dynamic programming with memoization (caching)\\n        @lru_cache(None)\\n        def dp(day: int, can_buy: True) -> int:\\n\\n            # Base case\\n            if day >= len(prices):\\n                return 0\\n\\n            if can_buy:\\n                # We don\\'t own any stocks. Two options:\\n                # 1. Don\\'t buy any stocks and go to the next day (wait for a better opportunity)\\n                # 2. Buy stocks and go to the next day (with hope to have the best profit)\\n                return max(dp(day + 1, True), dp(day + 1, False) - prices[day])\\n            else:\\n                # We own stocks. Two options:\\n                # 1. Don\\'t sell any stocks and go to the next day (maybe there is a better selling price)\\n                # 2. Sell the stocks and go to the day after tomorrow (cooldown tomorrow)\\n                return max(dp(day + 1, False), dp(day + 2, True) + prices[day])\\n\\n        # Start with no stocks\\n        return dp(0, True)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        # Bottom-up dynamic programming with memoization (caching)\\n        @lru_cache(None)\\n        def dp(day: int, can_buy: True) -> int:\\n\\n            # Base case\\n            if day >= len(prices):\\n                return 0\\n\\n            if can_buy:\\n                # We don\\'t own any stocks. Two options:\\n                # 1. Don\\'t buy any stocks and go to the next day (wait for a better opportunity)\\n                # 2. Buy stocks and go to the next day (with hope to have the best profit)\\n                return max(dp(day + 1, True), dp(day + 1, False) - prices[day])\\n            else:\\n                # We own stocks. Two options:\\n                # 1. Don\\'t sell any stocks and go to the next day (maybe there is a better selling price)\\n                # 2. Sell the stocks and go to the day after tomorrow (cooldown tomorrow)\\n                return max(dp(day + 1, False), dp(day + 2, True) + prices[day])\\n\\n        # Start with no stocks\\n        return dp(0, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522520,
                "title": "c-dp-with-explanation-o-n",
                "content": "I have mentioned the thought process using comments. In case of any further query, please let me know in the comments.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int dp[n][2]; //dp[0][0] represents profit at 1st day when we have no stock in hand\\n        //dp[0][1] represents profit at 1st day when we have stock in hand\\n        \\n        memset(dp, 0, sizeof(dp));\\n        \\n        if(n <= 1)\\n            return 0; //no profit if 1 day of profit;\\n        \\n        if(n == 2 && prices[1] > prices[0])\\n            return prices[1]-prices[0];\\n        else if(n == 2 && prices[1] < prices[0])\\n            return 0;\\n        \\n        //base condition\\n        dp[0][0] = 0;\\n        dp[0][1] = -prices[0];\\n        dp[1][0] = max(dp[0][1]+prices[1], dp[0][0]);\\n        dp[1][1] = max(-prices[1], dp[0][1]);\\n        \\n        //you have no stock when you sell the stock on ith day or carry forward your previous day\\'s state\\n        //you have stock when you buy today or carry forward your previous day\\'s state\\n\\t\\t//dp[i-1][1]+prices[i] is when you sell today. \\n\\t\\t//If you sell today, you add the prices of ith day to profit until previous day\\n\\t\\t//dp[i-2][0]-prices[i] is when you buy today.\\n\\t\\t//Since we have cooldown of 1 day, we substract the prices[i] from profit of i-2th day\\n        \\n        for(int i = 2; i < n; i++){\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]);\\n            dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i]);\\n        }\\n        \\n        return max(dp[n-1][0], dp[n-1][1]);\\n    }\\n};\\n```\\n\\nPlease **upvote** if you like my solution !!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int dp[n][2]; //dp[0][0] represents profit at 1st day when we have no stock in hand\\n        //dp[0][1] represents profit at 1st day when we have stock in hand\\n        \\n        memset(dp, 0, sizeof(dp));\\n        \\n        if(n <= 1)\\n            return 0; //no profit if 1 day of profit;\\n        \\n        if(n == 2 && prices[1] > prices[0])\\n            return prices[1]-prices[0];\\n        else if(n == 2 && prices[1] < prices[0])\\n            return 0;\\n        \\n        //base condition\\n        dp[0][0] = 0;\\n        dp[0][1] = -prices[0];\\n        dp[1][0] = max(dp[0][1]+prices[1], dp[0][0]);\\n        dp[1][1] = max(-prices[1], dp[0][1]);\\n        \\n        //you have no stock when you sell the stock on ith day or carry forward your previous day\\'s state\\n        //you have stock when you buy today or carry forward your previous day\\'s state\\n\\t\\t//dp[i-1][1]+prices[i] is when you sell today. \\n\\t\\t//If you sell today, you add the prices of ith day to profit until previous day\\n\\t\\t//dp[i-2][0]-prices[i] is when you buy today.\\n\\t\\t//Since we have cooldown of 1 day, we substract the prices[i] from profit of i-2th day\\n        \\n        for(int i = 2; i < n; i++){\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]);\\n            dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i]);\\n        }\\n        \\n        return max(dp[n-1][0], dp[n-1][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256920,
                "title": "c-top-down-bottom-up",
                "content": "```\\n\\nBottom -up solution :-\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        \\n        if(n == 1)\\n            return 0;\\n        \\n        vector<vector<int >> dp(n, vector<int>(2, 0));\\n        dp[0][0] = -prices[0];\\n        dp[1][0] = max(-prices[0], -prices[1]);\\n        dp[1][1] = max(0, prices[1] - prices[0]);\\n        \\n        for(int i = 2; i < n; ++i){\\n            \\n            dp[i][0] = max(-prices[i] + dp[i - 2][1], dp[i - 1][0]);\\n            dp[i][1] = max(prices[i] + dp[i - 1][0], dp[i - 1][1]);\\n            \\n        }\\n        \\n        return dp[n - 1][1];\\n    }\\n};\\n\\nTop-down solution:-\\n\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& prices, int n, int idx, int own, vector<vector<int>>& dp){\\n        \\n            if(idx >= n){\\n                return 0;\\n            }\\n        \\n        \\n            if(dp[idx][own] != -1)\\n                return dp[idx][own];\\n        \\n        if(own){\\n            \\n            // whether to sell or not to sell\\n            int op1 = prices[idx] + helper(prices, n, idx + 2, 0, dp);\\n            int op2 = helper(prices, n, idx + 1, own, dp);\\n            \\n            return dp[idx][own] = max(op1, op2);\\n            \\n        }\\n        else{\\n            \\n            // whether to buy or not\\n            int op1 = - prices[idx] + helper(prices, n, idx + 1, 1, dp);\\n            int op2 = helper(prices, n, idx + 1, own, dp);\\n            \\n            return dp[idx][own] = max(op1, op2);\\n            \\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n            int n = prices.size();\\n            \\n            vector<vector<int >> dp(n + 1, vector<int>(2, -1));\\n            int ans = helper(prices, n, 0, 0, dp);\\n            return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        \\n        if(n == 1)\\n            return 0;\\n        \\n        vector<vector<int >> dp(n, vector<int>(2, 0));\\n        dp[0][0] = -prices[0];\\n        dp[1][0] = max(-prices[0], -prices[1]);\\n        dp[1][1] = max(0, prices[1] - prices[0]);\\n        \\n        for(int i = 2; i < n; ++i){\\n            \\n            dp[i][0] = max(-prices[i] + dp[i - 2][1], dp[i - 1][0]);\\n            dp[i][1] = max(prices[i] + dp[i - 1][0], dp[i - 1][1]);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1225051,
                "title": "c-recur-memo-dp-o-n-2-dp-o-n-easy-comments",
                "content": "```\\n//Approach-1 (Recursion+Memoization)\\nclass Solution {\\npublic:\\n    int t[5001][2];\\n    int maxP(vector<int>& prices, int day, int n, int buy) {\\n        if(day >= n)\\n            return 0;\\n        \\n        int profit = 0;\\n        if(t[day][buy] != -1) {\\n            return t[day][buy];\\n        }\\n        //buy\\n        if(buy) {\\n            int consider      = maxP(prices, day+1, n, false) - prices[day];\\n            int not_consider  = maxP(prices, day+1, n, true);\\n            profit = max({profit, consider, not_consider});\\n        } else { //sell\\n            int consider      = maxP(prices, day+2, n, true) + prices[day];\\n            int not_consider  = maxP(prices, day+1, n, false);\\n            profit = max({profit, consider, not_consider}); \\n        }\\n        \\n        return t[day][buy] = profit;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        memset(t, -1, sizeof(t));\\n        return maxP(prices, 0, n, true);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (DP : O(n^2))\\nclass Solution {\\npublic:\\n    int maxP(vector<int>& prices, int& n) {\\n        if(n == 0 || n == 1)\\n            return 0;\\n        vector<int> t(n, 0);\\n        \\n        //t[i] = max profit at the end of ith day\\n        t[0] = 0; //no profit on 0th day\\n        t[1] = max(prices[1] - prices[0], 0); // max(bought_day_0 and sell_day_1, 0);\\n        \\n        /*  \\n            Let\\'s analyse ith day, i.e. t[i] :\\n            i-th day can be :\\n            - BUY DAY   -> NO, because why would someone buy on last day\\n            \\n            - COOL DOWN -> YES, in that case, max-profit will be previsou\\'s day profit (t[i] = t[i-1])\\n            \\n            - SELL DAY  -> If we choose to sell today, We will have to select the best buy day from j = 0 to j = (i-1)\\n                          So, profit = prices[j] - prices[i]; //i.e. we bought on day-j and sell on day-i\\n                          But, what about previous-profit of j i.e. t[j]. We need to consider that as well to find whole\\n                          maximum profit.\\n                          So, for that let\\'s look previously to j :\\n                          Look at (j-1) -> It can\\'t be buy-day, becuse we are already buying on jth day\\n                                        -> It can\\'t be sell-day, because we\\'ll be on cooldown on jth day\\n                                        -> It can only be cool-down day. max profit till (j-1)th day will be\\n                                            equal to its privous profit i.e. t[j-2]\\n                                            \\n                        So, profit at day i = prices[j] - prices[i] + t[j-2];\\n                          \\n        */\\n        \\n        for(int i = 2; i<n; i++) {\\n            t[i] = t[i-1]; //cool down\\n            \\n            //find best buy day from j  = 0 to i-1\\n            for(int j = 0; j<=i-1; j++) {\\n                \\n                int prev_profit = j>=2 ? t[j-2] : 0;\\n                \\n                t[i] = max(t[i], prices[i] - prices[j] + prev_profit);\\n            }\\n        }\\n        \\n        return t[n-1];\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return maxP(prices, n);\\n    }\\n};\\n```\\n\\n```\\nApproach-3 (Optimizing Approach-1 to O(n))\\nclass Solution {\\npublic:\\n    int maxP(vector<int>& prices, int& n) {\\n        if(n == 0 || n == 1)\\n            return 0;\\n        \\n        /*\\n            if you notice, while finding the best j from 0 to i-1 (i.e. best buy day)\\n            t[i] = max(t[i], prices[i] - prices[j] + prev_profit);\\n            Here, (prices[i] - prices[j] + prev_profit) in this, prices[i] is not changing\\n            So, it can be written as (prices[i] + (prev_profit - prices[j]))\\n            We need maximum (prev_profit - prices[j]) = maxDiff\\n            i.e. (prices[i] + maxDiff)\\n            SO, we maintain maxDiff through out.\\n            \\n            Notice, (when j < 2), prev_profit = 0;\\n            \\n            we get, (prices[i] - prices[j])\\n            So, when j < 2, maxDiff = -prices[j];\\n            \\n        */\\n        \\n        vector<int> t(n, 0);\\n        int maxDiff = INT_MIN;\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(i < 2)\\n                maxDiff = max(maxDiff, -prices[i]);\\n            if(i == 0)\\n                t[i] = 0;\\n            else if(i == 1)\\n                t[i] = max(prices[1] - prices[0], 0);\\n            else {\\n                //t[i] = max(cooldown, best buy privously to gain max profit after selling now);\\n                t[i]    = max(t[i-1], prices[i] + maxDiff);\\n                maxDiff = max(maxDiff, t[i-2] - prices[i]);\\n            }\\n        }\\n        \\n        return t[n-1];\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return maxP(prices, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Recursion+Memoization)\\nclass Solution {\\npublic:\\n    int t[5001][2];\\n    int maxP(vector<int>& prices, int day, int n, int buy) {\\n        if(day >= n)\\n            return 0;\\n        \\n        int profit = 0;\\n        if(t[day][buy] != -1) {\\n            return t[day][buy];\\n        }\\n        //buy\\n        if(buy) {\\n            int consider      = maxP(prices, day+1, n, false) - prices[day];\\n            int not_consider  = maxP(prices, day+1, n, true);\\n            profit = max({profit, consider, not_consider});\\n        } else { //sell\\n            int consider      = maxP(prices, day+2, n, true) + prices[day];\\n            int not_consider  = maxP(prices, day+1, n, false);\\n            profit = max({profit, consider, not_consider}); \\n        }\\n        \\n        return t[day][buy] = profit;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        memset(t, -1, sizeof(t));\\n        return maxP(prices, 0, n, true);\\n    }\\n};\\n```\n```\\n//Approach-2 (DP : O(n^2))\\nclass Solution {\\npublic:\\n    int maxP(vector<int>& prices, int& n) {\\n        if(n == 0 || n == 1)\\n            return 0;\\n        vector<int> t(n, 0);\\n        \\n        //t[i] = max profit at the end of ith day\\n        t[0] = 0; //no profit on 0th day\\n        t[1] = max(prices[1] - prices[0], 0); // max(bought_day_0 and sell_day_1, 0);\\n        \\n        /*  \\n            Let\\'s analyse ith day, i.e. t[i] :\\n            i-th day can be :\\n            - BUY DAY   -> NO, because why would someone buy on last day\\n            \\n            - COOL DOWN -> YES, in that case, max-profit will be previsou\\'s day profit (t[i] = t[i-1])\\n            \\n            - SELL DAY  -> If we choose to sell today, We will have to select the best buy day from j = 0 to j = (i-1)\\n                          So, profit = prices[j] - prices[i]; //i.e. we bought on day-j and sell on day-i\\n                          But, what about previous-profit of j i.e. t[j]. We need to consider that as well to find whole\\n                          maximum profit.\\n                          So, for that let\\'s look previously to j :\\n                          Look at (j-1) -> It can\\'t be buy-day, becuse we are already buying on jth day\\n                                        -> It can\\'t be sell-day, because we\\'ll be on cooldown on jth day\\n                                        -> It can only be cool-down day. max profit till (j-1)th day will be\\n                                            equal to its privous profit i.e. t[j-2]\\n                                            \\n                        So, profit at day i = prices[j] - prices[i] + t[j-2];\\n                          \\n        */\\n        \\n        for(int i = 2; i<n; i++) {\\n            t[i] = t[i-1]; //cool down\\n            \\n            //find best buy day from j  = 0 to i-1\\n            for(int j = 0; j<=i-1; j++) {\\n                \\n                int prev_profit = j>=2 ? t[j-2] : 0;\\n                \\n                t[i] = max(t[i], prices[i] - prices[j] + prev_profit);\\n            }\\n        }\\n        \\n        return t[n-1];\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return maxP(prices, n);\\n    }\\n};\\n```\n```\\nApproach-3 (Optimizing Approach-1 to O(n))\\nclass Solution {\\npublic:\\n    int maxP(vector<int>& prices, int& n) {\\n        if(n == 0 || n == 1)\\n            return 0;\\n        \\n        /*\\n            if you notice, while finding the best j from 0 to i-1 (i.e. best buy day)\\n            t[i] = max(t[i], prices[i] - prices[j] + prev_profit);\\n            Here, (prices[i] - prices[j] + prev_profit) in this, prices[i] is not changing\\n            So, it can be written as (prices[i] + (prev_profit - prices[j]))\\n            We need maximum (prev_profit - prices[j]) = maxDiff\\n            i.e. (prices[i] + maxDiff)\\n            SO, we maintain maxDiff through out.\\n            \\n            Notice, (when j < 2), prev_profit = 0;\\n            \\n            we get, (prices[i] - prices[j])\\n            So, when j < 2, maxDiff = -prices[j];\\n            \\n        */\\n        \\n        vector<int> t(n, 0);\\n        int maxDiff = INT_MIN;\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(i < 2)\\n                maxDiff = max(maxDiff, -prices[i]);\\n            if(i == 0)\\n                t[i] = 0;\\n            else if(i == 1)\\n                t[i] = max(prices[1] - prices[0], 0);\\n            else {\\n                //t[i] = max(cooldown, best buy privously to gain max profit after selling now);\\n                t[i]    = max(t[i-1], prices[i] + maxDiff);\\n                maxDiff = max(maxDiff, t[i-2] - prices[i]);\\n            }\\n        }\\n        \\n        return t[n-1];\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return maxP(prices, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212975,
                "title": "state-machine-js-solution",
                "content": "```\\n// State Machine\\nvar maxProfit = function(prices) {\\n    if (prices === null || prices.length === 0) {\\n        return 0;\\n    }\\n    // empty[i] is the max profit on day i with the state of no stock\\n    // empty[i] = Math.max(empty[i-1], sold[i-1])\\n    let empty = new Array(prices.length);\\n    // hold[i] is the max profit on day i with the state of holding stock\\n    // hold[i] = Math.max(hold[i-1], empty[i-1]-prices[i])\\n    let hold = new Array(prices.length);\\n    // sold[i] is the max profit on day i with the state of having stock sold on day i\\n    // sold[i] = hold[i-1] + prices[i]\\n    let sold = new Array(prices.length);\\n    empty[0] = 0;\\n    hold[0] = -prices[0];\\n    sold[0] = 0;\\n    for (let i = 1; i < prices.length; i++) {\\n        empty[i] = Math.max(empty[i-1], sold[i-1]);\\n        hold[i] = Math.max(hold[i-1], empty[i-1]-prices[i]);\\n        sold[i] = hold[i-1] + prices[i];\\n    }\\n    // Among the last entries, hold[i] will be always the worst case,\\n    // since we are still holding stock and have no way of selling it now \\n    // as we\\'ve reached the last day on Earth\\n    return Math.max(empty[empty.length-1], sold[sold.length-1]);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// State Machine\\nvar maxProfit = function(prices) {\\n    if (prices === null || prices.length === 0) {\\n        return 0;\\n    }\\n    // empty[i] is the max profit on day i with the state of no stock\\n    // empty[i] = Math.max(empty[i-1], sold[i-1])\\n    let empty = new Array(prices.length);\\n    // hold[i] is the max profit on day i with the state of holding stock\\n    // hold[i] = Math.max(hold[i-1], empty[i-1]-prices[i])\\n    let hold = new Array(prices.length);\\n    // sold[i] is the max profit on day i with the state of having stock sold on day i\\n    // sold[i] = hold[i-1] + prices[i]\\n    let sold = new Array(prices.length);\\n    empty[0] = 0;\\n    hold[0] = -prices[0];\\n    sold[0] = 0;\\n    for (let i = 1; i < prices.length; i++) {\\n        empty[i] = Math.max(empty[i-1], sold[i-1]);\\n        hold[i] = Math.max(hold[i-1], empty[i-1]-prices[i]);\\n        sold[i] = hold[i-1] + prices[i];\\n    }\\n    // Among the last entries, hold[i] will be always the worst case,\\n    // since we are still holding stock and have no way of selling it now \\n    // as we\\'ve reached the last day on Earth\\n    return Math.max(empty[empty.length-1], sold[sold.length-1]);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189677,
                "title": "c-dp-solution-0-ms-time-o-n-space-o-n",
                "content": "Basically, we have 2 possible states at any index ```i``` as follow -:\\nState 1. We don\\'t have any stock -> Possible options to move forward is to either buy a stock today or on a later date.\\nState 2. We have a stock -> Possible options to move forward from this state is to either sell today and then move forward with State 1 from ```(i+2)th``` index, or to sell the stock on a later date.\\n\\nHere is the solution I have coded usign above scenarios. The parameter ```bought``` represents whether or not you own a stock when reaching the ith index.\\n1. ```bought``` value 1 represents we own a stock\\n2. ```bought``` value 0 represent we do not own a stock\\n\\nRemember, if you chosse to buy the stock on ith day, the total profit will be ```prices[selling_day_index] - prices[i]```, the same has been implemented usign ```(-1) * prices[i]```\\n\\n```\\nclass Solution {\\npublic:\\n    int stock(vector<int>& prices, vector<vector<int>> &dp, int bought, int i, int n) {\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (dp[i][bought] != -1) {\\n            return dp[i][bought];\\n        }\\n        if (bought) {\\n            dp[i][bought] = max(prices[i] + stock(prices, dp, 0, i+2, n), stock(prices, dp, 1, i+1, n));\\n        } else {\\n            dp[i][bought] = max(-1*prices[i] + stock(prices, dp, 1, i+1, n), stock(prices, dp, 0, i+1, n));\\n        }\\n        return dp[i][bought];\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        if (n == 1) {\\n            return 0;\\n        }\\n        return max(0, stock(prices, dp, 0, 0, n));\\n    }\\n};\\n```\\n\\nTime Complexity : ```O(n)``` since we only swap the array twice at most\\nSpace Complexity :```O(n)``` since we create a DP array with fixed number of columns which is ```2```, i.e. space used is ```2 * (n)```, i.e. ```O(n)```",
                "solutionTags": [],
                "code": "```i```\n```(i+2)th```\n```bought```\n```bought```\n```bought```\n```prices[selling_day_index] - prices[i]```\n```(-1) * prices[i]```\n```\\nclass Solution {\\npublic:\\n    int stock(vector<int>& prices, vector<vector<int>> &dp, int bought, int i, int n) {\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (dp[i][bought] != -1) {\\n            return dp[i][bought];\\n        }\\n        if (bought) {\\n            dp[i][bought] = max(prices[i] + stock(prices, dp, 0, i+2, n), stock(prices, dp, 1, i+1, n));\\n        } else {\\n            dp[i][bought] = max(-1*prices[i] + stock(prices, dp, 1, i+1, n), stock(prices, dp, 0, i+1, n));\\n        }\\n        return dp[i][bought];\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        if (n == 1) {\\n            return 0;\\n        }\\n        return max(0, stock(prices, dp, 0, 0, n));\\n    }\\n};\\n```\n```O(n)```\n```O(n)```\n```2```\n```2 * (n)```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 961832,
                "title": "python-beats-100-clean-dp-with-comments-o-n",
                "content": "```\\ndef solution(prices):\\n    \\n    n = len(prices)\\n    if n <= 1: return 0\\n    \\n    stock = [0] * n         # balance with stock held at day i\\n    cash = [0] * n          # balance with cash held at day i\\n    \\n    # terminal condition\\n    stock[0] = -1 * prices[0]\\n    stock[1] = max(stock[0], -1 * prices[1])\\n    cash[1] = max(0, stock[0] + prices[1])\\n    \\n    for i in range(2, n):\\n        \\n        # dynamic programming recursive formula\\n        stock[i] = max(stock[i-1], cash[i-2] - prices[i])\\n        cash[i] = max(cash[i-1], stock[i-1] + prices[i])\\n    \\n    return cash[n-1]        # return last cash balance\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef solution(prices):\\n    \\n    n = len(prices)\\n    if n <= 1: return 0\\n    \\n    stock = [0] * n         # balance with stock held at day i\\n    cash = [0] * n          # balance with cash held at day i\\n    \\n    # terminal condition\\n    stock[0] = -1 * prices[0]\\n    stock[1] = max(stock[0], -1 * prices[1])\\n    cash[1] = max(0, stock[0] + prices[1])\\n    \\n    for i in range(2, n):\\n        \\n        # dynamic programming recursive formula\\n        stock[i] = max(stock[i-1], cash[i-2] - prices[i])\\n        cash[i] = max(cash[i-1], stock[i-1] + prices[i])\\n    \\n    return cash[n-1]        # return last cash balance\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 943676,
                "title": "scala-two-line-dynamic-programming-solution",
                "content": "Ok, I know it\\'s an eye-catching title\\n\\n\\nHere is the code\\n```\\nobject Solution {\\n  def maxProfit(prices: Array[Int]): Int = {\\n    val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) { case ((withoutHold, hold, cooldown), cost) => ( withoutHold max cooldown, hold max (withoutHold - cost), hold + cost)}\\n    withoutHold max cooldown\\n  }\\n}\\n```\\n* In scala, we always could chain functions in one line :)\\n\\n----\\n**Explaination**\\nThe following is the state transition picture\\n![image](https://assets.leetcode.com/users/images/d4917051-2598-4f3f-8000-04930de989d4_1605959225.9495778.png)\\n\\n\\nAs you see, we only need three state in this problem\\n1. without holding: you don\\'t have any stock on hand\\n2. holding: you keep a share on had\\n3. cool down: you have shorted your position and you need to rest one day\\n\\n\\n\\n**Readable version**\\n```\\nobject Solution {\\n    def maxProfit(prices: Array[Int]): Int = {\\n        val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) {\\n            case ((withoutHold, hold, cooldown), cost) => \\n             (\\n                 withoutHold max cooldown,\\n                 hold max (withoutHold - cost),\\n                 hold + cost      \\n             )\\n        }\\n        withoutHold max cooldown\\n    }\\n}\\n```\\n\\n* time complexity: O(N)\\n\\t* just visit each price once\\n* space complexity: O(1)\\n\\n---\\n\\nAre you looking for the vanilla dynamic programming solution ?\\nHere you are\\n```\\nobject Solution {\\n    def maxProfit(prices: Array[Int]): Int = {\\n        if(prices == null || prices.isEmpty) return 0\\n        /*\\n        * state definition\\n        * 0: without holding\\n        * 1: holding one share\\n        * 2: sell and cool down\\n        */\\n        val dp = Array.tabulate(prices.length, 3){\\n            case (0, 0) => 0\\n            case (0, 1) => -prices(0)\\n            case (0, 2) => 0\\n            case _ => 0\\n        }\\n        \\n        for(i <- 1 until prices.length) {\\n            dp(i)(0) = dp(i - 1)(0) max dp(i - 1)(2) // 0 -> 0 or 2 -> 0\\n            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i)) // 1 -> 1 or  0 -> 1\\n            dp(i)(2) = dp(i - 1)(1) + prices(i) // 1 -> 2\\n        }\\n        \\n        dp.last.max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\nobject Solution {\\n  def maxProfit(prices: Array[Int]): Int = {\\n    val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) { case ((withoutHold, hold, cooldown), cost) => ( withoutHold max cooldown, hold max (withoutHold - cost), hold + cost)}\\n    withoutHold max cooldown\\n  }\\n}\\n```\n```\\nobject Solution {\\n    def maxProfit(prices: Array[Int]): Int = {\\n        val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) {\\n            case ((withoutHold, hold, cooldown), cost) => \\n             (\\n                 withoutHold max cooldown,\\n                 hold max (withoutHold - cost),\\n                 hold + cost      \\n             )\\n        }\\n        withoutHold max cooldown\\n    }\\n}\\n```\n```\\nobject Solution {\\n    def maxProfit(prices: Array[Int]): Int = {\\n        if(prices == null || prices.isEmpty) return 0\\n        /*\\n        * state definition\\n        * 0: without holding\\n        * 1: holding one share\\n        * 2: sell and cool down\\n        */\\n        val dp = Array.tabulate(prices.length, 3){\\n            case (0, 0) => 0\\n            case (0, 1) => -prices(0)\\n            case (0, 2) => 0\\n            case _ => 0\\n        }\\n        \\n        for(i <- 1 until prices.length) {\\n            dp(i)(0) = dp(i - 1)(0) max dp(i - 1)(2) // 0 -> 0 or 2 -> 0\\n            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i)) // 1 -> 1 or  0 -> 1\\n            dp(i)(2) = dp(i - 1)(1) + prices(i) // 1 -> 2\\n        }\\n        \\n        dp.last.max\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 764683,
                "title": "super-concise-c-code-and-understandable-explanation-for-beginners",
                "content": "Step1: Define DP\\n\\n\\tDP[i][j] , i : days ; j : if hold stock\\n\\n\\tDP[3][0] --> at 3th day and not hold stock, the max profit would be DP[3][0]; \\n\\t\\n\\tDP[3][1] --> at 3th day and  hold stock, the max profit would be DP[3][1]; \\n\\nStep2: Find the formula that induct DP[i][j]\\n\\n\\ta. One tranzaction one time.  So guess where DP[i][0] come from? the answer are   DP[i-1][0] or DP[i-1][1] ---->> So,\\n\\t\\t\\n\\t\\tDP[i][0] = max( DP[i-1][0], DP[i-1][1] + prices[i] );\\n\\t\\n\\t       \\n\\tb. There must exit at least cooldown day before buy the stock. So guess where DP[i][1] come from?  the answer are : DP[i-1][1] or DP[i-2][0].\\n\\t\\n\\t   DP[i][1] = max( DP[i-1][1], DP[i-2][0] - prices[i] );\\n\\t   \\n\\t   Notice:  if i <2,  DP[i][1] = max( DP[i-1][1],  - prices[i] );    The reason is that when i <2, we don\\'t need to consider cooldown time.\\n\\n\\nSolution:\\n```\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        // dp[ days ][ holdstatus ], status: 0 -> not hold, 1 -> hold\\n        \\n        if(prices.empty()) return 0;\\n        \\n        int n = prices.size();\\n        vector< vector<int> > dp( n, vector<int>(2,0) );\\n        \\n        dp[0][0] = 0;\\n        dp[0][1] = -prices[0];\\n        \\n        for( int i = 1 ; i < n ; i++ ){\\n            \\n            \\n            dp[i][0] = max( dp[i-1][0], dp[i-1][1] + prices[i] );\\n            \\n            dp[i][1] =  dp[i-1][1];\\n            \\n            if( i-2>=0 )\\n                dp[i][1] = max( dp[i][1], dp[i-2][0] - prices[i] );\\n            else\\n                dp[i][1] = max( dp[i][1], -prices[i] );\\n\\n            \\n        }\\n\\n        return max( {dp[n-1][0], dp[n-1][1]} );\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        // dp[ days ][ holdstatus ], status: 0 -> not hold, 1 -> hold\\n        \\n        if(prices.empty()) return 0;\\n        \\n        int n = prices.size();\\n        vector< vector<int> > dp( n, vector<int>(2,0) );\\n        \\n        dp[0][0] = 0;\\n        dp[0][1] = -prices[0];\\n        \\n        for( int i = 1 ; i < n ; i++ ){\\n            \\n            \\n            dp[i][0] = max( dp[i-1][0], dp[i-1][1] + prices[i] );\\n            \\n            dp[i][1] =  dp[i-1][1];\\n            \\n            if( i-2>=0 )\\n                dp[i][1] = max( dp[i][1], dp[i-2][0] - prices[i] );\\n            else\\n                dp[i][1] = max( dp[i][1], -prices[i] );\\n\\n            \\n        }\\n\\n        return max( {dp[n-1][0], dp[n-1][1]} );\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762473,
                "title": "c-easy-recursive-dp-solution-with-some-explanation",
                "content": "So we have two choices with current stock (let\\'s say i th stock). either buy i th stock or don\\'t buy it.\\nIf we are buying current i th stock then we have to find the maximum solution recursively with one cooldown that\\'s why we jump to j+2 beacuse we are considering j th day to sell that stock.\\nIf we are not buying i th stock then just skip it.\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &dp, vector<int> &p)\\n    {\\n        if(i >= p.size()-1) return 0;\\n        int &ans = dp[i];\\n        if(ans != -1) return ans;\\n        ans = 0;\\n        for(int j = i+1; j < p.size(); j++)\\n        {\\n            if(p[i] < p[j])\\n            {\\n                ans = max(ans, solve(j+2, dp, p) + p[j]-p[i]); // if we buy current item then find when to sell \\n            }\\n        }\\n        ans = max(ans, solve(i+1, dp, p)); // don\\'t buy current item.\\n        return ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n == 0) return 0;\\n        vector<int> dp(n+1, -1);\\n        return solve(0, dp, prices);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &dp, vector<int> &p)\\n    {\\n        if(i >= p.size()-1) return 0;\\n        int &ans = dp[i];\\n        if(ans != -1) return ans;\\n        ans = 0;\\n        for(int j = i+1; j < p.size(); j++)\\n        {\\n            if(p[i] < p[j])\\n            {\\n                ans = max(ans, solve(j+2, dp, p) + p[j]-p[i]); // if we buy current item then find when to sell \\n            }\\n        }\\n        ans = max(ans, solve(i+1, dp, p)); // don\\'t buy current item.\\n        return ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n == 0) return 0;\\n        vector<int> dp(n+1, -1);\\n        return solve(0, dp, prices);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762377,
                "title": "swift-simple-sweet-solution-with-idea-and-complexity-100",
                "content": "The idea is, at each point in time, we can either buy, sell, or rest (or any other orders). The maximum at each of these actions is as follow:\\n```\\nsell = max(lastBuy + price, lastSell)\\nbuy = max(lastBuy, lastRest - price)\\nrest = lastSell // since the biggest profit while resting is from the last time we did a \"sell\"\\n```\\nWith that we have our solution:\\n**Time: O(n), Space: O(1)**\\n\\n```\\nfunc maxProfit(_ prices: [Int]) -> Int {\\n\\tvar buy = Int.min\\n\\tvar sell = 0\\n\\tvar rest = 0\\n\\n\\tfor (index, price) in prices.enumerated() {\\n\\t\\tlet lastSell = sell\\n\\t\\tsell = max(buy + price, sell)\\n\\t\\tbuy = max(buy, rest - price)\\n\\t\\trest = lastSell\\n\\t}\\n\\n\\treturn max(sell, rest)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nsell = max(lastBuy + price, lastSell)\\nbuy = max(lastBuy, lastRest - price)\\nrest = lastSell // since the biggest profit while resting is from the last time we did a \"sell\"\\n```\n```\\nfunc maxProfit(_ prices: [Int]) -> Int {\\n\\tvar buy = Int.min\\n\\tvar sell = 0\\n\\tvar rest = 0\\n\\n\\tfor (index, price) in prices.enumerated() {\\n\\t\\tlet lastSell = sell\\n\\t\\tsell = max(buy + price, sell)\\n\\t\\tbuy = max(buy, rest - price)\\n\\t\\trest = lastSell\\n\\t}\\n\\n\\treturn max(sell, rest)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 595345,
                "title": "dp-solution-beat-100-in-time-complexity",
                "content": "# Method#1\\nUsing Naive way to brute force all the possibility.\\nRecursion Tree will have n level due to n business date to trade.\\nEach branch in each level will split into 3 new branch with operations: buy, sell and nothing.\\nTime Complexity: O(n^3)\\nSpace Complexity: O(n)\\n\\n# Method#2\\nUsing Dynamic Programming to Solve this question. \\nBefore using DP, we should clarify 4 things: State, Target, Base Case and Algorithm/Transfer State.\\n\\n1. State\\nhold[i]: the maximum profit to hold stock at position/date i\\nunhold[]: the maximum profit to unhold stock at position/date i\\n\\n2. Target\\nreturn unhold[n - 1]\\n\\n3. Base Case\\nunhold[0] = 0\\nhold[0]   = -profit[0]\\n\\n4. Algorithm / Transfer State\\nunhold[i] has two option at date i:\\n    a. Sell the stock: unhold[i] = hold[i - 1] + profit[i]\\n    b. Have no stock:  unhold[i] = unhold[i - 1]\\nhold[i] has two option at date i:\\n    a. Buy the stock:  hold[i] = unhold[i - 2] - profit[i]\\n    b. Keep the stock: hold[i] = hold[i - 1]\\n\\t\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length <= 1){\\n            return 0;\\n        }\\n        int n = prices.length;\\n        int[] unhold = new int[n];\\n        int[] hold = new int[n];\\n        hold[0] = -1 * prices[0];\\n        for(int i = 1; i < n; i++) {\\n            unhold[i] = Math.max(hold[i - 1] + prices[i], unhold[i - 1]);\\n            if(i == 1) {\\n                hold[i] = Math.max(unhold[0] - prices[1], hold[0]);\\n            } else {\\n                hold[i] = Math.max(unhold[i - 2] - prices[i], hold[i - 1]);\\n            }\\n        }\\n        return unhold[n - 1];\\n    }\\n}\\n```\\nExample:\\n[1,2,3,0,2]\\nunhold: 0   1   2   2   3 <- TargetValue\\nhold  :-1  -1  -1   1  whatever\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n\\n# Improve Method#2\\nImprove the space complexity by using only 4 variables.\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length <= 1){\\n            return 0;\\n        }\\n        int n = prices.length;\\n        int unhold0 = 0, hold0 = -1 * prices[0];\\n        int unhold1 = Math.max(hold0 + prices[1], unhold0), hold1 = Math.max(unhold0 - prices[1], hold0);\\n        for(int i = 2; i < n; i++) {\\n            int prevUnhold1 = unhold1, prevHold1 = hold1;\\n            unhold1 = Math.max(hold1 + prices[i], unhold1);\\n            hold1 = Math.max(unhold0 - prices[i], hold1);\\n            \\n            unhold0 = prevUnhold1;\\n            hold0 = prevHold1;\\n        }\\n        return unhold1;\\n    }\\n}\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length <= 1){\\n            return 0;\\n        }\\n        int n = prices.length;\\n        int[] unhold = new int[n];\\n        int[] hold = new int[n];\\n        hold[0] = -1 * prices[0];\\n        for(int i = 1; i < n; i++) {\\n            unhold[i] = Math.max(hold[i - 1] + prices[i], unhold[i - 1]);\\n            if(i == 1) {\\n                hold[i] = Math.max(unhold[0] - prices[1], hold[0]);\\n            } else {\\n                hold[i] = Math.max(unhold[i - 2] - prices[i], hold[i - 1]);\\n            }\\n        }\\n        return unhold[n - 1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length <= 1){\\n            return 0;\\n        }\\n        int n = prices.length;\\n        int unhold0 = 0, hold0 = -1 * prices[0];\\n        int unhold1 = Math.max(hold0 + prices[1], unhold0), hold1 = Math.max(unhold0 - prices[1], hold0);\\n        for(int i = 2; i < n; i++) {\\n            int prevUnhold1 = unhold1, prevHold1 = hold1;\\n            unhold1 = Math.max(hold1 + prices[i], unhold1);\\n            hold1 = Math.max(unhold0 - prices[i], hold1);\\n            \\n            unhold0 = prevUnhold1;\\n            hold0 = prevHold1;\\n        }\\n        return unhold1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562679,
                "title": "java-dp-solution-explained",
                "content": "Clearly we can either buy, sell, or cooldown (i.e do nothing with) a stock. \\nConditions as per the problem:\\n1. Cooldown immediately follows a sell. \\n2. Cannot sell without buying\\n3. Cannot hold more than 1 stock at a time. \\n\\nGoal: Maximise profit with the above 3 operations (Buy, Sell, Cooldown).\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n      if(prices.length == 0) return 0;\\n        \\n      int[] profitAfterBuying = new int[prices.length];\\n      int[] profitAfterSelling = new int[prices.length];\\n      int[] profitAfterDoingNothing = new int[prices.length];\\n        \\n      profitAfterBuying[0]= -prices[0]; //After buying the stock at index 0, profit is neg, because we have not sold it yet.\\n      profitAfterDoingNothing[0] = 0; \\n      profitAfterSelling[0] = 0; \\n        \\n      for(int i = 1; i < prices.length; i++){\\n          profitAfterBuying[i] = Math.max(profitAfterBuying[i-1],profitAfterDoingNothing[i-1] - prices[i]); //Operation 1: Explained after the code\\n          profitAfterDoingNothing[i] = Math.max(profitAfterDoingNothing[i-1],profitAfterSelling[i-1]); //Operation 2: Explained after the code\\n          profitAfterSelling[i] = Math.max(profitAfterBuying[i-1] + prices[i],profitAfterSelling[i-1]); //Operation 3: Explained after the code\\n      }\\n        \\n      return Math.max(profitAfterSelling[prices.length -1],profitAfterDoingNothing[prices.length-1]);\\n    }\\n}\\n```\\n\\nOperations explained:\\n\\n1. `profitAfterBuying[i]`  - To buy a stock at index `i` , a cooldown is presumed at or before index `i-1`.\\nTherefore `profitAfterBuying[i] = Math.max(profitAfterBuying[i-1],profitAfterDoingNothing[i-1] - prices[i]);`\\nWhere `profitAfterBuying[i-1]` - Is the profit after buying stock at index `i-1`.\\n`profitAfterDoingNothing[i-1] - prices[i]` - profit after buying the stock at index `i`, with profit earned till `i-1`, given cooldown at `i-1`. \\n\\n2. `profitAfterDoingNothing[i]` - Profit after cooldown at `i`, a cooldown usually follows either another cooldown or sell.\\nTherefore `profitAfterDoingNothing[i] = Math.max(profitAfterDoingNothing[i-1],profitAfterSelling[i-1]);`\\nWhere `profitAfterDoingNothing[i-1]` - Profit earned given cooldown at `i`\\n`profitAfterSelling[i-1]` - Profit earned given a stock at index `i` is sold.\\n\\n3. `profitAfterSelling[i]` - To sell a stock at index `i`, we should have bought a stock at `i-1`\\nTherefore` profitAfterSelling[i] = Math.max(profitAfterBuying[i-1] + prices[i],profitAfterSelling[i-1]);`\\nWhere `profitAfterBuying[i-1] + prices[i]` - Total profit after selling at index `i`\\n`profitAfterSelling[i-1] `- Profit after selling at `i-1`, will equal `profitAfterSelling[i]` if selling a stock at index `i` is not profitable.\\n\\nAs we observe in the code above, we only need data at indexes `i-1` and `i`, therefore we can substitute arrays with prev. and current variables. \\n```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n      if(prices.length == 0) return 0;\\n        \\n      int currentProfitAfterBuying = 0;\\n      int currentProfitAfterSelling = 0;\\n      int currentProfitAfterDoingNothing = 0;\\n        \\n      int prevProfitAfterBuying = -prices[0];\\n      int prevProfitAfterSelling = 0;\\n      int prevProfitAfterDoingNothing = 0;\\n        \\n      for(int i = 1; i < prices.length; i++){\\n          currentProfitAfterBuying = Math.max(prevProfitAfterBuying , prevProfitAfterDoingNothing - prices[i]);\\n          currentProfitAfterDoingNothing = Math.max(prevProfitAfterDoingNothing , prevProfitAfterSelling);\\n          currentProfitAfterSelling = Math.max(prevProfitAfterBuying + prices[i], prevProfitAfterSelling);\\n          \\n          prevProfitAfterBuying = currentProfitAfterBuying;\\n          prevProfitAfterSelling = currentProfitAfterSelling;\\n          prevProfitAfterDoingNothing = currentProfitAfterDoingNothing;\\n      }\\n        \\n      return Math.max(currentProfitAfterSelling, currentProfitAfterDoingNothing);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n      if(prices.length == 0) return 0;\\n        \\n      int[] profitAfterBuying = new int[prices.length];\\n      int[] profitAfterSelling = new int[prices.length];\\n      int[] profitAfterDoingNothing = new int[prices.length];\\n        \\n      profitAfterBuying[0]= -prices[0]; //After buying the stock at index 0, profit is neg, because we have not sold it yet.\\n      profitAfterDoingNothing[0] = 0; \\n      profitAfterSelling[0] = 0; \\n        \\n      for(int i = 1; i < prices.length; i++){\\n          profitAfterBuying[i] = Math.max(profitAfterBuying[i-1],profitAfterDoingNothing[i-1] - prices[i]); //Operation 1: Explained after the code\\n          profitAfterDoingNothing[i] = Math.max(profitAfterDoingNothing[i-1],profitAfterSelling[i-1]); //Operation 2: Explained after the code\\n          profitAfterSelling[i] = Math.max(profitAfterBuying[i-1] + prices[i],profitAfterSelling[i-1]); //Operation 3: Explained after the code\\n      }\\n        \\n      return Math.max(profitAfterSelling[prices.length -1],profitAfterDoingNothing[prices.length-1]);\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n      if(prices.length == 0) return 0;\\n        \\n      int currentProfitAfterBuying = 0;\\n      int currentProfitAfterSelling = 0;\\n      int currentProfitAfterDoingNothing = 0;\\n        \\n      int prevProfitAfterBuying = -prices[0];\\n      int prevProfitAfterSelling = 0;\\n      int prevProfitAfterDoingNothing = 0;\\n        \\n      for(int i = 1; i < prices.length; i++){\\n          currentProfitAfterBuying = Math.max(prevProfitAfterBuying , prevProfitAfterDoingNothing - prices[i]);\\n          currentProfitAfterDoingNothing = Math.max(prevProfitAfterDoingNothing , prevProfitAfterSelling);\\n          currentProfitAfterSelling = Math.max(prevProfitAfterBuying + prices[i], prevProfitAfterSelling);\\n          \\n          prevProfitAfterBuying = currentProfitAfterBuying;\\n          prevProfitAfterSelling = currentProfitAfterSelling;\\n          prevProfitAfterDoingNothing = currentProfitAfterDoingNothing;\\n      }\\n        \\n      return Math.max(currentProfitAfterSelling, currentProfitAfterDoingNothing);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313201,
                "title": "intuitive-python-solution",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tif len(prices) < 2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdp1 = [0 for i in range(len(prices))] #max money u can have,holding a stock on ith day\\n\\t\\t\\tdp2 = [0 for i in range(len(prices))] #max money u can have,sold a stock on ith day\\n\\t\\t\\tdp3 = [0 for i in range(len(prices))] #max money u can have,did not do anything on ith day,not holding anything\\n\\t\\t\\tdp1[0] = prices[0] * -1\\n\\n\\t\\t\\tfor i in range(1,len(prices)):\\n\\t\\t\\t\\tdp1[i] = max(dp3[i - 1] - prices[i],dp1[i - 1])\\n\\t\\t\\t\\tdp2[i] = dp1[i - 1] + prices[i]\\n\\n\\t\\t\\t\\tdp3[i] = max(dp3[i - 1],dp2[i - 1] if i > 1 else 0)\\n\\t\\t\\treturn max(dp2[-1],dp1[-1] + prices[-1],dp3[-1])\\nPersonally I think this is more intuitive, comparing to the solutions using 2 dp arrays, which only have the state for holding and not holding. Since there is a cooldown time, I used the third dp array to denote the state for not holding any stock and did not do anything on ith day, which includes the cool down time.\\n\\n",
                "solutionTags": [],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tif len(prices) < 2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdp1 = [0 for i in range(len(prices))] #max money u can have,holding a stock on ith day\\n\\t\\t\\tdp2 = [0 for i in range(len(prices))] #max money u can have,sold a stock on ith day\\n\\t\\t\\tdp3 = [0 for i in range(len(prices))] #max money u can have,did not do anything on ith day,not holding anything\\n\\t\\t\\tdp1[0] = prices[0] * -1\\n\\n\\t\\t\\tfor i in range(1,len(prices)):\\n\\t\\t\\t\\tdp1[i] = max(dp3[i - 1] - prices[i],dp1[i - 1])\\n\\t\\t\\t\\tdp2[i] = dp1[i - 1] + prices[i]\\n\\n\\t\\t\\t\\tdp3[i] = max(dp3[i - 1],dp2[i - 1] if i > 1 else 0)\\n\\t\\t\\treturn max(dp2[-1],dp1[-1] + prices[-1],dp3[-1])\\nPersonally I think this is more intuitive, comparing to the solutions using 2 dp arrays, which only have the state for holding and not holding. Since there is a cooldown time, I used the third dp array to denote the state for not holding any stock and did not do anything on ith day, which includes the cool down time.\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 300675,
                "title": "java-solution-o-n-time-explanation",
                "content": "This one was a little crazier than the \"find best time to sell stock\" problem. It took me quite a while to figure this out and here\\'s my thought process.\\n\\nEssentially, the problem is that at any index in the array, you are faced with 3 decisions: buy, sell, or cooldown/rest. This means it may be easier to think about a solution where you can store decisions in separate arrays and then check them later, but that is in fact the more complicated solution.\\n\\nAn easier solution is to take away cooldown and just think about a similar problem: buy and then sell stock, multiple transactions allowed, and no cooldown. In such a problem, you only have to decide on two things: buy or sell. That\\'s kind of easier.\\n\\nThen to make it even easier, you can think about the other problem that I mentioned above: what if you can only buy and then sell once? Well, it\\'s plain simple: find the difference between the element at the current index, and whichever value that was the smallest that came before it, then check to see if that\\'s already the max difference value. Here\\'s my solution to that one (it\\'s also leetcode and this is an accepted answer):\\n\\n```\\nclass Solution {\\n    public int maxProfitSingleTransaction(int[] prices) {\\n        int smallest = Integer.MAX_VALUE;\\n        int max_diff = 0;\\n        \\n        for(int i=0; i<prices.length; i++) {\\n\\t\\t    smallest = Math.min(smallest, prices[i]);\\n\\t\\t\\tmax_diff = Math.max(max_diff, prices[i] - smallest);\\n        }\\n        \\n        return max_diff;\\n    }\\n}\\n```\\n\\nThat was pretty straight-forward. It was exactly how you would describe it verbally. Now, how do you achieve the same thing when you are allowed multiple transactions? When you are allowed multiple transactions, one situation that may arise is: you will have the best times to buy and sell, just like with the single transaction, but how does that compare to doing multiple smaller transactions with profits that stack up over the duration of that single transaction?\\n\\nThat sounds complicated. Here\\'s a simpler version: what if instead of profit, you keep track of funding? Assume you start out with 0 funding, then that means any amount different than that is actually your profit. Buying decreases your funding (well, you have to pay to buy stock after all), and selling increases your funding.\\n\\nHere\\'s my solution to that problem. It\\'s also on leet code and this is an accepted solution:\\n\\n```\\nclass Solution {\\n    public int maxProfitMultipleTransactions(int[] prices) {\\n        int fund_sel = Integer.MIN_VALUE; // funding for selling\\n        int fund_buy = 0; // funding for buying\\n        \\n        for(int i=0; i<prices.length; i++) {\\n\\t\\t    // buy if we get more funds \\n            fund_sel = Math.max(fund_sel, fund_buy - prices[i]);\\n\\t\\t\\t// sell if we get more funds\\n            fund_buy = Math.max(fund_buy, fund_sel + prices[i]);\\n\\t\\t\\t// also buying and selling on the same day counts\\n        }\\n        \\n        return fund_buy;\\n    }\\n}\\n```\\n\\nAnd that\\'s the one with multiple transactions. The thought process just shifted from keeping track of a max difference to having fundings/wells/etc... but the concept is practically the same. Because we start out at 0, it means the difference to 0 really is just the value, and that difference is still the profit that we want.\\n\\nHaving cooldown is basically just taking the above solution and adding a third variable to \"delay\" by one transaction every time.\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int fund_sel = Integer.MIN_VALUE; // fund_sel from above\\n        int fund_buy = 0; // fund_buy from above\\n        int delay = 0; // cooldown needs a delay\\n        \\n        for(int i=0; i<prices.length; i++) {\\n            fund_sel = Math.max(fund_sel, delay - prices[i]); // time to buy? (delayed!)\\n            delay = fund_buy; // delay funding by one iteration after we sell\\n            fund_buy = Math.max(fund_buy, fund_sel + prices[i]); // time to sell?\\n        }\\n        \\n        return fund_buy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitSingleTransaction(int[] prices) {\\n        int smallest = Integer.MAX_VALUE;\\n        int max_diff = 0;\\n        \\n        for(int i=0; i<prices.length; i++) {\\n\\t\\t    smallest = Math.min(smallest, prices[i]);\\n\\t\\t\\tmax_diff = Math.max(max_diff, prices[i] - smallest);\\n        }\\n        \\n        return max_diff;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfitMultipleTransactions(int[] prices) {\\n        int fund_sel = Integer.MIN_VALUE; // funding for selling\\n        int fund_buy = 0; // funding for buying\\n        \\n        for(int i=0; i<prices.length; i++) {\\n\\t\\t    // buy if we get more funds \\n            fund_sel = Math.max(fund_sel, fund_buy - prices[i]);\\n\\t\\t\\t// sell if we get more funds\\n            fund_buy = Math.max(fund_buy, fund_sel + prices[i]);\\n\\t\\t\\t// also buying and selling on the same day counts\\n        }\\n        \\n        return fund_buy;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int fund_sel = Integer.MIN_VALUE; // fund_sel from above\\n        int fund_buy = 0; // fund_buy from above\\n        int delay = 0; // cooldown needs a delay\\n        \\n        for(int i=0; i<prices.length; i++) {\\n            fund_sel = Math.max(fund_sel, delay - prices[i]); // time to buy? (delayed!)\\n            delay = fund_buy; // delay funding by one iteration after we sell\\n            fund_buy = Math.max(fund_buy, fund_sel + prices[i]); // time to sell?\\n        }\\n        \\n        return fund_buy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206433,
                "title": "c-dp-thought-process-behind-the-idea-how-i-thought-about-o-1-space-complexity-99",
                "content": "/*******************  **IDEA** *****************/\\n/* The solution is derived from approach shared by one of my friends.\\n * **The solution involves DP.**\\n * On a given day, we can BUY, SELL, or COOLDOWN.\\n * The conditions:\\n * a) **COOLDOWN**: There are no conditions for doing cooldown on a day.\\n * b) **BUY**: To buy or \"*own*\" a stock on \"i\"th day, we must not \"own\" any stock by the end of day \"i - 2\". This is because,\\n   if we want to buy on ith day, then \"i - 1\"th day must be a cooldown and before that we must   not own any stock.\\n * c) **SELL**: To sell or \"*notown*\" a stock on \"i\"th day, we must \"own\" a stock by the end of \"i - 1\"th day.\\n * Let *own[i]* represent the profit by owning a stock by the end of day \"i\".\\n * Let *notown[i]* represent the profit by not owning any stock by the end of day \"i\".\\n * ``` own[i] = max(own[i - 1], not_own[i - 2] - price[i]);``` // either don\\'t buy or buy it today\\n * ```not_own[i] = max(not_own[i - 1], own[i - 1] + price[i]);``` // either don\\'t sell or sell it today \\n * IT IS CLEARY VISIBLE THAT OPERATION ON DAY \"i\" DEPENDS ONLY ON DAY \"i - 1\" AND \"i - 2\". SO IT CAN BE DONE IS O(1) SPACE.\\n*/\\n```\\nClass Solution{\\npublic:\\n    int maxProfit(vector<int> &prices){\\n    int n = prices.length();\\n    if(n < 1)\\n        return 0;\\n    int own_last = -prices[0];\\n    int own_last_prev = 0;\\n    int not_own_last = 0;\\n    not_own_last_prev = 0;\\n    int profit = 0;\\n    for(int i = 1; i < n; ++i)\\n    {\\n        int own = max(own_last, not_own_last_prev - prices[i]);\\n        int not_own = max(not_own_last, own_last + prices[i]);\\n\\n        own_last_prev = own_last;\\n        own_last = own;\\n        not_own_last_prev = not_own_last;\\n        not_own_last = not_own;\\n        profit = max(profit, max(own, not_own));\\n    }\\n\\n    return profit;\\n    }\\n}\\nYour upvotes will help me write more elegant solutions. Thanks.\\n```",
                "solutionTags": [],
                "code": "``` own[i] = max(own[i - 1], not_own[i - 2] - price[i]);```\n```not_own[i] = max(not_own[i - 1], own[i - 1] + price[i]);```\n```\\nClass Solution{\\npublic:\\n    int maxProfit(vector<int> &prices){\\n    int n = prices.length();\\n    if(n < 1)\\n        return 0;\\n    int own_last = -prices[0];\\n    int own_last_prev = 0;\\n    int not_own_last = 0;\\n    not_own_last_prev = 0;\\n    int profit = 0;\\n    for(int i = 1; i < n; ++i)\\n    {\\n        int own = max(own_last, not_own_last_prev - prices[i]);\\n        int not_own = max(not_own_last, own_last + prices[i]);\\n\\n        own_last_prev = own_last;\\n        own_last = own;\\n        not_own_last_prev = not_own_last;\\n        not_own_last = not_own;\\n        profit = max(profit, max(own, not_own));\\n    }\\n\\n    return profit;\\n    }\\n}\\nYour upvotes will help me write more elegant solutions. Thanks.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181524,
                "title": "c-solution-with-explanation",
                "content": "public class Solution {\n    public int MaxProfit(int[] prices) {\n        \n    if(prices == null || prices.Length <= 1) return 0;\n  \n    int b0 = -prices[0], b1 = b0;\n    int s0 = 0, s1 = 0, s2 = 0;\n \n    for(int i = 1; i < prices.Length; i++) {\n    \tb0 = Math.Max(b1, s2 - prices[i]);\n    \ts0 = Math.Max(s1, b1 + prices[i]);\n    \tb1 = b0; \n        s2 = s1; \n        s1 = s0; \n    }\n    return s0;\n\n    }\n}\n\n\n/* Explanantion  \n Define States\n\nTo represent the decision at index i:\n\nbuy[i]: Max profit till index i. The series of transaction is ending with a buy.\nsell[i]: Max profit till index i. The series of transaction is ending with a sell.\nTo clarify:\n\nTill index i, the buy / sell action must happen and must be the last action. It may not happen at index i. It may happen at i - 1, i - 2, ... 0.\nIn the end n - 1, return sell[n - 1]. Apparently we cannot finally end up with a buy. In that case, we would rather take a rest at n - 1.\nFor special case no transaction at all, classify it as sell[i], so that in the end, we can still return sell[n - 1]. Thanks @alex153 @kennethliaoke @anshu2.\n    \n2. Define Recursion\n\nbuy[i]: To make a decision whether to buy at i, we either take a rest, by just using the old decision at i - 1, or sell at/before i - 2, then buy at i, We cannot sell at i - 1, then buy at i, because of cooldown.\nsell[i]: To make a decision whether to sell at i, we either take a rest, by just using the old decision at i - 1, or buy at/before i - 1, then sell at i.\nSo we get the following formula:\n\nbuy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);   \nsell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);\n\n3. Optimize to O(1) Space\n\nDP solution only depending on i - 1 and i - 2 can be optimized using O(1) space.\n\nLet b2, b1, b0 represent buy[i - 2], buy[i - 1], buy[i]\nLet s2, s1, s0 represent sell[i - 2], sell[i - 1], sell[i]\nThen arrays turn into Fibonacci like recursion:\n\nb0 = Math.max(b1, s2 - prices[i]);\ns0 = Math.max(s1, b1 + prices[i]);\n\n4. Write Code in 5 Minutes\n\nFirst we define the initial states at i = 0:\n\nWe can buy. The max profit at i = 0 ending with a buy is -prices[0].\nWe cannot sell. The max profit at i = 0 ending with a sell is 0.\nHere is my solution. Hope it helps!\n    */",
                "solutionTags": [],
                "code": "class Solution {\n    public int MaxProfit(int[] prices) {\n        \n    if(prices == null || prices.Length <= 1) return 0;\n  \n    int b0 = -prices[0], b1 = b0;\n    int s0 = 0, s1 = 0, s2 = 0;\n \n    for(int i = 1; i < prices.Length; i++) {\n    \tb0 = Math.Max(b1, s2 - prices[i]);\n    \ts0 = Math.Max(s1, b1 + prices[i]);\n    \tb1 = b0; \n        s2 = s1; \n        s1 = s0; \n    }",
                "codeTag": "Java"
            },
            {
                "id": 151887,
                "title": "classic-dp-python-beats-97",
                "content": "    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(prices)\\n        if not prices:\\n            return 0\\n        \\n        buy = [0]*n\\n        sell = [0]*n\\n        cool = [0]*n\\n        buy[0] = -prices[0]\\n        \\n        for i in range(1, n):\\n            buy[i] = max(buy[i-1], cool[i-1] - prices[i])\\n            sell[i] = max(sell[i-1], buy[i-1] + prices[i])\\n            cool[i] = max(cool[i-1], sell[i-1])\\n        \\n        return sell[-1]",
                "solutionTags": [],
                "code": "    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(prices)\\n        if not prices:\\n            return 0\\n        \\n        buy = [0]*n\\n        sell = [0]*n\\n        cool = [0]*n\\n        buy[0] = -prices[0]\\n        \\n        for i in range(1, n):\\n            buy[i] = max(buy[i-1], cool[i-1] - prices[i])\\n            sell[i] = max(sell[i-1], buy[i-1] + prices[i])\\n            cool[i] = max(cool[i-1], sell[i-1])\\n        \\n        return sell[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 147897,
                "title": "java-o-n-time-o-1-space-solution-with-detailed-thinking-and-improving-process",
                "content": "```\\n/* Keep two DP arrays, one for sell, one for cooldown\\n * sell[i] means the maximum profit gains at day i by selling at day i\\n * cooldown[i] means the maximum profit gains at day i by doing nothing at day i\\n * Since we can never get maximum profit at day i by buying stock at day i, so do not need to consider the buy array\\n */\\n\\n/* Method 1, time O(n ^ 2), space O(n)\\n * 1. update cooldown[i] is easy, cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]);\\n * 2. for update sell[i], need to scan j from 0 -> i - 1, sell[i] will be the maximum of cooldown[j - 1] + (prices[i] - prices[j])\\n * means cooldown at day j - 1, and buy at day j, and sell at day i;\\n * 3. Pay attention to the boundy conditon, when j == 0, cooldown[j - 1] is not defined, use 0 instead\\n * 4. The maximum profit is either sell[n - 1] or cooldown[n - 1];\\n */\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0) return 0;\\n        int n = prices.length;\\n        int[] sell = new int[n];\\n        int[] cooldown = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]);\\n            for (int j = 0; j < i; j++) {\\n                if (j == 0) sell[i] = Math.max(sell[i], prices[i] - prices[j]);\\n                else sell[i] = Math.max(sell[i], cooldown[j - 1] + prices[i] - prices[j]);\\n            }\\n        }\\n        return Math.max(sell[n - 1], cooldown[n - 1]);\\n    }\\n}\\n\\n/* Method 2, time O(n), space O(n)\\n * In the previous method, for updating sell[i], we need to scan from 0 -> i - 1, but if you pay attention to the transition expression, \\n * all we need is the maximum of cooldown[j - 1] - prices[j] from j = 0 -> j= i - 1, \\n * so we can use a variable diff to store this value, to avoid the loop;\\n * then the time expense will be just O(n)...\\n */\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0) return 0;\\n        int n = prices.length;\\n        int[] sell = new int[n];\\n        int[] cooldown = new int[n];\\n        int diff = -prices[0];\\n        for (int i = 1; i < n; i++) {\\n            cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]);\\n            sell[i] = Math.max(sell[i], prices[i] + diff);\\n            diff = Math.max(diff, cooldown[i - 1] - prices[i]);\\n        }\\n        return Math.max(sell[n - 1], cooldown[n - 1]);\\n    }\\n}\\n\\n\\n/* Method 3, time O(n), space O(1)\\n * If you take a look at method 2, when we update cooldown[i] or sell[i], we only need variable from i - 1;\\n * thus there is no need to store the whole array, we can just use two variables to store the data\\n * so the space cost wil be O(1)\\n */\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0) return 0;\\n        int n = prices.length;\\n        int sell = 0;\\n        int cooldown = 0;\\n        int diff = -prices[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = cooldown;\\n            cooldown = Math.max(cooldown, sell);\\n            sell = Math.max(sell, prices[i] + diff);\\n            diff = Math.max(diff, temp - prices[i]);\\n        }\\n        return Math.max(sell, cooldown);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0) return 0;\\n        int n = prices.length;\\n        int[] sell = new int[n];\\n        int[] cooldown = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]);\\n            for (int j = 0; j < i; j++) {\\n                if (j == 0) sell[i] = Math.max(sell[i], prices[i] - prices[j]);\\n                else sell[i] = Math.max(sell[i], cooldown[j - 1] + prices[i] - prices[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3797822,
                "title": "c-memoization-soln-100-beats-0ms",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& dp,vector<int>& prices,int idx,int buy){\\n        if(idx>=prices.size()-1){\\n            if(buy){\\n                return 0;\\n            }\\n            else{\\n                if(idx==prices.size()-1){\\n                    return prices[idx];\\n                }\\n                else{\\n                    return 0;\\n                }\\n            }\\n        }\\n        if(dp[idx][buy]!=-1){\\n            return dp[idx][buy];\\n        }\\n        if(buy){\\n            int take = -prices[idx] + solve(dp,prices,idx+1,1-buy);\\n            int nottake = 0 + solve(dp,prices,idx+1,buy);\\n            return dp[idx][buy] = max(take,nottake);\\n        }\\n        else{\\n            int take = prices[idx] + solve(dp,prices,idx+2,1+buy);\\n            int nottake = 0 + solve(dp,prices,idx+1,buy);\\n            return dp[idx][buy] = max(take,nottake);\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2,-1));\\n        return solve(dp,prices,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& dp,vector<int>& prices,int idx,int buy){\\n        if(idx>=prices.size()-1){\\n            if(buy){\\n                return 0;\\n            }\\n            else{\\n                if(idx==prices.size()-1){\\n                    return prices[idx];\\n                }\\n                else{\\n                    return 0;\\n                }\\n            }\\n        }\\n        if(dp[idx][buy]!=-1){\\n            return dp[idx][buy];\\n        }\\n        if(buy){\\n            int take = -prices[idx] + solve(dp,prices,idx+1,1-buy);\\n            int nottake = 0 + solve(dp,prices,idx+1,buy);\\n            return dp[idx][buy] = max(take,nottake);\\n        }\\n        else{\\n            int take = prices[idx] + solve(dp,prices,idx+2,1+buy);\\n            int nottake = 0 + solve(dp,prices,idx+1,buy);\\n            return dp[idx][buy] = max(take,nottake);\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2,-1));\\n        return solve(dp,prices,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118051,
                "title": "java-100-faster-easy-to-understand-using-state-transition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int cool=0,buy=-prices[0],sell=0;\\n        for(int i=1;i<n;i++){\\n            int cool_n=Math.max(cool, sell);\\n            int buy_n=Math.max(buy, cool-prices[i]);\\n            int sell_n=prices[i]+buy;\\n            cool=cool_n;\\n            buy=buy_n;\\n            sell=sell_n;\\n        }\\n        return Math.max(cool, Math.max(buy,sell));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int cool=0,buy=-prices[0],sell=0;\\n        for(int i=1;i<n;i++){\\n            int cool_n=Math.max(cool, sell);\\n            int buy_n=Math.max(buy, cool-prices[i]);\\n            int sell_n=prices[i]+buy;\\n            cool=cool_n;\\n            buy=buy_n;\\n            sell=sell_n;\\n        }\\n        return Math.max(cool, Math.max(buy,sell));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014833,
                "title": "o-n-complexity-and-intuitive-state-representation-dp-98-runtime-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- To solve the problem by Dynamic programming, we try to represent basic states and dynamics between these states. In this solution,  $dp[t][s], s = 0/1$ denotes the maximum profit we could get **at state s at the end of time t** .\\n- state 1 denotes holding the stock. (which means we buy or just hold at time t)\\n- state 0 denotes not holding the wtock. (which mean we sell or just wait at time t)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The dynamic between states 0 and 1 under the cooldown condition could be easily represented. \\n\\n***While we hold the stock at t, either we hold it from time k-1 or we buy it newly, so we need to pay prices[k] as cost.*** We use $dp[k-2][0]$ rather than $dp[k-1][0]$ to take the cooldown condition into consideration.\\n\\n- $$dp[k][1] = max(dp[k-1][1], dp[k-2][0] - prices[k])$$ \\n\\n***While we don\\'t hold the stock at t, either we don\\'t hold it from time k-1 or we sell it newly, so we could get price[k] as profit.***\\n- $$dp[k][0] = max(dp[k-1][0], dp[k-1][1] + prices[k])$$\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Could optimize more\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        if len(prices) == 1:\\n            return 0\\n\\n        # Initialization the first 2 timestamp\\n        dp = [[0] * 2 for _ in range(len(prices))]\\n        dp[0][0] = 0\\n        dp[0][1] = -prices[0]\\n        dp[1][0] = max(0, prices[1] - prices[0])\\n        dp[1][1] = -min(prices[0], prices[1])\\n        \\n        for k in range(2, len(prices)):\\n            # at the end of time k with a state of 1, calculate the maximum profit\\n            dp[k][1] = max(dp[k-1][1], dp[k-2][0] - prices[k]) \\n            # at the end of time k with a state of 0, calculate the maximum profit\\n            dp[k][0] = max(dp[k-1][0], dp[k-1][1] + prices[k]) \\n            \\n\\n        return dp[-1][0]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        if len(prices) == 1:\\n            return 0\\n\\n        # Initialization the first 2 timestamp\\n        dp = [[0] * 2 for _ in range(len(prices))]\\n        dp[0][0] = 0\\n        dp[0][1] = -prices[0]\\n        dp[1][0] = max(0, prices[1] - prices[0])\\n        dp[1][1] = -min(prices[0], prices[1])\\n        \\n        for k in range(2, len(prices)):\\n            # at the end of time k with a state of 1, calculate the maximum profit\\n            dp[k][1] = max(dp[k-1][1], dp[k-2][0] - prices[k]) \\n            # at the end of time k with a state of 0, calculate the maximum profit\\n            dp[k][0] = max(dp[k-1][0], dp[k-1][1] + prices[k]) \\n            \\n\\n        return dp[-1][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942941,
                "title": "c-solution-using-constant-space-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust take buy and sell prices and see profit for every iteration\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlet\\'s declare \\n- **buy[i]**=maximum profit till day i with buy as last action;\\n- **sell[i]**=maximum profit till day i with sell as last action;\\nNow, we just have to find a recurrence relation with these two situations.\\n1. **buy[i] = max(buy[i-1],sell[i-2]-buy[i]);**\\n**Explanation**: let us assume that we don\\'t do any of the actions i.e. (did not buy anything on day i),that means we must have done buy action on day i-1. So buy[i-1] is giving info about that.\\nIn case, we do actually buy action on day i, the net profit will be **sell[i-2]-buy[i]** i.e *(sold item profit till day i-2) - (buy price on day i).* there must be a cooldown time between selling on day i-2 and buying on ith day , the i-1th day will be cooldown in this case\\n\\n2. **sell[i] = max(sell[i-1],buy[i-1]+prices[i]);**\\n**Explanation**: let us assume that we don\\'t do any of the actions i.e. (did not sell anything on day i),that means we must have done sell action on day i-1. So sell [i-1] is giving info about that.\\nIn case, we do actually sell action on day i, the net profit will be  **buy[i-1]+prices[i]** i.e *(profit till day i-1 with buy as last action ) - (selling price on day i)* as for selling on day i we must have bought it on previous day.\\n# Complexity\\n- Time complexity:\\n**O(n) :** as  we are only iterating through whole price vector only once.\\n\\n- Space complexity:\\n**O(1):** space only taken by variables so it will be constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint maxProfit(vector<int>& prices) \\n    {\\n        int buy /*buy[i]*/,buy_pre=INT_MIN;/*buy[i-1]*/\\n        int sell=0 /*sell[i]*/,sell_pre1=0 /*sell[i-1]*/,sell_pre2=0 /*sell[i-2]*/;\\n\\n        for(int p :prices)\\n        {   //updating buy and sell values for current p\\n            buy=max(buy_pre,sell_pre2-p);\\n            sell=max(sell_pre1,buy_pre+p);\\n            //updating buy and sell values for next iteration\\n            buy_pre = buy;\\n            sell_pre2 = sell_pre1;\\n            sell_pre1 = sell;\\n        }\\n        return sell;\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxProfit(vector<int>& prices) \\n    {\\n        int buy /*buy[i]*/,buy_pre=INT_MIN;/*buy[i-1]*/\\n        int sell=0 /*sell[i]*/,sell_pre1=0 /*sell[i-1]*/,sell_pre2=0 /*sell[i-2]*/;\\n\\n        for(int p :prices)\\n        {   //updating buy and sell values for current p\\n            buy=max(buy_pre,sell_pre2-p);\\n            sell=max(sell_pre1,buy_pre+p);\\n            //updating buy and sell values for next iteration\\n            buy_pre = buy;\\n            sell_pre2 = sell_pre1;\\n            sell_pre1 = sell;\\n        }\\n        return sell;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942500,
                "title": "pick-and-not-pick-variation",
                "content": "# CODE\\n**Recursion + Memoization Method :**\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<int> &pr , int ind , int st , vector<vector<int>> &dp)\\n    {\\n        if(ind >= pr.size())  return 0 ;\\n        if(dp[ind][st] != -1)  return dp[ind][st] ;\\n\\n        int buy=0 ; \\n        if( !st ) buy = max(-pr[ind] + fun(pr , ind+1 , 1 , dp) , fun(pr , ind+1 , 0 , dp) ) ;\\n        int sel=0 ;\\n        if( st )    sel = max( pr[ind] + fun(pr , ind+2 , 0 , dp) , fun(pr , ind+1 , 1 , dp) ) ;\\n        \\n        return dp[ind][st] = max(buy , sel) ;\\n    }\\n    int maxProfit(vector<int>& pr) {\\n        int n=pr.size() ;\\n        vector<vector<int>> dp(n , vector<int>(2 , -1)) ;\\n        return fun(pr , 0 , 0 , dp) ;\\n    }\\n};\\n```\\n\\n**Tabulation Method :**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& pr) {\\n        int n=pr.size() ;\\n        vector<vector<int>> dp(n+2 , vector<int>(2 , 0)) ;\\n\\n        for(int ind=n-1 ; ind>=0 ; ind--)\\n        {\\n            for(int st=0 ; st<2 ; st++)\\n            {\\n                int buy=0 ; \\n                if( !st) buy = max(-pr[ind] + dp[ind+1][1] , dp[ind+1][0] ) ;\\n                int sel=0 ;\\n                if( st ) sel = max( pr[ind] + dp[ind+2][0] , dp[ind+1][1] ) ;\\n                \\n                dp[ind][st] = max(buy , sel) ;\\n            }\\n        }\\n        return dp[0][0] ;\\n    }\\n};\\n```\\n# UPVOTE IF HELPFUL :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int> &pr , int ind , int st , vector<vector<int>> &dp)\\n    {\\n        if(ind >= pr.size())  return 0 ;\\n        if(dp[ind][st] != -1)  return dp[ind][st] ;\\n\\n        int buy=0 ; \\n        if( !st ) buy = max(-pr[ind] + fun(pr , ind+1 , 1 , dp) , fun(pr , ind+1 , 0 , dp) ) ;\\n        int sel=0 ;\\n        if( st )    sel = max( pr[ind] + fun(pr , ind+2 , 0 , dp) , fun(pr , ind+1 , 1 , dp) ) ;\\n        \\n        return dp[ind][st] = max(buy , sel) ;\\n    }\\n    int maxProfit(vector<int>& pr) {\\n        int n=pr.size() ;\\n        vector<vector<int>> dp(n , vector<int>(2 , -1)) ;\\n        return fun(pr , 0 , 0 , dp) ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& pr) {\\n        int n=pr.size() ;\\n        vector<vector<int>> dp(n+2 , vector<int>(2 , 0)) ;\\n\\n        for(int ind=n-1 ; ind>=0 ; ind--)\\n        {\\n            for(int st=0 ; st<2 ; st++)\\n            {\\n                int buy=0 ; \\n                if( !st) buy = max(-pr[ind] + dp[ind+1][1] , dp[ind+1][0] ) ;\\n                int sel=0 ;\\n                if( st ) sel = max( pr[ind] + dp[ind+2][0] , dp[ind+1][1] ) ;\\n                \\n                dp[ind][st] = max(buy , sel) ;\\n            }\\n        }\\n        return dp[0][0] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1724940,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1725067,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1724986,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1575155,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1572812,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1571560,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1569220,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1725471,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1725031,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1574966,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1724940,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1725067,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1724986,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1575155,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1572812,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1571560,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1569220,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1725471,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1725031,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 1574966,
                "content": [
                    {
                        "username": "qiushile",
                        "content": "How can I buy a stock with price zero??\\nWho would sold with zero? totally unreasonable set"
                    },
                    {
                        "username": "wisprp",
                        "content": "Consider it oil futures during lockdowns"
                    },
                    {
                        "username": "mikurei",
                        "content": "[@harshzala](/harshzala) that's straight up a chatgpt answer"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "You can treat these prices as a value above some price line. In this case, even a negative value would make perfect sense."
                    },
                    {
                        "username": "charonme",
                        "content": "Yes the stock buying analogy is not great, there are other unrealistic or illogical aspect of it like only buying one share and not being able to hold more shares, but on the market there really are products that sometimes get sold even at a negative price (they pay you to take it off their hands) when the ownership of the product carries some obligation with it, for example you have to buy something in the future at some price or pay a penalty or physically go take the commodity and move it to your warehouse and pay housing it or pay for disposing it when it rots. Electricity contracts can have negative prices too."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@harshzala](/harshzala) the robot is not that smart..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a promoter but one of the best explaination u can get\\nlearn and grow\\nhttps://www.youtube.com/watch?v=IGIe46xw3YY&t=803s"
                    },
                    {
                        "username": "PrickyToTheMoon2308",
                        "content": "I love Striver videos as he explains very nicely. Didn\\'t know there was a solution for this question. Thank you so much for sharing"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Good testcase : [4,3,2,10,11,0,11]"
                    },
                    {
                        "username": "IngridMorstrad",
                        "content": "The way to solve stock problems is to consider \"state\".\\n\\nWhat states are possible? Usually, you can either be holding a stock, or not.\\nIn this case, there is another state as well - cooldown.\\n\\nCombining this with the number of days (another component of the state), this gives us a 2D DP array\\n\\ndp[i][j]\\n\\nwhere i = the day\\nand j = (0 = holding a stock, 1 = cooling down, 2 = not holding a stock & ready to buy).\\n\\nSince j takes only 3 values, this can be reduced to O(1) storage (3 variables)."
                    },
                    {
                        "username": "cursydd",
                        "content": "[@Brent_Pappas](/Brent_Pappas) Yeah it can be, if you are buying today you skip the previous  day while iterating and start from i-2.   "
                    },
                    {
                        "username": "arison646",
                        "content": "Thanks dude solid tip, stopped me from looking into solution. "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Can the value of the third variable be inferred from the values of the first two?"
                    },
                    {
                        "username": "ziaee",
                        "content": "I think this graph will be helpful:\\n![image](https://assets.leetcode.com/users/ziaee/image_1562177674.png)\\n"
                    },
                    {
                        "username": "user6744c",
                        "content": "Yes it is helpful, thanks."
                    },
                    {
                        "username": "shreyas88",
                        "content": "\\nSharing my thinking and generalization of the problem for the dp approach. Hope it helps\\n\\n* States at day  i `{S1, S2, S3}`. For this problem think of states are used to denote \"hold one share so we are eligible to sell\" , \"Just sold one share, need to rest(cooldown)\" , \"Cooldown period done, eligible to buy\"\\n\\n* DP constructs the optimal solution by traversing edges between these states(more on this below)  Instead of thinking it as a conventional state machine with transitions between edges I found the below abstraction more useful. Basically we can think of the problem as nodes(think states) of a graph and a map function(think edges or actions) which takes us from `day i from day i+1`. DP constructs a path in the forward path discarding the paths which are sub-optimal. \\n\\nFor instance in the below diagram an example path for arriving at `S1 at day 3 could be E22 -> E21`\\nSimplified diagram for 2 states below to help visualize.\\n![0_1509595138261_dp.jpg](/assets/uploads/files/1509595138409-dp-resized.jpg) \\n\\n\\n* Edges can be thought of having weights here. Here weights are the profit/loss number associated with each action. We progressively accumulate profits as we traverse a path  tracking the cumulative profit per state in a DP variable.\\n\\n > The DP algorithm at each `step i` can be thought of as a choice  for every possible `State Sm` : choose an edge  from the set of all edges that takes us from state `Sk at day i-1 -> Sm at day i` such that the cumulative weight(accumulated from the beginning) is maximized. \\n\\n* It can be proven by contradiction that we indeed get an optimal solution ie max profit accumulated for each state using this algorithm at the end.  \\n>Proof: Suppose we didn't achieve the optimal solution using the DP method. It implies that at some point we took a different edge than DP solution when we arrived at some `state Sm` at `day i`( if no such edge exist then we already have the optimal solution). But we know from our DP process that the edge we chose has the maximum accumulated profit for state `Sm at day i`. Now we can simply take the same series of steps that the optimal solution traversed for `days > i` and achieve higher profit than the optimal solution. This completes the proof since DP solution is optimal."
                    },
                    {
                        "username": "viraj071",
                        "content": "I am having a tough time coming up with a brute force solution to this problem along with its complexity.\\nAny suggestions will be appreciated."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@harshzala](/harshzala) the signature is different\\ncurrently the problem has a signature of \\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n```\\nwhere is `index` coming from?\\n"
                    },
                    {
                        "username": "harshzala",
                        "content": "```\\ndef maxProfit(prices, index, buy, sell, cooldown):\\n    # base case: if the index is out of bounds, return 0\\n    if index >= len(prices):\\n        return 0\\n\\n    # if the buy and sell variables are not set, then initialize them to 0\\n    if buy is None:\\n        buy = 0\\n    if sell is None:\\n        sell = 0\\n\\n    # if we are in the cooldown period, we can only skip the day or sell the stock\\n    if cooldown > 0:\\n        return max(maxProfit(prices, index+1, buy, sell, cooldown-1), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n\\n    # if we are not in the cooldown period, we have three options: skip the day, buy the stock, or sell the stock\\n    return max(maxProfit(prices, index+1, buy, sell, 0), maxProfit(prices, index+1, buy-prices[index], sell, 0), maxProfit(prices, index+1, buy, sell+prices[index], 0))\\n```\\ni have write this code for recursive approach \\nThe function takes in an array of prices representing the price of the stock on each day, an index representing the current day, two variables buy and sell representing the maximum profit that can be made by buying and selling the stock, and a cooldown variable representing the number of days left in the cooldown period."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Try to think of Recursion solution ... like buy on first day and sell after that day or next of that day. or don't buy on first day buy on next coming day ... if this solution implemented successfully use memorisation to reduce complexity ... then try DP to reduce more complexity. If recursion solution will be implemented then it wont be tough to implement the other solution\nAlthough it just a rough idea..."
                    },
                    {
                        "username": "user-x",
                        "content": "[@carminemangione](/carminemangione) \n\nIn these types of problems you essentially need to try out all possbilities and choose the one which gives you the maximum benefit from among them. You are correct that you cannot have future sight, which is why you have to try out all the decisions for every index.\n\nYou can essentially break the problem like this for every index:\n1. Do I have stock from a previous purchase?\n2. If yes - you have further 2 choices - you can sell the stock, or you can skip the day\n3. If no - you have 2 further options - you can buy stock today or you can skip the day and decide to buy stock later on\n\nYou need to recursively try out all the solutions and select the max from among them.\n\nThis is the crux of the problem. You can obviously apply memoization to reduce the time complexity further.\n\nYou can refer to this solution of mine which has the steps commented:\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941960/java-dp-memoization-with-intuitive-comments-at-each-step/"
                    },
                    {
                        "username": "santanusen",
                        "content": "Brute force solution O(3<sup>n</sup>):\n\nAt each day ```i``` you have 3 choices:\n\n1. Buy : profit -= price[i];\n2. Sell: profit += price[i];\n3. Do nothing: profit = profit;\n\nNote: You need to be in proper state to take an action, e.g. you can sell only if you have previously bought and you must only do nothing if you have just sold etc. So, keep track of what state you are in. The states are ```BUYABLE``` (Not holding any stock, have cooled off if previously sold), ```HOLDING``` (have bought some stock previously which we have not sold yet), ```COOLING``` (just sold, must do nothing for one day to become BUYABLE).\n\nJust think of what state transitions are possible, start in the ```BUYABLE``` state. \n\nAt each day, based on current state, see what actions can be taken and recurse for next day for each of the actions."
                    },
                    {
                        "username": "harshzala",
                        "content": "you can try with dynamic programming which has time and space complexity O(n)."
                    },
                    {
                        "username": "carminemangione",
                        "content": "Actually, the problem is misstated and the test cases are wrong. When buying/selling stock you are not omniscient: you don\\'t know all of the prices. In addition, if you did, the optimization problem is wrong in the test cases. I don\\'t know how people pass this. It is an illegitimate problem"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Two essential things to think about: trying to define \\n1. what \"state\" a stock buyer could have (there are 3 states)\\n2. what \"movement\" can a stock buyer could have (there are 3 movements)\\n\\nUse states to define a DP table,\\nsome specific movement will cause a state to transit into the other state, after you figure it out, you can create DP rules easily."
                    },
                    {
                        "username": "user8228j",
                        "content": "The time constraints are tough for this one, if using DP try to not have your score/total be a state variable. Not having your total/score in your state variable (make sure you didn\\'t abstract it in there) also improves memoization."
                    },
                    {
                        "username": "mgerasym",
                        "content": "what do you mean by tough? Usual O(n) approach..."
                    },
                    {
                        "username": "patl",
                        "content": "https://github.com/xxicypatxx/Leetcode---Medium/blob/main/Recursion_and_DP/309_solution.md"
                    }
                ]
            },
            {
                "id": 2059289,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 2055649,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 2009417,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 1958176,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 1946944,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 1946617,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 1935930,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 1912554,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 1909916,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 1845685,
                "content": [
                    {
                        "username": "pansari",
                        "content": "This should be a hard problem "
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "Based on the problem description, cooldown can only happen after the sell. Isn't it? And it's not clarified that if there can be two or more continuous days of cooldown after a sell."
                    },
                    {
                        "username": "yshdhiman",
                        "content": "[1,2,4]\\noutput = 1\\nexpected = 3\\nthen where is cooldown..??????????????????????"
                    },
                    {
                        "username": "Navknight",
                        "content": "Buy at 1 and sell at 4, you dont necessarily need to sell the next day"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "This is a very good question to solve in various way, i solve this in naive way, recursive with memozation ( DP in the towndown way ) and finally is Bottom-up way. A very good exercise to understand more about DP.  "
                    },
                    {
                        "username": "lpaben62",
                        "content": "can I buy two stocks without selling them?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "no bro"
                    },
                    {
                        "username": "spookie886",
                        "content": "i cant understand the solutions, so confusing literally cant understand any of them. sigh."
                    },
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write the dp relation for the code it give TLE \n\n\nclass Solution {\npublic:\n    int func(vector<int>& prices, int i ,int e ){\n        if(i>=prices.size()) return 0;\n        if(prices[i]>e && e!=-1){\n            return max(prices[i]-e+func(prices,i+2,-1), func(prices,i+1,e) );\n        }\n        else return func(prices,i+1,prices[i]);\n    }\n    int maxProfit(vector<int>& prices) {\n        return func(prices,0,-1);\n    }\n};\n"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "A few pointers on how to approach the problem:\\n\\n1) It is similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ with just one added condition of cooldown. Solve that before this one.\\n2) At each step, you can either buy or sell the stock depending upon your last action. (Initially, you\\'re only allowed to buy. Once you have a stock, you are allowed to sell. Once you\\'ve sold the stock, you can buy a new one. Think of how to implement a toggle)\\n3) If you\\'re allowed to buy, you may choose to buy a stock (profit -= prices[i] & update index+=1), or leave it (profit remains the same, move to the next index). \\n4) If you\\'re allowed to sell, you may choose to sell a stock (profit += prices[i] &  update index+=2 because you\\'re skipping an element due to cooldown), or leave it (profit remains the same, move to the next index). "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "when I can buy Amazon share with price zero :)\\n"
                    },
                    {
                        "username": "devansh_27",
                        "content": "a tip ( tho hardly anyone would have gone into blunder like this :) ) , since i went so here it\\'s:\\n\\nsolution in which u try to to skip the one day when u sell stock and go to next\\'s next day\\n\\ndon\\'t try to put a condition inside \"sell\" section that if i+2<=prices.size() then only execute sell the stock as this will neglect the chance of buying on the last day. like suppose i=second last day then u will skip this day and recursively go towards the next day now since u did cooldown by skipping no more cooldown is needed and hence u should be able to buy last day but when i=last day then i+2<=prices.size() will still remain false and u won\\'t be able to sell the stock despite having the chance of it."
                    }
                ]
            },
            {
                "id": 1815380,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1815379,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1759592,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1725924,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1725857,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1725615,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1725552,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1725550,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1725391,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1725242,
                "content": [
                    {
                        "username": "teckyshubham",
                        "content": " `int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index,int cool){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr][cool]!=-1){\\n            return dp[index][buyPr][cool];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1,1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,cool);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=0;\\n            if(cool!=1){\\n                ansCheck1=helper(prices,true,sell,1,index+1,0)-prices[index];\\n            }\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1,0);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr][cool]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3][3];\\n        for(int [][]arr:dp){\\n            for(int []arr2:arr)\\n                Arrays.fill(arr2,-1);\\n        }\\n        return helper(prices,false,false,0,0,0);\\n        \\n    }"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Looks like someone at LC relaxed the time requirements. The same solution that was getting TLE on 1 test case passed today."
                    },
                    {
                        "username": "Tilak27",
                        "content": "I\\'ve tried a brute force approach of this problem. Can someone explain me how should I apply dp in this code? \\n `class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices) {\\n\\n        vector <int> dp(prices.size(), -1);\\n\\n        return solve(0, prices, dp);\\n        \\n    }\\n\\n    int solve(int i, vector<int> prices, vector <int> &dp) {\\n\\n        if(i >= prices.size()) return 0;\\n\\n        else if(dp[i] != -1) return dp[i];\\n\\n        int cm = 0, maxi = 0;\\n\\n\\n        for(int j = i; j < prices.size(); j++){        // j is the price of the bought stock \\n\\n            for(int k = j + 1; k < prices.size(); k++) {  // k is the selling price\\n\\n                if(prices[k] - prices[j] >= 0) {\\n\\n\\n                    cm = prices[k] - prices[j];\\n\\n                    maxi = max(maxi, cm + solve(k + 2, prices, dp));   // done k + 2 here for \\n                                                                                                    //relaxation period\\n\\n                }\\n            }\\n        }\\n        dp[i] = maxi;\\n        return maxi;\\n    }\\n};`\\n\\nIt shows 208/210 cases passed when I submit the solution with the msg that time limit is exceeded."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**if still stuck and need detailed explanation from recursion to space-optimized**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2942958/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "denar50",
                        "content": "So for those struggling. Try first solving it on paper without the cooldown."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why this code show runtime error....?\\n\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    int find(int i, int n, bool flag, vector<int>&prices, vector<vector<int>>&dp){\\n        // baase case.\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[flag][i] != -1){\\n            return dp[flag][i];\\n        }\\n        if(flag == false){\\n            int buy = (0-prices[i]) + find(i+1,n,true,prices,dp);\\n            int notbuy = 0+ find(i+1,n,false,prices,dp);\\n            ans = max(buy,notbuy);\\n        }\\n        else{\\n            int sell = prices[i]+find(i+2,n,false,prices,dp);\\n            int notsell = find(i+1,n,true,prices,dp);\\n            ans = max(sell,notsell);\\n        }\\n        dp[flag][i] = ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        // create 2d array.\\n        // 2 means flag true or fals or show row.\\n        vector<vector<int>>dp(2,vector<int>(n-1));\\n        return find(0,n,false,prices,dp);\\n    }\\n};"
                    },
                    {
                        "username": "mohmmadzaid759",
                        "content": " `class Solution {\\n\\n    int solve(int buyedStock,int i,vector<int>&prices){\\n        if(i>=prices.size()){\\n            return 0;\\n        }\\n        if(buyedStock==-1){\\n            buyedStock=prices[i];\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n        int notbought=solve(-1,i+1,prices);\\n        int sold=prices[i]-buyedStock+solve(-1,i+2,prices);\\n        int notSold=solve(buyedStock,i+1,prices);\\n        return dp[i]=max({sold,notSold,notbought});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size()==1){\\n            return 0;\\n        } \\n     \\n       return solve(-1,0,prices);\\n    }\\n};`\\n\\nCan anyone help me how can I apply dp to it this is giving tle at 206 test Case"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "Here is the recursive solution of the problem.\\nI am unable to apply dp on the following.\\nPlease help me!\\nI am always stuck in memoization.\\n\\nwhat i did in solution :\\nbasically i am iteration over the price vector with variable `i` and keeping the track if at that position there is already stock bought or not with variable `b`. if not i have 2 option -> to buy/not buy. if stock is bought, again i have 2 option -> to sell/not sell.\\n```\\nclass Solution {\\npublic:\\n    int help(int i, int b, vector<int> &v) {\\n        if(i>=v.size()) {\\n            return 0;\\n        }\\n        if(b!=-1) {\\n            return max((help(i+2, -1, v) + (v[i]-b)), help(i+1, b, v));\\n        } else {\\n            return max(help(i+1, v[i], v), help(i+1, b, v));\\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return help(0, -1, prices);\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Height Trees",
        "question_content": "<p>A tree is an undirected graph in which any two vertices are connected by&nbsp;<i>exactly</i>&nbsp;one path. In other words, any connected graph without simple cycles is a tree.</p>\n\n<p>Given a tree of <code>n</code> nodes&nbsp;labelled from <code>0</code> to <code>n - 1</code>, and an array of&nbsp;<code>n - 1</code>&nbsp;<code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an undirected edge between the two nodes&nbsp;<code>a<sub>i</sub></code> and&nbsp;<code>b<sub>i</sub></code> in the tree,&nbsp;you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>)&nbsp; are called <strong>minimum height trees</strong> (MHTs).</p>\n\n<p>Return <em>a list of all <strong>MHTs&#39;</strong> root labels</em>.&nbsp;You can return the answer in <strong>any order</strong>.</p>\n\n<p>The <strong>height</strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e1.jpg\" style=\"width: 800px; height: 213px;\" />\n<pre>\n<strong>Input:</strong> n = 4, edges = [[1,0],[1,2],[1,3]]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e2.jpg\" style=\"width: 800px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n<strong>Output:</strong> [3,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are distinct.</li>\n\t<li>The given input is <strong>guaranteed</strong> to be a tree and there will be <strong>no repeated</strong> edges.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 76055,
                "title": "share-some-thoughts",
                "content": "**See [here for a better view](http://algobox.org/minimum-height-trees/)**\\n\\nFirst let's review some statement for tree in graph theory:\\n\\n> (1) A tree is an undirected graph in which any two vertices are\\n> connected by exactly one path.\\n> \\n> (2) Any connected graph who has `n` nodes with `n-1` edges is a tree.\\n> \\n> (3) The degree of a vertex of a graph is the number of\\n> edges incident to the vertex.\\n> \\n> (4) A leaf is a vertex of degree 1. An internal vertex is a vertex of\\n> degree at least 2.\\n> \\n> (5) A path graph is a tree with two or more vertices that is not\\n> branched at all.\\n> \\n> (6) A tree is called a rooted tree if one vertex has been designated\\n> the root.\\n> \\n> (7) The height of a rooted tree is the number of edges on the longest\\n> downward path between root and a leaf.\\n\\nOK. Let's stop here and look at our problem.\\n\\nOur problem want us to find the minimum height trees and return their root labels. First we can think about a simple case -- a path graph.\\n\\nFor a path graph of `n` nodes, find the minimum height trees is trivial. Just designate the middle point(s) as roots.\\n\\nDespite its triviality, let design a algorithm to find them.\\n\\nSuppose we don't know `n`, nor do we have random access of the nodes. We have to traversal. It is very easy to get the idea of two pointers. One from each end and move at the same speed. When they meet or they are one step away, (depends on the parity of `n`), we have the roots we want.\\n\\nThis gives us a lot of useful ideas to crack our real problem.\\n\\nFor a tree we can do some thing similar. We start from every end, by end we mean vertex of degree 1 (aka leaves). We let the pointers move the same speed. When two pointers meet, we keep only one of them, until the last two pointers meet or one step away we then find the roots.\\n\\nIt is easy to see that the last two pointers are from the two ends of the longest path in the graph.\\n\\nThe actual implementation is similar to the BFS topological sort. Remove the leaves, update the degrees of inner vertexes. Then remove the new leaves. Doing so level by level until there are 2 or 1 nodes left. What's left is our answer!\\n\\nThe time complexity and space complexity are both O(n). \\n\\nNote that for a tree we always have `V = n`, `E = n-1`.\\n\\n\\n**Java**\\n\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) return Collections.singletonList(0);\\n\\n        List<Set<Integer>> adj = new ArrayList<>(n);\\n        for (int i = 0; i < n; ++i) adj.add(new HashSet<>());\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n\\n        List<Integer> leaves = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            if (adj.get(i).size() == 1) leaves.add(i);\\n\\n        while (n > 2) {\\n            n -= leaves.size();\\n            List<Integer> newLeaves = new ArrayList<>();\\n            for (int i : leaves) {\\n                int j = adj.get(i).iterator().next();\\n                adj.get(j).remove(i);\\n                if (adj.get(j).size() == 1) newLeaves.add(j);\\n            }\\n            leaves = newLeaves;\\n        }\\n        return leaves;\\n    }\\n\\t\\n    // Runtime: 53 ms\\n\\n**Python**\\n\\n    def findMinHeightTrees(self, n, edges):\\n        if n == 1: return [0] \\n        adj = [set() for _ in xrange(n)]\\n        for i, j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n\\n        leaves = [i for i in xrange(n) if len(adj[i]) == 1]\\n\\n        while n > 2:\\n            n -= len(leaves)\\n            newLeaves = []\\n            for i in leaves:\\n                j = adj[i].pop()\\n                adj[j].remove(i)\\n                if len(adj[j]) == 1: newLeaves.append(j)\\n            leaves = newLeaves\\n        return leaves\\n\\t\\t\\n    # Runtime : 104ms",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "**See [here for a better view](http://algobox.org/minimum-height-trees/)**\\n\\nFirst let's review some statement for tree in graph theory:\\n\\n> (1) A tree is an undirected graph in which any two vertices are\\n> connected by exactly one path.\\n> \\n> (2) Any connected graph who has `n` nodes with `n-1` edges is a tree.\\n> \\n> (3) The degree of a vertex of a graph is the number of\\n> edges incident to the vertex.\\n> \\n> (4) A leaf is a vertex of degree 1. An internal vertex is a vertex of\\n> degree at least 2.\\n> \\n> (5) A path graph is a tree with two or more vertices that is not\\n> branched at all.\\n> \\n> (6) A tree is called a rooted tree if one vertex has been designated\\n> the root.\\n> \\n> (7) The height of a rooted tree is the number of edges on the longest\\n> downward path between root and a leaf.\\n\\nOK. Let's stop here and look at our problem.\\n\\nOur problem want us to find the minimum height trees and return their root labels. First we can think about a simple case -- a path graph.\\n\\nFor a path graph of `n` nodes, find the minimum height trees is trivial. Just designate the middle point(s) as roots.\\n\\nDespite its triviality, let design a algorithm to find them.\\n\\nSuppose we don't know `n`, nor do we have random access of the nodes. We have to traversal. It is very easy to get the idea of two pointers. One from each end and move at the same speed. When they meet or they are one step away, (depends on the parity of `n`), we have the roots we want.\\n\\nThis gives us a lot of useful ideas to crack our real problem.\\n\\nFor a tree we can do some thing similar. We start from every end, by end we mean vertex of degree 1 (aka leaves). We let the pointers move the same speed. When two pointers meet, we keep only one of them, until the last two pointers meet or one step away we then find the roots.\\n\\nIt is easy to see that the last two pointers are from the two ends of the longest path in the graph.\\n\\nThe actual implementation is similar to the BFS topological sort. Remove the leaves, update the degrees of inner vertexes. Then remove the new leaves. Doing so level by level until there are 2 or 1 nodes left. What's left is our answer!\\n\\nThe time complexity and space complexity are both O(n). \\n\\nNote that for a tree we always have `V = n`, `E = n-1`.\\n\\n\\n**Java**\\n\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) return Collections.singletonList(0);\\n\\n        List<Set<Integer>> adj = new ArrayList<>(n);\\n        for (int i = 0; i < n; ++i) adj.add(new HashSet<>());\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n\\n        List<Integer> leaves = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            if (adj.get(i).size() == 1) leaves.add(i);\\n\\n        while (n > 2) {\\n            n -= leaves.size();\\n            List<Integer> newLeaves = new ArrayList<>();\\n            for (int i : leaves) {\\n                int j = adj.get(i).iterator().next();\\n                adj.get(j).remove(i);\\n                if (adj.get(j).size() == 1) newLeaves.add(j);\\n            }\\n            leaves = newLeaves;\\n        }\\n        return leaves;\\n    }\\n\\t\\n    // Runtime: 53 ms\\n\\n**Python**\\n\\n    def findMinHeightTrees(self, n, edges):\\n        if n == 1: return [0] \\n        adj = [set() for _ in xrange(n)]\\n        for i, j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n\\n        leaves = [i for i in xrange(n) if len(adj[i]) == 1]\\n\\n        while n > 2:\\n            n -= len(leaves)\\n            newLeaves = []\\n            for i in leaves:\\n                j = adj[i].pop()\\n                adj[j].remove(i)\\n                if len(adj[j]) == 1: newLeaves.append(j)\\n            leaves = newLeaves\\n        return leaves\\n\\t\\t\\n    # Runtime : 104ms",
                "codeTag": "Python3"
            },
            {
                "id": 827284,
                "title": "c-99-tc-with-explanation-using-bfs-top-sort",
                "content": "![image](https://assets.leetcode.com/users/images/8323cdbe-aad8-444b-9bc7-ad4667ed8a35_1599222280.0331495.png)\\n\\ncredits to @earlme for the image\\n\\ncredits to @emmm_\\n\"Basic idea: the roots of MHT must be the mid points of the longest leaf to leaf path in the tree. \\nAnd to find the longest path, we can first find the farthest leaf from any node, and then find \\nthe farthest leaf from the node found above. Then these two nodes we found are the end points\\nof the longest path. And last, we find the centers of the longest path.\"\\n\\n**Steps:**\\n\\n1.Create adjcent list(neighbors)\\n\\n2.Count in-degree of all vertices.\\n\\n3.Pick any vertex \\'v\\' which has in-degree of 0.\\n\\n4.Print \\'v\\'. Remove the vertex \\'v\\' and all edges coming out of it. Decrement in-degrees of all neighbors of vertex \\'v\\' by 1.\\n\\n5.Repeat steps 3 and 4 till u either have just 1 or 2 nodes available.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==0)\\n            return {};\\n        if(n==1)\\n            return {0};\\n        vector<int>res;\\n        vector<int>degrees(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);//creating adjacent list\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            degrees[edges[i][1]]++;//updating how many edges each node has\\n            degrees[edges[i][0]]++;\\n        }\\n        queue<int>queue;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(degrees[i]==1)//adding all the leave nodes\\n                queue.push(i);\\n        }\\n        while(!queue.empty())\\n        {\\n            res.clear();// clear vector before we start traversing level by level.\\n            int size=queue.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int cur=queue.front();\\n                queue.pop();\\n                res.push_back(cur);//adding nodes to vector.Goal is to get a vector of  just 1 or 2 nodes available.\\n                for(auto &neighbor:adj[cur])\\n                {\\n                    degrees[neighbor]--;//removing current leave nodes\\n                    if(degrees[neighbor]==1)//adding current leave nodes\\n                        queue.push(neighbor);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n**Please thumbs up if it actually helped you :)**\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==0)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 76052,
                "title": "two-o-n-solutions",
                "content": "I am sharing two of my solutions, one is based on the longest path, and the other is related to Tree DP.\\n\\n**Longest Path**\\n\\nIt is easy to see that the root of an MHT has to be the middle point (or two middle points) of the longest path of the tree.\\nThough multiple longest paths can appear in an unrooted tree, they must share the same middle point(s).\\n\\nComputing the longest path of a unrooted tree can be done, in O(n) time, by tree dp, or simply 2 tree traversals (dfs or bfs).\\nThe following is some thought of the latter.\\n\\nRandomly select a node x as the root, do a dfs/bfs to find the node y that has the longest distance from x.\\nThen y must be one of the endpoints on some longest path.\\nLet y the new root, and do another dfs/bfs. Find the node z that has the longest distance from y.\\n\\nNow, the path from y to z is the longest one, and thus its middle point(s) is the answer. [Java Solution][1]\\n\\n\\n**Tree DP**\\n\\nAlternatively, one can solve this problem directly by tree dp.\\nLet dp[i] be the height of the tree when the tree root is i.\\nWe compute dp[0] ... dp[n - 1] by tree dp in a dfs manner.\\n\\nArbitrarily pick a node, say node 0, as the root, and do a dfs.\\nWhen we reach a node u, and let T be the subtree by removing all u's descendant (see the right figure below).\\nWe maintain a variable acc that keeps track of the length of the longest path in T with one endpoint being u.\\nThen dp[u] = max(height[u], acc)\\nNote, acc is 0 for the root of the tree.\\n\\n                 |                 |\\n                 .                 .\\n                /|\\\\               /|\\\\\\n               * u *             * u *\\n                /|\\\\\\n               / | \\\\\\n              *  v  *\\n\\n. denotes a single node, and * denotes a subtree (possibly empty).\\n\\nNow it remains to calculate the new acc for any of u's child, v.\\nIt is easy to see that the new acc is the max of the following\\n \\n 1. acc + 1 --- extend the previous path by edge uv;\\n 2. max(height[v'] + 2), where v != v' --- see below for an example.\\n \\n\\n                 u\\n                /|\\n               / |\\n              v' v\\n              |\\n              .\\n              .\\n              .\\n              |\\n              .\\n\\nIn fact, the second case can be computed in O(1) time instead of spending a time proportional to the degree of u.\\nOtherwise, the runtime can be quadratic when the degree of some node is Omega(n).\\nThe trick here is to maintain two heights of each node, the largest height (the conventional height), and the second largest height\\n(the height of the node after removing the branch w.r.t. the largest height).\\n\\nTherefore, after the dfs, all dp[i]'s are computed, and the problem can be answered trivially.\\nThe total runtime is still O(n). [Java Solution][2]\\n\\n\\n  [1]: https://github.com/lydxlx1/LeetCode/blob/master/src/_310.java\\n  [2]: https://github.com/lydxlx1/LeetCode/blob/master/src/_310_1.java",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "I am sharing two of my solutions, one is based on the longest path, and the other is related to Tree DP.\\n\\n**Longest Path**\\n\\nIt is easy to see that the root of an MHT has to be the middle point (or two middle points) of the longest path of the tree.\\nThough multiple longest paths can appear in an unrooted tree, they must share the same middle point(s).\\n\\nComputing the longest path of a unrooted tree can be done, in O(n) time, by tree dp, or simply 2 tree traversals (dfs or bfs).\\nThe following is some thought of the latter.\\n\\nRandomly select a node x as the root, do a dfs/bfs to find the node y that has the longest distance from x.\\nThen y must be one of the endpoints on some longest path.\\nLet y the new root, and do another dfs/bfs. Find the node z that has the longest distance from y.\\n\\nNow, the path from y to z is the longest one, and thus its middle point(s) is the answer. [Java Solution][1]\\n\\n\\n**Tree DP**\\n\\nAlternatively, one can solve this problem directly by tree dp.\\nLet dp[i] be the height of the tree when the tree root is i.\\nWe compute dp[0] ... dp[n - 1] by tree dp in a dfs manner.\\n\\nArbitrarily pick a node, say node 0, as the root, and do a dfs.\\nWhen we reach a node u, and let T be the subtree by removing all u's descendant (see the right figure below).\\nWe maintain a variable acc that keeps track of the length of the longest path in T with one endpoint being u.\\nThen dp[u] = max(height[u], acc)\\nNote, acc is 0 for the root of the tree.\\n\\n                 |                 |\\n                 .                 .\\n                /|\\\\               /|\\\\\\n               * u *             * u *\\n                /|\\\\\\n               / | \\\\\\n              *  v  *\\n\\n. denotes a single node, and * denotes a subtree (possibly empty).\\n\\nNow it remains to calculate the new acc for any of u's child, v.\\nIt is easy to see that the new acc is the max of the following\\n \\n 1. acc + 1 --- extend the previous path by edge uv;\\n 2. max(height[v'] + 2), where v != v' --- see below for an example.\\n \\n\\n                 u\\n                /|\\n               / |\\n              v' v\\n              |\\n              .\\n              .\\n              .\\n              |\\n              .\\n\\nIn fact, the second case can be computed in O(1) time instead of spending a time proportional to the degree of u.\\nOtherwise, the runtime can be quadratic when the degree of some node is Omega(n).\\nThe trick here is to maintain two heights of each node, the largest height (the conventional height), and the second largest height\\n(the height of the node after removing the branch w.r.t. the largest height).\\n\\nTherefore, after the dfs, all dp[i]'s are computed, and the problem can be answered trivially.\\nThe total runtime is still O(n). [Java Solution][2]\\n\\n\\n  [1]: https://github.com/lydxlx1/LeetCode/blob/master/src/_310.java\\n  [2]: https://github.com/lydxlx1/LeetCode/blob/master/src/_310_1.java",
                "codeTag": "Unknown"
            },
            {
                "id": 1631179,
                "title": "c-python-3-simple-solution-w-explanation-brute-force-2x-dfs-remove-leaves-w-bfs",
                "content": "We are given a tree graph and we need to return array of nodes which when considered as roots form minimum heighted tree.\\n\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nWe can approach this problem in brute-force manner by considering each one of the nodes as root and calculating the height of the tree thus formed. Each node which leads to minimum-height tree will be pushed in an array. If a node forms a tree with smaller height that observed till now, we will clear the array and refill if we find nodes having this smaller height. Finally this array will be returned.\\n\\nTo calculate height of tree formed starting at `i` node, we will perform a dfs traversal on all its adjacent nodes  and each dfs traversal will return maximum height of tree starting at that nodes. This will be performed recursively. We will also need to maintain `seen` to mark node as visited so we dont keep revisiting same node again.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> G;\\n    vector<bool> seen;\\n    int dfs(int i) {\\n        seen[i] = true;                      // mark as visited to avoid loop\\n        int H = 1;                           // find longest path starting from i. This gives height of tree rooted at i\\n        for(auto adj : G[i])\\n            if(!seen[adj])\\n                H = max(H, 1 + dfs(adj));\\n        seen[i] = false;                     // unmark while returning so we dont need to separately clear each element for next dfs\\n        return H;\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& E) {\\n        G.resize(n); seen.resize(n);\\n        vector<int> ans;\\n        for(auto& e : E)                     // form adjacency list graph\\n            G[e[0]].push_back(e[1]),  \\n            G[e[1]].push_back(e[0]);\\n        \\n        for(int i = 0, minH = n; i < n; i++) {\\n            int H = dfs(i);\\n            if(H < minH) {                   // found smallest height till now\\n                minH = H;                    // update minH\\n                ans.clear();                 // and clear ans since all nodes in it gave larger height\\n            }\\n            if(H == minH)\\n                ans.push_back(i);           // push only those nodes which form minH tree\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n, E):\\n        G, seen = defaultdict(set), [False]*n\\n        for u,v in E:\\n            G[u].add(v)\\n            G[v].add(u)\\n            \\n        def dfs(i):\\n            if seen[i]: return 0\\n            seen[i] = True\\n            H = 1 + max((dfs(adj) for adj in G[i]), default=0)\\n            seen[i] = False\\n            return H\\n        for i in range(n):\\n            H = dfs(i)\\n            if H < min_H:\\n                min_H = H\\n                ans.clear()\\n            if H == min_H:\\n                ans.append(i)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>, where `N` is the number of nodes in given tree. Each DFS takes `O(N)` and we make `N` calls in total.\\n***Space Complexity :*** `O(N)`, required for boolean array `seen`, stroing tree in adjacency list format in `G` and for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (2x DFS to find longest path in given graph)***\\n\\nThis approach is based on observing the fact that there can be **a maximum of 2 MHTs** and the **node which yields the minimum-heighted tree is(are) the mid-point(s) of longest path in the given graph.**\\n\\nIn MHT, we want minimum distance of leaves from root node. So, it\\'s obvious that we are trying to find a node that balances the maximum distance (height) from itself to its extreme nodes. Choosing the mid nodes of longest path (let its length be `L`) will ensure that the tree has its longest 2 branches, one begin of length `\\u2308L/2\\u2309` and other of `\\u2308L/2\\u2309` or `\\u2308L/2\\u2309-1` and they will differ by atmost 1 in length. Choosing any node other than the mid nodes of longest path or nodes not in longest path would off-balance the tree and lead to bigger height which would atleast be greater than `\\u2308L/2\\u2309`. \\n\\nAlso there cant be more than 2 MHTs, `2 MHT` being possible in case of even length longest path (`L % 2 == 0`) because there exist two mid points in this case, and `1 MHT` when longest path length is odd (`L%2!=0`). \\n\\nTo find the longest path, we can choose any arbitrary node and use DFS to find the furthest node from it (call it `node1`). Then we can take that node and run another DFS to find furthest node from it (call it `node2`). We are guaranteed that `node1` and `node2` will be the ends of longest path. **[Refer this for proof.](https://cs.stackexchange.com/questions/22855/algorithm-to-find-diameter-of-a-tree-using-bfs-dfs-why-does-it-work/22886#22886)** . Finally, we can return mid-point(s) of this longest path as the root nodes of MHT(s).\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> G;\\n\\tvector<bool> seen;\\n    vector<int> dfs(int i) {\\n\\t\\t// longestPath will hold longest path found, starting from any of adjacent nodes of i\\n        vector<int> longestPath, path;\\n        seen[i] = true;                            // mark as visited to avoid loop\\n        for(auto adj : G[i])                       // run DFS from each adjacent node to find longest path\\n            if(!seen[adj]) \\n                if(size(path = dfs(adj)) > size(longestPath)) \\n                    longestPath = move(path);      // avoids copying...more info below\\n        seen[i] = false;\\n\\t\\tlongestPath.push_back(i);                  // add i itself to longest path & we get the longest path starting at i\\n        return longestPath;\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        G.resize(n); seen.resize(n);\\n        for(auto& E : edges) \\n            G[E[0]].push_back(E[1]), \\n            G[E[1]].push_back(E[0]);\\n        auto path = dfs(dfs(0)[0]);                // 1st DFS from arbitrary node(0 in this case) & another DFS from furthest node returned by 1st DFS\\n        if(size(path) & 1)                         // 1 mid-node when path length is odd, otherwise 2\\n\\t\\t    return {path[size(path)/2]};           \\n        return {path[size(path)/2], path[size(path)/2-1]};\\n    }\\n};\\n```\\n\\n**Python**\\n<blockquote>\\n<details>\\n<summary>Previous Python Code (Gives higher runtime)</summary>\\n\\nEarlier I had mentioned the below solution as the answer. Althought it works, it results in returning a new copy of list everytime resulting in higher runtime and space usage. The below solution will pass but its time complexity should probably be denoted as  <code>O(N<sup>2</sup>)</code>\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n, E):\\n        G, seen = defaultdict(set), [False]*n\\n        for u,v in E:\\n            G[u].add(v)\\n            G[v].add(u)\\n\\n        def dfs(i):\\n            if seen[i]: return []\\n            seen[i] = True\\n            longest_path = max((dfs(adj) for adj in G[i]), key=len, default=[]) + [i]\\n            seen[i] = False\\n            return longest_path\\n\\n        path = dfs(dfs(0)[0])\\n        return set([path[len(path)//2], path[(len(path)-1)//2]])\\n```\\n\\n\\n</details>\\n</blockquote>\\n\\n*Updated Version -*\\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n, E):\\n        G, seen = defaultdict(set), [False]*n\\n        for u,v in E:\\n            G[u].add(v)\\n            G[v].add(u)\\n\\n        def dfs(i):\\n            if seen[i]: return []\\n            longest_path = []\\n            seen[i] = True\\n            for adj in G[i]:\\n                if not seen[adj]:\\n                    path = dfs(adj)\\n                    if len(path) > len(longest_path):\\n                        longest_path = path\\n            longest_path += [i]\\n            seen[i] = False\\n            return longest_path\\n\\n        path = dfs(dfs(0)[0])\\n        return set([path[len(path)//2], path[(len(path)-1)//2]])\\n```\\n\\n\\n***Time Complexity :*** <code>O(N)</code>, only 2 DFS calls is made each requiring `O(N)` time. \\n\\n<blockquote>\\n<b>Que:</b> The <code>dfs</code> function returns vector/list. Won\\'t the time complexity be <code>O(N<sup>2</sup>)</code> due to copy made while returning each time?</br></br>\\n<b>Ans:</b> I will speak in regards to C++. Generally speaking, yes, I think the time complexity could have been quadratic due to copies created while returning. But in practice, most compiler enable <b> copy elison(RVO/NRVO)</b>. [Some do it by default and some with optimization flag specified (GCC does it starting from <code>\"O0\"</code> itself) LC runs the submissions with <code>-O2</code> flag so it is enabled]. </br>Combined with NRVO and <code>std::move</code>, the above code helps avoid copies while returning as well as assigning from <code>path</code> to <code>longestPath</code>. You can read more about the working here - <b><a href=\"https://stackoverflow.com/questions/12953127/\">What are copy elision and return value optimization?</a></b> and <b><a href =\"https://stackoverflow.com/questions/12604431/\">Returning an STL vector from a function - copy cost<a></b>. To verify that indeed that\\'s how it\\'s working, you can try removing the <code>std::move</code> or try running on local environment without optmization or better using the <code>-fno-elide-constructors</code> flag. You will notice much higher runtime as well as space usage.</br></br>For python, assignments and returns from a function are shallow copy of objects (unless you explicity specifiy for a deep copy). Thus we  arent completely copying a path anytime in this case either.\\n</blockquote>\\n\\n***Space Complexity :*** `O(N)`, required for boolean array `seen`, stroing tree in adjacency list format in `G` and for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Remove Leaves using BFS)***\\n\\nAnother way to find the mid-node of the tree is start from each of the leaf nodes and iteratively delete them till you are left with final 1 or 2 nodes which will be the mid-nodes. \\n\\n* We can find the leaf nodes at each iteration using the indegree of the node, i.e, the number of edges which are connected to the node. \\n* A leaf node will have an indegree of 1. \\n* The algorithm used will be similar to BFS. At each level of BFS, we will pop the leaf node and push the new nodes which become leaves after deletion of leaf nodes in the current iteration.\\n* This will continue till we are left with only 1 or 2 nodes which would be our final mid-nodes forming the MHTs.\\n\\nThe following images will illustrate the steps carried out in this approach -\\n\\n\\n<table>\\n  <tr>\\n    <th>Image</th>\\n    <th>Description</th>\\n  </tr>\\n  \\n  <tr>\\n    <td><img src=\"https://assets.leetcode.com/users/images/0b2f519a-dbd1-4ef1-be9b-1ecc89e5a763_1639659450.0837114.png\" width=600 /></td>\\n    <td>Consider we are given this tree graph. <br/> The red numbers beside nodes denote the indegree (number of edges connected to node)</td>\\n  </tr>\\n  <tr></tr>\\n  <tr>\\n    <td>\\n<img src=\"https://assets.leetcode.com/users/images/eb314160-3587-412f-90c6-fc624788acf0_1639659404.9657586.png\" width=600 /></td>\\n    <td>We start with each of the leaf nodes</br>Each of the leaf node in the current level will be deleted and</br> the indegree of each node adjacent of that leaf will be reduced accordingly </td>\\n  </tr>\\n  <tr></tr>\\n  <tr>\\n    <td><img src=\"https://assets.leetcode.com/users/images/85ed8aa1-53b7-4331-bc7a-3e7d4585ff6a_1639659462.4327981.png\" width=600 /></td>\\n    <td>The 1st level of leaf nodes were deleted. </br> We continue the same process with the new nodes that become the leaf node</td>\\n  </tr>\\n  <tr></tr>\\n  <tr>\\n    <td><img src=\"https://assets.leetcode.com/users/images/4e848e8f-276c-4132-ab08-1f543f0e5459_1639659469.7684486.png\" width=600 /></td>\\n    <td>Continue the same process with new leaf nodes</td>\\n  </tr>\\n  <tr></tr>\\n  <tr>\\n    <td><img src=\"https://assets.leetcode.com/users/images/6bdee06f-3d6a-40e9-9ac1-1e0905745084_1639659474.7049432.png\" width=600 /></td>\\n    <td>Finally only single node is left</br>When 1 or 2 nodes are left, those are final mid-nodes which form MHTs</td>\\n  </tr>\\n</table>\\n\\n<p align=middle>\\n\\n\\n**C++**\\n \\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& E) {\\n        if(!size(E)) return {0};\\n        vector<vector<int>> G(n);\\n        for(auto& e : E) \\n            G[e[0]].push_back(e[1]), \\n            G[e[1]].push_back(e[0]);\\n        vector<int> leaves, newLeaves, inDegree;\\n        for(int i = 0; i < n; i++) {\\n            if(size(G[i]) == 1)\\n                leaves.push_back(i);\\n            inDegree.push_back(size(G[i]));        // used to determine which nodes become leaves\\n        }\\n        while(n > 2) {                             // process will continue till more than 2 nodes are remaining to be deleted\\n            for(auto leaf : leaves) \\n                for(auto adj : G[leaf])            // find all nodes which are adjacent to current leaf node\\n                    if(--inDegree[adj] == 1)       // if adj becomes leaf node after removing leaf, \\n                        newLeaves.push_back(adj);  // add it as new leaf\\n            n -= size(leaves);                     // subtract the deleted leaf nodes \\n            leaves = move(newLeaves);\\n        }\\n        return leaves;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n, E):\\n        if not E: return [0]\\n        G, seen = defaultdict(set), [False]*n\\n        for u,v in E:\\n            G[u].add(v)\\n            G[v].add(u)\\n        leaves, new_leaves, in_degree = [], [], []\\n        for i in range(n):\\n            if len(G[i]) == 1:\\n                leaves.append(i)\\n            in_degree.append(len(G[i]))\\n        while n > 2:\\n            for leaf in leaves:\\n                for adj in G[leaf]:\\n                    in_degree[adj] -= 1\\n                    if in_degree[adj] == 1:\\n                        new_leaves.append(adj)\\n            n -= len(leaves)\\n            leaves = new_leaves[:]\\n            new_leaves.clear()\\n        return leaves\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, iteration continues till `n-2` nodes are deleted\\n***Space Complexity :*** `O(N)`, required for stroing  `G` and `leaves`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> G;\\n    vector<bool> seen;\\n    int dfs(int i) {\\n        seen[i] = true;                      // mark as visited to avoid loop\\n        int H = 1;                           // find longest path starting from i. This gives height of tree rooted at i\\n        for(auto adj : G[i])\\n            if(!seen[adj])\\n                H = max(H, 1 + dfs(adj));\\n        seen[i] = false;                     // unmark while returning so we dont need to separately clear each element for next dfs\\n        return H;\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& E) {\\n        G.resize(n); seen.resize(n);\\n        vector<int> ans;\\n        for(auto& e : E)                     // form adjacency list graph\\n            G[e[0]].push_back(e[1]),  \\n            G[e[1]].push_back(e[0]);\\n        \\n        for(int i = 0, minH = n; i < n; i++) {\\n            int H = dfs(i);\\n            if(H < minH) {                   // found smallest height till now\\n                minH = H;                    // update minH\\n                ans.clear();                 // and clear ans since all nodes in it gave larger height\\n            }\\n            if(H == minH)\\n                ans.push_back(i);           // push only those nodes which form minH tree\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n, E):\\n        G, seen = defaultdict(set), [False]*n\\n        for u,v in E:\\n            G[u].add(v)\\n            G[v].add(u)\\n            \\n        def dfs(i):\\n            if seen[i]: return 0\\n            seen[i] = True\\n            H = 1 + max((dfs(adj) for adj in G[i]), default=0)\\n            seen[i] = False\\n            return H\\n        for i in range(n):\\n            H = dfs(i)\\n            if H < min_H:\\n                min_H = H\\n                ans.clear()\\n            if H == min_H:\\n                ans.append(i)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> G;\\n\\tvector<bool> seen;\\n    vector<int> dfs(int i) {\\n\\t\\t// longestPath will hold longest path found, starting from any of adjacent nodes of i\\n        vector<int> longestPath, path;\\n        seen[i] = true;                            // mark as visited to avoid loop\\n        for(auto adj : G[i])                       // run DFS from each adjacent node to find longest path\\n            if(!seen[adj]) \\n                if(size(path = dfs(adj)) > size(longestPath)) \\n                    longestPath = move(path);      // avoids copying...more info below\\n        seen[i] = false;\\n\\t\\tlongestPath.push_back(i);                  // add i itself to longest path & we get the longest path starting at i\\n        return longestPath;\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        G.resize(n); seen.resize(n);\\n        for(auto& E : edges) \\n            G[E[0]].push_back(E[1]), \\n            G[E[1]].push_back(E[0]);\\n        auto path = dfs(dfs(0)[0]);                // 1st DFS from arbitrary node(0 in this case) & another DFS from furthest node returned by 1st DFS\\n        if(size(path) & 1)                         // 1 mid-node when path length is odd, otherwise 2\\n\\t\\t    return {path[size(path)/2]};           \\n        return {path[size(path)/2], path[size(path)/2-1]};\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n, E):\\n        G, seen = defaultdict(set), [False]*n\\n        for u,v in E:\\n            G[u].add(v)\\n            G[v].add(u)\\n\\n        def dfs(i):\\n            if seen[i]: return []\\n            seen[i] = True\\n            longest_path = max((dfs(adj) for adj in G[i]), key=len, default=[]) + [i]\\n            seen[i] = False\\n            return longest_path\\n\\n        path = dfs(dfs(0)[0])\\n        return set([path[len(path)//2], path[(len(path)-1)//2]])\\n```\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n, E):\\n        G, seen = defaultdict(set), [False]*n\\n        for u,v in E:\\n            G[u].add(v)\\n            G[v].add(u)\\n\\n        def dfs(i):\\n            if seen[i]: return []\\n            longest_path = []\\n            seen[i] = True\\n            for adj in G[i]:\\n                if not seen[adj]:\\n                    path = dfs(adj)\\n                    if len(path) > len(longest_path):\\n                        longest_path = path\\n            longest_path += [i]\\n            seen[i] = False\\n            return longest_path\\n\\n        path = dfs(dfs(0)[0])\\n        return set([path[len(path)//2], path[(len(path)-1)//2]])\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& E) {\\n        if(!size(E)) return {0};\\n        vector<vector<int>> G(n);\\n        for(auto& e : E) \\n            G[e[0]].push_back(e[1]), \\n            G[e[1]].push_back(e[0]);\\n        vector<int> leaves, newLeaves, inDegree;\\n        for(int i = 0; i < n; i++) {\\n            if(size(G[i]) == 1)\\n                leaves.push_back(i);\\n            inDegree.push_back(size(G[i]));        // used to determine which nodes become leaves\\n        }\\n        while(n > 2) {                             // process will continue till more than 2 nodes are remaining to be deleted\\n            for(auto leaf : leaves) \\n                for(auto adj : G[leaf])            // find all nodes which are adjacent to current leaf node\\n                    if(--inDegree[adj] == 1)       // if adj becomes leaf node after removing leaf, \\n                        newLeaves.push_back(adj);  // add it as new leaf\\n            n -= size(leaves);                     // subtract the deleted leaf nodes \\n            leaves = move(newLeaves);\\n        }\\n        return leaves;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n, E):\\n        if not E: return [0]\\n        G, seen = defaultdict(set), [False]*n\\n        for u,v in E:\\n            G[u].add(v)\\n            G[v].add(u)\\n        leaves, new_leaves, in_degree = [], [], []\\n        for i in range(n):\\n            if len(G[i]) == 1:\\n                leaves.append(i)\\n            in_degree.append(len(G[i]))\\n        while n > 2:\\n            for leaf in leaves:\\n                for adj in G[leaf]:\\n                    in_degree[adj] -= 1\\n                    if in_degree[adj] == 1:\\n                        new_leaves.append(adj)\\n            n -= len(leaves)\\n            leaves = new_leaves[:]\\n            new_leaves.clear()\\n        return leaves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630778,
                "title": "c-simple-solution-topological-sort-w-explanation",
                "content": "We need to find the minimum height trees and return the roots of those trees. There can be atmost 2 trees with minimum height. So the result vector can have atmost 2 elements. Let\\'s see how!\\n**APPROACH :** \\nConsider the two graphs shown here :![image](https://assets.leetcode.com/users/images/3470900a-c358-4c23-87f2-3ffbe75f645b_1639617504.1436307.png)\\n* For the graph with odd no. of nodes, only the node at the middle of the graph when made the root, will give a minimum height tree.\\n* For the graph with even no. of nodes, both the middle nodes when made the root give a minimum height tree.\\n\\nSo, we need to start from the leaf nodes and find a way to approach the middle nodes, add them to the result vector and return the answer.\\nHow do we do that?\\n\\n**We use Topological Sorting!**\\n* We create an array called indegree which keeps the count of the no. of edges approaching each node in the tree.\\n* We start with the nodes having the minimum indegree (ie; indegree=1, i.e the leaf nodes) and we go on removing them i.e decrementing the indegree of nodes that\\'re connected to them, until we reach the middle nodes.\\n* So we can have only one root or at max two roots for minimum height depending on tree structure as explained above.\\n*  For the implementation, we are going to use a BFS like approach.\\n*  To begin with,  all leaf node are pushed into the queue, then they are removed from the tree, next new leaf node is pushed in the queue, this procedure keeps on going until we have only 1 or 2 node in our tree, which represent the result. \\n\\n**Time Complexity :** O(V+E)\\n\\n**Space Complexity :** O(V)\\n\\n**Code :** \\nThe code uses the basic algorithm of topological sorting\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n, 0), ans; //vector<int> indegree keeps count of the number of nodes approaching a node\\n        \\n        for(auto &e : edges){   //Creating an adjacency matrix for the given graph\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0; i<n;i++){\\n            if(indegree[i]==1) q.push(i), indegree[i]--; //add all the leaf nodes to the queue\\n        } \\n        \\n        while(!q.empty()){\\n            int s = q.size();\\n            ans.clear();\\n            for(int i=0; i<s;i++){\\n                int curr = q.front(); q.pop();\\n                ans.push_back(curr);\\n                for(auto child : graph[curr]){ //For each node, attached to the leaf niodes, we decrement the indegree i.e remove the leaf nodes connected to them. We keep on doing this until we reach the middle nodes.\\n                    indegree[child]--;\\n                    if(indegree[child]==1) q.push(child);   \\n                }\\n            }\\n        }\\n        if(n==1) ans.push_back(0); //If there is only 1 node in the graph, the min height is 0, with root being \\'0\\'\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nIf you like my solution & explanation, please upvote my post :)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n, 0), ans; //vector<int> indegree keeps count of the number of nodes approaching a node\\n        \\n        for(auto &e : edges){   //Creating an adjacency matrix for the given graph\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0; i<n;i++){\\n            if(indegree[i]==1) q.push(i), indegree[i]--; //add all the leaf nodes to the queue\\n        } \\n        \\n        while(!q.empty()){\\n            int s = q.size();\\n            ans.clear();\\n            for(int i=0; i<s;i++){\\n                int curr = q.front(); q.pop();\\n                ans.push_back(curr);\\n                for(auto child : graph[curr]){ //For each node, attached to the leaf niodes, we decrement the indegree i.e remove the leaf nodes connected to them. We keep on doing this until we reach the middle nodes.\\n                    indegree[child]--;\\n                    if(indegree[child]==1) q.push(child);   \\n                }\\n            }\\n        }\\n        if(n==1) ans.push_back(0); //If there is only 1 node in the graph, the min height is 0, with root being \\'0\\'\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76104,
                "title": "c-solution-o-n-time-o-n-space",
                "content": "The basic idea is **\"keep deleting leaves layer-by-layer, until reach the root.\"**\\n\\nSpecifically, first find all the leaves, then remove them. After removing, some nodes will become new leaves. So we can continue remove them. Eventually, there is only 1 or 2 nodes left.  If there is only one node left, it is the root. If there are 2 nodes, either of them could be a possible root.\\n\\n**Time Complexity**: Since each node will be removed at most once, the complexity is **O(n)**.\\n\\nThanks for pointing out any mistakes.\\n\\n----\\n*Updates:\\nMore precisely, if the number of nodes is V, and the number of edges is E. The space complexity is O(V+2E), for storing the whole tree. The time complexity is O(E), because we gradually remove all the neighboring information. As some friends pointing out,  for a tree, if V=n, then E=n-1. Thus both time complexity and space complexity become O(n).*\\n\\n        class Solution {\\n        public:\\n            \\n            struct Node\\n            {\\n                unordered_set<int> neighbor;\\n                bool isLeaf()const{return neighbor.size()==1;}\\n            };\\n            \\n            vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n                \\n                vector<int> buffer1;\\n                vector<int> buffer2;\\n                vector<int>* pB1 = &buffer1;\\n                vector<int>* pB2 = &buffer2;\\n                if(n==1)\\n                {\\n                    buffer1.push_back(0);\\n                    return buffer1;\\n                }\\n                if(n==2)\\n                {\\n                    buffer1.push_back(0);\\n                    buffer1.push_back(1);\\n                    return buffer1;\\n                }\\n                \\n                // build the graph\\n                vector<Node> nodes(n);\\n                for(auto p:edges)\\n                {\\n                    nodes[p.first].neighbor.insert(p.second);\\n                    nodes[p.second].neighbor.insert(p.first);\\n                }\\n                \\n                // find all leaves\\n                for(int i=0; i<n; ++i)\\n                {\\n                    if(nodes[i].isLeaf()) pB1->push_back(i);\\n                }\\n    \\n                // remove leaves layer-by-layer            \\n                while(1)\\n                {\\n                    for(int i : *pB1)\\n                    {\\n                        for(auto n: nodes[i].neighbor)\\n                        {\\n                            nodes[n].neighbor.erase(i);\\n                            if(nodes[n].isLeaf()) pB2->push_back(n);\\n                        }\\n                    }\\n                    if(pB2->empty())\\n                    {\\n                        return *pB1;\\n                    }\\n                    pB1->clear();\\n                    swap(pB1, pB2);\\n                }\\n                \\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            \\n            struct Node\\n            {\\n                unordered_set<int> neighbor;\\n                bool isLeaf()const{return neighbor.size()==1;}",
                "codeTag": "Java"
            },
            {
                "id": 76064,
                "title": "c-bfs-short-clean-solution-with-explanation",
                "content": "    class Solution {\\n     public:\\n      vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        // Initialize the undirected graph\\n        vector<unordered_set<int>> adj(n);\\n        for (pair<int, int> p : edges) {\\n          adj[p.first].insert(p.second);\\n          adj[p.second].insert(p.first);\\n        }\\n        // Corner case\\n        vector<int> current;\\n        if (n == 1) {\\n          current.push_back(0);\\n          return current;\\n        }\\n        // Create first leaf layer\\n        for (int i = 0; i < adj.size(); ++i) {\\n          if (adj[i].size() == 1) {\\n            current.push_back(i);\\n          }\\n        }\\n        // BFS the graph\\n        while (true) {\\n          vector<int> next;\\n          for (int node : current) {\\n            for (int neighbor : adj[node]) {\\n              adj[neighbor].erase(node);\\n              if (adj[neighbor].size() == 1) next.push_back(neighbor);\\n            }\\n          }\\n          if (next.empty()) return current;\\n          current = next;\\n        }\\n      }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n      vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        // Initialize the undirected graph\\n        vector<unordered_set<int>> adj(n);\\n        for (pair<int, int> p : edges) {\\n          adj[p.first].insert(p.second);\\n          adj[p.second].insert(p.first);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1630864,
                "title": "c-easy-to-solve-detailed-explanation-with-dry-run",
                "content": "**Intuition**\\nSo after reading the question let\\'s understand some terminology\\'s\\n\\n```\\nAmong all possible rooted trees, those with minimum height (i.e. min(h) ) are called minimum height trees (MHTs).\\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\\n\\nA leaf node is a node with degree 1.\\n\\nIn easy way a degree of node is the the number of nodes that are connected with it \\n```\\n\\nSo coming back to intuition , the MHT will always be the middle value of all the nodes. let\\'s understand by giving an example:-\\n```\\nexample :Let\\'s have a linear path graph of 5 elements say 0-1-2-3-4 than the MHT will be element 2.  \\nIn case of even path length there will be two MHT\\'s.\\n```\\nSo to find the middle node every time we process bfs we need to cut down the leaf nodes from tree.Now to implement this we will be using BFS and counting the degree of nodes\\n[WILL GET MORE CLEAR IN DRY RUN] \\n\\n**Algorithm:-**\\nAll the variables that are declared are some standard declarations so you want get confused :)\\n1. To find Minimum we wan\\'t to cut longest[LEAF]. since the longest path always starts with leaf nodes which has degree 1 \\n2. So to do this we will be using a queue by pushing them inside it and run BFS, while processign a node .\\n3. While doing step 2 we need to take care of reducing  degree of all its neighbour\\nnodes (as we are removing the current node from the tree) and those neighbous into the queue\\n4.  [REPEAT 1,2 &3 ] . In the end the nodes that are left are the middle nodes i.e our MHT\\'s\\n\\n**Before jumping to code let\\'s take a dry run [*STRONGLY RECOMMENDED*]**\\n![image](https://assets.leetcode.com/users/images/7bdbaf63-9da0-4dc3-aa83-8eb7137f5a91_1639625015.5453258.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/bda25f9f-20d1-4202-a849-d4123074cfcf_1639625015.744037.jpeg)\\n\\n\\n**Code:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        //base case i.e only one node is available\\n        if(n==1) return vector<int>{0};\\n        \\n        //Now we need to find the list of nodes for adjacency\\n        vector<vector<int>>graph(n);\\n        \\n        //Now count the degree of nodes\\n        vector<int>degree(n,0);\\n        \\n        //populate graph adjacency list and degree count of nodes\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0], b=edges[i][1];\\n            \\n            graph[a].push_back(b);\\n            graph[b].push_back(a);\\n            degree[a]++;\\n            degree[b]++;\\n        }\\n        queue<int>queue_degree_1;\\n        \\n        //push all the nodes with degree 1\\n        for(int i=0;i<n;i++) if(degree[i]==1) queue_degree_1.push(i);\\n        \\n        //MHT root nodes\\n        vector<int>res;\\n        \\n        //Run BFS until queue is empty\\n        while(!queue_degree_1.empty()){\\n            int n = queue_degree_1.size();\\n            res.clear();//clear the root nodes\\n            \\n            //This is our level order traverse\\n            while(n--){\\n                int node = queue_degree_1.front();\\n                queue_degree_1.pop();\\n                \\n                //add current node into the root node vector\\n                res.push_back(node);\\n                \\n                //Now it\\'s time for neighbouring nodes\\n                for(int i=0;i<graph[node].size();i++){\\n                    //decrease degree of neighbour nodes and push leaff nodes intp queue\\n                    degree[graph[node][i]]--;\\n                    if(degree[graph[node][i]]==1) queue_degree_1.push(graph[node][i]);\\n                }\\n            }\\n        }\\n        \\n        return res;//root nodes of MHT\\n    }\\n};\\n```\\n\\n**TC: O(V + E)\\nSC: O(V)**\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n**Feel free to comment if you have some suggestion or if you liked my post :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nAmong all possible rooted trees, those with minimum height (i.e. min(h) ) are called minimum height trees (MHTs).\\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\\n\\nA leaf node is a node with degree 1.\\n\\nIn easy way a degree of node is the the number of nodes that are connected with it \\n```\n```\\nexample :Let\\'s have a linear path graph of 5 elements say 0-1-2-3-4 than the MHT will be element 2.  \\nIn case of even path length there will be two MHT\\'s.\\n```\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        //base case i.e only one node is available\\n        if(n==1) return vector<int>{0};\\n        \\n        //Now we need to find the list of nodes for adjacency\\n        vector<vector<int>>graph(n);\\n        \\n        //Now count the degree of nodes\\n        vector<int>degree(n,0);\\n        \\n        //populate graph adjacency list and degree count of nodes\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0], b=edges[i][1];\\n            \\n            graph[a].push_back(b);\\n            graph[b].push_back(a);\\n            degree[a]++;\\n            degree[b]++;\\n        }\\n        queue<int>queue_degree_1;\\n        \\n        //push all the nodes with degree 1\\n        for(int i=0;i<n;i++) if(degree[i]==1) queue_degree_1.push(i);\\n        \\n        //MHT root nodes\\n        vector<int>res;\\n        \\n        //Run BFS until queue is empty\\n        while(!queue_degree_1.empty()){\\n            int n = queue_degree_1.size();\\n            res.clear();//clear the root nodes\\n            \\n            //This is our level order traverse\\n            while(n--){\\n                int node = queue_degree_1.front();\\n                queue_degree_1.pop();\\n                \\n                //add current node into the root node vector\\n                res.push_back(node);\\n                \\n                //Now it\\'s time for neighbouring nodes\\n                for(int i=0;i<graph[node].size();i++){\\n                    //decrease degree of neighbour nodes and push leaff nodes intp queue\\n                    degree[graph[node][i]]--;\\n                    if(degree[graph[node][i]]==1) queue_degree_1.push(graph[node][i]);\\n                }\\n            }\\n        }\\n        \\n        return res;//root nodes of MHT\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76129,
                "title": "share-my-bfs-java-code-using-degree-with-explanation-which-beats-more-than-95",
                "content": "Basically my code starts from the leaf nodes.\\n\\nFor leaf nodes, their degree = 1, which means each of them is only connected to one node.\\n\\nIn our loop, each time we delete the leaf nodes from our graph(just by putting their degrees to 0), and meanwhile we add the new leaf nodes after deleting them(just add their connected nodes with degree as 2) to the queue.\\n\\nSo basically in the end, the nodes in the queue would be connected to no other nodes but each other. They should be the answer.\\n\\n\\n   \\tList<List<Integer>> myGraph = new ArrayList<List<Integer>>();\\n    \\tList<Integer> res = new ArrayList<Integer>();\\n    \\tif (n==1) {\\n    \\t\\tres.add(0);\\n    \\t\\treturn res;\\n    \\t}\\n        int[] degree = new int[n];\\n        for(int i=0; i<n; i++) {\\n        \\tmyGraph.add(new ArrayList<Integer>());\\n        }\\n        for(int i=0; i<edges.length; i++) {\\n        \\tmyGraph.get(edges[i][0]).add(edges[i][1]);\\n        \\tmyGraph.get(edges[i][1]).add(edges[i][0]);\\n        \\tdegree[edges[i][0]]++;\\n        \\tdegree[edges[i][1]]++;\\n        }\\n        Queue<Integer> myQueue = new ArrayDeque<Integer>();\\n        \\n        for(int i=0; i<n; i++) \\n        \\tif (degree[i]==0) \\n        \\t\\treturn res;\\n        \\telse if (degree[i]==1) {\\n        \\t\\tmyQueue.offer(i);\\n        \\t}\\n        \\n        while (!myQueue.isEmpty()) {\\n        \\tres = new ArrayList<Integer>();\\n        \\tint count = myQueue.size();\\n        \\t\\n        \\tfor(int i=0; i<count; i++){\\n        \\t\\tint curr = myQueue.poll();\\n        \\t\\tres.add(curr);\\n        \\t\\tdegree[curr]--;\\n        \\t\\tfor(int k=0; k<myGraph.get(curr).size(); k++) {\\n        \\t\\t\\tint next = myGraph.get(curr).get(k);\\n        \\t\\t\\tif (degree[next]==0) continue;\\n        \\t\\t\\tif (degree[next]==2) {\\n        \\t\\t\\t\\tmyQueue.offer(next);\\n        \\t\\t\\t}\\n    \\t\\t\\t\\tdegree[next]--;\\n        \\t\\t}\\n        \\t}      \\t\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "Basically my code starts from the leaf nodes.\\n\\nFor leaf nodes, their degree = 1, which means each of them is only connected to one node.\\n\\nIn our loop, each time we delete the leaf nodes from our graph(just by putting their degrees to 0), and meanwhile we add the new leaf nodes after deleting them(just add their connected nodes with degree as 2) to the queue.\\n\\nSo basically in the end, the nodes in the queue would be connected to no other nodes but each other. They should be the answer.\\n\\n\\n   \\tList<List<Integer>> myGraph = new ArrayList<List<Integer>>();\\n    \\tList<Integer> res = new ArrayList<Integer>();\\n    \\tif (n==1) {\\n    \\t\\tres.add(0);\\n    \\t\\treturn res;\\n    \\t}\\n        int[] degree = new int[n];\\n        for(int i=0; i<n; i++) {\\n        \\tmyGraph.add(new ArrayList<Integer>());\\n        }\\n        for(int i=0; i<edges.length; i++) {\\n        \\tmyGraph.get(edges[i][0]).add(edges[i][1]);\\n        \\tmyGraph.get(edges[i][1]).add(edges[i][0]);\\n        \\tdegree[edges[i][0]]++;\\n        \\tdegree[edges[i][1]]++;\\n        }\\n        Queue<Integer> myQueue = new ArrayDeque<Integer>();\\n        \\n        for(int i=0; i<n; i++) \\n        \\tif (degree[i]==0) \\n        \\t\\treturn res;\\n        \\telse if (degree[i]==1) {\\n        \\t\\tmyQueue.offer(i);\\n        \\t}\\n        \\n        while (!myQueue.isEmpty()) {\\n        \\tres = new ArrayList<Integer>();\\n        \\tint count = myQueue.size();\\n        \\t\\n        \\tfor(int i=0; i<count; i++){\\n        \\t\\tint curr = myQueue.poll();\\n        \\t\\tres.add(curr);\\n        \\t\\tdegree[curr]--;\\n        \\t\\tfor(int k=0; k<myGraph.get(curr).size(); k++) {\\n        \\t\\t\\tint next = myGraph.get(curr).get(k);\\n        \\t\\t\\tif (degree[next]==0) continue;\\n        \\t\\t\\tif (degree[next]==2) {\\n        \\t\\t\\t\\tmyQueue.offer(next);\\n        \\t\\t\\t}\\n    \\t\\t\\t\\tdegree[next]--;\\n        \\t\\t}\\n        \\t}      \\t\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 923071,
                "title": "python-find-diameter-using-2-dfs-explained",
                "content": "Actually, what we need to find in this problem is diameter of our tree: two nodes, that have the biggest distance between them. How we can do it? There is two-stage dfs algorighm to do it:\\n\\n1. Start from any node and run `dfs`, which calculate distances for all other nodes from this node as well as create parent for each node. What our fucntion will return in the end is the index of farthest node (there can be more than one and it is OK for us).\\n2. Now, we need to start our `dfs` all over again from this node (that is why we use `dfs_helper` function - we need to clean our distances and parents arrays. When we run our dfs second time, we again find the farthest node.\\n3. Finally, we create path between the first node we found and the second and it will be our diameter: if it has even number of nodes, we return `2` middle nodes, in other case we return `1` middle node.\\n\\n**Complexity**: time complexity is `O(n)`, because we use our `dfs` twice. Space complexity is `O(n)` as well.\\n\\n```\\nclass Solution:\\n    def findMinHeightTrees(self, n, edges):\\n        def dfs_helper(start, n):\\n            self.dist, self.parent = [-1]*n, [-1]*n\\n            self.dist[start] = 0\\n            dfs(start)\\n            return self.dist.index(max(self.dist))\\n        \\n        def dfs(start):\\n            for neib in Graph[start]:\\n                if self.dist[neib] == -1:\\n                    self.dist[neib] = self.dist[start] + 1\\n                    self.parent[neib] = start\\n                    dfs(neib)\\n                    \\n        Graph = defaultdict(set)\\n        for a,b in edges:\\n            Graph[a].add(b)\\n            Graph[b].add(a)\\n        \\n        ind = dfs_helper(0,n)\\n        ind2 = dfs_helper(ind, n)\\n        \\n        path = []\\n        while ind2 != -1:\\n            path.append(ind2)           #backtracking to create path\\n            ind2 = self.parent[ind2]\\n            \\n        Q = len(path)\\n        return list(set([path[Q//2], path[(Q-1)//2]]))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n, edges):\\n        def dfs_helper(start, n):\\n            self.dist, self.parent = [-1]*n, [-1]*n\\n            self.dist[start] = 0\\n            dfs(start)\\n            return self.dist.index(max(self.dist))\\n        \\n        def dfs(start):\\n            for neib in Graph[start]:\\n                if self.dist[neib] == -1:\\n                    self.dist[neib] = self.dist[start] + 1\\n                    self.parent[neib] = start\\n                    dfs(neib)\\n                    \\n        Graph = defaultdict(set)\\n        for a,b in edges:\\n            Graph[a].add(b)\\n            Graph[b].add(a)\\n        \\n        ind = dfs_helper(0,n)\\n        ind2 = dfs_helper(ind, n)\\n        \\n        path = []\\n        while ind2 != -1:\\n            path.append(ind2)           #backtracking to create path\\n            ind2 = self.parent[ind2]\\n            \\n        Q = len(path)\\n        return list(set([path[Q//2], path[(Q-1)//2]]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923055,
                "title": "python-o-n-by-leave-node-removal-w-visualization",
                "content": "**Hint**:\\n\\nUse leaves node removal procedure to find **central nodes** of graph.\\n\\nThose trees which are rooted in **central nodes** have minimum tree height.\\n\\n---\\n\\n**Illustration and Visualization**:\\n\\nIn a tree, the degree of leaf node must be 1.\\n\\nFor example, in this graph, **leaves nodes** are **node 1**, **node 2**, **node 3**, and **node 6**.\\n\\nAnd after leaves node removal procedure is accomplish,\\n**central nodes** are **node 4** and **node 5**, also acts as *roots of trees with minimum tree height*\\n\\n![image](https://assets.leetcode.com/users/images/875fc275-dec4-43eb-9ab5-d9fb0b9aa8f9_1604479585.6769276.png)\\n\\n\\n[Image Source: \\nWiki: Tree](https://en.wikipedia.org/wiki/Tree_(graph_theory))\\n\\n---\\n\\n**Implementation** by leave nodes removal:\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        \\n        \\n        total_node_count = n\\n        \\n        if total_node_count == 1:\\n            # Quick response for one node tree\\n            return [0]\\n        \\n        \\n        # build adjacency matrix\\n        adj_matrix = defaultdict( set )\\n        \\n        for src_node, dst_node in edges:\\n            adj_matrix[src_node].add( dst_node )\\n            adj_matrix[dst_node].add( src_node )\\n            \\n            \\n        # get leaves node whose degree is 1\\n        leave_nodes = [ node for node in adj_matrix if len(adj_matrix[node]) == 1 ]\\n        \\n        \\n        # keep doing leave nodes removal until total node count is smaller or equal to 2\\n        while total_node_count > 2:\\n            \\n            total_node_count -= len(leave_nodes)\\n            \\n            leave_nodes_next_round = []\\n            \\n            # leave nodes removal\\n            for leaf in leave_nodes:\\n                \\n                neighbor = adj_matrix[leaf].pop()\\n                adj_matrix[neighbor].remove( leaf )\\n                \\n                if len(adj_matrix[neighbor]) == 1:\\n                    leave_nodes_next_round.append( neighbor )\\n                    \\n            leave_nodes = leave_nodes_next_round\\n        \\n        # final leave nodes are root node of minimum height trees\\n        return leave_nodes\\n                \\n\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Tree](https://en.wikipedia.org/wiki/Tree_(graph_theory))\\n\\n[2] [Python official docs about defaultdict](https://docs.python.org/3.8/library/collections.html#collections.defaultdict)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        \\n        \\n        total_node_count = n\\n        \\n        if total_node_count == 1:\\n            # Quick response for one node tree\\n            return [0]\\n        \\n        \\n        # build adjacency matrix\\n        adj_matrix = defaultdict( set )\\n        \\n        for src_node, dst_node in edges:\\n            adj_matrix[src_node].add( dst_node )\\n            adj_matrix[dst_node].add( src_node )\\n            \\n            \\n        # get leaves node whose degree is 1\\n        leave_nodes = [ node for node in adj_matrix if len(adj_matrix[node]) == 1 ]\\n        \\n        \\n        # keep doing leave nodes removal until total node count is smaller or equal to 2\\n        while total_node_count > 2:\\n            \\n            total_node_count -= len(leave_nodes)\\n            \\n            leave_nodes_next_round = []\\n            \\n            # leave nodes removal\\n            for leaf in leave_nodes:\\n                \\n                neighbor = adj_matrix[leaf].pop()\\n                adj_matrix[neighbor].remove( leaf )\\n                \\n                if len(adj_matrix[neighbor]) == 1:\\n                    leave_nodes_next_round.append( neighbor )\\n                    \\n            leave_nodes = leave_nodes_next_round\\n        \\n        # final leave nodes are root node of minimum height trees\\n        return leave_nodes\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76132,
                "title": "iterative-remove-leaves-python-solution",
                "content": "Because there're at most two nodes can be Minimum Height Trees. And all leaves are impossible because such nodes. So we can iterative remove leaves and related edges till we reach 1 or 2.\\n\\n        d = collections.defaultdict(set)\\n        for u, v in edges:\\n            d[u].add(v)\\n            d[v].add(u)\\n        s = set(range(n))\\n        while len(s) > 2:\\n            leaves = set(i for i in s if len(d[i]) == 1)\\n            s -= leaves\\n            for i in leaves:\\n                for j in d[i]:\\n                    d[j].remove(i)\\n        return list(s)",
                "solutionTags": [],
                "code": "Because there're at most two nodes can be Minimum Height Trees. And all leaves are impossible because such nodes. So we can iterative remove leaves and related edges till we reach 1 or 2.\\n\\n        d = collections.defaultdict(set)\\n        for u, v in edges:\\n            d[u].add(v)\\n            d[v].add(u)\\n        s = set(range(n))\\n        while len(s) > 2:\\n            leaves = set(i for i in s if len(d[i]) == 1)\\n            s -= leaves\\n            for i in leaves:\\n                for j in d[i]:\\n                    d[j].remove(i)\\n        return list(s)",
                "codeTag": "Unknown"
            },
            {
                "id": 897095,
                "title": "c-bfs-solution-explained",
                "content": "Runtime: 124 ms, faster than 91.05% of C++ online submissions for Minimum Height Trees.\\nMemory Usage: 27.7 MB, less than 5.75% of C++ online submissions for Minimum Height Trees.\\n\\n```\\nSuppose a tree has only one long linear path, in that case the minimum height tree\\'s root\\nwould be the middle value of the path when path length is odd or the two middle values of the\\npath when path length is even. So there can be at most two MHT and the root vlaues would be the \\nmiddle values of the longest path of the tree.\\n    \\nTree: 0-1-2-3-4-5, middle values: [2,3] => Path Length Even\\nTree: 0-1-2-3-4, middle values: [2] => Path Length Odd\\n\\nFinding longest tree path by running DFS/BFS is quite hectic.\\n\\nInstead we can find the middle values of the longest path by removing the leaf nodes from the tree\\nin each step which we implement by running BFS and counting degeree of node.\\n\\nLongest path always starts with leaf nodes which has degree 1, so initially we can add all degree 1\\nleaf nodes in to queue and run BFS, while processing a node, we decrease degree of all its neighbour\\nnodes (as we are removing the current node from the tree) and add neighbours in to queue which has \\ndegree 1 (leaf node). The nodes which exists at last are the middle nodes of the longest tree path.\\n    \\nExample: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\\n\\nPush node 0,1,2,5 in to queue and run BFS and for each node, decrease it\\'s neighbour\\'s degree\\nat last only node 3 and 4 remains and they are the root nodes of MHT.\\n```\\n    \\n![image](https://assets.leetcode.com/users/images/5f54d052-b354-4962-b7e7-6f32fde85722_1602851185.430539.png)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        // Base case: only one node\\n        if(n==1) return vector<int>{0};\\n        \\n        // graph adjacency list of nodes\\n        vector<vector<int>>graph(n);\\n        \\n        // degree count of nodes\\n        vector<int>degree(n,0);\\n        \\n        // populate graph adjacency list and degree count of nodes\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            \\n            graph[a].push_back(b);\\n            graph[b].push_back(a);\\n            \\n            degree[a]++;\\n            degree[b]++;\\n        }\\n        \\n        queue<int>Q;\\n        \\n        // push degree 1 nodes (leaf nodes) in to queue \\n        for(int i=0;i<n;i++)\\n            if(degree[i]==1)Q.push(i);\\n\\n        // MHT root nodes\\n        vector<int>res;\\n        \\n        // run BFS until queue is empty \\n        while(!Q.empty())\\n        {\\n            int n = Q.size();\\n            \\n            // clear root nodes \\n            res.clear();\\n            \\n            // perform level order traverse\\n            while(n--)\\n            {\\n                int node = Q.front();\\n                Q.pop();\\n                \\n                // add current in to root node vector\\n                res.push_back(node);\\n                \\n                // process neighbour nodes\\n                for(int i=0;i<graph[node].size();i++)\\n                {\\n                    // decrease degree of neighbour nodes\\n                    degree[graph[node][i]]--;\\n                    \\n                    // push leaf nodes in to queue\\n                    if(degree[graph[node][i]]==1)\\n                    {\\n                        Q.push(graph[node][i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // root nodes of MHT\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nSuppose a tree has only one long linear path, in that case the minimum height tree\\'s root\\nwould be the middle value of the path when path length is odd or the two middle values of the\\npath when path length is even. So there can be at most two MHT and the root vlaues would be the \\nmiddle values of the longest path of the tree.\\n    \\nTree: 0-1-2-3-4-5, middle values: [2,3] => Path Length Even\\nTree: 0-1-2-3-4, middle values: [2] => Path Length Odd\\n\\nFinding longest tree path by running DFS/BFS is quite hectic.\\n\\nInstead we can find the middle values of the longest path by removing the leaf nodes from the tree\\nin each step which we implement by running BFS and counting degeree of node.\\n\\nLongest path always starts with leaf nodes which has degree 1, so initially we can add all degree 1\\nleaf nodes in to queue and run BFS, while processing a node, we decrease degree of all its neighbour\\nnodes (as we are removing the current node from the tree) and add neighbours in to queue which has \\ndegree 1 (leaf node). The nodes which exists at last are the middle nodes of the longest tree path.\\n    \\nExample: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\\n\\nPush node 0,1,2,5 in to queue and run BFS and for each node, decrease it\\'s neighbour\\'s degree\\nat last only node 3 and 4 remains and they are the root nodes of MHT.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        // Base case: only one node\\n        if(n==1) return vector<int>{0};\\n        \\n        // graph adjacency list of nodes\\n        vector<vector<int>>graph(n);\\n        \\n        // degree count of nodes\\n        vector<int>degree(n,0);\\n        \\n        // populate graph adjacency list and degree count of nodes\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            \\n            graph[a].push_back(b);\\n            graph[b].push_back(a);\\n            \\n            degree[a]++;\\n            degree[b]++;\\n        }\\n        \\n        queue<int>Q;\\n        \\n        // push degree 1 nodes (leaf nodes) in to queue \\n        for(int i=0;i<n;i++)\\n            if(degree[i]==1)Q.push(i);\\n\\n        // MHT root nodes\\n        vector<int>res;\\n        \\n        // run BFS until queue is empty \\n        while(!Q.empty())\\n        {\\n            int n = Q.size();\\n            \\n            // clear root nodes \\n            res.clear();\\n            \\n            // perform level order traverse\\n            while(n--)\\n            {\\n                int node = Q.front();\\n                Q.pop();\\n                \\n                // add current in to root node vector\\n                res.push_back(node);\\n                \\n                // process neighbour nodes\\n                for(int i=0;i<graph[node].size();i++)\\n                {\\n                    // decrease degree of neighbour nodes\\n                    degree[graph[node][i]]--;\\n                    \\n                    // push leaf nodes in to queue\\n                    if(degree[graph[node][i]]==1)\\n                    {\\n                        Q.push(graph[node][i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // root nodes of MHT\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76149,
                "title": "share-my-accepted-bfs-python-code-with-o-n-time",
                "content": "The obvious method is to BFS for each node with the complexity of O(n^2) (and will get TLE).\\n\\nHere is one insight for this problem: the root of MHT is the middle point of the longest path in the tree; hence there are at most two MHT roots.   \\n\\nHow to find them? We can BFS from the bottom (leaves) to the top until the last level with <=2 nodes. To build the current level from the previous level, we can monitor the degree of each node. If the node has degree of one, it will be added to the current level. Since it only check the edges once, the complexity is O(n).\\n\\n\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 1: return [0]\\n        neighbors = collections.defaultdict(list)\\n        degrees = collections.defaultdict(int)\\n        for u, v in edges:\\n            neighbors[u].append(v)\\n            neighbors[v].append(u)\\n            degrees[u] += 1\\n            degrees[v] += 1\\n        \\n        # First find the leaves\\n        preLevel, unvisited = [], set(range(n))\\n        for i in range(n):\\n            if degrees[i] == 1: preLevel.append(i)\\n            \\n        while len(unvisited) > 2:\\n            thisLevel = []\\n            for u in preLevel:\\n                unvisited.remove(u)\\n                for v in neighbors[u]:\\n                    if v in unvisited: \\n                        degrees[v] -= 1\\n                        if degrees[v] == 1: thisLevel += [v]\\n            preLevel = thisLevel\\n                    \\n         return preLevel",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "The obvious method is to BFS for each node with the complexity of O(n^2) (and will get TLE).\\n\\nHere is one insight for this problem: the root of MHT is the middle point of the longest path in the tree; hence there are at most two MHT roots.   \\n\\nHow to find them? We can BFS from the bottom (leaves) to the top until the last level with <=2 nodes. To build the current level from the previous level, we can monitor the degree of each node. If the node has degree of one, it will be added to the current level. Since it only check the edges once, the complexity is O(n).\\n\\n\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 1: return [0]\\n        neighbors = collections.defaultdict(list)\\n        degrees = collections.defaultdict(int)\\n        for u, v in edges:\\n            neighbors[u].append(v)\\n            neighbors[v].append(u)\\n            degrees[u] += 1\\n            degrees[v] += 1\\n        \\n        # First find the leaves\\n        preLevel, unvisited = [], set(range(n))\\n        for i in range(n):\\n            if degrees[i] == 1: preLevel.append(i)\\n            \\n        while len(unvisited) > 2:\\n            thisLevel = []\\n            for u in preLevel:\\n                unvisited.remove(u)\\n                for v in neighbors[u]:\\n                    if v in unvisited: \\n                        degrees[v] -= 1\\n                        if degrees[v] == 1: thisLevel += [v]\\n            preLevel = thisLevel\\n                    \\n         return preLevel",
                "codeTag": "Python3"
            },
            {
                "id": 76078,
                "title": "java-accepted-solution-remove-nodes-from-leave-to-root",
                "content": "    public class Solution {\\n        public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n            if (n == 0) return new ArrayList<>();\\n            else if (n == 1) {\\n                List<Integer> ret = new ArrayList<>();\\n                ret.add(0);\\n                return ret;\\n            }\\n            List<Integer>[] lists = new ArrayList[n];\\n            for (int i = 0; i < n; i++) {\\n                lists[i] = new ArrayList<>();\\n            }\\n            for (int i = 0; i < edges.length; i++) {\\n                int v1 = edges[i][0];\\n                int v2 = edges[i][1];\\n                lists[v1].add(v2);\\n                lists[v2].add(v1);\\n            }\\n            List<Integer> leaves = new ArrayList<>();\\n            for (int i = 0; i < n; i++) {\\n                if (lists[i].size() == 1) {\\n                    leaves.add(i);\\n                }\\n            }\\n            int count = n;\\n            while (count > 2) {\\n                int size = leaves.size();\\n                count -= size;\\n                List<Integer> newLeaves = new ArrayList<>();\\n                for (int i = 0; i < size; i++) {\\n                    int leaf = leaves.get(i);\\n                    for (int j = 0; j < lists[leaf].size(); j++) {\\n                        int toRemove = lists[leaf].get(j);\\n                        lists[toRemove].remove(Integer.valueOf(leaf));\\n                        if (lists[toRemove].size() == 1)\\n                            newLeaves.add(toRemove);\\n                    }\\n                }\\n                leaves = newLeaves;\\n            }\\n            return leaves;\\n        }\\n    }",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n            if (n == 0) return new ArrayList<>();\\n            else if (n == 1) {\\n                List<Integer> ret = new ArrayList<>();\\n                ret.add(0);\\n                return ret;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76124,
                "title": "o-n-super-clean-solution-just-iteratively-deleting-leaves",
                "content": "    class Solution {\\n    public: \\n        vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n            vector<unordered_set<int>> graph(n);\\n            for(auto e: edges){\\n                graph[e.first].insert(e.second);\\n                graph[e.second].insert(e.first);\\n            }\\n            vector<int> degree(n, 0);  //degree\\n            for(int i=0; i<n; i++) degree[i]=graph[i].size();\\n            for(int remain=n, j; remain>2;){\\n                vector<int> del; // nodes to delete\\n                for(j=0; j<n; j++){\\n                    if(degree[j]==1) { //find leaves\\n                        remain--;\\n                        del.push_back(j);\\n                        degree[j]=-1;\\n                    }\\n                }\\n                for(auto k: del){ //delete this node and its edges \\n                    for(auto neigh: graph[k]) degree[neigh]--;\\n                }\\n            }\\n            vector<int> res;\\n            for(int i=0; i<n; i++) if(degree[i]>=0) res.push_back(i);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public: \\n        vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n            vector<unordered_set<int>> graph(n);\\n            for(auto e: edges){\\n                graph[e.first].insert(e.second);\\n                graph[e.second].insert(e.first);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 216472,
                "title": "follow-up-after-most-voted-post",
                "content": "Please Note that repeated numbers are not duplicates, some of them are set objects(VALUE) and some are Integer(KEY)(Mostly Parents having some children in their Value Set) during graph construction (Don\\'t Forget to upvote in case it is helpful, and for others\\' benefit):\\nExample 2 from Question -\\n![image](https://assets.leetcode.com/users/heyleetcoders/image_1547124672.png)\\nEdge Case-\\n![image](https://assets.leetcode.com/users/heyleetcoders/image_1547097710.png)\\n\\nI tried to post this in the most voted post but not sure how to upload images there.. Edge case diagram consists red colour text, first diagram covers example 2 from question, Below Commented code might clear some doubts (Apologies if it creates more confusion):\\n\\nThe below inlined comments might be useful, hope it may help someone struggling like me:\\n```\\nclass Solution {\\n    // Time Complexity - O(V+E), Space Complexity - O(V)\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if(n==1) return Arrays.asList(0);\\n        \\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for(int i=0; i<n; i++) graph.put(i, new HashSet<Integer>());\\n        \\n        //build graph\\n        for(int[] edge : edges){\\n            //In a bi-directional way\\n            graph.get(edge[0]).add(edge[1]); \\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\t\\t\\n        // Please note leaves are not the leaves not having any Children like in tree\\n\\t\\t// In this approach, we refer leaves to nodes having one node in their value set(corresponding child)\\n        // find leaves(having one child) because approach is to cut all nodes having one element in it\\'s child set \\n        // (we call nodes having one child node as leaves here)\\n        List<Integer> leaves = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            if(graph.get(i).size()==1) // leaves having child node hence size is 1\\n            leaves.add(i); // why we add i? refer diagram (Please note we initially populated set for every index)\\n        }\\n        \\n        //Eat all leaves having one child make sure to cover edge case by taking newLeaves local list\\n        //in edge case we will go through more than 1 halve, \\n        //and will cut new leaves (Refer edge case example in diagram)\\n         while(n>2){ // why more than 2? because in case of 2 nodes we just need to return leaves\\n             // See Edge case from diagram to see why we need local list here\\n             // we might need to cover more than one halve\\n            List<Integer> newLeaves = new ArrayList<Integer>();\\n            n-=leaves.size(); // this is just to break\\n            // below for loop will eat all \\n            //eligible leaves(having one child node) in one or more halves depending upon input, more than one halve will use newleaves to cut\\n            for(int leaf : leaves){\\n                int parent = graph.get(leaf).iterator().next(); // note every parent(Integer-Key) having it\\'s corrsponding children(Set-Value) in set hence need iterator, there is no straight forward way to get items from set without iterator\\n                graph.get(parent).remove(leaf); // remove leaf node having its own one child for this parent node in first halve \\n                if(graph.get(parent).size()==1) // let\\'s see if we ate all child nodes in set for this parent node apart from one remaining, hence checking size of parent node\\'s value set(this set contains leaves)\\n                 newLeaves.add(parent); // ok congrats, finally this patrent has only one child now, rest got eaten   \\n            }\\n            leaves = newLeaves; // this is to cover edge case where we need to cover more than one halve\\n        }\\n        return leaves;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    // Time Complexity - O(V+E), Space Complexity - O(V)\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if(n==1) return Arrays.asList(0);\\n        \\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for(int i=0; i<n; i++) graph.put(i, new HashSet<Integer>());\\n        \\n        //build graph\\n        for(int[] edge : edges){\\n            //In a bi-directional way\\n            graph.get(edge[0]).add(edge[1]); \\n            graph.get(edge[1]).add(edge[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 952374,
                "title": "python-3-approaches-detailed-explanation-and-visuals",
                "content": "-------------------------------------------------------------\\n## Approach 1 :  Brute Force : TLE\\n-------------------------------------------------------------\\n **Time :** O(V)*O(E+V) => O(EV + V^2)\\n \\n- A tree height is the  distance from root to farthest leaf\\n- Itertae over nodes and run BFS on each node to find greatest raduis (distance to farthest leaf)\\n- keep record of distance to farthest leaf for each node.\\n-  The min distance among all farthest distances is what we are interested in\\n-  find the node/root that gives you that result\\n        \\n**TLE : 65 / 68 test cases passed**. Test case 66 you have to process a huge graph/tree consisting of 5000 nodes | o_0 !\\n\\n```\\ndef findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        \\n\\t# Edge case\\n\\tif n == 1 or not edges:\\n\\t\\treturn [0]\\n\\n\\tif n == 2 and len(edges) == 1: # 2 nodes and one link between them\\n\\t\\treturn edges[0]\\n\\n\\t--- BFS helper ---\\n\\tdef dfs(node):\\n\\t\\theight = 0\\n\\t\\tfrom collections import deque\\n\\t\\tq = deque()\\n\\t\\tq.append(node)\\n\\t\\tvisited = set()\\n\\n\\t\\twhile q:\\n\\t\\t\\theight += 1 # raduis counter\\n\\t\\t\\tfor i in range(len(q)):\\n\\t\\t\\t\\tnode = q.popleft()\\n\\t\\t\\t\\tvisited.add(node)\\n\\n\\t\\t\\t\\tfor nei in d[node]: # more like a child than a nei\\n\\t\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\t\\tq.append(nei)\\n\\n\\t\\treturn height-1\\n\\n\\n\\t # --- main logic ---\\n\\tfrom collections import defaultdict\\n\\td = defaultdict(list)\\n\\n\\t# build graph/tree\\n\\tfor k, v in edges:\\n\\t\\td[k].append(v)\\n\\t\\td[v].append(k)\\n\\n\\trootDict = defaultdict(list)\\n\\tfor node in range(n):\\n\\t\\th = dfs(node)\\n\\t\\trootDict[h].append(node) # add all roots associated with that height\\n\\n\\tminHeight = min(rootDict.keys())\\n\\tfor h in rootDict:\\n\\t\\tif h == minHeight:\\n\\t\\t\\treturn rootDict[h]\\n```\\n\\n.\\n.\\n-------------------------------------------------------------\\n-------------------------------------------------------------\\n## Approach 2 : Closeness Centrality\\n-------------------------------------------------------------\\n **Time :** O(V)*O(E+V) => O(EV + V^2)\\n\\n**Idea:**\\n- Closeness Centrality is used when you need to know which nodes disseminate things the fastest.\\n- Uncovering nodes in favorable positions to control and acquire vital information and resources within an organization\\n- applications: telecommunications and package delivery\\n- The most dangerous node an infectious disease could spread/propogate from\\n\\n- The measure of a node\\u2019s centrality is its average farness (inverse distance) to all other nodes. \\n- Nodes with a high closeness score have the shortest distances from all other nodes.\\n\\n\\n**Steps:**\\n- Iterate over the nodes\\n- pick node as root - calculate closest centrality score of root with respect to all nodes\\n- store {node: centrality score} in a dict\\n- return the node with hight closeness score\\n\\n\\t![image](https://assets.leetcode.com/users/images/aae34f31-3261-4c18-bccc-ec6630a7a8e3_1606588002.0046017.png)\\n\\n- `closeness dict =  defaultdict(<class \\'list\\'>, {0.8: [0, 2, 3], 1.3333333333333333: [1]})`\\n- Node (1) has highest closeness score meaning it has the shortest distance to every other node and thus is best candidate to be a root (in order to give us min height of teh tree)\\n\\n.\\n## Cases where Closeness centrality won\\'t work for this particular problem:\\n![image](https://assets.leetcode.com/users/images/6b320f49-6a5e-47d1-8e47-0df861d3c392_1606585501.2536068.png)\\n\\n- In this example, the closeness centrality score for nodes 3 is greater than that of node 4\\n`closeness dict =  defaultdict(<class \\'list\\'>, {0.6: [0, 1, 2], 1.0: [3], 0.75: [4], 0.5: [5]})`\\n\\n- Closeness centrality is sensetive to the distance of root to all nodes. Min tree height on the other hand is only sensetive to\\nthe most far away node and does not care about any other node except for the one that is farthest away from it.\\nAs a result, this closeness based algorithm will only uncover one of the many nodes that can give us a min height of the tree\\nThus we can only use this approach if the requirement was to return `a root` that yeilds the min tree height rather than `a list of all MHTs\\' root labels.`\\n\\n```\\ndef findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\t# Edge case\\n\\tif n == 1 or not edges:\\n\\t\\treturn [0]\\n\\n\\tif n == 2 and len(edges) == 1: # 2 nodes and one link between them\\n\\t\\treturn edges[0]\\n\\t# --- Build the graph\\n\\tfrom collections import defaultdict\\n\\td = defaultdict(list)\\n\\tfor k, v in edges:\\n\\t\\td[k].append(v)\\n\\t\\td[v].append(k) # graph (not a di-graph)\\n\\n\\t# --- Helper to find sum of distances between a given node and all the other nodes\\n\\tdef bfs(node):\\n\\t\\tdistanceSum = 0\\n\\t\\tfrom collections import deque\\n\\t\\tq = deque()\\n\\t\\tq.append(node)\\n\\t\\traduis = 0\\n\\t\\tvisited = set()\\n\\t\\twhile q:\\n\\t\\t\\tqSize = len(q)\\n\\t\\t\\traduis += 1\\n\\t\\t\\tfor i in range(qSize):\\n\\t\\t\\t\\tnode = q.popleft()\\n\\t\\t\\t\\tvisited.add(node)\\n\\t\\t\\t\\tfor nei in d[node]:\\n\\t\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\t\\tq.append(nei)\\n\\t\\t\\t\\t\\t\\tdistanceSum += 1*raduis\\n\\t\\treturn distanceSum\\n\\n\\t# --- Main Logic\\n\\tmaxCloseness = 0\\n\\tclosenessDict = defaultdict(list)\\n\\tfor node in range(n):\\n\\t\\tsumOfDistancesToOtherNodes = bfs(node)\\n\\t\\tavgDistanceSum = sumOfDistancesToOtherNodes/n\\n\\t\\tcloseness = 1/avgDistanceSum\\n\\t\\tclosenessDict[closeness].append(node)\\n\\n\\treturn closenessDict[max(closenessDict.keys())]\\n```\\n\\n.\\n.\\n-------------------------------------------------------------\\n-------------------------------------------------------------\\n## Approach 3 : Intuitive Solution based off Topological Sort\\n-------------------------------------------------------------\\n**Time:** O(E+V)\\n\\n- Intro:\\n\\t- A tree height is the  distance from root to farthest leaf. This means the height of a tree varies depending on which node is designated a root. Therefore the minimum tree height is the height that a tree has when the root of the tree is at an equal distance from all the leaves in the tree. Since the height is dictated by the farthest distance from the root, it\\'s in our tree\\'s best interest to have a root that is at the same distance from all the leaves.\\n\\n\\t- As you can see, by looking at this problem this way, we can reformulate the prompt as follows:\\n\\t\\t*`Find the node that is located at the center of (at \"roughly\" equal distance from) all the leaves`*\\n\\n\\t- If we look at the tree-graph at a high level, it\\'s basically a blob of nodes. So If we start eating up this blob\\n  equally along the preimeter, we eventually arrive at the core/center of the graph -> which we should designate as our root -> because it will produce the min height.\\n\\n\\t - This type of algorithm has various useful applications that have to do with figuring out how to optimize the location of\\n  a centerlized service so that its at equal distance from all the users/clients. \\n  For example, where to place a new sport center in a neighbourhood? Or where should the new router be deployed so that latency/service experienced by users is roughly the same?\\n\\n- Idea:\\n\\t- We can approach this the same way we approach the topological sort problem with only a slight modification. I know what you\\'re thinking. Why would we want to use that and how does \"finding the Minimum Height of a tree\" relates to topoogocal sort?\\n\\n\\n\\t- Topological sort is used to order items/nodes according to their dependencies. In a topolgical sort algo, we identify the zero in-degree nodes (nodes with least depenecy). These nodes would represent something like freshman year courses in a course scheduling problem.\\nand then we start sepearting/deattaching them from the rest of the graph and add them to our to-be ordered list. And we repeat the same process until we have added all the nodes to our ordered list. \\n\\n\\t- In this problem, the logic is reversed. We are starting off with the nodes with the highest-depencecy (leaves)\\n  and will still trim the graph layer by layer (using a BFS travseral), but the major difference between this probelm and the typical topological sort one is that here we are only interested in the last layer standing after we peel off the unnecessary (leaf) layers. The nodes that remain standing after we have finished trimming are the core/centroid/root). Whereas in a topological sort algo, all the layers matter to us and are needed to build the ordered result as we peel off the graph one layer after another (all the layers are important). See note [1]\\n\\n\\n```\\ndef findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\t# Edge case\\n\\tif n == 1 or not edges:\\n\\t\\treturn [0]\\n\\n\\tif n == 2 and len(edges) == 1: # 2 nodes and one link between them\\n\\t\\treturn edges[0]\\n\\n\\t# A leaf is a node that has only one indegree link and zero outdegree links\\n\\tfrom collections import defaultdict\\n\\td = defaultdict(list)\\n\\tindegree = defaultdict(int)\\n\\tfor k, v in edges:\\n\\t\\t# build graph\\n\\t\\td[k].append(v)\\n\\t\\td[v].append(k) # unidrected\\n\\n\\t\\t# build indegree\\n\\t\\tindegree[k] += 1\\n\\t\\tindegree[v] += 1\\n\\n\\t# Identfiy leaves and enque them \\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tfor k in d:\\n\\t\\tif indegree[k] == 1: # thus leaf\\n\\t\\t\\tq.append(k)\\n\\n\\t# trigger your BFS and peel off leafy unnecessary layers (we are only interested in the core)\\n\\t# the trick is to make sure you discard the previous layer you peel off with each iteration\\n\\t# so that we only maintain the last layer (aka desired layer/core/centroid)\\n\\n\\t# result = [] -- [1] usually this where we would have a result list to build up the topological sort as we traverse\\n   visited = set()\\n\\twhile q:\\n\\t\\tlayer = [] # -- [1] discard older layers by resetting back to empty list \\n\\t\\tlayerSize = len(q)\\n\\t\\tfor i in range(layerSize):\\n\\t\\t\\tnode = q.popleft()\\n\\t\\t\\tvisited.add(node)\\n\\t\\t\\tlayer.append(node)\\n\\t\\t\\tfor nei in d[node]:\\n\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\tindegree[nei] -= 1 # cut tie\\n\\t\\t\\t\\t\\tif indegree[nei] == 1: # new leaf yet?\\n\\t\\t\\t\\t\\t\\tq.append(nei)\\n\\treturn layer\\n```\\n\\n- Check out how simialr this algorithm is to the Topological sort algortihm by checking the links below:\\n\\t- Topological Sort Algorithm explained : https://www.interviewcake.com/concept/java/topological-sort\\n\\t- My solution to Course Schedule I : https://leetcode.com/problems/course-schedule/discuss/952361/Python-Simple-DFS-with-Detailed-Explanation\\n\\t- My solution to Course Schedule II : https://leetcode.com/problems/course-schedule-ii/discuss/952373/Python-Simple-DFS-with-Detailed-Explanation\\n\\n.\\n.\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\ndef findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        \\n\\t# Edge case\\n\\tif n == 1 or not edges:\\n\\t\\treturn [0]\\n\\n\\tif n == 2 and len(edges) == 1: # 2 nodes and one link between them\\n\\t\\treturn edges[0]\\n\\n\\t--- BFS helper ---\\n\\tdef dfs(node):\\n\\t\\theight = 0\\n\\t\\tfrom collections import deque\\n\\t\\tq = deque()\\n\\t\\tq.append(node)\\n\\t\\tvisited = set()\\n\\n\\t\\twhile q:\\n\\t\\t\\theight += 1 # raduis counter\\n\\t\\t\\tfor i in range(len(q)):\\n\\t\\t\\t\\tnode = q.popleft()\\n\\t\\t\\t\\tvisited.add(node)\\n\\n\\t\\t\\t\\tfor nei in d[node]: # more like a child than a nei\\n\\t\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\t\\tq.append(nei)\\n\\n\\t\\treturn height-1\\n\\n\\n\\t # --- main logic ---\\n\\tfrom collections import defaultdict\\n\\td = defaultdict(list)\\n\\n\\t# build graph/tree\\n\\tfor k, v in edges:\\n\\t\\td[k].append(v)\\n\\t\\td[v].append(k)\\n\\n\\trootDict = defaultdict(list)\\n\\tfor node in range(n):\\n\\t\\th = dfs(node)\\n\\t\\trootDict[h].append(node) # add all roots associated with that height\\n\\n\\tminHeight = min(rootDict.keys())\\n\\tfor h in rootDict:\\n\\t\\tif h == minHeight:\\n\\t\\t\\treturn rootDict[h]\\n```\n```\\ndef findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\t# Edge case\\n\\tif n == 1 or not edges:\\n\\t\\treturn [0]\\n\\n\\tif n == 2 and len(edges) == 1: # 2 nodes and one link between them\\n\\t\\treturn edges[0]\\n\\t# --- Build the graph\\n\\tfrom collections import defaultdict\\n\\td = defaultdict(list)\\n\\tfor k, v in edges:\\n\\t\\td[k].append(v)\\n\\t\\td[v].append(k) # graph (not a di-graph)\\n\\n\\t# --- Helper to find sum of distances between a given node and all the other nodes\\n\\tdef bfs(node):\\n\\t\\tdistanceSum = 0\\n\\t\\tfrom collections import deque\\n\\t\\tq = deque()\\n\\t\\tq.append(node)\\n\\t\\traduis = 0\\n\\t\\tvisited = set()\\n\\t\\twhile q:\\n\\t\\t\\tqSize = len(q)\\n\\t\\t\\traduis += 1\\n\\t\\t\\tfor i in range(qSize):\\n\\t\\t\\t\\tnode = q.popleft()\\n\\t\\t\\t\\tvisited.add(node)\\n\\t\\t\\t\\tfor nei in d[node]:\\n\\t\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\t\\tq.append(nei)\\n\\t\\t\\t\\t\\t\\tdistanceSum += 1*raduis\\n\\t\\treturn distanceSum\\n\\n\\t# --- Main Logic\\n\\tmaxCloseness = 0\\n\\tclosenessDict = defaultdict(list)\\n\\tfor node in range(n):\\n\\t\\tsumOfDistancesToOtherNodes = bfs(node)\\n\\t\\tavgDistanceSum = sumOfDistancesToOtherNodes/n\\n\\t\\tcloseness = 1/avgDistanceSum\\n\\t\\tclosenessDict[closeness].append(node)\\n\\n\\treturn closenessDict[max(closenessDict.keys())]\\n```\n```\\ndef findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\t# Edge case\\n\\tif n == 1 or not edges:\\n\\t\\treturn [0]\\n\\n\\tif n == 2 and len(edges) == 1: # 2 nodes and one link between them\\n\\t\\treturn edges[0]\\n\\n\\t# A leaf is a node that has only one indegree link and zero outdegree links\\n\\tfrom collections import defaultdict\\n\\td = defaultdict(list)\\n\\tindegree = defaultdict(int)\\n\\tfor k, v in edges:\\n\\t\\t# build graph\\n\\t\\td[k].append(v)\\n\\t\\td[v].append(k) # unidrected\\n\\n\\t\\t# build indegree\\n\\t\\tindegree[k] += 1\\n\\t\\tindegree[v] += 1\\n\\n\\t# Identfiy leaves and enque them \\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tfor k in d:\\n\\t\\tif indegree[k] == 1: # thus leaf\\n\\t\\t\\tq.append(k)\\n\\n\\t# trigger your BFS and peel off leafy unnecessary layers (we are only interested in the core)\\n\\t# the trick is to make sure you discard the previous layer you peel off with each iteration\\n\\t# so that we only maintain the last layer (aka desired layer/core/centroid)\\n\\n\\t# result = [] -- [1] usually this where we would have a result list to build up the topological sort as we traverse\\n   visited = set()\\n\\twhile q:\\n\\t\\tlayer = [] # -- [1] discard older layers by resetting back to empty list \\n\\t\\tlayerSize = len(q)\\n\\t\\tfor i in range(layerSize):\\n\\t\\t\\tnode = q.popleft()\\n\\t\\t\\tvisited.add(node)\\n\\t\\t\\tlayer.append(node)\\n\\t\\t\\tfor nei in d[node]:\\n\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\tindegree[nei] -= 1 # cut tie\\n\\t\\t\\t\\t\\tif indegree[nei] == 1: # new leaf yet?\\n\\t\\t\\t\\t\\t\\tq.append(nei)\\n\\treturn layer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 269060,
                "title": "python-topological",
                "content": "High level idea is to keep pruning the outer node which has zero or one edge from the tree. Since it\\'s a undircted graph, the only edge allowed for a outer node is the edge connect it with an inner node.\\nThose last left nodes are at the \"center\" of the tree so expand from them, the tree will have minimal height.\\nSo in each iteration, we search those outer nodes. In each iteration, we prune those outer node by removing any edge that involves them. Thus, it\\'s kind of a topological sort.\\nEventually, if next queue for next iteration is empty, current queue contains those center nodes.\\n```\\ndef findMinHeightTrees(n, edges):\\n\\ttree = [set() for _ in range(n)]\\n\\tfor u, v in edges: tree[u].add(v), tree[v].add(u)\\n\\tq, nq = [x for x in range(n) if len(tree[x]) < 2], []\\n\\twhile True:\\n\\t\\tfor x in q:\\n\\t\\t\\tfor y in tree[x]:\\n\\t\\t\\t\\ttree[y].remove(x)\\n\\t\\t\\t\\tif len(tree[y]) == 1: nq.append(y)\\n\\t\\tif not nq: break\\n\\t\\tnq, q = [], nq\\n\\treturn q\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findMinHeightTrees(n, edges):\\n\\ttree = [set() for _ in range(n)]\\n\\tfor u, v in edges: tree[u].add(v), tree[v].add(u)\\n\\tq, nq = [x for x in range(n) if len(tree[x]) < 2], []\\n\\twhile True:\\n\\t\\tfor x in q:\\n\\t\\t\\tfor y in tree[x]:\\n\\t\\t\\t\\ttree[y].remove(x)\\n\\t\\t\\t\\tif len(tree[y]) == 1: nq.append(y)\\n\\t\\tif not nq: break\\n\\t\\tnq, q = [], nq\\n\\treturn q\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1343499,
                "title": "c-o-n-finding-diameter-using-2-dfs-with-explanation",
                "content": "Approach\\nWe find the diameter of the tree, the mid-point of the diameter are minimum height roots. If the length of the diameter is even, the middle two vertices are minimum height roots and if the length is odd the only middle vertex is minimum height root.\\n\\nFinding the diameter \\nChoose any random vertex (say vertex with 0 value) and find the vertex (say start ) that is at the largest distance from the vertex chosen. This can be done using BFS/DFS. If there are multiple such vertices that are farthest from the chosen vertex, then take any one of them.\\nNow look for the vertex ( say end ) that is at the largest distance from first. This can be done using BFS/DFS. If there are multiple such vertices that are farthest from first, then take any one of them. Now, start and end so obtained from the ends of the diameter.\\nObtain all the elements along the diameter using BFS/DFS including first and last.\\n\\n\\n\\n```\\nclass Solution {\\n  vector<vector<int>> g;\\n\\n public:\\n  int bfs(int src, int n) {\\n    vector<int> vis(n, -1), dis(n, 0);\\n    queue<int> q;\\n    q.push(src);\\n    while (!q.empty()) {\\n      int cur = q.front();\\n      q.pop();\\n      vis[cur] = 1;\\n      for (int x : g[cur]) {\\n        if (vis[x] == -1) {\\n          dis[x] = dis[cur] + 1;\\n          q.push(x);\\n        }\\n      }\\n    }\\n    int max_dis = INT_MIN, vertex;\\n    for (int i = 0; i < n; i++) {\\n      if (dis[i] > max_dis) {\\n        max_dis = dis[i];\\n        vertex = i;\\n      }\\n    }\\n    return vertex;\\n  }\\n\\n  vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n    g.resize(n);\\n    for (int i = 0; i < edges.size(); i++) {\\n      g[edges[i][0]].push_back(edges[i][1]);\\n      g[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    int start = bfs(0, n);\\n    int end = bfs(start, n);\\n    vector<int> parent(n), vis(n, 0);\\n    queue<int> q;\\n    parent[start] = -1;\\n    q.push(start);\\n    while (!q.empty()) {\\n      int cur = q.front();\\n      q.pop();\\n      vis[cur] = 1;\\n      for (int child : g[cur]) {\\n        if (vis[child] == 0) {\\n          parent[child] = cur;\\n          q.push(child);\\n        }\\n      }\\n    }\\n    vector<int> path;\\n    while (end != -1) {\\n      path.push_back(end);\\n      end = parent[end];\\n    }\\n    if (path.size() % 2 == 0) {\\n      return {path[path.size() / 2], path[path.size() / 2 - 1]};\\n    }\\n    return {path[path.size() / 2]};\\n  }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n  vector<vector<int>> g;\\n\\n public:\\n  int bfs(int src, int n) {\\n    vector<int> vis(n, -1), dis(n, 0);\\n    queue<int> q;\\n    q.push(src);\\n    while (!q.empty()) {\\n      int cur = q.front();\\n      q.pop();\\n      vis[cur] = 1;\\n      for (int x : g[cur]) {\\n        if (vis[x] == -1) {\\n          dis[x] = dis[cur] + 1;\\n          q.push(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 479559,
                "title": "python3-o-n-with-explanation",
                "content": "Note the following: if the height of a tree with root x is h, then the height of the same tree with the leaves removed and with root x is h - 1.\\n\\nTherefore, any vertex that minimizes the height of the tree also minimizes the height of the tree minus its leaves.  \\n\\nIn other words, if we remove all the leaves, we do not change the answer and we make the input smaller.\\n\\nTaking advantage of this, we iteratively remove leaves until we reach a point where all the vertices are leaves.  Note that this also proves that the size of the solution is 1 or 2.\\n```\\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -> List[int]:\\n        graph = [set() for _ in range(n)]\\n        \\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n\\n        leaves = [x for x in range(n) if len(graph[x]) <= 1]\\n        prev_leaves = leaves\\n        while leaves:\\n            new_leaves = []\\n            for leaf in leaves:\\n                if not graph[leaf]:\\n                    return leaves\\n                neighbor = graph[leaf].pop()\\n                graph[neighbor].remove(leaf)\\n                if len(graph[neighbor]) == 1:\\n                    new_leaves.append(neighbor)\\n            prev_leaves, leaves = leaves, new_leaves\\n\\n        return prev_leaves\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -> List[int]:\\n        graph = [set() for _ in range(n)]\\n        \\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n\\n        leaves = [x for x in range(n) if len(graph[x]) <= 1]\\n        prev_leaves = leaves\\n        while leaves:\\n            new_leaves = []\\n            for leaf in leaves:\\n                if not graph[leaf]:\\n                    return leaves\\n                neighbor = graph[leaf].pop()\\n                graph[neighbor].remove(leaf)\\n                if len(graph[neighbor]) == 1:\\n                    new_leaves.append(neighbor)\\n            prev_leaves, leaves = leaves, new_leaves\\n\\n        return prev_leaves\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 76121,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "My implementation just follows the idea that the-path-method inspired from \\n\\n[http://algobox.org/minimum-height-trees/][1]    \\n\\nJust like topological sorting, we delete the in-degree-1-node level by level.\\n\\nJust we can ensure that the path of the longest length will be left.\\n\\nSo the last 1 or last 2 node is the solution \\n\\n\\n    class Solution {\\n        public:\\n            vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n                vector<int> result;\\n                if(n==1) { result.push_back(0); return result; }\\n                vector<unordered_set<int>> graph(n, unordered_set<int>());\\n                for(int i=0; i<edges.size(); i++){\\n                    graph[edges[i].first].insert(edges[i].second);\\n                    graph[edges[i].second].insert(edges[i].first);\\n                }\\n                vector<int> degree(n, 0);\\n                for(int i=0; i<n; i++){\\n                    degree[i]=graph[i].size();\\n                    cout<<i<<\":\"<<degree[i]<<endl;\\n                }\\n                int count=n;\\n                while(count>2){\\n                    vector<int> record;\\n                    for(int i=0; i<n; i++){\\n                        if(degree[i]==1) {\\n                            count--;\\n                            degree[i]=-1;\\n                            record.push_back(i);\\n                        }\\n                    }\\n                    for(int i=0; i<record.size(); i++){\\n                        for(auto it : graph[record[i]])  degree[it]--;\\n                    }\\n                }\\n                for(int i=0; i<n; i++){\\n                    if(degree[i]==1 || degree[i]==0)  result.push_back(i);\\n                }\\n                return result;\\n            }\\n        };\\n\\n  [1]: http://algobox.org/minimum-height-trees/",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n                vector<int> result;\\n                if(n==1) { result.push_back(0); return result; }",
                "codeTag": "Java"
            },
            {
                "id": 1631066,
                "title": "dp-on-trees-multiple-approaches-image",
                "content": "**Idea? Dp on Trees with Rerooting**\\n* Let\\'s understand the problem in simpler words.*Consider D1,D2,...Dn is the maximum depth of tree rooted at node Di. We need to find min(D1, D2,...Dn). Then, find all those nodes which give this minimum Value*.\\n* The Basic Approach is to consider every node as the root node and find the maximum depth of the tree, store it in the vector of pairs and find those nodes which correspond to the minimum maximum depth of the tree. It will cost **O(n^2) time which won\\'t give AC**. **How do we optimize our code?** **Can we answer the maximum depth of tree for the current root node without running dfs again?**\\n* Yes, We can find that.\\n**Steps:-**\\n* **Root the Tree at any node** and find the maximum depth of every subtree (stored in vector h).\\n* Now, **Can we answer the maximum depth of tree when we consider v as the root node?**\\n* Yes.\\n* **Maximum depth [v] = 1 + max(par max upto node p,max(h[u])) for all u which is child of v**\\n* Note that when we move to child u of node v, par max for child u changes.\\n* **par max for child u will be max(par max of node v,max(h[t])) for all t not equal to u.**\\n* Check code for a detailed explanation.\\n![image](https://assets.leetcode.com/users/images/601cec6c-43cd-43ac-a1f6-067baae6c992_1639638364.554435.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O((V+E)log(V))\\n    // Space Complexity:- O(V)\\n    int MHT = INT_MAX; // Minimum Height, considering every node as root\\n    vector<int> ans; // stores all MHTs\\n    void dfs(int v,int p,vector<int> adj[],vector<int>& h){\\n        // h[v] = maximum depth of subtree of v\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                dfs(u,v,adj,h);\\n                h[v] = max(h[v],h[u]);\\n            }\\n        }\\n        h[v]++;\\n    }\\n    void dfs(int v,int p,vector<int> adj[],vector<int>& h,int par_max){\\n        // par_max stores maximum height of subtree of p when v is the child of p\\n        // multiset stores maximum height of all child nodes when we consider v as root node\\n        multiset<int,greater<int>> mx = {par_max};\\n        for(auto& u:adj[v]){\\n            if(u!=p)\\n                mx.insert(h[u]);\\n        }\\n        // 1 + *mx.begin() = maximum depth of tree if v is the root node\\n        if(1+*mx.begin()<MHT){\\n            MHT = 1 + *mx.begin();\\n            ans.clear();\\n            ans.push_back(v);\\n        }\\n        else if(1+*mx.begin()==MHT)\\n            ans.push_back(v);\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                // if we go to child u, we need to pass par_max\\n                // we should erase maximum height entry for subtree of u from multiset\\n                mx.erase(mx.find(h[u]));\\n                dfs(u,v,adj,h,1+*mx.begin());\\n                mx.insert(h[u]);\\n            }\\n        }\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n],h(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        dfs(0,-1,adj,h); // find the maximum depth for every subtree considering root node as 0\\n        dfs(0,-1,adj,h,0); // finds all nodes which corresponds to MHT\\n        return ans;\\n    }\\n};\\n```\\n\\n**Since we maximum at each time totally depends on maximum or second maximum element present in the multiset, we replace multiset by storing maximum and second maximum each time.**\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(V+E)\\n    // Space Complexity:- O(V)\\n    int MHT = INT_MAX; // Minimum Height, considering every node as root\\n    vector<int> ans; // stores all MHTs\\n    void dfs(int v,int p,vector<int> adj[],vector<int>& h){\\n        // h[v] = maximum depth of subtree of v\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                dfs(u,v,adj,h);\\n                h[v] = max(h[v],h[u]);\\n            }\\n        }\\n        h[v]++;\\n    }\\n    void dfs(int v,int p,vector<int> adj[],vector<int>& h,int par_max){\\n        // par_max stores maximum height of subtree of p when v is the child of p\\n        pair<int,int> mx = {par_max,0}; // first element = maximum, second element = second maximum\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                if(h[u]>mx.first){\\n                    mx.second = mx.first;\\n                    mx.first = h[u];\\n                }\\n                else\\n                    mx.second = max(mx.second,h[u]);\\n            }\\n        }\\n        if(1+mx.first<MHT){\\n            MHT = 1 + mx.first;\\n            ans.clear();\\n            ans.push_back(v);\\n        }\\n        else if(1+mx.first==MHT)\\n            ans.push_back(v);\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                // if we go to child u, we need to pass par_max\\n                // we should erase maximum height entry for subtree of u from multiset\\n                int curr = (h[u]==mx.first)?mx.second:mx.first;\\n                dfs(u,v,adj,h,1+curr);\\n            }\\n        }\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n],h(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        dfs(0,-1,adj,h); // find the maximum depth for every subtree considering root node as 0\\n        dfs(0,-1,adj,h,0); // finds all nodes which corresponds to MHT\\n        return ans;\\n    }\\n};\\n```\\n**Alternate Approach**\\n* **Answer will be at most 2 vertices? Why?**\\n* For a tree, it has almost two centers and from centers, we will have maximum depth being minimized.\\n* **For an odd number of nodes, there will be only one cente**r.\\n* **For an even number of nodes, there will be two centers.**\\n* How to find all center nodes of a tree?\\n* Start Plucking Leaves of the tree one by one, finally you will end with nodes having centers.\\n* How to do that?, **Hint:- Degree of leaves = 1 in an undirected graph.**\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(V+E)\\n    // Space Complexity:- O(V)\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)\\n            return {0};\\n        vector<int> deg(n),adj[n];\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n            deg[edge[1]]++;deg[edge[0]]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(deg[i]==1){ // start with leaves\\n                deg[i]--;\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            ans.clear();\\n            while(sz--){\\n                int v = q.front();\\n                q.pop();\\n                \\n                ans.push_back(v);\\n                for(auto& u:adj[v]){\\n                    if(--deg[u]==1) // when the current node becomes a leaf push it into queue\\n                        q.push(u);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O((V+E)log(V))\\n    // Space Complexity:- O(V)\\n    int MHT = INT_MAX; // Minimum Height, considering every node as root\\n    vector<int> ans; // stores all MHTs\\n    void dfs(int v,int p,vector<int> adj[],vector<int>& h){\\n        // h[v] = maximum depth of subtree of v\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                dfs(u,v,adj,h);\\n                h[v] = max(h[v],h[u]);\\n            }\\n        }\\n        h[v]++;\\n    }\\n    void dfs(int v,int p,vector<int> adj[],vector<int>& h,int par_max){\\n        // par_max stores maximum height of subtree of p when v is the child of p\\n        // multiset stores maximum height of all child nodes when we consider v as root node\\n        multiset<int,greater<int>> mx = {par_max};\\n        for(auto& u:adj[v]){\\n            if(u!=p)\\n                mx.insert(h[u]);\\n        }\\n        // 1 + *mx.begin() = maximum depth of tree if v is the root node\\n        if(1+*mx.begin()<MHT){\\n            MHT = 1 + *mx.begin();\\n            ans.clear();\\n            ans.push_back(v);\\n        }\\n        else if(1+*mx.begin()==MHT)\\n            ans.push_back(v);\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                // if we go to child u, we need to pass par_max\\n                // we should erase maximum height entry for subtree of u from multiset\\n                mx.erase(mx.find(h[u]));\\n                dfs(u,v,adj,h,1+*mx.begin());\\n                mx.insert(h[u]);\\n            }\\n        }\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n],h(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        dfs(0,-1,adj,h); // find the maximum depth for every subtree considering root node as 0\\n        dfs(0,-1,adj,h,0); // finds all nodes which corresponds to MHT\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(V+E)\\n    // Space Complexity:- O(V)\\n    int MHT = INT_MAX; // Minimum Height, considering every node as root\\n    vector<int> ans; // stores all MHTs\\n    void dfs(int v,int p,vector<int> adj[],vector<int>& h){\\n        // h[v] = maximum depth of subtree of v\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                dfs(u,v,adj,h);\\n                h[v] = max(h[v],h[u]);\\n            }\\n        }\\n        h[v]++;\\n    }\\n    void dfs(int v,int p,vector<int> adj[],vector<int>& h,int par_max){\\n        // par_max stores maximum height of subtree of p when v is the child of p\\n        pair<int,int> mx = {par_max,0}; // first element = maximum, second element = second maximum\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                if(h[u]>mx.first){\\n                    mx.second = mx.first;\\n                    mx.first = h[u];\\n                }\\n                else\\n                    mx.second = max(mx.second,h[u]);\\n            }\\n        }\\n        if(1+mx.first<MHT){\\n            MHT = 1 + mx.first;\\n            ans.clear();\\n            ans.push_back(v);\\n        }\\n        else if(1+mx.first==MHT)\\n            ans.push_back(v);\\n        for(auto& u:adj[v]){\\n            if(u!=p){\\n                // if we go to child u, we need to pass par_max\\n                // we should erase maximum height entry for subtree of u from multiset\\n                int curr = (h[u]==mx.first)?mx.second:mx.first;\\n                dfs(u,v,adj,h,1+curr);\\n            }\\n        }\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n],h(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        dfs(0,-1,adj,h); // find the maximum depth for every subtree considering root node as 0\\n        dfs(0,-1,adj,h,0); // finds all nodes which corresponds to MHT\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(V+E)\\n    // Space Complexity:- O(V)\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)\\n            return {0};\\n        vector<int> deg(n),adj[n];\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n            deg[edge[1]]++;deg[edge[0]]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(deg[i]==1){ // start with leaves\\n                deg[i]--;\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            ans.clear();\\n            while(sz--){\\n                int v = q.front();\\n                q.pop();\\n                \\n                ans.push_back(v);\\n                for(auto& u:adj[v]){\\n                    if(--deg[u]==1) // when the current node becomes a leaf push it into queue\\n                        q.push(u);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427802,
                "title": "javascript-bfs-solution",
                "content": "```js\\nvar findMinHeightTrees = function(n, edges) {\\n    if (!edges || n < 2) return [0];\\n    let graph = [];\\n\\t// parse edges\\n    for (let [x, y] of edges) {\\n        graph[x] = graph[x] || [];\\n        graph[y] = graph[y] || [];\\n        graph[x].push(y);\\n        graph[y].push(x);\\n    }\\n    let leaves = [];\\n\\t// init leaf nodes\\n    graph.map((pts,i) => pts.length === 1 && leaves.push(i));\\n    while (n > 2) {\\n        n = n - leaves.length;\\n        let nxt_leaves = [];\\n        for (let leave of leaves) {\\n\\t\\t    // remove leaf node and itself in related nodes\\n            tmp = graph[leave].pop();\\n            graph[tmp].splice(graph[tmp].indexOf(leave),1);\\n\\t\\t\\t// save new leaf node\\n            graph[tmp].length === 1 && nxt_leaves.push(tmp);\\n        }\\n        leaves = nxt_leaves;\\n    }\\n    return leaves;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar findMinHeightTrees = function(n, edges) {\\n    if (!edges || n < 2) return [0];\\n    let graph = [];\\n\\t// parse edges\\n    for (let [x, y] of edges) {\\n        graph[x] = graph[x] || [];\\n        graph[y] = graph[y] || [];\\n        graph[x].push(y);\\n        graph[y].push(x);\\n    }\\n    let leaves = [];\\n\\t// init leaf nodes\\n    graph.map((pts,i) => pts.length === 1 && leaves.push(i));\\n    while (n > 2) {\\n        n = n - leaves.length;\\n        let nxt_leaves = [];\\n        for (let leave of leaves) {\\n\\t\\t    // remove leaf node and itself in related nodes\\n            tmp = graph[leave].pop();\\n            graph[tmp].splice(graph[tmp].indexOf(leave),1);\\n\\t\\t\\t// save new leaf node\\n            graph[tmp].length === 1 && nxt_leaves.push(tmp);\\n        }\\n        leaves = nxt_leaves;\\n    }\\n    return leaves;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76142,
                "title": "35ms-concise-java-solution",
                "content": "\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) {\\n            return Arrays.asList(0);\\n        }\\n        \\n        List<List<Integer>> adj = new ArrayList<>();\\n        int[] inlinks = new int[n];\\n        createGraph(n, edges, adj, inlinks);\\n         \\n        List<Integer> leaves = new LinkedList<>();\\n        for(int i = 0; i < inlinks.length; i++) {\\n            if (inlinks[i] == 1) {\\n                leaves.add(i);\\n            }\\n        }\\n        \\n        while (n > 2) {\\n            List<Integer> newLeaves = new ArrayList<>();\\n            for (int leave : leaves) {\\n                for (int nb : adj.get(leave)) {\\n                    inlinks[nb]--;\\n                    if (inlinks[nb] == 1) {\\n                        newLeaves.add(nb);\\n                    }\\n                }\\n            }\\n            n -= leaves.size();\\n            leaves = newLeaves;\\n        }\\n        \\n        return leaves;\\n    }\\n    \\n    public void createGraph(int n, int[][] edges, List<List<Integer>> adj, int[] inlinks) {\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for (int[] e : edges) {\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n            inlinks[e[0]]++;\\n            inlinks[e[1]]++;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) {\\n            return Arrays.asList(0);\\n        }\\n        \\n        List<List<Integer>> adj = new ArrayList<>();\\n        int[] inlinks = new int[n];\\n        createGraph(n, edges, adj, inlinks);\\n         \\n        List<Integer> leaves = new LinkedList<>();\\n        for(int i = 0; i < inlinks.length; i++) {\\n            if (inlinks[i] == 1) {\\n                leaves.add(i);\\n            }\\n        }\\n        \\n        while (n > 2) {\\n            List<Integer> newLeaves = new ArrayList<>();\\n            for (int leave : leaves) {\\n                for (int nb : adj.get(leave)) {\\n                    inlinks[nb]--;\\n                    if (inlinks[nb] == 1) {\\n                        newLeaves.add(nb);\\n                    }\\n                }\\n            }\\n            n -= leaves.size();\\n            leaves = newLeaves;\\n        }\\n        \\n        return leaves;\\n    }\\n    \\n    public void createGraph(int n, int[][] edges, List<List<Integer>> adj, int[] inlinks) {\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for (int[] e : edges) {\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n            inlinks[e[0]]++;\\n            inlinks[e[1]]++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2351916,
                "title": "c-easy-to-understand-linear-solution-with-explanation-bfs-topological-sort",
                "content": "**The nodes having more edges attached to it will be our answer.\\nIn other words the nodes having highest indegree will be the answer.\\nIf you remember the topological sort order, then the last nodes in topological order have highest indegree\\nThere can be either 1 node or 2 node as root.**\\n\\n\\n**Algorithm -**\\n\\n1. Create a graph with adjacency list\\n2. Create an indegree array to store indegree of the nodes, initialise indegree array with 0\\n3. if number of nodes is 1, return {0}\\n4. Create vector<int> ans to return answer\\n5. if number of nodes are 2, return {0,1}\\n6. Fill the edges in graph and store the indegree of nodes in indegree array\\n7. Create a queue to perform BFS\\n8. Store all leaf nodes in queue, (leaf nodes are those nodes which have indegree as 1\\n9. Traversing the graph level order according to 1 indegree nodes\\n10. For each level, s = q.size() and clear to stored answer as if there are elements in queue then we will have our answer in that queue(in topological sort, most indegree node will be the final answer)\\n11. For all nodes of that level, (watch s-- loop in code), pop them from queue, push it to our ans and treverse all adjacent nodes of the popped node and decrease their indegree by 1, if indegree of that adjacent node is 1 we will push it to our queue\\n12. return ans finally\\n\\n```\\n vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n); \\n        int indegree[n];\\n        memset(indegree, 0 , sizeof(indegree));\\n        if(n == 1){\\n            return {0};\\n        }\\n        \\n        if(n == 2){\\n            return {0,1};\\n        }\\n        \\n        for(vector<int> edge: edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            indegree[edge[0]] += 1;              // storing indegree of nodes\\n            indegree[edge[1]] += 1;              // storing indegree of nodes\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i = 0 ; i < n ; i++ ){\\n            if(indegree[i] == 1){\\n                q.push(i);                       // storing leaf nodes in queue\\n            }\\n        }\\n        vector<int> ans;\\n   \\n        while( q.empty()  == false){\\n            int s =  q.size();                  // getting number of nodes on a particular level of graph\\n            ans = {};\\n            while(s--){                         // traversing all nodes on that level\\n                int u = q.front();\\n                q.pop();\\n                ans.push_back(u);\\n                \\n                for(int adj : graph[u]){           // traversing the adjacent nodes of the popped node\\n                    indegree[adj] -= 1;           // decreasing the indegree of adjacent node by 1\\n                    if(indegree[adj] == 1){\\n                        q.push(adj);                   // storing 1 indegree node in queue, there will be some having negative and 0, we need to skip them we have to store only 1 indegree nodes, which shows that this node is a leaf if it is detached from its parent\\n                    }\\n                }\\n                \\n            }\\n        }\\n \\n        return ans;\\n \\n    }\\n```\\n\\n\\n\\n\\nLet\\'s have a look around the time complexity and space complexity of the solution\\nTime Complexity - O(N+E), N is number of nodes and E is number of edges\\nSpace Complexity - O(N), queue used for bfs",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\n vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n); \\n        int indegree[n];\\n        memset(indegree, 0 , sizeof(indegree));\\n        if(n == 1){\\n            return {0};\\n        }\\n        \\n        if(n == 2){\\n            return {0,1};\\n        }\\n        \\n        for(vector<int> edge: edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            indegree[edge[0]] += 1;              // storing indegree of nodes\\n            indegree[edge[1]] += 1;              // storing indegree of nodes\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i = 0 ; i < n ; i++ ){\\n            if(indegree[i] == 1){\\n                q.push(i);                       // storing leaf nodes in queue\\n            }\\n        }\\n        vector<int> ans;\\n   \\n        while( q.empty()  == false){\\n            int s =  q.size();                  // getting number of nodes on a particular level of graph\\n            ans = {};\\n            while(s--){                         // traversing all nodes on that level\\n                int u = q.front();\\n                q.pop();\\n                ans.push_back(u);\\n                \\n                for(int adj : graph[u]){           // traversing the adjacent nodes of the popped node\\n                    indegree[adj] -= 1;           // decreasing the indegree of adjacent node by 1\\n                    if(indegree[adj] == 1){\\n                        q.push(adj);                   // storing 1 indegree node in queue, there will be some having negative and 0, we need to skip them we have to store only 1 indegree nodes, which shows that this node is a leaf if it is detached from its parent\\n                    }\\n                }\\n                \\n            }\\n        }\\n \\n        return ans;\\n \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307101,
                "title": "java-17ms-o-n-solution-using-topological-sort-with-explanation",
                "content": "Using the same idea of topological sort for directed graph and modify it a little, we can apply this method to sort undirect graph. \\nThe difference is:\\n1. When indegree of a node equals to 1 (which is 0 for directed graph), we push it into a queue;\\n2. We should check the adjacent node is already visited, if it is, skip it;\\n\\nHere is an example\\n```\\nInput: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]\\n\\n     0  1  2\\n      \\\\ | /\\n        3\\n        |\\n        4\\n        |\\n        5 \\n\\nThe indegrees of nodes 0 - 5 are: 1, 1, 1, 4, 2, 1\\nSo in the first round, we push node 0, 1, 2, 5 into the queue, and recalculate the indegrees of the rest nodes; \\nWe can see after the first round, the indegrees of both node 3 and node 4 are 1, so we push them into the queue;\\nThen there are no more nodes need to sort, so we poll the nodes in the queue into the resulting list, and get the final result [3, 4]\\n```\\n\\nHere are the codes:\\n```java\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // if edges is Empty, return [0]\\n        List<Integer> list = new ArrayList<>();\\n        if (edges.length == 0) {\\n            list.add(0);\\n            return list;\\n        }\\n        \\n        // calculate the indegree of every node\\n        int[] indegree = new int[n];\\n        // save adjacent nodes of certain node into a HashMap\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new ArrayList<>());\\n        for (int i = 0; i < edges.length; i++) {\\n            // for undirected graph, every edge has two directions, therefore...\\n            indegree[edges[i][0]]++;\\n            indegree[edges[i][1]]++;\\n            map.get(edges[i][0]).add(edges[i][1]);\\n            map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        // if indegree of a node is 1, it means that the node only has one adjacent node \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) if (indegree[i] == 1) q.offer(i);\\n        \\n        // count the number of nodes which has been watached\\n        int count = 0;\\n        while (! q.isEmpty()) {\\n            int size = q.size();\\n            count += size;\\n            for (int i = 0; i < size; i++) {\\n                Integer id = q.poll();\\n                indegree[id]--;\\n                // if count == n, add the id of node into the resulting list\\n                if (count == n) list.add(id);\\n                for (Integer adjId : map.get(id)) {\\n                    // if indegree of a node equals to 0, it means this node has already been added into the reulsting list\\n                    if (indegree[adjId] != 0) {\\n                        indegree[adjId]--;\\n                        if (indegree[adjId] == 1) q.offer(adjId);\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nInput: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]\\n\\n     0  1  2\\n      \\\\ | /\\n        3\\n        |\\n        4\\n        |\\n        5 \\n\\nThe indegrees of nodes 0 - 5 are: 1, 1, 1, 4, 2, 1\\nSo in the first round, we push node 0, 1, 2, 5 into the queue, and recalculate the indegrees of the rest nodes; \\nWe can see after the first round, the indegrees of both node 3 and node 4 are 1, so we push them into the queue;\\nThen there are no more nodes need to sort, so we poll the nodes in the queue into the resulting list, and get the final result [3, 4]\\n```\n```java\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // if edges is Empty, return [0]\\n        List<Integer> list = new ArrayList<>();\\n        if (edges.length == 0) {\\n            list.add(0);\\n            return list;\\n        }\\n        \\n        // calculate the indegree of every node\\n        int[] indegree = new int[n];\\n        // save adjacent nodes of certain node into a HashMap\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new ArrayList<>());\\n        for (int i = 0; i < edges.length; i++) {\\n            // for undirected graph, every edge has two directions, therefore...\\n            indegree[edges[i][0]]++;\\n            indegree[edges[i][1]]++;\\n            map.get(edges[i][0]).add(edges[i][1]);\\n            map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        // if indegree of a node is 1, it means that the node only has one adjacent node \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) if (indegree[i] == 1) q.offer(i);\\n        \\n        // count the number of nodes which has been watached\\n        int count = 0;\\n        while (! q.isEmpty()) {\\n            int size = q.size();\\n            count += size;\\n            for (int i = 0; i < size; i++) {\\n                Integer id = q.poll();\\n                indegree[id]--;\\n                // if count == n, add the id of node into the resulting list\\n                if (count == n) list.add(id);\\n                for (Integer adjId : map.get(id)) {\\n                    // if indegree of a node equals to 0, it means this node has already been added into the reulsting list\\n                    if (indegree[adjId] != 0) {\\n                        indegree[adjId]--;\\n                        if (indegree[adjId] == 1) q.offer(adjId);\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233891,
                "title": "concise-javascript",
                "content": "```\\nvar findMinHeightTrees = function(n, edges) {\\n    let g={};\\n    for(let i=0;i<n;i++) g[i]=new Set;\\n    for(let [a,b] of edges){\\n        g[a].add(b);\\n        g[b].add(a);\\n    }\\n    \\n    while(Object.keys(g).length > 2){\\n        Object.keys(g).filter(v=>g[v].size<2).forEach(v=>{\\n            g[v].forEach(nextv=>g[nextv].delete(parseInt(v)));\\n            delete g[v];\\n        })\\n    }\\n    \\n    return Object.keys(g);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findMinHeightTrees = function(n, edges) {\\n    let g={};\\n    for(let i=0;i<n;i++) g[i]=new Set;\\n    for(let [a,b] of edges){\\n        g[a].add(b);\\n        g[b].add(a);\\n    }\\n    \\n    while(Object.keys(g).length > 2){\\n        Object.keys(g).filter(v=>g[v].size<2).forEach(v=>{\\n            g[v].forEach(nextv=>g[nextv].delete(parseInt(v)));\\n            delete g[v];\\n        })\\n    }\\n    \\n    return Object.keys(g);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 923360,
                "title": "java-96-fast-explained",
                "content": "Use topological sort to filter out leaf elements.\\nSince the Minimum Height Tree nodes are to be well connected to all (therefore have least height), they are the ones left after you remove leaf nodes. The ones left are the MHT nodes.\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n      if(n==1)\\n        return Arrays.asList(0);\\n      \\n      //create a map\\n      List<Integer>[] map = new List[n];\\n      for(int i=0;i<n;i++)\\n        map[i] = new ArrayList<>();\\n      \\n      int[] indegree = new int[n];\\n        \\n      for(int edge[]:edges){\\n        int a=edge[0], b=edge[1];\\n        map[a].add(b);indegree[a]++;\\n        map[b].add(a);indegree[b]++;\\n      }\\n      \\n      Queue<Integer> queue = new LinkedList<>();\\n      \\n      for(int i=0;i<n;i++)\\n        if(indegree[i]==1)\\n          queue.add(i);\\n       \\n      List<Integer> result = new ArrayList<>();\\n      \\n      while(!queue.isEmpty()){\\n        result = new ArrayList<>();\\n        int size = queue.size();\\n        while(size--!=0){\\n          int node = queue.remove();\\n          result.add(node);\\n          for(int nebour: map[node]){\\n            if(--indegree[nebour]==1)\\n              queue.add(nebour);\\n          }\\n        }\\n      }\\n      \\n      return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n      if(n==1)\\n        return Arrays.asList(0);\\n      \\n      //create a map\\n      List<Integer>[] map = new List[n];\\n      for(int i=0;i<n;i++)\\n        map[i] = new ArrayList<>();\\n      \\n      int[] indegree = new int[n];\\n        \\n      for(int edge[]:edges){\\n        int a=edge[0], b=edge[1];\\n        map[a].add(b);indegree[a]++;\\n        map[b].add(a);indegree[b]++;\\n      }\\n      \\n      Queue<Integer> queue = new LinkedList<>();\\n      \\n      for(int i=0;i<n;i++)\\n        if(indegree[i]==1)\\n          queue.add(i);\\n       \\n      List<Integer> result = new ArrayList<>();\\n      \\n      while(!queue.isEmpty()){\\n        result = new ArrayList<>();\\n        int size = queue.size();\\n        while(size--!=0){\\n          int node = queue.remove();\\n          result.add(node);\\n          for(int nebour: map[node]){\\n            if(--indegree[nebour]==1)\\n              queue.add(nebour);\\n          }\\n        }\\n      }\\n      \\n      return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320092,
                "title": "python-remove-all-leaves-level-by-level-until-one-two-leaves-are-left",
                "content": "**Idea**\\n- Basically, the idea is to eat up all the leaves at the same time, until one/two leaves are left. This is same idea with Topological Sorting.\\n- I borrowed this idea from [@earlme](https://leetcode.com/earlme/).\\n![image](https://assets.leetcode.com/users/images/fb2d704f-22a5-44dc-b788-4b8d1bccd13b_1625575926.652073.png)\\n\\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1: return [0]\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n            \\n        leaves = []\\n        for i in range(n):\\n            if len(graph[i]) == 1:\\n                leaves.append(i)\\n                \\n        while n > 2:\\n            n -= len(leaves)\\n            newLeaves = []\\n            for i in leaves:\\n                j = graph[i].pop()  # Pop a remain neighbor\\n                graph[j].remove(i)\\n                if len(graph[j]) == 1:\\n                    newLeaves.append(j)\\n            leaves = newLeaves\\n        return leaves\\n```\\nComplexity:\\n- Time & Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1: return [0]\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n            \\n        leaves = []\\n        for i in range(n):\\n            if len(graph[i]) == 1:\\n                leaves.append(i)\\n                \\n        while n > 2:\\n            n -= len(leaves)\\n            newLeaves = []\\n            for i in leaves:\\n                j = graph[i].pop()  # Pop a remain neighbor\\n                graph[j].remove(i)\\n                if len(graph[j]) == 1:\\n                    newLeaves.append(j)\\n            leaves = newLeaves\\n        return leaves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240534,
                "title": "310-time-96-8-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can solve this problem using a BFS approach. We start by building an adjacency list of the input edges, which is a mapping between each node and its neighboring nodes. We can then perform a breadth-first search starting from the leaf nodes and moving towards the root. At each level of the BFS, we remove the leaf nodes and their corresponding edges from the adjacency list, until we are left with only 1 or 2 nodes. These nodes are the roots of the MHTs.\\n\\nAlgorithm:\\n\\n1. Build the adjacency list for the graph using the input edges.\\n2. Initialize a queue with all leaf nodes (i.e., nodes with degree 1) and remove them from the adjacency list.\\n3. While there are more than 2 nodes in the graph:\\na. Initialize a list to store the new leaf nodes.\\nb. For each node in the current level of the BFS:\\ni. For each of its neighboring nodes, remove the corresponding edge from the adjacency list.\\nii. If the neighboring node becomes a leaf node (i.e., degree 1), add it to the new leaf node list.\\nc. Remove the current level nodes from the graph.\\nd. Add the new leaf nodes to the queue.\\n4. Return the remaining nodes as the roots of the MHTs.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n    # Edge case: n=1, return [0]\\n    if n == 1:\\n        return [0]\\n    \\n    # Build adjacency list for the graph\\n    adj_list = {i: set() for i in range(n)}\\n    for u, v in edges:\\n        adj_list[u].add(v)\\n        adj_list[v].add(u)\\n    \\n    # Find all leaf nodes (i.e., nodes with degree 1)\\n    leaves = [i for i in range(n) if len(adj_list[i]) == 1]\\n    \\n    # Repeat until we are left with 1 or 2 nodes\\n    while n > 2:\\n        \\n        # Remove the current leaf nodes along with their edges\\n        n -= len(leaves)\\n        new_leaves = []\\n        for leaf in leaves:\\n            neighbor = adj_list[leaf].pop()\\n            adj_list[neighbor].remove(leaf)\\n            \\n            # If the neighbor becomes a new leaf node, add it to the list\\n            if len(adj_list[neighbor]) == 1:\\n                new_leaves.append(neighbor)\\n        \\n        # Update the list of leaf nodes\\n        leaves = new_leaves\\n    \\n    # The remaining nodes are the roots of the MHTs\\n    return leaves\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n    # Edge case: n=1, return [0]\\n    if n == 1:\\n        return [0]\\n    \\n    # Build adjacency list for the graph\\n    adj_list = {i: set() for i in range(n)}\\n    for u, v in edges:\\n        adj_list[u].add(v)\\n        adj_list[v].add(u)\\n    \\n    # Find all leaf nodes (i.e., nodes with degree 1)\\n    leaves = [i for i in range(n) if len(adj_list[i]) == 1]\\n    \\n    # Repeat until we are left with 1 or 2 nodes\\n    while n > 2:\\n        \\n        # Remove the current leaf nodes along with their edges\\n        n -= len(leaves)\\n        new_leaves = []\\n        for leaf in leaves:\\n            neighbor = adj_list[leaf].pop()\\n            adj_list[neighbor].remove(leaf)\\n            \\n            # If the neighbor becomes a new leaf node, add it to the list\\n            if len(adj_list[neighbor]) == 1:\\n                new_leaves.append(neighbor)\\n        \\n        # Update the list of leaf nodes\\n        leaves = new_leaves\\n    \\n    # The remaining nodes are the roots of the MHTs\\n    return leaves\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135345,
                "title": "straightforward-solution-with-finding-center-of-the-tree-algorithm",
                "content": "This problem is simply about to find Center of the tree in Undirected Acyclic Graph (or Tree idk)\\n\\nMy solution **beat** **86% runtime, beat 80% memory.**\\n\\nCenter is always the middle node in every longes path along the tree. And also centers can be 2 at most.\\n\\nExplanation:\\n- Iteratively pick off each leaf nodes (when node has 1 or 0 `degree` (neighbor), add to the `leaves` list,\\n- Since you are picking off leaf, decrease degree each of its neighbors.\\n- Finally all nodes added to `leaves` (tracking using `c` var since we need to replace `leaves` with `newLeaves`)\\n- Last 1 (or 2) nodes in the `leaves` would be center(s) of the tree which considered as minimum height tree\\'s root node \\n\\n\\n```\\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        int[] degree = new int[n];\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n        }\\n        List<Integer> leaves = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (degree[i] <= 1) {\\n                leaves.add(i);\\n                degree[i] = 0;\\n            }\\n        }\\n        \\n        int c = leaves.size();\\n        \\n        while (c < n) {\\n            List<Integer> newLeaves = new ArrayList<>();\\n            for (int leaf : leaves) {\\n                for (int neighbor : map.get(leaf)) {\\n                    degree[neighbor]--;\\n                    if (degree[neighbor] == 1) {\\n                        newLeaves.add(neighbor);\\n                    }\\n                }\\n                degree[leaf] = 0;\\n            }\\n            c += newLeaves.size();\\n            leaves = newLeaves;\\n        }\\n        \\n        return leaves;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        int[] degree = new int[n];\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n        }\\n        List<Integer> leaves = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (degree[i] <= 1) {\\n                leaves.add(i);\\n                degree[i] = 0;\\n            }\\n        }\\n        \\n        int c = leaves.size();\\n        \\n        while (c < n) {\\n            List<Integer> newLeaves = new ArrayList<>();\\n            for (int leaf : leaves) {\\n                for (int neighbor : map.get(leaf)) {\\n                    degree[neighbor]--;\\n                    if (degree[neighbor] == 1) {\\n                        newLeaves.add(neighbor);\\n                    }\\n                }\\n                degree[leaf] = 0;\\n            }\\n            c += newLeaves.size();\\n            leaves = newLeaves;\\n        }\\n        \\n        return leaves;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 76138,
                "title": "java-layer-by-layer-bfs",
                "content": "The idea is to layer by layer BFS from the leaf nodes. The last one or two nodes would be the center\\n\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n    \\tSet<Integer> []adj = (Set<Integer>[]) new HashSet[n];\\n    \\tSet<Integer> ans = new HashSet<>();\\n    \\tfor (int i = 0; i < n; ++i) {\\n    \\t\\tans.add(i);\\n    \\t}\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tadj[i] = new HashSet<>();\\n    \\t}\\n\\n    \\tfor (int i = 0; i < n - 1; i++) {\\n    \\t\\tint from = edges[i][0];\\n    \\t\\tint to = edges[i][1];\\n    \\t\\tadj[from].add(to);\\n    \\t\\tadj[to].add(from);\\n    \\t}\\n\\n    \\tSet<Integer> leaves = new HashSet<>();\\n    \\twhile(ans.size() > 2) {\\n    \\t\\tfor (int v : ans) {\\n    \\t\\t\\tif (adj[v].size() == 1) {\\n    \\t\\t\\t\\tleaves.add(v);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tans.removeAll(leaves);\\n    \\t\\tSet<Integer> nxtLeaves = new HashSet<>();\\n    \\t\\tfor (int v : leaves) {\\n    \\t\\t\\tint adjNode = adj[v].iterator().next();\\n\\t\\t\\t\\tadj[adjNode].remove(v);\\n\\t\\t\\t\\tif (adj[adjNode].size() == 1) {\\n\\t\\t\\t\\t\\tnxtLeaves.add(adjNode);\\n\\t\\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tleaves = nxtLeaves;\\n    \\t}\\n    \\treturn new ArrayList<>(ans);\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "The idea is to layer by layer BFS from the leaf nodes. The last one or two nodes would be the center\\n\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n    \\tSet<Integer> []adj = (Set<Integer>[]) new HashSet[n];\\n    \\tSet<Integer> ans = new HashSet<>();\\n    \\tfor (int i = 0; i < n; ++i) {\\n    \\t\\tans.add(i);\\n    \\t}\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tadj[i] = new HashSet<>();\\n    \\t}\\n\\n    \\tfor (int i = 0; i < n - 1; i++) {\\n    \\t\\tint from = edges[i][0];\\n    \\t\\tint to = edges[i][1];\\n    \\t\\tadj[from].add(to);\\n    \\t\\tadj[to].add(from);\\n    \\t}\\n\\n    \\tSet<Integer> leaves = new HashSet<>();\\n    \\twhile(ans.size() > 2) {\\n    \\t\\tfor (int v : ans) {\\n    \\t\\t\\tif (adj[v].size() == 1) {\\n    \\t\\t\\t\\tleaves.add(v);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tans.removeAll(leaves);\\n    \\t\\tSet<Integer> nxtLeaves = new HashSet<>();\\n    \\t\\tfor (int v : leaves) {\\n    \\t\\t\\tint adjNode = adj[v].iterator().next();\\n\\t\\t\\t\\tadj[adjNode].remove(v);\\n\\t\\t\\t\\tif (adj[adjNode].size() == 1) {\\n\\t\\t\\t\\t\\tnxtLeaves.add(adjNode);\\n\\t\\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tleaves = nxtLeaves;\\n    \\t}\\n    \\treturn new ArrayList<>(ans);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2118098,
                "title": "possibly-the-best-rerooting-solution-c",
                "content": "The idea is based on this question: https://leetcode.com/problems/sum-of-distances-in-tree/\\n\\n```\\nclass Solution {\\npublic:\\n    int minh = INT_MAX; // minimum height\\n    vector<pair<int,int>> heights;\\n    // First we\\'ll store heights with tree rooted at node 0\\n    int findHeight(vector<vector<int>>&graph,int u,int p)\\n    {\\n        int m1=0,m2=0,tmp;\\n        // m1 is max height, m2 is second max heigh\\n        for(int &v:graph[u])\\n        {\\n            if(v!=p)\\n            {\\n                tmp = 1 + findHeight(graph,v,u);\\n                if(tmp>m1)\\n                {\\n                    m2 = m1;\\n                    m1 =tmp;\\n                }\\n                else if(tmp>m2)\\n                {\\n                    m2 = tmp;\\n                }\\n            }\\n        }\\n        heights[u] = {m1,m2};\\n        return max(m1,m2);\\n    }\\n    void reroot(vector<vector<int>>&graph,int u,int p)\\n    {\\n       minh = min(minh,heights[u].first);\\n       int extra; //  extra height which the parent give to its child node\\n        \\n       for(int &v:graph[u])\\n       {\\n           if(v!=p)\\n           {\\n               // If child is in the path of maximum height of the parent, second maxmimum height of the    parent should be added\\n               \\n               if(heights[v].first+1==heights[u].first)\\n                   extra = heights[u].second;\\n               else\\n                   extra = heights[u].first;\\n               // Update the height of the child node accordingly\\n               if(1+extra>heights[v].first)\\n               {\\n                   heights[v].second = heights[v].first;\\n                   heights[v].first = 1 + extra;\\n               }\\n               else if(1+extra>heights[v].second)\\n               {\\n                   heights[v].second = 1 + extra;\\n               }\\n               \\n               reroot(graph,v,u);\\n           }\\n       }\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        heights.resize(n);\\n        for(vector<int>&edge:edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        findHeight(graph,0,-1);\\n\\n        reroot(graph,0,-1);\\n\\n        vector<int> ans;\\n        for(int i = 0;i<n;i++)\\n            if(heights[i].first==minh)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minh = INT_MAX; // minimum height\\n    vector<pair<int,int>> heights;\\n    // First we\\'ll store heights with tree rooted at node 0\\n    int findHeight(vector<vector<int>>&graph,int u,int p)\\n    {\\n        int m1=0,m2=0,tmp;\\n        // m1 is max height, m2 is second max heigh\\n        for(int &v:graph[u])\\n        {\\n            if(v!=p)\\n            {\\n                tmp = 1 + findHeight(graph,v,u);\\n                if(tmp>m1)\\n                {\\n                    m2 = m1;\\n                    m1 =tmp;\\n                }\\n                else if(tmp>m2)\\n                {\\n                    m2 = tmp;\\n                }\\n            }\\n        }\\n        heights[u] = {m1,m2};\\n        return max(m1,m2);\\n    }\\n    void reroot(vector<vector<int>>&graph,int u,int p)\\n    {\\n       minh = min(minh,heights[u].first);\\n       int extra; //  extra height which the parent give to its child node\\n        \\n       for(int &v:graph[u])\\n       {\\n           if(v!=p)\\n           {\\n               // If child is in the path of maximum height of the parent, second maxmimum height of the    parent should be added\\n               \\n               if(heights[v].first+1==heights[u].first)\\n                   extra = heights[u].second;\\n               else\\n                   extra = heights[u].first;\\n               // Update the height of the child node accordingly\\n               if(1+extra>heights[v].first)\\n               {\\n                   heights[v].second = heights[v].first;\\n                   heights[v].first = 1 + extra;\\n               }\\n               else if(1+extra>heights[v].second)\\n               {\\n                   heights[v].second = 1 + extra;\\n               }\\n               \\n               reroot(graph,v,u);\\n           }\\n       }\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        heights.resize(n);\\n        for(vector<int>&edge:edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        findHeight(graph,0,-1);\\n\\n        reroot(graph,0,-1);\\n\\n        vector<int> ans;\\n        for(int i = 0;i<n;i++)\\n            if(heights[i].first==minh)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775498,
                "title": "easy-c-solution-topological-sort-bfs-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)    //if there\\'s only 1 node ->return {0}\\n            return {0};\\n        \\n        vector <vector<int>> adj(n);        //to store neighbors of each node\\n        vector <int> in(n, 0);              //to store degrees of each node\\n        for(auto edge : edges){             //updating values in adj and in as we iterate through each edges\\n            int u = edge[0], v = edge[1];  \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            in[u]++;\\n            in[v]++;\\n        }\\n        \\n        queue <int> q;                      //to store the nodes which needs to be excluded in order to reach the middle nodes\\n        for(int i=0; i<n; i++)\\n            if(in[i]==1)\\n                q.push(i);\\n        \\n        vector <int> res;                   //to store the final result\\n        while(!q.empty())\\n        {\\n            res.clear();            //clearing before we start traversing level by level.\\n            int size=q.size();\\n            while(size--)           //doing for each inserted nodes\\n            {\\n                int cur=q.front();\\n                q.pop();\\n                res.push_back(cur); //adding nodes to vector (it may or may not be the final solution)\\n                for(auto &neigh :adj[cur])\\n                {\\n                    in[neigh]--;            //removing current leave nodes\\n                    if(in[neigh]==1)        //adding current leave nodes\\n                        q.push(neigh);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)    //if there\\'s only 1 node ->return {0}\\n            return {0};\\n        \\n        vector <vector<int>> adj(n);        //to store neighbors of each node\\n        vector <int> in(n, 0);              //to store degrees of each node\\n        for(auto edge : edges){             //updating values in adj and in as we iterate through each edges\\n            int u = edge[0], v = edge[1];  \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            in[u]++;\\n            in[v]++;\\n        }\\n        \\n        queue <int> q;                      //to store the nodes which needs to be excluded in order to reach the middle nodes\\n        for(int i=0; i<n; i++)\\n            if(in[i]==1)\\n                q.push(i);\\n        \\n        vector <int> res;                   //to store the final result\\n        while(!q.empty())\\n        {\\n            res.clear();            //clearing before we start traversing level by level.\\n            int size=q.size();\\n            while(size--)           //doing for each inserted nodes\\n            {\\n                int cur=q.front();\\n                q.pop();\\n                res.push_back(cur); //adding nodes to vector (it may or may not be the final solution)\\n                for(auto &neigh :adj[cur])\\n                {\\n                    in[neigh]--;            //removing current leave nodes\\n                    if(in[neigh]==1)        //adding current leave nodes\\n                        q.push(neigh);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753794,
                "title": "python-easy-to-read-and-understand-reverse-topological-sort",
                "content": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        graph = {i:[] for i in range(n)}\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        leaves = []\\n        for node in graph:\\n            if len(graph[node]) == 1:\\n                leaves.append(node)\\n        \\n        while len(graph) > 2:\\n            new_leaves = []\\n            for leaf in leaves:\\n                nei = graph[leaf].pop()\\n                del graph[leaf]\\n                graph[nei].remove(leaf)\\n                if len(graph[nei]) == 1:\\n                    new_leaves.append(nei)\\n            leaves = new_leaves\\n        \\n        return leaves",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        graph = {i:[] for i in range(n)}",
                "codeTag": "Java"
            },
            {
                "id": 924148,
                "title": "c-bfs-topological-sort-like-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/minimum-height-trees/submissions/\\n    \\n    TC: O(V + E)\\n    SC: O(V)\\n*/\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        // Since we need to find the MHT roots, we can think of it as finding\\n        // the nodes which are sort of in the middle of the graph and not near\\n        // the corners. If a node is near a corner and picked as a root\\n        // then for it the height will include all the nodes which come on the way from\\n        // another extreme point. Like if a leaf node is picked then height is taken all the \\n        // way from root in a normal binary tree, but if we pick a node in level 2 in a 3 level tree\\n        // then the chances of it having least height decreases, so we need to find the \\n        // nodes which lie in a mid point distance of max distance.\\n        //            1\\n        //         2     3\\n        //        4  5  6 7,     if 4,5,6 or 7 is picked h = 5, 2 and 3 gives h=4, whereas 1 gives h=3 \\n        \\n        // find the indegree of each node and use BFS to get to the nodes connected in a central position\\n        // So naturally it all starts with leaf nodes, remove them in each iteration to get to the central ones\\n        if(n <= 1)\\n            return n == 0 ? vector<int>{} : vector<int>{0};\\n        \\n        vector<int> indegree(n, 0);\\n        int min_degree = INT_MAX;\\n        \\n        // create a graph\\n        vector<vector<int>> g(n);\\n        for(auto &edge: edges) {\\n            g[edge[0]].emplace_back(edge[1]);\\n            g[edge[1]].emplace_back(edge[0]);\\n            ++indegree[edge[0]], ++indegree[edge[1]];\\n        }\\n        \\n        vector<int> result;\\n        queue<int> q;\\n        unordered_set<int> visited;\\n        \\n        // add leaf nodes(indegree 1)\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 1) {\\n                q.emplace(i);\\n                visited.emplace(i);\\n            }\\n        }\\n        \\n        int n_nodes = q.size();\\n        \\n        // we return the nodes in the last level\\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n            --n_nodes;\\n            // add node of current level\\n            result.emplace_back(curr);\\n            \\n            // remove the connection count for each neighbor\\n            for(auto v: g[curr]) {\\n                if(!visited.count(v)) {\\n                    --indegree[v];\\n                    // it has become a leaf node, add and mark visited\\n                    if(indegree[v] == 1) {\\n                        q.emplace(v);\\n                        visited.emplace(v);\\n                    }\\n                }\\n            }\\n            \\n            // end of level\\n            if(n_nodes == 0) {\\n                // not the last level\\n                if(!q.empty())\\n                    result.clear();\\n                n_nodes = q.size();\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/minimum-height-trees/submissions/\\n    \\n    TC: O(V + E)\\n    SC: O(V)\\n*/\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        // Since we need to find the MHT roots, we can think of it as finding\\n        // the nodes which are sort of in the middle of the graph and not near\\n        // the corners. If a node is near a corner and picked as a root\\n        // then for it the height will include all the nodes which come on the way from\\n        // another extreme point. Like if a leaf node is picked then height is taken all the \\n        // way from root in a normal binary tree, but if we pick a node in level 2 in a 3 level tree\\n        // then the chances of it having least height decreases, so we need to find the \\n        // nodes which lie in a mid point distance of max distance.\\n        //            1\\n        //         2     3\\n        //        4  5  6 7,     if 4,5,6 or 7 is picked h = 5, 2 and 3 gives h=4, whereas 1 gives h=3 \\n        \\n        // find the indegree of each node and use BFS to get to the nodes connected in a central position\\n        // So naturally it all starts with leaf nodes, remove them in each iteration to get to the central ones\\n        if(n <= 1)\\n            return n == 0 ? vector<int>{} : vector<int>{0};\\n        \\n        vector<int> indegree(n, 0);\\n        int min_degree = INT_MAX;\\n        \\n        // create a graph\\n        vector<vector<int>> g(n);\\n        for(auto &edge: edges) {\\n            g[edge[0]].emplace_back(edge[1]);\\n            g[edge[1]].emplace_back(edge[0]);\\n            ++indegree[edge[0]], ++indegree[edge[1]];\\n        }\\n        \\n        vector<int> result;\\n        queue<int> q;\\n        unordered_set<int> visited;\\n        \\n        // add leaf nodes(indegree 1)\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 1) {\\n                q.emplace(i);\\n                visited.emplace(i);\\n            }\\n        }\\n        \\n        int n_nodes = q.size();\\n        \\n        // we return the nodes in the last level\\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n            --n_nodes;\\n            // add node of current level\\n            result.emplace_back(curr);\\n            \\n            // remove the connection count for each neighbor\\n            for(auto v: g[curr]) {\\n                if(!visited.count(v)) {\\n                    --indegree[v];\\n                    // it has become a leaf node, add and mark visited\\n                    if(indegree[v] == 1) {\\n                        q.emplace(v);\\n                        visited.emplace(v);\\n                    }\\n                }\\n            }\\n            \\n            // end of level\\n            if(n_nodes == 0) {\\n                // not the last level\\n                if(!q.empty())\\n                    result.clear();\\n                n_nodes = q.size();\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923313,
                "title": "minimum-height-trees-solution-java-timecomplexity-o-mn-depending-on-cases",
                "content": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if(n<2){\\n            ArrayList<Integer> centroid = new ArrayList<>();\\n            for(int i=0; i<n; i++)\\n                centroid.add(i);\\n            return centroid;\\n        }\\n        ArrayList<Set<Integer>> adjacents  = new ArrayList<>();\\n        for(int i=0; i<n; i++)\\n            adjacents.add(new HashSet<Integer>());\\n        for(int[] edge : edges){\\n            Integer start = edge[0], end = edge[1];\\n            adjacents.get(start).add(end);\\n            adjacents.get(end).add(start);\\n        }\\n        ArrayList<Integer> leaves = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            if(adjacents.get(i).size() == 1)\\n                leaves.add(i);\\n        }\\n        int remainingNodes = n;\\n        while(remainingNodes >2){\\n            remainingNodes -= leaves.size();\\n            ArrayList<Integer> newLeaves = new ArrayList<>();\\n            for(Integer leaf : leaves){\\n                for(Integer adjacent : adjacents.get(leaf)){\\n                    adjacents.get(adjacent).remove(leaf);\\n                    if(adjacents.get(adjacent).size() == 1)\\n                        newLeaves.add(adjacent);\\n                }\\n            }\\n            leaves = newLeaves;\\n        }\\n        return leaves;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if(n<2){\\n            ArrayList<Integer> centroid = new ArrayList<>();\\n            for(int i=0; i<n; i++)\\n                centroid.add(i);\\n            return centroid;\\n        }\\n        ArrayList<Set<Integer>> adjacents  = new ArrayList<>();\\n        for(int i=0; i<n; i++)\\n            adjacents.add(new HashSet<Integer>());\\n        for(int[] edge : edges){\\n            Integer start = edge[0], end = edge[1];\\n            adjacents.get(start).add(end);\\n            adjacents.get(end).add(start);\\n        }\\n        ArrayList<Integer> leaves = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            if(adjacents.get(i).size() == 1)\\n                leaves.add(i);\\n        }\\n        int remainingNodes = n;\\n        while(remainingNodes >2){\\n            remainingNodes -= leaves.size();\\n            ArrayList<Integer> newLeaves = new ArrayList<>();\\n            for(Integer leaf : leaves){\\n                for(Integer adjacent : adjacents.get(leaf)){\\n                    adjacents.get(adjacent).remove(leaf);\\n                    if(adjacents.get(adjacent).size() == 1)\\n                        newLeaves.add(adjacent);\\n                }\\n            }\\n            leaves = newLeaves;\\n        }\\n        return leaves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768210,
                "title": "topological-sorting-similar-to-course-schedule-using-bfs",
                "content": "### Steps:\\n* build graph using HashMap and build inDegrees array\\n* use BFS, start visiting from all vertices with inDegree = 1\\n* the last existing vertices with inDegree == 1 are the result\\n\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> result = new ArrayList();\\n        int[] inDegree = new int[n];\\n        \\n        if (n == 1) {\\n            result.add(0);\\n            return result;\\n        }\\n        \\n        //build graph map, and count number of indegrees for each vertex:\\n        Map<Integer, List<Integer>> map = new HashMap();\\n        for (int[] pair: edges) {\\n            if (!map.containsKey(pair[0])) \\n                map.put(pair[0], new ArrayList());\\n\\n            if (!map.containsKey(pair[1])) \\n                map.put(pair[1], new ArrayList());\\n\\n            map.get(pair[0]).add(pair[1]);\\n            map.get(pair[1]).add(pair[0]);\\n\\n            inDegree[pair[0]]++;\\n            inDegree[pair[1]]++;\\n        }\\n\\n        //add all singly connected vertices\\n        Queue<Integer> queue = new LinkedList();\\n        for (int i = 0; i < n; i++) {\\n            if (inDegree[i] == 1)\\n                queue.offer(i);\\n        }\\n        \\n        //BFS\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> currList = new ArrayList();\\n            for (int i = 0; i < size; i++) {\\n                int curr = queue.poll();\\n                currList.add(curr);\\n                \\n                //add neighbor vertices onto queue\\n                for (int neighbor : map.get(curr)) \\n                    if (--inDegree[neighbor] == 1)\\n                        queue.offer(neighbor);                \\n            }\\n            result = currList;            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> result = new ArrayList();\\n        int[] inDegree = new int[n];\\n        \\n        if (n == 1) {\\n            result.add(0);\\n            return result;\\n        }\\n        \\n        //build graph map, and count number of indegrees for each vertex:\\n        Map<Integer, List<Integer>> map = new HashMap();\\n        for (int[] pair: edges) {\\n            if (!map.containsKey(pair[0])) \\n                map.put(pair[0], new ArrayList());\\n\\n            if (!map.containsKey(pair[1])) \\n                map.put(pair[1], new ArrayList());\\n\\n            map.get(pair[0]).add(pair[1]);\\n            map.get(pair[1]).add(pair[0]);\\n\\n            inDegree[pair[0]]++;\\n            inDegree[pair[1]]++;\\n        }\\n\\n        //add all singly connected vertices\\n        Queue<Integer> queue = new LinkedList();\\n        for (int i = 0; i < n; i++) {\\n            if (inDegree[i] == 1)\\n                queue.offer(i);\\n        }\\n        \\n        //BFS\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> currList = new ArrayList();\\n            for (int i = 0; i < size; i++) {\\n                int curr = queue.poll();\\n                currList.add(curr);\\n                \\n                //add neighbor vertices onto queue\\n                for (int neighbor : map.get(curr)) \\n                    if (--inDegree[neighbor] == 1)\\n                        queue.offer(neighbor);                \\n            }\\n            result = currList;            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130545,
                "title": "python-min-ht-trees-by-trimming-leaves",
                "content": "```\\nclass Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 1: return [0]\\n\\n        \\n        graph = [set() for _ in xrange(n)]\\n        for i,j in edges:\\n            graph[i].add(j)\\n            graph[j].add(i)\\n            \\n        # the intuition is that in a connected graph,\\n        # if you pick a node of degree 1 as the root\\n        # then the resulting tree has the max ht.\\n        # so trim the leaves until there are at most 2\\n        # and at least 1 node left.\\n        \\n        leaves = [i for i in xrange(n) if len(graph[i]) == 1]\\n        while n > 2:\\n            n -= len(leaves)\\n            new_leaves = []\\n            for leaf in leaves:\\n                neighbor = graph[leaf].pop()\\n                graph[neighbor].remove(leaf)\\n                if len(graph[neighbor]) == 1: new_leaves.append(neighbor)\\n            \\n            leaves = new_leaves\\n        \\n        return leaves\\n                    \\n                    \\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 1: return [0]\\n\\n        \\n        graph = [set() for _ in xrange(n)]\\n        for i,j in edges:\\n            graph[i].add(j)\\n            graph[j].add(i)\\n            \\n        # the intuition is that in a connected graph,\\n        # if you pick a node of degree 1 as the root\\n        # then the resulting tree has the max ht.\\n        # so trim the leaves until there are at most 2\\n        # and at least 1 node left.\\n        \\n        leaves = [i for i in xrange(n) if len(graph[i]) == 1]\\n        while n > 2:\\n            n -= len(leaves)\\n            new_leaves = []\\n            for leaf in leaves:\\n                neighbor = graph[leaf].pop()\\n                graph[neighbor].remove(leaf)\\n                if len(graph[neighbor]) == 1: new_leaves.append(neighbor)\\n            \\n            leaves = new_leaves\\n        \\n        return leaves\\n                    \\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 76077,
                "title": "c-bfs-solution-by-finding-the-longest-path-in-the-tree",
                "content": "Basic idea: the roots of MHT must be the mid points of the longest leaf to leaf path in the tree. And to find the longest path, we can first find the farthest leaf from any node, and then find the farthest leaf from the node found above. Then these two nodes we found are the end points of the longest path. And last, we find the centers of the longest path.\\n\\nEDIT: according to @hellotest solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        //find the longest path in the tree\\n        vector<vector<int>> lists(n);\\n        for(auto p : edges) {\\n            lists[p.first].push_back(p.second);\\n            lists[p.second].push_back(p.first);\\n        }\\n        \\n        int len;\\n        vector<int> prev(n, 0);\\n        int f1 = findFarthestLeaf(lists, 0, len, prev);\\n        int f2 = findFarthestLeaf(lists, f1, len, prev);\\n\\n        //find the mid\\n        for(int i = 0; i < (len - 1) / 2; ++i) {\\n            f2 = prev[f2];\\n        }\\n        if(len % 2) return vector<int>{f2};\\n        else return vector<int>{f2, prev[f2]};\\n    }\\n    \\n    int findFarthestLeaf(vector<vector<int>>& lists, int id, int& len, vector<int>& prev) {\\n        int n = lists.size();\\n        \\n        vector<bool> visited(n, 0);\\n        visited[id] = true;\\n        prev[id] = id;\\n        \\n        queue<int> q;\\n        q.push(id);\\n              \\n        len = 0;\\n        int leaf;\\n        while( !q.empty() ) {\\n            len++;\\n            int size = q.size();\\n            while(size-- > 0) {\\n                int f = q.front();\\n                q.pop();\\n                leaf = f;\\n                for (int i : lists[f]) {\\n                    if (!visited[i]) {\\n                        visited[i] = true;\\n                        q.push(i);\\n                        prev[i] = f;\\n                    }\\n                }\\n            }\\n        }\\n    \\n        return leaf;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        //find the longest path in the tree\\n        vector<vector<int>> lists(n);\\n        for(auto p : edges) {\\n            lists[p.first].push_back(p.second);\\n            lists[p.second].push_back(p.first);\\n        }\\n        \\n        int len;\\n        vector<int> prev(n, 0);\\n        int f1 = findFarthestLeaf(lists, 0, len, prev);\\n        int f2 = findFarthestLeaf(lists, f1, len, prev);\\n\\n        //find the mid\\n        for(int i = 0; i < (len - 1) / 2; ++i) {\\n            f2 = prev[f2];\\n        }\\n        if(len % 2) return vector<int>{f2};\\n        else return vector<int>{f2, prev[f2]};\\n    }\\n    \\n    int findFarthestLeaf(vector<vector<int>>& lists, int id, int& len, vector<int>& prev) {\\n        int n = lists.size();\\n        \\n        vector<bool> visited(n, 0);\\n        visited[id] = true;\\n        prev[id] = id;\\n        \\n        queue<int> q;\\n        q.push(id);\\n              \\n        len = 0;\\n        int leaf;\\n        while( !q.empty() ) {\\n            len++;\\n            int size = q.size();\\n            while(size-- > 0) {\\n                int f = q.front();\\n                q.pop();\\n                leaf = f;\\n                for (int i : lists[f]) {\\n                    if (!visited[i]) {\\n                        visited[i] = true;\\n                        q.push(i);\\n                        prev[i] = f;\\n                    }\\n                }\\n            }\\n        }\\n    \\n        return leaf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76100,
                "title": "c-bfs-84ms-beats-90-vector-and-queue-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        vector<int> roots;\\n        if(n==1) \\n        {\\n            roots.push_back(0);\\n            return roots;\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> inDegree(n); //  indegree of a node is the number of edges leading to that node \\n        for(auto& e:edges)\\n        {\\n            graph[e.first].push_back(e.second);\\n            graph[e.second].push_back(e.first);\\n            inDegree[e.first]++;\\n            inDegree[e.second]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(inDegree[i]==1) // leaf node\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int node = q.front();q.pop();\\n                inDegree[node]--; // remove leaf\\n                \\n                if(n<=2) roots.push_back(node);\\n                \\n                for(int& neighbor:graph[node])\\n                {\\n                    inDegree[neighbor]--; // remove leaf\\n                    if(inDegree[neighbor]==1) \\n                    {\\n                        q.push(neighbor);\\n                    }\\n                }\\n            }\\n            n-=size; // remove leaves layer by layer\\n        }\\n        return roots;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        vector<int> roots;\\n        if(n==1) \\n        {\\n            roots.push_back(0);\\n            return roots;\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> inDegree(n); //  indegree of a node is the number of edges leading to that node \\n        for(auto& e:edges)\\n        {\\n            graph[e.first].push_back(e.second);\\n            graph[e.second].push_back(e.first);\\n            inDegree[e.first]++;\\n            inDegree[e.second]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(inDegree[i]==1) // leaf node\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int node = q.front();q.pop();\\n                inDegree[node]--; // remove leaf\\n                \\n                if(n<=2) roots.push_back(node);\\n                \\n                for(int& neighbor:graph[node])\\n                {\\n                    inDegree[neighbor]--; // remove leaf\\n                    if(inDegree[neighbor]==1) \\n                    {\\n                        q.push(neighbor);\\n                    }\\n                }\\n            }\\n            n-=size; // remove leaves layer by layer\\n        }\\n        return roots;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76108,
                "title": "cpp-easy-to-understand-solution-using-graph",
                "content": "    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        //The principle is that in a path graph, the node at the middle is the root wiht MHTs. Use two pointers to achieve\\n        //Like course schedule problem. First, construct the graph baesd on edges. Then construct the degree vector. Delete all the leaf nodes which the degree is 1. Then construct the next leaf node.Until only two odes are remaining and these two nodes are the two located on the longest path in the graph, which should be the result.\\n        vector<int>result;\\n        if (n == 1) {\\n            result.push_back(0);\\n            return result;\\n        }\\n        //Construct the graph\\n        vector<vector<int>>graph(n, vector<int>());\\n        vector<int>degree(n, 0);\\n        for (int i = 0; i < edges.size(); i++) {\\n            graph[edges[i].first].push_back(edges[i].second);\\n            graph[edges[i].second].push_back(edges[i].first);\\n            degree[edges[i].first]++;\\n            degree[edges[i].second]++;\\n        }\\n        int count = n;\\n        while (count > 2) {\\n            vector<int>records;\\n            for (int i = 0; i < n; i++) {\\n                if (degree[i] == 1) {\\n                    records.push_back(i);\\n                    degree[i] = -1;\\n                    count--;\\n                }\\n            }\\n            for (int i = 0; i < records.size(); i++) {\\n                for (auto it : graph[records[i]]) {\\n                    degree[it]--;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (degree[i] == 1 || degree[i] == 0) {\\n                result.push_back(i);\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        //The principle is that in a path graph, the node at the middle is the root wiht MHTs. Use two pointers to achieve\\n        //Like course schedule problem. First, construct the graph baesd on edges. Then construct the degree vector. Delete all the leaf nodes which the degree is 1. Then construct the next leaf node.Until only two odes are remaining and these two nodes are the two located on the longest path in the graph, which should be the result.\\n        vector<int>result;\\n        if (n == 1) {\\n            result.push_back(0);\\n            return result;\\n        }\\n        //Construct the graph\\n        vector<vector<int>>graph(n, vector<int>());\\n        vector<int>degree(n, 0);\\n        for (int i = 0; i < edges.size(); i++) {\\n            graph[edges[i].first].push_back(edges[i].second);\\n            graph[edges[i].second].push_back(edges[i].first);\\n            degree[edges[i].first]++;\\n            degree[edges[i].second]++;\\n        }\\n        int count = n;\\n        while (count > 2) {\\n            vector<int>records;\\n            for (int i = 0; i < n; i++) {\\n                if (degree[i] == 1) {\\n                    records.push_back(i);\\n                    degree[i] = -1;\\n                    count--;\\n                }\\n            }\\n            for (int i = 0; i < records.size(); i++) {\\n                for (auto it : graph[records[i]]) {\\n                    degree[it]--;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (degree[i] == 1 || degree[i] == 0) {\\n                result.push_back(i);\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3828848,
                "title": "c-with-explanatory-comments",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n == 1) {\\n            return {0}; // Special case: only one node, it\\'s the root of the minimum height tree.\\n        }\\n\\n        vector<vector<int>> graph(n);  // Adjacency list\\n        vector<int> indegree(n, 0);    // Indegree of nodes\\n        vector<int> ans;               // Answer array\\n\\n        // Build the adjacency list and compute the indegree for each node\\n        for (const auto& e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (indegree[i] == 1) {\\n                q.push(i); // Initialize the queue with leaf nodes (indegree 1)\\n            }\\n        }\\n\\n        while (!q.empty()) {\\n            int s = q.size();\\n            ans.clear(); // We only want to store the last level of nodes\\n\\n            for (int i = 0; i < s; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                ans.push_back(node);\\n\\n                // Reduce the indegree of the neighbors and add them to the queue if their indegree becomes 1\\n                for (int neighbor : graph[node]) {\\n                    if (--indegree[neighbor] == 1) {\\n                        q.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(E+N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(E+N)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n == 1) {\\n            return {0}; // Special case: only one node, it\\'s the root of the minimum height tree.\\n        }\\n\\n        vector<vector<int>> graph(n);  // Adjacency list\\n        vector<int> indegree(n, 0);    // Indegree of nodes\\n        vector<int> ans;               // Answer array\\n\\n        // Build the adjacency list and compute the indegree for each node\\n        for (const auto& e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (indegree[i] == 1) {\\n                q.push(i); // Initialize the queue with leaf nodes (indegree 1)\\n            }\\n        }\\n\\n        while (!q.empty()) {\\n            int s = q.size();\\n            ans.clear(); // We only want to store the last level of nodes\\n\\n            for (int i = 0; i < s; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                ans.push_back(node);\\n\\n                // Reduce the indegree of the neighbors and add them to the queue if their indegree becomes 1\\n                for (int neighbor : graph[node]) {\\n                    if (--indegree[neighbor] == 1) {\\n                        q.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401788,
                "title": "java-runtime-12-ms-faster-than-99-90",
                "content": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if(edges.length == 0 || n == 1){\\n            List<Integer> res = Arrays.asList(0);\\n            return res;\\n        }\\n        ArrayList<Integer>[] adj = new ArrayList[n];\\n        int[] indegree = new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        \\n        for(int[] e: edges){\\n            int v = e[0];\\n            int u = e[1];\\n            \\n            adj[v].add(u);\\n            adj[u].add(v);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\\n        \\n        for(int i=0; i<n; ++i){\\n            if(indegree[i] == 1){\\n                queue.add(i);\\n            }\\n        }\\n        \\n        while(n > 2){\\n            int size = queue.size();\\n            n -= size;\\n            \\n            while(size-- > 0){\\n                //remove\\n                int rem = queue.remove();\\n                \\n                //mark*\\n                //work\\n                for(int i: adj[rem]){\\n                    indegree[i]--;\\n                    if(indegree[i] == 1){\\n                        queue.add(i);\\n                    }\\n                }\\n                //add*\\n            }\\n        }\\n        \\n        ArrayList<Integer> res = new ArrayList<>();\\n        while(queue.size()>0){\\n            res.add(queue.pop());\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if(edges.length == 0 || n == 1){\\n            List<Integer> res = Arrays.asList(0);\\n            return res;\\n        }\\n        ArrayList<Integer>[] adj = new ArrayList[n];\\n        int[] indegree = new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        \\n        for(int[] e: edges){\\n            int v = e[0];\\n            int u = e[1];\\n            \\n            adj[v].add(u);\\n            adj[u].add(v);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\\n        \\n        for(int i=0; i<n; ++i){\\n            if(indegree[i] == 1){\\n                queue.add(i);\\n            }\\n        }\\n        \\n        while(n > 2){\\n            int size = queue.size();\\n            n -= size;\\n            \\n            while(size-- > 0){\\n                //remove\\n                int rem = queue.remove();\\n                \\n                //mark*\\n                //work\\n                for(int i: adj[rem]){\\n                    indegree[i]--;\\n                    if(indegree[i] == 1){\\n                        queue.add(i);\\n                    }\\n                }\\n                //add*\\n            }\\n        }\\n        \\n        ArrayList<Integer> res = new ArrayList<>();\\n        while(queue.size()>0){\\n            res.add(queue.pop());\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291948,
                "title": "cpp-indegree-bfs-kahn-s-algo",
                "content": "\\nRemove leaves, since the path from a leaf to a root will be the longest. We need to focus on middle nodes i.e those nodes that have higher indegree (similar to Kahn\\'s ago). It is possible to have two nodes whose height is minimum in the answer, since in the case of three, the middle node would have the minimum height.\\n\\n```cpp\\nclass Solution {\\npublic:    \\n    #define PB push_back\\n    #define P push\\n    #define F front\\n\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)\\n    {\\n        if(n == 1) return { 0 };\\n        \\n        vector<int>* adj = new vector<int>[n];\\n        vector<int> ans;\\n\\t\\t\\n        // making a graph\\n        for(auto it: edges)\\n        {\\n            adj[it[0]].PB(it[1]);\\n            adj[it[1]].PB(it[0]);   \\n        }\\n        \\n        queue<int> leaves; \\n        int indegree[n];\\n        \\n        memset(indegree, 0, sizeof indegree);\\n        \\n        for(int idx = 0; idx < n; idx++)\\n        {\\n            indegree[idx] = adj[idx].size();\\n            \\n\\t\\t\\t// pushing leaves inside a queue\\n            if(indegree[idx] == 1) leaves.P(idx);\\n        }\\n        \\n        int finalNodes = n;\\n        \\n        while(finalNodes > 2) // as ans can\\'t be greater than two explained above\\n        {\\n            int noOfLeaves = leaves.size();\\n            \\n            finalNodes -= noOfLeaves;\\n            \\n            for(int idx = 0; idx < noOfLeaves; idx++)\\n            {\\n                int leaf = leaves.F();\\n                \\n                leaves.pop();\\n                \\n                for(auto it: adj[leaf])\\n                {\\n                    indegree[it]--;\\n                    \\n\\t\\t\\t\\t\\t// repeat the process\\n                    if(indegree[it] == 1) leaves.P(it);\\n                }\\n            }\\n        }\\n        \\n        while(!leaves.empty())\\n        {\\n            ans.PB(leaves.F());\\n            leaves.pop();\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:    \\n    #define PB push_back\\n    #define P push\\n    #define F front\\n\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)\\n    {\\n        if(n == 1) return { 0 };\\n        \\n        vector<int>* adj = new vector<int>[n];\\n        vector<int> ans;\\n\\t\\t\\n        // making a graph\\n        for(auto it: edges)\\n        {\\n            adj[it[0]].PB(it[1]);\\n            adj[it[1]].PB(it[0]);   \\n        }\\n        \\n        queue<int> leaves; \\n        int indegree[n];\\n        \\n        memset(indegree, 0, sizeof indegree);\\n        \\n        for(int idx = 0; idx < n; idx++)\\n        {\\n            indegree[idx] = adj[idx].size();\\n            \\n\\t\\t\\t// pushing leaves inside a queue\\n            if(indegree[idx] == 1) leaves.P(idx);\\n        }\\n        \\n        int finalNodes = n;\\n        \\n        while(finalNodes > 2) // as ans can\\'t be greater than two explained above\\n        {\\n            int noOfLeaves = leaves.size();\\n            \\n            finalNodes -= noOfLeaves;\\n            \\n            for(int idx = 0; idx < noOfLeaves; idx++)\\n            {\\n                int leaf = leaves.F();\\n                \\n                leaves.pop();\\n                \\n                for(auto it: adj[leaf])\\n                {\\n                    indegree[it]--;\\n                    \\n\\t\\t\\t\\t\\t// repeat the process\\n                    if(indegree[it] == 1) leaves.P(it);\\n                }\\n            }\\n        }\\n        \\n        while(!leaves.empty())\\n        {\\n            ans.PB(leaves.F());\\n            leaves.pop();\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668301,
                "title": "kahn-s-algorithm-topology-sort-bfs-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> result = new ArrayList();\\n        if (n < 2) {\\n            for (int i = 0; i < n; i++)\\n                result.add(i);\\n            \\n            return result;\\n        }\\n        \\n        int[] degree = new int[n];\\n        Map<Integer, List<Integer>> graph = new HashMap();\\n        for (int i = 0; i < n; i++)\\n            graph.put(i, new ArrayList());\\n        \\n        for (int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            degree[edge[0]]++;\\n            graph.get(edge[1]).add(edge[0]);\\n            degree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer> queue = new ArrayDeque();\\n        for (int i = 0; i < n; i++) {\\n            if (degree[i] == 1)\\n                queue.add(i);\\n        }\\n        \\n        int size = 0;\\n        while (!queue.isEmpty()) {\\n            result = new ArrayList();\\n            size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                result.add(node);\\n                degree[node]--;\\n                \\n                for (int neighbor : graph.get(node)) {                    \\n                    degree[neighbor]--;\\n                    \\n                    if (degree[neighbor] == 1)\\n                        queue.add(neighbor);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> result = new ArrayList();\\n        if (n < 2) {\\n            for (int i = 0; i < n; i++)\\n                result.add(i);\\n            \\n            return result;\\n        }\\n        \\n        int[] degree = new int[n];\\n        Map<Integer, List<Integer>> graph = new HashMap();\\n        for (int i = 0; i < n; i++)\\n            graph.put(i, new ArrayList());\\n        \\n        for (int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            degree[edge[0]]++;\\n            graph.get(edge[1]).add(edge[0]);\\n            degree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer> queue = new ArrayDeque();\\n        for (int i = 0; i < n; i++) {\\n            if (degree[i] == 1)\\n                queue.add(i);\\n        }\\n        \\n        int size = 0;\\n        while (!queue.isEmpty()) {\\n            result = new ArrayList();\\n            size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                result.add(node);\\n                degree[node]--;\\n                \\n                for (int neighbor : graph.get(node)) {                    \\n                    degree[neighbor]--;\\n                    \\n                    if (degree[neighbor] == 1)\\n                        queue.add(neighbor);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630837,
                "title": "c-dp-rerooting-using-double-dfs-o-n",
                "content": "Steps:\\n* at first calculate sub tree height for each node `i` where root is `0` . so `dp[u] = max(dp[v]+1)` where there is an edge between `u-v`\\n* we also calculate `dp2[u] = second_max(dp[v]+1)` where there is an edge between `u-v`.\\n* suppose our root is `u`, if we move our root to some adj. `v` we will adjust our `dp[u]`, `dp[v]`\\n* **in this way you can calculate maximum height of the tree if root equals `i[0<=i<n]`**\\n\\n```cpp\\nconst int mx = 2e4 + 5;\\nclass Solution {\\n\\tvector<int> g[mx];\\n\\tint dp[mx], dp2[mx], mi = 1000000;\\n\\tvector<int> ans;\\n\\tvoid dfs(int u = 0, int par = -1) {\\n\\t\\tdp[u] = dp2[u] = 1;\\n\\t\\tfor (int v : g[u]) {\\n\\t\\t\\tif (v != par) {\\n\\t\\t\\t\\tdfs(v, u);\\n\\t\\t\\t\\tif (dp[v] + 1 >= dp[u]) {\\n\\t\\t\\t\\t\\tdp2[u] = dp[u];\\n\\t\\t\\t\\t\\tdp[u] = dp[v] + 1;\\n\\t\\t\\t\\t} else if (dp[v] + 1 >= dp2[u]) {\\n\\t\\t\\t\\t\\tdp2[u] = dp[v] + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvoid reroot(int u = 0, int par = -1) {\\n\\t\\tif (dp[u] < mi) {\\n\\t\\t\\tmi = dp[u];\\n\\t\\t\\tans.clear();\\n\\t\\t}\\n\\t\\tif (dp[u] == mi) {\\n\\t\\t\\tans.push_back(u);\\n\\t\\t}\\n\\t\\tfor (int v : g[u]) {\\n\\t\\t\\tif (v != par) {\\n\\t\\t\\t\\tint x = dp[u], y = dp2[u];\\n\\t\\t\\t\\tint a = dp[v], b = dp2[v];\\n\\t\\t\\t\\tif (a + 1 == dp[u]) {\\n\\t\\t\\t\\t\\tdp[u] = dp2[u];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (dp[u] + 1 >= dp[v]) {\\n\\t\\t\\t\\t\\tdp2[v] = dp[v];\\n\\t\\t\\t\\t\\tdp[v] = dp[u] + 1;\\n\\t\\t\\t\\t} else if (dp[u] + 1 >= dp2[v]) {\\n\\t\\t\\t\\t\\tdp2[v] = dp[u] + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treroot(v, u);\\n\\t\\t\\t\\tdp[u] = x, dp2[u] = y;\\n\\t\\t\\t\\tdp[v] = a, dp2[v] = b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n\\t\\tfor (auto &x : edges) {\\n\\t\\t\\tg[x[0]].push_back(x[1]);\\n\\t\\t\\tg[x[1]].push_back(x[0]);\\n\\t\\t}\\n\\t\\tdfs();\\n\\t\\treroot();\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nconst int mx = 2e4 + 5;\\nclass Solution {\\n\\tvector<int> g[mx];\\n\\tint dp[mx], dp2[mx], mi = 1000000;\\n\\tvector<int> ans;\\n\\tvoid dfs(int u = 0, int par = -1) {\\n\\t\\tdp[u] = dp2[u] = 1;\\n\\t\\tfor (int v : g[u]) {\\n\\t\\t\\tif (v != par) {\\n\\t\\t\\t\\tdfs(v, u);\\n\\t\\t\\t\\tif (dp[v] + 1 >= dp[u]) {\\n\\t\\t\\t\\t\\tdp2[u] = dp[u];\\n\\t\\t\\t\\t\\tdp[u] = dp[v] + 1;\\n\\t\\t\\t\\t} else if (dp[v] + 1 >= dp2[u]) {\\n\\t\\t\\t\\t\\tdp2[u] = dp[v] + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvoid reroot(int u = 0, int par = -1) {\\n\\t\\tif (dp[u] < mi) {\\n\\t\\t\\tmi = dp[u];\\n\\t\\t\\tans.clear();\\n\\t\\t}\\n\\t\\tif (dp[u] == mi) {\\n\\t\\t\\tans.push_back(u);\\n\\t\\t}\\n\\t\\tfor (int v : g[u]) {\\n\\t\\t\\tif (v != par) {\\n\\t\\t\\t\\tint x = dp[u], y = dp2[u];\\n\\t\\t\\t\\tint a = dp[v], b = dp2[v];\\n\\t\\t\\t\\tif (a + 1 == dp[u]) {\\n\\t\\t\\t\\t\\tdp[u] = dp2[u];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (dp[u] + 1 >= dp[v]) {\\n\\t\\t\\t\\t\\tdp2[v] = dp[v];\\n\\t\\t\\t\\t\\tdp[v] = dp[u] + 1;\\n\\t\\t\\t\\t} else if (dp[u] + 1 >= dp2[v]) {\\n\\t\\t\\t\\t\\tdp2[v] = dp[u] + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treroot(v, u);\\n\\t\\t\\t\\tdp[u] = x, dp2[u] = y;\\n\\t\\t\\t\\tdp[v] = a, dp2[v] = b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n\\t\\tfor (auto &x : edges) {\\n\\t\\t\\tg[x[0]].push_back(x[1]);\\n\\t\\t\\tg[x[1]].push_back(x[0]);\\n\\t\\t}\\n\\t\\tdfs();\\n\\t\\treroot();\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788331,
                "title": "python-clean-solution-99",
                "content": "Similar to Kahn\\'s algorithm for topological sort. We find the leaves of the node and remove them, then proceed up the tree until the number of connected elements is less than 3.\\n```\\ndef findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\tif n == 1: return [0]\\n\\tedgelist = collections.defaultdict(set)\\n\\tfor u, v in edges:\\n\\t\\tedgelist[u].add(v)\\n\\t\\tedgelist[v].add(u)\\n\\n\\tleaves = [node for node, sibs in edgelist.items() if len(sibs) == 1]\\n\\n\\twhile len(edgelist) > 2:\\n\\t\\tnextleaves = []\\n\\t\\tfor leaf in leaves:\\n\\t\\t\\tparent = edgelist[leaf].pop()\\n\\t\\t\\tdel edgelist[leaf]\\n\\t\\t\\tedgelist[parent].remove(leaf)\\n\\t\\t\\tif len(edgelist[parent]) == 1:\\n\\t\\t\\t\\tnextleaves.append(parent)\\n\\n\\t\\tleaves = nextleaves\\n\\n\\treturn leaves\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\tif n == 1: return [0]\\n\\tedgelist = collections.defaultdict(set)\\n\\tfor u, v in edges:\\n\\t\\tedgelist[u].add(v)\\n\\t\\tedgelist[v].add(u)\\n\\n\\tleaves = [node for node, sibs in edgelist.items() if len(sibs) == 1]\\n\\n\\twhile len(edgelist) > 2:\\n\\t\\tnextleaves = []\\n\\t\\tfor leaf in leaves:\\n\\t\\t\\tparent = edgelist[leaf].pop()\\n\\t\\t\\tdel edgelist[leaf]\\n\\t\\t\\tedgelist[parent].remove(leaf)\\n\\t\\t\\tif len(edgelist[parent]) == 1:\\n\\t\\t\\t\\tnextleaves.append(parent)\\n\\n\\t\\tleaves = nextleaves\\n\\n\\treturn leaves\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 616075,
                "title": "c-solution-bfs-with-detailed-explanation",
                "content": "```\\nI have got the idea how to solve using this post.\\nhttps://leetcode.com/problems/minimum-height-trees/discuss/599934/C%2B%2B-O(n)-time-and-O(n)-Using-BFS-Easy-to-Understand\\nThe main idea of this algorithm is to keep trimmin the graphs until there are 2 nodes in the graph.\\nWhy 2 nodes?\\nThere are a maximum of 2 nodes that can contribute to minimum height tree.\\n\\nA degree of node is basically the number of edges connected to for from the node. This is the case for an undirected graph.\\n\\n     0  1  2\\n      \\\\ | /\\n        3\\n        |\\n        4\\n        |\\n        5 \\nthe degres for the following nodes are\\n\\n0 - 1\\n1 - 1\\n2 - 1\\n3 - 2\\n4 - 2\\n5 - 1\\n\\nWe are going to keep trimming the leafs(nodes with degree=1) until there are 2 nodes\\n\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n],degree(n,0);\\n        for(auto x:edges)\\n        {\\n            graph[x[1]].push_back(x[0]);\\n            graph[x[0]].push_back(x[1]);\\n            degree[x[0]]++;\\n            degree[x[1]]++;                        //Updating the degrees of each nodes\\n        }\\n        int nodecount=n;\\n        while(nodecount>2)\\n        {\\n            queue<int> q;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(degree[i]==1)\\n                {\\n                    q.push(i);\\n                    degree[i]=-1;\\n                nodecount--;                        //We decrement each time we visit a node with degree = 1\\n                }\\n            }\\n            while(!q.empty())\\n            {\\n                int t=q.front();\\n                q.pop();\\n                for(int x:graph[t])\\n                    degree[x]--;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(degree[i]==0||degree[i]==1)ans.push_back(i);     //If we are left with a node with degrees =0 or 1 that with contibute to an MHT\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nI have got the idea how to solve using this post.\\nhttps://leetcode.com/problems/minimum-height-trees/discuss/599934/C%2B%2B-O(n)-time-and-O(n)-Using-BFS-Easy-to-Understand\\nThe main idea of this algorithm is to keep trimmin the graphs until there are 2 nodes in the graph.\\nWhy 2 nodes?\\nThere are a maximum of 2 nodes that can contribute to minimum height tree.\\n\\nA degree of node is basically the number of edges connected to for from the node. This is the case for an undirected graph.\\n\\n     0  1  2\\n      \\\\ | /\\n        3\\n        |\\n        4\\n        |\\n        5 \\nthe degres for the following nodes are\\n\\n0 - 1\\n1 - 1\\n2 - 1\\n3 - 2\\n4 - 2\\n5 - 1\\n\\nWe are going to keep trimming the leafs(nodes with degree=1) until there are 2 nodes\\n\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n],degree(n,0);\\n        for(auto x:edges)\\n        {\\n            graph[x[1]].push_back(x[0]);\\n            graph[x[0]].push_back(x[1]);\\n            degree[x[0]]++;\\n            degree[x[1]]++;                        //Updating the degrees of each nodes\\n        }\\n        int nodecount=n;\\n        while(nodecount>2)\\n        {\\n            queue<int> q;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(degree[i]==1)\\n                {\\n                    q.push(i);\\n                    degree[i]=-1;\\n                nodecount--;                        //We decrement each time we visit a node with degree = 1\\n                }\\n            }\\n            while(!q.empty())\\n            {\\n                int t=q.front();\\n                q.pop();\\n                for(int x:graph[t])\\n                    degree[x]--;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(degree[i]==0||degree[i]==1)ans.push_back(i);     //If we are left with a node with degrees =0 or 1 that with contibute to an MHT\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354538,
                "title": "cpp-bfs-from-leaves",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> res;\\n        if(n == 1){\\n            res = {0};\\n            return res;\\n        }\\n        vector<int> degree(n);\\n        vector<vector<int>> adj(n);\\n        for(auto& edge: edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n            degree[edge[0]] ++;\\n            degree[edge[1]] ++;\\n        }\\n        \\n        queue<int> myq, nextq;\\n        for(int i = 0; i < n; ++ i){\\n            if(degree[i] == 1){\\n                myq.push(i);\\n            }\\n        }\\n        \\n        while(!myq.empty()){\\n            res.clear();\\n            auto size = myq.size();\\n            for(auto i = 0; i < size; ++ i){\\n                int cur = myq.front();\\n                myq.pop();\\n                res.push_back(cur);\\n                for(int j: adj[cur]){\\n                    degree[j] --;\\n                    if(degree[j] == 1)\\n                        myq.push(j);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> res;\\n        if(n == 1){\\n            res = {0};\\n            return res;\\n        }\\n        vector<int> degree(n);\\n        vector<vector<int>> adj(n);\\n        for(auto& edge: edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n            degree[edge[0]] ++;\\n            degree[edge[1]] ++;\\n        }\\n        \\n        queue<int> myq, nextq;\\n        for(int i = 0; i < n; ++ i){\\n            if(degree[i] == 1){\\n                myq.push(i);\\n            }\\n        }\\n        \\n        while(!myq.empty()){\\n            res.clear();\\n            auto size = myq.size();\\n            for(auto i = 0; i < size; ++ i){\\n                int cur = myq.front();\\n                myq.pop();\\n                res.push_back(cur);\\n                for(int j: adj[cur]){\\n                    degree[j] --;\\n                    if(degree[j] == 1)\\n                        myq.push(j);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212888,
                "title": "easy-bfs-traversal",
                "content": "\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<int> degree(n, 0);\\n        //Make an adjacency list and count for degree of each node\\n        for(int i=0; i<edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            \\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n        }\\n        \\n        \\n        //Queue for BFS traversal\\n        queue<int> q;\\n        //Push all the nodes whose degrees are one because these nodes can\\'t form minimum height trees\\n        for(int i=0; i<n; i++) {\\n            if(degree[i] == 1) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        vector<int> res; //Resultant vector\\n        //Do BFS traversal to find out the nodes which are most connecting\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> v; //Temporary vector\\n            while(size--) {\\n                int node = q.front();\\n                q.pop();\\n                v.push_back(node); //Push the node to temporary vector\\n                \\n                //Visit all the adjacent nodes\\n                for(auto it: adj[node]) {\\n                    degree[it]--; //Reduce degree since the node will be disconnected now\\n                    \\n                    if(degree[it] == 1) {\\n                        q.push(it); //Push when degree becomes one\\n                    }\\n                }\\n            }\\n            res = v; //Result vector updated \\n        }\\n        \\n        if(n == 1) res.push_back(0);\\n        return res;\\n    }\\n\\t\\nIf you liked the approach.....please upvote!!",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<int> degree(n, 0);\\n        //Make an adjacency list and count for degree of each node\\n        for(int i=0; i<edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            \\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n        }\\n        \\n        \\n        //Queue for BFS traversal\\n        queue<int> q;\\n        //Push all the nodes whose degrees are one because these nodes can\\'t form minimum height trees\\n        for(int i=0; i<n; i++) {\\n            if(degree[i] == 1) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        vector<int> res; //Resultant vector\\n        //Do BFS traversal to find out the nodes which are most connecting\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> v; //Temporary vector\\n            while(size--) {\\n                int node = q.front();\\n                q.pop();\\n                v.push_back(node); //Push the node to temporary vector\\n                \\n                //Visit all the adjacent nodes\\n                for(auto it: adj[node]) {\\n                    degree[it]--; //Reduce degree since the node will be disconnected now\\n                    \\n                    if(degree[it] == 1) {\\n                        q.push(it); //Push when degree becomes one\\n                    }\\n                }\\n            }\\n            res = v; //Result vector updated \\n        }\\n        \\n        if(n == 1) res.push_back(0);\\n        return res;\\n    }\\n\\t\\nIf you liked the approach.....please upvote!!",
                "codeTag": "Unknown"
            },
            {
                "id": 1631107,
                "title": "minimum-height-trees-100",
                "content": "class Solution {\\n\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) {\\n            return Collections.singletonList(0);\\n        }\\n\\n        int[] numEdges = new int[n];\\n        for (int[] edge : edges) {\\n            numEdges[edge[0]]++;\\n            numEdges[edge[1]]++;\\n        }\\n\\n        int[][] adjacencyList = new int[n][];\\n        for (int i = 0; i < n; i++) {\\n            adjacencyList[i] = new int[numEdges[i]];\\n        }\\n\\n        int[] work = new int[n];\\n        for (int[] edge : edges) {\\n            adjacencyList[edge[0]][work[edge[0]]++] = edge[1];\\n            adjacencyList[edge[1]][work[edge[1]]++] = edge[0];\\n        }\\n\\n        int leafCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (work[i] == 1) {\\n                work[leafCount++] = i;\\n            }\\n        }\\n\\n        int[] work2 = new int[n];\\n        int nextLeafCount;\\n\\n        int numVertices = n;\\n        while (numVertices > 2) {\\n            nextLeafCount = 0;\\n            for (int i = 0; i < leafCount; i++) {\\n                int leaf = work[i];\\n                for (int index : adjacencyList[leaf]) {\\n                    if (--numEdges[index] == 1) {\\n                        work2[nextLeafCount++] = index;\\n                    }\\n                }\\n            }\\n\\n            numVertices -= leafCount;\\n\\n            int[] w = work;\\n            work = work2;\\n            work2 = w;\\n\\n            leafCount = nextLeafCount;\\n        }\\n\\n        return leafCount == 2 ? Arrays.asList(work[0], work[1]) : Collections.singletonList(work[0]);\\n    }\\n}\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\n\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) {\\n            return Collections.singletonList(0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1260490,
                "title": "c-solution-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)return {0};\\n        vector<vector<int> > adj(n, vector<int>());\\n        \\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> leaves;\\n        for(int i = 0;i<n;i++){\\n            if(adj[i].size() == 1){\\n                leaves.push_back(i);\\n            }\\n        }\\n        \\n        while(n>2){\\n            n-=leaves.size();\\n            vector<int> newleaves;\\n            for(int i: leaves){\\n                int j = adj[i].back();\\n                adj[j].erase(std::remove(adj[j].begin(), adj[j].end(), i), adj[j].end());\\n                if(adj[j].size()==1)newleaves.push_back(j);\\n            }\\n            leaves = newleaves;\\n        }\\n        return leaves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)return {0};\\n        vector<vector<int> > adj(n, vector<int>());\\n        \\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> leaves;\\n        for(int i = 0;i<n;i++){\\n            if(adj[i].size() == 1){\\n                leaves.push_back(i);\\n            }\\n        }\\n        \\n        while(n>2){\\n            n-=leaves.size();\\n            vector<int> newleaves;\\n            for(int i: leaves){\\n                int j = adj[i].back();\\n                adj[j].erase(std::remove(adj[j].begin(), adj[j].end(), i), adj[j].end());\\n                if(adj[j].size()==1)newleaves.push_back(j);\\n            }\\n            leaves = newleaves;\\n        }\\n        return leaves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959989,
                "title": "javascript-topological-sort",
                "content": "```\\nvar findMinHeightTrees = function(n, edges) {\\n    if (n === 1) {\\n        return [0]\\n    }\\n    \\n    const indegrees = new Array(n).fill(0)\\n    const graph = new Map()\\n    \\n    for (let i = 0; i < n; i++) {\\n        graph.set(i, [])\\n    }\\n    \\n    for (const [e1, e2] of edges) {\\n        graph.get(e1).push(e2)\\n        graph.get(e2).push(e1)\\n        \\n        indegrees[e1] += 1\\n        indegrees[e2] += 1\\n    }\\n    \\n    const queue = []\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (indegrees[i] === 1) {\\n            queue.push(i)\\n        }\\n    }\\n\\n    while (n > 2) {\\n        let size = queue.length\\n        n -= size\\n                       \\n        while (size > 0) {\\n            const node = queue.shift()\\n            size -= 1\\n            \\n            for (const neighbour of graph.get(node)) {\\n                indegrees[neighbour] -= 1\\n                \\n                if (indegrees[neighbour] === 1) {\\n                    queue.push(neighbour)\\n                }\\n            }\\n        }\\n    }\\n    \\n    return queue\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort"
                ],
                "code": "```\\nvar findMinHeightTrees = function(n, edges) {\\n    if (n === 1) {\\n        return [0]\\n    }\\n    \\n    const indegrees = new Array(n).fill(0)\\n    const graph = new Map()\\n    \\n    for (let i = 0; i < n; i++) {\\n        graph.set(i, [])\\n    }\\n    \\n    for (const [e1, e2] of edges) {\\n        graph.get(e1).push(e2)\\n        graph.get(e2).push(e1)\\n        \\n        indegrees[e1] += 1\\n        indegrees[e2] += 1\\n    }\\n    \\n    const queue = []\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (indegrees[i] === 1) {\\n            queue.push(i)\\n        }\\n    }\\n\\n    while (n > 2) {\\n        let size = queue.length\\n        n -= size\\n                       \\n        while (size > 0) {\\n            const node = queue.shift()\\n            size -= 1\\n            \\n            for (const neighbour of graph.get(node)) {\\n                indegrees[neighbour] -= 1\\n                \\n                if (indegrees[neighbour] === 1) {\\n                    queue.push(neighbour)\\n                }\\n            }\\n        }\\n    }\\n    \\n    return queue\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924392,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=ZfzVig8UqBQ)\\nhttps://www.youtube.com/watch?v=ZfzVig8UqBQ\\n```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n <= 2:\\n            return [x for x in range(n)]\\n        \\n        neighbors = [set() for x in range(n)] \\n        for start, end in edges:\\n            neighbors[start].add(end)\\n            neighbors[end].add(start)\\n        \\n        leaves = []\\n        for i in range(n):\\n            if len(neighbors[i]) == 1:\\n                leaves.append(i)\\n        \\n        remaining_nodes = n\\n        while remaining_nodes > 2:\\n            remaining_nodes -= len(leaves)\\n            temp = []\\n            \\n            for leaf in leaves:\\n                for neighbor in neighbors[leaf]:\\n                    neighbors[neighbor].remove(leaf)\\n                    if len(neighbors[neighbor]) == 1:\\n                        temp.append(neighbor)\\n            leaves = temp\\n        \\n        return leaves\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n <= 2:\\n            return [x for x in range(n)]\\n        \\n        neighbors = [set() for x in range(n)] \\n        for start, end in edges:\\n            neighbors[start].add(end)\\n            neighbors[end].add(start)\\n        \\n        leaves = []\\n        for i in range(n):\\n            if len(neighbors[i]) == 1:\\n                leaves.append(i)\\n        \\n        remaining_nodes = n\\n        while remaining_nodes > 2:\\n            remaining_nodes -= len(leaves)\\n            temp = []\\n            \\n            for leaf in leaves:\\n                for neighbor in neighbors[leaf]:\\n                    neighbors[neighbor].remove(leaf)\\n                    if len(neighbors[neighbor]) == 1:\\n                        temp.append(neighbor)\\n            leaves = temp\\n        \\n        return leaves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732364,
                "title": "not-code-but-explanation-behind-cutting-the-leaves-after-i-alot-efforts-came-up-with-a-solution",
                "content": "```\\n Diameter of Tree: ->\\n\\nIt is the longest path between two any leaf nodes among all leaf nodes pairs\\n\\nFor Example :->\\n\\n     1\\n    / \\\\\\n   2    3\\n  / \\\\  / \\\\\\n 4  5  6  7\\n\\n  Options are :->\\n  Paths between all pairs of leaf nodes\\n  (4,5),(4,6),(4,7),(5,6),(5,7),(6,7)\\n\\n  4 -> 2 -> 5\\n  4 -> 2 -> 1 -> 3->6\\n  4 ->2 -> 1 -> 3 ->7\\n  5 ->2 ->  1-> 3 ->6\\n  5 ->2 ->1 -> 3-> 7\\n  6 -> 3 ->7\\n\\n\\n\\n\\n\\n     MHT (Minimum Height Trees Problem ) :->\\n    Remember we do not know root node that\\'s we need to find we only know leaf node\\n   In this problem we have to find the root nodes that form minimum height tree .\\n   For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.\\n\\n   Format\\n   The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).\\n\\n   You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\\n\\n\\n\\n  Remember :->  Number of root nodes for this problem will be MINIMUM - 1 AND MAXIMUM - 2\\n                These root nodes are the center of the Diameter .\\n                Why ?  Because height of any node depend on the longest path  of left side or  right side to last level leaf node under that subtree\\n\\n\\n\\n Important : -> If the length of the longest path is even we have two MHT otherwise 1\\n\\n\\n  That is why leaf cutting approach is best for MHT that follow same diameter pattern\\n\\n      4 -> 2 -> 5\\n      4 -> 2 -> 1 -> 3->6\\n      4 ->2 -> 1 -> 3 ->7\\n      5 ->2 ->  1-> 3 ->6\\n      5 ->2 ->1 -> 3-> 7\\n      6 -> 3 ->7\\n\\n      Leaf Nodes are 4,5,6,7  because they have degree 1\\n      Cut all these nodes\\n\\n      After that result is : ->\\n\\n             2\\n            2 -> 1 -> 3\\n            2 -> 1 -> 3\\n            2 ->  1-> 3\\n            2 ->1 -> 3\\n             3\\n      Nodes remaining in the original tree is 3\\n\\n      So cut again all leaf nodes\\n\\n         1\\n         1\\n         1\\n         1\\n\\n       Now remaining number of  node is only 1 that is not greater than 2\\n       so we need to stop cutting so our answer is 1\\n\\nIf a tree have all nodes having degree 1 then all nodes are answer for MHT again maximum is 2\\nLeaf nodes can not be treated as root for MHT problem .\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n Diameter of Tree: ->\\n\\nIt is the longest path between two any leaf nodes among all leaf nodes pairs\\n\\nFor Example :->\\n\\n     1\\n    / \\\\\\n   2    3\\n  / \\\\  / \\\\\\n 4  5  6  7\\n\\n  Options are :->\\n  Paths between all pairs of leaf nodes\\n  (4,5),(4,6),(4,7),(5,6),(5,7),(6,7)\\n\\n  4 -> 2 -> 5\\n  4 -> 2 -> 1 -> 3->6\\n  4 ->2 -> 1 -> 3 ->7\\n  5 ->2 ->  1-> 3 ->6\\n  5 ->2 ->1 -> 3-> 7\\n  6 -> 3 ->7\\n\\n\\n\\n\\n\\n     MHT (Minimum Height Trees Problem ) :->\\n    Remember we do not know root node that\\'s we need to find we only know leaf node\\n   In this problem we have to find the root nodes that form minimum height tree .\\n   For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.\\n\\n   Format\\n   The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).\\n\\n   You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\\n\\n\\n\\n  Remember :->  Number of root nodes for this problem will be MINIMUM - 1 AND MAXIMUM - 2\\n                These root nodes are the center of the Diameter .\\n                Why ?  Because height of any node depend on the longest path  of left side or  right side to last level leaf node under that subtree\\n\\n\\n\\n Important : -> If the length of the longest path is even we have two MHT otherwise 1\\n\\n\\n  That is why leaf cutting approach is best for MHT that follow same diameter pattern\\n\\n      4 -> 2 -> 5\\n      4 -> 2 -> 1 -> 3->6\\n      4 ->2 -> 1 -> 3 ->7\\n      5 ->2 ->  1-> 3 ->6\\n      5 ->2 ->1 -> 3-> 7\\n      6 -> 3 ->7\\n\\n      Leaf Nodes are 4,5,6,7  because they have degree 1\\n      Cut all these nodes\\n\\n      After that result is : ->\\n\\n             2\\n            2 -> 1 -> 3\\n            2 -> 1 -> 3\\n            2 ->  1-> 3\\n            2 ->1 -> 3\\n             3\\n      Nodes remaining in the original tree is 3\\n\\n      So cut again all leaf nodes\\n\\n         1\\n         1\\n         1\\n         1\\n\\n       Now remaining number of  node is only 1 that is not greater than 2\\n       so we need to stop cutting so our answer is 1\\n\\nIf a tree have all nodes having degree 1 then all nodes are answer for MHT again maximum is 2\\nLeaf nodes can not be treated as root for MHT problem .\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 613295,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> res = new ArrayList<>();\\n        if (n == 1){\\n            res.add(0);\\n            return res;\\n        }\\n        //edge list\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        //degree list\\n        int[] degree = new int[n];\\n        \\n        //construct edge list and degree list\\n        for (int[] edge: edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n            ++degree[edge[0]];\\n            ++degree[edge[1]];\\n        }\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < degree.length; i++) {\\n            if (degree[i] == 1) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        //every time, remove current leaf nodes \\n        //the left nodes have 2 cases: \\n        //1) only root; \\n        //2) 2 nodes connected by an edge, both can be root; \\n        while (!q.isEmpty()) {\\n            List<Integer> list = new ArrayList<>();\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int node = q.poll();\\n                list.add(node);\\n                degree[node] = 1;\\n                //like topological sort, remove nodes with 1 edge one by one.\\n                List<Integer> neighbours = map.get(node);\\n                for (int m = 0; m < neighbours.size(); m++) {\\n                    int v = neighbours.get(m);\\n                    --degree[v];\\n                    if (degree[v] == 1) {\\n                        q.add(v);\\n                    }\\n                }\\n            }\\n            res = list;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> res = new ArrayList<>();\\n        if (n == 1){\\n            res.add(0);\\n            return res;\\n        }\\n        //edge list\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        //degree list\\n        int[] degree = new int[n];\\n        \\n        //construct edge list and degree list\\n        for (int[] edge: edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n            ++degree[edge[0]];\\n            ++degree[edge[1]];\\n        }\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < degree.length; i++) {\\n            if (degree[i] == 1) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        //every time, remove current leaf nodes \\n        //the left nodes have 2 cases: \\n        //1) only root; \\n        //2) 2 nodes connected by an edge, both can be root; \\n        while (!q.isEmpty()) {\\n            List<Integer> list = new ArrayList<>();\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int node = q.poll();\\n                list.add(node);\\n                degree[node] = 1;\\n                //like topological sort, remove nodes with 1 edge one by one.\\n                List<Integer> neighbours = map.get(node);\\n                for (int m = 0; m < neighbours.size(); m++) {\\n                    int v = neighbours.get(m);\\n                    --degree[v];\\n                    if (degree[v] == 1) {\\n                        q.add(v);\\n                    }\\n                }\\n            }\\n            res = list;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573561,
                "title": "fast-and-simple-recursive-java-solution-with-explanation",
                "content": "Idea is we keep prone leaves in the tree, at the end the 1 or 2 nodes left will be our answer. Why we need to remove leaves? Because a leaf would not make a good candidate as the root of a Minimum Height Tree.\\n\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new ArrayList<>());\\n        for (int[] e : edges) {\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (map.get(i).size() == 1) list.add(i);\\n        }\\n        return prone(map, list);\\n    }\\n    \\n    private List<Integer> prone(Map<Integer, List<Integer>> map, List<Integer> leaves) {\\n        if (map.size() <= 2) return new ArrayList<>(map.keySet());\\n        List<Integer> list = new ArrayList<>();\\n        for (Integer leaf : leaves) {\\n            Integer neighbor = map.get(leaf).get(0);\\n            map.get(neighbor).remove(leaf);\\n            if (map.get(neighbor).size() == 1) list.add(neighbor);\\n            map.remove(leaf);\\n        }\\n        return prone(map, list);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new ArrayList<>());\\n        for (int[] e : edges) {\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (map.get(i).size() == 1) list.add(i);\\n        }\\n        return prone(map, list);\\n    }\\n    \\n    private List<Integer> prone(Map<Integer, List<Integer>> map, List<Integer> leaves) {\\n        if (map.size() <= 2) return new ArrayList<>(map.keySet());\\n        List<Integer> list = new ArrayList<>();\\n        for (Integer leaf : leaves) {\\n            Integer neighbor = map.get(leaf).get(0);\\n            map.get(neighbor).remove(leaf);\\n            if (map.get(neighbor).size() == 1) list.add(neighbor);\\n            map.remove(leaf);\\n        }\\n        return prone(map, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255963,
                "title": "solution-similar-to-topological-sort-with-image-and-speed-improvement-process",
                "content": "Thoughts:\\n1. Intuitively, to get a minnimum height tree is to look for the center of the input graph, which is kind of similar to find the mid node of a linked list. To find the mid node of a linked list \\nwe can cut node from start and end until the list contains only 1 or 2 nodes. \\n2. The center of the graph could be 1 node or 2 nodes.(As shown in question description)\\n3. To find the center of the graph want I will do is\\n   (1) Cut the leaf (only has one edge)\\n   (2) check how may nodes left in the graph\\n   (3) If more than 2 nodes left repeat step (1), otherwise return the nodes left in the graph.\\n4. The process is shown below.\\n\\n![image](https://assets.leetcode.com/users/popmao/image_1552674348.png)\\n\\n\\nWith above thoughts my first version code has correct logic but TLE for huge input. Because I created a matrix for the graph which takes too much time to remove the leaves from graph, for each leaf I have to go through\\ncol and row to set the value to 0. Finally I came up with something really similar to Topological Sort using a hashmap to store connected node and a array to store edge count. I will give the accpted code below and fisrt version after that.\\n\\n```\\n// Accepted \\npublic class Solution {\\n  public List<int> FindMinHeightTrees(int n, int[,] edges) {\\n\\n    List<int> res = new List<int>();\\n    if( n == 0 || edges == null) return res;\\n    int len = edges.GetLength(0);\\n\\n    //Arrar to store edge count for each node\\n    int[] edgeCount =  new int[n];\\n\\n    //Store each node and the connected nodes\\n    var dict= new Dictionary<int , List<int>>(); \\n    \\n    for(int i = 0; i < len ; i++)\\n    {\\n      int row = edges[i,0];\\n      int col =edges[i,1];\\n\\n      // if u, v connected edgeCount[u]++,edgeCount[v]++\\n      edgeCount[row]++;\\n      edgeCount[col]++;\\n\\n      if(dict.ContainsKey(row)){\\n        dict[row].Add(col);\\n      }\\n      else{\\n        dict.Add(row, new List<int>(){col});\\n      }\\n\\n      if(dict.ContainsKey(col)){\\n        dict[col].Add(row);\\n      }\\n      else{\\n        dict.Add(col, new List<int>(){row});\\n      }\\n    }\\n\\n    while(nodeleftcount(edgeCount) > 2)\\n    {    \\n\\n      // Find all leaves\\n      List<int> leaves = FindLeaves(edgeCount);\\n      foreach(var leaf in leaves)\\n      {\\n\\n          foreach(int e in dict[leaf])\\n          {\\n            // For all nodes connected with leaf, edgecount--\\n            edgeCount[e]--;\\n          }\\n          // cut leaf\\n          edgeCount[leaf] = -1;\\n      }\\n    }\\n\\n    for(int i =0;i<n;i++)\\n    {\\n      if(edgeCount[i]>=0)\\n      {\\n        res.Add(i);\\n      }\\n    }\\n\\n    return res;\\n  }\\n\\n\\n  public int nodeleftcount(int[] isRemoved)\\n  {\\n    int count = 0;\\n    foreach(var i in isRemoved)\\n    {\\n      if(i >= 0) count++;\\n    }\\n    return count;\\n  }\\n       \\n  public List<int> FindLeaves(int[] edgeCount)\\n  {\\n    List<int> leaves = new List<int>();\\n    for(int i = 0; i < edgeCount.Length; i++)\\n    {\\n        if(edgeCount[i] == 1) leaves.Add(i);\\n    }\\n    return leaves;\\n  }    \\n}\\n```\\n\\n\\n```\\n// First version\\npublic class Solution {\\n  public List<int> FindMinHeightTrees(int n, int[,] edges) {\\n    List<int> res = new List<int>();\\n    if( n == 0 || edges == null) return res;\\n    int len = edges.GetLength(0);\\n\\n    bool[] isRemoved =  new bool[n];\\n    int[][] matrix = new int[n][];\\n    for(int i = 0; i<n;i++)\\n    {\\n      matrix[i] = new int[n];\\n    }\\n    \\n    for(int i = 0; i < len ; i++)\\n    {\\n      int row = edges[i,0];\\n      int col =edges[i,1];\\n      matrix[row][col] = 1;\\n      matrix[col][row] = 1;\\n    }\\n\\n    while(nodeleftcount(isRemoved) > 2)\\n    {\\n      List<int> leaves = FindLeaves(matrix, isRemoved);\\n      foreach(int leaf in leaves)\\n      {\\n\\n        isRemoved[leaf] = true;\\n      }\\n    }\\n\\n    for(int i = 0 ;i < n;i++)\\n    {\\n      if(!isRemoved[i]) res.Add(i);\\n    }\\n\\n    return res;       \\n  }\\n\\n  public List<int> FindLeaves(int[][] matrix, bool[] isRemoved)\\n  {\\n    List<int> leaves = new List<int>();\\n    for(int i = 0; i < matrix.Length; i++)\\n    {\\n      if(isRemoved[i]) continue;\\n      if(matrix[i].Sum() == 1) leaves.Add(i);\\n    }\\n    return leaves;\\n  }\\n\\n  public int nodeleftcount(bool[] isRemoved)\\n  {\\n    int count = 0;\\n    foreach(bool i in isRemoved)\\n    {\\n      if(!i) count++;\\n    }\\n    return count;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\n// Accepted \\npublic class Solution {\\n  public List<int> FindMinHeightTrees(int n, int[,] edges) {\\n\\n    List<int> res = new List<int>();\\n    if( n == 0 || edges == null) return res;\\n    int len = edges.GetLength(0);\\n\\n    //Arrar to store edge count for each node\\n    int[] edgeCount =  new int[n];\\n\\n    //Store each node and the connected nodes\\n    var dict= new Dictionary<int , List<int>>(); \\n    \\n    for(int i = 0; i < len ; i++)\\n    {\\n      int row = edges[i,0];\\n      int col =edges[i,1];\\n\\n      // if u, v connected edgeCount[u]++,edgeCount[v]++\\n      edgeCount[row]++;\\n      edgeCount[col]++;\\n\\n      if(dict.ContainsKey(row)){\\n        dict[row].Add(col);\\n      }\\n      else{\\n        dict.Add(row, new List<int>(){col});\\n      }\\n\\n      if(dict.ContainsKey(col)){\\n        dict[col].Add(row);\\n      }\\n      else{\\n        dict.Add(col, new List<int>(){row});\\n      }\\n    }\\n\\n    while(nodeleftcount(edgeCount) > 2)\\n    {    \\n\\n      // Find all leaves\\n      List<int> leaves = FindLeaves(edgeCount);\\n      foreach(var leaf in leaves)\\n      {\\n\\n          foreach(int e in dict[leaf])\\n          {\\n            // For all nodes connected with leaf, edgecount--\\n            edgeCount[e]--;\\n          }\\n          // cut leaf\\n          edgeCount[leaf] = -1;\\n      }\\n    }\\n\\n    for(int i =0;i<n;i++)\\n    {\\n      if(edgeCount[i]>=0)\\n      {\\n        res.Add(i);\\n      }\\n    }\\n\\n    return res;\\n  }\\n\\n\\n  public int nodeleftcount(int[] isRemoved)\\n  {\\n    int count = 0;\\n    foreach(var i in isRemoved)\\n    {\\n      if(i >= 0) count++;\\n    }\\n    return count;\\n  }\\n       \\n  public List<int> FindLeaves(int[] edgeCount)\\n  {\\n    List<int> leaves = new List<int>();\\n    for(int i = 0; i < edgeCount.Length; i++)\\n    {\\n        if(edgeCount[i] == 1) leaves.Add(i);\\n    }\\n    return leaves;\\n  }    \\n}\\n```\n```\\n// First version\\npublic class Solution {\\n  public List<int> FindMinHeightTrees(int n, int[,] edges) {\\n    List<int> res = new List<int>();\\n    if( n == 0 || edges == null) return res;\\n    int len = edges.GetLength(0);\\n\\n    bool[] isRemoved =  new bool[n];\\n    int[][] matrix = new int[n][];\\n    for(int i = 0; i<n;i++)\\n    {\\n      matrix[i] = new int[n];\\n    }\\n    \\n    for(int i = 0; i < len ; i++)\\n    {\\n      int row = edges[i,0];\\n      int col =edges[i,1];\\n      matrix[row][col] = 1;\\n      matrix[col][row] = 1;\\n    }\\n\\n    while(nodeleftcount(isRemoved) > 2)\\n    {\\n      List<int> leaves = FindLeaves(matrix, isRemoved);\\n      foreach(int leaf in leaves)\\n      {\\n\\n        isRemoved[leaf] = true;\\n      }\\n    }\\n\\n    for(int i = 0 ;i < n;i++)\\n    {\\n      if(!isRemoved[i]) res.Add(i);\\n    }\\n\\n    return res;       \\n  }\\n\\n  public List<int> FindLeaves(int[][] matrix, bool[] isRemoved)\\n  {\\n    List<int> leaves = new List<int>();\\n    for(int i = 0; i < matrix.Length; i++)\\n    {\\n      if(isRemoved[i]) continue;\\n      if(matrix[i].Sum() == 1) leaves.Add(i);\\n    }\\n    return leaves;\\n  }\\n\\n  public int nodeleftcount(bool[] isRemoved)\\n  {\\n    int count = 0;\\n    foreach(bool i in isRemoved)\\n    {\\n      if(!i) count++;\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76123,
                "title": "why-c-is-much-slower-than-java",
                "content": "I solved this problem by C++ and Java, and the solutions used same algorithm. But the C++ solution is much slower than the Java one. Why? I thought that C++ should be much faster than Java. Here is my code:\\n\\nC++ version (1100+ms):\\n\\n    class Solution {\\n    public:\\n        vector<int> findMinHeightTrees(int n, vector<pair<int, int>> &edges) {\\n    \\n            if (n == 1)\\n                return { 0 };\\n    \\n            unordered_set<int> adj[n];\\n            for (auto &p : edges) {\\n                adj[p.first].insert(p.second);\\n                adj[p.second].insert(p.first);\\n            }\\n    \\n            vector<int> cur, next;\\n            for (int i = 0; i < n; i++)\\n                if (adj[i].size() == 1)\\n                    cur.push_back(i);\\n    \\n            while (n > 2) {\\n                for (int &v : cur) {\\n                    int w = *adj[v].begin();\\n                    adj[w].erase(v);\\n                    if (adj[w].size() == 1)\\n                        next.push_back(w);\\n                }\\n                n -= cur.size();\\n                cur.swap(next);\\n                next.clear();\\n            }\\n            return cur;\\n        }\\n    };\\n\\nJava version (50ms):\\n\\n    class Solution {\\n        public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n    \\n            if (n == 1)\\n                return Collections.singletonList(0);\\n    \\n            HashSet<Integer> adj[] = new HashSet[n];\\n            for (int i = 0; i < n; i++)\\n                adj[i] = new HashSet<>();\\n    \\n            for (int edge[] : edges) {\\n                adj[edge[0]].add(edge[1]);\\n                adj[edge[1]].add(edge[0]);\\n            }\\n    \\n            List<Integer> cur = new ArrayList<>();\\n    \\n            for (int i = 0; i < n; i++)\\n                if (adj[i].size() == 1)\\n                    cur.add(i);\\n    \\n            while (n > 2) {\\n                List<Integer> next = new ArrayList<>();\\n                for (int v : cur) {\\n                    int w = adj[v].iterator().next();\\n                    adj[w].remove(v);\\n                    if (adj[w].size() == 1)\\n                        next.add(w);\\n                }\\n                n -= cur.size();\\n                cur = next;\\n            }\\n            return cur;\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> findMinHeightTrees(int n, vector<pair<int, int>> &edges) {\\n    \\n            if (n == 1)\\n                return { 0 }",
                "codeTag": "Java"
            },
            {
                "id": 76140,
                "title": "short-o-n-time-o-n-space-python-solution-using-bfs",
                "content": "    def findMinHeightTrees(n, edges):\\n            if n <= 1:\\n                return [0]\\n            degrees = [0] * n\\n            graph = {x:[] for x in xrange(n)}\\n            for p in edges:\\n                degrees[p[1]] += 1\\n                degrees[p[0]] += 1\\n                graph[p[1]].append(p[0])\\n                graph[p[0]].append(p[1])\\n                \\n            queue = [x for x in xrange(0,n) if degrees[x] == 1]\\n            ret = []\\n            while queue:\\n                temp = []\\n                ret = queue[:]\\n                for x in queue:\\n                    for n in graph[x]:\\n                        degrees[n] -= 1\\n                        if degrees[n] == 1:\\n                            temp.append(n)\\n                queue = temp\\n                \\n            return ret",
                "solutionTags": [],
                "code": "    def findMinHeightTrees(n, edges):\\n            if n <= 1:\\n                return [0]\\n            degrees = [0] * n\\n            graph = {x:[] for x in xrange(n)}\\n            for p in edges:\\n                degrees[p[1]] += 1\\n                degrees[p[0]] += 1\\n                graph[p[1]].append(p[0])\\n                graph[p[0]].append(p[1])\\n                \\n            queue = [x for x in xrange(0,n) if degrees[x] == 1]\\n            ret = []\\n            while queue:\\n                temp = []\\n                ret = queue[:]\\n                for x in queue:\\n                    for n in graph[x]:\\n                        degrees[n] -= 1\\n                        if degrees[n] == 1:\\n                            temp.append(n)\\n                queue = temp\\n                \\n            return ret",
                "codeTag": "Python3"
            },
            {
                "id": 2812761,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==0)\\n            return {};\\n        if(n==1)\\n            return {0};\\n        vector<int>res;\\n        vector<int>degrees(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            degrees[edges[i][1]]++;\\n            degrees[edges[i][0]]++;\\n        }\\n        queue<int>queue;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(degrees[i]==1)\\n                queue.push(i);\\n        }\\n        while(!queue.empty())\\n        {\\n            res.clear();\\n            int size=queue.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int cur=queue.front();\\n                queue.pop();\\n                res.push_back(cur);\\n                for(auto &neighbor:adj[cur])\\n                {\\n                    degrees[neighbor]--;\\n                    if(degrees[neighbor]==1)\\n                        queue.push(neighbor);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\\\\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==0)\\n            return {};\\n        if(n==1)\\n            return {0};\\n        vector<int>res;\\n        vector<int>degrees(n,0);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            degrees[edges[i][1]]++;\\n            degrees[edges[i][0]]++;\\n        }\\n        queue<int>queue;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(degrees[i]==1)\\n                queue.push(i);\\n        }\\n        while(!queue.empty())\\n        {\\n            res.clear();\\n            int size=queue.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int cur=queue.front();\\n                queue.pop();\\n                res.push_back(cur);\\n                for(auto &neighbor:adj[cur])\\n                {\\n                    degrees[neighbor]--;\\n                    if(degrees[neighbor]==1)\\n                        queue.push(neighbor);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\\\\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652041,
                "title": "typical-variant-of-rerooting-dp-on-trees",
                "content": "In this problem we need to find all such nodes that have minimum height.To find the height of Tree from every node as root will take O(n*n) time.For checking every node as root will take O(n) time plus the additional O(n) for dfs to compute the height of tree from that particular root.That\\'s where the concept of rerooting dp comes into picture.\\n\\nApproach:\\n1:) We will first root the tree at 0 and calculate the height of subtrees of every node in the first dfs call.\\n2:) In the second dfs call we are finding the maximum possible height of the tree from that root.\\n3:) At the end of the two dfs calls we will return all such nodes that  have same minimum height \\n4;) Time Complexity : O(N).\\n\\n\\n\\n```\\nvector<vector<int>> adj;\\nvector<int> f;\\nvector<int> ans;\\nclass Solution {\\npublic:\\n     void dfs(int node,int par)\\n     {\\n         int temp=0;\\n         bool leaf=true;\\n           for(auto nbr:adj[node])\\n           {\\n                 if(nbr==par)\\n                 {\\n                      continue;\\n                 }\\n               leaf=false;\\n              dfs(nbr,node);\\n               temp=max(temp,f[nbr]);\\n           }\\n         if(!leaf)\\n         {\\n            f[node]=temp+1;\\n         }\\n         ans[node]=max(ans[node],f[node]);\\n     }\\n     void dfs2(int node,int par,int pd)\\n     {\\n             vector<pair<int,int>> temp;\\n            temp.push_back({pd,-1});\\n            ans[node]=max(ans[node],f[node]);\\n            for(auto nbr:adj[node])\\n            {\\n                 if(nbr==par)\\n                 {\\n                       continue;\\n                 }\\n              temp.push_back({f[nbr]+1,nbr});\\n            }\\n           sort(temp.begin(),temp.end());\\n          \\n            \\n           for(auto nbr:adj[node])\\n           {\\n                 if(nbr==par)\\n                 {\\n                      continue;\\n                 }\\n                 \\n                 if(temp.back().second==nbr)\\n                 {\\n                    \\n                    \\n                     int beforenode=f[node];\\n                     int beforenbr=f[nbr];\\n                 \\n                     f[node]=0;\\n                   f[node]+=temp[temp.size()-2].first;\\n                     \\n                   int pass=1+temp[temp.size()-2].first;\\n                   f[nbr]=max(f[nbr],pass);\\n                 \\n\\n                     \\n                   dfs2(nbr,node,pass);\\n                   f[node]=beforenode;\\n                   f[nbr]=beforenbr;                     \\n                    \\n                 }else if(temp.back().second!=nbr)\\n                 {\\n                     int beforenode=f[node];\\n                     int beforenbr=f[nbr];\\n                     \\n                     f[nbr]=max(f[nbr],temp.back().first+1);\\n                     int pass=temp.back().first+1;\\n                     dfs2(nbr,node,pass);\\n                     f[nbr]=beforenbr;\\n                     \\n                 }\\n           }\\n         \\n         \\n         \\n         \\n         \\n     }\\n    \\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        adj.assign(n,vector<int>());\\n        f.assign(n,0);\\n        ans.assign(n,0);\\n        int m=edges.size();\\n        for(int i=0;i<m;++i)\\n        {\\n              vector<int> e=edges[i];\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        dfs(0,n);\\n      \\n        dfs2(0,n,0);\\n      \\n      int mn=*min_element(ans.begin(),ans.end());\\n        vector<int> an;\\n        for(int i=0;i<n;++i)\\n        {\\n              if(ans[i]==mn)\\n              {\\n                    an.push_back(i);\\n              }\\n        }\\n       \\n       \\n        \\n       return an;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nvector<vector<int>> adj;\\nvector<int> f;\\nvector<int> ans;\\nclass Solution {\\npublic:\\n     void dfs(int node,int par)\\n     {\\n         int temp=0;\\n         bool leaf=true;\\n           for(auto nbr:adj[node])\\n           {\\n                 if(nbr==par)\\n                 {\\n                      continue;\\n                 }\\n               leaf=false;\\n              dfs(nbr,node);\\n               temp=max(temp,f[nbr]);\\n           }\\n         if(!leaf)\\n         {\\n            f[node]=temp+1;\\n         }\\n         ans[node]=max(ans[node],f[node]);\\n     }\\n     void dfs2(int node,int par,int pd)\\n     {\\n             vector<pair<int,int>> temp;\\n            temp.push_back({pd,-1});\\n            ans[node]=max(ans[node],f[node]);\\n            for(auto nbr:adj[node])\\n            {\\n                 if(nbr==par)\\n                 {\\n                       continue;\\n                 }\\n              temp.push_back({f[nbr]+1,nbr});\\n            }\\n           sort(temp.begin(),temp.end());\\n          \\n            \\n           for(auto nbr:adj[node])\\n           {\\n                 if(nbr==par)\\n                 {\\n                      continue;\\n                 }\\n                 \\n                 if(temp.back().second==nbr)\\n                 {\\n                    \\n                    \\n                     int beforenode=f[node];\\n                     int beforenbr=f[nbr];\\n                 \\n                     f[node]=0;\\n                   f[node]+=temp[temp.size()-2].first;\\n                     \\n                   int pass=1+temp[temp.size()-2].first;\\n                   f[nbr]=max(f[nbr],pass);\\n                 \\n\\n                     \\n                   dfs2(nbr,node,pass);\\n                   f[node]=beforenode;\\n                   f[nbr]=beforenbr;                     \\n                    \\n                 }else if(temp.back().second!=nbr)\\n                 {\\n                     int beforenode=f[node];\\n                     int beforenbr=f[nbr];\\n                     \\n                     f[nbr]=max(f[nbr],temp.back().first+1);\\n                     int pass=temp.back().first+1;\\n                     dfs2(nbr,node,pass);\\n                     f[nbr]=beforenbr;\\n                     \\n                 }\\n           }\\n         \\n         \\n         \\n         \\n         \\n     }\\n    \\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        adj.assign(n,vector<int>());\\n        f.assign(n,0);\\n        ans.assign(n,0);\\n        int m=edges.size();\\n        for(int i=0;i<m;++i)\\n        {\\n              vector<int> e=edges[i];\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        dfs(0,n);\\n      \\n        dfs2(0,n,0);\\n      \\n      int mn=*min_element(ans.begin(),ans.end());\\n        vector<int> an;\\n        for(int i=0;i<n;++i)\\n        {\\n              if(ans[i]==mn)\\n              {\\n                    an.push_back(i);\\n              }\\n        }\\n       \\n       \\n        \\n       return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926596,
                "title": "c-intuitive-o-n",
                "content": "* Firstly just find the longest path in the tree. Standard BFS problem.\\n* While doing that also mark the parents so that you can retrace the longest path.\\n* Now simply retrace the path till the mid point (one more point if the parity of diameter is odd).\\n* And just push the centre points to the ans.\\n* Return ans\\n\\n```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> edges;\\n\\tint node = 0;\\n\\tint maxi = 0;\\n\\n\\tvoid dfs(int root, int lev, int par) {\\n\\t\\tif (lev >= maxi) node = root, maxi = lev;\\n\\n\\t\\tfor (auto &child : edges[root]) {\\n\\t\\t\\tif (child == par)continue;\\n\\t\\t\\tdfs(child, lev + 1, root);\\n\\t\\t}\\n\\n\\t\\treturn;\\n\\t}\\n\\n\\tvector<int> findMinHeightTrees(int n, vector<vector<int>>& _edges) {\\n\\t\\tedges.clear();\\n\\t\\tedges.resize(n);\\n\\t\\tnode = 0;\\n\\t\\tmaxi = 0;\\n\\n\\t\\tfor (auto &elem : _edges) {\\n\\t\\t\\tedges[elem[0]].push_back(elem[1]);\\n\\t\\t\\tedges[elem[1]].push_back(elem[0]);\\n\\t\\t}\\n\\n\\t\\tdfs(0, 0, -1);\\n\\n\\t\\tvector<bool> vis(n, 0);\\n\\t\\tvector<int> par(n, -1);\\n\\t\\tqueue<vector<int>>q;\\n\\t\\tq.push({node, 0});\\n\\n\\t\\tint end1 = node;\\n\\t\\tvis[end1] = 1;\\n\\t\\tint depth = 0;\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tauto tp = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif (tp[1] >= depth) {\\n\\t\\t\\t\\tdepth = tp[1];\\n\\t\\t\\t\\tend1 = tp[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto &child : edges[tp[0]]) {\\n\\t\\t\\t\\tif (!vis[child]) {\\n\\t\\t\\t\\t\\tvis[child] = 1;\\n\\t\\t\\t\\t\\tpar[child] = tp[0];\\n\\t\\t\\t\\t\\tq.push({child, tp[1] + 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint count = 0;\\n\\t\\tint curr = end1;\\n\\t\\tvector<int> ans;\\n\\n\\t\\twhile (curr != -1 && ans.size() < depth % 2 + 1) {\\n\\t\\t\\tif (count == depth / 2 || count == (depth + 1) / 2) {\\n\\t\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t}\\n\\t\\t\\tcurr = par[curr];\\n\\t\\t\\tcount++;\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> edges;\\n\\tint node = 0;\\n\\tint maxi = 0;\\n\\n\\tvoid dfs(int root, int lev, int par) {\\n\\t\\tif (lev >= maxi) node = root, maxi = lev;\\n\\n\\t\\tfor (auto &child : edges[root]) {\\n\\t\\t\\tif (child == par)continue;\\n\\t\\t\\tdfs(child, lev + 1, root);\\n\\t\\t}\\n\\n\\t\\treturn;\\n\\t}\\n\\n\\tvector<int> findMinHeightTrees(int n, vector<vector<int>>& _edges) {\\n\\t\\tedges.clear();\\n\\t\\tedges.resize(n);\\n\\t\\tnode = 0;\\n\\t\\tmaxi = 0;\\n\\n\\t\\tfor (auto &elem : _edges) {\\n\\t\\t\\tedges[elem[0]].push_back(elem[1]);\\n\\t\\t\\tedges[elem[1]].push_back(elem[0]);\\n\\t\\t}\\n\\n\\t\\tdfs(0, 0, -1);\\n\\n\\t\\tvector<bool> vis(n, 0);\\n\\t\\tvector<int> par(n, -1);\\n\\t\\tqueue<vector<int>>q;\\n\\t\\tq.push({node, 0});\\n\\n\\t\\tint end1 = node;\\n\\t\\tvis[end1] = 1;\\n\\t\\tint depth = 0;\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tauto tp = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif (tp[1] >= depth) {\\n\\t\\t\\t\\tdepth = tp[1];\\n\\t\\t\\t\\tend1 = tp[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto &child : edges[tp[0]]) {\\n\\t\\t\\t\\tif (!vis[child]) {\\n\\t\\t\\t\\t\\tvis[child] = 1;\\n\\t\\t\\t\\t\\tpar[child] = tp[0];\\n\\t\\t\\t\\t\\tq.push({child, tp[1] + 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint count = 0;\\n\\t\\tint curr = end1;\\n\\t\\tvector<int> ans;\\n\\n\\t\\twhile (curr != -1 && ans.size() < depth % 2 + 1) {\\n\\t\\t\\tif (count == depth / 2 || count == (depth + 1) / 2) {\\n\\t\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t}\\n\\t\\t\\tcurr = par[curr];\\n\\t\\t\\tcount++;\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926551,
                "title": "go-two-o-n-solutions",
                "content": "This problem focus on minimum height tree (MHT), so I start to think how MHT is formed.\\n\\n- How is tree height reduced?\\n\\n\\tIf any node is decided to be root, then height of a tree is also determined. My question becomes: how does height of a tree reduced?\\n\\n\\tTaking following tree as an example, height(1) = 3, longest path `1-4-6-7`\\n\\n\\t```\\n       1\\n      / \\\\\\n\\t 3   4\\n        / \\\\\\n       5   6\\n          /\\n         7\\n\\t```\\n\\n\\tIf choose 4 as root, height(4) = 2, longest path `4-6-7` or `4-1-3`.\\n\\n\\t```\\n         4\\n      / \\\\  \\\\\\n     5   6  1\\n        /    \\\\\\n       7      3\\n\\t```\\n\\n\\tThe reason height(4) < height(1) is because, moving node 1 away from longest path to other paths not longest, reduces tree height.\\n\\n- How many MHT for a given tree can have?\\n\\n\\tTo think of this problem, I start from simple examples:\\n\\n\\t```\\n  (1)   (2)    (3)\\n   1     1      1      1\\n        /      / \\\\  =>\\n       2      2   3\\n\\t```\\n\\n\\tcondition (1), no further reduction, node 1 forms MHT.\\n\\tcondition (2), no further reduction, node 1 & node 2 both form MHT.\\n\\tcondition (3) can be reduced to condition (1)\\n\\n\\tStart from basics, at most 2 nodes form MHT. Because every tree can be decomposed into sub-tree by removing all leaf nodes. Keep removing leaf nodes, all tree will eventually decomposed into condition (1) or (2).\\n\\n\\tWith above observations, there exists 2 ways of solving this problem, both time complexity O(n)\\n\\n- Solution 1 - topological sort\\n\\n\\tBecause MHT can be found by farthest node(s) to every leaf, so every time remove leaf nodes until remaining nodes <= 2.\\n\\n\\t```goalng\\n\\tfunc findMinHeightTrees(n int, edges [][]int) []int {\\n\\t\\tif n <= 1 {\\n\\t\\t\\tans := make([]int, 0)\\n\\t\\t\\tfor i := 0; i < n; i++ {\\n\\t\\t\\t\\tans = append(ans, i)\\n\\t\\t\\t}\\n\\t\\t\\treturn ans\\n\\t\\t}\\n\\n\\t\\tgraph := make(map[int][]int)\\n\\t\\tinDegree := make([]int, n)\\n\\n\\t\\tfor _, edge := range edges {\\n\\t\\t\\tif _, ok := graph[edge[0]]; !ok {\\n\\t\\t\\t\\tgraph[edge[0]] = make([]int, 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif _, ok := graph[edge[1]]; !ok {\\n\\t\\t\\t\\tgraph[edge[1]] = make([]int, 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\tgraph[edge[0]] = append(graph[edge[0]], edge[1])\\n\\t\\t\\tgraph[edge[1]] = append(graph[edge[1]], edge[0])\\n\\t\\t\\tinDegree[edge[0]]++\\n\\t\\t\\tinDegree[edge[1]]++\\n\\t\\t}\\n\\n\\t\\tqueue := make([]int, 0)\\n\\n\\t\\t// find leaf nodes\\n\\t\\tfor i, degree := range inDegree {\\n\\t\\t\\tif degree == 1 {\\n\\t\\t\\t\\tqueue = append(queue, i)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor n > 2 {\\n\\t\\t\\tsize := len(queue)\\n\\t\\t\\tn -= size\\n\\n\\t\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\t\\tinDegree[queue[i]]--\\n\\n\\t\\t\\t\\tfor _, to := range graph[queue[i]] {\\n\\t\\t\\t\\t\\tinDegree[to]--\\n\\n\\t\\t\\t\\t\\t// next round leaf node\\n\\t\\t\\t\\t\\tif inDegree[to] == 1 {\\n\\t\\t\\t\\t\\t\\tqueue = append(queue, to)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tqueue = queue[size:]\\n\\t\\t}\\n\\n\\t\\treturn queue\\n\\t}\\n\\t```\\n\\n- Solution 2 - longest path\\n\\n\\tMHT nodes must positioned on middle point(s) of overall tree longest path. And height of a tree can be changed by different root node, to find overall longest path, first select a random node x and find longest path ends at node y. Using this node y to find longest path ends at node z, MHT is middle points of path y - z.\\n\\n\\tThe reason y - z forms overall longest path is because, y must be positioned on one overall longest path (multiple paths could with same longest length). If for random node x, longest path for node x ends on node y\\', and node y\\' is not on overall longest path(s), which means longest path y\\' equals to y.\\n\\n\\t```golang\\n\\tfunc findMinHeightTrees(n int, edges [][]int) []int {\\n\\t\\tif n == 1 {\\n\\t\\t\\treturn []int{0}\\n\\t\\t}\\n\\n\\t\\tgraph := make(map[int][]int)\\n\\t\\tfor _, edge := range edges {\\n\\t\\t\\tif _, ok := graph[edge[0]]; !ok {\\n\\t\\t\\t\\tgraph[edge[0]] = make([]int, 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif _, ok := graph[edge[1]]; !ok {\\n\\t\\t\\t\\tgraph[edge[1]] = make([]int, 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\tgraph[edge[0]] = append(graph[edge[0]], edge[1])\\n\\t\\t\\tgraph[edge[1]] = append(graph[edge[1]], edge[0])\\n\\t\\t}\\n\\n\\t\\tlongest1 := make([]int, 0)\\n\\t\\tvisited1 := make([]bool, n)\\n\\t\\tdfs(0, graph, []int{0}, &longest1, visited1)\\n\\n\\t\\tlongest2 := make([]int, 0)\\n\\t\\tvisited2 := make([]bool, n)\\n\\t\\tdfs(longest1[len(longest1)-1], graph, []int{longest1[len(longest1)-1]}, &longest2, visited2)\\n\\n\\t\\treturn longest2[(len(longest2)-1)/2 : len(longest2)/2+1]\\n\\t}\\n\\n\\tfunc dfs(node int, graph map[int][]int, current []int, longest *[]int, visited []bool) {\\n\\t\\tif visited[node] {\\n\\t\\t\\tif len(current) > len(*longest) {\\n\\t\\t\\t\\t*longest = (*longest)[:0]\\n\\t\\t\\t\\t*longest = append(*longest, current[:len(current)-1]...)\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tvisited[node] = true\\n\\n\\t\\tfor _, to := range graph[node] {\\n\\t\\t\\ttmp := append([]int{}, current...)\\n\\t\\t\\ttmp = append(tmp, to)\\n\\t\\t\\tdfs(to, graph, tmp, longest, visited)\\n\\t\\t}\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n       1\\n      / \\\\\\n\\t 3   4\\n        / \\\\\\n       5   6\\n          /\\n         7\\n\\t```\n```\\n         4\\n      / \\\\  \\\\\\n     5   6  1\\n        /    \\\\\\n       7      3\\n\\t```\n```\\n  (1)   (2)    (3)\\n   1     1      1      1\\n        /      / \\\\  =>\\n       2      2   3\\n\\t```\n```goalng\\n\\tfunc findMinHeightTrees(n int, edges [][]int) []int {\\n\\t\\tif n <= 1 {\\n\\t\\t\\tans := make([]int, 0)\\n\\t\\t\\tfor i := 0; i < n; i++ {\\n\\t\\t\\t\\tans = append(ans, i)\\n\\t\\t\\t}\\n\\t\\t\\treturn ans\\n\\t\\t}\\n\\n\\t\\tgraph := make(map[int][]int)\\n\\t\\tinDegree := make([]int, n)\\n\\n\\t\\tfor _, edge := range edges {\\n\\t\\t\\tif _, ok := graph[edge[0]]; !ok {\\n\\t\\t\\t\\tgraph[edge[0]] = make([]int, 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif _, ok := graph[edge[1]]; !ok {\\n\\t\\t\\t\\tgraph[edge[1]] = make([]int, 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\tgraph[edge[0]] = append(graph[edge[0]], edge[1])\\n\\t\\t\\tgraph[edge[1]] = append(graph[edge[1]], edge[0])\\n\\t\\t\\tinDegree[edge[0]]++\\n\\t\\t\\tinDegree[edge[1]]++\\n\\t\\t}\\n\\n\\t\\tqueue := make([]int, 0)\\n\\n\\t\\t// find leaf nodes\\n\\t\\tfor i, degree := range inDegree {\\n\\t\\t\\tif degree == 1 {\\n\\t\\t\\t\\tqueue = append(queue, i)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor n > 2 {\\n\\t\\t\\tsize := len(queue)\\n\\t\\t\\tn -= size\\n\\n\\t\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\t\\tinDegree[queue[i]]--\\n\\n\\t\\t\\t\\tfor _, to := range graph[queue[i]] {\\n\\t\\t\\t\\t\\tinDegree[to]--\\n\\n\\t\\t\\t\\t\\t// next round leaf node\\n\\t\\t\\t\\t\\tif inDegree[to] == 1 {\\n\\t\\t\\t\\t\\t\\tqueue = append(queue, to)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tqueue = queue[size:]\\n\\t\\t}\\n\\n\\t\\treturn queue\\n\\t}\\n\\t```\n```golang\\n\\tfunc findMinHeightTrees(n int, edges [][]int) []int {\\n\\t\\tif n == 1 {\\n\\t\\t\\treturn []int{0}\\n\\t\\t}\\n\\n\\t\\tgraph := make(map[int][]int)\\n\\t\\tfor _, edge := range edges {\\n\\t\\t\\tif _, ok := graph[edge[0]]; !ok {\\n\\t\\t\\t\\tgraph[edge[0]] = make([]int, 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif _, ok := graph[edge[1]]; !ok {\\n\\t\\t\\t\\tgraph[edge[1]] = make([]int, 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\tgraph[edge[0]] = append(graph[edge[0]], edge[1])\\n\\t\\t\\tgraph[edge[1]] = append(graph[edge[1]], edge[0])\\n\\t\\t}\\n\\n\\t\\tlongest1 := make([]int, 0)\\n\\t\\tvisited1 := make([]bool, n)\\n\\t\\tdfs(0, graph, []int{0}, &longest1, visited1)\\n\\n\\t\\tlongest2 := make([]int, 0)\\n\\t\\tvisited2 := make([]bool, n)\\n\\t\\tdfs(longest1[len(longest1)-1], graph, []int{longest1[len(longest1)-1]}, &longest2, visited2)\\n\\n\\t\\treturn longest2[(len(longest2)-1)/2 : len(longest2)/2+1]\\n\\t}\\n\\n\\tfunc dfs(node int, graph map[int][]int, current []int, longest *[]int, visited []bool) {\\n\\t\\tif visited[node] {\\n\\t\\t\\tif len(current) > len(*longest) {\\n\\t\\t\\t\\t*longest = (*longest)[:0]\\n\\t\\t\\t\\t*longest = append(*longest, current[:len(current)-1]...)\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tvisited[node] = true\\n\\n\\t\\tfor _, to := range graph[node] {\\n\\t\\t\\ttmp := append([]int{}, current...)\\n\\t\\t\\ttmp = append(tmp, to)\\n\\t\\t\\tdfs(to, graph, tmp, longest, visited)\\n\\t\\t}\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 923862,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/faaee155-befd-4dad-96e5-9e7113ef9de9_1604549341.390088.png)\\n\\nInspired by- https://leetcode.com/problems/minimum-height-trees/discuss/76055/Share-some-thoughts\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n      //Let\\'s take siimple example, if it is single linkedy linked list, if we have to find min hight tree,\\n        //It will be the middle of the list.\\n        //Same concept is applied here. Start from all the leaf node, and traverse inside until 1 or 2 nodes are \\n        //left. Those nodes will be minimum height tree root nodes.\\n        //Refer snapshot.\\n \\n\\n        //In the case of graph, we need to hold the adjacent nodes. E.g. garph [[1,2],[1,3]]\\n        //Adj list will be like below, Lets take the vector<HashSet<int>> to hold this\\n        //It\\'s undirected graph, the adj should be added for both the node of the edge\\n        //1->(2,3)\\n        //2->(1)\\n        //3->(1)\\n        \\n        \\n        //edge case if there is single node then node with value 0 will be the output\\n        if(n==1)\\n        {\\n            return vector<int>(1,0);\\n        }\\n        \\n        vector<unordered_set<int>> adj(n);\\n        for(vector<int> ed:edges)\\n        {\\n            adj[ed[0]].insert(ed[1]);\\n            adj[ed[1]].insert(ed[0]);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0; i<adj.size(); ++i)\\n        {            \\n            if(adj[i].size()==1)//if set size is 1.\\n                q.push(i);\\n        }\\n        //start BFS with these leaf nodes.      \\n        \\n        //Run the loop until there is only two nodes left\\n        while(n>2)\\n        {\\n            int len = q.size();\\n            n=n-len;\\n            for(int i=0; i<len; ++i)\\n            {\\n                int node = q.front(); q.pop();\\n                unordered_set<int> &ad=adj[node];                 \\n                //Actually we need to the current leaf node from each node in the adj list.\\n                //In the above example for leaf node 2. THe adj list is (1). So, fetch adj list of node 1\\n                //And remove 2 from there.\\n                for(auto a:ad)\\n                {\\n                    unordered_set<int> &adOfAdjNode=adj[a]; \\n                    adOfAdjNode.erase(node);\\n                    if(adOfAdjNode.size()==1)//for new leaf node, add it in the queue\\n                        q.push(a);\\n                }\\n            }\\n        }\\n        \\n        //Now we need to get the values from queue and add it in the output\\n        vector<int> out;\\n        while(!q.empty())\\n        {\\n            out.push_back(q.front()); q.pop();\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n      //Let\\'s take siimple example, if it is single linkedy linked list, if we have to find min hight tree,\\n        //It will be the middle of the list.\\n        //Same concept is applied here. Start from all the leaf node, and traverse inside until 1 or 2 nodes are \\n        //left. Those nodes will be minimum height tree root nodes.\\n        //Refer snapshot.\\n \\n\\n        //In the case of graph, we need to hold the adjacent nodes. E.g. garph [[1,2],[1,3]]\\n        //Adj list will be like below, Lets take the vector<HashSet<int>> to hold this\\n        //It\\'s undirected graph, the adj should be added for both the node of the edge\\n        //1->(2,3)\\n        //2->(1)\\n        //3->(1)\\n        \\n        \\n        //edge case if there is single node then node with value 0 will be the output\\n        if(n==1)\\n        {\\n            return vector<int>(1,0);\\n        }\\n        \\n        vector<unordered_set<int>> adj(n);\\n        for(vector<int> ed:edges)\\n        {\\n            adj[ed[0]].insert(ed[1]);\\n            adj[ed[1]].insert(ed[0]);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0; i<adj.size(); ++i)\\n        {            \\n            if(adj[i].size()==1)//if set size is 1.\\n                q.push(i);\\n        }\\n        //start BFS with these leaf nodes.      \\n        \\n        //Run the loop until there is only two nodes left\\n        while(n>2)\\n        {\\n            int len = q.size();\\n            n=n-len;\\n            for(int i=0; i<len; ++i)\\n            {\\n                int node = q.front(); q.pop();\\n                unordered_set<int> &ad=adj[node];                 \\n                //Actually we need to the current leaf node from each node in the adj list.\\n                //In the above example for leaf node 2. THe adj list is (1). So, fetch adj list of node 1\\n                //And remove 2 from there.\\n                for(auto a:ad)\\n                {\\n                    unordered_set<int> &adOfAdjNode=adj[a]; \\n                    adOfAdjNode.erase(node);\\n                    if(adOfAdjNode.size()==1)//for new leaf node, add it in the queue\\n                        q.push(a);\\n                }\\n            }\\n        }\\n        \\n        //Now we need to get the values from queue and add it in the output\\n        vector<int> out;\\n        while(!q.empty())\\n        {\\n            out.push_back(q.front()); q.pop();\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923520,
                "title": "c-topological-sort-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> res;\\n        vector<int> degree(n, 0);\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        if(n <= 0) return {};\\n        if(n == 1) return {0};\\n        \\n        for(auto e:edges) {\\n            degree[e[0]]++;\\n            degree[e[1]]++;\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<degree.size();i++) {\\n            if(degree[i] == 1) q.push(i);\\n        }\\n        \\n        while(n>2) {\\n            int size = q.size();\\n            n -= size;\\n            while(size--) {\\n                int v = q.front();\\n                q.pop();\\n                for(auto x:adj[v]) {\\n                    degree[x]--;\\n                    if(degree[x] == 1) {\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n        }\\n        while(!q.empty()) {\\n            res.push_back(q.front());\\n            q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> res;\\n        vector<int> degree(n, 0);\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        if(n <= 0) return {};\\n        if(n == 1) return {0};\\n        \\n        for(auto e:edges) {\\n            degree[e[0]]++;\\n            degree[e[1]]++;\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<degree.size();i++) {\\n            if(degree[i] == 1) q.push(i);\\n        }\\n        \\n        while(n>2) {\\n            int size = q.size();\\n            n -= size;\\n            while(size--) {\\n                int v = q.front();\\n                q.pop();\\n                for(auto x:adj[v]) {\\n                    degree[x]--;\\n                    if(degree[x] == 1) {\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n        }\\n        while(!q.empty()) {\\n            res.push_back(q.front());\\n            q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923489,
                "title": "c-bfs",
                "content": "```\\nclass Solution { // BFS\\npublic://Time/Space: O(N); O(N)\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n < 2) return {0};\\n        vector<vector<int>> g(n);\\n        vector<int> indegrees(n, 0);\\n        for(const auto& e: edges){\\n            g[e[0]].emplace_back(e[1]);\\n            g[e[1]].emplace_back(e[0]);\\n            indegrees[e[0]]++;\\n            indegrees[e[1]]++;\\n        }        \\n     \\n        vector<int> q, level;\\n        for(int i = 0; i < n; i++)\\n            if(indegrees[i] == 1) q.emplace_back(i);\\n        for(int step = 0; !q.empty(); ++step){            \\n            for(int sz = q.size(); sz > 0; sz--){                \\n                auto cur = q[sz - 1];\\n                for(const auto& next: g[cur])\\n                    if(--indegrees[next] == 1)\\n                        level.emplace_back(next);\\n            }            \\n            if(level.empty()) break;\\n            swap(q, level);level.clear();\\n        }\\n        return q;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { // BFS\\npublic://Time/Space: O(N); O(N)\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n < 2) return {0};\\n        vector<vector<int>> g(n);\\n        vector<int> indegrees(n, 0);\\n        for(const auto& e: edges){\\n            g[e[0]].emplace_back(e[1]);\\n            g[e[1]].emplace_back(e[0]);\\n            indegrees[e[0]]++;\\n            indegrees[e[1]]++;\\n        }        \\n     \\n        vector<int> q, level;\\n        for(int i = 0; i < n; i++)\\n            if(indegrees[i] == 1) q.emplace_back(i);\\n        for(int step = 0; !q.empty(); ++step){            \\n            for(int sz = q.size(); sz > 0; sz--){                \\n                auto cur = q[sz - 1];\\n                for(const auto& next: g[cur])\\n                    if(--indegrees[next] == 1)\\n                        level.emplace_back(next);\\n            }            \\n            if(level.empty()) break;\\n            swap(q, level);level.clear();\\n        }\\n        return q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804374,
                "title": "c-using-next-and-prev-state",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)return vector<int>{0};\\n        vector<int> adj[n];\\n        vector<int> deg(n,0);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            \\n            deg[it[0]]++;\\n            deg[it[1]]++;\\n        }\\n        vector<int> prev,next;\\n        for(int i=0;i<n;i++)\\n            if(deg[i]==1){\\n                prev.push_back(i);\\n            }\\n        while(true){\\n            next.clear();\\n            for(int i=0;i<prev.size();i++){\\n                int t=prev[i];\\n                for(auto it:adj[t]){\\n                    deg[it]--;\\n                    if(deg[it]==1)\\n                        next.push_back(it);\\n                }\\n            }\\n            if(next.size()==0)return prev;\\n            prev=next;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)return vector<int>{0};\\n        vector<int> adj[n];\\n        vector<int> deg(n,0);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            \\n            deg[it[0]]++;\\n            deg[it[1]]++;\\n        }\\n        vector<int> prev,next;\\n        for(int i=0;i<n;i++)\\n            if(deg[i]==1){\\n                prev.push_back(i);\\n            }\\n        while(true){\\n            next.clear();\\n            for(int i=0;i<prev.size();i++){\\n                int t=prev[i];\\n                for(auto it:adj[t]){\\n                    deg[it]--;\\n                    if(deg[it]==1)\\n                        next.push_back(it);\\n                }\\n            }\\n            if(next.size()==0)return prev;\\n            prev=next;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748160,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(!n)\\n            return {};\\n        if(n == 1)\\n            return {0};\\n        \\n        vector<vector<int>> map(n);\\n        vector<int> degrees(n), heights(n);\\n        for(auto &e : edges)\\n        {\\n            map[e[0]].push_back(e[1]);\\n            map[e[1]].push_back(e[0]);\\n            degrees[e[0]]++;\\n            degrees[e[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(degrees[i] == 1)\\n                q.push(i);\\n        }\\n        \\n        int max_height = 0;\\n        while(q.size())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            max_height = max(max_height, heights[node]);\\n            for(auto adjnode : map[node])\\n            {\\n                degrees[adjnode]--;\\n                if(degrees[adjnode] == 1)\\n                {\\n                    heights[adjnode] = max(heights[adjnode], heights[node]+1);\\n                    q.push(adjnode);\\n                }\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for(int i = 0; i < n; ++i)\\n            if(heights[i] == max_height)\\n                res.push_back(i);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(!n)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 680767,
                "title": "bfs-java-solution-21ms",
                "content": "\\n\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (edges.length == 0 && n == 1) return new ArrayList<>(List.of(0));\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>(); \\n        Queue<Integer> queue = new LinkedList<>();\\n            \\n        for (int[] edge : edges) {\\n            int x = edge[0];\\n            int y = edge[1];\\n            \\n            if (!map.containsKey(x)) {\\n                map.put(x, new ArrayList<>());\\n            }\\n            map.get(x).add(y);\\n            \\n            if (!map.containsKey(y)) {\\n                map.put(y, new ArrayList<>());\\n            }\\n            map.get(y).add(x);\\n        }\\n        \\n        if (map.size() < n-1) return new ArrayList<>();\\n        \\n        \\n        for (int i : map.keySet()) {\\n            if (map.get(i).size() == 1) {\\n                queue.add(i);\\n            }\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            if (map.size() < 3) return new ArrayList<>(map.keySet());\\n            int size = queue.size();\\n            while (size > 0) {\\n                int node = queue.poll();\\n\\n                List<Integer> adjList = map.get(node);\\n                for (int adj : adjList) {\\n                    map.get(adj).remove(Integer.valueOf(node));\\n                    if (map.get(adj).size() == 1) {\\n                        queue.add(adj);\\n                    }\\n                   \\n                }\\n                map.remove(node);\\n                size--;\\n            }\\n        }\\n        \\n        return new ArrayList<>(queue);     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (edges.length == 0 && n == 1) return new ArrayList<>(List.of(0));\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>(); \\n        Queue<Integer> queue = new LinkedList<>();\\n            \\n        for (int[] edge : edges) {\\n            int x = edge[0];\\n            int y = edge[1];\\n            \\n            if (!map.containsKey(x)) {\\n                map.put(x, new ArrayList<>());\\n            }\\n            map.get(x).add(y);\\n            \\n            if (!map.containsKey(y)) {\\n                map.put(y, new ArrayList<>());\\n            }\\n            map.get(y).add(x);\\n        }\\n        \\n        if (map.size() < n-1) return new ArrayList<>();\\n        \\n        \\n        for (int i : map.keySet()) {\\n            if (map.get(i).size() == 1) {\\n                queue.add(i);\\n            }\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            if (map.size() < 3) return new ArrayList<>(map.keySet());\\n            int size = queue.size();\\n            while (size > 0) {\\n                int node = queue.poll();\\n\\n                List<Integer> adjList = map.get(node);\\n                for (int adj : adjList) {\\n                    map.get(adj).remove(Integer.valueOf(node));\\n                    if (map.get(adj).size() == 1) {\\n                        queue.add(adj);\\n                    }\\n                   \\n                }\\n                map.remove(node);\\n                size--;\\n            }\\n        }\\n        \\n        return new ArrayList<>(queue);     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616245,
                "title": "intuitive-javascript-solution-with-leaves-deletion",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[]}\\n */\\nvar findMinHeightTrees = function(n, edges) {\\n  if (edges.length === 0) {\\n    return [0];\\n  }\\n  \\n  const graph = makeAdjacencyList(n, edges);\\n  let m = n;\\n  let leaves = [];\\n  \\n  for (const [node, adj] of graph) {\\n    if (adj.size === 1) {\\n      leaves.push(node);\\n    }\\n  }\\n  \\n  while (m > 2) {\\n    m -= leaves.length;\\n    // The goal is to remove leaves from graph and find new leaves\\n    const newLeaves = [];\\n    \\n    for (const leaf of leaves) {\\n      const neighbor = graph.get(leaf).values().next().value;\\n      // a leaf only connects to one neighbor\\n      graph.get(neighbor).delete(leaf);\\n      // keep track of new leaves when if a node becomes a leaf after deletion\\n      if (graph.get(neighbor).size === 1) {\\n        newLeaves.push(neighbor);\\n      }\\n      graph.delete(leaf);\\n    }\\n    leaves = newLeaves;\\n  }\\n  return leaves;\\n};\\n\\nfunction makeAdjacencyList(n, edges) {\\n  const adjacencyList = new Map();\\n  \\n  for (let i = 0; i < n; i++) {\\n    adjacencyList.set(i, new Set());\\n  }\\n  for (const [v1, v2] of edges) {\\n    adjacencyList.get(v1).add(v2);\\n    adjacencyList.get(v2).add(v1);\\n  }\\n  return adjacencyList;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[]}\\n */\\nvar findMinHeightTrees = function(n, edges) {\\n  if (edges.length === 0) {\\n    return [0];\\n  }\\n  \\n  const graph = makeAdjacencyList(n, edges);\\n  let m = n;\\n  let leaves = [];\\n  \\n  for (const [node, adj] of graph) {\\n    if (adj.size === 1) {\\n      leaves.push(node);\\n    }\\n  }\\n  \\n  while (m > 2) {\\n    m -= leaves.length;\\n    // The goal is to remove leaves from graph and find new leaves\\n    const newLeaves = [];\\n    \\n    for (const leaf of leaves) {\\n      const neighbor = graph.get(leaf).values().next().value;\\n      // a leaf only connects to one neighbor\\n      graph.get(neighbor).delete(leaf);\\n      // keep track of new leaves when if a node becomes a leaf after deletion\\n      if (graph.get(neighbor).size === 1) {\\n        newLeaves.push(neighbor);\\n      }\\n      graph.delete(leaf);\\n    }\\n    leaves = newLeaves;\\n  }\\n  return leaves;\\n};\\n\\nfunction makeAdjacencyList(n, edges) {\\n  const adjacencyList = new Map();\\n  \\n  for (let i = 0; i < n; i++) {\\n    adjacencyList.set(i, new Set());\\n  }\\n  for (const [v1, v2] of edges) {\\n    adjacencyList.get(v1).add(v2);\\n    adjacencyList.get(v2).add(v1);\\n  }\\n  return adjacencyList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588485,
                "title": "simple-cpp-solution-with-detailed-explanation",
                "content": "```\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n == 1) return {0};\\n        \\n        vector<vector<int>> graph(n);\\n        vector<int> degrees(n, 0), res;\\n        int V = n;\\n        \\n        //Make the graph and also increment each node\\'s degrees simultaneously.\\n        for(auto edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            \\n            degrees[edge[0]]++;\\n            degrees[edge[1]]++;\\n        }\\n        \\n        /*Push all 1 degree nodes into Q. These 1 degree nodes will include the originating roots and the leaf nodes. \\n        Ex:         0\\n                    |\\n                    1\\n                   / \\\\\\n                  2   3\\n    The Q will have {0, 2, 3}. All these have 1 degree nodes. Make these degrees as -1, just so that they will not be included in the result vector.*/\\n        while(V > 2)\\n        {\\n            vector<int> Q;\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(degrees[i] == 1)\\n                {\\n                    Q.push_back(i);\\n                    degrees[i] = -1;\\n                    V--;\\n                }\\n            }\\n    \\n        /*Do BFS and iterate through neighbors of each node. The key here is to find the middle nodes of the graph. They are roots for MHTs.\\n            While iterating through the negihbors, decrement their in-degrees.\\n            If you consider above example, its basically moving one step closer towards middle node (1) from either ends.\\n            You have 0, 2, 3. You decrement its neighbor\\'s node(1) degree. You move one down from 0, one up from 2 and 3.\\n            Finally, in the end, the degrees which have 1 or 0 are your middle nodes of the graph and those are the roots for MHTs.\\n        */\\n            for(auto i : Q)\\n            {\\n                for(int neighbor : graph[i])\\n                    degrees[neighbor]--;\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(degrees[i] == 1 || degrees[i] == 0)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n == 1) return {0};\\n        \\n        vector<vector<int>> graph(n);\\n        vector<int> degrees(n, 0), res;\\n        int V = n;\\n        \\n        //Make the graph and also increment each node\\'s degrees simultaneously.\\n        for(auto edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            \\n            degrees[edge[0]]++;\\n            degrees[edge[1]]++;\\n        }\\n        \\n        /*Push all 1 degree nodes into Q. These 1 degree nodes will include the originating roots and the leaf nodes. \\n        Ex:         0\\n                    |\\n                    1\\n                   / \\\\\\n                  2   3\\n    The Q will have {0, 2, 3}. All these have 1 degree nodes. Make these degrees as -1, just so that they will not be included in the result vector.*/\\n        while(V > 2)\\n        {\\n            vector<int> Q;\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(degrees[i] == 1)\\n                {\\n                    Q.push_back(i);\\n                    degrees[i] = -1;\\n                    V--;\\n                }\\n            }\\n    \\n        /*Do BFS and iterate through neighbors of each node. The key here is to find the middle nodes of the graph. They are roots for MHTs.\\n            While iterating through the negihbors, decrement their in-degrees.\\n            If you consider above example, its basically moving one step closer towards middle node (1) from either ends.\\n            You have 0, 2, 3. You decrement its neighbor\\'s node(1) degree. You move one down from 0, one up from 2 and 3.\\n            Finally, in the end, the degrees which have 1 or 0 are your middle nodes of the graph and those are the roots for MHTs.\\n        */\\n            for(auto i : Q)\\n            {\\n                for(int neighbor : graph[i])\\n                    degrees[neighbor]--;\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(degrees[i] == 1 || degrees[i] == 0)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 529745,
                "title": "python-topological-sort-using-bfs",
                "content": "The idea is \\'delete leaves layer by layer, until we reach the root\\'.  Find all the leaves and delete them, after removing, some nodes will become new leaves.Eventually there will be 1 level of leaves,  that\\'s the results we need. \\n```python\\nclass Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\tif n == 1:\\n            return [0]\\n        graph = collections.defaultdict(list)\\n        queue = collections.deque()\\n        indegree = [0]*n\\n\\t\\t#undirected graph in adjacency list\\uFF0C and update the degree for each node,\\n\\t\\t#remember it\\'s undirected graph\\n        for pair in edges:\\n            graph[pair[0]].append(pair[1])\\n            graph[pair[1]].append(pair[0])\\n            indegree[pair[0]] +=1\\n            indegree[pair[1]] +=1\\n\\t\\t#the smallest degree is 1, which represent all these leaves\\n        for i in range(n):\\n            if indegree[i] == 1:\\n                queue.append(i)\\n        while queue:\\n            path = []\\n\\t\\t\\t#standard BFS using deque\\n            for _ in range(len(queue)):\\n                vertex = queue.popleft()\\n                path.append(vertex)\\n                for neigh in graph[vertex]:\\n                    indegree[neigh] -=1\\n                    if indegree[neigh] == 1:\\n                        queue.append(neigh)\\n        return path\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\tif n == 1:\\n            return [0]\\n        graph = collections.defaultdict(list)\\n        queue = collections.deque()\\n        indegree = [0]*n\\n\\t\\t#undirected graph in adjacency list\\uFF0C and update the degree for each node,\\n\\t\\t#remember it\\'s undirected graph\\n        for pair in edges:\\n            graph[pair[0]].append(pair[1])\\n            graph[pair[1]].append(pair[0])\\n            indegree[pair[0]] +=1\\n            indegree[pair[1]] +=1\\n\\t\\t#the smallest degree is 1, which represent all these leaves\\n        for i in range(n):\\n            if indegree[i] == 1:\\n                queue.append(i)\\n        while queue:\\n            path = []\\n\\t\\t\\t#standard BFS using deque\\n            for _ in range(len(queue)):\\n                vertex = queue.popleft()\\n                path.append(vertex)\\n                for neigh in graph[vertex]:\\n                    indegree[neigh] -=1\\n                    if indegree[neigh] == 1:\\n                        queue.append(neigh)\\n        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397464,
                "title": "java-topo-sort-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> res = new ArrayList<>();\\n        if(n == 0) {\\n            return res;\\n        }\\n        if(n == 1) {\\n            res.add(0);\\n            return res; \\n        }\\n        \\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] indegree = new int[n];\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        for(int[] edge : edges){\\n            if(!graph.containsKey(edge[0])){\\n                graph.put(edge[0], new ArrayList<Integer>());\\n            }\\n            graph.get(edge[0]).add(edge[1]);\\n            if(!graph.containsKey(edge[1])){\\n                graph.put(edge[1], new ArrayList<Integer>());\\n            }\\n            graph.get(edge[1]).add(edge[0]);\\n            indegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 1) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int len = q.size();\\n            res = new ArrayList<Integer>();\\n            \\n            for(int i = 0; i < len; i++){\\n                int curr = q.poll();\\n                res.add(curr);\\n                for(Integer x : graph.get(curr)){\\n                    indegree[x]--;\\n                    if(indegree[x] == 1){\\n                        q.add(x);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> res = new ArrayList<>();\\n        if(n == 0) {\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 365665,
                "title": "bfs",
                "content": "```java\\n /*\\n    *\\u5265\\u6D0B\\u8471\\u89E3\\u6CD5\\uFF1A\\u4ECE\\u5916\\u5C42\\u5411\\u91CC\\u5C42\\u8FDB\\u884CBFS\\u904D\\u5386\\n    *\\u5177\\u4F53\\u601D\\u8DEF\\uFF1A\\n    *\\u5C06\\u56FE\\u8F6C\\u5316\\u4E3A\\u90BB\\u63A5\\u8868\\u5B58\\u50A8\\u540E\\uFF0C\\u82E5\\u53EA\\u6709\\u4E00\\u6761\\u8FB9\\u7684\\u5219\\u4E3A\\u6700\\u5916\\u56F4\\u7684\\u5143\\u7D20\\uFF0C\\u5C06\\u5916\\u56F4\\u5143\\u7D20\\u5168\\u90E8\\u52A0\\u5165\\u961F\\u5217\\n    *\\u7136\\u540E\\u5728\\u961F\\u5217\\u5F39\\u51FA\\u65F6\\uFF0C\\u9700\\u8981\\u5C06\\u8FD9\\u4E2A\\u7ED3\\u70B9\\u5728\\u90BB\\u63A5\\u8868\\u4E2D\\u5220\\u9664\\uFF0C\\u5C42\\u5C42\\u5411\\u91CC\\uFF0C\\u6700\\u540E\\u53EA\\u5269\\u4E0B2\\u4E2A\\u5143\\u7D20\\u4EE5\\u5185\\u65F6\\uFF0C\\u5219\\u4E3A\\u6700\\u4E2D\\u5FC3\\u5143\\u7D20\\uFF0C\\u5373\\u4EE5\\u5B83\\u4EEC\\u4F5C\\u4E3A\\u6811\\u6839\\u4F1A\\u5F97\\u5230\\u6700\\u5C0F\\u9AD8\\u5EA6\\u6811\\n    */\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> res = new LinkedList<Integer>();\\n        if(n==1) {\\n            res.add(0);\\n            return res;\\n        }\\n        List[] graph = new LinkedList[n];\\n        for(int i=0;i<graph.length;i++){//\\u5206\\u914D\\u7A7A\\u95F4\\n            graph[i]=new LinkedList<Integer>();\\n        }\\n        \\n        for(int i=0;i<edges.length;i++){//\\u8F6C\\u5316\\u6210\\u90BB\\u63A5\\u8868\\u5B58\\u50A8\\u56FE\\n            graph[edges[i][0]].add(edges[i][1]);\\n            graph[edges[i][1]].add(edges[i][0]);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for(int i=0;i<graph.length;i++){\\n            if(graph[i].size()==1){\\n                queue.offer(i);\\n                visited[i]=true;\\n            }\\n        }\\n        \\n        while(n>2){\\n            int size=queue.size();\\n            n -= size;\\n            for(int i=0;i<size;i++){\\n                int curNode = queue.poll();\\n                List<Integer> nodeList = graph[curNode];\\n                for(int j=0;j<graph.length;j++){\\n                    if(visited[j]==true) continue;\\n                    else{\\n                        graph[j].remove((Integer)curNode);\\n                        if(graph[j].size()==1) {\\n                            queue.offer(j);\\n                            visited[j]=true;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            res.add(queue.poll());\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n /*\\n    *\\u5265\\u6D0B\\u8471\\u89E3\\u6CD5\\uFF1A\\u4ECE\\u5916\\u5C42\\u5411\\u91CC\\u5C42\\u8FDB\\u884CBFS\\u904D\\u5386\\n    *\\u5177\\u4F53\\u601D\\u8DEF\\uFF1A\\n    *\\u5C06\\u56FE\\u8F6C\\u5316\\u4E3A\\u90BB\\u63A5\\u8868\\u5B58\\u50A8\\u540E\\uFF0C\\u82E5\\u53EA\\u6709\\u4E00\\u6761\\u8FB9\\u7684\\u5219\\u4E3A\\u6700\\u5916\\u56F4\\u7684\\u5143\\u7D20\\uFF0C\\u5C06\\u5916\\u56F4\\u5143\\u7D20\\u5168\\u90E8\\u52A0\\u5165\\u961F\\u5217\\n    *\\u7136\\u540E\\u5728\\u961F\\u5217\\u5F39\\u51FA\\u65F6\\uFF0C\\u9700\\u8981\\u5C06\\u8FD9\\u4E2A\\u7ED3\\u70B9\\u5728\\u90BB\\u63A5\\u8868\\u4E2D\\u5220\\u9664\\uFF0C\\u5C42\\u5C42\\u5411\\u91CC\\uFF0C\\u6700\\u540E\\u53EA\\u5269\\u4E0B2\\u4E2A\\u5143\\u7D20\\u4EE5\\u5185\\u65F6\\uFF0C\\u5219\\u4E3A\\u6700\\u4E2D\\u5FC3\\u5143\\u7D20\\uFF0C\\u5373\\u4EE5\\u5B83\\u4EEC\\u4F5C\\u4E3A\\u6811\\u6839\\u4F1A\\u5F97\\u5230\\u6700\\u5C0F\\u9AD8\\u5EA6\\u6811\\n    */\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> res = new LinkedList<Integer>();\\n        if(n==1) {\\n            res.add(0);\\n            return res;\\n        }\\n        List[] graph = new LinkedList[n];\\n        for(int i=0;i<graph.length;i++){//\\u5206\\u914D\\u7A7A\\u95F4\\n            graph[i]=new LinkedList<Integer>();\\n        }\\n        \\n        for(int i=0;i<edges.length;i++){//\\u8F6C\\u5316\\u6210\\u90BB\\u63A5\\u8868\\u5B58\\u50A8\\u56FE\\n            graph[edges[i][0]].add(edges[i][1]);\\n            graph[edges[i][1]].add(edges[i][0]);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for(int i=0;i<graph.length;i++){\\n            if(graph[i].size()==1){\\n                queue.offer(i);\\n                visited[i]=true;\\n            }\\n        }\\n        \\n        while(n>2){\\n            int size=queue.size();\\n            n -= size;\\n            for(int i=0;i<size;i++){\\n                int curNode = queue.poll();\\n                List<Integer> nodeList = graph[curNode];\\n                for(int j=0;j<graph.length;j++){\\n                    if(visited[j]==true) continue;\\n                    else{\\n                        graph[j].remove((Integer)curNode);\\n                        if(graph[j].size()==1) {\\n                            queue.offer(j);\\n                            visited[j]=true;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            res.add(queue.poll());\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76060,
                "title": "swift-solution-bfs",
                "content": "```\\nclass Solution {\\n    func findMinHeightTrees(_ n: Int, _ edges: [[Int]]) -> [Int] {\\n        if n == 1 {\\n            return [0]\\n        }\\n        \\n        var adj = [Set<Int>](repeatElement(Set<Int>(), count: n))\\n        var leaves = [Int]()\\n        var count = n\\n        \\n        for edge in edges {\\n            adj[edge[0]].insert(edge[1])\\n            adj[edge[1]].insert(edge[0])\\n        }\\n        for i in 0..<n {\\n            if adj[i].count == 1 {\\n                leaves.append(i)\\n            }\\n        }\\n        while count > 2 {\\n            count -= leaves.count\\n            var newLeaves = [Int]()\\n            for leaf in leaves {\\n                let node = adj[leaf].first!\\n                adj[node].remove(leaf)\\n                if adj[node].count == 1 {\\n                    newLeaves.append(node)\\n                }\\n            }\\n            leaves = newLeaves\\n        }\\n        \\n        return leaves\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findMinHeightTrees(_ n: Int, _ edges: [[Int]]) -> [Int] {\\n        if n == 1 {\\n            return [0]\\n        }\\n        \\n        var adj = [Set<Int>](repeatElement(Set<Int>(), count: n))\\n        var leaves = [Int]()\\n        var count = n\\n        \\n        for edge in edges {\\n            adj[edge[0]].insert(edge[1])\\n            adj[edge[1]].insert(edge[0])\\n        }\\n        for i in 0..<n {\\n            if adj[i].count == 1 {\\n                leaves.append(i)\\n            }\\n        }\\n        while count > 2 {\\n            count -= leaves.count\\n            var newLeaves = [Int]()\\n            for leaf in leaves {\\n                let node = adj[leaf].first!\\n                adj[node].remove(leaf)\\n                if adj[node].count == 1 {\\n                    newLeaves.append(node)\\n                }\\n            }\\n            leaves = newLeaves\\n        }\\n        \\n        return leaves\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76063,
                "title": "compact-python-solution-using-two-bfs",
                "content": "    class Solution(object):\\n        def findMinHeightTrees(self, n, edges):\\n            graph = [[] for i in range(n)]\\n            for v1, v2 in edges:\\n                graph[v1].append(v2)\\n                graph[v2].append(v1)\\n            \\n            p1 = self.FindLongestPath(graph, 0)\\n            p2 = self.FindLongestPath(graph, p1[-1])\\n            \\n            if len(p2) % 2: return [p2[len(p2)/2]]\\n            else:           return [p2[len(p2)/2 - 1], p2[len(p2)/2]]\\n        \\n        def FindLongestPath(self, graph, root):\\n            queue = collections.deque([[root]])\\n            traversed = set([root])\\n            while queue:\\n                path = queue.pop()\\n                for v in graph[path[-1]]:\\n                    if v not in traversed:\\n                        queue.appendleft(path + [v])\\n                        traversed.add(v)\\n            return path",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def findMinHeightTrees(self, n, edges):\\n            graph = [[] for i in range(n)]\\n            for v1, v2 in edges:\\n                graph[v1].append(v2)\\n                graph[v2].append(v1)\\n            \\n            p1 = self.FindLongestPath(graph, 0)\\n            p2 = self.FindLongestPath(graph, p1[-1])\\n            \\n            if len(p2) % 2: return [p2[len(p2)/2]]\\n            else:           return [p2[len(p2)/2 - 1], p2[len(p2)/2]]\\n        \\n        def FindLongestPath(self, graph, root):\\n            queue = collections.deque([[root]])\\n            traversed = set([root])\\n            while queue:\\n                path = queue.pop()\\n                for v in graph[path[-1]]:\\n                    if v not in traversed:\\n                        queue.appendleft(path + [v])\\n                        traversed.add(v)\\n            return path",
                "codeTag": "Java"
            },
            {
                "id": 76139,
                "title": "solution-share-midpoint-of-longest-path",
                "content": "Algorithm:\\n\\n1. G = <V[1..n], E[1..n-1]>, G is connected;\\n1. Find a path P = V[p[1]], V[p[2]], ... V[p[l]] which is the longest path in G\\n1. The Midpoint of the path  V[p[floor(l/2)]], or, V[p[ceil(l/2)]] is the answer\\n\\n\\nImplementation:\\n\\n    class Solution(object):\\n        # longest path from node i\\n        def longestPath(self, n, e, i):\\n            a, b = set([i]), [[i, 0]]\\n            r = list(range(n))\\n            while len(b):\\n                t, d = b.pop(0)\\n                for j in e[t]:\\n                    if j in a: continue\\n                    b.append([j, d + 1])\\n                    a.add(j)\\n                    r[j] = t\\n            p = [t]\\n            while p[0] != i:\\n                p.insert(0, r[p[0]])\\n            return p\\n    \\n        def findMinHeightTrees(self, n, edges):\\n            e = [[] for i in range(n)]\\n            for x, y in edges:\\n                e[x].append(y)\\n                e[y].append(x)\\n            p = self.longestPath(n, e, 0)\\n            q = self.longestPath(n, e, p[-1])\\n            return list(sorted(q[(len(q)-1)//2:len(q)//2+1]))",
                "solutionTags": [],
                "code": "Algorithm:\\n\\n1. G = <V[1..n], E[1..n-1]>, G is connected;\\n1. Find a path P = V[p[1]], V[p[2]], ... V[p[l]] which is the longest path in G\\n1. The Midpoint of the path  V[p[floor(l/2)]], or, V[p[ceil(l/2)]] is the answer\\n\\n\\nImplementation:\\n\\n    class Solution(object):\\n        # longest path from node i\\n        def longestPath(self, n, e, i):\\n            a, b = set([i]), [[i, 0]]\\n            r = list(range(n))\\n            while len(b):\\n                t, d = b.pop(0)\\n                for j in e[t]:\\n                    if j in a: continue\\n                    b.append([j, d + 1])\\n                    a.add(j)\\n                    r[j] = t\\n            p = [t]\\n            while p[0] != i:\\n                p.insert(0, r[p[0]])\\n            return p\\n    \\n        def findMinHeightTrees(self, n, edges):\\n            e = [[] for i in range(n)]\\n            for x, y in edges:\\n                e[x].append(y)\\n                e[y].append(x)\\n            p = self.longestPath(n, e, 0)\\n            q = self.longestPath(n, e, p[-1])\\n            return list(sorted(q[(len(q)-1)//2:len(q)//2+1]))",
                "codeTag": "Java"
            },
            {
                "id": 3223102,
                "title": "simple-dfs",
                "content": "1->Make any node of the tree a root and try to visualise now \\n2->for every node what we have to keep track is the max height of its subtree and other thing is the distance from the top \\nexample \\n                                           1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t **2**  3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t5\\n\\tassuming 1 as root \\nso in this example for this 2 what we have to store is \\n->max height of its subtree is 2->4->5  is 3 and distance from top is 2 \\nfor this i have made two dfs functions dont have much time to explain try to understand on your own using copy pen this approach is worth understanding for sure\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    unordered_map<int,int>len;\\n    int dfs(int curr,vector<int>adj[],int par){\\n        int ans=0;\\n        int maxno=0;\\n        for(int i:adj[curr]){\\n            if(i==par){\\n                continue;\\n            }\\n            int first=dfs(i,adj,curr);\\n            maxno=max(maxno,first);\\n        }\\n        maxno++;\\n        mp[curr]=maxno;\\n        return maxno;\\n    }\\n    void dfs2(int node,vector<int>adj[],int par,int piche){\\n        int maxno=max(mp[node]-1,piche);\\n        len[node]=maxno;\\n        maxno=0;\\n        int minno=0;\\n        for(int i:adj[node]){\\n            if(i==par){\\n                continue;\\n            }\\n            int first=mp[i];\\n            if(first>maxno){\\n                minno=maxno;\\n                maxno=first;\\n            }\\n            else if(first>minno){\\n                minno=first;\\n            }\\n            \\n        }\\n        for(int i:adj[node]){\\n            if(i==par){\\n                continue;\\n            }\\n            int temp=mp[i];\\n            if(maxno==temp){\\n                \\n                int num=piche+1;\\n                num=max(num,minno+1);\\n                dfs2(i,adj,node,num);\\n            }\\n            else{\\n                int num=piche+1;\\n                num=max(num,maxno+1);\\n                dfs2(i,adj,node,num);\\n            }\\n        }\\n        return;\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //graph done \\n        dfs(0,adj,-1);\\n        dfs2(0,adj,-1,0);\\n        unordered_map<int,vector<int>>res;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            //cout<<len[i]<<endl;\\n            ans=min(ans,len[i]);\\n            res[len[i]].push_back(i);\\n        }\\n        return res[ans];\\n    }\\n};\\n```\\ntime complexity is 2*(V+E) running dfs function twice thats it",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    unordered_map<int,int>len;\\n    int dfs(int curr,vector<int>adj[],int par){\\n        int ans=0;\\n        int maxno=0;\\n        for(int i:adj[curr]){\\n            if(i==par){\\n                continue;\\n            }\\n            int first=dfs(i,adj,curr);\\n            maxno=max(maxno,first);\\n        }\\n        maxno++;\\n        mp[curr]=maxno;\\n        return maxno;\\n    }\\n    void dfs2(int node,vector<int>adj[],int par,int piche){\\n        int maxno=max(mp[node]-1,piche);\\n        len[node]=maxno;\\n        maxno=0;\\n        int minno=0;\\n        for(int i:adj[node]){\\n            if(i==par){\\n                continue;\\n            }\\n            int first=mp[i];\\n            if(first>maxno){\\n                minno=maxno;\\n                maxno=first;\\n            }\\n            else if(first>minno){\\n                minno=first;\\n            }\\n            \\n        }\\n        for(int i:adj[node]){\\n            if(i==par){\\n                continue;\\n            }\\n            int temp=mp[i];\\n            if(maxno==temp){\\n                \\n                int num=piche+1;\\n                num=max(num,minno+1);\\n                dfs2(i,adj,node,num);\\n            }\\n            else{\\n                int num=piche+1;\\n                num=max(num,maxno+1);\\n                dfs2(i,adj,node,num);\\n            }\\n        }\\n        return;\\n    }\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //graph done \\n        dfs(0,adj,-1);\\n        dfs2(0,adj,-1,0);\\n        unordered_map<int,vector<int>>res;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            //cout<<len[i]<<endl;\\n            ans=min(ans,len[i]);\\n            res[len[i]].push_back(i);\\n        }\\n        return res[ans];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3007457,
                "title": "mht",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nby finding the diameter of tree\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthere is only 1 or 2 mhts are possible.\\nfirst calculate the length of diametre of tree then find height of all the nodes from the one the nodes of a diametre and after that if length of diametre is odd two ans possible and that are height of node that is equal to length of diametre/2+1 orlength of diametre/2\\nelse if length of diametre is even only one answer is possible and that is height of node that is equal to length of diametre/2.\\nhope you found this approach useful.\\n\\n# Complexity\\n- Time complexity: O(N+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nQu$$$$*[[[[ote]()]()]()]()*$$$$\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int vertex,int par,vector<int> g[],vector<int>&h,vector<int> &depth){\\n        // depth[vertex]=0;\\n        for(auto &child:g[vertex]){\\n            \\n            if(child==par) continue;\\n            depth[child]=depth[vertex]+1;\\n            dfs(child,vertex,g,h,depth);\\n            h[vertex]=max(h[vertex],h[child]+1);\\n        }\\n    }\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> g[n];\\n        for(int i=0;i<edges.size();i++){\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> height(n,0);\\n        vector<int> depth(n,0);\\n       \\n        if(n<=2){\\n            for(int i=0;i<n;i++) ans.push_back(i);\\n            return ans;\\n        }\\n        dfs(0,-1,g,height,depth);\\n        vector<int> height2(n,0);\\n        int maxd=*max_element(depth.begin(),depth.end());\\n        for(int i=0;i<n;i++){\\n            if(depth[i]==maxd){\\n                dfs(i,-1,g,height2,depth);\\n                break;\\n            }\\n        }\\n        int x=*max_element(height2.begin(),height2.end());\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            \\n            if(x%2){\\n                if(height2[i]==x/2+1) ans.push_back(i);\\n                if(height2[i]==x/2) ans.push_back(i);\\n            }\\n            else {\\n               if(height2[i]==x/2) ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int vertex,int par,vector<int> g[],vector<int>&h,vector<int> &depth){\\n        // depth[vertex]=0;\\n        for(auto &child:g[vertex]){\\n            \\n            if(child==par) continue;\\n            depth[child]=depth[vertex]+1;\\n            dfs(child,vertex,g,h,depth);\\n            h[vertex]=max(h[vertex],h[child]+1);\\n        }\\n    }\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> g[n];\\n        for(int i=0;i<edges.size();i++){\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> height(n,0);\\n        vector<int> depth(n,0);\\n       \\n        if(n<=2){\\n            for(int i=0;i<n;i++) ans.push_back(i);\\n            return ans;\\n        }\\n        dfs(0,-1,g,height,depth);\\n        vector<int> height2(n,0);\\n        int maxd=*max_element(depth.begin(),depth.end());\\n        for(int i=0;i<n;i++){\\n            if(depth[i]==maxd){\\n                dfs(i,-1,g,height2,depth);\\n                break;\\n            }\\n        }\\n        int x=*max_element(height2.begin(),height2.end());\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            \\n            if(x%2){\\n                if(height2[i]==x/2+1) ans.push_back(i);\\n                if(height2[i]==x/2) ans.push_back(i);\\n            }\\n            else {\\n               if(height2[i]==x/2) ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165262,
                "title": "c-topological-sort-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)    //if there\\'s only 1 node ->return {0}\\n            return {0};\\n        \\n        vector <vector<int>> adj(n);        //to store neighbors of each node\\n        vector <int> in(n, 0);              //to store degrees of each node\\n        for(auto edge : edges){             //updating values in adj and in as we iterate through each edges\\n            int u = edge[0], v = edge[1];  \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            in[u]++;\\n            in[v]++;\\n        }\\n        \\n        queue <int> q;                      //to store the nodes which needs to be excluded in order to reach the middle nodes\\n        for(int i=0; i<n; i++)\\n            if(in[i]==1)\\n                q.push(i);\\n        \\n        vector <int> res;                   //to store the final result\\n        while(!q.empty())\\n        {\\n            res.clear();            //clearing before we start traversing level by level.\\n            int size=q.size();\\n            while(size--)           //doing for each inserted nodes\\n            {\\n                int cur=q.front();\\n                q.pop();\\n                res.push_back(cur); //adding nodes to vector (it may or may not be the final solution)\\n                for(auto &neigh :adj[cur])\\n                {\\n                    in[neigh]--;            //removing current leave nodes\\n                    if(in[neigh]==1)        //adding current leave nodes\\n                        q.push(neigh);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**If Helpful PLease Like Or Upvoke**",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1)    //if there\\'s only 1 node ->return {0}\\n            return {0};\\n        \\n        vector <vector<int>> adj(n);        //to store neighbors of each node\\n        vector <int> in(n, 0);              //to store degrees of each node\\n        for(auto edge : edges){             //updating values in adj and in as we iterate through each edges\\n            int u = edge[0], v = edge[1];  \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            in[u]++;\\n            in[v]++;\\n        }\\n        \\n        queue <int> q;                      //to store the nodes which needs to be excluded in order to reach the middle nodes\\n        for(int i=0; i<n; i++)\\n            if(in[i]==1)\\n                q.push(i);\\n        \\n        vector <int> res;                   //to store the final result\\n        while(!q.empty())\\n        {\\n            res.clear();            //clearing before we start traversing level by level.\\n            int size=q.size();\\n            while(size--)           //doing for each inserted nodes\\n            {\\n                int cur=q.front();\\n                q.pop();\\n                res.push_back(cur); //adding nodes to vector (it may or may not be the final solution)\\n                for(auto &neigh :adj[cur])\\n                {\\n                    in[neigh]--;            //removing current leave nodes\\n                    if(in[neigh]==1)        //adding current leave nodes\\n                        q.push(neigh);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056284,
                "title": "python-o-n-time-space-commented-code-for-easy-understanding",
                "content": "```\\ndef findMinHeightTrees(self, n, edges):\\n    \"\"\"\\n    :type n: int\\n    :type edges: List[List[int]]\\n    :rtype: List[int]\\n    \"\"\"\\n    if n == 1: return [0]\\n\\t#create graph\\n    adj = [set() for _ in xrange(n)]\\n    for i, j in edges:\\n        adj[i].add(j)\\n        adj[j].add(i)\\n    #find leaves - these are only connected to one other node (this will help us find min height)\\n    leaves = [i for i in xrange(n) if len(adj[i]) == 1]\\n    #we then want to remove the leaves from the graph iteratively until we reach the node\\n    while n > 2:\\n        #minus the leaves from the total nodes\\n        n -= len(leaves)\\n        #newLeaves are the leaves for the next iteration\\n        newLeaves = []\\n        #go through each current leaf\\n        for i in leaves:\\n            #remove leaf from the graph\\n            j = adj[i].pop()\\n            #remove the connection of the leaf to the node its connected to\\n            adj[j].remove(i)\\n            #check whether this node is now a leaf node and if it is, append it to newLeaves\\n            if len(adj[j]) == 1: newLeaves.append(j)\\n        #update the new leafs in the graph\\n        leaves = newLeaves\\n    #return the remaining leaf node which is the node to make the min height of the tree\\n    return leaves\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef findMinHeightTrees(self, n, edges):\\n    \"\"\"\\n    :type n: int\\n    :type edges: List[List[int]]\\n    :rtype: List[int]\\n    \"\"\"\\n    if n == 1: return [0]\\n\\t#create graph\\n    adj = [set() for _ in xrange(n)]\\n    for i, j in edges:\\n        adj[i].add(j)\\n        adj[j].add(i)\\n    #find leaves - these are only connected to one other node (this will help us find min height)\\n    leaves = [i for i in xrange(n) if len(adj[i]) == 1]\\n    #we then want to remove the leaves from the graph iteratively until we reach the node\\n    while n > 2:\\n        #minus the leaves from the total nodes\\n        n -= len(leaves)\\n        #newLeaves are the leaves for the next iteration\\n        newLeaves = []\\n        #go through each current leaf\\n        for i in leaves:\\n            #remove leaf from the graph\\n            j = adj[i].pop()\\n            #remove the connection of the leaf to the node its connected to\\n            adj[j].remove(i)\\n            #check whether this node is now a leaf node and if it is, append it to newLeaves\\n            if len(adj[j]) == 1: newLeaves.append(j)\\n        #update the new leafs in the graph\\n        leaves = newLeaves\\n    #return the remaining leaf node which is the node to make the min height of the tree\\n    return leaves\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1631275,
                "title": "java-4ms-100-next-fastest-7ms-topological-sort-no-lists-or-sets-explanation",
                "content": "**Topological Sort sped up:** ` ` The code below uses the Topological Sort approach from the \"Solution\" tab for this leetcode problem, which has an excellent detailed explanation in the \"Solution\" tab.  The example code from the \"Solution\" tab uses multiple ArrayLists and Sets.  My code below is the same basic algorithm, but using `int[]` arrays, which can be faster for execution time.  ArrayLists are useful when the number of items is unknown, and Sets are useful when a large amount of information must be quickly searched.  But when the number of items is known, or the number of items to search is small, then `int[]` arrays can be faster than the overhead of the more complex ArrayList and Set data structures.  Also, in Java, arrays of primitive types such as `int` or `boolean` are faster and less memory than their object types of `Integer` or `Boolean`.\\n\\nIn the example code in the \"Solution\" tab for this leetcode problem, the collection of the graph\\'s adjacent neighbors for each node are built as\\n` ` ` ` ` ` ` `  `ArrayList<Set<Integer>> neighbors`\\nwhere the `ArrayList` is indexed by node number, and each `Set` is a collection of that node\\'s adjacent neighbor\\'s node numbers.  But the `ArrayList` could have been easily be replaced by the faster array `Set<Integer>[]` because the number of nodes is known as the passed value `n`.  Also, the maximum number of adjacent neighbors for any node for any test-case in this leetcode problem happens to currently be 19, and most test-cases have a much lower maximum number of adjacent neighbor nodes.  The `Set` can be replaced by an `int[]` array after calculating the maximum number of adjcent neighbors for the passed set of `edges`.  The overhead of calculating the maximum number of adjacent neighbors and the overhead of searching a short `int[]` array, is less than the overhead of the more complex `Set` data structures for this leetcode problem.  Therefore, my code below uses\\n` ` ` ` ` ` ` `  `int[][] adjacentList = new int[n][maxEdges]`\\nto contain the adjacent node numbers for each node of the graph, with the help of another `int[]` array to contain the number of adjacent nodes, and a \\'boolean[]\\' to indicate which nodes have been \"removed\" from the graph.\\n\\nThe \"Solution\" tab\\'s example code also uses multiple ArrayLists as a collection of successive layers of leaf nodes to to be removed from the graph.  But the maximum number of leaf nodes is less than the passed value `n`, and each successive layer of leaf nodes has the same or fewer leaf nodes as the previously removed layer of leaf nodes.  So the code below uses a single `int[] leafs` to replace the multiple ArrayLists of the \"Solution\" tab\\'s example code.  The `int[]` contains the leaves that are being removed, and also is overwritten by the node numbers of nodes that become leaves, but these two arrays of node numbers within the single `int[]` will never overwrite each other because removing a leaf node will convert at most one one other node to become a leaf node.\\n\\n**Execution time:** ` ` The code below can run as fast as 4ms for the test cases as of December 2021.  When the leetcode servers are not very busy, this code usually runs in 5ms, but will run in 4ms for about 1/5th of the Submits.  When the leetcode servers are busy, this same code has run in as much as 15ms.  Leetcode execution times are not consistent between different Submits.\\n\\n**Faster version:** ` ` A version of the code below, with a hard-coded number for the maximum number of edges for any node, will usually run in 4ms when the leetcode servers are not very busy.  The hard-coded constant will fail if new test cases are added with higher number of adjacent neighbors for some node.  This version with the hard-coded value is shown after the real code below.  I will consider the hard-coded maximum number of edges as a real type of solution ONLY when programming requirements absolutely require the extra speed.  These requirements for timing speed are more likely to occur in real-time or embedded programming, and are often caused by hardware timing or by fast user response requirements.  Otherwise, the code below with the dynamically determined maximum number of edges for any node for each test case, is the better solution with better coding practices.\\n\\n**If this is useful, please upvote.**\\n```\\n// Leetcode problem #310 -- Minimum Height Trees\\n// This code uses the Topological Sorting approach that is described in detail in \\n// the Solution tab for this leetcode problem.  The general idea is use the graph \\n// of nodes and edges passed into this code, then remove layer after layer of edge \\n// nodes until only 1 or 2 nodes remain,  The remaining 1 or 2 nodes will be the \\n// root nodes of the minumum height trees.\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // If only 1 or 2 nodes, then each node is a possible Minimum \\n        // Height Tree root.\\n        if (n < 2) \\n            return Arrays.asList((n == 1) ? \\n                                (new Integer[]{0}) :\\n                                (new Integer[]{0,1}));\\n        \\n        // For each node, build an array of adjacent nodes it is connected to.\\n        // Find the maximum number of connections for any node, then allocate \\n        // the 2-D array adjacentList[][] to be indexed by node number to result \\n        // in a 1-D array of adjacent node numbers.\\n        // adjacentCount[node] --   The number of adjacent nodes to node \\'node\\'.\\n        // adjacentRemaining[node]--The number of adjacent nodes remaining \\n        //                          connected to node \\'node\\', after some of the \\n        //                          leaf nodes have been removed.\\n        // nodeRemoved[node] --     Boolean indicating if node \\'node\\' has been \\n        //                          removed from the graph/tree.\\n        // adjacentList[node][0..adjacentCount[node]] --\\n        //                          Lists the adjacent node numbers for node \\n        //                          \\'node\\'.  The adjacent nodes are a group of \\n        //                          node numbers indexed by the second index of \\n        //                          this array, and the count of numbers in that \\n        //                          group is: adjacentCount[node].\\n        int[] adjacentCount = new int[n];\\n        for (int[] edge : edges) {          // Loop to count edges for each node.\\n            adjacentCount[edge[0]]++;\\n            adjacentCount[edge[1]]++;\\n        }\\n        int maxEdges = 0;\\n        for (int i = n - 1; i >= 0; i--)     // Loop to find max number of edges \\n            if (adjacentCount[i] > maxEdges) //     for any node.\\n                maxEdges = adjacentCount[i];\\n        int[] adjacentRemaining = new int[n];\\n        int[][] adjacentList = new int[n][maxEdges];\\n        for (int[] edge : edges) {          // Fill-in 2-D array of adjacent node nums.\\n            adjacentList[edge[0]][adjacentRemaining[edge[0]]++] = edge[1];\\n            adjacentList[edge[1]][adjacentRemaining[edge[1]]++] = edge[0];\\n        }\\n        \\n        // Collect the original leaf nodes into an array.  We will later \\n        // multiply re-use this array to build the next inward layer of \\n        // leaves that were created as we remove the outer layer of leaves.  \\n        // We can re-use this array by starting at the beginning of the \\n        // array and filling in any node that became a leaf when an outer \\n        // layer leaf was removed.  We can do this because the next inward \\n        // layer of leaves can only have at most one leaf created by the \\n        // removal of a single outer layer leaf, so that the next inward \\n        // layer of leaves will have at most the same number of leaves as \\n        // the outer layer of leaves had.  The next inward leaf numbers \\n        // that are being added to the array while outer layer leaves are \\n        // still being read from the array and being removed from the graph.  \\n        // The next inward leaves being created and written to the array, \\n        // will never overwrite the outer layer of leaf numbers that are \\n        // still being processed.\\n        int[] leafs = new int[n];\\n        int leafCount = 0;\\n        int nextLeafCount = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n            if (adjacentRemaining[i] == 1)\\n                leafs[nextLeafCount++] = i;\\n        \\n        // For all the leaves in the leafs array, remove those leaf nodes \\n        // and add next inward layer leaves that thereby become leaf nodes \\n        // into the leafs array, so those next inward layer of leaves can \\n        // be removed on the next pass through the leafs array.  Repeat \\n        // removing layers of leaf nodes until only one or two nodes are \\n        // remaining.  Those remaining nodes will be the root node(s) for the \\n        // minimum height tree.\\n        int nodesRemaining = n;\\n        boolean[] nodeRemoved = new boolean[n];\\n        // Loop until only the 1 or 2 root nodes remain in the graph.\\n        while (nodesRemaining > 2) {\\n            leafCount = nextLeafCount;\\n            nextLeafCount = 0;\\n            nodesRemaining -= leafCount;\\n            // Loop to remove each outer layer leaf node from the graph.\\n            // The outer layer leaf nude numbers are in the array leafs[].\\n            for (int leafIdx = 0; leafIdx < leafCount; leafIdx++) {\\n                int node = leafs[leafIdx];\\n                int adjacentNode = -1;\\n                // Find the single valid un-removed edge for this leaf node \\n                // from the array of edges that this node was adjacent to.\\n                for (int i = adjacentCount[node] - 1; i >= 0; i--) {\\n                    if (!nodeRemoved[adjacentList[node][i]]) {\\n                        adjacentNode = adjacentList[node][i];\\n                        break;\\n                    }\\n                }\\n                nodeRemoved[node] = true;\\n                // If the node that this leaf node was connected to, if that \\n                // adjacent node has itself become a leaf node by the removal \\n                // of this leaf node, then add the node that has just become a \\n                // leaf node, to the array of leaf nodes to be removed on the \\n                // next pass.\\n                if (--adjacentRemaining[adjacentNode] == 1)\\n                    leafs[nextLeafCount++] = adjacentNode;\\n            }\\n        }\\n        \\n        // The 1 or 2 nodes remaining in the leaf node list, are the root nodes \\n        // for the minimum height tree, after successive layers of leaf nodes \\n        // have been removed from the tree.\\n        return Arrays.asList((nextLeafCount == 1) ? \\n                                (new Integer[]{leafs[0]}) :\\n                                (new Integer[]{leafs[0], leafs[1]}));\\n    }\\n}\\n```\\n________________________________________________________________________\\n--------------------------------------------------------------------------\\n==========================\\n**Slightly Faster Version with Hard Coded Constant:** ` ` The code below is nearly the same as the code above, except the maximum number of adjacent nodes for any graph node, is hard-coded, which makes the submission execution time faster because the code does not have to search the graph to determine the maximum number of adjacent nodes.  This hard coded value is not as flexible for new future test cases that might exceed this hard coded value.  But if faster execution speed is a requirement of the software, then this is an approach that can get a little faster execution time.  In a work situation, some project requirements may necessitate poor programming practices so that some project requirement can be met.  This is especially true in real-time programming with absolute timing requirements, or embedded programming with minimal space requirements.\\n```\\n// Leetcode problem #310 -- Minimum Height Trees\\n// This code uses the Topological Sorting approach that is described in detail in \\n// the Solution tab for this leetcode problem.  The general idea is use the graph \\n// of nodes and edges passed into this code, then remove layer after layer of edge \\n// nodes until only 1 or 2 nodes remain,  The remaining 1 or 2 nodes will be the \\n// root nodes of the minumum height trees.\\nclass Solution {\\n    // Max number of nodes that any node can be connected to.  Another \\n    // version of this code determines this number dynamically for each \\n    // test case, but I wanted to see if this code would run faster with \\n    // this number hard-coded to it\\'s maximum value for all test cases \\n    // that were used as of December 2021.\\n    static final int MAX_ADJACENT = 20;\\n    \\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // If only 1 or 2 nodes, then each node is a possible Minimum \\n        // Height Tree root.\\n        if (n < 2) \\n            return Arrays.asList((n == 1) ? \\n                                (new Integer[]{0}) :\\n                                (new Integer[]{0,1}));\\n        \\n        // For each node, build an array of adjacent nodes it is connected to.\\n        // Find the maximum number of connections for any node, then allocate \\n        // the 2-D array adjacentList[][] to be indexed by node number to result \\n        // in a 1-D array of adjacent node numbers.\\n        // adjacentCount[node] --   The number of adjacent nodes to node \\'node\\'.\\n        // adjacentRemaining[node]--The number of adjacent nodes remaining \\n        //                          connected to node \\'node\\', after some of the \\n        //                          leaf nodes have been removed.\\n        // nodeRemoved[node] --     Boolean indicating if node \\'node\\' has been \\n        //                          removed from the graph/tree.\\n        // adjacentList[node][0..adjacentCount[node]] --\\n        //                          Lists the adjacent node numbers for node \\n        //                          \\'node\\'.  The adjacent nodes are a group of \\n        //                          node numbers indexed by the second index of \\n        //                          this array, and the count of numbers in that \\n        //                          group is: adjacentCount[node].\\n        int[] adjacentRemaining = new int[n];\\n        int[][] adjacentList = new int[n][MAX_ADJACENT];\\n        for (int[] edge : edges) {          // Fill-in 2-D array of adjacent node nums.\\n            adjacentList[edge[0]][adjacentRemaining[edge[0]]++] = edge[1];\\n            adjacentList[edge[1]][adjacentRemaining[edge[1]]++] = edge[0];\\n        }\\n        int[] adjacentCount = Arrays.copyOf(adjacentRemaining, n);\\n        \\n        // Collect the original leaf nodes into an array.  We will later \\n        // multiply re-use this array to build the next inward layer of \\n        // leaves that were created as we remove the outer layer of leaves.  \\n        // We can re-use this array by starting at the beginning of the \\n        // array and filling in any node that became a leaf when an outer \\n        // layer leaf was removed.  We can do this because the next inward \\n        // layer of leaves can only have at most one leaf created by the \\n        // removal of a single outer layer leaf, so that the next inward \\n        // layer of leaves will have at most the same number of leaves as \\n        // the outer layer of leaves had.  The next inward leaf numbers \\n        // that are being added to the array while outer layer leaves are \\n        // still being read from the array and being removed from the graph.  \\n        // The next inward leaves being created and written to the array, \\n        // will never overwrite the outer layer of leaf numbers that are \\n        // still being processed.\\n        int[] leafs = new int[n];\\n        int leafCount = 0;\\n        int nextLeafCount = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n            if (adjacentRemaining[i] == 1)\\n                leafs[nextLeafCount++] = i;\\n        \\n        // For all the leaves in the leafs array, remove those leaf nodes \\n        // and add next inward layer leaves that thereby become leaf nodes \\n        // into the leafs array, so those next inward layer of leaves can \\n        // be removed on the next pass through the leafs array.  Repeat \\n        // removing layers of leaf nodes until only one or two nodes are \\n        // remaining.  Those remaining nodes will be the root node(s) for the \\n        // minimum height tree.\\n        int nodesRemaining = n;\\n        boolean[] nodeRemoved = new boolean[n];\\n        // Loop until only the 1 or 2 root nodes remain in the graph.\\n        while (nodesRemaining > 2) {\\n            leafCount = nextLeafCount;\\n            nextLeafCount = 0;\\n            nodesRemaining -= leafCount;\\n            // Loop to remove each outer layer leaf node from the graph.\\n            // The outer layer leaf nude numbers are in the array leafs[].\\n            for (int leafIdx = 0; leafIdx < leafCount; leafIdx++) {\\n                int node = leafs[leafIdx];\\n                int adjacentNode = -1;\\n                // Find the single valid un-removed edge for this leaf node \\n                // from the array of edges that this node was adjacent to.\\n                for (int i = adjacentCount[node] - 1; i >= 0; i--) {\\n                    if (!nodeRemoved[adjacentList[node][i]]) {\\n                        adjacentNode = adjacentList[node][i];\\n                        break;\\n                    }\\n                }\\n                nodeRemoved[node] = true;\\n                // If the node that this leaf node was connected to, if that \\n                // adjacent node has itself become a leaf node by the removal \\n                // of this leaf node, then add the node that has just become a \\n                // leaf node, to the array of leaf nodes to be removed on the \\n                // next pass.\\n                if (--adjacentRemaining[adjacentNode] == 1)\\n                    leafs[nextLeafCount++] = adjacentNode;\\n            }\\n        }\\n        \\n        // The 1 or 2 nodes remaining in the leaf node list, are the root nodes \\n        // for the minimum height tree, after successive layers of leaf nodes \\n        // have been removed from the tree.\\n        return Arrays.asList((nextLeafCount == 1) ? \\n                                (new Integer[]{leafs[0]}) :\\n                                (new Integer[]{leafs[0], leafs[1]}));\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Leetcode problem #310 -- Minimum Height Trees\\n// This code uses the Topological Sorting approach that is described in detail in \\n// the Solution tab for this leetcode problem.  The general idea is use the graph \\n// of nodes and edges passed into this code, then remove layer after layer of edge \\n// nodes until only 1 or 2 nodes remain,  The remaining 1 or 2 nodes will be the \\n// root nodes of the minumum height trees.\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // If only 1 or 2 nodes, then each node is a possible Minimum \\n        // Height Tree root.\\n        if (n < 2) \\n            return Arrays.asList((n == 1) ? \\n                                (new Integer[]{0}) :\\n                                (new Integer[]{0,1}));\\n        \\n        // For each node, build an array of adjacent nodes it is connected to.\\n        // Find the maximum number of connections for any node, then allocate \\n        // the 2-D array adjacentList[][] to be indexed by node number to result \\n        // in a 1-D array of adjacent node numbers.\\n        // adjacentCount[node] --   The number of adjacent nodes to node \\'node\\'.\\n        // adjacentRemaining[node]--The number of adjacent nodes remaining \\n        //                          connected to node \\'node\\', after some of the \\n        //                          leaf nodes have been removed.\\n        // nodeRemoved[node] --     Boolean indicating if node \\'node\\' has been \\n        //                          removed from the graph/tree.\\n        // adjacentList[node][0..adjacentCount[node]] --\\n        //                          Lists the adjacent node numbers for node \\n        //                          \\'node\\'.  The adjacent nodes are a group of \\n        //                          node numbers indexed by the second index of \\n        //                          this array, and the count of numbers in that \\n        //                          group is: adjacentCount[node].\\n        int[] adjacentCount = new int[n];\\n        for (int[] edge : edges) {          // Loop to count edges for each node.\\n            adjacentCount[edge[0]]++;\\n            adjacentCount[edge[1]]++;\\n        }\\n        int maxEdges = 0;\\n        for (int i = n - 1; i >= 0; i--)     // Loop to find max number of edges \\n            if (adjacentCount[i] > maxEdges) //     for any node.\\n                maxEdges = adjacentCount[i];\\n        int[] adjacentRemaining = new int[n];\\n        int[][] adjacentList = new int[n][maxEdges];\\n        for (int[] edge : edges) {          // Fill-in 2-D array of adjacent node nums.\\n            adjacentList[edge[0]][adjacentRemaining[edge[0]]++] = edge[1];\\n            adjacentList[edge[1]][adjacentRemaining[edge[1]]++] = edge[0];\\n        }\\n        \\n        // Collect the original leaf nodes into an array.  We will later \\n        // multiply re-use this array to build the next inward layer of \\n        // leaves that were created as we remove the outer layer of leaves.  \\n        // We can re-use this array by starting at the beginning of the \\n        // array and filling in any node that became a leaf when an outer \\n        // layer leaf was removed.  We can do this because the next inward \\n        // layer of leaves can only have at most one leaf created by the \\n        // removal of a single outer layer leaf, so that the next inward \\n        // layer of leaves will have at most the same number of leaves as \\n        // the outer layer of leaves had.  The next inward leaf numbers \\n        // that are being added to the array while outer layer leaves are \\n        // still being read from the array and being removed from the graph.  \\n        // The next inward leaves being created and written to the array, \\n        // will never overwrite the outer layer of leaf numbers that are \\n        // still being processed.\\n        int[] leafs = new int[n];\\n        int leafCount = 0;\\n        int nextLeafCount = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n            if (adjacentRemaining[i] == 1)\\n                leafs[nextLeafCount++] = i;\\n        \\n        // For all the leaves in the leafs array, remove those leaf nodes \\n        // and add next inward layer leaves that thereby become leaf nodes \\n        // into the leafs array, so those next inward layer of leaves can \\n        // be removed on the next pass through the leafs array.  Repeat \\n        // removing layers of leaf nodes until only one or two nodes are \\n        // remaining.  Those remaining nodes will be the root node(s) for the \\n        // minimum height tree.\\n        int nodesRemaining = n;\\n        boolean[] nodeRemoved = new boolean[n];\\n        // Loop until only the 1 or 2 root nodes remain in the graph.\\n        while (nodesRemaining > 2) {\\n            leafCount = nextLeafCount;\\n            nextLeafCount = 0;\\n            nodesRemaining -= leafCount;\\n            // Loop to remove each outer layer leaf node from the graph.\\n            // The outer layer leaf nude numbers are in the array leafs[].\\n            for (int leafIdx = 0; leafIdx < leafCount; leafIdx++) {\\n                int node = leafs[leafIdx];\\n                int adjacentNode = -1;\\n                // Find the single valid un-removed edge for this leaf node \\n                // from the array of edges that this node was adjacent to.\\n                for (int i = adjacentCount[node] - 1; i >= 0; i--) {\\n                    if (!nodeRemoved[adjacentList[node][i]]) {\\n                        adjacentNode = adjacentList[node][i];\\n                        break;\\n                    }\\n                }\\n                nodeRemoved[node] = true;\\n                // If the node that this leaf node was connected to, if that \\n                // adjacent node has itself become a leaf node by the removal \\n                // of this leaf node, then add the node that has just become a \\n                // leaf node, to the array of leaf nodes to be removed on the \\n                // next pass.\\n                if (--adjacentRemaining[adjacentNode] == 1)\\n                    leafs[nextLeafCount++] = adjacentNode;\\n            }\\n        }\\n        \\n        // The 1 or 2 nodes remaining in the leaf node list, are the root nodes \\n        // for the minimum height tree, after successive layers of leaf nodes \\n        // have been removed from the tree.\\n        return Arrays.asList((nextLeafCount == 1) ? \\n                                (new Integer[]{leafs[0]}) :\\n                                (new Integer[]{leafs[0], leafs[1]}));\\n    }\\n}\\n```\n```\\n// Leetcode problem #310 -- Minimum Height Trees\\n// This code uses the Topological Sorting approach that is described in detail in \\n// the Solution tab for this leetcode problem.  The general idea is use the graph \\n// of nodes and edges passed into this code, then remove layer after layer of edge \\n// nodes until only 1 or 2 nodes remain,  The remaining 1 or 2 nodes will be the \\n// root nodes of the minumum height trees.\\nclass Solution {\\n    // Max number of nodes that any node can be connected to.  Another \\n    // version of this code determines this number dynamically for each \\n    // test case, but I wanted to see if this code would run faster with \\n    // this number hard-coded to it\\'s maximum value for all test cases \\n    // that were used as of December 2021.\\n    static final int MAX_ADJACENT = 20;\\n    \\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // If only 1 or 2 nodes, then each node is a possible Minimum \\n        // Height Tree root.\\n        if (n < 2) \\n            return Arrays.asList((n == 1) ? \\n                                (new Integer[]{0}) :\\n                                (new Integer[]{0,1}));\\n        \\n        // For each node, build an array of adjacent nodes it is connected to.\\n        // Find the maximum number of connections for any node, then allocate \\n        // the 2-D array adjacentList[][] to be indexed by node number to result \\n        // in a 1-D array of adjacent node numbers.\\n        // adjacentCount[node] --   The number of adjacent nodes to node \\'node\\'.\\n        // adjacentRemaining[node]--The number of adjacent nodes remaining \\n        //                          connected to node \\'node\\', after some of the \\n        //                          leaf nodes have been removed.\\n        // nodeRemoved[node] --     Boolean indicating if node \\'node\\' has been \\n        //                          removed from the graph/tree.\\n        // adjacentList[node][0..adjacentCount[node]] --\\n        //                          Lists the adjacent node numbers for node \\n        //                          \\'node\\'.  The adjacent nodes are a group of \\n        //                          node numbers indexed by the second index of \\n        //                          this array, and the count of numbers in that \\n        //                          group is: adjacentCount[node].\\n        int[] adjacentRemaining = new int[n];\\n        int[][] adjacentList = new int[n][MAX_ADJACENT];\\n        for (int[] edge : edges) {          // Fill-in 2-D array of adjacent node nums.\\n            adjacentList[edge[0]][adjacentRemaining[edge[0]]++] = edge[1];\\n            adjacentList[edge[1]][adjacentRemaining[edge[1]]++] = edge[0];\\n        }\\n        int[] adjacentCount = Arrays.copyOf(adjacentRemaining, n);\\n        \\n        // Collect the original leaf nodes into an array.  We will later \\n        // multiply re-use this array to build the next inward layer of \\n        // leaves that were created as we remove the outer layer of leaves.  \\n        // We can re-use this array by starting at the beginning of the \\n        // array and filling in any node that became a leaf when an outer \\n        // layer leaf was removed.  We can do this because the next inward \\n        // layer of leaves can only have at most one leaf created by the \\n        // removal of a single outer layer leaf, so that the next inward \\n        // layer of leaves will have at most the same number of leaves as \\n        // the outer layer of leaves had.  The next inward leaf numbers \\n        // that are being added to the array while outer layer leaves are \\n        // still being read from the array and being removed from the graph.  \\n        // The next inward leaves being created and written to the array, \\n        // will never overwrite the outer layer of leaf numbers that are \\n        // still being processed.\\n        int[] leafs = new int[n];\\n        int leafCount = 0;\\n        int nextLeafCount = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n            if (adjacentRemaining[i] == 1)\\n                leafs[nextLeafCount++] = i;\\n        \\n        // For all the leaves in the leafs array, remove those leaf nodes \\n        // and add next inward layer leaves that thereby become leaf nodes \\n        // into the leafs array, so those next inward layer of leaves can \\n        // be removed on the next pass through the leafs array.  Repeat \\n        // removing layers of leaf nodes until only one or two nodes are \\n        // remaining.  Those remaining nodes will be the root node(s) for the \\n        // minimum height tree.\\n        int nodesRemaining = n;\\n        boolean[] nodeRemoved = new boolean[n];\\n        // Loop until only the 1 or 2 root nodes remain in the graph.\\n        while (nodesRemaining > 2) {\\n            leafCount = nextLeafCount;\\n            nextLeafCount = 0;\\n            nodesRemaining -= leafCount;\\n            // Loop to remove each outer layer leaf node from the graph.\\n            // The outer layer leaf nude numbers are in the array leafs[].\\n            for (int leafIdx = 0; leafIdx < leafCount; leafIdx++) {\\n                int node = leafs[leafIdx];\\n                int adjacentNode = -1;\\n                // Find the single valid un-removed edge for this leaf node \\n                // from the array of edges that this node was adjacent to.\\n                for (int i = adjacentCount[node] - 1; i >= 0; i--) {\\n                    if (!nodeRemoved[adjacentList[node][i]]) {\\n                        adjacentNode = adjacentList[node][i];\\n                        break;\\n                    }\\n                }\\n                nodeRemoved[node] = true;\\n                // If the node that this leaf node was connected to, if that \\n                // adjacent node has itself become a leaf node by the removal \\n                // of this leaf node, then add the node that has just become a \\n                // leaf node, to the array of leaf nodes to be removed on the \\n                // next pass.\\n                if (--adjacentRemaining[adjacentNode] == 1)\\n                    leafs[nextLeafCount++] = adjacentNode;\\n            }\\n        }\\n        \\n        // The 1 or 2 nodes remaining in the leaf node list, are the root nodes \\n        // for the minimum height tree, after successive layers of leaf nodes \\n        // have been removed from the tree.\\n        return Arrays.asList((nextLeafCount == 1) ? \\n                                (new Integer[]{leafs[0]}) :\\n                                (new Integer[]{leafs[0], leafs[1]}));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630809,
                "title": "python-leaf-removal-o-v-e",
                "content": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: list[list[int]]) -> list[int]:\\n        \"\"\"\\n        @see https://leetcode.com/problems/minimum-height-trees/solution/\\n        :param n:\\n        :param edges:\\n        :return:\\n        \"\"\"\\n        if n <= 2:\\n            return list(range(n))\\n\\n        g = self.create_graph(n, edges)\\n\\n        leaves = [u for u, nbrs in enumerate(g) if len(nbrs) == 1]\\n        remaining_nodes = n\\n\\n        while remaining_nodes > 2:\\n            remaining_nodes -= len(leaves)\\n\\n            new_leaves = []\\n\\n            for u in leaves:\\n                v = g[u].pop()\\n                (v_nbrs := g[v]).remove(u)\\n\\n                if len(v_nbrs) == 1:\\n                    new_leaves.append(v)\\n\\n            leaves = new_leaves\\n\\n        return leaves\\n\\n    @staticmethod\\n    def create_graph(n, edges: list[list[int]]) -> list[set[int]]:\\n        \"\"\"\\n        :param n: total number of nodes in graph\\n        :param edges:\\n        :return: list of sets, item at index i is set of neighbors of ith node\\n        \"\"\"\\n        g = [set() for _ in range(n)]\\n\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n\\n        return g\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: list[list[int]]) -> list[int]:\\n        \"\"\"\\n        @see https://leetcode.com/problems/minimum-height-trees/solution/\\n        :param n:\\n        :param edges:\\n        :return:\\n        \"\"\"\\n        if n <= 2:\\n            return list(range(n))\\n\\n        g = self.create_graph(n, edges)\\n\\n        leaves = [u for u, nbrs in enumerate(g) if len(nbrs) == 1]\\n        remaining_nodes = n\\n\\n        while remaining_nodes > 2:\\n            remaining_nodes -= len(leaves)\\n\\n            new_leaves = []\\n\\n            for u in leaves:\\n                v = g[u].pop()\\n                (v_nbrs := g[v]).remove(u)\\n\\n                if len(v_nbrs) == 1:\\n                    new_leaves.append(v)\\n\\n            leaves = new_leaves\\n\\n        return leaves\\n\\n    @staticmethod\\n    def create_graph(n, edges: list[list[int]]) -> list[set[int]]:\\n        \"\"\"\\n        :param n: total number of nodes in graph\\n        :param edges:\\n        :return: list of sets, item at index i is set of neighbors of ith node\\n        \"\"\"\\n        g = [set() for _ in range(n)]\\n\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630797,
                "title": "java-topological-sort",
                "content": "This question may be a little difficult for people who have never seen similar questions like this before because if you pick 1 node at a time and loop through all the possibilities to find the minimum height tree, you\\'d get TLE like I did the first time I did it a month ago. \\n\\nThe proper approach is quite brilliant, I\\'d recommend you read the solution at https://leetcode.com/problems/minimum-height-trees/solution/ to gain a better understanding of why it works. They explain it better than I ever could. \\n\\nI am here just to share my implementation of that idea. Hope you find it helpful!\\n\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) return List.of(0); \\n\\t\\t//the only edge case becase trees are connected, so all indexes will show up inside edges[][] except when there is no edge. \\n\\n        List<Integer> ans = new ArrayList<>();\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int[] indeg = new int[n];\\n        for (int[] e : edges){ //we build the connection graph map here and the indegree array\\n            map.computeIfAbsent(e[0], o -> new ArrayList<>()).add(e[1]);\\n            map.computeIfAbsent(e[1], o -> new ArrayList<>()).add(e[0]);\\n            indeg[e[0]]++;\\n            indeg[e[1]]++;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++)\\n            if (indeg[i] == 1) //those that have indegree of 1 are in the outermost layer\\n                queue.add(i);\\n\\n        while(n > 2){ //remove it layer by layer until there are at most 2 nodes left.\\n            int size = queue.size();\\n            n -= size;\\n            while (size-- > 0)\\n                for (int v : map.get(queue.poll()))\\n                    if(--indeg[v] == 1)\\n                        queue.offer(v);\\n        }\\n\\n        while(!queue.isEmpty()) ans.add(queue.poll()); \\n\\t\\t//the remaining nodes will be in the queue, so add them to the ans list.\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) return List.of(0); \\n\\t\\t//the only edge case becase trees are connected, so all indexes will show up inside edges[][] except when there is no edge. \\n\\n        List<Integer> ans = new ArrayList<>();\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int[] indeg = new int[n];\\n        for (int[] e : edges){ //we build the connection graph map here and the indegree array\\n            map.computeIfAbsent(e[0], o -> new ArrayList<>()).add(e[1]);\\n            map.computeIfAbsent(e[1], o -> new ArrayList<>()).add(e[0]);\\n            indeg[e[0]]++;\\n            indeg[e[1]]++;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++)\\n            if (indeg[i] == 1) //those that have indegree of 1 are in the outermost layer\\n                queue.add(i);\\n\\n        while(n > 2){ //remove it layer by layer until there are at most 2 nodes left.\\n            int size = queue.size();\\n            n -= size;\\n            while (size-- > 0)\\n                for (int v : map.get(queue.poll()))\\n                    if(--indeg[v] == 1)\\n                        queue.offer(v);\\n        }\\n\\n        while(!queue.isEmpty()) ans.add(queue.poll()); \\n\\t\\t//the remaining nodes will be in the queue, so add them to the ans list.\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515887,
                "title": "c-topological-sort-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(edges.size() == 0){\\n            vector<int> res;\\n            res.push_back(0);\\n            return res;\\n        }\\n        unordered_map<int,vector<int>> graph;\\n        vector<int> indegree(n);\\n        for(auto e:edges){\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        for(int i = 0;i < n;i++){\\n            if(indegree[i] == 1)\\n                q.push(i);\\n        }\\n        while(n > 2){\\n            int size = q.size();\\n            n -= size;\\n            while(size-- > 0){\\n                int v = q.front();\\n                q.pop();\\n                for(auto vertex:graph[v]){\\n                    indegree[vertex]--;\\n                    if(indegree[vertex] == 1)\\n                        q.push(vertex);\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        while(!q.empty()){\\n            res.push_back(q.front());\\n            q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(edges.size() == 0){\\n            vector<int> res;\\n            res.push_back(0);\\n            return res;\\n        }\\n        unordered_map<int,vector<int>> graph;\\n        vector<int> indegree(n);\\n        for(auto e:edges){\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        for(int i = 0;i < n;i++){\\n            if(indegree[i] == 1)\\n                q.push(i);\\n        }\\n        while(n > 2){\\n            int size = q.size();\\n            n -= size;\\n            while(size-- > 0){\\n                int v = q.front();\\n                q.pop();\\n                for(auto vertex:graph[v]){\\n                    indegree[vertex]--;\\n                    if(indegree[vertex] == 1)\\n                        q.push(vertex);\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        while(!q.empty()){\\n            res.push_back(q.front());\\n            q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369832,
                "title": "c-variation-of-kahn-s-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n\\t\\tif(n==1) return {0};\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n,0);\\n        \\n        for(auto &e : edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;++i){\\n            if(indegree[i]==1){\\n                q.push(i);\\n                indegree[i]--;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        while(!q.empty()){\\n            int size = q.size();\\n            ans.clear();\\n            for(int i=0;i<size;++i){\\n                int curNode = q.front(); q.pop();\\n                ans.push_back(curNode);\\n                for(auto &childNode : graph[curNode]){\\n                    indegree[childNode]--;\\n                   if(indegree[childNode]==1){\\n                       q.push(childNode);\\n                   }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n\\t\\tif(n==1) return {0};\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n,0);\\n        \\n        for(auto &e : edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;++i){\\n            if(indegree[i]==1){\\n                q.push(i);\\n                indegree[i]--;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        while(!q.empty()){\\n            int size = q.size();\\n            ans.clear();\\n            for(int i=0;i<size;++i){\\n                int curNode = q.front(); q.pop();\\n                ans.push_back(curNode);\\n                for(auto &childNode : graph[curNode]){\\n                    indegree[childNode]--;\\n                   if(indegree[childNode]==1){\\n                       q.push(childNode);\\n                   }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318866,
                "title": "c-easy",
                "content": "```\\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1) return {0};\\n        vector<unordered_set<int>>adj(n);\\n        for(auto i:edges){\\n            adj[i[0]].insert(i[1]);\\n            adj[i[1]].insert(i[0]);\\n        }\\n        queue<int>q;\\n        for(int i=0;i<adj.size();i++)\\n            if(adj[i].size()==1)q.push(i);\\n        while(n>2){\\n            int l=q.size();\\n            n-=l;            \\n            for(int i=0;i<l;i++){\\n                int node=q.front();\\n                q.pop();\\n                for(auto i:adj[node]){\\n                    adj[i].erase(node);\\n                    if(adj[i].size()==1)q.push(i);\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        while(!q.empty()){\\n            res.push_back(q.front());\\n            q.pop();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1) return {0};\\n        vector<unordered_set<int>>adj(n);\\n        for(auto i:edges){\\n            adj[i[0]].insert(i[1]);\\n            adj[i[1]].insert(i[0]);\\n        }\\n        queue<int>q;\\n        for(int i=0;i<adj.size();i++)\\n            if(adj[i].size()==1)q.push(i);\\n        while(n>2){\\n            int l=q.size();\\n            n-=l;            \\n            for(int i=0;i<l;i++){\\n                int node=q.front();\\n                q.pop();\\n                for(auto i:adj[node]){\\n                    adj[i].erase(node);\\n                    if(adj[i].size()==1)q.push(i);\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        while(!q.empty()){\\n            res.push_back(q.front());\\n            q.pop();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1061232,
                "title": "c-solution-in-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n == 1){\\n            return {0};\\n        }\\n        vector<list<int>> adj(n);\\n        vector<int> nodes;\\n        for(auto& e: edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        queue<int> Q;\\n        for(int i = 0; i < adj.size(); i++){\\n            if(adj[i].size() == 1)\\n                Q.push(i);\\n        }\\n        while(n > 2){\\n            int len = Q.size();\\n            n = n - len;\\n            for(int i = 0; i < len; i++){\\n                int current = Q.front();\\n                Q.pop();\\n                for(auto& a : adj[current]){\\n                    auto it = std::find(adj[a].begin(),adj[a].end(),current);\\n                    adj[a].erase(it);\\n                    if(adj[a].size() == 1)\\n                        Q.push(a);\\n                }\\n            }\\n        }\\n        while(!Q.empty()){\\n            nodes.push_back(Q.front());\\n            Q.pop();\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n == 1){\\n            return {0};\\n        }\\n        vector<list<int>> adj(n);\\n        vector<int> nodes;\\n        for(auto& e: edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        queue<int> Q;\\n        for(int i = 0; i < adj.size(); i++){\\n            if(adj[i].size() == 1)\\n                Q.push(i);\\n        }\\n        while(n > 2){\\n            int len = Q.size();\\n            n = n - len;\\n            for(int i = 0; i < len; i++){\\n                int current = Q.front();\\n                Q.pop();\\n                for(auto& a : adj[current]){\\n                    auto it = std::find(adj[a].begin(),adj[a].end(),current);\\n                    adj[a].erase(it);\\n                    if(adj[a].size() == 1)\\n                        Q.push(a);\\n                }\\n            }\\n        }\\n        while(!Q.empty()){\\n            nodes.push_back(Q.front());\\n            Q.pop();\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925407,
                "title": "o-n-with-three-bfs-thought-process",
                "content": "First, we can come up with a brute force soltuion that performs a DFS for each vertex and remember the min height.\\n\\n```java\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> neighbors = new HashMap();\\n        for (int i = 0; i < n; i++) {\\n            neighbors.put(i, new ArrayList());\\n        }\\n        \\n        for (int[] edge : edges) {\\n            neighbors.get(edge[0]).add(edge[1]);\\n            neighbors.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        int[] heights = new int[n];\\n        \\n        int minHeight = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            boolean[] visited = new boolean[n];\\n            int h = walk(i, neighbors, visited, 0);\\n            heights[i] = h;\\n            minHeight = Math.min(minHeight, h);\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            if (heights[i] == minHeight) {\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int walk(int i, Map<Integer, List<Integer>> neighbors, boolean[] visited, int height) {\\n        visited[i] = true;\\n        int ret = height;\\n        \\n        for (int j : neighbors.get(i)) {\\n            if (!visited[j]) {\\n                ret = Math.max(ret, walk(j, neighbors, visited, height+1));\\n            }\\n        }\\n        \\n        visited[i] = false;\\n        return ret;\\n    }\\n}\\n```\\n\\nThe brute force solution has a time complexity of `~O(N^2)` where `N` is the number of nodes in the graph. Can we do better?\\n\\nAn idea I had was, if we know two points that are furthest from each other, we can find the points with the minimum height by running two BFSs.\\n\\n```java\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> G = new HashMap();\\n        for (int i = 0; i < n; i++) {\\n            G.put(i, new ArrayList());\\n        }\\n        \\n        for (int[] edge : edges) {\\n            G.get(edge[0]).add(edge[1]);\\n            G.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        int[] heights = new int[n];\\n\\n        int w = bfs(n, G, 0, heights); // find one extreme point w\\n        int v = bfs(n, G, w, heights); // find another extreme point v. calculate height from w\\n        bfs(n, G, v, heights); // calculate height from v\\n        \\n        int minHeight = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < n; i++) {\\n            minHeight = Math.min(minHeight, heights[i]);\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            if (heights[i] == minHeight) {\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int bfs(int n, Map<Integer, List<Integer>> G, int src, int[] heights) {\\n        boolean[] visited = new boolean[n];\\n        Deque<Integer> q = new ArrayDeque();\\n        \\n        q.addLast(src);\\n        int ret = src;\\n        int height = 0;\\n        \\n        while (q.size() > 0) {\\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                int v = q.removeFirst();\\n                visited[v] = true;\\n                ret = v;\\n                \\n                heights[v] = Math.max(heights[v], height);           \\n                \\n                for (int w : G.get(v)) {\\n                    if (!visited[w]) {\\n                        q.addLast(w);\\n                    }\\n                }\\n            }\\n            \\n            height++;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```\\n\\nThe idea is that, given an extreme point, we can run a BFS to find the maximum height for each node reachable from it (all nodes, actually, because the graph is a tree). We remember those heights in `heights` array. But wait, a height for a node could be larger if we calculate it from another extreme point. So let\\'s run another BFS from another extreme point, and store the heights in `heights` array, taking the maximum. Then we can find the minimum height and the nodes at which that value occurs.\\n\\nHow do we find such a pair of extreme points? Simply allow BFS to return a leaf node. Then, run a first BFS from any node. The returned node is guaranteed to be extreme because BFS visits all nodes level by level. Then we run a second BFS to find another extreme point.\\n\\nThe time complexity is `~O(N)` and the space complexity is `~O(N)` for the use of adjacency list graph data structure, `heights` array, and the queue. Additional note is that we can probably avoid allocating `heights`, and simply find the middle elements, given the two extreme points.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> neighbors = new HashMap();\\n        for (int i = 0; i < n; i++) {\\n            neighbors.put(i, new ArrayList());\\n        }\\n        \\n        for (int[] edge : edges) {\\n            neighbors.get(edge[0]).add(edge[1]);\\n            neighbors.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        int[] heights = new int[n];\\n        \\n        int minHeight = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            boolean[] visited = new boolean[n];\\n            int h = walk(i, neighbors, visited, 0);\\n            heights[i] = h;\\n            minHeight = Math.min(minHeight, h);\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            if (heights[i] == minHeight) {\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int walk(int i, Map<Integer, List<Integer>> neighbors, boolean[] visited, int height) {\\n        visited[i] = true;\\n        int ret = height;\\n        \\n        for (int j : neighbors.get(i)) {\\n            if (!visited[j]) {\\n                ret = Math.max(ret, walk(j, neighbors, visited, height+1));\\n            }\\n        }\\n        \\n        visited[i] = false;\\n        return ret;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> G = new HashMap();\\n        for (int i = 0; i < n; i++) {\\n            G.put(i, new ArrayList());\\n        }\\n        \\n        for (int[] edge : edges) {\\n            G.get(edge[0]).add(edge[1]);\\n            G.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        int[] heights = new int[n];\\n\\n        int w = bfs(n, G, 0, heights); // find one extreme point w\\n        int v = bfs(n, G, w, heights); // find another extreme point v. calculate height from w\\n        bfs(n, G, v, heights); // calculate height from v\\n        \\n        int minHeight = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < n; i++) {\\n            minHeight = Math.min(minHeight, heights[i]);\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            if (heights[i] == minHeight) {\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int bfs(int n, Map<Integer, List<Integer>> G, int src, int[] heights) {\\n        boolean[] visited = new boolean[n];\\n        Deque<Integer> q = new ArrayDeque();\\n        \\n        q.addLast(src);\\n        int ret = src;\\n        int height = 0;\\n        \\n        while (q.size() > 0) {\\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                int v = q.removeFirst();\\n                visited[v] = true;\\n                ret = v;\\n                \\n                heights[v] = Math.max(heights[v], height);           \\n                \\n                for (int w : G.get(v)) {\\n                    if (!visited[w]) {\\n                        q.addLast(w);\\n                    }\\n                }\\n            }\\n            \\n            height++;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924029,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    const int shift = 15; \\n    const int cntr = 1 << shift;\\n    const int mask = cntr - 1;\\n\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n==1) return {0};\\n   \\n        \\n        edges.push_back(vector<int>{0,0});\\n        const int k2 = n - 1;\\n        for (int k=0; k < k2; k++) {\\n            int i = edges[k][0] & mask;\\n            int j = edges[k][1] & mask;\\n            edges[i][0] += cntr; \\n            edges[i][1] += (j << shift); \\n\\n            edges[j][0] += cntr;\\n            edges[j][1] += (i << shift);\\n        }\\n\\n        deque<int> leaves;\\n        const int m = n;\\n        for (int i=0; i < m; i++) {\\n            edges[i][0] = edges[i][0] >> shift;\\n            edges[i][1] = edges[i][1] >> shift;\\n            if (edges[i][0]==1) leaves.push_back(i);\\n        }\\n        \\n        while (n > 2) {\\n            const int leaves_size = leaves.size();\\n            for (int i=0; i < leaves_size; i++) {\\n                const int leaf = leaves.front(); leaves.pop_front();\\n                const int conn = edges[leaf][1];\\n                edges[conn][1] -= leaf;\\n                if (--edges[conn][0]==1) leaves.push_back(conn);\\n            }\\n            n -= leaves_size;\\n        }\\n\\n        return vector<int>(leaves.begin(), leaves.end());\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    const int shift = 15; \\n    const int cntr = 1 << shift;\\n    const int mask = cntr - 1;\\n\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n==1) return {0}",
                "codeTag": "Java"
            },
            {
                "id": 923875,
                "title": "minimum-height-trees-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // 1. Create list of adjacencies for each node (nodeAdjs)\\n    // 2. Get nodes which are leaves\\n    // 3. Remove leaf nodes from nodeAdjs\\n    // 4. Repeat 2 and 3 until we have 1 or 2 nodes left\\n    // 5. Return nodes left\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n == 1) return {0};\\n        if (n == 2) return {0, 1};\\n        \\n        unordered_map<int, unordered_set<int>> nodeAdjs;\\n        vector<int> leaves;\\n        \\n        buildNodeAdjacencies(nodeAdjs, edges);\\n        \\n        while (nodeAdjs.size() > 2) {\\n            getLeaves(leaves, nodeAdjs);\\n            removeNodes(nodeAdjs, leaves);\\n        }\\n        \\n        getLeaves(leaves, nodeAdjs);\\n            \\n        return leaves;\\n    }\\n    \\nprivate:\\n    void buildNodeAdjacencies(unordered_map<int, unordered_set<int>>& nodeAdjs, const vector<vector<int>>& edges) const {\\n        nodeAdjs = unordered_map<int, unordered_set<int>>(edges.size() + 1);\\n        for (const auto& edge : edges) {\\n            nodeAdjs[edge[0]].insert(edge[1]);\\n            nodeAdjs[edge[1]].insert(edge[0]);\\n        }\\n    }\\n    \\n    void getLeaves(vector<int>& leaves, const unordered_map<int, unordered_set<int>>& nodeAdjs) const {\\n        leaves = vector<int>();\\n        for (const auto& p : nodeAdjs) {\\n            if (p.second.size() <= 1) {\\n                leaves.push_back(p.first);\\n            }\\n        }\\n    }\\n    \\n    void removeNodes(unordered_map<int, unordered_set<int>>& nodeAdjs, const vector<int>& nodes) const {\\n        for (const auto& node : nodes) {\\n            for (const auto& adj : nodeAdjs[node]) {\\n                nodeAdjs[adj].erase(node);\\n            }\\n            nodeAdjs.erase(node);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // 1. Create list of adjacencies for each node (nodeAdjs)\\n    // 2. Get nodes which are leaves\\n    // 3. Remove leaf nodes from nodeAdjs\\n    // 4. Repeat 2 and 3 until we have 1 or 2 nodes left\\n    // 5. Return nodes left\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n == 1) return {0};\\n        if (n == 2) return {0, 1};\\n        \\n        unordered_map<int, unordered_set<int>> nodeAdjs;\\n        vector<int> leaves;\\n        \\n        buildNodeAdjacencies(nodeAdjs, edges);\\n        \\n        while (nodeAdjs.size() > 2) {\\n            getLeaves(leaves, nodeAdjs);\\n            removeNodes(nodeAdjs, leaves);\\n        }\\n        \\n        getLeaves(leaves, nodeAdjs);\\n            \\n        return leaves;\\n    }\\n    \\nprivate:\\n    void buildNodeAdjacencies(unordered_map<int, unordered_set<int>>& nodeAdjs, const vector<vector<int>>& edges) const {\\n        nodeAdjs = unordered_map<int, unordered_set<int>>(edges.size() + 1);\\n        for (const auto& edge : edges) {\\n            nodeAdjs[edge[0]].insert(edge[1]);\\n            nodeAdjs[edge[1]].insert(edge[0]);\\n        }\\n    }\\n    \\n    void getLeaves(vector<int>& leaves, const unordered_map<int, unordered_set<int>>& nodeAdjs) const {\\n        leaves = vector<int>();\\n        for (const auto& p : nodeAdjs) {\\n            if (p.second.size() <= 1) {\\n                leaves.push_back(p.first);\\n            }\\n        }\\n    }\\n    \\n    void removeNodes(unordered_map<int, unordered_set<int>>& nodeAdjs, const vector<int>& nodes) const {\\n        for (const auto& node : nodes) {\\n            for (const auto& adj : nodeAdjs[node]) {\\n                nodeAdjs[adj].erase(node);\\n            }\\n            nodeAdjs.erase(node);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903192,
                "title": "c-40-faster-hash",
                "content": "idea : our graph is tree and we understand that minimum tree we can constract from two nodes( if max len of graph is even) or one node (if max of graph is odd) so we will erase leaf and after all we will have our final nodes(or node)\\n**new version :**\\n```\\nclass Solution {\\npublic:\\n  vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n    unordered_map<int, unordered_set<int>>g;\\n    for(auto &e: edges) g[e[0]].insert(e[1]), g[e[1]].insert(e[0]);\\n    \\n    while(g.size() > 2){\\n      vector<pair<int,int>>v;\\n      for(auto &[x, st] : g)\\n        if(st.size() == 1) v.push_back({x, *st.begin()});\\n      while(!v.empty()){\\n        auto [x, y] = v.back(); v.pop_back();\\n        g.erase(x);\\n        g[y].erase(x);\\n      }\\n    }\\n    \\n    vector<int>ans;\\n    for(auto &[x, st]: g) ans.push_back(x);\\n    if(ans.empty()) ans.push_back(0);\\n    return ans;\\n  }\\n};\\n```\\n\\n**first version :**\\n```\\nclass Solution {\\npublic:\\n    struct graph{unordered_set <int> nb;};\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> rez;\\n        if(n==1) {rez.push_back(0);return rez;}\\n        if(n == 2) {rez.push_back(0);rez.push_back(1);return rez;}\\n        unordered_map <int,graph*> mp;\\n        for(int i = 0;i < n;i++){\\n            graph* tmp = new graph();\\n            mp[i] = tmp;\\n        }\\n        for(int i = 0;i < edges.size();i++){\\n            mp[edges[i][0]]->nb.insert(edges[i][1]);\\n            mp[edges[i][1]]->nb.insert(edges[i][0]);\\n        }\\n\\n        stack <int> leaf;\\n        unordered_map <int,graph*>::iterator it = mp.begin();\\n        for(it ; it!=mp.end(); it++)\\n            if(it->second->nb.size() == 1) leaf.push (it->first);\\n        \\n        while(mp.size() > 2){\\n            stack <int> cand;\\n            while(!leaf.empty()){\\n                int n_leaf = leaf.top();\\n                leaf.pop();\\n                unordered_set <int>::iterator it = mp[n_leaf]->nb.begin();\\n                int nb_leaf = *it;\\n                mp.erase(n_leaf);\\n                mp[nb_leaf]->nb.erase(n_leaf);\\n                if(mp[nb_leaf]->nb.size() == 1) cand.push(nb_leaf);\\n            }\\n            while(!cand.empty()) {\\n                leaf.push(cand.top());\\n                cand.pop();\\n            } \\n        }\\n         while(!leaf.empty()) {\\n                rez.push_back(leaf.top());\\n                leaf.pop();\\n            }\\n        \\n        return rez;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n    unordered_map<int, unordered_set<int>>g;\\n    for(auto &e: edges) g[e[0]].insert(e[1]), g[e[1]].insert(e[0]);\\n    \\n    while(g.size() > 2){\\n      vector<pair<int,int>>v;\\n      for(auto &[x, st] : g)\\n        if(st.size() == 1) v.push_back({x, *st.begin()});\\n      while(!v.empty()){\\n        auto [x, y] = v.back(); v.pop_back();\\n        g.erase(x);\\n        g[y].erase(x);\\n      }\\n    }\\n    \\n    vector<int>ans;\\n    for(auto &[x, st]: g) ans.push_back(x);\\n    if(ans.empty()) ans.push_back(0);\\n    return ans;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct graph{unordered_set <int> nb;};\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> rez;\\n        if(n==1) {rez.push_back(0);return rez;}\\n        if(n == 2) {rez.push_back(0);rez.push_back(1);return rez;}\\n        unordered_map <int,graph*> mp;\\n        for(int i = 0;i < n;i++){\\n            graph* tmp = new graph();\\n            mp[i] = tmp;\\n        }\\n        for(int i = 0;i < edges.size();i++){\\n            mp[edges[i][0]]->nb.insert(edges[i][1]);\\n            mp[edges[i][1]]->nb.insert(edges[i][0]);\\n        }\\n\\n        stack <int> leaf;\\n        unordered_map <int,graph*>::iterator it = mp.begin();\\n        for(it ; it!=mp.end(); it++)\\n            if(it->second->nb.size() == 1) leaf.push (it->first);\\n        \\n        while(mp.size() > 2){\\n            stack <int> cand;\\n            while(!leaf.empty()){\\n                int n_leaf = leaf.top();\\n                leaf.pop();\\n                unordered_set <int>::iterator it = mp[n_leaf]->nb.begin();\\n                int nb_leaf = *it;\\n                mp.erase(n_leaf);\\n                mp[nb_leaf]->nb.erase(n_leaf);\\n                if(mp[nb_leaf]->nb.size() == 1) cand.push(nb_leaf);\\n            }\\n            while(!cand.empty()) {\\n                leaf.push(cand.top());\\n                cand.pop();\\n            } \\n        }\\n         while(!leaf.empty()) {\\n                rez.push_back(leaf.top());\\n                leaf.pop();\\n            }\\n        \\n        return rez;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720062,
                "title": "do-bfs-twice-to-find-the-diameter",
                "content": "The first BFS is done from **node-0** to find the ***last*** node in the diameter. Now perform the BFS again from **last node** to find the other end of diameter. If diamater is odd then answer has ***2*** else ***1*** nodes. To find those nodes traverse the parent array formed in first BFS.\\n  \\n     class Solution {\\n     public:\\n     int last;\\n      void bfs(int source,vector<int>&visited,vector<int>adj[],vector<int>&level,vector<int>&parent)\\n      {\\n        queue<int>q;\\n        q.push(source);\\n\\n        while(!q.empty())\\n        {int top=q.front();\\n         last=top;\\n         visited[top]=1;\\n         q.pop();\\n         for(int i=0;i<adj[top].size();i++)\\n            {int x=adj[top][i];\\n             if(visited[x]==0)\\n             {q.push(x);\\n              parent[x]=top;level[x]=level[top]+1;\\n             }}\\n           }\\n    } \\n    public:\\n     vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n      vector<int>parent1(n);\\n      vector<int>parent2(n);\\n      for(int i=0;i<n;i++)\\n      {parent1[i]=i;parent2[i]=i;}    \\n      vector<int>visited1(n,0);\\n      vector<int>visited2(n,0);\\n      vector<int>level1(n,0);\\n      vector<int>level2(n,0);  \\n      vector<int>adj[n];  \\n      for(int i=0;i<edges.size();i++)\\n      {int x=edges[i][0];\\n       int y=edges[i][1];\\n       adj[x].push_back(y);adj[y].push_back(x);}\\n       bfs(0,visited1,adj,level1,parent1);\\n       int maxi=0;int u=0;\\n       for(int i=0;i<level1.size();i++)\\n       {\\n       if(level1[i]>u)\\n       {maxi=i;u=level1[i];}\\n       }   \\n       bfs(maxi,visited2,adj,level2,parent2);\\n       int d=level2[last];\\n       int count=1;    \\n       while(count<=d/2)\\n       {int p=parent1[maxi];\\n        maxi=p;count++;}\\n       vector<int>ans;\\n       ans.push_back(maxi);\\n       if(d%2!=0)\\n       ans.push_back(parent1[maxi]);    \\n       return ans;\\n    }\\n    };\\n",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n     int last;\\n      void bfs(int source,vector<int>&visited,vector<int>adj[],vector<int>&level,vector<int>&parent)\\n      {\\n        queue<int>q;\\n        q.push(source);\\n\\n        while(!q.empty())\\n        {int top=q.front();\\n         last=top;\\n         visited[top]=1;\\n         q.pop();\\n         for(int i=0;i<adj[top].size();i++)\\n            {int x=adj[top][i];\\n             if(visited[x]==0)\\n             {q.push(x);\\n              parent[x]=top;level[x]=level[top]+1;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 477187,
                "title": "java-tree-dp-solution-o-n-time-and-space",
                "content": "I didn\\'t come up with leave pruning or BFS solution to find the middle point of the graph (I don\\'t see the pattern there). My intuition is to try each node as the root and to find the minimum, for example\\n![image](https://assets.leetcode.com/users/yyfyifan/image_1578763084.png)\\nSo it\\'s easy to find this brute force O(N^2) solution. \\n\\nBut I then realize some height calculation is duplicated, such as:\\n![image](https://assets.leetcode.com/users/yyfyifan/image_1578763185.png)\\n\\n**That is to say, when a node\\'s parent is knwon, then the subtree rooted at the node is also fixed.** With this in mind, I tried to build a memo to recording a `(node, parent) -> height` map. The graph has O(edges) pairs, and in this tree, edges ~ O(N), so the space complexity is O(N) for this memo. And to rebuild the graph as a adjacency list, it needs O(V+E) space, which is also O(N).\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n> Please let me know if this is really a stupid method. I really can\\'t see the \\'mid-point\\' method,so I\\'m thinking I\\'m too bad.\\n\\n\\n```java\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // Build the adjacency list\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        \\n        Map<Integer, Map<Integer, Integer>> height = new HashMap<>();  // (node, parent) -> height map\\n        int[] treeHeight = new int[n];   // height for each root\\n        int minHeight = Integer.MAX_VALUE;   // min height in the `treeHeight`\\n        // try each node as the root node and calculate it\\'s tree height\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> children = graph.get(i);\\n            int childHeight = -1;\\n            // get the height of each child, using the current root as parent\\n            for(int child : children) {\\n                childHeight = Math.max(childHeight, getHeight(child, i, height, graph));\\n            }\\n            treeHeight[i] = childHeight + 1;   // calculate root\\'s height\\n            minHeight = Math.min(minHeight, treeHeight[i]); // calculate global min height\\n        }\\n        // add all root\\'s height = minHeight into the answer list\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if(treeHeight[i] == minHeight) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // calculate the node\\'s tree height when the parent node is `parent`\\n    // the result should be memorized in a map\\n    private int getHeight(int node, int parent, Map<Integer, Map<Integer, Integer>> height, List<List<Integer>> graph) {\\n        // if already seen, return\\n        if(height.containsKey(node) && height.get(node).containsKey(parent)) {\\n            return height.get(node).get(parent);\\n        }\\n        \\n        \\n        List<Integer> neighbors = graph.get(node);\\n        int treeHeight = 0;\\n        // if it has only one children, then it is the parent node, just return 0\\n        // otherwise iterate through all children\\'s tree height\\n        if(neighbors.size() != 1){\\n            int maxChildHeight = -1;\\n            for(int n : neighbors) {\\n                if(n != parent) {\\n                    maxChildHeight = Math.max(maxChildHeight, getHeight(n, node, height, graph));\\n                }\\n            }    \\n            treeHeight = maxChildHeight + 1;\\n        }\\n        // update the (node, parent) ->height in the memo\\n        Map<Integer, Integer> childHeight = height.getOrDefault(node, new HashMap<>());\\n        childHeight.put(parent, treeHeight);\\n        height.put(node, childHeight);\\n        return treeHeight;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // Build the adjacency list\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        \\n        Map<Integer, Map<Integer, Integer>> height = new HashMap<>();  // (node, parent) -> height map\\n        int[] treeHeight = new int[n];   // height for each root\\n        int minHeight = Integer.MAX_VALUE;   // min height in the `treeHeight`\\n        // try each node as the root node and calculate it\\'s tree height\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> children = graph.get(i);\\n            int childHeight = -1;\\n            // get the height of each child, using the current root as parent\\n            for(int child : children) {\\n                childHeight = Math.max(childHeight, getHeight(child, i, height, graph));\\n            }\\n            treeHeight[i] = childHeight + 1;   // calculate root\\'s height\\n            minHeight = Math.min(minHeight, treeHeight[i]); // calculate global min height\\n        }\\n        // add all root\\'s height = minHeight into the answer list\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if(treeHeight[i] == minHeight) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // calculate the node\\'s tree height when the parent node is `parent`\\n    // the result should be memorized in a map\\n    private int getHeight(int node, int parent, Map<Integer, Map<Integer, Integer>> height, List<List<Integer>> graph) {\\n        // if already seen, return\\n        if(height.containsKey(node) && height.get(node).containsKey(parent)) {\\n            return height.get(node).get(parent);\\n        }\\n        \\n        \\n        List<Integer> neighbors = graph.get(node);\\n        int treeHeight = 0;\\n        // if it has only one children, then it is the parent node, just return 0\\n        // otherwise iterate through all children\\'s tree height\\n        if(neighbors.size() != 1){\\n            int maxChildHeight = -1;\\n            for(int n : neighbors) {\\n                if(n != parent) {\\n                    maxChildHeight = Math.max(maxChildHeight, getHeight(n, node, height, graph));\\n                }\\n            }    \\n            treeHeight = maxChildHeight + 1;\\n        }\\n        // update the (node, parent) ->height in the memo\\n        Map<Integer, Integer> childHeight = height.getOrDefault(node, new HashMap<>());\\n        childHeight.put(parent, treeHeight);\\n        height.put(node, childHeight);\\n        return treeHeight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456428,
                "title": "find-the-longest-path-in-a-tree-proof",
                "content": "1. The root of the minimum height tree should be on the longest path.\\nAssuming the root is not on the longest path, and the heighest node on the longest path is x, dividing the longest path into two parts, h1 and h2, hence the height of tree root h > max(h1,h2), if we promote node x to be the root, the new height is max(h1,h2) < h according to the longest path assumption. To minimize max(h1,h2) we have to choose the middle point(s) among the longest path.\\nBonus: If there are multiple longest paths, they must share the same middle point(s), otherwise we can construct a longer path contradicting the longest path assumption.\\n\\n2. How to find the longest path and their middle point(s) ?\\nFor each node in a tree, there is an unique path from the node to every leaf path(i,j), more generally a unique path from any node to any node in an acyclic graph, and a distance d(i,j), here are two cases to discuss\\n\\ni. path(i,j) = path(i,k)+path(k,j), only if path(i,j) pass through neighboring node k, d(i,j) = d(i,k)+d(k,j) > d(k,j)\\n```\\n    x     x\\n     \\\\   /\\n       \\\\/\\nx ---- i ---- k ~~~~~ j\\n       /\\\\\\n      /  \\\\\\n     x    x\\n```\\n\\t \\nii. if path(i,j) does not pass k, then node k is not used to obtain d(i,j)\\n```\\n    x     x\\n     \\\\   /\\n       \\\\/\\nk ---- i ---- x ~~~~~ j\\n       /\\\\\\n      /  \\\\\\n     x    x\\n```\\nTo sum up, for a given leaf, we can easily find the path of any other node to the given leaf using bottom up approach (starting from the leaf and then bfs updating). But how do we find the longest path? we start bfs at all leaf nodes in parallel !\\nIn detail, at bfs step t, for all of node `i` \\'s neighbors `x` (except node `k`), we have known all node `x` to leaves distances (not passing through `x-i`) and they are all not great than t, therefore if the longest path pass through `x` then it must pass through `i`, and now node `i` to all leaves not passing through `i-k` will be obtained and node `i` is ready to be pushed to the queue for the next round update. From this pattern we see the candidates for the longest path is shrinking until only one/two nodes left in the queue, which is/are the middle point(s), moreover, we can keep track of the path using a pointer to the previous node and recovering the path in reverse.\\n```\\n    x     x\\n     \\\\   /\\n       \\\\/\\nx ---- i ---- k ~~~~~ j\\n       /\\\\\\n      /  \\\\\\n     x    x\\n```\\n\\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        nxt = [set() for _ in range(n)]\\n        for a, b in edges:\\n            nxt[a].add(b)\\n            nxt[b].add(a)\\n        q = [x for x in range(n) if len(nxt[x]) == 1]\\n        res = []\\n        # print(nxt,q)\\n        while q:\\n            res, q = q, []\\n            for cur in res:\\n                # print(cur,nxt)\\n                if not nxt[cur]:\\n                    continue\\n                child = nxt[cur].pop()\\n                nxt[child].remove(cur)\\n                if len(nxt[child]) == 1:\\n                    q.append(child)\\n                                        \\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    x     x\\n     \\\\   /\\n       \\\\/\\nx ---- i ---- k ~~~~~ j\\n       /\\\\\\n      /  \\\\\\n     x    x\\n```\n```\\n    x     x\\n     \\\\   /\\n       \\\\/\\nk ---- i ---- x ~~~~~ j\\n       /\\\\\\n      /  \\\\\\n     x    x\\n```\n```\\n    x     x\\n     \\\\   /\\n       \\\\/\\nx ---- i ---- k ~~~~~ j\\n       /\\\\\\n      /  \\\\\\n     x    x\\n```\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        nxt = [set() for _ in range(n)]\\n        for a, b in edges:\\n            nxt[a].add(b)\\n            nxt[b].add(a)\\n        q = [x for x in range(n) if len(nxt[x]) == 1]\\n        res = []\\n        # print(nxt,q)\\n        while q:\\n            res, q = q, []\\n            for cur in res:\\n                # print(cur,nxt)\\n                if not nxt[cur]:\\n                    continue\\n                child = nxt[cur].pop()\\n                nxt[child].remove(cur)\\n                if len(nxt[child]) == 1:\\n                    q.append(child)\\n                                        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447124,
                "title": "easy-bfs-solution-with-comments-faster-than-80",
                "content": "**Approach:**\\n- Find in-degree of all the vertices.\\n- Vertices with in-degree 1 are the leaf nodes. \\n- Keep removing leaves level by level until you reach the middle of the graph with maximum 2 vertices.\\n- There will be maximum 2 such vertices that will form minimum height trees. (middle of the graph)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        //undirected graph from edges\\n        for(vector<int> e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        //compute in-degree of vertices\\n        vector<int> indegree(n);\\n        for(int u=0;u<n;u++)\\n        {\\n            for(int v: adj[u])\\n                indegree[v]++;\\n        }\\n\\n        queue<int> q;\\n\\n        //in-degree 1 -> leaf vertex\\n        //add all leaves to the queue\\n        for(int v=0;v<n;v++)\\n        {\\n            if(indegree[v]==1)\\n                q.push(v);\\n        }\\n        \\n        vector<int> root;\\n        \\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            //remove leaves level by level\\n            //newly added leaves will be removed in next turn\\n            for(int i=0;i<size;i++)\\n            {\\n                int u=q.front();\\n                q.pop();\\n                indegree[u]--;\\n                \\n                //when two or one vertex are remaining -> add to the result\\n                if(n<=2)        \\n                {\\n                    root.push_back(u);\\n                    continue;\\n                }    \\n            \\n                for(int v: adj[u])\\n                {\\n                    indegree[v]--;\\n                    if(indegree[v]==1)\\n                        q.push(v);\\n                }\\n            }\\n            //update remaining vertices after removing current level of leaf nodes\\n            n=n-size;\\n        }\\n        \\n        if(root.size()==0)\\n            return {0};\\n        return root;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        //undirected graph from edges\\n        for(vector<int> e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        //compute in-degree of vertices\\n        vector<int> indegree(n);\\n        for(int u=0;u<n;u++)\\n        {\\n            for(int v: adj[u])\\n                indegree[v]++;\\n        }\\n\\n        queue<int> q;\\n\\n        //in-degree 1 -> leaf vertex\\n        //add all leaves to the queue\\n        for(int v=0;v<n;v++)\\n        {\\n            if(indegree[v]==1)\\n                q.push(v);\\n        }\\n        \\n        vector<int> root;\\n        \\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            //remove leaves level by level\\n            //newly added leaves will be removed in next turn\\n            for(int i=0;i<size;i++)\\n            {\\n                int u=q.front();\\n                q.pop();\\n                indegree[u]--;\\n                \\n                //when two or one vertex are remaining -> add to the result\\n                if(n<=2)        \\n                {\\n                    root.push_back(u);\\n                    continue;\\n                }    \\n            \\n                for(int v: adj[u])\\n                {\\n                    indegree[v]--;\\n                    if(indegree[v]==1)\\n                        q.push(v);\\n                }\\n            }\\n            //update remaining vertices after removing current level of leaf nodes\\n            n=n-size;\\n        }\\n        \\n        if(root.size()==0)\\n            return {0};\\n        return root;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357355,
                "title": "python-with-explanation-cutting-leafs",
                "content": "The idea - we don\\'t need to count how many steps, we need find those nodes which are located in the center of graph. So we will just remove all single leafs (leafs with only one connection) using iterations utill we cut all of of leafs. Our central leafs (it can be 1 or 2, or even 3) will be cutted at the very end. So first we build a list of nodes which are connected with only one link  ( you can call them edge nodes or I call them single leafs) and delete them. Delete means - we visit each neighboar of such nodes and delete those single nodes from neighbors list there.  Then some of nodes which had 2 neighbors before will become single leafs too. We will store those new single leafs and will cut them in next iterattion. And so on. At the end we will find than no more single leafs exist - we cut all leafs, and when we look into last transaction - we will find those  nodes which were located in center.\\n\\n```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n==1:\\n            return [0]\\n\\n        # prepare empty lists where we will keep connected neighbors, if n=5, we will have 5 lists\\n        nbrs = [[] for i in range(n)] \\n        \\n        # building list of neighbors\\n        for l, r in edges:\\n            nbrs[l].append(r)\\n            nbrs[r].append(l)\\n        \\n        # each iteration we cut all single leafs, they will have only ONE neighbor, \\n        # bcs they are last on branch, here our candidates for the first cut\\n        cut = [i for i, nlist in enumerate(nbrs) if len(nlist)==1]\\n        \\n        #after the cut we will look for nodes which become now single leaf, for now it is empty\\n        new_cut = []\\n        \\n        # continue cutting till some of leafs are available, but should break early\\n        while cut:          \\n            for leaf in cut:\\n                # we visit that one neighbor of single leaf and delete current leaf from stored \\n                # neighbors there, so current leaf will lost his connection.\\n                for nb in nbrs[leaf]:\\n                    nbrs[nb].remove(leaf)\\n                    \\n                    # if after the cut some of neighboars become single, we put them into next cut \\n                    if len(nbrs[nb])==1:\\n                        new_cut.append(nb)\\n                        \\n            # we have cut all leafs, can break, out answer will be in last \"cut\"\\n            if not new_cut:\\n                break\\n            \\n            \\n            cut, new_cut = new_cut, []\\n        return cut\\n            \\n                    \\n                \\n            \\n            \\n",
                "solutionTags": [],
                "code": "The idea - we don\\'t need to count how many steps, we need find those nodes which are located in the center of graph. So we will just remove all single leafs (leafs with only one connection) using iterations utill we cut all of of leafs. Our central leafs (it can be 1 or 2, or even 3) will be cutted at the very end. So first we build a list of nodes which are connected with only one link  ( you can call them edge nodes or I call them single leafs) and delete them. Delete means - we visit each neighboar of such nodes and delete those single nodes from neighbors list there.  Then some of nodes which had 2 neighbors before will become single leafs too. We will store those new single leafs and will cut them in next iterattion. And so on. At the end we will find than no more single leafs exist - we cut all leafs, and when we look into last transaction - we will find those  nodes which were located in center.\\n\\n```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n==1:\\n            return [0]\\n\\n        # prepare empty lists where we will keep connected neighbors, if n=5, we will have 5 lists\\n        nbrs = [[] for i in range(n)] \\n        \\n        # building list of neighbors\\n        for l, r in edges:\\n            nbrs[l].append(r)\\n            nbrs[r].append(l)\\n        \\n        # each iteration we cut all single leafs, they will have only ONE neighbor, \\n        # bcs they are last on branch, here our candidates for the first cut\\n        cut = [i for i, nlist in enumerate(nbrs) if len(nlist)==1]\\n        \\n        #after the cut we will look for nodes which become now single leaf, for now it is empty\\n        new_cut = []\\n        \\n        # continue cutting till some of leafs are available, but should break early\\n        while cut:          \\n            for leaf in cut:\\n                # we visit that one neighbor of single leaf and delete current leaf from stored \\n                # neighbors there, so current leaf will lost his connection.\\n                for nb in nbrs[leaf]:\\n                    nbrs[nb].remove(leaf)\\n                    \\n                    # if after the cut some of neighboars become single, we put them into next cut \\n                    if len(nbrs[nb])==1:\\n                        new_cut.append(nb)\\n                        \\n            # we have cut all leafs, can break, out answer will be in last \"cut\"\\n            if not new_cut:\\n                break\\n            \\n            \\n            cut, new_cut = new_cut, []\\n        return cut\\n            \\n                    \\n                \\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 353261,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) return Collections.singletonList(0);\\n\\n        List<Set<Integer>> adj = new ArrayList<>(n);\\n        for (int i = 0; i < n; ++i) adj.add(new HashSet<>());\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n\\n        List<Integer> leaves = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            if (adj.get(i).size() == 1) leaves.add(i);\\n\\n        while (n > 2) {\\n            n -= leaves.size();\\n            List<Integer> newLeaves = new ArrayList<>();\\n            for (int i : leaves) {\\n                int j = adj.get(i).iterator().next();\\n                adj.get(j).remove(i);\\n                if (adj.get(j).size() == 1) newLeaves.add(j);\\n            }\\n            leaves = newLeaves;\\n        }\\n        return leaves;\\n        }\\n}\\n```\\n\\nRuntime: 23 ms, faster than 54.51% of Java online submissions for Minimum Height Trees.\\nMemory Usage: 50.3 MB, less than 75.00% of Java online submissions for Minimum Height Trees.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) return Collections.singletonList(0);\\n\\n        List<Set<Integer>> adj = new ArrayList<>(n);\\n        for (int i = 0; i < n; ++i) adj.add(new HashSet<>());\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n\\n        List<Integer> leaves = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            if (adj.get(i).size() == 1) leaves.add(i);\\n\\n        while (n > 2) {\\n            n -= leaves.size();\\n            List<Integer> newLeaves = new ArrayList<>();\\n            for (int i : leaves) {\\n                int j = adj.get(i).iterator().next();\\n                adj.get(j).remove(i);\\n                if (adj.get(j).size() == 1) newLeaves.add(j);\\n            }\\n            leaves = newLeaves;\\n        }\\n        return leaves;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351796,
                "title": "java-solution-bfs",
                "content": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n\\tList<Integer> res = new ArrayList<>();\\n\\tif (n == 1) {\\n\\t\\tres.add(0);\\n\\t\\treturn res;\\n\\t}\\n\\n\\tint[] indegree = new int[n];\\n\\tArrayList<Integer>[] adj = new ArrayList[n];\\n\\tfor(int i=0; i<n; i++) \\n\\t\\tadj[i] = new ArrayList<>();\\n\\tfor(int[] edge: edges){\\n\\t\\tadj[edge[0]].add(edge[1]);\\n\\t\\tadj[edge[1]].add(edge[0]);\\n\\t\\tindegree[edge[0]]++;\\n\\t\\tindegree[edge[1]]++;\\n\\t}\\n\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tif(indegree[i] == 1)\\n\\t\\t\\tqueue.offer(i);\\n\\t}\\n\\n\\twhile(!queue.isEmpty()){\\n\\t\\tint size = queue.size();\\n\\t\\tres = new ArrayList<>();\\n\\n\\t\\tfor(int i=0; i<size; i++){\\n\\t\\t\\tint node = queue.poll();\\n\\t\\t\\tres.add(node);\\n\\t\\t\\tfor(int j: adj[node]){\\n\\t\\t\\t\\tindegree[j]--;\\n\\t\\t\\t\\tif(indegree[j] == 1)\\n\\t\\t\\t\\t\\tqueue.offer(j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n    }\\n}\\n        \\n        \\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n\\tList<Integer> res = new ArrayList<>();\\n\\tif (n == 1) {\\n\\t\\tres.add(0);\\n\\t\\treturn res;\\n\\t}\\n\\n\\tint[] indegree = new int[n];\\n\\tArrayList<Integer>[] adj = new ArrayList[n];\\n\\tfor(int i=0; i<n; i++) \\n\\t\\tadj[i] = new ArrayList<>();\\n\\tfor(int[] edge: edges){\\n\\t\\tadj[edge[0]].add(edge[1]);\\n\\t\\tadj[edge[1]].add(edge[0]);\\n\\t\\tindegree[edge[0]]++;\\n\\t\\tindegree[edge[1]]++;\\n\\t}\\n\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tif(indegree[i] == 1)\\n\\t\\t\\tqueue.offer(i);\\n\\t}\\n\\n\\twhile(!queue.isEmpty()){\\n\\t\\tint size = queue.size();\\n\\t\\tres = new ArrayList<>();\\n\\n\\t\\tfor(int i=0; i<size; i++){\\n\\t\\t\\tint node = queue.poll();\\n\\t\\t\\tres.add(node);\\n\\t\\t\\tfor(int j: adj[node]){\\n\\t\\t\\t\\tindegree[j]--;\\n\\t\\t\\t\\tif(indegree[j] == 1)\\n\\t\\t\\t\\t\\tqueue.offer(j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n    }\\n}\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338804,
                "title": "python-bfs",
                "content": "Run time O(N)\\n```\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n <= 1:\\n            return [0]\\n        graph = collections.defaultdict(list)\\n        degree = [0] * n\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            degree[a] += 1\\n            degree[b] += 1\\n        queue = [ n for n in range(n) if degree[n]==1 ]\\n        while queue:\\n            tmp = []\\n            ans = queue\\n            for leaf in queue:\\n                for nei in graph[leaf]:\\n                    degree[nei] -= 1\\n                    if degree[nei] == 1:\\n                        tmp.append(nei)\\n            queue = tmp\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n <= 1:\\n            return [0]\\n        graph = collections.defaultdict(list)\\n        degree = [0] * n\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            degree[a] += 1\\n            degree[b] += 1\\n        queue = [ n for n in range(n) if degree[n]==1 ]\\n        while queue:\\n            tmp = []\\n            ans = queue\\n            for leaf in queue:\\n                for nei in graph[leaf]:\\n                    degree[nei] -= 1\\n                    if degree[nei] == 1:\\n                        tmp.append(nei)\\n            queue = tmp\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 212140,
                "title": "c-bfs-solution",
                "content": "```\\nvector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n\\tif (n == 1) {\\n\\t\\treturn {0};\\n\\t}\\n\\tvector<int> result;\\n\\tvector<vector<int>> graph(n, vector<int>());\\n\\tvector<int> degree(n, 0);\\n\\tqueue<int> leafs;\\n\\n\\tfor (auto item: edges) {\\n\\t\\tgraph[item.first].push_back(item.second);\\n\\t\\tgraph[item.second].push_back(item.first);\\n\\t\\t++ degree[item.first];\\n\\t\\t++ degree[item.second];\\n\\t}\\n\\n\\tfor (int node = 0; node < n; ++ node) {\\n\\t\\tif (degree[node] == 1) {\\n\\t\\t\\tleafs.push(node);\\n\\t\\t}\\n\\t}\\n\\n\\tint left = n;\\n\\twhile (left > 2) {\\n\\t\\tint leaf_size = leafs.size();\\n\\t\\tfor (int i = 0; i < leaf_size; ++ i) {\\n\\t\\t\\tint node = leafs.front();\\n\\t\\t\\tleafs.pop();\\n\\t\\t\\t-- left;\\n\\t\\t\\tfor (auto peer_node : graph[node]) {\\n\\t\\t\\t\\t-- degree[peer_node];\\n\\t\\t\\t\\tif (degree[peer_node] == 1) {\\n\\t\\t\\t\\t\\tleafs.push(peer_node);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\twhile (!leafs.empty()) {\\n\\t\\tresult.push_back(leafs.front());\\n\\t\\tleafs.pop();\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n\\tif (n == 1) {\\n\\t\\treturn {0};\\n\\t}\\n\\tvector<int> result;\\n\\tvector<vector<int>> graph(n, vector<int>());\\n\\tvector<int> degree(n, 0);\\n\\tqueue<int> leafs;\\n\\n\\tfor (auto item: edges) {\\n\\t\\tgraph[item.first].push_back(item.second);\\n\\t\\tgraph[item.second].push_back(item.first);\\n\\t\\t++ degree[item.first];\\n\\t\\t++ degree[item.second];\\n\\t}\\n\\n\\tfor (int node = 0; node < n; ++ node) {\\n\\t\\tif (degree[node] == 1) {\\n\\t\\t\\tleafs.push(node);\\n\\t\\t}\\n\\t}\\n\\n\\tint left = n;\\n\\twhile (left > 2) {\\n\\t\\tint leaf_size = leafs.size();\\n\\t\\tfor (int i = 0; i < leaf_size; ++ i) {\\n\\t\\t\\tint node = leafs.front();\\n\\t\\t\\tleafs.pop();\\n\\t\\t\\t-- left;\\n\\t\\t\\tfor (auto peer_node : graph[node]) {\\n\\t\\t\\t\\t-- degree[peer_node];\\n\\t\\t\\t\\tif (degree[peer_node] == 1) {\\n\\t\\t\\t\\t\\tleafs.push(peer_node);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\twhile (!leafs.empty()) {\\n\\t\\tresult.push_back(leafs.front());\\n\\t\\tleafs.pop();\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130048,
                "title": "logical-thinking-with-clear-java-code",
                "content": "We can\\'t tell which nodes can be roots in the beginning, however, we can tell the leaf nodes for the number of edges connecting to them must be 1.\\nWe build the undirected graph first with the help of `outNodes` and `inDegree`.\\nLike BFS implementation of Topological Sort, we start with those leaf nodes, update the number of edges connecting to its adjacent nodes, and remove those leaf nodes. We keep removing the node whoes indegree is 1.\\nWe update `roots` in each level, the last one remained will be the result list. Please note that `java.util.ConcurrentModificationException` will occur if we use list.remove() during the iteration. Instead, we use `iterator.remove();`. In fact, we don\\'t really need to remove those \\'leaf nodes\\'. However, to make the code clear, I still do the removal in the code as below:\\n```\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 0 || edges == null || edges.length == 0) {\\n            List<Integer> result = new ArrayList<>();\\n            result.add(0);\\n            return result;\\n        }\\n        Map<Integer, List<Integer>> outNodes = new HashMap<>(); \\n        int[] inDegree = new int[n]; \\n        buildGraph(n, edges, outNodes, inDegree);\\n        return topologicalSort(outNodes, inDegree);\\n    }\\n\\n    private void buildGraph(int n, int[][] edges, Map<Integer, List<Integer>> outNodes, int[] inDegree) {\\n        for (int i = 0; i < n; i++) {\\n            outNodes.put(i, new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            outNodes.get(edge[0]).add(edge[1]);\\n            inDegree[edge[0]]++;\\n            outNodes.get(edge[1]).add(edge[0]);\\n            inDegree[edge[1]]++;\\n        }\\n    }\\n\\n    private List<Integer> topologicalSort(Map<Integer, List<Integer>> outNodes, int[] inDegree) {\\n        List<Integer> roots = new ArrayList<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < inDegree.length; i++) {\\n            if (inDegree[i] == 1) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        Iterator<Integer> iterator;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            roots = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                roots.add(node);\\n                iterator = outNodes.get(node).iterator();\\n                while (iterator.hasNext()) {\\n                    int adjNode = iterator.next();\\n                    inDegree[adjNode]--;\\n                    iterator.remove();\\n                    if (inDegree[adjNode] == 1) {\\n                        queue.add(adjNode);\\n                    }\\n                }\\n            }\\n        }\\n        return roots;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 0 || edges == null || edges.length == 0) {\\n            List<Integer> result = new ArrayList<>();\\n            result.add(0);\\n            return result;\\n        }\\n        Map<Integer, List<Integer>> outNodes = new HashMap<>(); \\n        int[] inDegree = new int[n]; \\n        buildGraph(n, edges, outNodes, inDegree);\\n        return topologicalSort(outNodes, inDegree);\\n    }\\n\\n    private void buildGraph(int n, int[][] edges, Map<Integer, List<Integer>> outNodes, int[] inDegree) {\\n        for (int i = 0; i < n; i++) {\\n            outNodes.put(i, new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            outNodes.get(edge[0]).add(edge[1]);\\n            inDegree[edge[0]]++;\\n            outNodes.get(edge[1]).add(edge[0]);\\n            inDegree[edge[1]]++;\\n        }\\n    }\\n\\n    private List<Integer> topologicalSort(Map<Integer, List<Integer>> outNodes, int[] inDegree) {\\n        List<Integer> roots = new ArrayList<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < inDegree.length; i++) {\\n            if (inDegree[i] == 1) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        Iterator<Integer> iterator;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            roots = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                roots.add(node);\\n                iterator = outNodes.get(node).iterator();\\n                while (iterator.hasNext()) {\\n                    int adjNode = iterator.next();\\n                    inDegree[adjNode]--;\\n                    iterator.remove();\\n                    if (inDegree[adjNode] == 1) {\\n                        queue.add(adjNode);\\n                    }\\n                }\\n            }\\n        }\\n        return roots;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76075,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Minimum Height Trees** https://leetcode.com/problems/minimum-height-trees/\\n\\n* The discuss posts are super helpful.\\n* Brute force would be to try every node and find its height. This is N^2 solution.\\n* Minimum height tree is rooted at the mid point of the longest path in the tree.\\n* Here is one insight for this problem: the root of MHT is the middle point of the longest path in the tree; hence there are at most two MHT roots.\\n* How to find them? We can BFS from the bottom (leaves) to the top until the last level with <=2 nodes. To build the current level from the previous level, we can monitor the degree of each node. If the node has degree of one, it will be added to the current level. Since it only check the edges once, the complexity is O(n). \\n* Remember a tree has n nodes and n-1 edges.\\n* https://discuss.leetcode.com/topic/30572/share-some-thoughts\\n\\n```\\nclass Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        degree = {k:0 for k in range(n)}\\n        graph = {k:set([]) for k in range(n)}\\n        for edge in edges:\\n            u,v = edge[0], edge[1]\\n            degree[u], degree[v] = degree[u]+1, degree[v]+1\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        leaves = [k for k,v in degree.items() if v == 1]\\n        while leaves and len(graph) > 2:\\n            for leaf in leaves:\\n                v = graph[leaf].pop()\\n                del graph[leaf]\\n                del degree[leaf]\\n                degree[v] -= 1\\n                graph[v].remove(leaf)\\n            leaves = [k for k,v in degree.items() if v == 1]\\n        return list(graph.keys())\\n```\\n\\n**How will you find the longest path in a tree?**\\n* Randomly select any node in the tree and find the longest path from that node. Use DFS to do that. Let the terminal node be x.\\n* x must be the end-point of the true longest path in the tree.\\n* Run DFS/BFS from x to find the real longest path in the tree.\\n* Minimum height tree is rooted at the mid point of this longest path. There can be atmost 2 mid-points or two roots.\\n* https://www.quora.com/How-does-following-algorithm-for-finding-longest-path-in-tree-work\\n* https://discuss.leetcode.com/topic/30956/two-o-n-solutions",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        degree = {k:0 for k in range(n)}\\n        graph = {k:set([]) for k in range(n)}\\n        for edge in edges:\\n            u,v = edge[0], edge[1]\\n            degree[u], degree[v] = degree[u]+1, degree[v]+1\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        leaves = [k for k,v in degree.items() if v == 1]\\n        while leaves and len(graph) > 2:\\n            for leaf in leaves:\\n                v = graph[leaf].pop()\\n                del graph[leaf]\\n                del degree[leaf]\\n                degree[v] -= 1\\n                graph[v].remove(leaf)\\n            leaves = [k for k,v in degree.items() if v == 1]\\n        return list(graph.keys())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76111,
                "title": "c-120-ms-topological-sort",
                "content": "  Based on \\n  https://leetcode.com/discuss/88737/sharing-my-c-solution-using-the-idea-of-topological-sort\\n   ```\\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        vector<int> ans;\\n        if(!n)\\n           return ans;\\n        if(n == 1)\\n        {\\n            ans.push_back(0);\\n            return ans;\\n        }\\n        vector<unordered_set<int>> v(n);\\n        for(int i = 0; i < edges.size();++i)\\n        {\\n           v[edges[i].first].insert(edges[i].second);\\n           v[edges[i].second].insert(edges[i].first);\\n        }\\n        vector<int> leaves;\\n        for(int i = 0; i < n; ++i)\\n           if(v[i].size() == 1)\\n              leaves.push_back(i);\\n        while(true)\\n        {\\n            vector<int> newleaves;\\n            for(int l : leaves)\\n            {\\n                 for(int i : v[l])\\n                 {\\n                     v[i].erase(l);\\n                     if(v[i].size() == 1)\\n                        newleaves.push_back(i);\\n                 }\\n            }\\n            if(newleaves.size() == 0)\\n               return leaves;\\n            leaves = newleaves;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n        vector<int> ans;\\n        if(!n)\\n           return ans;\\n        if(n == 1)\\n        {\\n            ans.push_back(0);\\n            return ans;\\n        }\\n        vector<unordered_set<int>> v(n);\\n        for(int i = 0; i < edges.size();++i)\\n        {\\n           v[edges[i].first].insert(edges[i].second);\\n           v[edges[i].second].insert(edges[i].first);\\n        }\\n        vector<int> leaves;\\n        for(int i = 0; i < n; ++i)\\n           if(v[i].size() == 1)\\n              leaves.push_back(i);\\n        while(true)\\n        {\\n            vector<int> newleaves;\\n            for(int l : leaves)\\n            {\\n                 for(int i : v[l])\\n                 {\\n                     v[i].erase(l);\\n                     if(v[i].size() == 1)\\n                        newleaves.push_back(i);\\n                 }\\n            }\\n            if(newleaves.size() == 0)\\n               return leaves;\\n            leaves = newleaves;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76122,
                "title": "sharing-my-c-solution-using-the-idea-of-topological-sort",
                "content": "    class Solution {\\n    public:\\n        vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n            if(n==1)\\n                return vector<int>(1, 0);\\n                \\n            vector<unordered_set<int>> myConnections(n);\\n            int N = edges.size(), i;\\n            int first, second;\\n            for(i=0; i<N; i++)\\n            {\\n                first = edges[i].first;\\n                second = edges[i].second;\\n                myConnections[first].insert(second);\\n                myConnections[second].insert(first);\\n            }\\n            \\n            vector<int> current;\\n            for(i=0; i<n; i++)\\n                if(myConnections[i].size()==1)\\n                    current.push_back(i);\\n                    \\n            while(true)\\n            {\\n                vector<int> next;\\n                for(int iCurrent : current)\\n                    for(int iNext : myConnections[iCurrent])\\n                    {\\n                        if(myConnections[iNext].erase(iCurrent));\\n                        if(myConnections[iNext].size()==1)\\n                            next.push_back(iNext);\\n                    }\\n                    \\n                if(next.size()==0)\\n                    return current;\\n                else\\n                    current = next;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\\n            if(n==1)\\n                return vector<int>(1, 0);\\n                \\n            vector<unordered_set<int>> myConnections(n);\\n            int N = edges.size(), i;\\n            int first, second;\\n            for(i=0; i<N; i++)\\n            {\\n                first = edges[i].first;\\n                second = edges[i].second;\\n                myConnections[first].insert(second);\\n                myConnections[second].insert(first);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3799316,
                "title": "c-solution-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==0) return {};\\n        if(n==1) return {0};\\n        if(n==2) return {0,1};\\n         vector<vector<int>> graph(n);\\n        vector<int> degree(n,0);\\n        vector<int> res;\\n        for(auto &edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++) {\\n            if(degree[i] == 1) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            res.clear();\\n            int sz = q.size();\\n            \\n            while(sz--) {\\n                int u = q.front();\\n                q.pop();\\n                res.push_back(u);\\n\\n                for(auto v: graph[u]) {\\n                    if(--degree[v] == 1) \\n                        q.push(v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==0) return {};\\n        if(n==1) return {0};\\n        if(n==2) return {0,1};\\n         vector<vector<int>> graph(n);\\n        vector<int> degree(n,0);\\n        vector<int> res;\\n        for(auto &edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++) {\\n            if(degree[i] == 1) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            res.clear();\\n            int sz = q.size();\\n            \\n            while(sz--) {\\n                int u = q.front();\\n                q.pop();\\n                res.push_back(u);\\n\\n                for(auto v: graph[u]) {\\n                    if(--degree[v] == 1) \\n                        q.push(v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586219,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)\\n     {\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n, 0), ans; \\n        for(auto &e : edges)\\n        {   \\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n;i++)\\n        {\\n            if(indegree[i]==1) q.push(i), indegree[i]--; \\n        } \\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            ans.clear();\\n            for(int i=0; i<s;i++)\\n            {\\n                int curr = q.front(); q.pop();\\n                ans.push_back(curr);\\n                for(auto child : graph[curr])\\n                { \\n                    indegree[child]--;\\n                    if(indegree[child]==1) q.push(child);   \\n                }\\n            }\\n        }\\n        if(n==1) ans.push_back(0);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)\\n     {\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n, 0), ans; \\n        for(auto &e : edges)\\n        {   \\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n;i++)\\n        {\\n            if(indegree[i]==1) q.push(i), indegree[i]--; \\n        } \\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            ans.clear();\\n            for(int i=0; i<s;i++)\\n            {\\n                int curr = q.front(); q.pop();\\n                ans.push_back(curr);\\n                for(auto child : graph[curr])\\n                { \\n                    indegree[child]--;\\n                    if(indegree[child]==1) q.push(child);   \\n                }\\n            }\\n        }\\n        if(n==1) ans.push_back(0);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586214,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)\\n     {\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n, 0), ans; \\n        for(auto &e : edges)\\n        {   \\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n;i++)\\n        {\\n            if(indegree[i]==1) q.push(i), indegree[i]--; \\n        } \\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            ans.clear();\\n            for(int i=0; i<s;i++)\\n            {\\n                int curr = q.front(); q.pop();\\n                ans.push_back(curr);\\n                for(auto child : graph[curr])\\n                { \\n                    indegree[child]--;\\n                    if(indegree[child]==1) q.push(child);   \\n                }\\n            }\\n        }\\n        if(n==1) ans.push_back(0);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)\\n     {\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n, 0), ans; \\n        for(auto &e : edges)\\n        {   \\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n;i++)\\n        {\\n            if(indegree[i]==1) q.push(i), indegree[i]--; \\n        } \\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            ans.clear();\\n            for(int i=0; i<s;i++)\\n            {\\n                int curr = q.front(); q.pop();\\n                ans.push_back(curr);\\n                for(auto child : graph[curr])\\n                { \\n                    indegree[child]--;\\n                    if(indegree[child]==1) q.push(child);   \\n                }\\n            }\\n        }\\n        if(n==1) ans.push_back(0);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400076,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nidea is that we have to find the middle node of the longest leaf-to-leaf path in the given graph. that middle node is the only candidate for MHT.\\n\\nthere can only be at most two node such that when rooted graph becomes MHT.\\n\\n## so how do we find the middle node in the longest path ?\\nwe do a bfs where in the queue we maintain all the leaf nodes.\\nat each iteration we remove those nodes and adjust the indegree of their adjacent nodes . is adjacent node becomes leaf we add it to queue.\\nwe keep doing this till size of the reduced graph is > 2 \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(size(edges)==0)return {0}; //just a base case\\n        //create graph\\n        vector<vector<int>> g(n);\\n        for(auto ed : edges){\\n            g[ed[0]].push_back(ed[1]);\\n            g[ed[1]].push_back(ed[0]);\\n        }\\n\\n        vector<int> indegree(n, 0); //store indegree of each node\\n        vector<bool> vis(n, 0); //visited vector\\n        queue<int> q;\\n    //adjust indegree and add leafs to queue;\\n        for(int i=0; i<n; i++){\\n            if(g[i].size() == 1){\\n                q.push(i);\\n                vis[i] = true;\\n            }\\n            indegree[i] = g[i].size();\\n        }\\n        //loop till size of reduced graph is > 2\\n        while(n > 2){\\n            int sz = q.size();\\n            n-=sz; //updating the size of graph\\n            while(sz--){\\n                auto node = q.front();q.pop();\\n                for(auto ch : g[node]){ //go to child and update indegree\\n                    if(vis[ch])continue;\\n                    indegree[ch]--;\\n                    if(indegree[ch] == 1){ //child becomes leaf add to queue\\n                        vis[ch] = true;\\n                        q.push(ch);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        while(q.size()){\\n            ans.push_back(q.front());\\n            q.pop();\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(size(edges)==0)return {0}; //just a base case\\n        //create graph\\n        vector<vector<int>> g(n);\\n        for(auto ed : edges){\\n            g[ed[0]].push_back(ed[1]);\\n            g[ed[1]].push_back(ed[0]);\\n        }\\n\\n        vector<int> indegree(n, 0); //store indegree of each node\\n        vector<bool> vis(n, 0); //visited vector\\n        queue<int> q;\\n    //adjust indegree and add leafs to queue;\\n        for(int i=0; i<n; i++){\\n            if(g[i].size() == 1){\\n                q.push(i);\\n                vis[i] = true;\\n            }\\n            indegree[i] = g[i].size();\\n        }\\n        //loop till size of reduced graph is > 2\\n        while(n > 2){\\n            int sz = q.size();\\n            n-=sz; //updating the size of graph\\n            while(sz--){\\n                auto node = q.front();q.pop();\\n                for(auto ch : g[node]){ //go to child and update indegree\\n                    if(vis[ch])continue;\\n                    indegree[ch]--;\\n                    if(indegree[ch] == 1){ //child becomes leaf add to queue\\n                        vis[ch] = true;\\n                        q.push(ch);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        while(q.size()){\\n            ans.push_back(q.front());\\n            q.pop();\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382379,
                "title": "simple-c-bfs-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1) return {0};\\n        vector<int>adj[n];\\n        vector<int>degree(n,0);\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            degree[it[0]]++;\\n            degree[it[1]]++;\\n        }\\n\\n        queue<int>q;\\n        for(int i=0;i<n;i++) if(degree[i]==1) q.push(i);\\n        vector<int>res;\\n        while(!q.empty()){\\n            int si = q.size();\\n            res.clear();\\n            while(si--){\\n                auto temp = q.front();\\n                q.pop();\\n                res.push_back(temp);\\n\\n                for(auto it : adj[temp]){\\n                    degree[it]--;\\n                    if(degree[it]==1) q.push(it);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1) return {0};\\n        vector<int>adj[n];\\n        vector<int>degree(n,0);\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            degree[it[0]]++;\\n            degree[it[1]]++;\\n        }\\n\\n        queue<int>q;\\n        for(int i=0;i<n;i++) if(degree[i]==1) q.push(i);\\n        vector<int>res;\\n        while(!q.empty()){\\n            int si = q.size();\\n            res.clear();\\n            while(si--){\\n                auto temp = q.front();\\n                q.pop();\\n                res.push_back(temp);\\n\\n                for(auto it : adj[temp]){\\n                    degree[it]--;\\n                    if(degree[it]==1) q.push(it);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355811,
                "title": "python-dfs-naive-and-bfs-topological-solutions-comparison-solved",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Solution 1: DFS (Naive Approach)\\n\\nThis solution is relatively straightforward. A representation of the tree/graph is created using a hashmap. Iterating through ALL nodes, a dfs recursive search is performed on EACH node. This means each node will be treated as the \\'root\\', and all heights are calculated. The minimum height(s) are then picked out and the respective nodes selected.\\n\\nHowever, this WILL result in TLE as with a growing number of nodes and connections, the number of paths grows exponentially. \\n\\nThis is the solution which technically works, but will NOT pass in Leetcode.\\n\\n### Solution 2: BFS (Topological)\\n\\nI will not delve into a detailed explanation for the preferred solution, as it has been well explained by numerous other users. Here I will break down the solution into the component steps, as well as highlight important points along the way.\\n\\n1. 2 nodes are the smallest possible \\'set\\' where it is not meaningful to trim any more leaves. this would be the \\'base case\\'\\n2. create a representation of the tree using a hashmap\\n3. construct the first layer of leaves. leaves will have only 1 edge connection\\n4. outer while loop which runs until only 2 nodes are left, the base case. \\n5. create a store for the next layer of leaves to be constructed\\n6. inner while loop which runs and does two things (IMPT: must be done in sequence)\\n    1. remove leaf-neighbour edge from current leaf\\n    2. create new leaf layer from the neighbours\\n7. reassign the new leaf layer\\n\\nThis will trim the leaves layer by layer until either 1 or 2 nodes are left in which case both would be the solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nDFS: $$O(n^2)$$\\nBFS: $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDFS: $$O(n.m)$$\\nBFS: $$O(n.m)$$\\n\\n# Code\\n### Solution 1: DFS (Naive Approach)\\n```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\n        # represent the nodes and edges in a graph using a hashmap\\n        graph = { i: [] for i in range(n) }\\n\\n        for edge in edges:\\n            node1, node2 = edge\\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n\\n        visited = set()\\n        heights = defaultdict(int)\\n        # dfs recursive function, dive into the tree from each node, and determine the heights of the trees from each node chosen as the root\\n        def dfs(node, parent, count, visited):\\n            heights[parent] = max(heights[parent], count)\\n            # dfs through the connections\\n            for c in graph[node]:\\n                if c not in visited:\\n                    visited.add(node)\\n                    dfs(c, parent, count + 1, visited)\\n                    # node has to be removed \\'backtracking\\' to progress to the other child node from parent\\n                    visited.remove(node)\\n\\n        for node in graph:\\n            dfs(node, node, 0, visited)\\n\\n        # global minimum height\\n        min_height = min(heights.values())\\n        output = []\\n\\n        for k, v in heights.items():\\n            if v == min_height:\\n                output.append(k)\\n\\n        return output\\n```\\n\\n### Solution 2: BFS (Topological)\\n```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\n        # edge case where the nodes are already reduced to the smallest possible set\\n        if n < 3:\\n            return [i for i in range(n)]\\n\\n        # represent the nodes and edges in a graph using a hashmap\\n        graph = {i: [] for i in range(n)}\\n\\n        for node1, node2 in edges:\\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n\\n        # populate the first leaf layer\\n        leaves = []\\n        for node in graph:\\n            # leaves will only have one connection\\n            if len(graph[node]) == 1:\\n                leaves.append(node)\\n\\n        # outer while loop runs until only two nodes left as leaves are removed\\n        while n > 2:\\n            n -= len(leaves)\\n            # store next layer of leaves which will be constructed in inner while loop\\n            next_leaves_layer = []\\n            while leaves:\\n                leaf = leaves.pop()\\n                # 1. remove leaf-neighbour edges\\n                neighbour = graph[leaf].pop()\\n                neighbour_connections = graph[neighbour]\\n                neighbour_connections.remove(leaf)\\n                # 2. create new leaf layer from neighbour\\n                if len(neighbour_connections) == 1:\\n                    next_leaves_layer.append(neighbour)\\n            # reassign next layer to \\'leaves\\'\\n            leaves = next_leaves_layer\\n        \\n        return leaves\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\n        # represent the nodes and edges in a graph using a hashmap\\n        graph = { i: [] for i in range(n) }\\n\\n        for edge in edges:\\n            node1, node2 = edge\\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n\\n        visited = set()\\n        heights = defaultdict(int)\\n        # dfs recursive function, dive into the tree from each node, and determine the heights of the trees from each node chosen as the root\\n        def dfs(node, parent, count, visited):\\n            heights[parent] = max(heights[parent], count)\\n            # dfs through the connections\\n            for c in graph[node]:\\n                if c not in visited:\\n                    visited.add(node)\\n                    dfs(c, parent, count + 1, visited)\\n                    # node has to be removed \\'backtracking\\' to progress to the other child node from parent\\n                    visited.remove(node)\\n\\n        for node in graph:\\n            dfs(node, node, 0, visited)\\n\\n        # global minimum height\\n        min_height = min(heights.values())\\n        output = []\\n\\n        for k, v in heights.items():\\n            if v == min_height:\\n                output.append(k)\\n\\n        return output\\n```\n```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n\\n        # edge case where the nodes are already reduced to the smallest possible set\\n        if n < 3:\\n            return [i for i in range(n)]\\n\\n        # represent the nodes and edges in a graph using a hashmap\\n        graph = {i: [] for i in range(n)}\\n\\n        for node1, node2 in edges:\\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n\\n        # populate the first leaf layer\\n        leaves = []\\n        for node in graph:\\n            # leaves will only have one connection\\n            if len(graph[node]) == 1:\\n                leaves.append(node)\\n\\n        # outer while loop runs until only two nodes left as leaves are removed\\n        while n > 2:\\n            n -= len(leaves)\\n            # store next layer of leaves which will be constructed in inner while loop\\n            next_leaves_layer = []\\n            while leaves:\\n                leaf = leaves.pop()\\n                # 1. remove leaf-neighbour edges\\n                neighbour = graph[leaf].pop()\\n                neighbour_connections = graph[neighbour]\\n                neighbour_connections.remove(leaf)\\n                # 2. create new leaf layer from neighbour\\n                if len(neighbour_connections) == 1:\\n                    next_leaves_layer.append(neighbour)\\n            # reassign next layer to \\'leaves\\'\\n            leaves = next_leaves_layer\\n        \\n        return leaves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143365,
                "title": "topological-sort-indegree",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1) return {0};\\n          vector<vector<int>>adj(n,vector<int>());\\n        vector<int>indegree(n,0);\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n            indegree[x[0]]++;\\n            indegree[x[1]]++;\\n        }\\n        vector<int>res;\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==1) q.push(i);\\n        }\\n        while(q.empty()==false)\\n        {\\n            int sz=q.size();\\n           // res.empty();\\n            res.clear();\\n            for(int i=0;i<sz;i++)\\n            {\\n                auto curr=q.front();\\n                q.pop();\\n                res.push_back(curr);\\n                for(auto x:adj[curr])\\n                {\\n                    indegree[x]--;\\n                    if(indegree[x]==1) q.push(x);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n==1) return {0};\\n          vector<vector<int>>adj(n,vector<int>());\\n        vector<int>indegree(n,0);\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n            indegree[x[0]]++;\\n            indegree[x[1]]++;\\n        }\\n        vector<int>res;\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==1) q.push(i);\\n        }\\n        while(q.empty()==false)\\n        {\\n            int sz=q.size();\\n           // res.empty();\\n            res.clear();\\n            for(int i=0;i<sz;i++)\\n            {\\n                auto curr=q.front();\\n                q.pop();\\n                res.push_back(curr);\\n                for(auto x:adj[curr])\\n                {\\n                    indegree[x]--;\\n                    if(indegree[x]==1) q.push(x);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677980,
                "title": "python-linear-time-solution-using-topological-sorting",
                "content": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1: return [0]\\n        adj = defaultdict(list)\\n        for edge in edges:\\n            adj[edge[0]].append(edge[1])\\n            adj[edge[1]].append(edge[0])\\n        queue, degrees = [], {}\\n        for node, neighbors in adj.items():\\n            degrees[node] = len(neighbors)\\n            # Insert all leaves into our priority queue.\\n            if degrees[node] == 1:\\n                queue.append(node)\\n        ans = []\\n        while queue:\\n            nodes = []\\n            while queue:\\n                nodes.append(queue.pop())\\n            ans = nodes\\n            for node in nodes:\\n                degrees[node] -= 1\\n                for neighbor in adj[node]:\\n                    degrees[neighbor] -= 1\\n                    if degrees[neighbor] == 1:\\n                        queue.append(neighbor)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1: return [0]\\n        adj = defaultdict(list)\\n        for edge in edges:\\n            adj[edge[0]].append(edge[1])\\n            adj[edge[1]].append(edge[0])\\n        queue, degrees = [], {}\\n        for node, neighbors in adj.items():\\n            degrees[node] = len(neighbors)\\n            # Insert all leaves into our priority queue.\\n            if degrees[node] == 1:\\n                queue.append(node)\\n        ans = []\\n        while queue:\\n            nodes = []\\n            while queue:\\n                nodes.append(queue.pop())\\n            ans = nodes\\n            for node in nodes:\\n                degrees[node] -= 1\\n                for neighbor in adj[node]:\\n                    degrees[neighbor] -= 1\\n                    if degrees[neighbor] == 1:\\n                        queue.append(neighbor)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444530,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using BFS***\\n\\n* ***Time Complexity :- O(V + E)***\\n\\n* ***Space Complexity :- O(V + E)***\\n\\n* ***At most 2 MHT is possible***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        // if there is only one node then 0 will be root of MHT\\n        \\n        if(n == 1)\\n            return {0};\\n        \\n        // make a adjacency list\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        // find the indegree of every node\\n        \\n        vector<int> indegree(n, 0);\\n        \\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int u = edges[i][0];\\n            \\n            int v = edges[i][1];\\n            \\n            adj[u].push_back(v);\\n            \\n            adj[v].push_back(u);\\n            \\n            indegree[u]++;\\n            \\n            indegree[v]++;\\n        }\\n        \\n        // push the node with indegree 1 into queue\\n        \\n        queue<int> q;\\n        \\n        for(int u = 0; u < n; u++)\\n        {\\n            if(indegree[u] == 1)\\n            {\\n               q.push(u);\\n            }\\n        }\\n        \\n        // run the loop while there is more than 2 node present\\n        \\n        while(n > 2)\\n        {\\n            int size = q.size();\\n            \\n            // remove the size no. of node from graph\\n            \\n            n = n - size;\\n            \\n            for(int i = 0; i < size; i++)\\n            {\\n                // take the front node\\n                \\n                int u = q.front();\\n                \\n                q.pop();\\n                \\n                // decrement the indegree of adjacent node\\n                \\n                for(auto v : adj[u])\\n                {\\n                    indegree[v]--;\\n                    \\n                    // if indegree becomes 1, then push into the queue\\n                    \\n                    if(indegree[v] == 1)\\n                    {\\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // remaining node will be the root of MHT\\n        \\n        vector<int> res;\\n        \\n        while(!q.empty())\\n        {\\n            res.push_back(q.front());\\n            \\n            q.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        // if there is only one node then 0 will be root of MHT\\n        \\n        if(n == 1)\\n            return {0};\\n        \\n        // make a adjacency list\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        // find the indegree of every node\\n        \\n        vector<int> indegree(n, 0);\\n        \\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int u = edges[i][0];\\n            \\n            int v = edges[i][1];\\n            \\n            adj[u].push_back(v);\\n            \\n            adj[v].push_back(u);\\n            \\n            indegree[u]++;\\n            \\n            indegree[v]++;\\n        }\\n        \\n        // push the node with indegree 1 into queue\\n        \\n        queue<int> q;\\n        \\n        for(int u = 0; u < n; u++)\\n        {\\n            if(indegree[u] == 1)\\n            {\\n               q.push(u);\\n            }\\n        }\\n        \\n        // run the loop while there is more than 2 node present\\n        \\n        while(n > 2)\\n        {\\n            int size = q.size();\\n            \\n            // remove the size no. of node from graph\\n            \\n            n = n - size;\\n            \\n            for(int i = 0; i < size; i++)\\n            {\\n                // take the front node\\n                \\n                int u = q.front();\\n                \\n                q.pop();\\n                \\n                // decrement the indegree of adjacent node\\n                \\n                for(auto v : adj[u])\\n                {\\n                    indegree[v]--;\\n                    \\n                    // if indegree becomes 1, then push into the queue\\n                    \\n                    if(indegree[v] == 1)\\n                    {\\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // remaining node will be the root of MHT\\n        \\n        vector<int> res;\\n        \\n        while(!q.empty())\\n        {\\n            res.push_back(q.front());\\n            \\n            q.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389330,
                "title": "c-easy-to-understand-using-indegree-bfs",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tif(n == 1) {ans.push_back(0); return ans;}\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tvector<int> indegree(n,0);\\n\\t\\t\\tfor(int i = 0 ; i < edges.size() ;  i++){\\n\\t\\t\\t\\tadj[edges[i][0]].push_back(edges[i][1]);\\n\\t\\t\\t\\tadj[edges[i][1]].push_back(edges[i][0]);\\n\\t\\t\\t\\tindegree[edges[i][0]]++;\\n\\t\\t\\t\\tindegree[edges[i][1]]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tfor(int i = 0 ; i < indegree.size() ; i++) if(indegree[i] == 1) q.push(i);\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tans.clear();\\n\\t\\t\\t\\tint s = q.size();\\n\\t\\t\\t\\tfor(int i = 0 ; i < s ; i++){\\n\\t\\t\\t\\t\\tint curr = q.front() ; q.pop();\\n\\t\\t\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\t\\tfor(auto it : adj[curr]){\\n\\t\\t\\t\\t\\t\\tindegree[it]--;\\n\\t\\t\\t\\t\\t\\tif(indegree[it] == 1) q.push(it);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tif(n == 1) {ans.push_back(0); return ans;}",
                "codeTag": "Java"
            },
            {
                "id": 2334677,
                "title": "c-using-2-dfs-diameter-and-path-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        //constructing graph\\n        vector<vector<int>> adj(n+1, vector<int>());\\n        for(int i=0;i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        //starting DFS with random node(for finding diameter)\\n        vector<int> depth(n+1, 0), parent(n+1, 0);\\n        dfs(adj,depth, parent, 0);\\n        \\n        int max_depth = INT_MIN, max_depth_node;\\n        for(int i=0;i<n;i++){\\n            if(depth[i] > max_depth){\\n                max_depth = depth[i];\\n                max_depth_node = i;\\n            }\\n            depth[i] = 0;\\n            parent[i] = 0;\\n        }\\n        //starting DFS second time\\n        dfs(adj, depth, parent, max_depth_node);\\n        \\n        max_depth = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(depth[i] > max_depth){\\n                max_depth = depth[i];\\n                max_depth_node = i;\\n            }\\n        }\\n        \\n        //backtracking for forming path\\n        vector<int> path(max_depth+1);\\n        int temp = max_depth;\\n        while(max_depth != -1){\\n            path[max_depth] = max_depth_node;\\n            max_depth_node = parent[max_depth_node];\\n            max_depth--;\\n        }\\n        \\n        vector<int> ans;\\n        ans.push_back(path[temp/2]);\\n        if(temp%2){   \\n            ans.push_back(path[(temp+1)/2]);\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<int>& depth, vector<int> &parent, int node, int par = -1){\\n        for(auto child: adj[node]){\\n            if(child == par) continue;\\n            depth[child] = depth[node]+1;\\n            parent[child] = node;\\n            dfs(adj, depth, parent, child, node);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        //constructing graph\\n        vector<vector<int>> adj(n+1, vector<int>());\\n        for(int i=0;i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        //starting DFS with random node(for finding diameter)\\n        vector<int> depth(n+1, 0), parent(n+1, 0);\\n        dfs(adj,depth, parent, 0);\\n        \\n        int max_depth = INT_MIN, max_depth_node;\\n        for(int i=0;i<n;i++){\\n            if(depth[i] > max_depth){\\n                max_depth = depth[i];\\n                max_depth_node = i;\\n            }\\n            depth[i] = 0;\\n            parent[i] = 0;\\n        }\\n        //starting DFS second time\\n        dfs(adj, depth, parent, max_depth_node);\\n        \\n        max_depth = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(depth[i] > max_depth){\\n                max_depth = depth[i];\\n                max_depth_node = i;\\n            }\\n        }\\n        \\n        //backtracking for forming path\\n        vector<int> path(max_depth+1);\\n        int temp = max_depth;\\n        while(max_depth != -1){\\n            path[max_depth] = max_depth_node;\\n            max_depth_node = parent[max_depth_node];\\n            max_depth--;\\n        }\\n        \\n        vector<int> ans;\\n        ans.push_back(path[temp/2]);\\n        if(temp%2){   \\n            ans.push_back(path[(temp+1)/2]);\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<int>& depth, vector<int> &parent, int node, int par = -1){\\n        for(auto child: adj[node]){\\n            if(child == par) continue;\\n            depth[child] = depth[node]+1;\\n            parent[child] = node;\\n            dfs(adj, depth, parent, child, node);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267121,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& pre) {\\n        vector<int>res;\\n        if(n<2){\\n            for(int i=0;i<n;i++) res.push_back(i);\\n            \\n            return res;\\n        }\\n        vector<vector<int>>adj(n);\\n        vector<int>indegree(n,0);\\n        for(auto it:pre){\\n            adj[it[1]].push_back(it[0]);\\n            adj[it[0]].push_back(it[1]);\\n            indegree[it[0]]++;\\n            indegree[it[1]]++;\\n        }\\n        \\n        \\n        queue<int>q;\\n        for(int i=0;i<indegree.size();i++){\\n            if(indegree[i]==1){\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            res.clear();\\n            for(int i=0;i<size;i++){\\n                int node = q.front();\\n                q.pop();\\n                res.push_back(node);\\n                for(auto it:adj[node]){\\n                    indegree[it]--;\\n                    if(indegree[it]==1){\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& pre) {\\n        vector<int>res;\\n        if(n<2){\\n            for(int i=0;i<n;i++) res.push_back(i);\\n            \\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2238567,
                "title": "java-topological-sort",
                "content": "I don\\'t think this solution comes naturally unless you\\'ve been fiddling with topological sort for some time. DFS/BFS solution is more intuitive.\\n\\nLC solution talks about centroids an others, but for me the thought process was if we move from leaves up layer by layer, then the last layer should contain all root candidates. Going from \\'leaves\\' up is equivalent to a topological sort.\\n\\nWhat I found tricky was understanding how to apply it since the graph is undirected. Usually topological sort problems are directed graphs so that threw me off.\\n\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            int v = e[0], u = e[1];\\n            graph[v].add(u);\\n            graph[u].add(v);\\n            indegree[v]++;\\n            indegree[u]++;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int v = 0; v < n; v++) {\\n            if (indegree[v] <= 1) {\\n                queue.offer(v);\\n            }\\n        }\\n        \\n        List<Integer> layer = new ArrayList<>();\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            layer = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                int v = queue.poll();\\n                layer.add(v);\\n                for (int u : graph[v]) {\\n                    if (--indegree[u] == 1) {\\n                        queue.add(u);\\n                    }\\n                }\\n            }\\n        }\\n        return layer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            int v = e[0], u = e[1];\\n            graph[v].add(u);\\n            graph[u].add(v);\\n            indegree[v]++;\\n            indegree[u]++;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int v = 0; v < n; v++) {\\n            if (indegree[v] <= 1) {\\n                queue.offer(v);\\n            }\\n        }\\n        \\n        List<Integer> layer = new ArrayList<>();\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            layer = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                int v = queue.poll();\\n                layer.add(v);\\n                for (int u : graph[v]) {\\n                    if (--indegree[u] == 1) {\\n                        queue.add(u);\\n                    }\\n                }\\n            }\\n        }\\n        return layer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104432,
                "title": "java-easy-to-understand",
                "content": "```\\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n\\tif(edges == null) return null;\\n\\tif(n < 2) return Collections.singletonList(0);\\n\\t\\n\\t//build adjacency list from given edge list\\n\\tMap<Integer, Set<Integer>> adj = new HashMap<>();\\n\\tfor(int[] edge: edges) {\\n\\t\\tadj.computeIfAbsent(edge[0], val -> new HashSet<>()).add(edge[1]);\\n\\t\\tadj.computeIfAbsent(edge[1], val -> new HashSet<>()).add(edge[0]);\\n\\t}\\n\\n\\t//removal from a linked list takes constant time\\n\\tQueue<Integer> leaves = new LinkedList<>(); \\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(adj.get(i).size() == 1)\\n\\t\\t\\tleaves.add(i);\\n\\t}\\n\\n\\t//keep iterating and pruning leaf nodes till number of nodes is less than 2\\n\\twhile(n > 2) {\\n\\t\\tint lsize = leaves.size();\\n\\n\\t\\tfor(int i = 0; i < lsize; i++) {\\n\\t\\t\\t//get each leaf node from the queue in constant time \\n\\t\\t\\tInteger leaf = leaves.remove();\\n\\t\\t\\t//reduce count of nodes\\n\\t\\t\\tn--;\\n\\n\\t\\t\\tSet<Integer> leafNeighbors = adj.get(leaf);             \\n\\t\\t\\tfor(Integer leafNeighbor: leafNeighbors) {\\n\\t\\t\\t\\t//break connection of leaf node from adj list\\n\\t\\t\\t\\tadj.get(leafNeighbor).remove(leaf);\\n\\t\\t\\t\\t//add to queue if the neighbor becomes a leaf after removal\\n\\t\\t\\t\\tif(adj.get(leafNeighbor).size() == 1)\\n\\t\\t\\t\\t\\tleaves.add(leafNeighbor);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn (List)leaves;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n\\tif(edges == null) return null;\\n\\tif(n < 2) return Collections.singletonList(0);\\n\\t\\n\\t//build adjacency list from given edge list\\n\\tMap<Integer, Set<Integer>> adj = new HashMap<>();\\n\\tfor(int[] edge: edges) {\\n\\t\\tadj.computeIfAbsent(edge[0], val -> new HashSet<>()).add(edge[1]);\\n\\t\\tadj.computeIfAbsent(edge[1], val -> new HashSet<>()).add(edge[0]);\\n\\t}\\n\\n\\t//removal from a linked list takes constant time\\n\\tQueue<Integer> leaves = new LinkedList<>(); \\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(adj.get(i).size() == 1)\\n\\t\\t\\tleaves.add(i);\\n\\t}\\n\\n\\t//keep iterating and pruning leaf nodes till number of nodes is less than 2\\n\\twhile(n > 2) {\\n\\t\\tint lsize = leaves.size();\\n\\n\\t\\tfor(int i = 0; i < lsize; i++) {\\n\\t\\t\\t//get each leaf node from the queue in constant time \\n\\t\\t\\tInteger leaf = leaves.remove();\\n\\t\\t\\t//reduce count of nodes\\n\\t\\t\\tn--;\\n\\n\\t\\t\\tSet<Integer> leafNeighbors = adj.get(leaf);             \\n\\t\\t\\tfor(Integer leafNeighbor: leafNeighbors) {\\n\\t\\t\\t\\t//break connection of leaf node from adj list\\n\\t\\t\\t\\tadj.get(leafNeighbor).remove(leaf);\\n\\t\\t\\t\\t//add to queue if the neighbor becomes a leaf after removal\\n\\t\\t\\t\\tif(adj.get(leafNeighbor).size() == 1)\\n\\t\\t\\t\\t\\tleaves.add(leafNeighbor);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn (List)leaves;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906043,
                "title": "bfs-simple-approach",
                "content": "vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int>adj[n];  //creating adjacency list\\n        vector<int>deg(n);  //creating degree vector\\n        \\n        for(int i=0;i<edges.size();i++){  //filling adjacency list and degree vector\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            \\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        \\n        queue<int>q;\\n        vector<int> ans;\\n        \\n        for(int i=0;i<n;i++){  //pushing all those nodes having deg==1\\n            if(deg[i]==1){\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n                        \\n            int s=q.size();\\n            ans.clear();    //reset ans vector after each level of queue\\n            \\n            for(int i=0;i<s;i++){\\n                \\n                int c=q.front();  //extratcting first element and pushing it in ans vector\\n                q.pop();\\n                ans.push_back(c);\\n                \\n                for(int x:adj[c]){  //exploring it\\'s adjacnet and reducing their deg and if deg[x]==1 pushing\\n                    deg[x]--;       //in queue\\n                    \\n                    if(deg[x]==1){\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        if(n==1){                //if there is a single node, then it can\\'t have an MHT\\n            ans.push_back(0);\\n        }\\n        \\n        return ans;\\n        \\n    }****",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int>adj[n];  //creating adjacency list\\n        vector<int>deg(n);  //creating degree vector\\n        \\n        for(int i=0;i<edges.size();i++){  //filling adjacency list and degree vector\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            \\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        \\n        queue<int>q;\\n        vector<int> ans;\\n        \\n        for(int i=0;i<n;i++){  //pushing all those nodes having deg==1\\n            if(deg[i]==1){\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n                        \\n            int s=q.size();\\n            ans.clear();    //reset ans vector after each level of queue\\n            \\n            for(int i=0;i<s;i++){\\n                \\n                int c=q.front();  //extratcting first element and pushing it in ans vector\\n                q.pop();\\n                ans.push_back(c);\\n                \\n                for(int x:adj[c]){  //exploring it\\'s adjacnet and reducing their deg and if deg[x]==1 pushing\\n                    deg[x]--;       //in queue\\n                    \\n                    if(deg[x]==1){\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        if(n==1){                //if there is a single node, then it can\\'t have an MHT\\n            ans.push_back(0);\\n        }\\n        \\n        return ans;\\n        \\n    }****",
                "codeTag": "Unknown"
            },
            {
                "id": 1777483,
                "title": "easy-bfs-solution-with-comments",
                "content": "\\n\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        \\n        List<Integer> res = new ArrayList();\\n        \\n        // security check 1\\n        if(n <= 0) return res;\\n        \\n        // security check 2\\n        // returning the root node itself\\n        if(n == 1) {\\n            res.add(0);\\n            return res;\\n        }\\n        \\n        // degree\\n        int[] degree = new int[n];\\n        // adjacency list\\n        List<List<Integer>> adj = new ArrayList();\\n        \\n        // for each and every node add an empty adjacency list\\n        for(int i=0; i<n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        // adjacency list for every node is updated\\n        for(int[] e: edges) {\\n            degree[e[0]]++;\\n            degree[e[1]]++;\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n        \\n        // BFS starts\\n        Queue<Integer> q = new LinkedList();\\n        \\n        for(int i=0; i<n; i++) {\\n            if(degree[i] == 1) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        // There can be atmost 2 MHTs\\n        while(n > 2) {\\n            int size = q.size();\\n            n -= size;\\n            \\n            // if we remove a leaf node, the neighbouring nodes\\' degrees must be decremented \\n            while(size --> 0) {\\n                int v = q.poll();\\n                for(int i: adj.get(v)) {\\n                    degree[i]--;\\n                    // the queue maintains all the nodes of degree 1\\n                    if(degree[i] == 1) {\\n                        q.add(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        res.addAll(q);\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        \\n        List<Integer> res = new ArrayList();\\n        \\n        // security check 1\\n        if(n <= 0) return res;\\n        \\n        // security check 2\\n        // returning the root node itself\\n        if(n == 1) {\\n            res.add(0);\\n            return res;\\n        }\\n        \\n        // degree\\n        int[] degree = new int[n];\\n        // adjacency list\\n        List<List<Integer>> adj = new ArrayList();\\n        \\n        // for each and every node add an empty adjacency list\\n        for(int i=0; i<n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        // adjacency list for every node is updated\\n        for(int[] e: edges) {\\n            degree[e[0]]++;\\n            degree[e[1]]++;\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n        \\n        // BFS starts\\n        Queue<Integer> q = new LinkedList();\\n        \\n        for(int i=0; i<n; i++) {\\n            if(degree[i] == 1) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        // There can be atmost 2 MHTs\\n        while(n > 2) {\\n            int size = q.size();\\n            n -= size;\\n            \\n            // if we remove a leaf node, the neighbouring nodes\\' degrees must be decremented \\n            while(size --> 0) {\\n                int v = q.poll();\\n                for(int i: adj.get(v)) {\\n                    degree[i]--;\\n                    // the queue maintains all the nodes of degree 1\\n                    if(degree[i] == 1) {\\n                        q.add(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        res.addAll(q);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652154,
                "title": "javascript",
                "content": "```\\nvar findMinHeightTrees = function(n, edges) {\\n    if (n == 1) return [0];\\n    \\n    let adj = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        adj[i] = new Set();\\n    }\\n    \\n    for (let [i,j] of edges) {\\n        adj[i].add(j);\\n        adj[j].add(i);\\n    }\\n    \\n    let leaves = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (adj[i].size == 1) {\\n            leaves.push(i);\\n        }\\n    }\\n    \\n    while (n > 2) {\\n        n -= leaves.length;\\n        let newLeaves = [];\\n        \\n        for (let i of leaves) {\\n            let j = Array.from(adj[i])[0];\\n            adj[j].delete(i);\\n            \\n            if (adj[j].size == 1) {\\n                newLeaves.push(j);\\n            }\\n        }\\n        \\n        leaves = newLeaves;\\n    }\\n    \\n    return leaves;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findMinHeightTrees = function(n, edges) {\\n    if (n == 1) return [0];\\n    \\n    let adj = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        adj[i] = new Set();\\n    }\\n    \\n    for (let [i,j] of edges) {\\n        adj[i].add(j);\\n        adj[j].add(i);\\n    }\\n    \\n    let leaves = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (adj[i].size == 1) {\\n            leaves.push(i);\\n        }\\n    }\\n    \\n    while (n > 2) {\\n        n -= leaves.length;\\n        let newLeaves = [];\\n        \\n        for (let i of leaves) {\\n            let j = Array.from(adj[i])[0];\\n            adj[j].delete(i);\\n            \\n            if (adj[j].size == 1) {\\n                newLeaves.push(j);\\n            }\\n        }\\n        \\n        leaves = newLeaves;\\n    }\\n    \\n    return leaves;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631357,
                "title": "java-kahn-s-algorithm",
                "content": "**Idea:**:\\n* Build adjacency list\\n* Prune leaves until there are only 1 or 2 nodes left\\n* Use Kahn\\'s Algorithm used in [LC 207. Course Schedule](https://leetcode.com/problems/course-schedule/discuss/347690/Java-or-Topological-Sort-Template-or-BFS-Kahn\\'s-Algo-or-DFS)\\n**T/S:** O(n)/O(n)\\n```\\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n\\tif (n == 1)\\n\\t\\treturn List.of(0);\\n\\n\\tvar adjList = getAdjList(edges);\\n\\tvar q = getQ(adjList);\\n\\tfindMinHeightTrees(n, adjList, q);\\n\\treturn q;\\n}\\n\\nprivate Map<Integer, Set<Integer>> getAdjList(int[][] edges) {\\n\\tvar adjList = new HashMap<Integer, Set<Integer>>();\\n\\tfor (var edge : edges) {\\n\\t\\tadjList.computeIfAbsent(edge[0], k -> new HashSet<>())\\n\\t\\t\\t   .add(edge[1]);\\n\\t\\tadjList.computeIfAbsent(edge[1], k -> new HashSet<>())\\n\\t\\t\\t   .add(edge[0]);\\n\\t}\\n\\treturn adjList;\\n}\\n\\nprivate LinkedList<Integer> getQ(Map<Integer, Set<Integer>> adjList) {\\n\\tvar q = new LinkedList<Integer>();\\n\\tfor (var entry : adjList.entrySet())\\n\\t\\tif (entry.getValue().size() == 1)\\n\\t\\t\\tq.add(entry.getKey());\\n\\treturn q;\\n}\\n\\nprivate void findMinHeightTrees(int n, Map<Integer, Set<Integer>> adjList, LinkedList<Integer> q) {\\n\\twhile (n > 2) {\\n\\t\\tn -= q.size();\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar head = q.poll();\\n\\n\\t\\t\\tfor (var neighbor : adjList.get(head)) {\\n\\t\\t\\t\\tadjList.get(neighbor).remove(head);\\n\\t\\t\\t\\tif (adjList.get(neighbor).size() == 1)\\n\\t\\t\\t\\t\\tq.add(neighbor);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n\\tif (n == 1)\\n\\t\\treturn List.of(0);\\n\\n\\tvar adjList = getAdjList(edges);\\n\\tvar q = getQ(adjList);\\n\\tfindMinHeightTrees(n, adjList, q);\\n\\treturn q;\\n}\\n\\nprivate Map<Integer, Set<Integer>> getAdjList(int[][] edges) {\\n\\tvar adjList = new HashMap<Integer, Set<Integer>>();\\n\\tfor (var edge : edges) {\\n\\t\\tadjList.computeIfAbsent(edge[0], k -> new HashSet<>())\\n\\t\\t\\t   .add(edge[1]);\\n\\t\\tadjList.computeIfAbsent(edge[1], k -> new HashSet<>())\\n\\t\\t\\t   .add(edge[0]);\\n\\t}\\n\\treturn adjList;\\n}\\n\\nprivate LinkedList<Integer> getQ(Map<Integer, Set<Integer>> adjList) {\\n\\tvar q = new LinkedList<Integer>();\\n\\tfor (var entry : adjList.entrySet())\\n\\t\\tif (entry.getValue().size() == 1)\\n\\t\\t\\tq.add(entry.getKey());\\n\\treturn q;\\n}\\n\\nprivate void findMinHeightTrees(int n, Map<Integer, Set<Integer>> adjList, LinkedList<Integer> q) {\\n\\twhile (n > 2) {\\n\\t\\tn -= q.size();\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar head = q.poll();\\n\\n\\t\\t\\tfor (var neighbor : adjList.get(head)) {\\n\\t\\t\\t\\tadjList.get(neighbor).remove(head);\\n\\t\\t\\t\\tif (adjList.get(neighbor).size() == 1)\\n\\t\\t\\t\\t\\tq.add(neighbor);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631268,
                "title": "re-rooting-of-trees",
                "content": "A solution using re rooting of trees\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>v[20000+5];\\n    int visited[20000+5];\\n    int ht[20000+5];\\n    map<int,vector<int>>m;\\n    \\n    void calc_ht(int root){\\n\\n        if (v[root].size()==1 && visited[v[root][0]]){\\n            ht[root]=0;\\n            return;\\n        }\\n        \\n        int ans=0;\\n        for (auto child:v[root]){\\n            if (!visited[child]){\\n                visited[child]=1;\\n                calc_ht(child);\\n                ans=max(ans,ht[child]);\\n            }\\n        }\\n       \\n        ht[root]=ans+1;\\n        \\n    }\\n    \\n    void dfs(int root,int parent){\\n        vector<int>temp;\\n        for (auto child:v[root]){\\n            temp.push_back(ht[child]);\\n        }\\n      \\n        sort(temp.begin(),temp.end());\\n        \\n        m[temp[temp.size()-1]+1].push_back(root);\\n        \\n        for (auto child:v[root]){\\n            if (child!=parent){\\n                int x=ht[root];\\n                int cur;\\n                if (ht[child]==temp[temp.size()-1]){\\n                    if (temp.size()==1){\\n                        cur=-1;\\n                    }\\n                    else{\\n                        cur=temp[temp.size()-2];   \\n                    }\\n                }\\n                else{\\n                    cur=temp[temp.size()-1];\\n                }\\n                cur=cur+1;\\n                ht[root]=cur;\\n                dfs(child,root);\\n                ht[root]=x;\\n            }\\n        }\\n    }\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n==1){\\n            vector<int>ans;\\n            ans.push_back(0);\\n            return ans;\\n\\n        }\\n        memset(ht,0,sizeof(ht));\\n        memset(visited,0,sizeof(visited));\\n        \\n        for (int j=0;j<edges.size();j++){\\n            v[edges[j][0]].push_back(edges[j][1]);\\n            v[edges[j][1]].push_back(edges[j][0]);\\n        }\\n        \\n        visited[0]=1;\\n        calc_ht(0);\\n        \\n        memset(visited,0,sizeof(visited));\\n        \\n        dfs(0,-1);\\n\\n        return (m[m.begin()->first]);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v[20000+5];\\n    int visited[20000+5];\\n    int ht[20000+5];\\n    map<int,vector<int>>m;\\n    \\n    void calc_ht(int root){\\n\\n        if (v[root].size()==1 && visited[v[root][0]]){\\n            ht[root]=0;\\n            return;\\n        }\\n        \\n        int ans=0;\\n        for (auto child:v[root]){\\n            if (!visited[child]){\\n                visited[child]=1;\\n                calc_ht(child);\\n                ans=max(ans,ht[child]);\\n            }\\n        }\\n       \\n        ht[root]=ans+1;\\n        \\n    }\\n    \\n    void dfs(int root,int parent){\\n        vector<int>temp;\\n        for (auto child:v[root]){\\n            temp.push_back(ht[child]);\\n        }\\n      \\n        sort(temp.begin(),temp.end());\\n        \\n        m[temp[temp.size()-1]+1].push_back(root);\\n        \\n        for (auto child:v[root]){\\n            if (child!=parent){\\n                int x=ht[root];\\n                int cur;\\n                if (ht[child]==temp[temp.size()-1]){\\n                    if (temp.size()==1){\\n                        cur=-1;\\n                    }\\n                    else{\\n                        cur=temp[temp.size()-2];   \\n                    }\\n                }\\n                else{\\n                    cur=temp[temp.size()-1];\\n                }\\n                cur=cur+1;\\n                ht[root]=cur;\\n                dfs(child,root);\\n                ht[root]=x;\\n            }\\n        }\\n    }\\n    \\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n==1){\\n            vector<int>ans;\\n            ans.push_back(0);\\n            return ans;\\n\\n        }\\n        memset(ht,0,sizeof(ht));\\n        memset(visited,0,sizeof(visited));\\n        \\n        for (int j=0;j<edges.size();j++){\\n            v[edges[j][0]].push_back(edges[j][1]);\\n            v[edges[j][1]].push_back(edges[j][0]);\\n        }\\n        \\n        visited[0]=1;\\n        calc_ht(0);\\n        \\n        memset(visited,0,sizeof(visited));\\n        \\n        dfs(0,-1);\\n\\n        return (m[m.begin()->first]);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631121,
                "title": "java-bfs-by-removing-leaf-verteces",
                "content": "```\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        Set<Integer>[] sets = new Set[n];\\n        for(int i=0;i<n;i++)\\n            sets[i] = new HashSet<>();\\n\\n        for(int[] edge : edges){\\n            sets[ edge[0] ].add( edge[1] );\\n            sets[ edge[1] ].add( edge[0] );\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(sets[i].size()<2)\\n                q.offer(i);\\n        }\\n        while(n>2) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.poll();\\n                int next = sets[curr].iterator().next();\\n                sets[next].remove(curr);\\n                if (sets[next].size() == 1)\\n                    q.offer(next);\\n            }\\n            n -= size;\\n        }\\n        return new ArrayList<>(q);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        Set<Integer>[] sets = new Set[n];\\n        for(int i=0;i<n;i++)\\n            sets[i] = new HashSet<>();\\n\\n        for(int[] edge : edges){\\n            sets[ edge[0] ].add( edge[1] );\\n            sets[ edge[1] ].add( edge[0] );\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(sets[i].size()<2)\\n                q.offer(i);\\n        }\\n        while(n>2) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.poll();\\n                int next = sets[curr].iterator().next();\\n                sets[next].remove(curr);\\n                if (sets[next].size() == 1)\\n                    q.offer(next);\\n            }\\n            n -= size;\\n        }\\n        return new ArrayList<>(q);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1630839,
                "title": "dfs-dp",
                "content": "\\nDFS + DP can reduce the complexity from `O(N^2)` to `O(N)`\\n\\nThe idea: \\n- create function `dfs(node,parent)` \\n- cache the reusult\\n- loop for each node of `n` and it\\'s kids\\n- save max path into the array\\n- create answer from the nodes that have minumun values in the array\\n\\n```python\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        graph = defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        @cache\\n        def dfs(n,p):\\n            # n - current node\\n            # p - parrent\\n            ans = 0\\n            for nb in graph[n]:\\n                if nb != p:\\n                    ans = max(ans, 1 + dfs(nb,n))\\n            return ans\\n        \\n\\t\\t# distance from node till the last leaf\\n        c = [inf] * n\\n        for node in range(n):\\n            a = 0\\n            for nb in graph[node]:\\n                a = max(a, 1 + dfs(nb,node))\\n            c[node] = min(c[node], a)\\n        \\n        min_path = min(c)\\n        ans = []\\n        for i,v in enumerate(c):\\n            if v == min_path:\\n                ans.append(i)\\n        return ans\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3dc01408-a8a8-492a-b0b0-02bda5c16576_1665962957.1069884.png)\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        graph = defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        @cache\\n        def dfs(n,p):\\n            # n - current node\\n            # p - parrent\\n            ans = 0\\n            for nb in graph[n]:\\n                if nb != p:\\n                    ans = max(ans, 1 + dfs(nb,n))\\n            return ans\\n        \\n\\t\\t# distance from node till the last leaf\\n        c = [inf] * n\\n        for node in range(n):\\n            a = 0\\n            for nb in graph[node]:\\n                a = max(a, 1 + dfs(nb,node))\\n            c[node] = min(c[node], a)\\n        \\n        min_path = min(c)\\n        ans = []\\n        for i,v in enumerate(c):\\n            if v == min_path:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610492,
                "title": "python-using-dictionary-less-memory-than-98-faster-from-50-to-95",
                "content": "```\\nclass Solution:\\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n    if n == 1:\\n      return [0]\\n    gra = {} # our graph\\n    for ii in range(n):\\n      gra[ii] = []\\n    for k in edges:\\n      gra[k[0]].append(k[1])\\n      gra[k[1]].append(k[0])\\n    que = []\\n    curr = 0 # we use queue (my queue)\\n    for ii in gra.keys(): # getting leafs into our queue\\n      if len(gra[ii]) == 1:\\n        que.append(ii)\\n    while len(que) < n: # when all nodes will be in our array, then we know its the end of our misery\\n      le = len(que)\\n      for ii in range(curr,le):\\n        # print(que)\\n        if ii >= len(que):\\n          print(\"FU:>\") # my debbuging, I don\\'t have premium\\n        # deleting node (getting ridof leaf) is achived simply by curr += 1\\n        todelNode = que[ii] # number of (leaf) node we want to delete\\n        tocheNode = gra[todelNode][0] # node connected to todelNode (current leaf node) (toche = to check)\\n        gra[tocheNode].remove(todelNode)\\n        if len(gra[tocheNode]) <= 1: # here we check, the name of variable suddenly makes sense\\n          que.append(tocheNode)\\n      curr = le # we need to move on\\n    if curr != n-1:\\n      return que[n-2:n]\\n    else:\\n      return [que[-1]] # idea between this if is actualy pritty simple:> Im so smart\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n    if n == 1:\\n      return [0]\\n    gra = {} # our graph\\n    for ii in range(n):\\n      gra[ii] = []\\n    for k in edges:\\n      gra[k[0]].append(k[1])\\n      gra[k[1]].append(k[0])\\n    que = []\\n    curr = 0 # we use queue (my queue)\\n    for ii in gra.keys(): # getting leafs into our queue\\n      if len(gra[ii]) == 1:\\n        que.append(ii)\\n    while len(que) < n: # when all nodes will be in our array, then we know its the end of our misery\\n      le = len(que)\\n      for ii in range(curr,le):\\n        # print(que)\\n        if ii >= len(que):\\n          print(\"FU:>\") # my debbuging, I don\\'t have premium\\n        # deleting node (getting ridof leaf) is achived simply by curr += 1\\n        todelNode = que[ii] # number of (leaf) node we want to delete\\n        tocheNode = gra[todelNode][0] # node connected to todelNode (current leaf node) (toche = to check)\\n        gra[tocheNode].remove(todelNode)\\n        if len(gra[tocheNode]) <= 1: # here we check, the name of variable suddenly makes sense\\n          que.append(tocheNode)\\n      curr = le # we need to move on\\n    if curr != n-1:\\n      return que[n-2:n]\\n    else:\\n      return [que[-1]] # idea between this if is actualy pritty simple:> Im so smart\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393677,
                "title": "java-bfs-solution-from-leaves-to-center",
                "content": "```\\n// BFS Solution from leaves to center\\n// Start from the nodes whose degrees <= 1\\n// Only degrees[neighbor] == 1 can be added to the que during the BFS.\\n// if n <= 2, stop the search and remaining 1 or 2 nodes are the result.\\n// Note: if n == 1, degrees[0] is 0.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n <= 0) return new ArrayList<>();\\n        int[] degrees = new int[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        buildGraph(graph, degrees, edges);\\n        Queue<Integer> que = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++) {\\n            if (degrees[i] <= 1) {  // Note: if n == 1, degrees[0] is 0.\\n                que.add(i);\\n            }\\n        }\\n        while (n > 2) {\\n            int size = que.size();\\n            n -= size;\\n            for (int k = 0; k < size; k++) {\\n                int node = que.poll();\\n                for (int neighbor : graph[node]) {\\n                    degrees[neighbor]--;\\n                    if (degrees[neighbor] == 1) {\\n                        que.add(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList<>(que);\\n    }\\n    \\n    private void buildGraph(List<Integer>[] graph, int[] degrees, int[][] edges) {\\n        for (int i = 0; i < graph.length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            graph[u].add(v);\\n            graph[v].add(u);\\n            degrees[u]++;\\n            degrees[v]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// BFS Solution from leaves to center\\n// Start from the nodes whose degrees <= 1\\n// Only degrees[neighbor] == 1 can be added to the que during the BFS.\\n// if n <= 2, stop the search and remaining 1 or 2 nodes are the result.\\n// Note: if n == 1, degrees[0] is 0.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n <= 0) return new ArrayList<>();\\n        int[] degrees = new int[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        buildGraph(graph, degrees, edges);\\n        Queue<Integer> que = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++) {\\n            if (degrees[i] <= 1) {  // Note: if n == 1, degrees[0] is 0.\\n                que.add(i);\\n            }\\n        }\\n        while (n > 2) {\\n            int size = que.size();\\n            n -= size;\\n            for (int k = 0; k < size; k++) {\\n                int node = que.poll();\\n                for (int neighbor : graph[node]) {\\n                    degrees[neighbor]--;\\n                    if (degrees[neighbor] == 1) {\\n                        que.add(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList<>(que);\\n    }\\n    \\n    private void buildGraph(List<Integer>[] graph, int[] degrees, int[][] edges) {\\n        for (int i = 0; i < graph.length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            graph[u].add(v);\\n            graph[v].add(u);\\n            degrees[u]++;\\n            degrees[v]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247810,
                "title": "c-kahn-s-algo-bfs-topo-sort-solution",
                "content": "**Points to remember:**\\n1. We are basically trying to delete all leaf nodes at every step. This is very similar to Kahn\\'s Algo or sometimes known as BFS Topological Sort.\\n2. `Indegree` can be used to keep track of how many neighbours are left of a particular `node`. Once only one neighbour is left, that means it is the leaf node and thus we push it into our `queue`\\n3. We keep counting the number of Nodes deleted and once 1 or 2 nodes are left, we return the elements in the queue as they would be the middle elements.\\n4. **Note:** Since, this is an Undirected Graph, we also keep a track of visited/deleted nodes in `visited`.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> indegree(n, 0);\\n        vector<bool> visited(n, false);\\n        unordered_map<int, vector<int>> graph;\\n        \\n        for(auto i: edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n            indegree[i[0]]++;\\n            indegree[i[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0; i<n; i++) \\n            if(indegree[i] == 1 || indegree[i] == 0) q.push(i);\\n        \\n        int count = 0;\\n        while(!q.empty()){\\n            if(count == n-1 || count == n-2) break;\\n            int N = q.size();\\n            for(int i=0; i<N; i++){\\n                count++;\\n                int node = q.front(), q.pop();\\n                visited[node] = true;\\n                for(auto child: graph[node]){\\n                    if(visited[child]) continue;\\n                    indegree[child]--;\\n                    if(indegree[child] == 1) q.push(child);\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n        while(!q.empty())\\n            ans.push_back(q.front()), q.pop();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> indegree(n, 0);\\n        vector<bool> visited(n, false);\\n        unordered_map<int, vector<int>> graph;\\n        \\n        for(auto i: edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n            indegree[i[0]]++;\\n            indegree[i[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0; i<n; i++) \\n            if(indegree[i] == 1 || indegree[i] == 0) q.push(i);\\n        \\n        int count = 0;\\n        while(!q.empty()){\\n            if(count == n-1 || count == n-2) break;\\n            int N = q.size();\\n            for(int i=0; i<N; i++){\\n                count++;\\n                int node = q.front(), q.pop();\\n                visited[node] = true;\\n                for(auto child: graph[node]){\\n                    if(visited[child]) continue;\\n                    indegree[child]--;\\n                    if(indegree[child] == 1) q.push(child);\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n        while(!q.empty())\\n            ans.push_back(q.front()), q.pop();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143050,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> res;\\n        queue<int> myq;\\n        vector<unordered_set<int>> adj(n);\\n        \\n        if (edges.size() == 0) return {0};\\n        \\n        // Create adj matrix\\n        for (auto iter : edges) {\\n            adj[iter[0]].insert(iter[1]);\\n            adj[iter[1]].insert(iter[0]);\\n        }\\n        \\n        // Find the leaf nodes or the nodes connected to only one node\\n        for (int i =0; i < n; i++) {\\n            if (adj[i].size() == 1) {\\n                myq.push(i);\\n            }\\n        }\\n        \\n        // Keep on scrapping the leaf nodes until we reach only two nodes in the adj\\n        //int new_n = n;\\n        while(n > 2) {\\n            int len = myq.size();\\n            //new_n = new_n - len; // Removing nodes from the adj\\n            n = n - len;\\n    \\n            for (int i = 0; i < len; i++) {\\n                int node = myq.front();\\n                myq.pop();\\n                for (int j : adj[node]) {\\n                    // Remove the node from each adj node\\n                    adj[j].erase(node);\\n                    // If new size is 1 push in myq\\n                    if (adj[j].size() == 1) {\\n                        myq.push(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while (!myq.empty()) {\\n            res.push_back(myq.front());\\n            myq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> res;\\n        queue<int> myq;\\n        vector<unordered_set<int>> adj(n);\\n        \\n        if (edges.size() == 0) return {0};\\n        \\n        // Create adj matrix\\n        for (auto iter : edges) {\\n            adj[iter[0]].insert(iter[1]);\\n            adj[iter[1]].insert(iter[0]);\\n        }\\n        \\n        // Find the leaf nodes or the nodes connected to only one node\\n        for (int i =0; i < n; i++) {\\n            if (adj[i].size() == 1) {\\n                myq.push(i);\\n            }\\n        }\\n        \\n        // Keep on scrapping the leaf nodes until we reach only two nodes in the adj\\n        //int new_n = n;\\n        while(n > 2) {\\n            int len = myq.size();\\n            //new_n = new_n - len; // Removing nodes from the adj\\n            n = n - len;\\n    \\n            for (int i = 0; i < len; i++) {\\n                int node = myq.front();\\n                myq.pop();\\n                for (int j : adj[node]) {\\n                    // Remove the node from each adj node\\n                    adj[j].erase(node);\\n                    // If new size is 1 push in myq\\n                    if (adj[j].size() == 1) {\\n                        myq.push(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while (!myq.empty()) {\\n            res.push_back(myq.front());\\n            myq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007488,
                "title": "c-explained-bfs-graph-code-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        if(n<=1){                 //if the tree is empty\\n            vector<int> res;\\n            for(int i=0;i<n;i++)\\n                res.push_back(i);\\n            return res;\\n        }\\n        vector<vector<int>> adj(n);  //create a undirected grpah from given edges\\n        vector<int> degree(n,0);     .//degree vector to store the no. of edges incident on a node\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            \\n            degree[edges[i][0]]++;     //increase the degree of both nodes connected with the edge\\n            degree[edges[i][1]]++;    \\n    \\n        }\\n        queue<int> q;    \\n    //intially only those nodes will be processed whose degree is one  i.e, nodes connected with only one other node\\n        for(int i=0;i<degree.size();i++){\\n            if(degree[i]==1)q.push(i);\\n        }\\n  vector<int> res; //vector to store the result\\n        \\n  //level order traversal      \\n        while(!q.empty()){  \\n            int s = q.size();\\n            res.clear();\\n            \\n            for(int i=0;i<s;i++){\\n               int to =  q.front();\\n                q.pop();\\n                res.push_back(to);\\n                \\n                for(auto v:adj[to]){  //process the neighbour nodes of the one poped above\\n                    degree[v]--;   // since we are removing the edges one by one starting from the one which is connected to least no of nodes until only two nodesare left\\n                    if(degree[v]==1){  //if degree of any onode becomes one push them on queue\\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        return res;  //return the nodes with minimum height\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        \\n        if(n<=1){                 //if the tree is empty\\n            vector<int> res;\\n            for(int i=0;i<n;i++)\\n                res.push_back(i);\\n            return res;\\n        }\\n        vector<vector<int>> adj(n);  //create a undirected grpah from given edges\\n        vector<int> degree(n,0);     .//degree vector to store the no. of edges incident on a node\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            \\n            degree[edges[i][0]]++;     //increase the degree of both nodes connected with the edge\\n            degree[edges[i][1]]++;    \\n    \\n        }\\n        queue<int> q;    \\n    //intially only those nodes will be processed whose degree is one  i.e, nodes connected with only one other node\\n        for(int i=0;i<degree.size();i++){\\n            if(degree[i]==1)q.push(i);\\n        }\\n  vector<int> res; //vector to store the result\\n        \\n  //level order traversal      \\n        while(!q.empty()){  \\n            int s = q.size();\\n            res.clear();\\n            \\n            for(int i=0;i<s;i++){\\n               int to =  q.front();\\n                q.pop();\\n                res.push_back(to);\\n                \\n                for(auto v:adj[to]){  //process the neighbour nodes of the one poped above\\n                    degree[v]--;   // since we are removing the edges one by one starting from the one which is connected to least no of nodes until only two nodesare left\\n                    if(degree[v]==1){  //if degree of any onode becomes one push them on queue\\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        return res;  //return the nodes with minimum height\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950414,
                "title": "java-bfs-queue-solution",
                "content": "\\t class Solution {\\n\\t\\tpublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n\\t\\t\\t//create List<Integer> to return a result\\n\\t\\t\\tList<Integer> res = new ArrayList<>();\\n\\t\\t\\t//corner case\\n\\t\\t\\tif(n == 1){//that vertex start from 0;\\n\\t\\t\\t\\tres.add(0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint [] degree = new int [n]; //to record each vertex degree;\\n\\t\\t\\tMap<Integer, List<Integer>> map = new HashMap<>();// to record each vertex connect neiborhood.\\n\\n\\t\\t\\tbuildGraph(edges, degree, map);\\n\\n\\t\\t\\tQueue<Integer> queue = new LinkedList<>();\\n\\n\\t\\t\\tfor(int i = 0; i<n; i++){//add all vertex degree equals 1 \\n\\t\\t\\t\\tif(degree[i] == 1){\\n\\t\\t\\t\\t\\tqueue.offer(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\t\\tList<Integer> tmp = new ArrayList<>();\\n\\t\\t\\t\\tint size = queue.size();\\n\\t\\t\\t\\tfor(int i = 0; i < size; i++){//to process each level\\n\\t\\t\\t\\t\\tint vertex = queue.poll();\\n\\t\\t\\t\\t\\ttmp.add(vertex);\\n\\t\\t\\t\\t\\tfor(int neibor: map.get(vertex)){//to get each vertex neiborhood;\\n\\t\\t\\t\\t\\t\\tdegree[neibor]--;\\n\\t\\t\\t\\t\\t\\tif(degree[neibor] == 1){\\n\\t\\t\\t\\t\\t\\t\\tqueue.offer(neibor);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = tmp; //update res.\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tprivate void buildGraph(int[][] edges, int[]degree, Map<Integer, List<Integer>> map){\\n\\n\\t\\t\\tfor(int[] pair: edges){\\n\\t\\t\\t\\tif(!map.containsKey(pair[0]) ){\\n\\t\\t\\t\\t\\tmap.put(pair[0], new ArrayList<>());  \\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(!map.containsKey(pair[1])){\\n\\t\\t\\t\\t\\t map.put(pair[1], new ArrayList<>());\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmap.get(pair[0]).add(pair[1]);\\n\\t\\t\\t\\tmap.get(pair[1]).add(pair[0]);\\n\\t\\t\\t\\tdegree[pair[0]]++;\\n\\t\\t\\t\\tdegree[pair[1]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n\\t\\t\\t//create List<Integer> to return a result\\n\\t\\t\\tList<Integer> res = new ArrayList<>();\\n\\t\\t\\t//corner case\\n\\t\\t\\tif(n == 1){//that vertex start from 0;\\n\\t\\t\\t\\tres.add(0);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 924109,
                "title": "deque-topological-sort-highly-intuitive-and-simple-c-solution",
                "content": "```\\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n == 1)\\n            return {0};\\n        vector<int> ans;\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n, 0);\\n        deque<int> dq;\\n        \\n        for (auto item: edges)\\n        {\\n            graph[item[0]].push_back(item[1]);\\n            graph[item[1]].push_back(item[0]);\\n            ++indegree[item[0]];\\n            ++indegree[item[1]];\\n\\t    }\\n        \\n        for(int i = 0; i < indegree.size(); i++)\\n        {\\n            if(indegree[i] == 1)\\n                dq.push_back(i);\\n        }\\n        \\n        while(n > 2)\\n        {\\n            int size =  dq.size();\\n            while(size--)\\n            {\\n                auto front = dq.front();\\n                dq.pop_front();\\n                n--;\\n                for(auto node: graph[front])\\n                {\\n                    indegree[node]--;\\n                    if(indegree[node] == 1)\\n                        dq.push_back(node);\\n                }\\n            }\\n        }\\n        ans.insert(ans.begin(), dq.begin(), dq.end());\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if(n == 1)\\n            return {0};\\n        vector<int> ans;\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n, 0);\\n        deque<int> dq;\\n        \\n        for (auto item: edges)\\n        {\\n            graph[item[0]].push_back(item[1]);\\n            graph[item[1]].push_back(item[0]);\\n            ++indegree[item[0]];\\n            ++indegree[item[1]];\\n\\t    }\\n        \\n        for(int i = 0; i < indegree.size(); i++)\\n        {\\n            if(indegree[i] == 1)\\n                dq.push_back(i);\\n        }\\n        \\n        while(n > 2)\\n        {\\n            int size =  dq.size();\\n            while(size--)\\n            {\\n                auto front = dq.front();\\n                dq.pop_front();\\n                n--;\\n                for(auto node: graph[front])\\n                {\\n                    indegree[node]--;\\n                    if(indegree[node] == 1)\\n                        dq.push_back(node);\\n                }\\n            }\\n        }\\n        ans.insert(ans.begin(), dq.begin(), dq.end());\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 923881,
                "title": "python-clean-simple",
                "content": "```python\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1: return [0]\\n        \\n        graph = defaultdict(set)\\n        for src, dst in edges:\\n            graph[src].add(dst)\\n            graph[dst].add(src)\\n        \\n        leaves = [node for node in graph if len(graph[node]) == 1]\\n        \\n        while n > 2:\\n            n -= len(leaves)\\n            temp = []\\n            for leaf in leaves:\\n                neighbor = graph[leaf].pop()\\n                graph[neighbor].remove(leaf)\\n                if len(graph[neighbor]) == 1:\\n                    temp.append(neighbor)\\n            leaves = temp\\n        return leaves\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1: return [0]\\n        \\n        graph = defaultdict(set)\\n        for src, dst in edges:\\n            graph[src].add(dst)\\n            graph[dst].add(src)\\n        \\n        leaves = [node for node in graph if len(graph[node]) == 1]\\n        \\n        while n > 2:\\n            n -= len(leaves)\\n            temp = []\\n            for leaf in leaves:\\n                neighbor = graph[leaf].pop()\\n                graph[neighbor].remove(leaf)\\n                if len(graph[neighbor]) == 1:\\n                    temp.append(neighbor)\\n            leaves = temp\\n        return leaves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923713,
                "title": "brute-force-o-n-2-time-limit-exceed",
                "content": "There have been alot of solutions showing to solve this in O(N) time, where N is just the number of edges or nodes we have to traverse, but I was having a hard time seeing how trimming the leaf nodes until there are two remaining nodes, where the two remaining nodes are the roots of the trees that would yeild the minimum height...I still don\\'t really get it. So to help those new people starting out on LC and learning BFS, I came up wit the brute force solution.\\n\\nAlgo:\\n* build the tree using each node as the root\\n* BFS to find the max level for each build\\n* dump into a heights array\\n* find the min and return indices that are the min\\n\\nThe brute force works on 64/68 test cases. I know this isn\\'t the best one, but it is something I could come up with on the spot, although havining minimal knowledge of topological sort. \\n\\nUpvote if helpful!\\n\\n```\\nclass Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\'\\'\\'\\n        enumerate all possible trees using each node as the root, that would take a long time...\\n        brute force algo:\\n            generate adj list once\\n            for each node do bfs finding the max height\\n            dump the neights into a list\\n            fin the min height\\n            return those nodes correpsoding to the min height\\n        \\'\\'\\'\\n        #base cases\\n        if n <= 2:\\n            return [i for i in range(n)]\\n        \\n        #build adj list\\n        adj = collections.defaultdict(list)\\n        for start,end in edges:\\n            adj[start].append(end)\\n            adj[end].append(start)\\n        \\n        \\n        heights = [0]*n\\n        \\n        #bfs finding the max height for each tree with the rooted node\\n        for i in range(n):\\n            #q up and keep track of already visited nodes\\n            visited = set()\\n            q = deque([(node,1) for node in adj[i]]) #tuple is list with list[0] being nodes list[1] level\\n            visited.add(i)\\n            while q:\\n                node,level = q.popleft()\\n                visited.add(node)\\n                for neigh in adj[node]:\\n                    if neigh not in visited:\\n                        q.append((neigh,level+1))\\n\\n            heights[i] = level\\n        \\n        #find the min\\n        mini = min(heights)\\n        \\n        #return indices where it equals min\\n        results = []\\n        for i in range(n):\\n            if heights[i] == mini:\\n                results.append(i)\\n        \\n        return results\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\'\\'\\'\\n        enumerate all possible trees using each node as the root, that would take a long time...\\n        brute force algo:\\n            generate adj list once\\n            for each node do bfs finding the max height\\n            dump the neights into a list\\n            fin the min height\\n            return those nodes correpsoding to the min height\\n        \\'\\'\\'\\n        #base cases\\n        if n <= 2:\\n            return [i for i in range(n)]\\n        \\n        #build adj list\\n        adj = collections.defaultdict(list)\\n        for start,end in edges:\\n            adj[start].append(end)\\n            adj[end].append(start)\\n        \\n        \\n        heights = [0]*n\\n        \\n        #bfs finding the max height for each tree with the rooted node\\n        for i in range(n):\\n            #q up and keep track of already visited nodes\\n            visited = set()\\n            q = deque([(node,1) for node in adj[i]]) #tuple is list with list[0] being nodes list[1] level\\n            visited.add(i)\\n            while q:\\n                node,level = q.popleft()\\n                visited.add(node)\\n                for neigh in adj[node]:\\n                    if neigh not in visited:\\n                        q.append((neigh,level+1))\\n\\n            heights[i] = level\\n        \\n        #find the min\\n        mini = min(heights)\\n        \\n        #return indices where it equals min\\n        results = []\\n        for i in range(n):\\n            if heights[i] == mini:\\n                results.append(i)\\n        \\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923684,
                "title": "minimum-height-tree-java-o-mn",
                "content": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> mhtNodes = null;\\n\\t\\t//Quick get out condition\\n        if(n<=2){\\n            mhtNodes = new LinkedList();\\n            for(int i=0; i<n; i++){\\n                mhtNodes.add(i);\\n            }\\n            return mhtNodes;\\n        }\\n\\t\\t\\n        List<Set<Integer>> adjacencyList = new ArrayList<>();\\n        Set<Integer> leaves = new HashSet<>();\\n        for(int i=0; i<n; i++){\\n            adjacencyList.add(i, new HashSet<>());\\n        }\\n        \\n\\t\\t//Generate adjacency list and find out leaf nodes\\n        for(int[] edge: edges){\\n            adjacencyList.get(edge[0]).add(edge[1]);\\n            adjacencyList.get(edge[1]).add(edge[0]);\\n            \\n            if(adjacencyList.get(edge[0]).size() == 1){\\n                leaves.add(edge[0]);\\n            }else{\\n                leaves.remove(edge[0]);\\n            }\\n            \\n            if(adjacencyList.get(edge[1]).size() == 1){\\n                leaves.add(edge[1]);\\n            }else{\\n                leaves.remove(edge[1]);\\n            }\\n        }\\n        \\n        //Keep removing leaf nodes layer by layer. Like peeling an onion :). The innermost nodes are the aswer\\n        while(!leaves.isEmpty()){\\n            mhtNodes = new LinkedList<>(leaves);\\n            leaves.clear();\\n            for(int node: mhtNodes){\\n                for(int connectedNode: adjacencyList.get(node)){\\n                    adjacencyList.get(connectedNode).remove(node);\\n                    if(adjacencyList.get(connectedNode).size() == 1){\\n                        leaves.add(connectedNode);\\n                    }\\n                }\\n            }\\n        }\\n        return mhtNodes;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> mhtNodes = null;\\n\\t\\t//Quick get out condition\\n        if(n<=2){\\n            mhtNodes = new LinkedList();\\n            for(int i=0; i<n; i++){\\n                mhtNodes.add(i);\\n            }\\n            return mhtNodes;\\n        }\\n\\t\\t\\n        List<Set<Integer>> adjacencyList = new ArrayList<>();\\n        Set<Integer> leaves = new HashSet<>();\\n        for(int i=0; i<n; i++){\\n            adjacencyList.add(i, new HashSet<>());\\n        }\\n        \\n\\t\\t//Generate adjacency list and find out leaf nodes\\n        for(int[] edge: edges){\\n            adjacencyList.get(edge[0]).add(edge[1]);\\n            adjacencyList.get(edge[1]).add(edge[0]);\\n            \\n            if(adjacencyList.get(edge[0]).size() == 1){\\n                leaves.add(edge[0]);\\n            }else{\\n                leaves.remove(edge[0]);\\n            }\\n            \\n            if(adjacencyList.get(edge[1]).size() == 1){\\n                leaves.add(edge[1]);\\n            }else{\\n                leaves.remove(edge[1]);\\n            }\\n        }\\n        \\n        //Keep removing leaf nodes layer by layer. Like peeling an onion :). The innermost nodes are the aswer\\n        while(!leaves.isEmpty()){\\n            mhtNodes = new LinkedList<>(leaves);\\n            leaves.clear();\\n            for(int node: mhtNodes){\\n                for(int connectedNode: adjacencyList.get(node)){\\n                    adjacencyList.get(connectedNode).remove(node);\\n                    if(adjacencyList.get(connectedNode).size() == 1){\\n                        leaves.add(connectedNode);\\n                    }\\n                }\\n            }\\n        }\\n        return mhtNodes;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923593,
                "title": "python3-dfs-cache",
                "content": "This is the most straightforward solution: iterate through each node as root and compute its height. However, we incorporate a cache to memoize the height of each branch from a root. This can speed up the computation tremendously while not incurring too much change to the naive bruteforce solution.\\n\\n```python\\nfrom typing import List\\nimport math\\n\\n\\nclass Solution:\\n    def get_height(self, adj_list, root, seen, cache):\\n        seen.add(root)\\n        children_h = 0\\n        for child in adj_list[root]:\\n            if child not in seen:\\n                if child not in cache[root]:\\n                    cache[root][child] = self.get_height(adj_list, child, seen, cache)\\n                children_h = max(children_h, cache[root][child])\\n        return children_h + 1\\n\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        \"\"\"34% ranking.\\n        \\n        Without a cache, this method times out. However, after adding a cache,\\n        which records the height of a branch from a root to each of its child,\\n        we are able to reduce computation tremendously and pass the OJ.\\n        \"\"\"\\n        cache = [dict() for _ in range(n)]  # key component in the algo\\n        adj_list = [[] for _ in range(n)]\\n        min_h = math.inf\\n        res = []\\n        for n1, n2 in edges:\\n            adj_list[n1].append(n2)\\n            adj_list[n2].append(n1)\\n        for root, children in enumerate(adj_list):\\n            if len(children) > 1:\\n                height = self.get_height(adj_list, root, set(), cache)\\n                if height < min_h:\\n                    min_h = height\\n                    res = [root]\\n                elif height == min_h:\\n                    res.append(root)\\n        return res if res else list(range(n))\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom typing import List\\nimport math\\n\\n\\nclass Solution:\\n    def get_height(self, adj_list, root, seen, cache):\\n        seen.add(root)\\n        children_h = 0\\n        for child in adj_list[root]:\\n            if child not in seen:\\n                if child not in cache[root]:\\n                    cache[root][child] = self.get_height(adj_list, child, seen, cache)\\n                children_h = max(children_h, cache[root][child])\\n        return children_h + 1\\n\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        \"\"\"34% ranking.\\n        \\n        Without a cache, this method times out. However, after adding a cache,\\n        which records the height of a branch from a root to each of its child,\\n        we are able to reduce computation tremendously and pass the OJ.\\n        \"\"\"\\n        cache = [dict() for _ in range(n)]  # key component in the algo\\n        adj_list = [[] for _ in range(n)]\\n        min_h = math.inf\\n        res = []\\n        for n1, n2 in edges:\\n            adj_list[n1].append(n2)\\n            adj_list[n2].append(n1)\\n        for root, children in enumerate(adj_list):\\n            if len(children) > 1:\\n                height = self.get_height(adj_list, root, set(), cache)\\n                if height < min_h:\\n                    min_h = height\\n                    res = [root]\\n                elif height == min_h:\\n                    res.append(root)\\n        return res if res else list(range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923361,
                "title": "c-two-different-approaches-faster-than-97",
                "content": "1. Intuitive approach - BFS (Time Limit Exceeded)\\n\\t```\\n\\tpublic class Solution_BFS\\n    {\\n        HashSet<int>[] Edges;\\n        int min = int.MaxValue;\\n\\n        public IList<int> FindMinHeightTrees(int n, int[][] edges)\\n        {\\n            if (n == 1)\\n                return new int[1] { 0 };\\n            Edges = new HashSet<int>[n];\\n\\n            foreach (var pair in edges)\\n            {\\n                AddEdge(pair[0], pair[1]);\\n                AddEdge(pair[1], pair[0]);\\n            }\\n\\n            var maxDist = new List<(int, int)>();\\n            for (int i = 0; i < n; i++)\\n            {\\n                var dist = GetMaxDist(i);\\n                min = Math.Min(min, dist);\\n                maxDist.Add((i, dist));\\n            }\\n\\n            return maxDist.Where(p => p.Item2 == min).Select(p => p.Item1).ToArray();\\n        }\\n\\n        private int GetMaxDist(int vertex)\\n        {\\n            HashSet<int> visited = new HashSet<int>();\\n            int max = 0;\\n            Queue<(int, int)> queue = new Queue<(int, int)>();\\n            queue.Enqueue((vertex, 0));\\n\\n            while (queue.Count > 0)\\n            {\\n                var curr = queue.Dequeue();\\n                var v = curr.Item1;\\n                var dist = curr.Item2;\\n                if (visited.Contains(v))\\n                    continue;\\n                visited.Add(v);\\n                max = Math.Max(max, dist);\\n                if (max > min)\\n                    break;\\n                foreach (int target in Edges[v])\\n                    if (!visited.Contains(target))\\n                        queue.Enqueue((target, dist + 1));\\n            }\\n            return max;\\n        }\\n\\n        private void AddEdge(int v1, int v2)\\n        {\\n            if (Edges[v1] == null)\\n                Edges[v1] = new HashSet<int>();\\n            Edges[v1].Add(v2);\\n        }\\n    }\\n\\t```\\n\\n2. Topological Sorting with leaves cutting (explained in the *Problem Solution*)\\nRuntime: 288 ms, faster than 97.18% of C# online submissions for Minimum Height Trees.\\nMemory Usage: 43.7 MB, less than 5.63% of C# online submissions for Minimum Height Trees.\\n\\n\\t```\\n\\tpublic class Solution \\n\\t{\\n\\t\\tHashSet<int>[] Edges;\\n\\t\\tint min = int.MaxValue;\\n\\n\\t\\tpublic IList<int> FindMinHeightTrees(int n, int[][] edges) \\n\\t\\t{\\n\\t\\t\\tif (n == 1)\\n                return new int[1] { 0 };\\n            Edges = new HashSet<int>[n];\\n\\n            foreach (var pair in edges)\\n            {\\n                AddEdge(pair[0], pair[1]);\\n                AddEdge(pair[1], pair[0]);\\n            }\\n\\n            Queue<int> leaves = new Queue<int>();\\n            for (int i = 0; i < n; i++)\\n                if (Edges[i].Count == 1)\\n                    leaves.Enqueue(i);\\n\\n            while (n > 2)\\n            {\\n                List<int> newLeaves = new List<int>();\\n                while (leaves.Count > 0)\\n                {\\n                    n--;\\n                    var leaf = leaves.Dequeue();\\n                    var neighbour = Edges[leaf].First();    //the only one\\n                    Edges[neighbour].Remove(leaf);\\n                    if (Edges[neighbour].Count == 1)\\n                        newLeaves.Add(neighbour);\\n                }\\n                foreach (var leaf in newLeaves)\\n                    leaves.Enqueue(leaf);\\n            }\\n\\n            List<int> res = new List<int>();\\n            while (leaves.Count > 0)\\n                res.Add(leaves.Dequeue());\\n\\n            return res;\\n\\t\\t}\\n\\n\\t\\tprivate void AddEdge(int v1, int v2)\\n\\t\\t{\\n\\t\\t\\tif(Edges[v1] == null)\\n\\t\\t\\t\\tEdges[v1] = new HashSet<int>();\\n\\t\\t\\tEdges[v1].Add(v2);\\n\\t\\t}\\n\\t}\\n\\t```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n\\tpublic class Solution_BFS\\n    {\\n        HashSet<int>[] Edges;\\n        int min = int.MaxValue;\\n\\n        public IList<int> FindMinHeightTrees(int n, int[][] edges)\\n        {\\n            if (n == 1)\\n                return new int[1] { 0 };\\n            Edges = new HashSet<int>[n];\\n\\n            foreach (var pair in edges)\\n            {\\n                AddEdge(pair[0], pair[1]);\\n                AddEdge(pair[1], pair[0]);\\n            }\\n\\n            var maxDist = new List<(int, int)>();\\n            for (int i = 0; i < n; i++)\\n            {\\n                var dist = GetMaxDist(i);\\n                min = Math.Min(min, dist);\\n                maxDist.Add((i, dist));\\n            }\\n\\n            return maxDist.Where(p => p.Item2 == min).Select(p => p.Item1).ToArray();\\n        }\\n\\n        private int GetMaxDist(int vertex)\\n        {\\n            HashSet<int> visited = new HashSet<int>();\\n            int max = 0;\\n            Queue<(int, int)> queue = new Queue<(int, int)>();\\n            queue.Enqueue((vertex, 0));\\n\\n            while (queue.Count > 0)\\n            {\\n                var curr = queue.Dequeue();\\n                var v = curr.Item1;\\n                var dist = curr.Item2;\\n                if (visited.Contains(v))\\n                    continue;\\n                visited.Add(v);\\n                max = Math.Max(max, dist);\\n                if (max > min)\\n                    break;\\n                foreach (int target in Edges[v])\\n                    if (!visited.Contains(target))\\n                        queue.Enqueue((target, dist + 1));\\n            }\\n            return max;\\n        }\\n\\n        private void AddEdge(int v1, int v2)\\n        {\\n            if (Edges[v1] == null)\\n                Edges[v1] = new HashSet<int>();\\n            Edges[v1].Add(v2);\\n        }\\n    }\\n\\t```\n```\\n\\tpublic class Solution \\n\\t{\\n\\t\\tHashSet<int>[] Edges;\\n\\t\\tint min = int.MaxValue;\\n\\n\\t\\tpublic IList<int> FindMinHeightTrees(int n, int[][] edges) \\n\\t\\t{\\n\\t\\t\\tif (n == 1)\\n                return new int[1] { 0 };\\n            Edges = new HashSet<int>[n];\\n\\n            foreach (var pair in edges)\\n            {\\n                AddEdge(pair[0], pair[1]);\\n                AddEdge(pair[1], pair[0]);\\n            }\\n\\n            Queue<int> leaves = new Queue<int>();\\n            for (int i = 0; i < n; i++)\\n                if (Edges[i].Count == 1)\\n                    leaves.Enqueue(i);\\n\\n            while (n > 2)\\n            {\\n                List<int> newLeaves = new List<int>();\\n                while (leaves.Count > 0)\\n                {\\n                    n--;\\n                    var leaf = leaves.Dequeue();\\n                    var neighbour = Edges[leaf].First();    //the only one\\n                    Edges[neighbour].Remove(leaf);\\n                    if (Edges[neighbour].Count == 1)\\n                        newLeaves.Add(neighbour);\\n                }\\n                foreach (var leaf in newLeaves)\\n                    leaves.Enqueue(leaf);\\n            }\\n\\n            List<int> res = new List<int>();\\n            while (leaves.Count > 0)\\n                res.Add(leaves.Dequeue());\\n\\n            return res;\\n\\t\\t}\\n\\n\\t\\tprivate void AddEdge(int v1, int v2)\\n\\t\\t{\\n\\t\\t\\tif(Edges[v1] == null)\\n\\t\\t\\t\\tEdges[v1] = new HashSet<int>();\\n\\t\\t\\tEdges[v1].Add(v2);\\n\\t\\t}\\n\\t}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 923196,
                "title": "java-using-indegree-beats-100",
                "content": "Start from leaf nodes and go on climbing to upper nodes, until you reach middle.\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> answer = new ArrayList<>();\\n        if (n == 1) {\\n            answer.add(0);\\n            return answer;\\n        }\\n        List<Integer>[] graph = new ArrayList[n];\\n        int[] degree = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] edge: edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n            \\n        }\\n        Queue<Integer> leaf = new LinkedList<>();\\n        int remainingNodes = n;\\n        for (int i = 0; i < n; i++) {\\n            if (degree[i] == 1){\\n                leaf.add(i);\\n            }\\n        }\\n        while(!leaf.isEmpty()) {\\n            //We found answer if queue left with <=2 elements\\n            if (remainingNodes <= 2) {\\n                break;\\n            }\\n            int size = leaf.size();\\n            while (--size >= 0) {\\n                int l = leaf.poll();\\n                remainingNodes--;\\n                for (int adj: graph[l]) {\\n                    // edge is removed so degree will decrease for both vertex\\n                    degree[adj]--;\\n                    if (degree[adj] == 1) {\\n                        leaf.add(adj);\\n                    }\\n                }\\n            }\\n        }\\n        answer.addAll(leaf);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        List<Integer> answer = new ArrayList<>();\\n        if (n == 1) {\\n            answer.add(0);\\n            return answer;\\n        }\\n        List<Integer>[] graph = new ArrayList[n];\\n        int[] degree = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] edge: edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n            \\n        }\\n        Queue<Integer> leaf = new LinkedList<>();\\n        int remainingNodes = n;\\n        for (int i = 0; i < n; i++) {\\n            if (degree[i] == 1){\\n                leaf.add(i);\\n            }\\n        }\\n        while(!leaf.isEmpty()) {\\n            //We found answer if queue left with <=2 elements\\n            if (remainingNodes <= 2) {\\n                break;\\n            }\\n            int size = leaf.size();\\n            while (--size >= 0) {\\n                int l = leaf.poll();\\n                remainingNodes--;\\n                for (int adj: graph[l]) {\\n                    // edge is removed so degree will decrease for both vertex\\n                    degree[adj]--;\\n                    if (degree[adj] == 1) {\\n                        leaf.add(adj);\\n                    }\\n                }\\n            }\\n        }\\n        answer.addAll(leaf);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903683,
                "title": "c-faster-than-97-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& e) {\\n        vector<vector <int> > g(n);\\n        vector <int> deg(n,0);\\n        if(e.size()==0)\\n        {\\n            return {0};\\n        }\\n        for(int i=0;i<e.size();i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n            deg[e[i][1]]++;\\n            deg[e[i][0]]++;\\n        }\\n        queue <int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(deg[i]==1)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(n>2)\\n        {\\n            int sz=q.size();\\n            n=n-q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int t=q.front();\\n                q.pop();\\n                for(int j=0;j<g[t].size();j++)\\n                {\\n                    deg[g[t][j]]--;\\n                    if(deg[g[t][j]]==1)\\n                    {\\n                        q.push(g[t][j]);\\n                    }\\n                }\\n            }\\n        }\\n        vector <int> ans;\\n        while(!q.empty())\\n        {\\n            ans.push_back(q.front());\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& e) {\\n        vector<vector <int> > g(n);\\n        vector <int> deg(n,0);\\n        if(e.size()==0)\\n        {\\n            return {0};\\n        }\\n        for(int i=0;i<e.size();i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n            deg[e[i][1]]++;\\n            deg[e[i][0]]++;\\n        }\\n        queue <int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(deg[i]==1)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(n>2)\\n        {\\n            int sz=q.size();\\n            n=n-q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int t=q.front();\\n                q.pop();\\n                for(int j=0;j<g[t].size();j++)\\n                {\\n                    deg[g[t][j]]--;\\n                    if(deg[g[t][j]]==1)\\n                    {\\n                        q.push(g[t][j]);\\n                    }\\n                }\\n            }\\n        }\\n        vector <int> ans;\\n        while(!q.empty())\\n        {\\n            ans.push_back(q.front());\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852086,
                "title": "java-solution-calculating-diameter-of-the-tree",
                "content": "```\\nclass Solution {\\n    \\n    int diameter;\\n    int nodeIndex;\\n    List<Integer> res;\\n    \\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n            \\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        tree.put(0, new ArrayList<>());\\n        for(int i = 1; i < n; i++)\\n            tree.put(i, new ArrayList<>());\\n        for(int[] x: edges) {\\n            tree.get(x[0])\\n                .add(x[1]);\\n            tree.get(x[1])\\n                .add(x[0]);\\n        }\\n        diameter = -1;\\n        nodeIndex = 0;\\n        \\n        dfs(tree, 0, 0, new HashSet<>(), new ArrayList<>());\\n        \\n        diameter = -1;\\n        dfs(tree, nodeIndex, 0, new HashSet<>(), new ArrayList<>());\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(res.get(diameter / 2));\\n        if(diameter % 2 == 1)\\n            ans.add(res.get(diameter / 2 + diameter % 2));\\n        \\n        return ans;\\n    }\\n    \\n    public void dfs(Map<Integer, List<Integer>> tree, int node ,int level, Set<Integer> visited, List<Integer> ans) {\\n        visited.add(node);\\n        ans.add(node);\\n        \\n        if(level > diameter){\\n            diameter = level;\\n            nodeIndex = node; \\n            res = ans;\\n        }\\n        \\n        for(int x : tree.get(node)) {\\n            if(!visited.contains(x))\\n                dfs(tree, x, level + 1, visited, new ArrayList<>(ans));\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int diameter;\\n    int nodeIndex;\\n    List<Integer> res;\\n    \\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n            \\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        tree.put(0, new ArrayList<>());\\n        for(int i = 1; i < n; i++)\\n            tree.put(i, new ArrayList<>());\\n        for(int[] x: edges) {\\n            tree.get(x[0])\\n                .add(x[1]);\\n            tree.get(x[1])\\n                .add(x[0]);\\n        }\\n        diameter = -1;\\n        nodeIndex = 0;\\n        \\n        dfs(tree, 0, 0, new HashSet<>(), new ArrayList<>());\\n        \\n        diameter = -1;\\n        dfs(tree, nodeIndex, 0, new HashSet<>(), new ArrayList<>());\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(res.get(diameter / 2));\\n        if(diameter % 2 == 1)\\n            ans.add(res.get(diameter / 2 + diameter % 2));\\n        \\n        return ans;\\n    }\\n    \\n    public void dfs(Map<Integer, List<Integer>> tree, int node ,int level, Set<Integer> visited, List<Integer> ans) {\\n        visited.add(node);\\n        ans.add(node);\\n        \\n        if(level > diameter){\\n            diameter = level;\\n            nodeIndex = node; \\n            res = ans;\\n        }\\n        \\n        for(int x : tree.get(node)) {\\n            if(!visited.contains(x))\\n                dfs(tree, x, level + 1, visited, new ArrayList<>(ans));\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820951,
                "title": "c-bfs-solution-with-100-runtime-and-100-memory",
                "content": "The idea of all BFS solution for this problem is to remove leaf nodes and edges layer by layer, until the inner most nodes are exposed. The general framework comes up easily, however, the main problem is to find and remove leaf edges. Initially, 2 solutions came to my mind. \\n1. Use vectors. We could look up the leaf node in `edges`. We can find the first edge that contains leaf node, then update the # edge count of the other node. However, this operation takes O(n) time for each leaf. \\n1. Use map of sets. We could have a map to store node and all of their connect nodes as set. It will take O(1) for each lookup. However, this adds up to complexity in implementation and memory usage. Most discussion page solutions use this method. \\n\\nAfter careful observation, we find that we don\\'t care which nodes each node is connected to until it becomes a leaf. So in the second solution above, we store redundant information when multiple nodes are connected. How to reduce them? We can choose any reversible operation set, the simplest one being addition/subtraction. During construction, connected nodes are sumed up to a single value. During BFS, node indexes are subtracted until the last one is revealed. \\n\\nThough both being O(n) runtime and memory, this data structure is more efficient and easier to implement than the map of set solution. After turning map to vector, it achieves 112ms runtime and 24MB memory. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> edge_count(n, 0);  // number of connected node\\n        vector<int> edge_sum(n, 0);  // sum of all connected node\\n        int i, n1, n2, n0 = n;\\n        for (vector<int> edge: edges) {\\n            n1 = edge[0];\\n            n2 = edge[1];\\n            edge_count[n1] ++;\\n            edge_count[n2] ++;\\n            edge_sum[n1] += n2;\\n            edge_sum[n2] += n1;\\n        }\\n        queue<int> q;\\n        for (i = 0; i < n; i ++) {\\n            if (edge_count[i] == 1) {\\n                q.push(i);\\n            }\\n        }\\n\\n        int root, root1, q_size;\\n        while (n > 2) {\\n            q_size = q.size();\\n            for (i = 0; i < q_size; i ++) {\\n                root = q.front(); q.pop();\\n                root1 = edge_sum[root];   // leaf only connect to 1 node, sum equals to node index\\n                edge_sum[root1] -= root;\\n                edge_count[root1] --;\\n                if (edge_count[root1] == 1) {\\n                    q.push(root1);\\n                }\\n                edge_count[root] = -1;\\n                n --;\\n            }\\n        }\\n        vector<int> ans;\\n        for (i = 0; i < n0; i ++) {\\n            if (edge_count[i] > -1) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf we use `edges` to store `edge_count` and `edge_sum`, we could further reduce runtime to 96 ms and memory to 21.5MB, achieving 100% in both area. However, this requires n < sqrt(INT_MAX) = 46340.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        int i, n1, n2, n0 = n;\\n        edges.push_back(vector<int> (2, 0));\\n        for (i = 0; i < n - 1; i ++) {\\n            n1 = edges[i][0] % n;\\n            n2 = edges[i][1] % n;\\n            edges[n1][0] += 1 * n;  // edge count\\n            edges[n2][0] += 1 * n;\\n            edges[n1][1] += n2 * n;  //edge sum\\n            edges[n2][1] += n1 * n;\\n        }\\n        for (i = 0; i < n; i ++) {\\n            edges[i][0] /= n;\\n            edges[i][1] /= n;\\n        }\\n        queue<int> q;\\n        for (i = 0; i < n; i ++) {\\n            if (edges[i][0] == 1) {\\n                q.push(i);\\n            }\\n        }\\n\\n        int root, root1, q_size;\\n        while (n > 2) {\\n            q_size = q.size();\\n            for (i = 0; i < q_size; i ++) {\\n                root = q.front(); q.pop();\\n                root1 = edges[root][1];   // leaf only connect to 1 node, sum equals to node index\\n                edges[root1][1] -= root;\\n                edges[root1][0] --;\\n                if (edges[root1][0] == 1) {\\n                    q.push(root1);\\n                }\\n                edges[root][0] = -1;\\n                n --;\\n            }\\n        }\\n        vector<int> ans;\\n        for (i = 0; i < n0; i ++) {\\n            if (edges[i][0] > -1) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> edge_count(n, 0);  // number of connected node\\n        vector<int> edge_sum(n, 0);  // sum of all connected node\\n        int i, n1, n2, n0 = n;\\n        for (vector<int> edge: edges) {\\n            n1 = edge[0];\\n            n2 = edge[1];\\n            edge_count[n1] ++;\\n            edge_count[n2] ++;\\n            edge_sum[n1] += n2;\\n            edge_sum[n2] += n1;\\n        }\\n        queue<int> q;\\n        for (i = 0; i < n; i ++) {\\n            if (edge_count[i] == 1) {\\n                q.push(i);\\n            }\\n        }\\n\\n        int root, root1, q_size;\\n        while (n > 2) {\\n            q_size = q.size();\\n            for (i = 0; i < q_size; i ++) {\\n                root = q.front(); q.pop();\\n                root1 = edge_sum[root];   // leaf only connect to 1 node, sum equals to node index\\n                edge_sum[root1] -= root;\\n                edge_count[root1] --;\\n                if (edge_count[root1] == 1) {\\n                    q.push(root1);\\n                }\\n                edge_count[root] = -1;\\n                n --;\\n            }\\n        }\\n        vector<int> ans;\\n        for (i = 0; i < n0; i ++) {\\n            if (edge_count[i] > -1) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        int i, n1, n2, n0 = n;\\n        edges.push_back(vector<int> (2, 0));\\n        for (i = 0; i < n - 1; i ++) {\\n            n1 = edges[i][0] % n;\\n            n2 = edges[i][1] % n;\\n            edges[n1][0] += 1 * n;  // edge count\\n            edges[n2][0] += 1 * n;\\n            edges[n1][1] += n2 * n;  //edge sum\\n            edges[n2][1] += n1 * n;\\n        }\\n        for (i = 0; i < n; i ++) {\\n            edges[i][0] /= n;\\n            edges[i][1] /= n;\\n        }\\n        queue<int> q;\\n        for (i = 0; i < n; i ++) {\\n            if (edges[i][0] == 1) {\\n                q.push(i);\\n            }\\n        }\\n\\n        int root, root1, q_size;\\n        while (n > 2) {\\n            q_size = q.size();\\n            for (i = 0; i < q_size; i ++) {\\n                root = q.front(); q.pop();\\n                root1 = edges[root][1];   // leaf only connect to 1 node, sum equals to node index\\n                edges[root1][1] -= root;\\n                edges[root1][0] --;\\n                if (edges[root1][0] == 1) {\\n                    q.push(root1);\\n                }\\n                edges[root][0] = -1;\\n                n --;\\n            }\\n        }\\n        vector<int> ans;\\n        for (i = 0; i < n0; i ++) {\\n            if (edges[i][0] > -1) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820719,
                "title": "java-o-n-time-and-o-n-v-space-bfs-solution-with-comments",
                "content": "If you liked this solution, please upvote it.\\nThanks\\n\\n```\\nclass Solution {\\n    \\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // edge case\\n        if (n <= 1) return Arrays.asList(new Integer[]{0});\\n        \\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        // filling empty graph with empty list of connections\\n        for (int i = 0; i < n; i ++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        // fill connections, connect one to another and vice versa;\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            graph[edge[0]].add(edge[1]); \\n            graph[edge[1]].add(edge[0]); \\n        }\\n        // exclude actually all nodes with 1 connection\\n        // as they might be the source of max height tree\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (graph[i].size() == 1) {\\n                queue.add(i);\\n            }\\n        }\\n        // while resulting amount of nodes not redused to 2 or 1\\n        while ( n > 2) {\\n            int size = queue.size();\\n            n -= size;\\n            while (size > 0) {\\n                // removing connections one by one\\n\\t\\t\\t\\t// each vertex in a queue already had one coonnection\\n                Integer curr = queue.poll();\\n\\t\\t\\t\\t// this is that one connection\\n                Integer next = graph[curr].get(0);\\n\\t\\t\\t\\t// remove current vertex from connection list\\n                graph[next].remove(curr);\\n\\t\\t\\t\\t// if connection list reduced to one vertex - add it to the queue\\n                if (graph[next].size() == 1) {\\n                    queue.add(next);\\n                }\\n\\t\\t\\t\\t// clear current vertext connections.\\n                graph[curr].clear();\\n                size--;\\n            }\\n        }\\n        return (List) queue;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        // edge case\\n        if (n <= 1) return Arrays.asList(new Integer[]{0});\\n        \\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        // filling empty graph with empty list of connections\\n        for (int i = 0; i < n; i ++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        // fill connections, connect one to another and vice versa;\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            graph[edge[0]].add(edge[1]); \\n            graph[edge[1]].add(edge[0]); \\n        }\\n        // exclude actually all nodes with 1 connection\\n        // as they might be the source of max height tree\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (graph[i].size() == 1) {\\n                queue.add(i);\\n            }\\n        }\\n        // while resulting amount of nodes not redused to 2 or 1\\n        while ( n > 2) {\\n            int size = queue.size();\\n            n -= size;\\n            while (size > 0) {\\n                // removing connections one by one\\n\\t\\t\\t\\t// each vertex in a queue already had one coonnection\\n                Integer curr = queue.poll();\\n\\t\\t\\t\\t// this is that one connection\\n                Integer next = graph[curr].get(0);\\n\\t\\t\\t\\t// remove current vertex from connection list\\n                graph[next].remove(curr);\\n\\t\\t\\t\\t// if connection list reduced to one vertex - add it to the queue\\n                if (graph[next].size() == 1) {\\n                    queue.add(next);\\n                }\\n\\t\\t\\t\\t// clear current vertext connections.\\n                graph[curr].clear();\\n                size--;\\n            }\\n        }\\n        return (List) queue;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732735,
                "title": "python-3-onion-peel-of-leaves-based-on-william-fisset-s-video",
                "content": "https://www.youtube.com/watch?v=nzF_9bjDzdc\\n\\nRuntime: 252 ms, faster than 80.44% of Python3 online submissions for Minimum Height Trees.\\nMemory Usage: 17.7 MB, less than 80.23% of Python3 online submissions for Minimum Height Trees.\\n\\n```\\n# minimum height tree = center of undirected graph,if its tree\\n\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def __init__(self):\\n        self.adjacency_list = defaultdict(list)\\n\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        \\n        ingress_count = [0]*n\\n    \\n        #creare adjacency and ingress count\\n        for edge_to, edge_from in edges:\\n            self.adjacency_list[edge_to].append(edge_from)\\n            self.adjacency_list[edge_from].append(edge_to)\\n            ingress_count[edge_from] += 1\\n            ingress_count[edge_to] += 1\\n        \\n        \\n        #find leaves , ingress_count == 1\\n        leaves = [node for node in range(n) if ingress_count[node] < 2]\\n        count_of_nodes_visited = 0\\n        \\n        #do onion peel and remove the leaves on by one\\n        # by decreasing the ingress count\\n        # but \\n        while count_of_nodes_visited < n - 2:   \\n            new_leaves = []\\n            for leave in leaves:\\n                #lets add the next layer to queue to process later\\n                # and simulate removing the leave layer too\\n                for kid in self.adjacency_list[leave]:\\n                    ingress_count[kid] -= 1 \\n                    if ingress_count[kid] == 1:\\n                        new_leaves.append(kid)\\n                #set leaves = 0\\n                ingress_count[leave] = 0\\n                leaves = new_leaves\\n                count_of_nodes_visited += 1\\n                # print(leaves, count_of_nodes_visited)\\n\\n        return leaves\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# minimum height tree = center of undirected graph,if its tree\\n\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def __init__(self):\\n        self.adjacency_list = defaultdict(list)\\n\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        \\n        ingress_count = [0]*n\\n    \\n        #creare adjacency and ingress count\\n        for edge_to, edge_from in edges:\\n            self.adjacency_list[edge_to].append(edge_from)\\n            self.adjacency_list[edge_from].append(edge_to)\\n            ingress_count[edge_from] += 1\\n            ingress_count[edge_to] += 1\\n        \\n        \\n        #find leaves , ingress_count == 1\\n        leaves = [node for node in range(n) if ingress_count[node] < 2]\\n        count_of_nodes_visited = 0\\n        \\n        #do onion peel and remove the leaves on by one\\n        # by decreasing the ingress count\\n        # but \\n        while count_of_nodes_visited < n - 2:   \\n            new_leaves = []\\n            for leave in leaves:\\n                #lets add the next layer to queue to process later\\n                # and simulate removing the leave layer too\\n                for kid in self.adjacency_list[leave]:\\n                    ingress_count[kid] -= 1 \\n                    if ingress_count[kid] == 1:\\n                        new_leaves.append(kid)\\n                #set leaves = 0\\n                ingress_count[leave] = 0\\n                leaves = new_leaves\\n                count_of_nodes_visited += 1\\n                # print(leaves, count_of_nodes_visited)\\n\\n        return leaves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682681,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\\n        if n == 1 {\\n            return vec![0];\\n        }\\n        let mut degrees = vec![0; n as usize];\\n        let mut queue = VecDeque::new();\\n        let mut graph = vec![Vec::new(); n as usize];\\n        let mut num_vertexes = n;\\n\\n        edges.iter().for_each(|edge| {\\n            graph[edge[0] as usize].push(edge[1]);\\n            graph[edge[1] as usize].push(edge[0]);\\n        });\\n\\n        for edge in edges {\\n            let first_vertex = edge[0] as usize;\\n            let second_vertex = edge[1] as usize;\\n            degrees[first_vertex] = degrees[first_vertex] + 1;\\n            degrees[second_vertex] = degrees[second_vertex] + 1;\\n        }\\n\\n        degrees.iter().enumerate().for_each(|(idx, degree)| if *degree == 1 {queue.push_back(idx)});\\n\\n        while num_vertexes > 2 {\\n            for _ in 0..queue.len() {\\n                let leaf_to_remove = queue.pop_front().unwrap() as usize;\\n                num_vertexes -= 1;\\n\\n                degrees[leaf_to_remove] = degrees[leaf_to_remove] - 1;\\n\\n                for adjacent_vertex in &graph[leaf_to_remove] {\\n                    degrees[*adjacent_vertex as usize] = degrees[*adjacent_vertex as usize] - 1;\\n\\n                    if degrees[*adjacent_vertex as usize] == 1 {\\n                        queue.push_back(*adjacent_vertex as usize);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return queue.iter().map(|val| *val as i32).collect();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\\n        if n == 1 {\\n            return vec![0];\\n        }\\n        let mut degrees = vec![0; n as usize];\\n        let mut queue = VecDeque::new();\\n        let mut graph = vec![Vec::new(); n as usize];\\n        let mut num_vertexes = n;\\n\\n        edges.iter().for_each(|edge| {\\n            graph[edge[0] as usize].push(edge[1]);\\n            graph[edge[1] as usize].push(edge[0]);\\n        });\\n\\n        for edge in edges {\\n            let first_vertex = edge[0] as usize;\\n            let second_vertex = edge[1] as usize;\\n            degrees[first_vertex] = degrees[first_vertex] + 1;\\n            degrees[second_vertex] = degrees[second_vertex] + 1;\\n        }\\n\\n        degrees.iter().enumerate().for_each(|(idx, degree)| if *degree == 1 {queue.push_back(idx)});\\n\\n        while num_vertexes > 2 {\\n            for _ in 0..queue.len() {\\n                let leaf_to_remove = queue.pop_front().unwrap() as usize;\\n                num_vertexes -= 1;\\n\\n                degrees[leaf_to_remove] = degrees[leaf_to_remove] - 1;\\n\\n                for adjacent_vertex in &graph[leaf_to_remove] {\\n                    degrees[*adjacent_vertex as usize] = degrees[*adjacent_vertex as usize] - 1;\\n\\n                    if degrees[*adjacent_vertex as usize] == 1 {\\n                        queue.push_back(*adjacent_vertex as usize);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return queue.iter().map(|val| *val as i32).collect();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 666238,
                "title": "c-different-flavor-of-bfs-with-explanation",
                "content": "Idea is to find the center of the given graph from which the height to the leaf is minimum.  The center node can be one or two. In other words, if the longest path in the given graph has even number of nodes, then we will have two centers as our answer and for odd number of nodes, we will have only 1 center as our answer.\\n\\nExample 1 in description, the longest path is 0->1->2 or 0->1->3 (total 3 nodes) so 1 is our answer.\\nExample 2 in description, the longest path is 1 or 2 or 0->3->4->5 (total 4 nodes) so answer is 3,4.\\n\\nA node which has only one node connected to it in its adjacency list is called as leaf node.\\n\\nRemoving the leaf node means we have to remove this leaf from the adjacency list of the leaf\\'s adjacent node.\\nThe adjacent node may still have two or more nodes connected to it or it would have become leaf node as we removed a leaf before. At any point, after removing the leaf if the adjacent node becomes leaf then add it to a new leaf list for next iteration of removal. \\n\\nThe exit condtion is n>2 because the number of nodes left after removing leaf nodes will either be two or one, which is our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)\\n    {\\n        vector<int> leaves;\\n        vector<vector<int>> graph(n,vector<int>());\\n        \\n        for(auto ed : edges)\\n        {\\n            graph[ed[0]].push_back(ed[1]);\\n            graph[ed[1]].push_back(ed[0]);\\n        }\\n        //Prepare the list of leaves to remove\\n        for(int i=0;i<n;i++)\\n        {\\n            if(graph[i].size()==1)\\n                leaves.push_back(i);\\n        }\\n        while(n>2)\\n        {\\n            n-=leaves.size();\\n            vector<int> new_leaves;\\n            for(auto leaf : leaves)\\n            {\\n                int adj = graph[leaf][0];\\n                vector<int>::iterator itr = remove(graph[adj].begin(),graph[adj].end(),leaf);\\n                graph[adj].erase(itr,graph[adj].end());\\n                if(graph[adj].size()==1)\\n                    new_leaves.push_back(adj);\\n            }\\n            leaves = new_leaves;\\n        }\\n        if(leaves.size()==0)\\n            return {0};\\n        return leaves;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)\\n    {\\n        vector<int> leaves;\\n        vector<vector<int>> graph(n,vector<int>());\\n        \\n        for(auto ed : edges)\\n        {\\n            graph[ed[0]].push_back(ed[1]);\\n            graph[ed[1]].push_back(ed[0]);\\n        }\\n        //Prepare the list of leaves to remove\\n        for(int i=0;i<n;i++)\\n        {\\n            if(graph[i].size()==1)\\n                leaves.push_back(i);\\n        }\\n        while(n>2)\\n        {\\n            n-=leaves.size();\\n            vector<int> new_leaves;\\n            for(auto leaf : leaves)\\n            {\\n                int adj = graph[leaf][0];\\n                vector<int>::iterator itr = remove(graph[adj].begin(),graph[adj].end(),leaf);\\n                graph[adj].erase(itr,graph[adj].end());\\n                if(graph[adj].size()==1)\\n                    new_leaves.push_back(adj);\\n            }\\n            leaves = new_leaves;\\n        }\\n        if(leaves.size()==0)\\n            return {0};\\n        return leaves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655594,
                "title": "python-simple-clean-and-fast-bfs-solution",
                "content": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        graph = [[] for _ in range(n)]\\n        degree = [0] * n\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            degree[a] += 1\\n            degree[b] += 1\\n        cur = [i for i in range(n) if degree[i] == 1]\\n        while cur:\\n            nxt = []\\n            for node in cur:\\n                degree[node] -= 1\\n                for _node in graph[node]:\\n                    degree[_node] -= 1\\n                    if degree[_node] == 1:\\n                        nxt.append(_node)\\n            if not nxt: # if nxt is empty, it means cur is the result.\\n                return cur\\n            cur = nxt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        graph = [[] for _ in range(n)]\\n        degree = [0] * n\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            degree[a] += 1\\n            degree[b] += 1\\n        cur = [i for i in range(n) if degree[i] == 1]\\n        while cur:\\n            nxt = []\\n            for node in cur:\\n                degree[node] -= 1\\n                for _node in graph[node]:\\n                    degree[_node] -= 1\\n                    if degree[_node] == 1:\\n                        nxt.append(_node)\\n            if not nxt: # if nxt is empty, it means cur is the result.\\n                return cur\\n            cur = nxt\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1724899,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1570301,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1565804,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1993611,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1846144,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1715557,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1573611,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1567346,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1571562,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1571561,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1724899,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1570301,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1565804,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1993611,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1846144,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1715557,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1573611,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1567346,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1571562,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 1571561,
                "content": [
                    {
                        "username": "beautyofdeduction",
                        "content": "While this problem wasn\\'t easy, I found it to be very good practice for the following common tree tasks:\\n* finding the diameter of a tree\\n* finding the path between two vertices of a tree\\n* understanding that the root of the min-height tree is the \"center of gravity\"\\n\\nI realized it was a hard for me because I did not understand these tree fundamentals. I\\'m glad I persevered and learned."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@suren-yeager](/suren-yeager) Check out this solution: https://leetcode.com/problems/minimum-height-trees/solutions/923071/python-find-diameter-using-2-dfs-explained/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "where did we use the diameter concept?"
                    },
                    {
                        "username": "nckshr",
                        "content": "Does anyone else find it confusing that this is compared to topological sort? Topological sort is defined as \"for any edge u->v, u comes before v in the ordering\". However, here we have undirected edges so by definition this is something different. Also, the given solution labeled \"Approach: Topological Sort\" does not really look much like the other topological sort solutions I\\'ve seen (trimming leaf nodes layer by layer as opposed to DFS + book keeping). To be fair, it is also called \"topological-alike\" in the description, but there seems to be so little overlap in concept I\\'m not sure why the comparison is useful. What am I missing here?"
                    },
                    {
                        "username": "Achintya_Bhat",
                        "content": "It is similar to Kahn\\'s algorithm for topological sorting."
                    },
                    {
                        "username": "coda_209",
                        "content": "I agree with you. The term \"Topological Sort\" is misleading. Perhaps they could have called it as \"Reverse Bottom Up Traversal\"."
                    },
                    {
                        "username": "rick_014",
                        "content": "Topological sort using BFS is relatable."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-height-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Topological Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Raghavagg",
                        "content": "just when i thought i have mastered graphs"
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: delete those nodes with only one connection repeatly, the only 1 or 2 nodes left are the answer. "
                    },
                    {
                        "username": "imsb5678",
                        "content": "that ain\\'t a hint that\\'s straight up the solution in one sentence..."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is a rough one..."
                    },
                    {
                        "username": "ltbtb_rise",
                        "content": "I am just wondering how many of you have worked it out without seeing any hints or saw this problem before?"
                    },
                    {
                        "username": "godshiva",
                        "content": "If I did I wouldn\\'t be in the discussion section right now ;)  I copied my solution where I fixed the first TLE with a bundling solution, now I got my second TLE and I\\'m out of ideas.. 50 seconds on my local machine, which is faster than LC vms for sure"
                    },
                    {
                        "username": "NIO_up_to_moon",
                        "content": "\\u5173\\u4E8E\\u65E0\\u5411\\u56FE\\u6C42\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u65B9\\u6CD5\\uFF0C\\u4EFB\\u9009\\u4E00\\u4E2A\\u8282\\u70B9Q\\uFF0Cdfs\\u5230\\u7EC8\\u70B9W\\u505C\\u6B62\\uFF0C\\u5219W\\u4E3AQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84\\uFF0C\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u4E00\\u4E2A\\u7AEF\\u70B9\\uFF0C\\n\\u518D\\u4EE5\\u6B64\\u7AEF\\u70B9dfs\\u627E\\u5230\\u53E6\\u4E00\\u4E2A\\u7AEF\\u70B9\\nproof:\\u5047\\u8BBEQ\\u4E3A\\u8D77\\u70B9\\u7684\\u6700\\u957F\\u8DEF\\u5F84Qm\\u82E5\\u4E0D\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\uFF1A\\n\\u5047\\u8BBEA,B\\u4E3A\\u6700\\u957F\\u8DEF\\u5F842\\u7AEF\\u70B9\\n1.\\u8BE5\\u8DEF\\u5F84\\u4E0D\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5047\\u8BBEQ\\u901A\\u8FC7\\u53E6\\u4E00\\u6761\\u8DEF\\u5F84\\u4E0E\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u4EA4\\u4E8Eq,\\u82E5max(Aq,Bq)+qQ<Qm,\\u5219\\u53EF\\u4EE5\\u6784\\u9020\\u65B0\\u7684\\u6700\\u957F\\u8DEF\\u5F84max(Aq,Bq)+qQ+Qm>Aq+Bq\\n\\u5219\\u4E00\\u5B9A\\u4E0E\\u6700\\u957F\\u8DEF\\u5F84\\u76F8\\u4EA4\\n2.\\u5047\\u8BBE\\u8BE5\\u8DEF\\u5F84\\u76F8\\u4EA4\\u4E8Eq\\u70B9(\\u975E2\\u4E2A\\u7AEF\\u70B9)\\uFF0C\\u53CD\\u8BC1\\uFF1A\\n\\u5219\\u8BE5\\u4ECEQ\\u51FA\\u53D1\\u7684\\u6700\\u957F\\u8DEF\\u5F84==Qq+qm>=Qq+max(qA,qB),\\u53EF\\u63A8\\u51FAqm>=max(qA,qB),\\u53EF\\u6784\\u9020\\u65B0\\u6700\\u957F\\u8DEF\\u5F84max(qA,qB)+qm>qA+qB\\n\\u5219\\u8BE5\\u8DEF\\u5F84\\u5FC5\\u4E3A\\u56FE\\u6700\\u957F\\u8DEF\\u5F84\\u7684\\u7AEF\\u70B9\\n3\\u76F8\\u4EA4\\u4E8E\\u7AEF\\u70B9\\uFF0C\\u5219q\\u4E3AA or B,\\u5FC5\\u987Bqm==0\\uFF0C\\u4E0D\\u7136\\u53EF\\u4EE5\\u6784\\u5EFAAB+qm>AB\\n\\u6240\\u4EE5q==m==(A or B)"
                    },
                    {
                        "username": "JustinMei",
                        "content": "[@Kaltu](/Kaltu) I have reported several non-English content but nothing happened. So I suspect the report function is just a trick."
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@alisink](/alisink) Please help reporting it by \\n1. Mouse hover around \"Reply\"\\n2. Click ... option next to \"Share\"\\n3. Click \"Report\"\\n4. Click \"Non English content\"\\n5. Click \"Confirm\"\\nThank you"
                    },
                    {
                        "username": "alisink",
                        "content": "write in english\\n"
                    },
                    {
                        "username": "TWiStErRob",
                        "content": "These three are from the Problem description:\\n> For a undirected graph with tree characteristics  \\n> Given such a graph  \\n> \\u201ca tree is an undirected graph in which any two vertices are connected by exactly one path\"\\n\\nBased on the above:\\n\\n * `0, []` is kind-of a valid input, the tree has no nodes, there aren't anything to be connected, and all of those none are connected with exactly one path. The expectation of `[]` as a result is valid, because there's no node to pick.\\n * `1, []` is a valid input, the tree has 1 node, there aren't any two vertices, so all of those are connected by exactly one path. The expectation of `[0]` as a result is valid, because the single node can be picked as root.\\n * `2, []` is not a valid input, this tree has 2 independent nodes, so if I pick those two nodes there exists no path between them. The expectation of `[0,1]` as a result is not valid, because either one is picked, the other is not part of the resulting structure.\\n * `n, []`  (3 <= n) is not a valid input, this tree has 3 independent nodes, so if I pick any two of those `n` nodes there exists no path between them. The expectation of `[]` is valid, because any of them is picked, the others are not part of the resulting structure.\\n\\nI got bitten by the `1, []` test case, I'm not sure if there's a `2, []` or higher test case in the lot, but the verifier returns the above expectations when pressing \"Run code\" which could be misleading."
                    },
                    {
                        "username": "leetcodebic",
                        "content": "why is O(n)? I think remove() method in ArrayList is O(n). And overall time complexity will be O(n2)"
                    }
                ]
            },
            {
                "id": 2064996,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 2032622,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 2022411,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 2016425,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 2016014,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 2008255,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 1997200,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 1922901,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 1910376,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            },
            {
                "id": 1898244,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "\\'Medium\\'?! Are you kidding me?!"
                    },
                    {
                        "username": "alice0217",
                        "content": "if you wonder how many MHTs a graph can have at most: https://stackoverflow.com/questions/63237671/how-many-minimum-height-trees-mhts-can-a-graph-have-at-most#:~:text=So%20at%20most%202%20different,path%20between%20two%20tree%20nodes."
                    },
                    {
                        "username": "Archit_Verma",
                        "content": "can anyone tell me what is wrong with my code please.\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        vector<int> ans;\\n        vector<vector<int>> adj(n);\\n        vector<int> indegree(n, 0);\\n        queue<pair<int,int>> q;\\n        queue<int> help;\\n        int mini = INT_MIN; \\n        help.push(mini);\\n        \\n        for (auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n            indegree[v]++;\\n        }\\n        \\n        int count = INT_MAX;\\n       for (int i = 0; i < n; i++) {\\n    vector<int> vis(n, 0);  // Reset vis array for each traversal\\n            \\n    int h = 0;\\n    q.push({i, 0});\\n    while (!q.empty()) {\\n        auto f = q.front();\\n        h = f.second;\\n        q.pop();\\n        for (auto it : adj[f.first]) {\\n            if (vis[it] != 1) {\\n                vis[it] = 1;\\n                        \\n                q.push({it, h+1});\\n            }\\n        }\\n    }\\n\\n    if (h < count) {\\n        count = h;  // Update count outside the if block\\n        while (!help.empty()) {\\n            help.pop();\\n        }\\n        help.push(i);\\n    } else if (h == count) {\\n        help.push(i);\\n    }\\n  \\n}\\n        \\n        while (!help.empty()) {\\n            ans.push_back(help.front());\\n            help.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I would like to improve the description `any connected graph without simple cycles is a tree.`. Why the word `simple` is used? \\nI makes me confused, do we have some `simple` and `complex` pathes? \\n\\nI would like to suggest to remove the word and keep `any connected graph without cycles is a tree.` which is valid statement https://en.wikipedia.org/wiki/Tree_(graph_theory) "
                    },
                    {
                        "username": "dapperllama",
                        "content": "Can someone explain why this test case: [[0,1],[0,2],[0,3],[3,4],[4,5]] has an expected output of [3], when my algorithm says [0,4]? If 3 was the root, then the min heights would be 2 (3-> 0 -> 1 and 3 - > 4 -> 5), whereas root of 0 has a min height of just 1, since there is only one edge from 0 -> 1. Thanks in advance!"
                    },
                    {
                        "username": "dapperllama",
                        "content": "[@Kaltu](/Kaltu) Thanks, you\\'re right -- my bad!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Read the problem statement more carefully\nThe **height** of a rooted tree is the number of edges on the ***longest*** downward path between the root and a leaf."
                    },
                    {
                        "username": "tomerezon",
                        "content": "What\\'s Going on with the 71st testcase?"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "New fear unlocked! just when i was thinking, I\\'m getting close with graphs."
                    },
                    {
                        "username": "darkillers",
                        "content": "Ruby solution is no longer passing even the algorithm is right."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "This should be a HARD problem, its not medium. very hard to know what algo to apply here.\\n"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "In C I have this error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffd9f2e6ff8 (pc 0x55a4855e02e5 bp 0x7ffd9f2e7010 sp 0x7ffd9f2e7000 T0)\n==22==ABORTING"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "ig it can happen when we use recursion for traversal but the traversal does not end resulting in endless calls....."
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "It is what it says \"Stack Overflow\"!"
                    }
                ]
            }
        ]
    }
]