[
    {
        "title": "Largest Rectangle in Histogram",
        "question_content": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n&nbsp;\nExample 1:\n\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\nExample 2:\n\nInput: heights = [2,4]\nOutput: 4\n\n&nbsp;\nConstraints:\n\n\t1 <= heights.length <= 105\n\t0 <= heights[i] <= 104",
        "solutions": [
            {
                "id": 28902,
                "title": "5ms-o-n-java-solution-explained-beats-96",
                "content": "For any bar `i` the maximum rectangle is of width `r - l - 1` where r - is the last coordinate of the bar to the **right** with height `h[r] >= h[i]` and l - is the last coordinate of the bar to the **left** which height `h[l] >= h[i]`\\n\\nSo if for any `i` coordinate we know his utmost higher (or of the same height) neighbors to the right and to the left, we can easily find the largest rectangle:\\n\\n    int maxArea = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));\\n    }\\n\\nThe main trick is how to effectively calculate `lessFromRight` and `lessFromLeft` arrays. The trivial solution is to use **O(n^2)** solution and for each `i` element first find his left/right heighbour in the second inner loop just iterating back or forward:\\n\\n    for (int i = 1; i < height.length; i++) {              \\n        int p = i - 1;\\n        while (p >= 0 && height[p] >= height[i]) {\\n            p--;\\n        }\\n        lessFromLeft[i] = p;              \\n    }\\n\\nThe only line change shifts this algorithm from **O(n^2)** to **O(n)** complexity: we don't need to rescan each item to the left - we can reuse results of previous calculations and \"jump\" through indices in quick manner:\\n\\n    while (p >= 0 && height[p] >= height[i]) {\\n          p = lessFromLeft[p];\\n    }\\n\\nHere is the whole solution:\\n\\n    public static int largestRectangleArea(int[] height) {\\n        if (height == null || height.length == 0) {\\n            return 0;\\n        }\\n        int[] lessFromLeft = new int[height.length]; // idx of the first bar the left that is lower than current\\n        int[] lessFromRight = new int[height.length]; // idx of the first bar the right that is lower than current\\n        lessFromRight[height.length - 1] = height.length;\\n        lessFromLeft[0] = -1;\\n\\n        for (int i = 1; i < height.length; i++) {\\n            int p = i - 1;\\n\\n            while (p >= 0 && height[p] >= height[i]) {\\n                p = lessFromLeft[p];\\n            }\\n            lessFromLeft[i] = p;\\n        }\\n\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            int p = i + 1;\\n\\n            while (p < height.length && height[p] >= height[i]) {\\n                p = lessFromRight[p];\\n            }\\n            lessFromRight[i] = p;\\n        }\\n\\n        int maxArea = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));\\n        }\\n\\n        return maxArea;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "For any bar `i` the maximum rectangle is of width `r - l - 1` where r - is the last coordinate of the bar to the **right** with height `h[r] >= h[i]` and l - is the last coordinate of the bar to the **left** which height `h[l] >= h[i]`\\n\\nSo if for any `i` coordinate we know his utmost higher (or of the same height) neighbors to the right and to the left, we can easily find the largest rectangle:\\n\\n    int maxArea = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));\\n    }\\n\\nThe main trick is how to effectively calculate `lessFromRight` and `lessFromLeft` arrays. The trivial solution is to use **O(n^2)** solution and for each `i` element first find his left/right heighbour in the second inner loop just iterating back or forward:\\n\\n    for (int i = 1; i < height.length; i++) {              \\n        int p = i - 1;\\n        while (p >= 0 && height[p] >= height[i]) {\\n            p--;\\n        }\\n        lessFromLeft[i] = p;              \\n    }\\n\\nThe only line change shifts this algorithm from **O(n^2)** to **O(n)** complexity: we don't need to rescan each item to the left - we can reuse results of previous calculations and \"jump\" through indices in quick manner:\\n\\n    while (p >= 0 && height[p] >= height[i]) {\\n          p = lessFromLeft[p];\\n    }\\n\\nHere is the whole solution:\\n\\n    public static int largestRectangleArea(int[] height) {\\n        if (height == null || height.length == 0) {\\n            return 0;\\n        }\\n        int[] lessFromLeft = new int[height.length]; // idx of the first bar the left that is lower than current\\n        int[] lessFromRight = new int[height.length]; // idx of the first bar the right that is lower than current\\n        lessFromRight[height.length - 1] = height.length;\\n        lessFromLeft[0] = -1;\\n\\n        for (int i = 1; i < height.length; i++) {\\n            int p = i - 1;\\n\\n            while (p >= 0 && height[p] >= height[i]) {\\n                p = lessFromLeft[p];\\n            }\\n            lessFromLeft[i] = p;\\n        }\\n\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            int p = i + 1;\\n\\n            while (p < height.length && height[p] >= height[i]) {\\n                p = lessFromRight[p];\\n            }\\n            lessFromRight[i] = p;\\n        }\\n\\n        int maxArea = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));\\n        }\\n\\n        return maxArea;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28917,
                "title": "ac-python-clean-solution-using-stack-76ms",
                "content": "    def largestRectangleArea(self, height):\\n        height.append(0)\\n        stack = [-1]\\n        ans = 0\\n        for i in xrange(len(height)):\\n            while height[i] < height[stack[-1]]:\\n                h = height[stack.pop()]\\n                w = i - stack[-1] - 1\\n                ans = max(ans, h * w)\\n            stack.append(i)\\n        height.pop()\\n        return ans\\n\\n\\n\\n    # 94 / 94 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 97.34%\\n\\nThe stack maintain the indexes of buildings with ascending height. Before adding a new building pop the building who is taller than the new one. The building popped out represent the height of a rectangle with the new building as the right boundary and the current stack top as the left boundary. Calculate its area and update ans of maximum area. Boundary is handled using dummy buildings.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def largestRectangleArea(self, height):\\n        height.append(0)\\n        stack = [-1]\\n        ans = 0\\n        for i in xrange(len(height)):\\n            while height[i] < height[stack[-1]]:\\n                h = height[stack.pop()]\\n                w = i - stack[-1] - 1\\n                ans = max(ans, h * w)\\n            stack.append(i)\\n        height.pop()\\n        return ans\\n\\n\\n\\n    # 94 / 94 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 97.34%\\n\\nThe stack maintain the indexes of buildings with ascending height. Before adding a new building pop the building who is taller than the new one. The building popped out represent the height of a rectangle with the new building as the right boundary and the current stack top as the left boundary. Calculate its area and update ans of maximum area. Boundary is handled using dummy buildings.",
                "codeTag": "Python3"
            },
            {
                "id": 28900,
                "title": "short-and-clean-o-n-stack-based-java-solution",
                "content": "For explanation, please see https://bit.ly/2we8Wfx\\n\\n```\\n    public int largestRectangleArea(int[] heights) {\\n        int len = heights.length;\\n        Stack<Integer> s = new Stack<>();\\n        int maxArea = 0;\\n        for (int i = 0; i <= len; i++){\\n            int h = (i == len ? 0 : heights[i]);\\n            if (s.isEmpty() || h >= heights[s.peek()]) {\\n                s.push(i);\\n            } else {\\n                int tp = s.pop();\\n                maxArea = Math.max(maxArea, heights[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));\\n                i--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n```\\n\\nOP\\'s Note: Two years later I need to interview again. I came to this problem and I couldn\\'t understand this solution. After reading the explanation through the link above, I finally figured this out again. \\nTwo key points that I found helpful while understanding the solution: \\n\\n1. When a bar is popped, we calculate the area with the popped bar at index ``tp`` as shortest bar. Now we know the rectangle **height** is ``heights[tp]``, we just need rectangle width to calculate the area.\\n2. How to determine rectangle **width**? The maximum width we can have here would be made of all connecting bars with height greater than or equal to ``heights[tp]``. ``heights[s.peek() + 1] >= heights[tp]`` because the index on top of the stack right now ``s.peek()`` is the first index left of ``tp`` with height smaller than tp\\'s height (if ``s.peek()`` was greater then it should have already been poped out of the stack). ``heights[i - 1] >= heights[tp]`` because index ``i`` is the first index right of ``tp`` with height smaller than tp\\'s height (if ``i`` was greater then ``tp`` would have remained on the stack). Now we multiply height ``heights[tp]`` by width ``i - 1 - s.peek()`` to get the **area**.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int largestRectangleArea(int[] heights) {\\n        int len = heights.length;\\n        Stack<Integer> s = new Stack<>();\\n        int maxArea = 0;\\n        for (int i = 0; i <= len; i++){\\n            int h = (i == len ? 0 : heights[i]);\\n            if (s.isEmpty() || h >= heights[s.peek()]) {\\n                s.push(i);\\n            } else {\\n                int tp = s.pop();\\n                maxArea = Math.max(maxArea, heights[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));\\n                i--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28905,
                "title": "my-concise-c-solution-ac-90-ms",
                "content": "I push a sentinel node back into the end of height to make the code logic more concise.\\n  \\n\\n      class Solution {\\n        public:\\n            int largestRectangleArea(vector<int> &height) {\\n                \\n                int ret = 0;\\n                height.push_back(0);\\n                vector<int> index;\\n                \\n                for(int i = 0; i < height.size(); i++)\\n                {\\n                    while(index.size() > 0 && height[index.back()] >= height[i])\\n                    {\\n                        int h = height[index.back()];\\n                        index.pop_back();\\n                        \\n                        int sidx = index.size() > 0 ? index.back() : -1;\\n                        if(h * (i-sidx-1) > ret)\\n                            ret = h * (i-sidx-1);\\n                    }\\n                    index.push_back(i);\\n                }\\n                \\n                return ret;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int largestRectangleArea(vector<int> &height) {\\n                \\n                int ret = 0;\\n                height.push_back(0);\\n                vector<int> index;\\n                \\n                for(int i = 0; i < height.size(); i++)\\n                {\\n                    while(index.size() > 0 && height[index.back()] >= height[i])\\n                    {\\n                        int h = height[index.back()];\\n                        index.pop_back();\\n                        \\n                        int sidx = index.size() > 0 ? index.back() : -1;\\n                        if(h * (i-sidx-1) > ret)\\n                            ret = h * (i-sidx-1);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 29018,
                "title": "ac-clean-java-solution-using-stack",
                "content": "    public int largestRectangleArea(int[] h) {\\n      int n = h.length, i = 0, max = 0;\\n        \\n      Stack<Integer> s = new Stack<>();\\n        \\n      while (i < n) {\\n        // as long as the current bar is shorter than the last one in the stack\\n        // we keep popping out the stack and calculate the area based on\\n        // the popped bar\\n        while (!s.isEmpty() && h[i] < h[s.peek()]) {\\n          // tricky part is how to handle the index of the left bound\\n          max = Math.max(max, h[s.pop()] * (i - (s.isEmpty() ? 0 : s.peek() + 1)));\\n        }\\n        // put current bar's index to the stack\\n        s.push(i++);\\n      }\\n        \\n      // finally pop out any bar left in the stack and calculate the area based on it\\n      while (!s.isEmpty()) {\\n        max = Math.max(max, h[s.pop()] * (n - (s.isEmpty() ? 0 : s.peek() + 1)));\\n      }\\n        \\n      return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int largestRectangleArea(int[] h) {\\n      int n = h.length, i = 0, max = 0;\\n        \\n      Stack<Integer> s = new Stack<>();\\n        \\n      while (i < n) {\\n        // as long as the current bar is shorter than the last one in the stack\\n        // we keep popping out the stack and calculate the area based on\\n        // the popped bar\\n        while (!s.isEmpty() && h[i] < h[s.peek()]) {\\n          // tricky part is how to handle the index of the left bound\\n          max = Math.max(max, h[s.pop()] * (i - (s.isEmpty() ? 0 : s.peek() + 1)));\\n        }\\n        // put current bar's index to the stack\\n        s.push(i++);\\n      }\\n        \\n      // finally pop out any bar left in the stack and calculate the area based on it\\n      while (!s.isEmpty()) {\\n        max = Math.max(max, h[s.pop()] * (n - (s.isEmpty() ? 0 : s.peek() + 1)));\\n      }\\n        \\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 995249,
                "title": "python-increasing-stack-explained",
                "content": "**Key insight**: for given bar `i` with value `h`, how to find the biggest rectangle, which is ending with this bar?  We need to find the previous smallest place, where value is less or equal than `h`: that is smallest `j`, such that `j < i` and `heights[j] >= heights[i]`. Ideal data structure for these type of problems is monostack: stack which has the following invariant: elements inside will be always in increasing order. To be more clear let us consired the following histogram `[1,4,2,5,6,3,2,6,6,5,2,1,3]`. Let us go element by element and understand what is going on.\\n\\n1. Stack is empty, so just put first bar of our histogram into stack: so we have `stack = [1]`. (actually what we put inside are indexes of bars, not values, but here we look at values for simplicity).\\n2. Next we put bar `4`, and we have `[1, 4]` now. \\n3. Next, we have bar `2`, which is less than `4`. So, first we evaluate When we evaluate `H` and `W`: width and height rectangle we can construct, using last element of stack as height: they equal to `4` and `1`. Next, we extract `4` and add `2` to stack, so we have `[1, 2]` bars in stack now.\\n4. Next bar is bigger than `2`, so just add it and we have `[1, 2, 5]`\\n5. Next bar is bigger than `5`, so just add it and we have `[1, 2, 5, 6]`\\n6. Next bar is `3`, so we need to extract some stuff from our stack, until it becomes increasing one. We extract `6`, evaluate `(H, W) = (6, 1)` and extract `5` and evaluate `(H, W) = (5, 2)`. Now we have `[1, 2, 3]` in our stack.\\n7. Next bar is `2`, it is smaller than `stack[-1]`, so we again need to extract some stuff: we extract `3` and have  `(H, W) = (3, 3)` and also we extract `2` and have  `(H, W) = (2, 5)`. Note here, why exactly we have `W = 5`: because we keep in stack indexes of our bars, and we can evaluate width as `i - stack[-1] - 1`. Now, we have `stack = [1, 2]`\\n8. Next bar is `6`, so just put it to stack and we have `stack = [1, 2, 6]`.\\n9. Next bar is `6` also, and we need to extract one last element from stack and put this new `6` to stack. `(H, W) = (6, 1)`. Note, that we have in stack `[1, 2, 6]` again, but it is values, for indexes last index was increased by one.\\n10. Next bar is `5`, we extract last element from stack, have `(H, W) = (6, 2)` and put it to stack, so we have `[1, 2, 5]` now.\\n11. Next bar is `2`, so we again start to pop elements to keep increasing order: `(H, W) = (5, 3)` for fisrt step and `(H, W) = (2, 9)` for second step, now `stack = [1, 2]`.\\n12. Next bar is `1`, so we have `(H, W) = (2, 10)` and then `(H, W) = (1, 11)` and `stack = [1]`.\\n13. Next bar is `3`, so we just put it to stack and have `[1, 3]` in stack.\\n14. Next bar is `0` (we added it to process border cases), so we have `(H, W) = (3, 1)` and `(H, W) = (1, 13)` and finally stack is empty.\\n\\n**Complexity** is `O(n)`, where `n` is number of bars, space complexity is `O(n)` as well.\\n\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights):\\n        stack, ans = [], 0\\n        for i, h in enumerate(heights + [0]):\\n            while stack and heights[stack[-1]] >= h:\\n                H = heights[stack.pop()]\\n                W = i if not stack else i-stack[-1]-1\\n                ans = max(ans, H*W)\\n            stack.append(i)\\n        return ans\\n```\\n\\nSee also similar problems with monostack idea:\\n\\n**239.** Sliding Window Maximum https://leetcode.com/problems/sliding-window-maximum/discuss/951683/Python-Decreasing-deque-short-explained\\n**496.** Next Greater Element I\\n**739.** Daily Temperatures\\n**862.** Shortest Subarray with Sum at Least K\\n**901.** Online Stock Span\\n**907.** Sum of Subarray Minimums\\n**1687.** Delivering Boxes from Storage to Ports\\n\\n**Please let me know if you know more problems with this idea**\\n\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights):\\n        stack, ans = [], 0\\n        for i, h in enumerate(heights + [0]):\\n            while stack and heights[stack[-1]] >= h:\\n                H = heights[stack.pop()]\\n                W = i if not stack else i-stack[-1]-1\\n                ans = max(ans, H*W)\\n            stack.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28941,
                "title": "segment-tree-solution-just-another-idea-o-n-logn-solution",
                "content": "Inspired by this solution:\\nhttp://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n\\nJust wanna to provide another idea of how to solve this question in O(N*logN) theoretically, 40 ms solution:\\n\\n    // Largest Rectangle in Histogram\\n    // Stack solution, O(NlogN) solution\\n    \\n    class SegTreeNode {\\n    public:\\n      int start;\\n      int end;\\n      int min;\\n      SegTreeNode *left;\\n      SegTreeNode *right;\\n      SegTreeNode(int start, int end) {\\n        this->start = start;\\n        this->end = end;\\n        left = right = NULL;\\n      }\\n    };\\n    \\n    class Solution {\\n    public:\\n      int largestRectangleArea(vector<int>& heights) {\\n        if (heights.size() == 0) return 0;\\n        // first build a segment tree\\n        SegTreeNode *root = buildSegmentTree(heights, 0, heights.size() - 1);\\n        // next calculate the maximum area recursively\\n        return calculateMax(heights, root, 0, heights.size() - 1);\\n      }\\n      \\n      int calculateMax(vector<int>& heights, SegTreeNode* root, int start, int end) {\\n        if (start > end) {\\n          return -1;\\n        }\\n        if (start == end) {\\n          return heights[start];\\n        }\\n        int minIndex = query(root, heights, start, end);\\n        int leftMax = calculateMax(heights, root, start, minIndex - 1);\\n        int rightMax = calculateMax(heights, root, minIndex + 1, end);\\n        int minMax = heights[minIndex] * (end - start + 1);\\n        return max( max(leftMax, rightMax), minMax );\\n      }\\n      \\n      SegTreeNode *buildSegmentTree(vector<int>& heights, int start, int end) {\\n        if (start > end) return NULL;\\n        SegTreeNode *root = new SegTreeNode(start, end);\\n        if (start == end) {\\n            root->min = start;\\n          return root;\\n        } else {\\n          int middle = (start + end) / 2;\\n          root->left = buildSegmentTree(heights, start, middle);\\n          root->right = buildSegmentTree(heights, middle + 1, end);\\n          root->min = heights[root->left->min] < heights[root->right->min] ? root->left->min : root->right->min;\\n          return root;\\n        }\\n      }\\n      \\n      int query(SegTreeNode *root, vector<int>& heights, int start, int end) {\\n        if (root == NULL || end < root->start || start > root->end) return -1;\\n        if (start <= root->start && end >= root->end) {\\n          return root->min;\\n        }\\n        int leftMin = query(root->left, heights, start, end);\\n        int rightMin = query(root->right, heights, start, end);\\n        if (leftMin == -1) return rightMin;\\n        if (rightMin == -1) return leftMin;\\n        return heights[leftMin] < heights[rightMin] ? leftMin : rightMin;\\n      }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n      int largestRectangleArea(vector<int>& heights) {\\n        if (heights.size() == 0) return 0;\\n        // first build a segment tree\\n        SegTreeNode *root = buildSegmentTree(heights, 0, heights.size() - 1);\\n        // next calculate the maximum area recursively\\n        return calculateMax(heights, root, 0, heights.size() - 1);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1727776,
                "title": "java-c-explanation-going-from-brute-to-optimal-approach",
                "content": "```\\nWhat the Question is saying, \\nGiven an array of integers heights representing the histogram\\'s bar height where the width of each bar is 1, \\nreturn the area of the largest rectangle in the histogram.\\n```\\n\\nUnderstand this problem with an example;\\n**Input:** `heights = [2,1,5,6,2,3]`\\n![image](https://assets.leetcode.com/users/images/a844c036-9d8d-4155-a5fa-8f565822109d_1643426746.9005287.png)\\n\\nLet\\'s understand how we calculate this, let\\'s took on index 4 height is 2. If we go to the left and see where the height is less then 2 and i.e. at index 1. So, that becomes the left Boundary. Similarly if we go to right and see where the height is less then 2 & i.e. at index 6 [which is end of the array].\\n\\nNow we have left & right boundary the area could be find out by height * width. And width will get by (right - left - 1) in case of 4 that will be 6 - 1 - 1 = 4. And we know the height already i.e. 2.\\n\\nThe Area we get is 2 * 4 i.e. 8\\n\\n![image](https://assets.leetcode.com/users/images/c49249ab-e50d-487a-8761-e130f41ee36c_1643428100.9047763.png)\\n\\nThe main idea here would be how to find **left boundary & right boundary** for every index. The **brute way** is using an **ARRAY**\\n`For left boundary array:`\\n* Start with index 1, (left[0] = -1)\\n* For each index -> go to left & find the nearest index where height [index] < height[curr]\\n* Start with index 1,\\n* Eg : Index 1 : left[1] = -1\\n\\n`For right boundary array:`\\n* Start with index n - 2 right[n - 1] = n\\n* For each index -> go to right & find the nearest index where height[index] < height[curr]\\n* Start with index n - 2\\n* Eg : Index 2 : right[2] = 4\\n\\nI hope you got the point and let\\'s code this brute force Approach then we move to optimal Approach:\\n**Java**\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        if(n == 0) return 0; // Base Condition\\n        int maxArea = 0;\\n        int left[] = new int[n]; //fill left boundary\\n        int right[] = new int[n]; // fill right boundary\\n        \\n        left[0] = -1;\\n        right[n - 1] = n;\\n        \\n        for(int i = 1; i < n; i++){\\n            int prev = i - 1; // previous for comparing the heights\\n            while(prev >= 0 && heights[prev] >= heights[i]){\\n                prev = left[prev]; // we have done this to minimise the jumps we make to the left\\n            }\\n            left[i] = prev;\\n        }\\n        // Similarly we do for right\\n        for(int i = n - 2; i >= 0; i--){\\n            int prev = i + 1; \\n            while(prev < n && heights[prev] >= heights[i]){\\n                prev = right[prev]; \\n            }\\n            right[i] = prev;\\n        }\\n        // once we have these two arrays fill we need width & area\\n        for(int i = 0; i < n; i++){\\n            int width = right[i] - left[i] - 1;\\n            maxArea = Math.max(maxArea, heights[i] * width);\\n        }\\n        return maxArea;\\n        \\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        if(n == 0) return 0; // Base Condition\\n        int maxArea = 0;\\n        vector<int> left(n); //fill left boundary\\n        vector<int> right(n); // fill right boundary\\n        \\n        left[0] = -1;\\n        right[n - 1] = n;\\n        \\n        for(int i = 1; i < n; i++){\\n            int prev = i - 1; // previous for comparing the heights\\n            while(prev >= 0 && heights[prev] >= heights[i]){\\n                prev = left[prev]; // we have done this to minimise the jumps we make to the left\\n            }\\n            left[i] = prev;\\n        }\\n        // Similarly we do for right\\n        for(int i = n - 2; i >= 0; i--){\\n            int prev = i + 1; \\n            while(prev < n && heights[prev] >= heights[i]){\\n                prev = right[prev]; \\n            }\\n            right[i] = prev;\\n        }\\n        // once we have these two arrays fill we need width & area\\n        for(int i = 0; i < n; i++){\\n            int width = right[i] - left[i] - 1;\\n            maxArea = max(maxArea, heights[i] * width);\\n        }\\n        return maxArea;\\n    }\\n};\\n```\\nANALYSIS :\\n* **Time Complexity :-** BigO(N^2)\\n\\n* **Space Complexity :-** BigO(N)\\n\\nNow, let\\'s see our Optimize Approach i.e. **Using Stack**\\nSo, what we do is we take a stack & keep on adding the indexes in the stack till we get a increasing sequence. Once the sequence becomes decreasing we need to pop the element and find the area `[That\\'s the basic idea behind the stack]`\\n\\nSo, let\\'s take the stack and we are at index 1. The height of current is less than that of top of stack which is the 0th index. As the height is decreasing. So, what we do here is find the area for elements in stack\\n![image](https://assets.leetcode.com/users/images/7688de81-3901-4177-92b9-416735c81ab2_1643429827.2194455.png)\\n\\nNow, to find the area we pop the element from stack & then for that element the area becomes **height[top] * curr i.e. 1**\\nIf the stack becomes empty i.e. if this is the only element present for that we find the width and multiply with the height of top element `[width would be curr - stack.peek - 1]` where curr is right & stack.peek() is left\\n\\nFor this case we **pop \"0\"** and stack becomes **empty**, so the area becomes **height[0] * curr = 2 * 1 = 2.** So, till now maxArea we have found is 2\\n\\n![image](https://assets.leetcode.com/users/images/b4251cd2-8015-48eb-9ed4-b5bf6ffb9919_1643431407.4375658.png)\\n\\nWe will do this procedure for all the element\\'s and we will get the **maxArea i.e. 10**\\n\\n*I hope you got the idea,* **So, let\\'s code it up:**\\n**Java**\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        int maxArea = 0;\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i = 0; i <= n; i++){\\n            int currHeight = i == n ? 0 : heights[i];\\n            // check if currHeight becomes greater then height[top] element of stack. we do a push because it\\'s an increasing sequence\\n            // otherwise we do pop and find area, so for that we write a while loop\\n            while(!st.isEmpty() && currHeight < heights[st.peek()]){\\n                int top = st.pop(); // current element on which we are working\\n                // now we need width & area\\n                int width = st.isEmpty() ? i : i - st.peek() - 1; // width differ, if stack is empty or not empty after we pop the element\\n                int area = heights[top] * width; // current height * width\\n                maxArea = Math.max(area, maxArea);\\n            }\\n            // if it doesn\\'t enter in while loop, it means it\\'s an increasing sequence & we need to push index\\n            st.push(i);\\n        }\\n        return maxArea;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int maxArea = 0;\\n        stack<int> st;\\n        \\n        for(int i = 0; i <= n; i++){\\n            int currHeight = i == n ? 0 : heights[i];\\n            // check if currHeight becomes greater then height[top] element of stack. we do a push because it\\'s an increasing sequence\\n            // otherwise we do pop and find area, so for that we write a while loop\\n            while(!st.empty() && currHeight < heights[st.top()]){\\n                int top = st.top(); st.pop(); // current element on which we are working\\n                // now we need width & area\\n                int width = st.empty() ? i : i - st.top() - 1; // width differ if we stack is empty or not empty after we pop the element\\n                int area = heights[top] * width; // current height * width\\n                maxArea = max(area, maxArea);\\n            }\\n            // if it doesn\\'t enter in while loop, it means it\\'s an increasing sequence & we need to push index\\n            st.push(i);\\n        }\\n        return maxArea;\\n    }\\n};\\n```\\nANALYSIS :\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nWhat the Question is saying, \\nGiven an array of integers heights representing the histogram\\'s bar height where the width of each bar is 1, \\nreturn the area of the largest rectangle in the histogram.\\n```\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        if(n == 0) return 0; // Base Condition\\n        int maxArea = 0;\\n        int left[] = new int[n]; //fill left boundary\\n        int right[] = new int[n]; // fill right boundary\\n        \\n        left[0] = -1;\\n        right[n - 1] = n;\\n        \\n        for(int i = 1; i < n; i++){\\n            int prev = i - 1; // previous for comparing the heights\\n            while(prev >= 0 && heights[prev] >= heights[i]){\\n                prev = left[prev]; // we have done this to minimise the jumps we make to the left\\n            }\\n            left[i] = prev;\\n        }\\n        // Similarly we do for right\\n        for(int i = n - 2; i >= 0; i--){\\n            int prev = i + 1; \\n            while(prev < n && heights[prev] >= heights[i]){\\n                prev = right[prev]; \\n            }\\n            right[i] = prev;\\n        }\\n        // once we have these two arrays fill we need width & area\\n        for(int i = 0; i < n; i++){\\n            int width = right[i] - left[i] - 1;\\n            maxArea = Math.max(maxArea, heights[i] * width);\\n        }\\n        return maxArea;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        if(n == 0) return 0; // Base Condition\\n        int maxArea = 0;\\n        vector<int> left(n); //fill left boundary\\n        vector<int> right(n); // fill right boundary\\n        \\n        left[0] = -1;\\n        right[n - 1] = n;\\n        \\n        for(int i = 1; i < n; i++){\\n            int prev = i - 1; // previous for comparing the heights\\n            while(prev >= 0 && heights[prev] >= heights[i]){\\n                prev = left[prev]; // we have done this to minimise the jumps we make to the left\\n            }\\n            left[i] = prev;\\n        }\\n        // Similarly we do for right\\n        for(int i = n - 2; i >= 0; i--){\\n            int prev = i + 1; \\n            while(prev < n && heights[prev] >= heights[i]){\\n                prev = right[prev]; \\n            }\\n            right[i] = prev;\\n        }\\n        // once we have these two arrays fill we need width & area\\n        for(int i = 0; i < n; i++){\\n            int width = right[i] - left[i] - 1;\\n            maxArea = max(maxArea, heights[i] * width);\\n        }\\n        return maxArea;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        int maxArea = 0;\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i = 0; i <= n; i++){\\n            int currHeight = i == n ? 0 : heights[i];\\n            // check if currHeight becomes greater then height[top] element of stack. we do a push because it\\'s an increasing sequence\\n            // otherwise we do pop and find area, so for that we write a while loop\\n            while(!st.isEmpty() && currHeight < heights[st.peek()]){\\n                int top = st.pop(); // current element on which we are working\\n                // now we need width & area\\n                int width = st.isEmpty() ? i : i - st.peek() - 1; // width differ, if stack is empty or not empty after we pop the element\\n                int area = heights[top] * width; // current height * width\\n                maxArea = Math.max(area, maxArea);\\n            }\\n            // if it doesn\\'t enter in while loop, it means it\\'s an increasing sequence & we need to push index\\n            st.push(i);\\n        }\\n        return maxArea;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int maxArea = 0;\\n        stack<int> st;\\n        \\n        for(int i = 0; i <= n; i++){\\n            int currHeight = i == n ? 0 : heights[i];\\n            // check if currHeight becomes greater then height[top] element of stack. we do a push because it\\'s an increasing sequence\\n            // otherwise we do pop and find area, so for that we write a while loop\\n            while(!st.empty() && currHeight < heights[st.top()]){\\n                int top = st.top(); st.pop(); // current element on which we are working\\n                // now we need width & area\\n                int width = st.empty() ? i : i - st.top() - 1; // width differ if we stack is empty or not empty after we pop the element\\n                int area = heights[top] * width; // current height * width\\n                maxArea = max(area, maxArea);\\n            }\\n            // if it doesn\\'t enter in while loop, it means it\\'s an increasing sequence & we need to push index\\n            st.push(i);\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28910,
                "title": "simple-divide-and-conquer-ac-solution-without-segment-tree",
                "content": "The idea is simple: for a given range of bars, the maximum area can either from left or right half of the bars, or from the area containing the middle two bars. For the last condition, expanding from the middle two bars to find a maximum area is `O(n)`, which makes a typical Divide and Conquer solution with `T(n) = 2T(n/2) + O(n)`. Thus the overall complexity is `O(nlgn)` for time and `O(1)` for space (or `O(lgn)` considering stack usage). \\n\\nFollowing is the code accepted with 44ms. I posted this because I didn't find a similar solution, but only the RMQ idea which seemed less straightforward to me.\\n\\n    class Solution {\\n        int maxCombineArea(const vector<int> &height, int s, int m, int e) {\\n            // Expand from the middle to find the max area containing height[m] and height[m+1]\\n            int i = m, j = m+1;\\n            int area = 0, h = min(height[i], height[j]);\\n            while(i >= s && j <= e) {\\n                h = min(h, min(height[i], height[j]));\\n                area = max(area, (j-i+1) * h);\\n                if (i == s) {\\n                    ++j;\\n                }\\n                else if (j == e) {\\n                    --i;\\n                }\\n                else {\\n                    // if both sides have not reached the boundary,\\n                    // compare the outer bars and expand towards the bigger side\\n                    if (height[i-1] > height[j+1]) {\\n                        --i;\\n                    }\\n                    else {\\n                        ++j;\\n                    }\\n                }\\n            }\\n            return area;\\n        }\\n        int maxArea(const vector<int> &height, int s, int e) {\\n            // if the range only contains one bar, return its height as area\\n            if (s == e) {\\n                return height[s];\\n            }\\n            // otherwise, divide & conquer, the max area must be among the following 3 values\\n            int m = s + (e-s)/2;\\n            // 1 - max area from left half\\n            int area = maxArea(height, s, m);\\n            // 2 - max area from right half\\n            area = max(area, maxArea(height, m+1, e));\\n            // 3 - max area across the middle\\n            area = max(area, maxCombineArea(height, s, m, e));\\n            return area;\\n        }\\n    public:\\n        int largestRectangleArea(vector<int> &height) {\\n            if (height.empty()) {\\n                return 0;\\n            }\\n            return maxArea(height, 0, height.size()-1);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n        int maxCombineArea(const vector<int> &height, int s, int m, int e) {\\n            // Expand from the middle to find the max area containing height[m] and height[m+1]\\n            int i = m, j = m+1;\\n            int area = 0, h = min(height[i], height[j]);\\n            while(i >= s && j <= e) {\\n                h = min(h, min(height[i], height[j]));\\n                area = max(area, (j-i+1) * h);\\n                if (i == s) {\\n                    ++j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28963,
                "title": "python-solution-without-using-stack-with-explanation",
                "content": "The algorithm using stack actually is not quite intuitive. At least I won't think about using it at first time.\\n\\nIt is more natural to think about this way. Let left[i] to indicate how many bars to the left (including the bar at index i) are equal or higher than bar[i], right[i] is that to the right of bar[i], so the the square of the max rectangle containing bar[i] is simply height[i] * (left[i] + right[i] - 1)\\n\\n    class Solution:\\n        # @param height, a list of integer\\n        # @return an integer\\n        def largestRectangleArea(self, height):\\n            n = len(height)\\n\\n            # left[i], right[i] represent how many bars are >= than the current bar\\n\\n            left = [1] * n\\n            right = [1] * n\\n            max_rect = 0\\n\\n            # calculate left\\n            for i in range(0, n):\\n                j = i - 1\\n                while j >= 0:\\n                    if height[j] >= height[i]:\\n                        left[i] += left[j]\\n                        j -= left[j]\\n                    else: break\\n\\n            # calculate right\\n            for i in range(n - 1, -1, -1):\\n                j = i + 1\\n                while j < n:\\n                    if height[j] >= height[i]:\\n                        right[i] += right[j]\\n                        j += right[j]\\n                    else: break\\n\\n            for i in range(0, n):\\n                max_rect = max(max_rect, height[i] * (left[i] + right[i] - 1))\\n\\n            return max_rect\\n\\nNote, this algorithm runs O(n) not O(n^2)! The while loop in the for loop jumps forward or backward by the steps already calculated.",
                "solutionTags": [],
                "code": "The algorithm using stack actually is not quite intuitive. At least I won't think about using it at first time.\\n\\nIt is more natural to think about this way. Let left[i] to indicate how many bars to the left (including the bar at index i) are equal or higher than bar[i], right[i] is that to the right of bar[i], so the the square of the max rectangle containing bar[i] is simply height[i] * (left[i] + right[i] - 1)\\n\\n    class Solution:\\n        # @param height, a list of integer\\n        # @return an integer\\n        def largestRectangleArea(self, height):\\n            n = len(height)\\n\\n            # left[i], right[i] represent how many bars are >= than the current bar\\n\\n            left = [1] * n\\n            right = [1] * n\\n            max_rect = 0\\n\\n            # calculate left\\n            for i in range(0, n):\\n                j = i - 1\\n                while j >= 0:\\n                    if height[j] >= height[i]:\\n                        left[i] += left[j]\\n                        j -= left[j]\\n                    else: break\\n\\n            # calculate right\\n            for i in range(n - 1, -1, -1):\\n                j = i + 1\\n                while j < n:\\n                    if height[j] >= height[i]:\\n                        right[i] += right[j]\\n                        j += right[j]\\n                    else: break\\n\\n            for i in range(0, n):\\n                max_rect = max(max_rect, height[i] * (left[i] + right[i] - 1))\\n\\n            return max_rect\\n\\nNote, this algorithm runs O(n) not O(n^2)! The while loop in the for loop jumps forward or backward by the steps already calculated.",
                "codeTag": "Java"
            },
            {
                "id": 732697,
                "title": "44ms-easy-solution-c",
                "content": "This method is not very intuitive ..i did this with some previous knowledge of similar problems\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        // this problem should be solved using stack .\\n        /* whenever you see a monotonic increase in the input which      \\n\\t\\twould yield  the answer closest to \\n\\t\\trequired you gotta understand that you should\\n\\t\\tuse  a stack datastructure to  calculate the answer*/\\n        // so let\\'s begin by creating a stack and ans that we return \\n        stack<int> st;\\n        int ans=0;\\n        //just to make our code understand better i\\'m adding 0 at the end of\\n        //heights\\n        heights.push_back(0);\\n        /* how do you add the elements to the stack ? mmmmmm? okay \\n\\t\\tlet us think \\n        way ,lets add all the ascending order elements to the stack so that \\n\\t\\tit\\n        looks like climbing steps .coz in that way we can have atleast the \\n\\t\\tmin\\n        size step * number of elements in the stack .if we encounter any \\n\\t\\tbar with         lesser height than the top element of the stack ,we \\n\\t\\twill compute the \\n        existing stack element area and pop the top element just to check \\n\\t\\tif the \\n        current top < bar height ,if it is so ..add it to the stack ..i think it        \\n\\t\\twill be more clearer if you go through the code*/\\n         //very important note .. we are adding indices ..not the values\\n        for(int i=0;i<heights.size();i++){\\n            while(!st.empty() && heights[st.top()]>heights[i]){\\n                //here we are checking if stack is empty or if we encounter \\n\\t\\t\\t\\tany \\n                // number that doesn\\'t satisfy our stack filling property\\n                int top=heights[st.top()];\\n                st.pop();\\n                int ran=st.empty()?-1:st.top();\\n                //this is to check if stack is empty, if so we will just take the                 //index\\n                ans=max(ans,top*(i-ran-1));\\n                // this is just to take the max area covered so far\\n            }\\n            st.push(i);\\n            //we push into the stack as long as it satsifies our stack condition\\n        }\\n        return ans;\\n        // i know it\\'s not a very clever explanation ..but i tried to explain \\n        //whatever i can ...HAPPY CODING!!\\n    }\\n};\\n```\\nHere in this problem stack can be replaced with vector and we can use popback and back methods which can implement the same functionality as stack but that one would take more time than the stack method\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        // this problem should be solved using stack .\\n        /* whenever you see a monotonic increase in the input which      \\n\\t\\twould yield  the answer closest to \\n\\t\\trequired you gotta understand that you should\\n\\t\\tuse  a stack datastructure to  calculate the answer*/\\n        // so let\\'s begin by creating a stack and ans that we return \\n        stack<int> st;\\n        int ans=0;\\n        //just to make our code understand better i\\'m adding 0 at the end of\\n        //heights\\n        heights.push_back(0);\\n        /* how do you add the elements to the stack ? mmmmmm? okay \\n\\t\\tlet us think \\n        way ,lets add all the ascending order elements to the stack so that \\n\\t\\tit\\n        looks like climbing steps .coz in that way we can have atleast the \\n\\t\\tmin\\n        size step * number of elements in the stack .if we encounter any \\n\\t\\tbar with         lesser height than the top element of the stack ,we \\n\\t\\twill compute the \\n        existing stack element area and pop the top element just to check \\n\\t\\tif the \\n        current top < bar height ,if it is so ..add it to the stack ..i think it        \\n\\t\\twill be more clearer if you go through the code*/\\n         //very important note .. we are adding indices ..not the values\\n        for(int i=0;i<heights.size();i++){\\n            while(!st.empty() && heights[st.top()]>heights[i]){\\n                //here we are checking if stack is empty or if we encounter \\n\\t\\t\\t\\tany \\n                // number that doesn\\'t satisfy our stack filling property\\n                int top=heights[st.top()];\\n                st.pop();\\n                int ran=st.empty()?-1:st.top();\\n                //this is to check if stack is empty, if so we will just take the                 //index\\n                ans=max(ans,top*(i-ran-1));\\n                // this is just to take the max area covered so far\\n            }\\n            st.push(i);\\n            //we push into the stack as long as it satsifies our stack condition\\n        }\\n        return ans;\\n        // i know it\\'s not a very clever explanation ..but i tried to explain \\n        //whatever i can ...HAPPY CODING!!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728151,
                "title": "all-4-approaches-shown-o-n-2-o-nlogn-o-n-two-pass-o-n-one-pass-with-explanation",
                "content": "I will try to explain all the three approaches I know for solving this problem : \\n**1) Brute Force  O(n^2)**(too slow **TLE**)\\nwe can compute area of every subarray and return the max of them all.\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size() ; \\n\\t\\tint max_area = 0 ; \\n\\t\\tfor(int i = 0 ; i < n ; i++) {\\n\\t\\t\\tint curr_max = 0 ; \\n\\t\\t\\tint min_height = INT_MAX ; \\n\\t\\t\\tfor(int j = i ; j < n ; j++) {\\n\\t\\t\\t\\tmin_height = min(min_height , heights[j]) ; \\n\\t\\t\\t\\tcurr_max = max(curr_max , min_height * (j - i + 1)) ; \\n\\t\\t\\t}\\n\\t\\t\\tmax_area = max(max_area , curr_max) ; \\n\\t\\t}\\n\\t\\treturn max_area ; \\n    }\\n};\\n```\\n\\n**2) Divide n Conquer Approach O(NlogN)(using segment tree) O(N^2)(if we calculate range minimum naively)**\\nWe can use Divide and Conquer to solve this in O(nLogn) time.\\nThe idea is to find the minimum value in the given array.\\nOnce we have index of the minimum value, the max area is maximum of following three values :\\n1. Maximum area in left side of minimum value ( excluding the min value)\\n2. Maximum area in right of minimum value ( excluding the min value)\\n3. Minimum value * length of segment .\\nThe areas on left and right can be calculated recursively.\\nIf we use linear search to find the minimum value, then the worst case time complexity of this algorithm becomes O(n^2).**(TLE)**\\n```\\nclass SegmentTree {\\npublic: \\n    int start , end , min ; \\n    SegmentTree *left ;\\n    SegmentTree *right ;\\n    \\n    SegmentTree (int start, int end) {\\n        this->start = start ;\\n        this->end = end ;\\n        left = right = NULL ;\\n    }  \\n};\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        SegmentTree* root = build(heights , 0 , heights.size() - 1) ;\\n        return maxAreaInThisSegment(heights , 0 , heights.size() - 1 , root) ;\\n    }\\n    \\n    SegmentTree* build(vector<int>& heights, int start, int end) {\\n        if (start > end) return NULL ;\\n        SegmentTree *root = new SegmentTree(start, end) ;\\n        if (start == end) {\\n            root->min = start ;\\n        return root ;\\n        } else {\\n          int middle = (start + end) / 2 ;\\n          root->left = build(heights, start, middle) ;\\n          root->right = build(heights, middle + 1, end) ;\\n          root->min = heights[root->left->min] < heights[root->right->min] ? root->left->min : root->right->min ;\\n          return root ;\\n        }\\n    }\\n    \\n    int query(vector<int> &heights , int start , int end , SegmentTree* root) {\\n        if(!root || end < root->start || start > root->end) return -1 ;\\n        if (start <= root->start && end >= root->end) {\\n            return root->min ;\\n        }\\n        int leftMin = query(heights , start , end , root->left) ;\\n        int rightMin = query(heights , start , end , root->right) ; \\n        if(leftMin == -1)   return rightMin ;\\n        if(rightMin == -1)  return leftMin ; \\n        return heights[leftMin] < heights[rightMin] ? leftMin : rightMin ; \\n    }\\n    //calculates the maximum possible area in the histogram between indexes start and end\\n    int maxAreaInThisSegment(vector<int> &heights , int start , int end , SegmentTree *root) {\\n        if(start > end) {\\n            return -1 ;\\n        } \\n        if(start == end) {\\n            return heights[start] ;\\n        }\\n        int wholeMin = query(heights , start , end , root) ; \\n        return max({heights[wholeMin] * (end - start + 1) , maxAreaInThisSegment(heights , start , wholeMin - 1 , root) , maxAreaInThisSegment(heights , wholeMin + 1 , end , root)}) ;\\n    }\\n};\\n```\\n\\n**3) Using left_smaller and right_smaller O(N)(2 pass)**\\nwe use two arrays left and right which store the next smaller element to the left and right respectively.\\nthen for every index we calculate area as `heights[i] * (right[i] - left[i] + 1)`\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size() ; \\n        vector<int> left(n , 0) , right(n , n) ; \\n        stack<int> s ; \\n        for(int i = 0 ; i < n ; i++) {\\n            while(!s.empty() && heights[i] <= heights[s.top()]) s.pop() ;\\n            if(s.empty())   left[i] = 0 ; //minimum element\\n            else    left[i] = s.top() + 1 ;\\n            s.push(i) ; \\n        }\\n        while(!s.empty())   s.pop() ; \\n        for(int i = n - 1 ; i >= 0 ; i--) {\\n            while(!s.empty() && heights[i] <= heights[s.top()]) s.pop() ;\\n            if(s.empty())   right[i] = n - 1 ; //minimum element\\n            else    right[i] = s.top() - 1 ;\\n            s.push(i) ; \\n        }\\n        int max_area = 0 ; \\n        for(int i = 0 ; i < n ; i++) {\\n            max_area = max(max_area , heights[i] * (right[i] - left[i] + 1)) ;\\n        }\\n        return max_area ;\\n    }\\n};\\n```\\n**4) using only one stack O(N)(1 pass)**\\nsame as approach 3 but better space complexity **(O(N) space)**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size() , max_area = INT_MIN , i = 0 ; \\n        stack<int> s ;\\n        while(i < n) {\\n            if(s.empty() || heights[s.top()] <= heights[i]) {\\n                s.push(i) ; \\n                i++ ; \\n            } else {\\n                int prev_top = s.top() ; \\n                s.pop() ; \\n                max_area = max(max_area , heights[prev_top] * (s.empty() ? i : i - s.top() - 1)) ;\\n            }\\n        }\\n        while(!s.empty()) {\\n            int prev_top = s.top() ; \\n            s.pop() ; \\n            max_area = max(max_area , heights[prev_top] * (s.empty() ? i : i - s.top() - 1)) ;\\n        }  \\n        return max_area ;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Stack",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size() ; \\n\\t\\tint max_area = 0 ; \\n\\t\\tfor(int i = 0 ; i < n ; i++) {\\n\\t\\t\\tint curr_max = 0 ; \\n\\t\\t\\tint min_height = INT_MAX ; \\n\\t\\t\\tfor(int j = i ; j < n ; j++) {\\n\\t\\t\\t\\tmin_height = min(min_height , heights[j]) ; \\n\\t\\t\\t\\tcurr_max = max(curr_max , min_height * (j - i + 1)) ; \\n\\t\\t\\t}\\n\\t\\t\\tmax_area = max(max_area , curr_max) ; \\n\\t\\t}\\n\\t\\treturn max_area ; \\n    }\\n};\\n```\n```\\nclass SegmentTree {\\npublic: \\n    int start , end , min ; \\n    SegmentTree *left ;\\n    SegmentTree *right ;\\n    \\n    SegmentTree (int start, int end) {\\n        this->start = start ;\\n        this->end = end ;\\n        left = right = NULL ;\\n    }  \\n};\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        SegmentTree* root = build(heights , 0 , heights.size() - 1) ;\\n        return maxAreaInThisSegment(heights , 0 , heights.size() - 1 , root) ;\\n    }\\n    \\n    SegmentTree* build(vector<int>& heights, int start, int end) {\\n        if (start > end) return NULL ;\\n        SegmentTree *root = new SegmentTree(start, end) ;\\n        if (start == end) {\\n            root->min = start ;\\n        return root ;\\n        } else {\\n          int middle = (start + end) / 2 ;\\n          root->left = build(heights, start, middle) ;\\n          root->right = build(heights, middle + 1, end) ;\\n          root->min = heights[root->left->min] < heights[root->right->min] ? root->left->min : root->right->min ;\\n          return root ;\\n        }\\n    }\\n    \\n    int query(vector<int> &heights , int start , int end , SegmentTree* root) {\\n        if(!root || end < root->start || start > root->end) return -1 ;\\n        if (start <= root->start && end >= root->end) {\\n            return root->min ;\\n        }\\n        int leftMin = query(heights , start , end , root->left) ;\\n        int rightMin = query(heights , start , end , root->right) ; \\n        if(leftMin == -1)   return rightMin ;\\n        if(rightMin == -1)  return leftMin ; \\n        return heights[leftMin] < heights[rightMin] ? leftMin : rightMin ; \\n    }\\n    //calculates the maximum possible area in the histogram between indexes start and end\\n    int maxAreaInThisSegment(vector<int> &heights , int start , int end , SegmentTree *root) {\\n        if(start > end) {\\n            return -1 ;\\n        } \\n        if(start == end) {\\n            return heights[start] ;\\n        }\\n        int wholeMin = query(heights , start , end , root) ; \\n        return max({heights[wholeMin] * (end - start + 1) , maxAreaInThisSegment(heights , start , wholeMin - 1 , root) , maxAreaInThisSegment(heights , wholeMin + 1 , end , root)}) ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size() ; \\n        vector<int> left(n , 0) , right(n , n) ; \\n        stack<int> s ; \\n        for(int i = 0 ; i < n ; i++) {\\n            while(!s.empty() && heights[i] <= heights[s.top()]) s.pop() ;\\n            if(s.empty())   left[i] = 0 ; //minimum element\\n            else    left[i] = s.top() + 1 ;\\n            s.push(i) ; \\n        }\\n        while(!s.empty())   s.pop() ; \\n        for(int i = n - 1 ; i >= 0 ; i--) {\\n            while(!s.empty() && heights[i] <= heights[s.top()]) s.pop() ;\\n            if(s.empty())   right[i] = n - 1 ; //minimum element\\n            else    right[i] = s.top() - 1 ;\\n            s.push(i) ; \\n        }\\n        int max_area = 0 ; \\n        for(int i = 0 ; i < n ; i++) {\\n            max_area = max(max_area , heights[i] * (right[i] - left[i] + 1)) ;\\n        }\\n        return max_area ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size() , max_area = INT_MIN , i = 0 ; \\n        stack<int> s ;\\n        while(i < n) {\\n            if(s.empty() || heights[s.top()] <= heights[i]) {\\n                s.push(i) ; \\n                i++ ; \\n            } else {\\n                int prev_top = s.top() ; \\n                s.pop() ; \\n                max_area = max(max_area , heights[prev_top] * (s.empty() ? i : i - s.top() - 1)) ;\\n            }\\n        }\\n        while(!s.empty()) {\\n            int prev_top = s.top() ; \\n            s.pop() ; \\n            max_area = max(max_area , heights[prev_top] * (s.empty() ? i : i - s.top() - 1)) ;\\n        }  \\n        return max_area ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727641,
                "title": "python3-monotonic-stack-t-t-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe idea is to use a monotonic stack. We iterate over bars and add them to the stack as long as the last element in the stack is less than the current bar. When the condition doesn\\'t hold, we start to calculate areas by popping out bars from the stack until the last element of the stack is greater than the current. The area is calculated as the number of pops multiplied by the height of the popped bar. On every pop, the height of the bar will be less or equal to the previous (since elements in the stack are always monotonically increasing).\\n\\nNow let\\'s consider this example `[2,1,2]`. For this case the formula for the area (number of pops * current height) won\\'t work because when we reach `1` we will pop out `2` from the stack and will not consider it later which is wrong since the largest area here is equal to `3 * 1`, i.e we somehow need to remember the previously discarded bars that still can form areas. We solve this problem by storing in the stack the width of the bar as well. So for our example, after discarding `2`, we push to the stack the `1` with the width equal to `2`.\\n\\nTime: **O(n)** - In the worst case we have 2 scans: one for the bars and one for the stack\\nSpace: **O(n)** - in the wors case we push to the stack the whjole input array\\n\\nRuntime: 932 ms, faster than **51.27%** of Python3 online submissions for Largest Rectangle in Histogram.\\nMemory Usage: 28.4 MB, less than **30.61%** of Python3 online submissions for Largest Rectangle in Histogram.\\n\\n```\\ndef largestRectangleArea(self, bars: List[int]) -> int:\\n\\tst, res = [], 0\\n\\tfor bar in bars + [-1]: # add -1 to have an additional iteration\\n\\t\\tstep = 0\\n\\t\\twhile st and st[-1][1] >= bar:\\n\\t\\t\\tw, h = st.pop()\\n\\t\\t\\tstep += w\\n\\t\\t\\tres = max(res, step * h)\\n\\n\\t\\tst.append((step + 1, bar))\\n\\n\\treturn res\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\ndef largestRectangleArea(self, bars: List[int]) -> int:\\n\\tst, res = [], 0\\n\\tfor bar in bars + [-1]: # add -1 to have an additional iteration\\n\\t\\tstep = 0\\n\\t\\twhile st and st[-1][1] >= bar:\\n\\t\\t\\tw, h = st.pop()\\n\\t\\t\\tstep += w\\n\\t\\t\\tres = max(res, step * h)\\n\\n\\t\\tst.append((step + 1, bar))\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 28959,
                "title": "my-concise-code-20ms-stack-based-o-n-one-trick-used",
                "content": "The idea is simple, use a stack to save the index of each vector entry in a ascending order; once the current entry is smaller than the one with the index s.top(), then that means the rectangle with the height height[s.top()] ends at the current position, so calculate its area and update the maximum. \\nThe only trick I use to avoid checking whether the stack is empty (due to pop) and also avoiding emptying the stack at the end (i.e. after going through the vector, s is not empty and we have to consider those in the stack) is to put a dummy \"0\" at the beginning of vector \"height\" and the end of \"height\": the first one makes sure the stack will never be empty (since all the height entries are >=0) and the last one will flush all the remaining non-zero entries of the stack at the end of \"for\" iteration. This trick helps us keep the code concise.\\n\\n    class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& height) {\\n            height.insert(height.begin(),0); // dummy \"0\" added to make sure stack s will never be empty\\n            height.push_back(0); // dummy \"0\" added to clear the stack at the end\\n            int len = height.size();\\n            int i, res = 0, idx;\\n            stack<int> s; // stack to save \"height\" index\\n            s.push(0); // index to the first dummy \"0\"\\n            for(i=1;i<len;i++)\\n            {\\n                while(height[i]<height[idx = s.top()]) // if the current entry is out of order\\n                {\\n                    s.pop();\\n                    res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry\\n                }\\n                s.push(i);\\n            }\\n            height.erase(height.begin()); // remove two dummy \"0\"\\n            height.pop_back();\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& height) {\\n            height.insert(height.begin(),0); // dummy \"0\" added to make sure stack s will never be empty\\n            height.push_back(0); // dummy \"0\" added to clear the stack at the end\\n            int len = height.size();\\n            int i, res = 0, idx;\\n            stack<int> s; // stack to save \"height\" index\\n            s.push(0); // index to the first dummy \"0\"\\n            for(i=1;i<len;i++)\\n            {\\n                while(height[i]<height[idx = s.top()]) // if the current entry is out of order\\n                {\\n                    s.pop();\\n                    res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1430546,
                "title": "monotonique-stack-solution-intuition-javascript",
                "content": "Oh, **hard problem** it is, isn\\'t it? \\nLet\\'s develop some intuition on how to access it.\\n\\n## Increasing \\nWhen the heights are **increasing**, we can always build rectangle from a point there a previous height started, to the current point. \\n![image](https://assets.leetcode.com/users/images/5b931e15-5391-4cd5-bed3-a894533829e1_1630144379.5151935.jpeg)\\nE.g we have heights [1, 2, 5]. In point 2 we can build rectangle of the height 1. In the point 5 we can build rectangle of height 2, starting from index 1, or height 1, starting from index 0. \\n\\nLet\\'s put the height, and the index, from where it\\'s possible to build rectangle of this height, into a stack. \\n\\t```javascript\\n\\tstack.push([index, height])\\n\\t```\\n## Decreasing \\nWhen the height is **decreasing**, we couldn\\'t build rectangle of any previous height, heigher than the current one. So it\\'s the place to make evaluation. \\n![image](https://assets.leetcode.com/users/images/f6fbe0c0-d0b3-42ae-9965-9f6a351512b8_1630145345.9980621.jpeg)\\n\\n\\nWe\\'ll pop all the heights bigger than the current one from the stack, and estimate the rectangles which could be build to this point:\\n```javascript\\nwhile (stack.length && stack[stack.length - 1][1] > heights[i]) {\\n                let [pos, height] = stack.pop();\\n                res = Math.max(res, (i - pos) * height);\\n\\t}\\n```\\n## What to put in the stack?\\nIt\\'s seems like we put in the stack the current index we are processing? \\nAlmost. \\nBut when we pop up all the heights which are bigger than the current one, guess where current height could start? From any of this points. \\nImagine we have array [1, 3, 5, 2]. At the height of 2 we pop up 5 and 3, but rectangle of the height 2 can start from index 1, not from index 3!\\nSo, we put in the stack the **earliest point, from there this height could start**. Which is either current index, or the last height poped from the stack. \\n## Append 0 to heights\\nTo make sure we processed all the heights, we can add additinal while statement in the end, or do more elegant solution - append 0 to the end of heights.\\n\\n## Full code\\n```javascript\\nheights.push(0)  \\nlet stack = [];\\nlet res = 0;\\nfor (let i = 0; i < heights.length; i++) {\\n\\tlet heightStart = i;\\n\\twhile (stack.length && stack[stack.length - 1][1] > heights[i]) {\\n\\t\\t\\tlet [pos, height] = stack.pop();\\n\\t\\t\\tres = Math.max(res, (i - pos) * height);\\n\\t\\t\\theightStart = pos; \\n\\t\\t}\\n\\tstack.push([heightStart, heights[i]]);\\n}\\nreturn res;\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```javascript\\n\\tstack.push([index, height])\\n\\t```\n```javascript\\nwhile (stack.length && stack[stack.length - 1][1] > heights[i]) {\\n                let [pos, height] = stack.pop();\\n                res = Math.max(res, (i - pos) * height);\\n\\t}\\n```\n```javascript\\nheights.push(0)  \\nlet stack = [];\\nlet res = 0;\\nfor (let i = 0; i < heights.length; i++) {\\n\\tlet heightStart = i;\\n\\twhile (stack.length && stack[stack.length - 1][1] > heights[i]) {\\n\\t\\t\\tlet [pos, height] = stack.pop();\\n\\t\\t\\tres = Math.max(res, (i - pos) * height);\\n\\t\\t\\theightStart = pos; \\n\\t\\t}\\n\\tstack.push([heightStart, heights[i]]);\\n}\\nreturn res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29025,
                "title": "c-solution-clean-code",
                "content": "    int largestRectangleArea(vector<int>& height) {\\n        height.push_back(0);\\n        const int size_h = height.size();\\n        stack<int> stk;\\n        int i = 0, max_a = 0;\\n        while (i < size_h) {\\n            if (stk.empty() || height[i] >= height[stk.top()]) stk.push(i++);\\n            else {\\n                int h = stk.top();\\n                stk.pop();\\n                max_a = max(max_a, height[h] * (stk.empty() ? i : i - stk.top() - 1));\\n            }\\n        }\\n        return max_a;\\n    }",
                "solutionTags": [],
                "code": "    int largestRectangleArea(vector<int>& height) {\\n        height.push_back(0);\\n        const int size_h = height.size();\\n        stack<int> stk;\\n        int i = 0, max_a = 0;\\n        while (i < size_h) {\\n            if (stk.empty() || height[i] >= height[stk.top()]) stk.push(i++);\\n            else {\\n                int h = stk.top();\\n                stk.pop();\\n                max_a = max(max_a, height[h] * (stk.empty() ? i : i - stk.top() - 1));\\n            }\\n        }\\n        return max_a;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1727605,
                "title": "c-simple-solution-brute-force-optimal-w-explanation",
                "content": "**APPROACH 1 : BRUTE FORCE**\\n\\n* A Brute force approach would be to one by one consider all bars as starting points and calculate area of all rectangles starting with every bar. \\n* Finally return maximum of all possible areas. \\n\\n**Time complexity :** O(n^2)\\n\\n* We can use Divide and Conquer to solve this in O(nLogn) time. \\n* The idea is to find the minimum value in the given array. \\n* Once we have index of the minimum value, the max area is maximum of following three values :\\n          1. Maximum area in left side of minimum value (w/o including the min value) \\n          2. Maximum area in right of minimum value (not including the min value) \\n          3. Number of bars multiplied by minimum value. \\n* The areas on left & right can be calculated recursively. \\n* If we use linear search to find the minimum value, then the worst case time complexity of this algorithm becomes O(n^2). (In the worst case, there are always ```n-1``` elements on one-side & 0 elements on the other)\\n\\n**APPROACH 2 : Using Left-Smaller & Right-Smaller Arrays**\\n\\n* First we will take two arrays left_smaller[] and right_smaller[] and initialize it with -1 and n respectively.\\n* For every index, we will store the index of previous smaller and next smaller element in ```left_smaller``` and ```right_smaller``` arrays respectively. - ```O(n)``` time\\n*  Now for every element we will calculate area by taking this ith element as the smallest in the range left_smaller[i] and right_smaller[i] and multiplying it with the difference of left_smaller[i] and right_smaller[i].\\n*  Each time we update the max_area according to the area obtained in the previous step.\\n\\n**Time Complexity :** O(n) - 3-pass \\n\\n**Space Complexity :** O(n)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        stack<int> s; \\n        vector<int> left_bound(n,0),right_bound(n,n); \\n        for(int i=0;i<n;i++) {\\n            while(!s.empty() && heights[i]<=heights[s.top()])  s.pop();\\n            if(s.empty())  left_bound[i]=0;\\n            else  left_bound[i] = s.top()+1;\\n\\t\\t\\t\\n            s.push(i);\\n        }\\n        while(!s.empty()) s.pop();\\n        for(int i=n-1; i>=0; i--)  {\\n            while(!s.empty() && heights[i]<=heights[s.top()])  s.pop();\\n            if(s.empty()) right_bound[i] = n-1;\\n            else  right_bound[i] = s.top()-1;\\n            s.push(i);\\n        }\\n        int maxi = 0, area;\\n        for(int i=0; i<n; i++) {\\n            area = (right_bound[i]-left_bound[i]+1)*heights[i];\\n            maxi = max(maxi, area);\\n        }\\n        return maxi; \\n    }\\n};\\n```\\n\\n**APPROACH 3 : Using Only Stack**\\n\\n* For every bar \\u2018x\\u2019, we calculate the area with \\u2018x\\u2019 as the smallest bar in the rectangle.\\n* We need to know index of the first smaller (smaller than \\u2018x\\u2019) bar on left of \\u2018x\\u2019 and index of first smaller bar on right of \\u2018x\\u2019.\\n* We traverse all bars from left to right, maintain a stack of bars. \\n* Every bar is pushed to stack once. \\n* A bar is popped from stack when a bar of smaller height is seen. \\n* When a bar is popped, we calculate the area with the popped bar as smallest bar - the current index tells us the \\u2018right index\\u2019 and index of previous item in stack is the \\u2018left index\\u2019.\\n\\n**ALGORITHM :**\\n* Create an empty stack.\\n* Start from first bar, and do following for every bar \\u2018hist[i]\\u2019 where \\u2018i\\u2019 varies from 0 to n-1. \\n\\t\\t1.  If stack is empty or hist[i] is higher than the bar at top of stack, then push \\u2018i\\u2019 to stack. \\n\\t\\t2.  If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. \\n\\t\\t3.  Let the removed bar be hist[tp]. \\n\\t\\t4.  Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the \\u2018left index\\u2019 is previous (previous to tp) item in stack and \\u2018right index\\u2019 is \\u2018i\\u2019 (current index).\\n Until the stack becomes empty, one by one remove all bars from stack and do steps 2-4 of the previous step for every removed bar.\\n \\n **Time Complexity :** O(n) - One-pass\\n \\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int ans=INT_MIN, area_with_top=0, top=0, i=0, n=heights.size();\\n        stack<int> s;\\n        \\n        while(i<n){\\n            if(s.empty() || heights[s.top()]<=heights[i]) s.push(i++);\\n            else{\\n                top = s.top(); s.pop();\\n                area_with_top = heights[top]*(s.empty() ? i : i-s.top()-1);\\n                ans = max(ans, area_with_top);\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            top = s.top(); s.pop();\\n            area_with_top = heights[top]*(s.empty() ? i : i-s.top()-1);\\n            ans = max(ans, area_with_top);\\n        }  \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if you like my solution :)**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```n-1```\n```left_smaller```\n```right_smaller```\n```O(n)```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        stack<int> s; \\n        vector<int> left_bound(n,0),right_bound(n,n); \\n        for(int i=0;i<n;i++) {\\n            while(!s.empty() && heights[i]<=heights[s.top()])  s.pop();\\n            if(s.empty())  left_bound[i]=0;\\n            else  left_bound[i] = s.top()+1;\\n\\t\\t\\t\\n            s.push(i);\\n        }\\n        while(!s.empty()) s.pop();\\n        for(int i=n-1; i>=0; i--)  {\\n            while(!s.empty() && heights[i]<=heights[s.top()])  s.pop();\\n            if(s.empty()) right_bound[i] = n-1;\\n            else  right_bound[i] = s.top()-1;\\n            s.push(i);\\n        }\\n        int maxi = 0, area;\\n        for(int i=0; i<n; i++) {\\n            area = (right_bound[i]-left_bound[i]+1)*heights[i];\\n            maxi = max(maxi, area);\\n        }\\n        return maxi; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int ans=INT_MIN, area_with_top=0, top=0, i=0, n=heights.size();\\n        stack<int> s;\\n        \\n        while(i<n){\\n            if(s.empty() || heights[s.top()]<=heights[i]) s.push(i++);\\n            else{\\n                top = s.top(); s.pop();\\n                area_with_top = heights[top]*(s.empty() ? i : i-s.top()-1);\\n                ans = max(ans, area_with_top);\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            top = s.top(); s.pop();\\n            area_with_top = heights[top]*(s.empty() ? i : i-s.top()-1);\\n            ans = max(ans, area_with_top);\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29010,
                "title": "my-modified-answer-from-geeksforgeeks-in-java",
                "content": "I was stuck and took an eye on Geeks4Geeks. I got the idea and tried to figure it out by myself...\\nIt takes me a lot of time to make it through....\\n\\n**EDITED:** Now it is pretty concise....\\n\\n    public class Solution {\\n    public int largestRectangleArea(int[] height) {\\n        if (height==null) return 0;//Should throw exception\\n        if (height.length==0) return 0;\\n        \\n        Stack<Integer> index= new Stack<Integer>();\\n        index.push(-1);\\n        int max=0;\\n        \\n        for  (int i=0;i<height.length;i++){\\n                //Start calculate the max value\\n            while (index.peek()>-1)\\n                if (height[index.peek()]>height[i]){\\n                    int top=index.pop();                    \\n                    max=Math.max(max,height[top]*(i-1-index.peek()));  \\n                }else break;\\n                \\n            index.push(i);\\n        }\\n        while(index.peek()!=-1){\\n        \\tint top=index.pop();\\n            max=Math.max(max,height[top]*(height.length-1-index.peek()));\\n        }        \\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int largestRectangleArea(int[] height) {\\n        if (height==null) return 0;//Should throw exception\\n        if (height.length==0) return 0;\\n        \\n        Stack<Integer> index= new Stack<Integer>();\\n        index.push(-1);\\n        int max=0;\\n        \\n        for  (int i=0;i<height.length;i++){\\n                //Start calculate the max value\\n            while (index.peek()>-1)\\n                if (height[index.peek()]>height[i]){\\n                    int top=index.pop();                    \\n                    max=Math.max(max,height[top]*(i-1-index.peek()));  \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1603860,
                "title": "6-similar-questions-prev-smaller-next-smaller-monotonic-stack-c",
                "content": "**1. Largest Rectangle in a Histogram**: https://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> nsl(n),psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans = max(ans,(nsl[i]-psl[i]-1)*(heights[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**2. Maximal Rectangle** : https://leetcode.com/problems/maximal-rectangle/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int histogram(vector<int>& heights){\\n        int n = heights.size();\\n        vector<int> nsl(n),psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans = max(ans,(nsl[i]-psl[i]-1)*(heights[i]));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        \\n        \\n        int n = matrix.size();\\n        \\n        if(n==0){\\n            return 0;\\n        }\\n        \\n        \\n        int m = matrix[0].size();\\n        \\n        int dup[n][m];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    dup[i][j]=0;\\n                }\\n                else{\\n                    dup[i][j]=1;\\n                }\\n            }\\n        }\\n        \\n\\n        for(int i=0;i<n;i++){\\n            if(i==0) continue;\\n            \\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    dup[i][j] = 1+dup[i-1][j];\\n                }\\n                else{\\n                    dup[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> each_row;\\n            for(int j=0;j<m;j++){\\n                each_row.push_back(dup[i][j]);\\n            }\\n            \\n            ans = max(ans,histogram(each_row));\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**3. Maximum score of a Good subarray**: https://leetcode.com/problems/maximum-score-of-a-good-subarray/\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<long long>nsr(n),nsl(n);\\n        //NSL\\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n            nsl[i]=st.empty()?-1:st.top();\\n            st.push(i);\\n        }\\n        //NSR\\n        stack<int>tt;\\n        for(int i=n-1;i>=0;i--){\\n            while(!tt.empty() && nums[tt.top()]>=nums[i])\\n                tt.pop();\\n            nsr[i]=tt.empty()?n:tt.top();\\n            tt.push(i);\\n        }\\n        vector<long long>pref(n,0);\\n        pref[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int mn = nums[i];\\n            int l=nsl[i]+1, r=nsr[i]-1;\\n            int len, prod;\\n            if(l<=k && r>=k){\\n                len = r-l+1;\\n                prod = mn*len;\\n                ans = max(ans,prod);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**4. Sum of subarray minimums** : https://leetcode.com/problems/sum-of-subarray-minimums/\\n\\n```\\nclass Solution {\\npublic:\\n    int sumSubarrayMins(vector<int>& arr) {\\n        \\n        int mod = 1000000007;\\n        int n = arr.size();\\n        vector<int> nsl(n);\\n        vector<int> psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && arr[s.top()]>arr[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && arr[s.top()]>=arr[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            long long r = nsl[i]-i;\\n            long long l = i-psl[i];\\n            \\n            cout<<psl[i]<<\" \"<<nsl[i]<<endl;\\n            \\n            ans+= (l*r*arr[i]);\\n            ans = ans%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**5. Maximum subarray min-Product**: https://leetcode.com/problems/maximum-subarray-min-product/\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> nsl(n);\\n        vector<int> psl(n);\\n        \\n        int mod = 1000000007;\\n        \\n        \\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && nums[s.top()]>=nums[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n: s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && nums[s.top()]>=nums[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        long long prefix[n+1];\\n        prefix[0]=0;\\n        for(int i=1;i<=n;i++){\\n            prefix[i] = prefix[i-1]+nums[i-1];\\n        }\\n        \\n        long long ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans = max(ans,nums[i]*(prefix[nsl[i]]-prefix[psl[i]+1]));\\n        }\\n        \\n        return ans%mod;\\n        \\n    }\\n};\\n\\n```\\n\\n**6. Daily Temperatures**: https://leetcode.com/problems/daily-temperatures/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\\n        stack<int> s;\\n        \\n        int n = temperatures.size();\\n        \\n        vector<int> ans(n);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(s.empty()){\\n                ans[i] = 0;\\n            }\\n            else{\\n                while(!s.empty() && temperatures[i]>=temperatures[s.top()]){\\n                    s.pop();\\n                }\\n                \\n                if(s.empty()){\\n                    ans[i] = 0;\\n                }\\n                else{\\n                    ans[i] = s.top()-i;\\n                }\\n                \\n                \\n            }\\n            \\n            s.push(i);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> nsl(n),psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans = max(ans,(nsl[i]-psl[i]-1)*(heights[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int histogram(vector<int>& heights){\\n        int n = heights.size();\\n        vector<int> nsl(n),psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans = max(ans,(nsl[i]-psl[i]-1)*(heights[i]));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        \\n        \\n        int n = matrix.size();\\n        \\n        if(n==0){\\n            return 0;\\n        }\\n        \\n        \\n        int m = matrix[0].size();\\n        \\n        int dup[n][m];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    dup[i][j]=0;\\n                }\\n                else{\\n                    dup[i][j]=1;\\n                }\\n            }\\n        }\\n        \\n\\n        for(int i=0;i<n;i++){\\n            if(i==0) continue;\\n            \\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    dup[i][j] = 1+dup[i-1][j];\\n                }\\n                else{\\n                    dup[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> each_row;\\n            for(int j=0;j<m;j++){\\n                each_row.push_back(dup[i][j]);\\n            }\\n            \\n            ans = max(ans,histogram(each_row));\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<long long>nsr(n),nsl(n);\\n        //NSL\\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n            nsl[i]=st.empty()?-1:st.top();\\n            st.push(i);\\n        }\\n        //NSR\\n        stack<int>tt;\\n        for(int i=n-1;i>=0;i--){\\n            while(!tt.empty() && nums[tt.top()]>=nums[i])\\n                tt.pop();\\n            nsr[i]=tt.empty()?n:tt.top();\\n            tt.push(i);\\n        }\\n        vector<long long>pref(n,0);\\n        pref[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int mn = nums[i];\\n            int l=nsl[i]+1, r=nsr[i]-1;\\n            int len, prod;\\n            if(l<=k && r>=k){\\n                len = r-l+1;\\n                prod = mn*len;\\n                ans = max(ans,prod);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumSubarrayMins(vector<int>& arr) {\\n        \\n        int mod = 1000000007;\\n        int n = arr.size();\\n        vector<int> nsl(n);\\n        vector<int> psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && arr[s.top()]>arr[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && arr[s.top()]>=arr[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            long long r = nsl[i]-i;\\n            long long l = i-psl[i];\\n            \\n            cout<<psl[i]<<\" \"<<nsl[i]<<endl;\\n            \\n            ans+= (l*r*arr[i]);\\n            ans = ans%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> nsl(n);\\n        vector<int> psl(n);\\n        \\n        int mod = 1000000007;\\n        \\n        \\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && nums[s.top()]>=nums[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n: s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && nums[s.top()]>=nums[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        long long prefix[n+1];\\n        prefix[0]=0;\\n        for(int i=1;i<=n;i++){\\n            prefix[i] = prefix[i-1]+nums[i-1];\\n        }\\n        \\n        long long ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans = max(ans,nums[i]*(prefix[nsl[i]]-prefix[psl[i]+1]));\\n        }\\n        \\n        return ans%mod;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\\n        stack<int> s;\\n        \\n        int n = temperatures.size();\\n        \\n        vector<int> ans(n);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(s.empty()){\\n                ans[i] = 0;\\n            }\\n            else{\\n                while(!s.empty() && temperatures[i]>=temperatures[s.top()]){\\n                    s.pop();\\n                }\\n                \\n                if(s.empty()){\\n                    ans[i] = 0;\\n                }\\n                else{\\n                    ans[i] = s.top()-i;\\n                }\\n                \\n                \\n            }\\n            \\n            s.push(i);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 688492,
                "title": "python-monotone-increasing-stack-similar-problems-attached",
                "content": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : MONOTONOUS INCREASING STACK ##\\n        ## Similar to Leetcode: 1475. Final Prices With a Special Discount in a Shop ##\\n        ## Similar to Leetcode: 907. Sum Of Subarray Minimums ##\\n        ## Similar to Leetcode: 85. maximum Rectangle ##\\n        ## Similar to Leetcode: 402. Remove K Digits ##\\n        ## Similar to Leetcode: 456. 132 Pattern ##\\n        ## Similar to Leetcode: 1063. Number Of Valid Subarrays ##\\n        ## Similar to Leetcode: 739. Daily Temperatures ##\\n        ## Similar to Leetcode: 1019. Next Greater Node In LinkedList ##\\n        \\n        ## LOGIC ##\\n        ## 1. Before Solving this problem, go through Monotone stack.\\n        ## 2. Using Monotone Stack we can solve 1) Next Greater Element 2) Next Smaller Element 3) Prev Greater Element 4) Prev Smaller Element\\n        ## 3. Using \\'NSE\\' Monotone Stack concept, we can find width of rectangles, height obviously will be the minimum of those. Thus we can calculate the area\\n        ## 4. As we are using NSE concept, adding 0 to the end, will make sure that stack is EMPTY at the end. ( so all the areas can be calculated while popping )\\n        \\n        heights.append(0)\\n        stack = [-1]\\n        ans = 0\\n        for i in range(len(heights)):\\n            while heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i - stack[-1] - 1\\n                ans = max(ans, height * width)\\n            stack.append(i)\\n        heights.pop()\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : MONOTONOUS INCREASING STACK ##\\n        ## Similar to Leetcode: 1475. Final Prices With a Special Discount in a Shop ##\\n        ## Similar to Leetcode: 907. Sum Of Subarray Minimums ##\\n        ## Similar to Leetcode: 85. maximum Rectangle ##\\n        ## Similar to Leetcode: 402. Remove K Digits ##\\n        ## Similar to Leetcode: 456. 132 Pattern ##\\n        ## Similar to Leetcode: 1063. Number Of Valid Subarrays ##\\n        ## Similar to Leetcode: 739. Daily Temperatures ##\\n        ## Similar to Leetcode: 1019. Next Greater Node In LinkedList ##\\n        \\n        ## LOGIC ##\\n        ## 1. Before Solving this problem, go through Monotone stack.\\n        ## 2. Using Monotone Stack we can solve 1) Next Greater Element 2) Next Smaller Element 3) Prev Greater Element 4) Prev Smaller Element\\n        ## 3. Using \\'NSE\\' Monotone Stack concept, we can find width of rectangles, height obviously will be the minimum of those. Thus we can calculate the area\\n        ## 4. As we are using NSE concept, adding 0 to the end, will make sure that stack is EMPTY at the end. ( so all the areas can be calculated while popping )\\n        \\n        heights.append(0)\\n        stack = [-1]\\n        ans = 0\\n        for i in range(len(heights)):\\n            while heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i - stack[-1] - 1\\n                ans = max(ans, height * width)\\n            stack.append(i)\\n        heights.pop()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579352,
                "title": "c-100-worst-to-best-approaches-with-explanation-easy-to-understand",
                "content": "**Read the below solutions to understand the logic.**\\n\\n***Please upvote if you like it***\\n\\n**Solution 1: Brute Force Approach (TLE)**\\n\\n**Intuition:** The intuition behind the approach is taking different bars and finding the maximum width possible using the bar.\\n\\n![image](https://assets.leetcode.com/users/images/52a26c24-4a05-4a06-8b08-a364b969549d_1663241771.5117555.png)\\n\\n**~Time Complexity: O(N*N )** \\n\\n**~Space Complexity: O(1)**\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        int maxArea = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int minHeight = INT_MAX;\\n            for (int j = i; j < n; j++) {\\n                minHeight = min(minHeight, heights[j]);\\n                maxArea = max(maxArea, minHeight * (j - i + 1));\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n};\\n```\\n\\n**Solution 2: Optimised Approach ( 100% Accepted )**\\n\\n**Intuition:** The intuition behind the approach is the same as finding the smaller element on both sides but in an optimized way using the concept of the next greater element and the next smaller element.\\n\\n**Approach: **\\n\\n1. Steps to be done for finding Left smaller element\\n2. Steps to be done for finding the Right smaller element\\n3. After finding the right smaller and left smaller of each subsequent array elements, after that find area for each bar using this formuula\\n\\n\\t![image](https://assets.leetcode.com/users/images/bdd608ad-1db0-4850-bac1-b81fbb0fc8b8_1663242227.7100823.png)\\n\\t\\n4. At the end return the maximum area.\\n\\n**Dry run:-**\\n\\n![image](https://assets.leetcode.com/users/images/4092b4bc-4a43-4402-9b71-40cb98fbdff5_1663259833.031889.jpeg)\\n\\n\\n**~Time Complexity: O( N )**\\n\\n**~Space Complexity: O(3N) where 3 is for the stack, left small array and a right small array**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElementIndex(vector<int>& heights,int n){\\n        stack<int> st;\\n        vector<int> res(n);\\n        st.push(-1);\\n        for(int i=n-1;i>=0;i--){\\n            int curr=heights[i];\\n            while(st.top()!=-1 && heights[st.top()]>=curr){\\n                st.pop();\\n            }\\n            res[i]=st.top();\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> prevSmallerElementIndex(vector<int>& heights,int n){\\n        stack<int> st;\\n        vector<int> res(n);\\n        st.push(-1);\\n        for(int i=0;i<n;i++){\\n            int curr=heights[i];\\n            while(st.top()!=-1 && heights[st.top()]>=curr){\\n                st.pop();\\n            }\\n            res[i]=st.top();\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        //Storing next smaller element index\\n        vector<int> next=nextSmallerElementIndex(heights,n);\\n        //Storing prev smaller element index\\n        vector<int> prev=prevSmallerElementIndex(heights,n);\\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int l=heights[i];\\n            if(next[i]==-1) next[i]=n;\\n            int b=next[i]-prev[i]-1;\\n            ans=max(ans,l*b);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        int maxArea = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int minHeight = INT_MAX;\\n            for (int j = i; j < n; j++) {\\n                minHeight = min(minHeight, heights[j]);\\n                maxArea = max(maxArea, minHeight * (j - i + 1));\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElementIndex(vector<int>& heights,int n){\\n        stack<int> st;\\n        vector<int> res(n);\\n        st.push(-1);\\n        for(int i=n-1;i>=0;i--){\\n            int curr=heights[i];\\n            while(st.top()!=-1 && heights[st.top()]>=curr){\\n                st.pop();\\n            }\\n            res[i]=st.top();\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> prevSmallerElementIndex(vector<int>& heights,int n){\\n        stack<int> st;\\n        vector<int> res(n);\\n        st.push(-1);\\n        for(int i=0;i<n;i++){\\n            int curr=heights[i];\\n            while(st.top()!=-1 && heights[st.top()]>=curr){\\n                st.pop();\\n            }\\n            res[i]=st.top();\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        //Storing next smaller element index\\n        vector<int> next=nextSmallerElementIndex(heights,n);\\n        //Storing prev smaller element index\\n        vector<int> prev=prevSmallerElementIndex(heights,n);\\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int l=heights[i];\\n            if(next[i]==-1) next[i]=n;\\n            int b=next[i]-prev[i]-1;\\n            ans=max(ans,l*b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527399,
                "title": "javascript-using-stack-detail-breakdown",
                "content": "Do I explain this good enough?``\\n```js\\n/**\\n * @param {number[]} heights\\n * @return {number}\\n */\\nconst largestRectangleArea = function (heights) {\\n    let maxArea = 0;\\n    const stack = [];\\n    // Append shadow rectangle (height = 0) to both side\\n    heights = [0].concat(heights).concat([0]);\\n    for (let i = 0; i < heights.length; i++) {\\n        /**\\n         *  Check if height of last element in the stack bigger than height at current position\\n         *  Position in stack always smaller than current position at least 1\\n         *  For example we have heights array [2,5,6,2]\\n         *   1: Add shadow rectangle to array => [0,2,5,6,2,0]\\n         *   2:\\n         *      Expression: heights[stack[stack.length - 1]] > heights[i]\\n         *      i = 0 => stack = [0],\\n         *      i = 1 => heights[0] > heights[1] (0 > 2) => false => stack = [0,1]\\n         *      i = 2 => heights[1] > heights[2] (2 > 5) => false => stack = [0,1,2]\\n         *      i = 3 => heights[2] > heights[3] (5 > 6) => false => stack = [0,1,2,3]\\n         *      i = 4 => heights[3] > heights[4] (6 > 2) => true\\n         *   3: Because the previous height bigger than the current height (6 > 2) so that we can confirm that the next rectangle\\n         *      will only shrink area. Let calculate the result\\n         *      First we get the position from the stack and assign to variable \"j\" from original stack = [0,1,2,3]\\n         *      Expression: (i - stack[stack.length - 1] - 1) * heights[j]\\n         *       j = 3 => stack = [0,1,2] => (i - stack[3 - 1] - 1) *  => (4 - 2 - 1) * 6 = 6\\n         *      Explain:\\n         *      - We need to calculate area backward so that we take i - last stack (4 - 2) and because we already\\n         *      get a value from stack before so that we need to subtract 1 => (4 - 2 - 1)\\n         *      - The latest position in stack is the maximum height we can get (j = 3 => heights[3] = 6)\\n         *       => Area calculate equal (4 - 2 - 1) * 6 = 6 (1 bar)\\n         *      - Compare with the current max area (currently 0) => New max area = 6\\n         *\\n         *      Expression: heights[stack[stack.length - 1]] > heights[i] | stack = [0,1,2]\\n         *      heights[2] > heights[4] (5 > 2) => true\\n         *      j = 2 => stack = [0, 1] => (i - stack[2 - 1] - 1) * 5 => (4 - 1 - 1) * 5 = 10\\n         *      Area > MaxArea (10 > 6) => New max area = 10 (2 bar)\\n         *      Explain: Because the height in stack are sorted (We stop add position to stack if the next height is lower)\\n         *\\n         *      heights[1] > heights[4] (2 > 2) => false | stack = [0,1,2]\\n         *      Keep running and the final answer it is the max area you need\\n         */\\n        while (stack && heights[stack[stack.length - 1]] > heights[i]) {\\n            const j = stack.pop();\\n            maxArea = Math.max((i - stack[stack.length - 1] - 1) * heights[j], maxArea);\\n        }\\n        stack.push(i);\\n    }\\n    return maxArea;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} heights\\n * @return {number}\\n */\\nconst largestRectangleArea = function (heights) {\\n    let maxArea = 0;\\n    const stack = [];\\n    // Append shadow rectangle (height = 0) to both side\\n    heights = [0].concat(heights).concat([0]);\\n    for (let i = 0; i < heights.length; i++) {\\n        /**\\n         *  Check if height of last element in the stack bigger than height at current position\\n         *  Position in stack always smaller than current position at least 1\\n         *  For example we have heights array [2,5,6,2]\\n         *   1: Add shadow rectangle to array => [0,2,5,6,2,0]\\n         *   2:\\n         *      Expression: heights[stack[stack.length - 1]] > heights[i]\\n         *      i = 0 => stack = [0],\\n         *      i = 1 => heights[0] > heights[1] (0 > 2) => false => stack = [0,1]\\n         *      i = 2 => heights[1] > heights[2] (2 > 5) => false => stack = [0,1,2]\\n         *      i = 3 => heights[2] > heights[3] (5 > 6) => false => stack = [0,1,2,3]\\n         *      i = 4 => heights[3] > heights[4] (6 > 2) => true\\n         *   3: Because the previous height bigger than the current height (6 > 2) so that we can confirm that the next rectangle\\n         *      will only shrink area. Let calculate the result\\n         *      First we get the position from the stack and assign to variable \"j\" from original stack = [0,1,2,3]\\n         *      Expression: (i - stack[stack.length - 1] - 1) * heights[j]\\n         *       j = 3 => stack = [0,1,2] => (i - stack[3 - 1] - 1) *  => (4 - 2 - 1) * 6 = 6\\n         *      Explain:\\n         *      - We need to calculate area backward so that we take i - last stack (4 - 2) and because we already\\n         *      get a value from stack before so that we need to subtract 1 => (4 - 2 - 1)\\n         *      - The latest position in stack is the maximum height we can get (j = 3 => heights[3] = 6)\\n         *       => Area calculate equal (4 - 2 - 1) * 6 = 6 (1 bar)\\n         *      - Compare with the current max area (currently 0) => New max area = 6\\n         *\\n         *      Expression: heights[stack[stack.length - 1]] > heights[i] | stack = [0,1,2]\\n         *      heights[2] > heights[4] (5 > 2) => true\\n         *      j = 2 => stack = [0, 1] => (i - stack[2 - 1] - 1) * 5 => (4 - 1 - 1) * 5 = 10\\n         *      Area > MaxArea (10 > 6) => New max area = 10 (2 bar)\\n         *      Explain: Because the height in stack are sorted (We stop add position to stack if the next height is lower)\\n         *\\n         *      heights[1] > heights[4] (2 > 2) => false | stack = [0,1,2]\\n         *      Keep running and the final answer it is the max area you need\\n         */\\n        while (stack && heights[stack[stack.length - 1]] > heights[i]) {\\n            const j = stack.pop();\\n            maxArea = Math.max((i - stack[stack.length - 1] - 1) * heights[j], maxArea);\\n        }\\n        stack.push(i);\\n    }\\n    return maxArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217539,
                "title": "o-n-stack-c-solution-12ms",
                "content": "\\u601D\\u8DEF\\u662F\\n\\n\\u56E0\\u4E3A\\u76F8\\u90BB\\u7684\\u6BD4curr\\u9AD8\\u7684\\u5757\\u80AF\\u5B9A\\u53EF\\u4EE5\\u4F5C\\u4E3A \\u9AD8\\u5EA6\\u4E3Aheights[curr]\\u7684\\u957F\\u65B9\\u5F62\\u7684\\u4E00\\u90E8\\u5206\\n\\u6240\\u4EE5\\u89C2\\u5BDF\\u5230\\u9AD8\\u5EA6\\u4E3Aheights[curr]\\u7684\\u957F\\u65B9\\u5F62\\u7684\\u6700\\u5927\\u9762\\u79EF\\u662F \\n\\n                     \\uFF08\\u540E\\u4E00\\u4E2A\\u9AD8\\u5EA6\\u6BD4curr\\u4F4E\\u7684index - \\u524D\\u4E00\\u4E2A\\u9AD8\\u5EA6\\u6BD4curr\\u4F4E\\u7684index - 1\\uFF09* \\u5F53\\u524D\\u5757\\u7684\\u9AD8\\u5EA6\\n\\n\\u90A3\\u4E48\\u5C31\\u8981\\u627E\\u5230\\u524D\\u4E00\\u4E2A\\u6BD4curr\\u4F4E\\u7684\\u5757\\u548C\\u540E\\u4E00\\u4E2A\\u6BD4curr\\u4F4E\\u7684\\u5757\\u7684index\\n\\n\\u66F4\\u8FDB\\u4E00\\u6B65\\uFF0C \\u5F53\\u524D\\u7684\\u5757 \\u662F \\u524D\\u9762\\u6240\\u6709\\u6BD4\\u4ED6\\u9AD8\\u7684\\u5757 \\u7684\\u53F3\\u754C\\uFF0C\\u5728\\u8BA1\\u7B97\\u524D\\u9762\\u6240\\u6709\\u6BD4\\u4ED6\\u9AD8\\u7684\\u5757\\u80FD\\u5F62\\u6210\\u957F\\u65B9\\u5F62\\u7684\\u6700\\u5927\\u9762\\u79EF\\u65F6\\u4E00\\u5B9A\\u4F1A\\u7528\\u5230\\u3002\\n\\n\\u53F3\\u4FA7\\u7684index\\u627E\\u5230\\u4E86\\uFF0C\\u90A3\\u4E48\\u600E\\u4E48\\u627E\\u5DE6\\u4FA7\\u6BD4\\u5F53\\u524D\\u7684\\u5757\\u4F4E\\u7684\\u7B2C\\u4E00\\u4E2A\\u5757\\u7684index\\u5462\\uFF1F\\n\\n\\u6211\\u4EEC\\u4F7F\\u7528stack\\u5B58\\u5347\\u5E8F\\u6392\\u5217\\u7684index\\uFF0C\\u904D\\u5386heights\\uFF0C\\u653E\\u5165\\u65B0\\u7684height\\u4E4B\\u524Dpop\\u6240\\u6709\\u6BD4\\u4ED6\\u9AD8\\u7684\\u5757\\u7684index\\u3002\\n\\uFF08\\uFF01\\uFF01\\uFF01\\uFF09\\u540C\\u65F6\\uFF0C\\u8BA1\\u7B97\\u88ABpop\\u51FA\\u53BB\\u7684\\u5757\\u80FD\\u5F62\\u6210\\u7684\\u957F\\u65B9\\u5F62\\u7684\\u6700\\u5927\\u9762\\u79EF\\uFF0C\\u56E0\\u4E3A\\u6B64\\u65F6\\u7684i\\u662F\\u53F3\\u8FB9\\u7B2C\\u4E00\\u4E2A\\u6BD4\\u5B83\\u4F4E\\u7684index\\uFF0Cstack\\u9876\\u662F\\u5DE6\\u8FB9\\u7B2C\\u4E00\\u4E2A\\u6BD4\\u5B83\\u4F4E\\u7684index\\u3002\\n\\n\\n```\\nint largestRectangleArea(vector<int>& heights) {\\n        stack<int> indexes;\\n        int maxArea = 0;\\n        heights.push_back(0);\\n        indexes.push(0);\\n        for (int i = 1; i < heights.size(); i++){\\n            while(!indexes.empty() && heights[i] < heights[indexes.top()]){\\n                int h = heights[indexes.top()];\\n                indexes.pop();\\n                int prev = indexes.empty() ? -1 : indexes.top();\\n                maxArea = max(maxArea, (i - prev -1) * h);\\n            }\\n            indexes.push(i);\\n        }\\n        return maxArea;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestRectangleArea(vector<int>& heights) {\\n        stack<int> indexes;\\n        int maxArea = 0;\\n        heights.push_back(0);\\n        indexes.push(0);\\n        for (int i = 1; i < heights.size(); i++){\\n            while(!indexes.empty() && heights[i] < heights[indexes.top()]){\\n                int h = heights[indexes.top()];\\n                indexes.pop();\\n                int prev = indexes.empty() ? -1 : indexes.top();\\n                maxArea = max(maxArea, (i - prev -1) * h);\\n            }\\n            indexes.push(i);\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1508521,
                "title": "c-stack-next-smaller-element",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerRight(vector<int> heights, int n){\\n        vector<int> res(n);\\n        stack<int> st;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            while(!st.empty() && heights[st.top()]>=heights[i])\\n                st.pop();\\n            if(st.empty())\\n                res[i] = -1;\\n            else\\n                res[i] = st.top();\\n            st.push(i);\\n        }\\n        return res;\\n        \\n    }\\n    vector<int> nextSmallerLeft(vector<int> heights, int n){\\n        vector<int> res(n);\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!st.empty() && heights[st.top()]>=heights[i])\\n                st.pop();\\n            if(st.empty())\\n                res[i] = -1;\\n            else\\n                res[i] = st.top();\\n            st.push(i);\\n        }\\n        return res;\\n        \\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        \\n        vector<int> leftSmaller(n), rightSmaller(n);\\n        \\n        rightSmaller = nextSmallerRight(heights,n);\\n        leftSmaller = nextSmallerLeft(heights,n);\\n\\n        \\n        int res = INT_MIN;\\n        \\n        for(int i=0; i<n; i++){\\n            int left = leftSmaller[i];\\n            int right = rightSmaller[i];\\n            int  w;\\n            \\n            if(left==-1) left = -1;\\n            if(right==-1) right = n;\\n            \\n            w = (right-1)-(left+1)+1;\\n            res = max(res,heights[i]*w);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerRight(vector<int> heights, int n){\\n        vector<int> res(n);\\n        stack<int> st;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            while(!st.empty() && heights[st.top()]>=heights[i])\\n                st.pop();\\n            if(st.empty())\\n                res[i] = -1;\\n            else\\n                res[i] = st.top();\\n            st.push(i);\\n        }\\n        return res;\\n        \\n    }\\n    vector<int> nextSmallerLeft(vector<int> heights, int n){\\n        vector<int> res(n);\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!st.empty() && heights[st.top()]>=heights[i])\\n                st.pop();\\n            if(st.empty())\\n                res[i] = -1;\\n            else\\n                res[i] = st.top();\\n            st.push(i);\\n        }\\n        return res;\\n        \\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        \\n        vector<int> leftSmaller(n), rightSmaller(n);\\n        \\n        rightSmaller = nextSmallerRight(heights,n);\\n        leftSmaller = nextSmallerLeft(heights,n);\\n\\n        \\n        int res = INT_MIN;\\n        \\n        for(int i=0; i<n; i++){\\n            int left = leftSmaller[i];\\n            int right = rightSmaller[i];\\n            int  w;\\n            \\n            if(left==-1) left = -1;\\n            if(right==-1) right = n;\\n            \\n            w = (right-1)-(left+1)+1;\\n            res = max(res,heights[i]*w);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519257,
                "title": "java-tc-o-n-sc-o-n-optimal-stack-solution",
                "content": "```java\\n/**\\n * Using stack to save the increasing height index.\\n *\\n * Time Complexity: O(N) --> Each element is visited maximum twice. (Once pushed\\n * in stack and once popped for stack)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        if (heights == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = heights.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n        if (len == 1) {\\n            return heights[0];\\n        }\\n\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int maxArea = 0;\\n\\n        for (int i = 0; i <= len; i++) {\\n            while (!stack.isEmpty() && (i == len || heights[stack.peek()] >= heights[i])) {\\n                int h = heights[stack.pop()];\\n                int left = stack.isEmpty() ? -1 : stack.peek();\\n                /**\\n                 * i-1 - left ==> This is calculating the width of the rectangle. Both ith and\\n                 * left positions are excluded.\\n                 */\\n                maxArea = Math.max(maxArea, (i - 1 - left) * h);\\n            }\\n            stack.push(i);\\n        }\\n\\n        return maxArea;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other similar question on LeetCode:\\n- [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/discuss/1519263/Java-or-TC:-O(RC)-or-SC:-O(min(RC))-or-Optimal-Stack-solution)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```java\\n/**\\n * Using stack to save the increasing height index.\\n *\\n * Time Complexity: O(N) --> Each element is visited maximum twice. (Once pushed\\n * in stack and once popped for stack)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        if (heights == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = heights.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n        if (len == 1) {\\n            return heights[0];\\n        }\\n\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int maxArea = 0;\\n\\n        for (int i = 0; i <= len; i++) {\\n            while (!stack.isEmpty() && (i == len || heights[stack.peek()] >= heights[i])) {\\n                int h = heights[stack.pop()];\\n                int left = stack.isEmpty() ? -1 : stack.peek();\\n                /**\\n                 * i-1 - left ==> This is calculating the width of the rectangle. Both ith and\\n                 * left positions are excluded.\\n                 */\\n                maxArea = Math.max(maxArea, (i - 1 - left) * h);\\n            }\\n            stack.push(i);\\n        }\\n\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519885,
                "title": "c-java-python-javascript-stack-tc-o-n",
                "content": "# Intuition:\\nThe intuition behind the solution is to use two arrays, `nsr` (nearest smaller to the right) and `nsl` (nearest smaller to the left), to determine the boundaries of the rectangle for each bar in the histogram. By calculating the area for each rectangle and keeping track of the maximum area, we can find the largest rectangle in the histogram.\\n\\n# Approach:\\n1. Initialize an empty stack `s` to store the indices of the histogram bars.\\n2. Create two arrays, `nsr` and `nsl`, each of size `n` (where `n` is the number of elements in the `heights` vector), and initialize all elements to 0.\\n3. Process the histogram bars from right to left:\\n   - While the stack is not empty and the height of the current bar is less than or equal to the height of the bar at the top of the stack, pop the stack.\\n   - If the stack becomes empty, set `nsr[i]` (the nearest smaller to the right for the current bar) to `n`.\\n   - Otherwise, set `nsr[i]` to the index at the top of the stack.\\n   - Push the current index `i` onto the stack.\\n4. Empty the stack.\\n5. Process the histogram bars from left to right:\\n   - While the stack is not empty and the height of the current bar is less than or equal to the height of the bar at the top of the stack, pop the stack.\\n   - If the stack becomes empty, set `nsl[i]` (the nearest smaller to the left for the current bar) to -1.\\n   - Otherwise, set `nsl[i]` to the index at the top of the stack.\\n   - Push the current index `i` onto the stack.\\n6. Initialize a variable `ans` to 0. This variable will store the maximum rectangle area.\\n7. Iterate over the histogram bars:\\n   - Calculate the area of the rectangle for the current bar using the formula: `heights[i] * (nsr[i] - nsl[i] - 1)`.\\n   - Update `ans` with the maximum of `ans` and the calculated area.\\n8. Return `ans` as the largest rectangle area in the histogram.\\n\\n# Complexity:\\n- The time complexity of this solution is O(n), where n is the number of elements in the `heights` vector. This is because each bar is processed only once.\\n- The space complexity is O(n) as well because we use two additional arrays of size n, `nsr` and `nsl`, and a stack to store indices.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights){\\n        int n=heights.size();\\n        vector<int> nsr(n,0);\\n        vector<int> nsl(n,0);\\n\\n        stack<int> s;\\n\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[i]<=heights[s.top()]){\\n                s.pop();\\n            }\\n            if(s.empty()) nsr[i]=n;\\n            else nsr[i]=s.top();\\n            s.push(i);\\n        }\\n\\n        while(!s.empty()) s.pop();\\n\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[i]<=heights[s.top()]){\\n                s.pop();\\n            }\\n            if(s.empty()) nsl[i]=-1;\\n            else nsl[i]=s.top();\\n            s.push(i);\\n        }\\n\\n        int ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            ans=max(ans, heights[i]*(nsr[i]-nsl[i]-1));\\n        }\\n        return ans;        \\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```java\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        int[] nsr = new int[n];\\n        int[] nsl = new int[n];\\n        \\n        Stack<Integer> s = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.isEmpty() && heights[i] <= heights[s.peek()]) {\\n                s.pop();\\n            }\\n            if (s.isEmpty()) nsr[i] = n;\\n            else nsr[i] = s.peek();\\n            s.push(i);\\n        }\\n\\n        while (!s.isEmpty()) s.pop();\\n\\n        for (int i = 0; i < n; i++) {\\n            while (!s.isEmpty() && heights[i] <= heights[s.peek()]) {\\n                s.pop();\\n            }\\n            if (s.isEmpty()) nsl[i] = -1;\\n            else nsl[i] = s.peek();\\n            s.push(i);\\n        }\\n\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, heights[i] * (nsr[i] - nsl[i] - 1));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n# Python\\n```py\\nclass Solution(object):\\n    def largestRectangleArea(self, heights):\\n        n = len(heights)\\n        nsr = [0] * n\\n        nsl = [0] * n\\n\\n        s = []\\n\\n        for i in range(n - 1, -1, -1):\\n            while s and heights[i] <= heights[s[-1]]:\\n                s.pop()\\n            if not s:\\n                nsr[i] = n\\n            else:\\n                nsr[i] = s[-1]\\n            s.append(i)\\n\\n        while s:\\n            s.pop()\\n\\n        for i in range(n):\\n            while s and heights[i] <= heights[s[-1]]:\\n                s.pop()\\n            if not s:\\n                nsl[i] = -1\\n            else:\\n                nsl[i] = s[-1]\\n            s.append(i)\\n\\n        ans = 0\\n\\n        for i in range(n):\\n            ans = max(ans, heights[i] * (nsr[i] - nsl[i] - 1))\\n        return ans\\n\\n```\\n\\n---\\n\\n# JavaScript\\n```js\\nvar largestRectangleArea = function(heights) {\\n    const n = heights.length;\\n    const nsr = new Array(n).fill(0);\\n    const nsl = new Array(n).fill(0);\\n\\n    const stack = [];\\n        \\n    for (let i = n - 1; i >= 0; i--) {\\n        while (stack.length !== 0 && heights[i] <= heights[stack[stack.length - 1]]) {\\n                stack.pop();\\n        }\\n        if (stack.length === 0) {\\n            nsr[i] = n;\\n        } else {\\n            nsr[i] = stack[stack.length - 1];\\n        }\\n        stack.push(i);\\n    }\\n\\n    while (stack.length !== 0) {\\n        stack.pop();\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        while (stack.length !== 0 && heights[i] <= heights[stack[stack.length - 1]]) {\\n            stack.pop();\\n        }\\n        if (stack.length === 0) {\\n            nsl[i] = -1;\\n        } else {\\n             nsl[i] = stack[stack.length - 1];\\n        }\\n        stack.push(i);\\n    }\\n\\n    let ans = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        ans = Math.max(ans, heights[i] * (nsr[i] - nsl[i] - 1));\\n    }\\n   \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Monotonic Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights){\\n        int n=heights.size();\\n        vector<int> nsr(n,0);\\n        vector<int> nsl(n,0);\\n\\n        stack<int> s;\\n\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[i]<=heights[s.top()]){\\n                s.pop();\\n            }\\n            if(s.empty()) nsr[i]=n;\\n            else nsr[i]=s.top();\\n            s.push(i);\\n        }\\n\\n        while(!s.empty()) s.pop();\\n\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[i]<=heights[s.top()]){\\n                s.pop();\\n            }\\n            if(s.empty()) nsl[i]=-1;\\n            else nsl[i]=s.top();\\n            s.push(i);\\n        }\\n\\n        int ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            ans=max(ans, heights[i]*(nsr[i]-nsl[i]-1));\\n        }\\n        return ans;        \\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        int[] nsr = new int[n];\\n        int[] nsl = new int[n];\\n        \\n        Stack<Integer> s = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.isEmpty() && heights[i] <= heights[s.peek()]) {\\n                s.pop();\\n            }\\n            if (s.isEmpty()) nsr[i] = n;\\n            else nsr[i] = s.peek();\\n            s.push(i);\\n        }\\n\\n        while (!s.isEmpty()) s.pop();\\n\\n        for (int i = 0; i < n; i++) {\\n            while (!s.isEmpty() && heights[i] <= heights[s.peek()]) {\\n                s.pop();\\n            }\\n            if (s.isEmpty()) nsl[i] = -1;\\n            else nsl[i] = s.peek();\\n            s.push(i);\\n        }\\n\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, heights[i] * (nsr[i] - nsl[i] - 1));\\n        }\\n        return ans;\\n    }\\n}\\n```\n```py\\nclass Solution(object):\\n    def largestRectangleArea(self, heights):\\n        n = len(heights)\\n        nsr = [0] * n\\n        nsl = [0] * n\\n\\n        s = []\\n\\n        for i in range(n - 1, -1, -1):\\n            while s and heights[i] <= heights[s[-1]]:\\n                s.pop()\\n            if not s:\\n                nsr[i] = n\\n            else:\\n                nsr[i] = s[-1]\\n            s.append(i)\\n\\n        while s:\\n            s.pop()\\n\\n        for i in range(n):\\n            while s and heights[i] <= heights[s[-1]]:\\n                s.pop()\\n            if not s:\\n                nsl[i] = -1\\n            else:\\n                nsl[i] = s[-1]\\n            s.append(i)\\n\\n        ans = 0\\n\\n        for i in range(n):\\n            ans = max(ans, heights[i] * (nsr[i] - nsl[i] - 1))\\n        return ans\\n\\n```\n```js\\nvar largestRectangleArea = function(heights) {\\n    const n = heights.length;\\n    const nsr = new Array(n).fill(0);\\n    const nsl = new Array(n).fill(0);\\n\\n    const stack = [];\\n        \\n    for (let i = n - 1; i >= 0; i--) {\\n        while (stack.length !== 0 && heights[i] <= heights[stack[stack.length - 1]]) {\\n                stack.pop();\\n        }\\n        if (stack.length === 0) {\\n            nsr[i] = n;\\n        } else {\\n            nsr[i] = stack[stack.length - 1];\\n        }\\n        stack.push(i);\\n    }\\n\\n    while (stack.length !== 0) {\\n        stack.pop();\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        while (stack.length !== 0 && heights[i] <= heights[stack[stack.length - 1]]) {\\n            stack.pop();\\n        }\\n        if (stack.length === 0) {\\n            nsl[i] = -1;\\n        } else {\\n             nsl[i] = stack[stack.length - 1];\\n        }\\n        stack.push(i);\\n    }\\n\\n    let ans = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        ans = Math.max(ans, heights[i] * (nsr[i] - nsl[i] - 1));\\n    }\\n   \\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28954,
                "title": "share-my-2ms-java-solution-beats-100-java-submissions",
                "content": "    public class Solution {\\n        public int largestRectangleArea(int[] heights) {\\n            if (heights == null || heights.length == 0) return 0;\\n            return getMax(heights, 0, heights.length);\\n        }    \\n        int getMax(int[] heights, int s, int e) {\\n            if (s + 1 >= e) return heights[s];\\n            int min = s;\\n            boolean sorted = true;\\n            for (int i = s; i < e; i++) {\\n                if (i > s && heights[i] < heights[i - 1]) sorted = false;\\n                if (heights[min] > heights[i]) min = i;\\n            }\\n            if (sorted) {\\n                int max = 0;\\n                for (int i = s; i < e; i++) {\\n                    max = Math.max(max, heights[i] * (e - i));\\n                }\\n                return max;\\n            }\\n            int left = (min > s) ? getMax(heights, s, min) : 0;\\n            int right = (min < e - 1) ? getMax(heights, min + 1, e) : 0;\\n            return Math.max(Math.max(left, right), (e - s) * heights[min]);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int largestRectangleArea(int[] heights) {\\n            if (heights == null || heights.length == 0) return 0;\\n            return getMax(heights, 0, heights.length);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1727709,
                "title": "stack-c-easy-to-understand-180ms-2-approaches",
                "content": "Here are two approaches for the problem:\\n1. We use previous smaller element and next smaller element and compare those two to \\n\\tget our desired max rectangle area.\\n\\t\\n\\tWe have to use two separate functions here to find the previous smaller and next smaller element.\\n\\tThe algorithm to make it happen is this:\\n\\t```\\n\\t curr += ( i - prevSmall[i]-1 ) * heights[i];\\n     curr += ( nextSmall[i] - i - 1 ) * heights[i];\\n\\t```\\n\\t\\n\\t**Time Complexity: O(n)\\n\\tSpace Complexity: O(n)**\\n\\t\\n```\\nclass Solution {\\nprivate:\\n    vector<int> prevSmall;\\n    vector<int> nextSmall;\\n\\n    void previousSmaller(vector<int> heights){\\n        stack<int> s;\\n        s.push(0);\\n        prevSmall.push_back(-1);\\n        for(int i=1;i<heights.size();i++){\\n            while(s.empty()==false && heights[s.top()]>=heights[i])\\n                s.pop();\\n            if(s.empty())\\n                prevSmall.push_back(-1);\\n            else\\n                prevSmall.push_back(s.top());\\n            s.push(i);\\n        }\\n    }\\n    void nextSmaller(vector<int> heights){\\n        stack<int> s;\\n        int n = heights.size();\\n        s.push(n-1);\\n        nextSmall.push_back(n);\\n        for(int i=n-2;i>=0;i--){\\n            while(s.empty()==false && heights[s.top()]>=heights[i])\\n                s.pop();\\n            if(s.empty())\\n                nextSmall.push_back(n);\\n            else\\n                nextSmall.push_back(s.top());\\n            s.push(i);\\n        }\\n        //We used the reverse of array to find the next Smaller\\n        //So we need to reverse the vector\\n        reverse(nextSmall.begin(),nextSmall.end());\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        nextSmaller(heights);\\n        previousSmaller(heights);\\n        int res = 0;\\n        for(int i=0;i<heights.size();i++){\\n            int curr = heights[i];\\n            curr += (i-prevSmall[i]-1)*heights[i];\\n            curr += (nextSmall[i]-i-1)*heights[i];\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n2. We can make the above approach more efficient by using the idea of just previous smaller element\\n\\tAnd it can be done in a single loop.\\n\\t**Time Complexity: O(n)\\n\\tSpace Complexity: O(n)**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int res = 0, curr = 0, n = heights.size();\\n        stack<int> s;\\n        for(int i=0;i<n;i++){\\n            while(s.empty() == false && heights[s.top()]>=heights[i]){\\n                int top = s.top();\\n                s.pop();\\n                if(s.empty())\\n                    curr = heights[top]*i;\\n                else\\n                    curr = heights[top]*(i-s.top()-1);\\n                res = max(curr,res);\\n            }\\n            s.push(i);\\n        }\\n        //For the elements left in the stack\\n        while(s.empty() == false){\\n                int top = s.top();\\n                s.pop();\\n                if(s.empty())\\n                    curr = heights[top]*n;\\n                else\\n                    curr = heights[top]*(n-s.top()-1);\\n                res = max(curr,res);\\n            }\\n        return res;\\n    }\\n};\\n```\\n\\nHope you get it now :)",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\t curr += ( i - prevSmall[i]-1 ) * heights[i];\\n     curr += ( nextSmall[i] - i - 1 ) * heights[i];\\n\\t```\n```\\nclass Solution {\\nprivate:\\n    vector<int> prevSmall;\\n    vector<int> nextSmall;\\n\\n    void previousSmaller(vector<int> heights){\\n        stack<int> s;\\n        s.push(0);\\n        prevSmall.push_back(-1);\\n        for(int i=1;i<heights.size();i++){\\n            while(s.empty()==false && heights[s.top()]>=heights[i])\\n                s.pop();\\n            if(s.empty())\\n                prevSmall.push_back(-1);\\n            else\\n                prevSmall.push_back(s.top());\\n            s.push(i);\\n        }\\n    }\\n    void nextSmaller(vector<int> heights){\\n        stack<int> s;\\n        int n = heights.size();\\n        s.push(n-1);\\n        nextSmall.push_back(n);\\n        for(int i=n-2;i>=0;i--){\\n            while(s.empty()==false && heights[s.top()]>=heights[i])\\n                s.pop();\\n            if(s.empty())\\n                nextSmall.push_back(n);\\n            else\\n                nextSmall.push_back(s.top());\\n            s.push(i);\\n        }\\n        //We used the reverse of array to find the next Smaller\\n        //So we need to reverse the vector\\n        reverse(nextSmall.begin(),nextSmall.end());\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        nextSmaller(heights);\\n        previousSmaller(heights);\\n        int res = 0;\\n        for(int i=0;i<heights.size();i++){\\n            int curr = heights[i];\\n            curr += (i-prevSmall[i]-1)*heights[i];\\n            curr += (nextSmall[i]-i-1)*heights[i];\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int res = 0, curr = 0, n = heights.size();\\n        stack<int> s;\\n        for(int i=0;i<n;i++){\\n            while(s.empty() == false && heights[s.top()]>=heights[i]){\\n                int top = s.top();\\n                s.pop();\\n                if(s.empty())\\n                    curr = heights[top]*i;\\n                else\\n                    curr = heights[top]*(i-s.top()-1);\\n                res = max(curr,res);\\n            }\\n            s.push(i);\\n        }\\n        //For the elements left in the stack\\n        while(s.empty() == false){\\n                int top = s.top();\\n                s.pop();\\n                if(s.empty())\\n                    curr = heights[top]*n;\\n                else\\n                    curr = heights[top]*(n-s.top()-1);\\n                res = max(curr,res);\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28971,
                "title": "detailed-explanation-of-this-problem-o-n",
                "content": "Idea 1:\\n\\tDivide and Conquer using segment tree search. Time & space O(nlgn)\\n\\thttp://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n\\t\\n\\t\\nIdea 2:\\n\\tFor each bar, we calculate maximum area with current bar as the smallest one in the rectangle. If we want to maximize the area of this rectangle, the two sides' bars right next to this rectangle (but not belonging to this rectangle) are smaller than current bar. \\n\\t\\nIf we do this for every bar, and record the maximum, then this maximum is the result we want. (Since height of rectangle is determined by smallest bar in this rectangle, and width is determined by number of bars in this rectangle. Now we calculate all possible maximum rectangles whose height is one of the bars with largest possible width.)\\n\\t\\nHow can we get left smaller bar and right smaller bar of each bar?\\n\\n(1) Brute force way: Traverse all bars, and use linear search to find. O(n^2) time O(1) space\\n\\t\\n(2) Use two arrays to record known left, right bars of each bar. When we search for next bar, we might use this result to skip some bars. It is time O(n) and space O(n).\\n\\thttps://discuss.leetcode.com/topic/48127/java-o-n-left-right-arrays-solution-4ms-beats-96\\n\\t\\n(3) Use a Stack to store indexes of all pending bars. What does 'pending' means here? It means we cannot find corresponding right bar for it. A valid corresponding right bar is defined as the first bar the smaller than this bar to the right.\\n\\nSo when we meet a higher bar than current top of stack, we push it. Otherwise, we pop out the top of current stack, because we find a valid right bar for this popped out bar. Then we look for its left bar which just located on the next layer of this stack. Now we have left bar and right bar of this popped out bar, we can calculate its maximum rectangle's area.\\n\\t\\nSo stack always maintains indexes of ascending ordered bars.\\n\\t\\nAfter we traverse all bars, if stack is not empty. Then it means there is no right bar for these remaining bars (an extreme example is increasing ordered bars), so we can just use heights.length as the index of right bar for them, and popped them out one by one.\\n\\t\\nThis method time complexity is O(n) space O(n)\\n\\t\\n\\t\\nSome corner cases during execution:\\n\\t1. Stack is empty when try to compare top of stack: Just push current bar.\\n\\t2. No left bar found after current bar is popped out: case like [3,1]. use -1 if stack is empty when looking for left bar.\\n\\t\\t\\nA small trick:\\n\\tWhen rightIndex == heights.length, use 0 as new bar's height so that we can pop out all remaining bars in the stack. (Since no bar's height will be smaller than 0. We won't need another while loop to handle it.)\\n\\n\\n\\n```java\\npublic class Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int max = 0, rightIndex = 0;\\n        while(rightIndex <= heights.length) {\\n            int rightHeight = (rightIndex == heights.length ? 0 : heights[rightIndex]); // All new bars are seen as potential right bar\\n            if(stack.isEmpty() || heights[stack.peek()] < rightHeight) stack.push(rightIndex++); // Only increment rightIndex, when pushed\\n            else {\\n                int curHeight = heights[stack.pop()];  // Be careful that stack only store index, we still need heights[index] to get height\\n                int leftIndex = (stack.isEmpty() ? -1 : stack.peek());  // Be careful of case of no left bar\\n                max = Math.max(max, (rightIndex - leftIndex - 1) * curHeight);\\n            }\\n        }\\n        return max;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t/*\\n\\t\\tWithout trick version\\n\\t*/\\n\\tpublic int largestRectangleArea(int[] heights) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int max = 0, rightIndex = 0;\\n        while(rightIndex < heights.length) {\\n            int rightHeight = heights[rightIndex]; // All new bars are seen as potential right bar\\n            if(stack.isEmpty() || heights[stack.peek()] < rightHeight) stack.push(rightIndex++); // Only increment rightIndex, when pushed\\n            else {\\n                int curHeight = heights[stack.pop()];  // Be careful that stack only store index, we still need heights[index] to get height\\n                int leftIndex = (stack.isEmpty() ? -1 : stack.peek());  // Be careful of case of no left bar\\n                max = Math.max(max, (rightIndex - leftIndex - 1) * curHeight);\\n            }\\n        }\\n        while(!stack.isEmpty()) {\\n            int curHeight = heights[stack.pop()]; \\n            int leftIndex = (stack.isEmpty() ? -1 : stack.peek()); \\n            max = Math.max(max, (rightIndex - leftIndex - 1) * curHeight); // here rightIndex == heights.length\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int max = 0, rightIndex = 0;\\n        while(rightIndex <= heights.length) {\\n            int rightHeight = (rightIndex == heights.length ? 0 : heights[rightIndex]); // All new bars are seen as potential right bar\\n            if(stack.isEmpty() || heights[stack.peek()] < rightHeight) stack.push(rightIndex++); // Only increment rightIndex, when pushed\\n            else {\\n                int curHeight = heights[stack.pop()];  // Be careful that stack only store index, we still need heights[index] to get height\\n                int leftIndex = (stack.isEmpty() ? -1 : stack.peek());  // Be careful of case of no left bar\\n                max = Math.max(max, (rightIndex - leftIndex - 1) * curHeight);\\n            }\\n        }\\n        return max;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t/*\\n\\t\\tWithout trick version\\n\\t*/\\n\\tpublic int largestRectangleArea(int[] heights) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int max = 0, rightIndex = 0;\\n        while(rightIndex < heights.length) {\\n            int rightHeight = heights[rightIndex]; // All new bars are seen as potential right bar\\n            if(stack.isEmpty() || heights[stack.peek()] < rightHeight) stack.push(rightIndex++); // Only increment rightIndex, when pushed\\n            else {\\n                int curHeight = heights[stack.pop()];  // Be careful that stack only store index, we still need heights[index] to get height\\n                int leftIndex = (stack.isEmpty() ? -1 : stack.peek());  // Be careful of case of no left bar\\n                max = Math.max(max, (rightIndex - leftIndex - 1) * curHeight);\\n            }\\n        }\\n        while(!stack.isEmpty()) {\\n            int curHeight = heights[stack.pop()]; \\n            int leftIndex = (stack.isEmpty() ? -1 : stack.peek()); \\n            max = Math.max(max, (rightIndex - leftIndex - 1) * curHeight); // here rightIndex == heights.length\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29002,
                "title": "my-c-dp-solution-16ms-easy-to-understand",
                "content": "I think it might be O(n), or very close to O(n), it cannot be O(n^2).\\nCan anybody help to prove?\\n\\n\\n    int largestRectangleArea(vector<int>& height) {\\n        int n = height.size(), ans = 0, p;\\n        vector<int> left(n,0), right(n,n);\\n        for (int i = 1;i < n;++i) {\\n            p = i-1;\\n            while (p >= 0 && height[i] <= height[p])\\n                p = left[p] - 1;\\n            left[i] = p + 1;\\n        }\\n        for (int i = n-2;i >= 0;--i) {\\n            p = i+1;\\n            while (p < n && height[i] <= height[p])\\n                p = right[p];\\n            right[i] = p;\\n        }\\n        for (int i = 0;i < n;++i)\\n            ans = max(ans,height[i]*(right[i]-left[i]));\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "I think it might be O(n), or very close to O(n), it cannot be O(n^2).\\nCan anybody help to prove?\\n\\n\\n    int largestRectangleArea(vector<int>& height) {\\n        int n = height.size(), ans = 0, p;\\n        vector<int> left(n,0), right(n,n);\\n        for (int i = 1;i < n;++i) {\\n            p = i-1;\\n            while (p >= 0 && height[i] <= height[p])\\n                p = left[p] - 1;\\n            left[i] = p + 1;\\n        }\\n        for (int i = n-2;i >= 0;--i) {\\n            p = i+1;\\n            while (p < n && height[i] <= height[p])\\n                p = right[p];\\n            right[i] = p;\\n        }\\n        for (int i = 0;i < n;++i)\\n            ans = max(ans,height[i]*(right[i]-left[i]));\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3437179,
                "title": "c-explanation-using-stack-o-n-time-space",
                "content": "Problem:\\n- We are given an array of integers which represent the height of bars in a histogram.\\n- The width of each bar is 1.\\n- We need to form a rectangle with these bars with the largest area.\\n\\nExample :\\n\\n![WhatsApp Image 2023-04-20 at 10.54.15 AM.jpeg](https://assets.leetcode.com/users/images/f503d54d-30ce-43b4-80a1-781f6ef109d9_1681968701.6486282.jpeg)\\n\\n\\n- Above we have a histogram, where value of bar represents the height of the bar.\\n- We need to form rectangle using these which has the largest area.\\n- Say, one rectangle which can be formed would be of ```height = 1```, and ```width = 6```, like below :\\n\\n![3_1.jpeg](https://assets.leetcode.com/users/images/9effc917-9fc9-4388-827d-2a396a4dca7d_1681968812.4244616.jpeg)\\n\\n\\n- Another rectangle which can be formed is using the last 4 bars, as shown below:\\n\\n![2_1.jpeg](https://assets.leetcode.com/users/images/f0e78d03-49da-48ed-a9cc-c64d6ba8553f_1681968839.778373.jpeg)\\n\\n\\n- Since we need to find the rectangle with the largest area, it would be the one below : \\n\\n![4_1.jpeg](https://assets.leetcode.com/users/images/67aaa468-39bb-4ebc-aacd-70b31e37151e_1681968868.5627692.jpeg)\\n\\n\\n# Solution explaination:\\n\\n- So the idea is to use stack, in such a way, that we push the indexes of bars with increasing heights into it.\\n- If, at one point, we find a bar smaller than the bar in the top of stack, we will pop that bar, and use it as height of rectangle, and the width would be the the difference between the index of the popped bar and the index of the bar which we are currently at. \\n- Let\\'s understand through an example : ```[ 1 , 2 , 3 , 1]```\\n\\n![5_1.jpeg](https://assets.leetcode.com/users/images/b359e6d3-41ef-44c6-9862-52fe2f930924_1681968900.60353.jpeg)\\n\\n\\n- We will iterate through the bars one by one, through a variable, say ```i```. \\n- Also, lets make a stack, initially empty.\\n\\n![6_1.jpeg](https://assets.leetcode.com/users/images/b64775a5-d308-4d02-9c59-03bb80ad39a5_1681968924.4549932.jpeg)\\n\\n\\n- At , ```i = 0```, our stack is initially empty, so we push the index , ```i = 0``` into stack, and increment ```i```.\\n\\n![7_1.jpeg](https://assets.leetcode.com/users/images/13b0be3f-dde6-4471-9baa-d6138ee78340_1681968947.7664087.jpeg)\\n\\n\\n- At, ```i = 1```, our stack is not empty.\\n- As I had said, we will be pushing bars into stack, if the bar at which we are currently at (i = 1) is greater than the bar at the top of stack.\\n- ```Top of stack = 0 , height[0] = 1```\\n- ``` i = 1 , height [1] = 2 ```\\n- ``` Since height[i] >= height[top of stack],therefore, push i=1 into stack```\\n\\n![8_1.jpeg](https://assets.leetcode.com/users/images/377721c8-91f2-4b71-b602-846cabe52881_1681968974.5572207.jpeg)\\n\\n\\n- Similary, at ```i = 2``` \\n-  ```Top of stack = 1 , height[1] = 2```\\n- ``` i = 2 , height [2] = 3 ```\\n- ``` Since height[i] >= height[top of stack],therefore, push i = 2 , into stack```\\n\\n![9_1.jpeg](https://assets.leetcode.com/users/images/9e089954-6f87-4518-a955-d31933284a84_1681968992.3227355.jpeg)\\n\\n\\n- Now, at ``` i = 3 ``` , we see that ```height[i] < height[top of stack]```\\n- ```height[i] = height[3] = 1```\\n- ```height[top of stack] = height[2] = 3```\\n- So, we cannot push this bar into stack.\\n- We pop out the index at the top of the stack.\\n- Now using this bar, we will form the ```height``` of rectangle.\\n- So the question to form the ```width``` rectangle is : \\n```\\n What is the distance between the bars , top of stack, \\n and the index \\'i\\' ?\\n  \\n```\\n- Important idea to note is, that while forming rectangle, we do not consider merging the bars behind the top of stack bar\\n- This is because we have pushed them into the stack.Meaning they must already be less than this bar, so we cannot merge them with this bar to form rectangle.\\n- So, we can can calculate our ```height``` and ```width``` of rectangle, and then calculate the area as shown below:\\n\\n![10_1.jpeg](https://assets.leetcode.com/users/images/b72f0f05-a458-4aa8-8a31-3e85ab4c4336_1681969035.2992516.jpeg)\\n\\n\\n![11_1.jpeg](https://assets.leetcode.com/users/images/394663b8-f9d3-4046-b112-23e415e8df18_1681969084.0234222.jpeg)\\n\\n\\n![12_1.jpeg](https://assets.leetcode.com/users/images/e4a6e6b4-ba38-402d-92d9-c5937929d85a_1681969102.8191037.jpeg)\\n\\n![13_1.jpeg](https://assets.leetcode.com/users/images/7706ad12-cb1d-42d1-a0b4-d9fde690e55d_1681969113.2921057.jpeg)\\n\\n- So , our ```max area = 3 ``` so far.\\n- Again , we will compare the ```height[i]``` bar and ```height[top of stack]``` bar.\\n- ```height[i] = height[3] = 1```\\n- ```height[top of stack] = height[1] = 2```\\n- Since ```height[i] <= height[top of stack] ``` we will pop from the stack, as shown below :\\n\\n![14_1.jpeg](https://assets.leetcode.com/users/images/74149e41-3a69-4e4d-ba76-f0d48322c580_1681969141.1497586.jpeg)\\n\\n\\n- We will try forming a rectangle with ```height = height[top of stack] ```. \\n\\n![15_1.jpeg](https://assets.leetcode.com/users/images/06128f91-54bc-4ff6-a038-cf46e6447034_1681969167.3417048.jpeg)\\n\\n\\n![16_1.jpeg](https://assets.leetcode.com/users/images/3cc847dd-b3f1-4d7f-85c1-b12ad551f836_1681969191.2273915.jpeg)\\n\\n\\n- The area formed = 4, which is greater than ```max area = 3``` therefore, we will update ```max area = 4``` now.\\n- Again, we will compare with ```height[i]``` and ```height[top of stack]```.\\n- ```height[i] = height[3] = 1```\\n- ```height[top of stack] = height[0] = 1 ```\\n- ```height[i] <= height[top of stack]```, therefore pop from stack.\\n\\n![17_1.jpeg](https://assets.leetcode.com/users/images/8023ad8b-42f6-4ea6-9a87-5f2511393ecc_1681969216.411232.jpeg)\\n\\n\\n![t_345.jpeg](https://assets.leetcode.com/users/images/df819cfc-90be-48ad-8235-787138fc1470_1681972523.8587441.jpeg)\\n\\n\\n![t_234.jpeg](https://assets.leetcode.com/users/images/245a0e3a-bfaa-4cd1-831f-280578ccb17d_1681973020.3200893.jpeg)\\n\\n\\n- We have an empty stack, so we will push ```i=3``` bar into stack and increment ``i``.\\n\\n![t_182.jpeg](https://assets.leetcode.com/users/images/03b6741c-017d-4ddb-a83f-fc3013296596_1681972764.2276301.jpeg)\\n\\n\\n- Since, we have tarversed all the bars, ```i=4```, there is no need to push more bars into the stack.\\n- However, our stack is not yet empty.\\n- So we will pop out the top of stack, and use it as ```height``` of rectangle.\\n- So,\\n\\n\\n![t_111.jpeg](https://assets.leetcode.com/users/images/259321da-5a11-485a-b5a4-a59a81358eb0_1681972640.717916.jpeg)\\n\\n\\n![21_1.jpeg](https://assets.leetcode.com/users/images/cad162ee-9ae2-4932-b4cd-150f3698d22c_1681969371.0752761.jpeg)\\n\\n\\n- ```Thus the rectangle which can be formed with the max area would be = 4```.\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int>stk;\\n        int i=0;\\n        int n=heights.size();\\n        int maxArea = 0;\\n        while(i < n)\\n            {   \\n\\n    if(stk.empty() or( heights[stk.top()] <= heights[i] ))\\n            {\\n                stk.push(i++);\\n            }\\n            else\\n            {\\n                int minBarIndex = stk.top();\\n                stk.pop();\\n                int width = i;\\n                if(!stk.empty())  width = i - 1 - stk.top();\\n                int area = heights[minBarIndex] * width;\\n                maxArea = max(maxArea , area);\\n            }\\n        }\\n\\n        while(!stk.empty())\\n        {\\n            int minBarIndex = stk.top();\\n            stk.pop();\\n            int width = i;\\n            if(!stk.empty())  width = i - 1 - stk.top();\\n            int area = heights[minBarIndex] * width;\\n            maxArea = max(maxArea , area);\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack",
                    "Simulation"
                ],
                "code": "```height = 1```\n```width = 6```\n```[ 1 , 2 , 3 , 1]```\n```i```\n```i = 0```\n```i = 0```\n```i```\n```i = 1```\n```Top of stack = 0 , height[0] = 1```\n``` i = 1 , height [1] = 2 ```\n``` Since height[i] >= height[top of stack],therefore, push i=1 into stack```\n```i = 2```\n```Top of stack = 1 , height[1] = 2```\n``` i = 2 , height [2] = 3 ```\n``` Since height[i] >= height[top of stack],therefore, push i = 2 , into stack```\n``` i = 3 ```\n```height[i] < height[top of stack]```\n```height[i] = height[3] = 1```\n```height[top of stack] = height[2] = 3```\n```height```\n```width```\n```\\n What is the distance between the bars , top of stack, \\n and the index \\'i\\' ?\\n  \\n```\n```height```\n```width```\n```max area = 3 ```\n```height[i]```\n```height[top of stack]```\n```height[i] = height[3] = 1```\n```height[top of stack] = height[1] = 2```\n```height[i] <= height[top of stack] ```\n```height = height[top of stack] ```\n```max area = 3```\n```max area = 4```\n```height[i]```\n```height[top of stack]```\n```height[i] = height[3] = 1```\n```height[top of stack] = height[0] = 1 ```\n```height[i] <= height[top of stack]```\n```i=3```\n```i=4```\n```height```\n```Thus the rectangle which can be formed with the max area would be = 4```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int>stk;\\n        int i=0;\\n        int n=heights.size();\\n        int maxArea = 0;\\n        while(i < n)\\n            {   \\n\\n    if(stk.empty() or( heights[stk.top()] <= heights[i] ))\\n            {\\n                stk.push(i++);\\n            }\\n            else\\n            {\\n                int minBarIndex = stk.top();\\n                stk.pop();\\n                int width = i;\\n                if(!stk.empty())  width = i - 1 - stk.top();\\n                int area = heights[minBarIndex] * width;\\n                maxArea = max(maxArea , area);\\n            }\\n        }\\n\\n        while(!stk.empty())\\n        {\\n            int minBarIndex = stk.top();\\n            stk.pop();\\n            int width = i;\\n            if(!stk.empty())  width = i - 1 - stk.top();\\n            int area = heights[minBarIndex] * width;\\n            maxArea = max(maxArea , area);\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921900,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of heights.\\n    //   - space: O(n), where n is the length of heights.\\n\\n    func largestRectangleArea(_ heights: [Int]) -> Int {\\n        var stack = [Int]()\\n        let n = heights.count\\n        var ans = 0\\n        \\n        for i in 0..<n {\\n            while let curHeight = stack.last, heights[curHeight] >= heights[i] {\\n                stack.removeLast()\\n                let curWidth = stack.last ?? -1\\n                ans = max(ans, heights[curHeight] * (i - curWidth - 1))\\n            }\\n            stack.append(i)\\n        }\\n        \\n        while !stack.isEmpty {\\n            let curHeight = stack.removeLast()\\n            let curWidth = stack.last ?? -1\\n            ans = max(ans, heights[curHeight] * (n - curWidth - 1))\\n        }\\n        \\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of heights.\\n    //   - space: O(n), where n is the length of heights.\\n\\n    func largestRectangleArea(_ heights: [Int]) -> Int {\\n        var stack = [Int]()\\n        let n = heights.count\\n        var ans = 0\\n        \\n        for i in 0..<n {\\n            while let curHeight = stack.last, heights[curHeight] >= heights[i] {\\n                stack.removeLast()\\n                let curWidth = stack.last ?? -1\\n                ans = max(ans, heights[curHeight] * (i - curWidth - 1))\\n            }\\n            stack.append(i)\\n        }\\n        \\n        while !stack.isEmpty {\\n            let curHeight = stack.removeLast()\\n            let curWidth = stack.last ?? -1\\n            ans = max(ans, heights[curHeight] * (n - curWidth - 1))\\n        }\\n        \\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142427,
                "title": "solution-using-stack-c",
                "content": "This problem is particularly  almost similar to Trapping Rainwater Problem.\\nHere in this post I would like to highlight both their solutions so one could dop a comparitive study of the approach and figure out their individual details.\\n\\n**Trapping Rainwater Problem (Approach Using Stack)**\\n\\n```\\nint trap(vector<int>& height)\\n{\\n    int ans = 0, current = 0;\\n    stack<int> st;\\n    while (current < height.size()) {\\n        while (!st.empty() && height[current] > height[st.top()]) {\\n            int top = st.top();\\n            st.pop();\\n            if (st.empty())\\n                break;\\n            int horizontal = current - st.top() - 1;\\n            int vertical = min(height[current], height[st.top()]) - height[top];\\n            ans += horizontal * vertical;\\n        }\\n        st.push(current++);\\n    }\\n    return ans;\\n}\\n```\\n\\n*Link: https://leetcode.com/problems/trapping-rain-water/solution/*\\n\\n**Largest Rectangle Problem (Approach Using Stack)**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int>st;\\n        heights.push_back(0);\\n        int ret=0;\\n            for(int i = 0; i < heights.size(); i++)\\n            {\\n                while(st.size() > 0 && heights[st.top()] >= heights[i])\\n                {\\n                    int vertical = heights[st.top()];\\n                    st.pop();\\n                    \\n                    int right_upper_bound = st.size() > 0 ? st.top() : -1;\\n                    int horizontal=(i-right_upper_bound-1);\\n                    if(vertical * horizontal  > ret)\\n                        ret = vertical * horizontal;\\n                }\\n                st.push(i);\\n            }\\n            \\n            return ret;\\n        }\\n    };\\n```\\n\\nHope this would help to make a comparision and help you to approach similar problems with ease!!",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint trap(vector<int>& height)\\n{\\n    int ans = 0, current = 0;\\n    stack<int> st;\\n    while (current < height.size()) {\\n        while (!st.empty() && height[current] > height[st.top()]) {\\n            int top = st.top();\\n            st.pop();\\n            if (st.empty())\\n                break;\\n            int horizontal = current - st.top() - 1;\\n            int vertical = min(height[current], height[st.top()]) - height[top];\\n            ans += horizontal * vertical;\\n        }\\n        st.push(current++);\\n    }\\n    return ans;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int>st;\\n        heights.push_back(0);\\n        int ret=0;\\n            for(int i = 0; i < heights.size(); i++)\\n            {\\n                while(st.size() > 0 && heights[st.top()] >= heights[i])\\n                {\\n                    int vertical = heights[st.top()];\\n                    st.pop();\\n                    \\n                    int right_upper_bound = st.size() > 0 ? st.top() : -1;\\n                    int horizontal=(i-right_upper_bound-1);\\n                    if(vertical * horizontal  > ret)\\n                        ret = vertical * horizontal;\\n                }\\n                st.push(i);\\n            }\\n            \\n            return ret;\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727816,
                "title": "c-o-n-stack-solution-explaination-with-diagram",
                "content": "**Approach:**\\nArea of reactangle is height * width\\nSince we want to maximise the area , we can either increase height or width. But since the heights are already fixed , we need to find the maximum width for each height,\\n\\nThe naive approach to implement this is to traverse and for each height traverse to left and right and find the first block shorter than current . If we go beyond this , then we can form a rectangle only by \\ntaking height of smaller block. \\n**Time**: O(n^2), **Space**: O(1)\\n\\n**Optimisation**:\\nWe can optimise the time to find smaller block on both sides by using a monotonic stack.\\n1. We traverse from left and right seperately. \\n2. The idea of monotonic stack is simple , if we find a smaller element than those in stack, then simply pop those greater elements from stack as if the new element is smaller than them , then it would be the first to cause any hinderance to further element and the elements in stack would be useless \\n3. While doing so store the values in left and right arrays.\\n4. Now traverse in array and now we can find left and right smaller blocks in constant time\\n\\n**Time: O(n)\\nSpace: O(n)**\\n\\n![image](https://assets.leetcode.com/users/images/5e3d3d9a-36de-471c-81f9-08c5d92e4524_1643433903.9594283.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n    int n = heights.size();\\n    vector<int> left(n, 0) , right(n, 0);\\n\\n    stack<int> s;\\n\\n    for (int i = 0; i < n; i++) {\\n        while (!s.empty() and heights[s.top()] >= heights[i]) {\\n            s.pop();\\n        }\\n        left[i] = (s.empty()) ? -1 : s.top();\\n        s.push(i);\\n    }\\n\\n    while (!s.empty())\\n        s.pop();\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        while (!s.empty() and heights[s.top()] >= heights[i]) {\\n            s.pop();\\n        }\\n        right[i] = (s.empty()) ? n : s.top();\\n        s.push(i);\\n    }\\n\\n    int ans = INT_MIN;\\n\\n    for (int i = 0; i < n; i++) {\\n        int distance = right[i] - left[i] - 1;\\n        ans = max(ans , heights[i] * distance);\\n    }\\n\\n\\n    return ans;\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n    int n = heights.size();\\n    vector<int> left(n, 0) , right(n, 0);\\n\\n    stack<int> s;\\n\\n    for (int i = 0; i < n; i++) {\\n        while (!s.empty() and heights[s.top()] >= heights[i]) {\\n            s.pop();\\n        }\\n        left[i] = (s.empty()) ? -1 : s.top();\\n        s.push(i);\\n    }\\n\\n    while (!s.empty())\\n        s.pop();\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        while (!s.empty() and heights[s.top()] >= heights[i]) {\\n            s.pop();\\n        }\\n        right[i] = (s.empty()) ? n : s.top();\\n        s.push(i);\\n    }\\n\\n    int ans = INT_MIN;\\n\\n    for (int i = 0; i < n; i++) {\\n        int distance = right[i] - left[i] - 1;\\n        ans = max(ans , heights[i] * distance);\\n    }\\n\\n\\n    return ans;\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023979,
                "title": "python-solution",
                "content": "Initialize an empty `stack` and iterate over the elements in `heights`. Suppose we are at index `i`, we can construct `stack` in such a way that it contains all the rectangles that started at an index `j <= i`, and can survive `i` (i.e., `height[j] <= height[i]`). By construction, the rectangles in `stack` will have a monotonic non-decreasing height. More specifically, at index `i`, we have the following possibilities:\\n1. The `stack` is empty, in which case, we add `(i, heights[i])` into `stack`, i.e., a rectangle starting at `i` of height `heights[i]`.\\n2. The `stack` is non-empty, and `stack[-1][1] <= heights[i]`, in which case all rectangles in the `stack` will be able to survive `i`, and we don\\'t need to do anything about existing elements in `stack`. We just need to append `(i, heights[i])` to the `stack`.\\n3. The `stack` is non-empty, and  `stack[-1][1] > heights[i]`, in which case rectangles in `stack` with height larger than `heights[i]` will not be able to survive `i`. So we keep popping the `stack` until it\\'s empty or the last element of the stack has height no larger than `heights[i]`. Each time we pop `stack`, and get an element `(j, m)`, we need to update the `max_area`, because there is a rectangle of height `m` that started at `j` and end at `i - 1`, with area `(i - j) * m`, and it may well be the rectangle with the largest area. Finally, we need to append a rectangle `stack` of height `heights[i]`. To maximize its area, we want to make its starting point as small as possible. The smallest it can be is the starting point of the shortest rectangle that fails to survive `i`, which is the index of the last rectangle we popped from `stack`. So when finish `stack`, we just need to append `(j, heights[i])` to it.\\n\\nFinally, after iterating over `heights`, whatever that\\'s left in `stack` are all the rectangles that managed to survive the last index of `heights`. So we just need to pop out each element `(j, m)` in `stack`, and check its area `(len(heights) - j) * m` is larger than `max_area`, and update `max_area` accordingly. After this, `max_area` is the desired solution to the problem.\\n\\nTime complexity: O(n), space complexity: O(n).\\n\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        stack = []\\n        max_area = 0\\n        l = len(heights)\\n        for i, n in enumerate(heights):\\n            if not stack or stack[-1][1] <= n:\\n                stack.append((i, n))\\n            else:\\n                while stack and stack[-1][1] > n:\\n                    j, m = stack.pop()\\n                    max_area = max(max_area, (i - j) * m)\\n                stack.append((j, n))\\n        \\n        while stack:\\n            j, m = stack.pop()\\n            max_area = max(max_area, (l - j) * m)\\n        return max_area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        stack = []\\n        max_area = 0\\n        l = len(heights)\\n        for i, n in enumerate(heights):\\n            if not stack or stack[-1][1] <= n:\\n                stack.append((i, n))\\n            else:\\n                while stack and stack[-1][1] > n:\\n                    j, m = stack.pop()\\n                    max_area = max(max_area, (i - j) * m)\\n                stack.append((j, n))\\n        \\n        while stack:\\n            j, m = stack.pop()\\n            max_area = max(max_area, (l - j) * m)\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29011,
                "title": "tle-for-test-case-3000-consecutive-1s",
                "content": "It passes the custom testcase in 24ms, but when I submit it's TLE..\\n\\nCode:\\n\\n    public class Solution {\\n        public int largestRectangleArea(int[] height) {\\n            Stack<Integer> maxIdx = new Stack<Integer>();\\n            int area = 0;\\n            for (int i = 0; i < height.length; i++) {\\n                if (maxIdx.isEmpty() || height[maxIdx.peek()] <= height[i]) {\\n                    maxIdx.push(i);\\n                } else {\\n                    int idx = maxIdx.pop();\\n                    int width = maxIdx.isEmpty() ? i : i - maxIdx.peek() - 1;\\n                    area = Math.max(area, width * height[idx]);\\n                    i--;\\n                }\\n            }\\n            while(!maxIdx.isEmpty()) {\\n                int idx = maxIdx.pop();\\n                int width = maxIdx.isEmpty() ? height.length : height.length - maxIdx.peek() - 1;\\n                area = Math.max(area, width * height[idx]);\\n            }\\n        return area;\\n        }\\n    }\\n\\nThanks!",
                "solutionTags": [],
                "code": "class Solution {\\n        public int largestRectangleArea(int[] height) {\\n            Stack<Integer> maxIdx = new Stack<Integer>();\\n            int area = 0;\\n            for (int i = 0; i < height.length; i++) {\\n                if (maxIdx.isEmpty() || height[maxIdx.peek()] <= height[i]) {\\n                    maxIdx.push(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1747815,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int ans=0;\\n        int ps[]=previousSmall(heights);\\n        int ns[]=nextSmall(heights);\\n        for(int i=0 ;i<heights.length ;i++){\\n            ans=Math.max(ans,(ns[i]-ps[i]-1)*heights[i]);\\n        }\\n        return ans;\\n    }\\n    public int[] previousSmall(int[] arr) {\\n        int n=arr.length;\\n        Stack<Integer> s= new Stack<>();\\n        int[] ans=new int[n];\\n        for(int i=0 ;i<n ;i++){\\n            while(!s.isEmpty() && arr[s.peek()]>=arr[i]) s.pop();\\n            if(s.isEmpty()) ans[i]=-1;\\n            else ans[i]=s.peek();\\n            \\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n    public int[] nextSmall(int[] arr) {\\n        int n=arr.length;\\n        Stack<Integer> s= new Stack<>();\\n        int[] ans=new int[n];\\n        for(int i=n-1 ;i>=0 ;i--){\\n            while(!s.isEmpty() && arr[s.peek()]>=arr[i]) s.pop();\\n            if(s.isEmpty()) ans[i]=n;\\n            else ans[i]=s.peek();\\n            \\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int ans=0;\\n        int ps[]=previousSmall(heights);\\n        int ns[]=nextSmall(heights);\\n        for(int i=0 ;i<heights.length ;i++){\\n            ans=Math.max(ans,(ns[i]-ps[i]-1)*heights[i]);\\n        }\\n        return ans;\\n    }\\n    public int[] previousSmall(int[] arr) {\\n        int n=arr.length;\\n        Stack<Integer> s= new Stack<>();\\n        int[] ans=new int[n];\\n        for(int i=0 ;i<n ;i++){\\n            while(!s.isEmpty() && arr[s.peek()]>=arr[i]) s.pop();\\n            if(s.isEmpty()) ans[i]=-1;\\n            else ans[i]=s.peek();\\n            \\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n    public int[] nextSmall(int[] arr) {\\n        int n=arr.length;\\n        Stack<Integer> s= new Stack<>();\\n        int[] ans=new int[n];\\n        for(int i=n-1 ;i>=0 ;i--){\\n            while(!s.isEmpty() && arr[s.peek()]>=arr[i]) s.pop();\\n            if(s.isEmpty()) ans[i]=n;\\n            else ans[i]=s.peek();\\n            \\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728106,
                "title": "easy-c-sol-with-just-one-traversal",
                "content": "**Pre-requisite** = Previous smaller element using stack.\\n\\n**Idea** :-The idea is to use the concept of next smaller element and previous smaller element, we will maintain the index of previous smaller element in the stack and we can get the next smaller element when we pop the element from the stack as the element is popped only when we encounter a smaller element. If at the end the stack is not empty , then for those elements there was no next smaller element so we can consider the next smaller element to exist at the the index = size of the vector/ array, while the previous smaller element is always just below the element it in the stack given the stack had an element below it, otherwise consider the previous smaller element at -1. \\n\\n```\\nint largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        stack<int> st;\\n        int maxArea = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            while(!st.empty() && heights[i] <= heights[st.top()]) {\\n                int ind = st.top();\\n                st.pop();\\n                int currArea = heights[ind]*(st.empty() ? i : i - st.top() - 1);\\n                maxArea = max(maxArea, currArea);\\n            }\\n            st.push(i);\\n        }\\n        \\n        while(!st.empty()) {\\n            int ind = st.top();\\n            st.pop();\\n            int currArea = heights[ind]*(st.empty() ? n : n - st.top() - 1);\\n            maxArea = max(maxArea, currArea);\\n        }\\n        return maxArea;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        stack<int> st;\\n        int maxArea = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            while(!st.empty() && heights[i] <= heights[st.top()]) {\\n                int ind = st.top();\\n                st.pop();\\n                int currArea = heights[ind]*(st.empty() ? i : i - st.top() - 1);\\n                maxArea = max(maxArea, currArea);\\n            }\\n            st.push(i);\\n        }\\n        \\n        while(!st.empty()) {\\n            int ind = st.top();\\n            st.pop();\\n            int currArea = heights[ind]*(st.empty() ? n : n - st.top() - 1);\\n            maxArea = max(maxArea, currArea);\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709320,
                "title": "c-solution-using-stack-arrays-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019ll take a stack & 2 arrays to solve it.\\n- We\\u2019ll find the left and right smaller of every index and store it in left and right array.\\n- In the stack, we\\u2019ll store the index which is in increasing order for the left array.\\n- For the right array, we\\u2019ll store decreasing indexes in the stack.\\n- After iterating all elements we\\u2019ll calculate the area using **`max(ans, heights[i]*(right[i]-left[i]+1))`**\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size(), ans = 0, left[n], right[n];\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!st.empty() && heights[st.top()] >= heights[i]) st.pop();\\n            if(st.empty()) left[i]=0;\\n            else left[i] = st.top() + 1;\\n            st.push(i);\\n        }\\n        \\n        while(!st.empty()) st.pop();\\n        \\n        for(int i=n-1; i>=0; i--){\\n            while(!st.empty() && heights[st.top()] >= heights[i]) st.pop();\\n            if(st.empty()) right[i] = n-1;\\n            else right[i] = st.top() - 1;\\n            st.push(i);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n            ans = max(ans, heights[i]*(right[i]-left[i]+1));\\n         \\n        return ans;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size(), ans = 0, left[n], right[n];\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!st.empty() && heights[st.top()] >= heights[i]) st.pop();\\n            if(st.empty()) left[i]=0;\\n            else left[i] = st.top() + 1;\\n            st.push(i);\\n        }\\n        \\n        while(!st.empty()) st.pop();\\n        \\n        for(int i=n-1; i>=0; i--){\\n            while(!st.empty() && heights[st.top()] >= heights[i]) st.pop();\\n            if(st.empty()) right[i] = n-1;\\n            else right[i] = st.top() - 1;\\n            st.push(i);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n            ans = max(ans, heights[i]*(right[i]-left[i]+1));\\n         \\n        return ans;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862695,
                "title": "java-clean-code-o-n-solution-using-stack-data-structure",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        \\n        int maximumRectangle = 0;\\n        Stack<Integer> stack = new Stack<> ();\\n        \\n        for (int i = 0; i <= heights.length; i++) {\\n            while (!stack.isEmpty () && (i == heights.length || heights[stack.peek ()] > heights[i])) {\\n                int length = heights[stack.pop ()];\\n                int width = stack.isEmpty () ? i : i - stack.peek () - 1;\\n                maximumRectangle = Math.max (maximumRectangle, length * width);\\n            }\\n            \\n            stack.push (i);\\n        }\\n        \\n        return maximumRectangle;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        \\n        int maximumRectangle = 0;\\n        Stack<Integer> stack = new Stack<> ();\\n        \\n        for (int i = 0; i <= heights.length; i++) {\\n            while (!stack.isEmpty () && (i == heights.length || heights[stack.peek ()] > heights[i])) {\\n                int length = heights[stack.pop ()];\\n                int width = stack.isEmpty () ? i : i - stack.peek () - 1;\\n                maximumRectangle = Math.max (maximumRectangle, length * width);\\n            }\\n            \\n            stack.push (i);\\n        }\\n        \\n        return maximumRectangle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801731,
                "title": "faster-than-88-25-easy-understanding-c-stack",
                "content": "\\n      class Solution {\\n            public:\\n                int largestRectangleArea(vector<int>& heights) {\\n                    stack<int> s;\\n                    int maxArea = 0;\\n                    int area = 0;\\n                    int i;\\n                    for(i=0; i < heights.size();){\\n                        if(s.empty() || heights[s.top()] <= heights[i]){\\n                            s.push(i++);\\n                        }else{\\n                            int top = s.top();\\n                            s.pop();      \\n                            //if stack is empty means everything till i has to be\\n                            //greater or equal to heights[top] so get area by\\n                            //heights[top] * i;\\n                            if(s.empty()){\\n                                area = heights[top] * i;\\n                            }\\n                            //if stack is not empty then everythin from i-1 to   heights.top() + 1\\n                            //has to be greater or equal to heights[top]\\n                            //so area = heights[top]*(i - stack.top() - 1);\\n                            else{\\n                                area = heights[top] * (i - s.top() - 1);\\n                            }\\n                            if(area > maxArea){\\n                                maxArea = area;\\n                            }\\n                        }\\n                    }\\n                    while(!s.empty()){\\n                        int top = s.top();\\n                        s.pop();\\n                        //if stack is empty means everything till i has to be\\n                        //greater or equal to heights[top] so get area by\\n                        //heights[top] * i;\\n                        if(s.empty()){\\n                            area = heights[top] * i;\\n                        }\\n                        //if stack is not empty then everything from i-1 to       height.top() + 1\\n                        //has to be greater or equal to heights[top]\\n                        //so area = heights[top]*(i - stack.top() - 1);\\n                        else{\\n                            area = heights[top] * (i - s.top() - 1);\\n                        }\\n                    if(area > maxArea){\\n                            maxArea = area;\\n                        }\\n                    }\\n                    return maxArea;\\n                }\\n            };\\n\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n            public:\\n                int largestRectangleArea(vector<int>& heights) {\\n                    stack<int> s;\\n                    int maxArea = 0;\\n                    int area = 0;\\n                    int i;\\n                    for(i=0; i < heights.size();){\\n                        if(s.empty() || heights[s.top()] <= heights[i]){\\n                            s.push(i++);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 510500,
                "title": "python-using-stack",
                "content": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        ans = 0\\n        stack = []\\n        heights = [0] + heights + [0]\\n        for i in range(len(heights)):\\n            while(stack and heights[stack[-1]] > heights[i]):\\n                j = stack.pop()\\n                ans = max(ans, (i-stack[-1]-1)*heights[j])\\n            stack.append(i)\\n        return ans\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        ans = 0\\n        stack = []\\n        heights = [0] + heights + [0]\\n        for i in range(len(heights)):\\n            while(stack and heights[stack[-1]] > heights[i]):\\n                j = stack.pop()\\n                ans = max(ans, (i-stack[-1]-1)*heights[j])\\n            stack.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192288,
                "title": "c-stack-solution-next-smaller-to-left-right",
                "content": "\\t// find the index vector for next smaller to left\\n\\t// find the index vector for next smaller to right \\n\\t// width will be right[i]-left[i]-1 \\n\\t// here stack<pair<int,int>> first element in pair denotes height[i] and \\n\\t// second element of pair corresponds to index i \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t// next smaller to left --> traverse from left \\n\\t\\t// here we will assume that one building is at index -1 of 0 height\\n\\t\\tvector<int>NSL(vector<int>h)\\n\\t\\t{\\n\\t\\t\\tvector<int>left;\\n\\t\\t\\tstack<pair<int,int>>st;\\n\\t\\t\\tint pseudo=-1; \\n\\t\\t\\tfor(int i=0;i<h.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.empty())\\n\\t\\t\\t\\t   left.push_back(pseudo);\\n\\n\\t\\t\\t\\telse if(st.size()>0 && st.top().first<h[i])\\n\\t\\t\\t\\t\\tleft.push_back(st.top().second);\\n\\n\\t\\t\\t\\telse if(st.size()>0 && st.top().first>=h[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile(st.size()>0 && st.top().first>=h[i])\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tif(st.empty())\\n\\t\\t\\t\\t\\t\\tleft.push_back(pseudo);\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tleft.push_back(st.top().second);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push({h[i],i});\\n\\t\\t\\t}\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\n\\t\\t// next smaller to right traverse --> from right \\n\\t\\t// here we will assume that one building is after lastmost index of 0 height\\n\\t\\tvector<int>NSR(vector<int>h)\\n\\t\\t{\\n\\t\\t\\tvector<int>right;\\n\\t\\t\\tstack<pair<int,int>>st;\\n\\t\\t\\tint pseudo=h.size(); \\n\\t\\t\\tfor(int i=h.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.empty())\\n\\t\\t\\t\\t   right.push_back(pseudo);\\n\\t\\t\\t\\telse if(st.size()>0 && st.top().first<h[i])\\n\\t\\t\\t\\t\\tright.push_back(st.top().second);\\n\\t\\t\\t\\telse if(st.size()>0 && st.top().first>=h[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile(st.size()>0 && st.top().first>=h[i])\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tif(st.empty())\\n\\t\\t\\t\\t\\t\\tright.push_back(pseudo);\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tright.push_back(st.top().second);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push({h[i],i});\\n\\t\\t\\t}\\n\\t\\t\\treturn right;\\n\\t\\t}\\n\\n\\t\\tint largestRectangleArea(vector<int>& heights) {\\n\\t\\t\\tvector<int>left=NSL(heights);\\n\\t\\t\\tvector<int>right=NSR(heights);\\n\\t\\t\\tvector<int>width;\\n\\t\\t\\treverse(right.begin(),right.end()); // reversing to get the correct order of next smaller to right\\n\\n\\t\\t\\tint maxarea=-1;\\n\\t\\t\\tfor(int i=0;i<heights.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint width=right[i]-left[i]-1;\\n\\t\\t\\t\\tmaxarea=max(maxarea,width*heights[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn maxarea;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t// next smaller to left --> traverse from left \\n\\t\\t// here we will assume that one building is at index -1 of 0 height\\n\\t\\tvector<int>NSL(vector<int>h)\\n\\t\\t{\\n\\t\\t\\tvector<int>left;\\n\\t\\t\\tstack<pair<int,int>>st;\\n\\t\\t\\tint pseudo=-1; \\n\\t\\t\\tfor(int i=0;i<h.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.empty())\\n\\t\\t\\t\\t   left.push_back(pseudo);\\n\\n\\t\\t\\t\\telse if(st.size()>0 && st.top().first<h[i])\\n\\t\\t\\t\\t\\tleft.push_back(st.top().second);\\n\\n\\t\\t\\t\\telse if(st.size()>0 && st.top().first>=h[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile(st.size()>0 && st.top().first>=h[i])\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tif(st.empty())\\n\\t\\t\\t\\t\\t\\tleft.push_back(pseudo);\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tleft.push_back(st.top().second);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 225556,
                "title": "java-solution-with-explanations-in-chinese",
                "content": "S1:\\u53CC\\u91CD\\u904D\\u5386\\u6CD5\\n\\n\\u672C\\u9898\\u8981\\u6C42\\u7684\\u662F\\u4E00\\u6BB5\\u8FDE\\u7EED\\u7684\\u77E9\\u5F62\\uFF0C\\u80FD\\u591F\\u7EC4\\u6210\\u7684\\u9762\\u79EF\\u6700\\u5927\\u7684\\u77E9\\u5F62\\u7684\\u9762\\u79EF\\uFF0C\\u6240\\u4EE5\\uFF0C\\u53EA\\u8981\\u80FD\\u591F\\u6C42\\u51FA\\u8FD9\\u4E00\\u6BB5\\u77E9\\u5F62\\u7684\\u4F4D\\u7F6E\\u7684\\u5C31\\u53EF\\u4EE5\\u4E86\\u3002\\u6700\\u7B80\\u5355\\u7684\\u60F3\\u6CD5\\uFF0C\\u5C06\\u6240\\u6709\\u7684\\u53EF\\u80FD\\u7684\\u7EC4\\u5408\\u90FD\\u6C42\\u89E3\\u4E00\\u904D\\uFF0C\\u6BD4\\u8F83\\u4E4B\\u540E\\u4FDD\\u7559\\u6700\\u5927\\u7684\\u90A3\\u4E00\\u4E2A\\u5C31\\u597D\\u4E86\\uFF0C\\u5982\\u4E0B\\uFF1A\\n\\n    public static int largestRectangleArea(int[] heights) {\\n        int max = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            int min = heights[i];\\n            for (int j = i; j >= 0; j--) {\\n                if (heights[j] < min) {\\n                    min = heights[j];\\n                }\\n                max = Math.max(max, min * (i-j+1));\\n            }\\n        }\\n        return max;\\n    }\\n\\n\\u901A\\u8FC7\\u4E00\\u4E2A\\u53CC\\u91CD\\u904D\\u5386\\uFF0C\\u5916\\u5C42\\u904D\\u5386\\u77E9\\u5F62\\u7684\\u7ED3\\u675F\\u5730\\u5740\\uFF0C\\u5185\\u5C42\\u904D\\u5386\\u77E9\\u5F62\\u8D77\\u59CB\\u5730\\u5740\\uFF0C\\u901A\\u8FC7\\u6C42\\u7B97\\u6BCF\\u4E00\\u4E2A\\u7EC4\\u5408\\u7684\\u6700\\u5927\\u7EC4\\u6210\\u9762\\u79EF\\u6C42\\u89E3\\u3002\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(n^2)\\u3002\\n\\nS2:\\u5206\\u6CBB\\u6CD5\\n\\n\\u4E0A\\u9762\\u7684\\u65B9\\u6CD5\\u6211\\u4EEC\\u662F\\u4F9D\\u636E\\u77E9\\u5F62\\u7684\\u8D77\\u59CB\\u3001\\u7ED3\\u675F\\u4F4D\\u7F6E\\u8FDB\\u884C\\u5206\\u7C7B\\u3001\\u6C42\\u7B97\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u8FD8\\u53EF\\u4EE5\\u4F7F\\u7528\\u53E6\\u4E00\\u79CD\\u65B9\\u6CD5\\u6C42\\u7B97\\uFF1A\\u6309\\u7167\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u4ECE\\u4F4E\\u5230\\u9AD8\\u6C42\\u89E3\\uFF0C\\u7136\\u540E\\u53D6\\u6700\\u5927\\u3002\\u6211\\u4EEC\\u77E5\\u9053\\uFF0C\\u5728\\u7ED9\\u5B9A\\u7684\\u4E00\\u7EC4\\u77E9\\u9635\\u4E2D\\uFF0C\\u5982\\u679C\\u53D6\\u9AD8\\u5EA6\\u4E3A\\u6700\\u4F4E\\u7684\\u90A3\\u4E00\\u4E2A\\uFF0C\\u90A3\\u4E48\\u5BBD\\u5EA6\\u5FC5\\u7136\\u53EF\\u53D6\\u6570\\u7EC4\\u7684\\u957F\\u5EA6\\u3002\\u5982\\uFF0C\\u7ED9\\u5B9A\\u7684\\u4E00\\u4E2A\\u6570\\u7EC4[2,1,2]\\uFF0C\\u90A3\\u4E48\\u5F53\\u6211\\u4EEC\\u53D6\\u9AD8\\u5EA6\\u4E3A 1 \\uFF0C\\u90A3\\u4E48\\u5BBD\\u5EA6\\u5FC5\\u7136\\u53EF\\u53D6 3 \\u3002\\u6B64\\u65F6\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u9762\\u79EF\\u662F 3 \\u3002\\u8FD9\\u65F6\\uFF0C\\u7EC4\\u5408\\u77E9\\u9635\\u53D6\\u5F97\\u662F\\u6700\\u4F4E\\u9AD8\\u5EA6 1 \\u3002\\u90A3\\u4E48\\u63A5\\u4E0B\\u6765\\uFF0C\\u5982\\u679C\\u53D6\\u4E00\\u4E2A\\u66F4\\u9AD8\\u7684\\u9AD8\\u5EA6\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A\\u9AD8\\u5EA6\\u4E3A 1 \\u7684\\u5C0F\\u77E9\\u9635\\u5FC5\\u7136\\u4E0D\\u4F1A\\u5305\\u542B\\u5728\\u5185\\uFF0C\\u6240\\u4EE5\\u4E0B\\u4E00\\u6B65\\u8981\\u7EC4\\u6210\\u7684\\u77E9\\u9635\\u5FC5\\u7136\\u5728\\u8FD9\\u4E2A 1 \\u7684\\u5DE6\\u8FB9\\u6216\\u8005\\u53F3\\u8FB9\\uFF0C\\u8FD9\\u6837\\u4E00\\u6765\\uFF0C\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u770B\\u4F5C\\uFF0C\\u8FD9\\u4E2A\\u9AD8\\u5EA6\\u4E3A 1 \\u7684\\u5C0F\\u77E9\\u9635\\u5C06\\u6574\\u4E2A\\u77E9\\u9635\\u5E8F\\u5217\\u5206\\u5272\\u6210\\u4E86\\u4E24\\u90E8\\u5206\\uFF0C\\u6211\\u4EEC\\u4E0B\\u4E00\\u6B65\\u8981\\u5224\\u65AD\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u5C31\\u5728\\u5DE6\\u90E8\\u6216\\u8005\\u53F3\\u90E8\\uFF0C\\u5982\\u6B64\\u4E00\\u4E0B\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u6C42\\u5DE6\\u53F3\\u4E24\\u90E8\\u4E2D\\u80FD\\u591F\\u7EC4\\u6210\\u7684\\u6700\\u5927\\u9762\\u79EF\\u5C31\\u597D\\u4E86\\uFF0C\\u4E8E\\u662F\\uFF0C\\u4E00\\u4E2A\\u6570\\u7EC4[2,1,2]\\u88AB\\u6700\\u5C0F\\u503C1\\u5206\\u5272\\u6210\\u4E86\\u4E24\\u4E2A\\u6570\\u7EC4[2]\\u548C[2]\\uFF0C\\u5982\\u6B64\\u4E00\\u6765\\uFF0C\\u6C42[2,1,2]\\u7684\\u89E3\\u7684\\u95EE\\u9898\\u53D8\\u6210\\u4E86\\u6C42[2]\\u7684\\u89E3\\uFF0C\\u800C[2]\\u7684\\u89E3\\u53EA\\u6709\\u4E00\\u4E2A 2 \\uFF0C\\u4EE5\\u6B64\\u7C7B\\u63A8\\uFF0C\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u5C06\\u4EFB\\u610F\\u4E00\\u4E2A\\u5927\\u7684\\u95EE\\u9898\\u5206\\u89E3\\u6210\\u82E5\\u5E72\\u4E2A\\u5C0F\\u7684\\u95EE\\u9898\\uFF0C\\u7136\\u540E\\u5728\\u8FD9\\u51E0\\u4E2A\\u5C0F\\u95EE\\u9898\\u4E2D\\u6C42\\u6700\\u5927\\u503C\\u5373\\u53EF\\u3002\\n\\n\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n    public static int largestRectangleArea2(int[] heights) {\\n        return largest(heights, 0, heights.length-1);\\n    }\\n    public static int largest(int[] heights, int start, int end) {\\n        if (start > end) return 0;\\n        if (start == end) return heights[start];\\n        boolean sorted = true;\\n        int min = start;\\n        for (int i = start+1; i <= end; i++) {\\n            if (heights[i] < heights[i-1]) sorted = false;\\n            if (heights[i] < heights[min]) min = i;\\n        }\\n        if (sorted) {\\n            int max = heights[start] * (end - start + 1);\\n            for (int i = start+1; i <= end; i++) {\\n                max = Math.max(max, heights[i] * (end - i + 1));\\n            }\\n            return max;\\n        }\\n        return Math.max(Math.max(largest(heights, start, min-1), largest(heights, min+1, end)),\\n                heights[min] * (end - start + 1));\\n    }\\n\\n\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u6570\\u7EC4\\u800C\\u8A00\\uFF0C\\u53EF\\u80FD\\u6210\\u4E3A\\u6700\\u5927\\u503C\\u7684\\u89E3\\u6709\\u4E09\\u4E2A\\uFF1A\\n\\n1.  \\u6700\\u5C0F\\u503C\\u5DE6\\u90E8\\u7684\\u67D0\\u4E2A\\u89E3\\n2.  \\u6700\\u5C0F\\u503C\\u53F3\\u90E8\\u7684\\u67D0\\u4E2A\\u89E3\\n3.  \\u5305\\u542B\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\u7684\\u89E3\\n\\n\\u53E6\\u5916\\uFF0C\\u4E0A\\u9762\\u7684\\u65B9\\u6CD5\\u4E2D\\uFF0C\\u901A\\u8FC7\\u5224\\u65AD\\u5F53\\u524D\\u7684\\u5B50\\u6570\\u7EC4\\u662F\\u5426\\u662F\\u4E00\\u4E2A\\u6709\\u5E8F\\u6570\\u7EC4\\uFF0C\\u6765\\u7B80\\u5316\\u8FD9\\u4E2A\\u6570\\u7EC4\\u7684\\u5224\\u65AD\\uFF0C\\u4E0A\\u9762\\u4EC5\\u5224\\u65AD\\u4E86\\u7531\\u5C0F\\u5230\\u5927\\u7684\\u987A\\u5E8F\\uFF0C\\u8FD8\\u53EF\\u4EE5\\u901A\\u8FC7\\u5224\\u65AD\\u662F\\u5426\\u662F\\u4E00\\u4E2A\\u7531\\u5927\\u5230\\u5C0F\\u7684\\u987A\\u5E8F\\u8FDB\\u4E00\\u6B65\\u63D0\\u9AD8\\u5224\\u65AD\\u6548\\u7387\\u3002\\u6B64\\u7B97\\u6CD5\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(n\\\\log n)\\u3002\\n\\nS3:\\u5229\\u7528\\u6808\\n\\n\\u7B2C\\u4E00\\u79CD\\u65B9\\u6CD5\\u7684\\u5916\\u5C42\\u904D\\u5386\\uFF0C\\u662F\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u7ED3\\u675F\\u4F4D\\u7F6E\\uFF0C\\u7136\\u540E\\u5728\\u5185\\u5C42\\u9010\\u4E2A\\u904D\\u5386\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u5F00\\u59CB\\u4F4D\\u7F6E\\u3002\\u901A\\u8FC7\\u5BF9\\u8FD9\\u6837\\u4E00\\u4E2A\\u6A21\\u578B\\u7684\\u5206\\u6790\\uFF0C\\u5BF9\\u4E8E\\u4EE5\\u4F4D\\u7F6E i \\u7ED3\\u675F\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u6765\\u8BF4\\uFF0C\\u5B83\\u4E0E\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E4B\\u524D\\u7684\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u6709\\u4E00\\u5B9A\\u5173\\u7CFB\\uFF1A\\n\\n1.  \\u5982\\u679C i \\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\u5927\\u4E8E i-1 \\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\uFF0C\\u5219\\u5728\\u4E0E\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E4B\\u524D\\u7684\\u77E9\\u9635\\u7684\\u7EC4\\u5408\\u4E2D\\uFF0C\\u4E0D\\u80FD\\u4EE5\\u5F53\\u524D\\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\u4F5C\\u4E3A\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u3002\\u5982\\u6570\\u7EC4[1,2]\\uFF0C\\u90A3\\u4E48\\u5BF9\\u4E8E\\u4F4D\\u7F6E 2 \\u6765\\u8BF4\\uFF0C\\u8FD9\\u4E24\\u4E2A\\u4F4D\\u7F6E\\u7684\\u7EC4\\u5408\\u4E0D\\u80FD\\u4EE5 2 \\u4F5C\\u4E3A\\u7EC4\\u5408\\u77E9\\u9635\\u9AD8\\u5EA6\\u3002\\n2.  \\u5982\\u679C i \\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\u4E0D\\u5927\\u4E8E i-1 \\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\uFF0C\\u5219\\u5B58\\u5728\\u9AD8\\u5EA6\\u4E3A\\u5F53\\u524D\\u9AD8\\u5EA6\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u3002\\u5982\\u6570\\u7EC4[2\\uFF0C1]\\uFF0C\\u5BF9\\u4E8E\\u4F4D\\u7F6E 1 \\uFF0C\\u6709\\u4E00\\u79CD\\u7EC4\\u5408\\u65B9\\u6CD5[1,1]\\uFF0C\\u6240\\u4EE5\\u5728\\u8FD9\\u79CD\\u60C5\\u51B5\\u4E0B\\u5E94\\u8BE5\\u5224\\u65AD\\u4E00\\u4E0B\\u3002\\n\\n\\u53E6\\u5916\\uFF0C\\u6211\\u4EEC\\u77E5\\u9053\\uFF0C\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u9AD8\\u5EA6\\u9012\\u589E\\u7684\\u6570\\u7EC4\\u6765\\u8BF4\\uFF0C\\u5F88\\u5BB9\\u6613\\u6C42\\u51FA\\u5176\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u6700\\u5927\\u9762\\u79EF\\uFF0C\\u90A3\\u4E48\\u662F\\u5426\\u53EF\\u4EE5\\u5C06\\u4EFB\\u610F\\u4E00\\u4E2A\\u77E9\\u9635\\u8F6C\\u5316\\u4E3A\\u4E00\\u4E2A\\u9AD8\\u5EA6\\u9012\\u589E\\u7684\\u77E9\\u9635\\u5E8F\\u5217\\uFF1F\\u5982\\u5C06\\u4E00\\u4E2A\\u6570\\u7EC4[2,3,1,3,5]\\u53D8\\u6210[1,1,1,3,5]\\uFF0C\\u4F46\\u662F\\u8FD9\\u4E2A\\u8FC7\\u7A0B\\u4E2D\\u5BF9 2 \\u4F5C\\u4E86\\u6539\\u53D8\\uFF0C\\u6211\\u4EEC\\u8981\\u901A\\u8FC7\\u4E00\\u5B9A\\u529E\\u6CD5\\u5F25\\u8865\\u8FD9\\u91CC\\u7684\\u6539\\u53D8\\uFF0C\\u4E00\\u79CD\\u65B9\\u6CD5\\u662F\\uFF0C\\u5728\\u4F5C\\u6539\\u53D8\\u524D\\uFF0C\\u5C06\\u5176\\u80FD\\u591F\\u7EC4\\u6210\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u6700\\u5927\\u9762\\u79EF\\u8BB0\\u5F55\\u4E0B\\u6765\\uFF0C\\u5B8C\\u4E86\\u4E4B\\u540E\\u4FBF\\u53EF\\u4EE5\\u5BF9\\u5176\\u505A\\u51FA\\u6539\\u53D8\\u4E86\\u3002\\u5BF9\\u4E8E\\u4E0A\\u9762\\u90A3\\u4E2A\\u4F8B\\u5B50\\uFF0C\\u5B9E\\u9645\\u4E0A\\u6211\\u4EEC\\u662F\\u5BF9\\u4E24\\u4E2A\\u9012\\u589E\\u7684\\u6570\\u7EC4\\u6C42\\u89E3\\uFF1A[2,3]\\u548C[1,1,1,3,5]\\uFF0C\\u800C\\u5B83\\u4EEC\\u4E4B\\u95F4\\u7684\\u6700\\u5927\\u89E3\\u5FC5\\u7136\\u4E0E[2,3,1,3,5]\\u7684\\u89E3\\u76F8\\u540C\\u3002\\u4E8E\\u662F\\uFF0C\\u5C06\\u4E00\\u4E2A\\u4E0D\\u89C4\\u5219\\u6570\\u7EC4\\u8F6C\\u5316\\u4E3A\\u82E5\\u5E72\\u6709\\u5E8F\\u6570\\u7EC4\\uFF0C\\u518D\\u8FDB\\u884C\\u6C42\\u89E3\\uFF0C\\u4FBF\\u662F\\u672C\\u65B9\\u6CD5\\u7684\\u601D\\u60F3\\u3002\\n\\n\\u4E0B\\u9762\\u662F\\u5229\\u7528\\u6808\\u7684\\u4E00\\u79CD\\u5B9E\\u73B0\\uFF0C\\u5229\\u7528\\u6808\\u7684\\u8BDD\\u4E0D\\u9700\\u8981\\u5BF9\\u539F\\u6570\\u636E\\u8FDB\\u884C\\u4FEE\\u6539\\uFF0C\\u800C\\u662F\\u76F4\\u63A5\\u5C06\\u539F\\u6570\\u7EC4\\u622A\\u53D6\\u6210\\u591A\\u4E2A\\u6709\\u5E8F\\u6570\\u7EC4\\uFF0C\\u901A\\u8FC7\\u4FDD\\u5B58\\u7D22\\u5F15\\u503C\\u786E\\u5B9A\\u5F53\\u524D\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u5BBD\\u5EA6\\uFF1A\\n\\n    public static int largestRectangleArea3(int[] heights) {\\n        Stack<Integer> stack = new Stack<>();\\n        int n = heights.length;\\n        int max = 0;\\n        for (int i = 0; i <= n; i++) {\\n            while (!stack.empty() && (i >= n || heights[stack.peek()] > heights[i])) {\\n                int top = stack.pop();\\n                int h = heights[top];\\n                int w = stack.empty() ? i : (i-stack.peek()-1);\\n                max = Math.max(max, h*w);\\n            }\\n            stack.push(i);\\n        }\\n        return max;\\n    }\\n\\nS4:\\u6700\\u957F\\u5BBD\\u5EA6\\u6CD5\\n\\n\\u6211\\u4EEC\\u77E5\\u9053\\uFF0C\\u7531\\u591A\\u4E2A\\u77E9\\u9635\\u7EC4\\u6210\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\uFF0C\\u5176\\u5BBD\\u5EA6\\u4E3A\\u77E9\\u9635\\u7684\\u6570\\u91CF\\uFF0C\\u9AD8\\u5EA6\\u4E3A\\u77E9\\u9635\\u4E2D\\u9AD8\\u5EA6\\u6700\\u4F4E\\u7684\\u90A3\\u4E00\\u4E2A\\u3002\\u6240\\u4EE5\\uFF0C\\u5BF9\\u4E8E\\u4EFB\\u610F\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u7684\\u77E9\\u9635\\uFF0C\\u5047\\u8BBE\\u6B64\\u65F6\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u9AD8\\u5EA6\\u4E3A\\u5F53\\u524D\\u4F4D\\u7F6E\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u6C42\\u51FA\\u8FD9\\u65F6\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u6700\\u5927\\u5BBD\\u5EA6\\uFF0C\\u4FBF\\u53EF\\u4EE5\\u6C42\\u51FA\\u4EE5\\u5F53\\u524D\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u4E3A\\u9AD8\\u5EA6\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u6700\\u5927\\u9762\\u79EF\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u6C42\\u51FA\\u6BCF\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u80FD\\u591F\\u5F62\\u6210\\u7684\\u6700\\u5927\\u89E3\\uFF0C\\u4FBF\\u80FD\\u591F\\u5F97\\u5230\\u672C\\u9898\\u7684\\u89E3\\u3002\\n\\n\\u8981\\u6C42\\u51FA\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u7684\\u6700\\u5927\\u89E3\\uFF0C\\u5982 i \\uFF0C\\u53EF\\u4EE5\\u8FD9\\u6837\\u7406\\u89E3\\uFF0C\\u4ECE\\u6570\\u7EC4[0,...,n]\\u4E2D\\u627E\\u5230\\u6700\\u5927\\u7684\\u4E00\\u6BB5[start,...,i,...end]\\uFF0C\\u5E76\\u4E14\\u5728\\u8FD9\\u6BB5\\u4E2D\\uFF0C\\u4F4D\\u7F6E i \\u5904\\u7684\\u9AD8\\u5EA6\\u6700\\u4F4E\\uFF0C\\u90A3\\u4E48\\u6B64\\u65F6\\u8FD9\\u6BB5\\u77E9\\u9635\\u7EC4\\u6210\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u9762\\u79EF\\u5FC5\\u7136\\u662F(end-start) * heights[i]\\u3002\\u6240\\u4EE5\\u6211\\u4EEC\\u8981\\u5728\\u4F4D\\u7F6E i \\u7684\\u5DE6\\u8FB9\\u627E\\u5230\\u4E00\\u6BB5[start,...,i]\\uFF0C\\u662F\\u7684\\u8FD9\\u91CC\\u9762\\u6BCF\\u4E00\\u4E2A\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u90FD\\u5927\\u4E8E\\u7B49\\u4E8E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u540C\\u7406\\uFF0C\\u8FD8\\u8981\\u5728 i \\u7684\\u53F3\\u8FB9\\u627E\\u5230\\u4E00\\u6BB5[i,...end]\\uFF0C\\u627E\\u5230\\u8FD9\\u4E9B\\u4E4B\\u540E\\uFF0C\\u4F4D\\u7F6E i \\u5904\\u7684\\u89E3\\u5C31\\u53EF\\u4EE5\\u6C42\\u5F97\\u4E86\\u3002\\n\\n\\u6240\\u4EE5\\uFF0C\\u5BF9\\u4E8E\\u6BCF\\u4E00\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u53EA\\u8981\\u627E\\u5230\\u5728 i \\u7684\\u5DE6\\u8FB9\\u7B2C\\u4E00\\u4E2A\\u5C0F\\u4E8E i \\u5904\\u9AD8\\u5EA6\\u7684\\u4F4D\\u7F6E start \\uFF0C\\u518D\\u627E\\u5230 i \\u7684\\u53F3\\u8FB9\\u7B2C\\u4E00\\u4E2A\\u5C0F\\u4E8E i \\u5904\\u9AD8\\u5EA6\\u7684\\u4F4D\\u7F6E end \\u4FBF\\u53EF\\u3002\\u800C\\u8FD9\\u4E2A\\u6570\\u636E\\u53EF\\u4EE5\\u901A\\u8FC7\\u4E24\\u4E2A\\u904D\\u5386\\u6C42\\u89E3\\u3002\\n\\n    public static int largestRectangleArea4(int[] heights) {\\n        int n = heights.length;\\n        if (n == 0) return 0;\\n        int[] leftLess = new int[n], rightLess = new int[n];\\n        // find left\\n        leftLess[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            int p = i-1;\\n            while (true) {\\n                if (p >= 0 && heights[i] <= heights[p]) {\\n                    p -= leftLess[p] + 1;\\n                } else {\\n                    leftLess[i] = i - p - 1;\\n                    break;\\n                }\\n            }\\n        }\\n        // find right\\n        rightLess[n-1] = 0;\\n        for (int i = n-2; i >= 0; i--) {\\n            int p = i+1;\\n            while (true) {\\n                if (p < n && heights[i] <= heights[p]) {\\n                    p += rightLess[p] + 1;\\n                } else {\\n                    rightLess[i] = p - 1 - i;\\n                    break;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, heights[i] * (leftLess[i] + rightLess[i] + 1));\\n        }\\n        return max;\\n    }\\n\\n\\u4F7F\\u7528\\u4E00\\u4E2A\\u6570\\u7EC4 leftLess \\u4FDD\\u5B58\\u6BCF\\u4E2A\\u4F4D\\u7F6E\\u7684\\u5DE6\\u8FB9\\u9AD8\\u5EA6\\u5927\\u4E8E\\u5F53\\u524D\\u4F4D\\u7F6E\\u9AD8\\u5EA6\\u7684\\u77E9\\u9635\\u6570\\u91CF\\uFF0CrightLess \\u540C\\u7406\\u3002\\u5177\\u4F53\\u7684\\u6C42\\u89E3\\u65B9\\u6CD5\\u4E3A\\uFF1A\\u5BF9\\u4E8E\\u4F4D\\u7F6E i \\uFF0C\\u5982\\u679C i-1 \\u5904\\u7684\\u9AD8\\u5EA6\\u5927\\u4E8E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u90A3\\u4E48\\u56E0\\u4E3AleftLess[i-1]\\u4FDD\\u5B58\\u7684\\u662F\\u5927\\u4E8E\\u4F4D\\u7F6E i-1 \\u5904\\u9AD8\\u5EA6\\u7684\\u6570\\u91CF\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E9B\\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\u5FC5\\u7136\\u4E5F\\u5927\\u4E8E\\u4F4D\\u7F6E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u6240\\u4EE5\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u76F4\\u63A5\\u8DF3\\u8FC71 + leftLess[i-1]\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u5224\\u65AD\\u4E0B\\u4E00\\u4E2A\\u4F4D\\u7F6E p \\u5904\\u7684\\u9AD8\\u5EA6\\u662F\\u5426\\u5927\\u4E8E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u5982\\u679C\\u8FD8\\u662F\\u5927\\u4E8E\\uFF0C\\u90A3\\u4E48\\u8FD8\\u8981\\u7EE7\\u7EED\\u8DF3\\u8FC7leftLess[p] + 1\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u518D\\u5224\\u65AD......\\u76F4\\u5230 p \\u5904\\u7684\\u9AD8\\u5EA6\\u5C0F\\u4E8E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u6B64\\u65F6\\u5728 i \\u7684\\u5DE6\\u8FB9\\u6BD4 i \\u5904\\u9AD8\\u5EA6\\u5927\\u7684\\u77E9\\u9635\\u7684\\u6570\\u91CF\\u5C31\\u662Fi - p - 1\\u4E2A\\u3002\\u5BF9\\u4E8E rightLess \\u7684\\u6C42\\u89E3\\u540C\\u7406\\u3002\\n",
                "solutionTags": [],
                "code": "S1:\\u53CC\\u91CD\\u904D\\u5386\\u6CD5\\n\\n\\u672C\\u9898\\u8981\\u6C42\\u7684\\u662F\\u4E00\\u6BB5\\u8FDE\\u7EED\\u7684\\u77E9\\u5F62\\uFF0C\\u80FD\\u591F\\u7EC4\\u6210\\u7684\\u9762\\u79EF\\u6700\\u5927\\u7684\\u77E9\\u5F62\\u7684\\u9762\\u79EF\\uFF0C\\u6240\\u4EE5\\uFF0C\\u53EA\\u8981\\u80FD\\u591F\\u6C42\\u51FA\\u8FD9\\u4E00\\u6BB5\\u77E9\\u5F62\\u7684\\u4F4D\\u7F6E\\u7684\\u5C31\\u53EF\\u4EE5\\u4E86\\u3002\\u6700\\u7B80\\u5355\\u7684\\u60F3\\u6CD5\\uFF0C\\u5C06\\u6240\\u6709\\u7684\\u53EF\\u80FD\\u7684\\u7EC4\\u5408\\u90FD\\u6C42\\u89E3\\u4E00\\u904D\\uFF0C\\u6BD4\\u8F83\\u4E4B\\u540E\\u4FDD\\u7559\\u6700\\u5927\\u7684\\u90A3\\u4E00\\u4E2A\\u5C31\\u597D\\u4E86\\uFF0C\\u5982\\u4E0B\\uFF1A\\n\\n    public static int largestRectangleArea(int[] heights) {\\n        int max = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            int min = heights[i];\\n            for (int j = i; j >= 0; j--) {\\n                if (heights[j] < min) {\\n                    min = heights[j];\\n                }\\n                max = Math.max(max, min * (i-j+1));\\n            }\\n        }\\n        return max;\\n    }\\n\\n\\u901A\\u8FC7\\u4E00\\u4E2A\\u53CC\\u91CD\\u904D\\u5386\\uFF0C\\u5916\\u5C42\\u904D\\u5386\\u77E9\\u5F62\\u7684\\u7ED3\\u675F\\u5730\\u5740\\uFF0C\\u5185\\u5C42\\u904D\\u5386\\u77E9\\u5F62\\u8D77\\u59CB\\u5730\\u5740\\uFF0C\\u901A\\u8FC7\\u6C42\\u7B97\\u6BCF\\u4E00\\u4E2A\\u7EC4\\u5408\\u7684\\u6700\\u5927\\u7EC4\\u6210\\u9762\\u79EF\\u6C42\\u89E3\\u3002\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(n^2)\\u3002\\n\\nS2:\\u5206\\u6CBB\\u6CD5\\n\\n\\u4E0A\\u9762\\u7684\\u65B9\\u6CD5\\u6211\\u4EEC\\u662F\\u4F9D\\u636E\\u77E9\\u5F62\\u7684\\u8D77\\u59CB\\u3001\\u7ED3\\u675F\\u4F4D\\u7F6E\\u8FDB\\u884C\\u5206\\u7C7B\\u3001\\u6C42\\u7B97\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u8FD8\\u53EF\\u4EE5\\u4F7F\\u7528\\u53E6\\u4E00\\u79CD\\u65B9\\u6CD5\\u6C42\\u7B97\\uFF1A\\u6309\\u7167\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u4ECE\\u4F4E\\u5230\\u9AD8\\u6C42\\u89E3\\uFF0C\\u7136\\u540E\\u53D6\\u6700\\u5927\\u3002\\u6211\\u4EEC\\u77E5\\u9053\\uFF0C\\u5728\\u7ED9\\u5B9A\\u7684\\u4E00\\u7EC4\\u77E9\\u9635\\u4E2D\\uFF0C\\u5982\\u679C\\u53D6\\u9AD8\\u5EA6\\u4E3A\\u6700\\u4F4E\\u7684\\u90A3\\u4E00\\u4E2A\\uFF0C\\u90A3\\u4E48\\u5BBD\\u5EA6\\u5FC5\\u7136\\u53EF\\u53D6\\u6570\\u7EC4\\u7684\\u957F\\u5EA6\\u3002\\u5982\\uFF0C\\u7ED9\\u5B9A\\u7684\\u4E00\\u4E2A\\u6570\\u7EC4[2,1,2]\\uFF0C\\u90A3\\u4E48\\u5F53\\u6211\\u4EEC\\u53D6\\u9AD8\\u5EA6\\u4E3A 1 \\uFF0C\\u90A3\\u4E48\\u5BBD\\u5EA6\\u5FC5\\u7136\\u53EF\\u53D6 3 \\u3002\\u6B64\\u65F6\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u9762\\u79EF\\u662F 3 \\u3002\\u8FD9\\u65F6\\uFF0C\\u7EC4\\u5408\\u77E9\\u9635\\u53D6\\u5F97\\u662F\\u6700\\u4F4E\\u9AD8\\u5EA6 1 \\u3002\\u90A3\\u4E48\\u63A5\\u4E0B\\u6765\\uFF0C\\u5982\\u679C\\u53D6\\u4E00\\u4E2A\\u66F4\\u9AD8\\u7684\\u9AD8\\u5EA6\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A\\u9AD8\\u5EA6\\u4E3A 1 \\u7684\\u5C0F\\u77E9\\u9635\\u5FC5\\u7136\\u4E0D\\u4F1A\\u5305\\u542B\\u5728\\u5185\\uFF0C\\u6240\\u4EE5\\u4E0B\\u4E00\\u6B65\\u8981\\u7EC4\\u6210\\u7684\\u77E9\\u9635\\u5FC5\\u7136\\u5728\\u8FD9\\u4E2A 1 \\u7684\\u5DE6\\u8FB9\\u6216\\u8005\\u53F3\\u8FB9\\uFF0C\\u8FD9\\u6837\\u4E00\\u6765\\uFF0C\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u770B\\u4F5C\\uFF0C\\u8FD9\\u4E2A\\u9AD8\\u5EA6\\u4E3A 1 \\u7684\\u5C0F\\u77E9\\u9635\\u5C06\\u6574\\u4E2A\\u77E9\\u9635\\u5E8F\\u5217\\u5206\\u5272\\u6210\\u4E86\\u4E24\\u90E8\\u5206\\uFF0C\\u6211\\u4EEC\\u4E0B\\u4E00\\u6B65\\u8981\\u5224\\u65AD\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u5C31\\u5728\\u5DE6\\u90E8\\u6216\\u8005\\u53F3\\u90E8\\uFF0C\\u5982\\u6B64\\u4E00\\u4E0B\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u6C42\\u5DE6\\u53F3\\u4E24\\u90E8\\u4E2D\\u80FD\\u591F\\u7EC4\\u6210\\u7684\\u6700\\u5927\\u9762\\u79EF\\u5C31\\u597D\\u4E86\\uFF0C\\u4E8E\\u662F\\uFF0C\\u4E00\\u4E2A\\u6570\\u7EC4[2,1,2]\\u88AB\\u6700\\u5C0F\\u503C1\\u5206\\u5272\\u6210\\u4E86\\u4E24\\u4E2A\\u6570\\u7EC4[2]\\u548C[2]\\uFF0C\\u5982\\u6B64\\u4E00\\u6765\\uFF0C\\u6C42[2,1,2]\\u7684\\u89E3\\u7684\\u95EE\\u9898\\u53D8\\u6210\\u4E86\\u6C42[2]\\u7684\\u89E3\\uFF0C\\u800C[2]\\u7684\\u89E3\\u53EA\\u6709\\u4E00\\u4E2A 2 \\uFF0C\\u4EE5\\u6B64\\u7C7B\\u63A8\\uFF0C\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u5C06\\u4EFB\\u610F\\u4E00\\u4E2A\\u5927\\u7684\\u95EE\\u9898\\u5206\\u89E3\\u6210\\u82E5\\u5E72\\u4E2A\\u5C0F\\u7684\\u95EE\\u9898\\uFF0C\\u7136\\u540E\\u5728\\u8FD9\\u51E0\\u4E2A\\u5C0F\\u95EE\\u9898\\u4E2D\\u6C42\\u6700\\u5927\\u503C\\u5373\\u53EF\\u3002\\n\\n\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n    public static int largestRectangleArea2(int[] heights) {\\n        return largest(heights, 0, heights.length-1);\\n    }\\n    public static int largest(int[] heights, int start, int end) {\\n        if (start > end) return 0;\\n        if (start == end) return heights[start];\\n        boolean sorted = true;\\n        int min = start;\\n        for (int i = start+1; i <= end; i++) {\\n            if (heights[i] < heights[i-1]) sorted = false;\\n            if (heights[i] < heights[min]) min = i;\\n        }\\n        if (sorted) {\\n            int max = heights[start] * (end - start + 1);\\n            for (int i = start+1; i <= end; i++) {\\n                max = Math.max(max, heights[i] * (end - i + 1));\\n            }\\n            return max;\\n        }\\n        return Math.max(Math.max(largest(heights, start, min-1), largest(heights, min+1, end)),\\n                heights[min] * (end - start + 1));\\n    }\\n\\n\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u6570\\u7EC4\\u800C\\u8A00\\uFF0C\\u53EF\\u80FD\\u6210\\u4E3A\\u6700\\u5927\\u503C\\u7684\\u89E3\\u6709\\u4E09\\u4E2A\\uFF1A\\n\\n1.  \\u6700\\u5C0F\\u503C\\u5DE6\\u90E8\\u7684\\u67D0\\u4E2A\\u89E3\\n2.  \\u6700\\u5C0F\\u503C\\u53F3\\u90E8\\u7684\\u67D0\\u4E2A\\u89E3\\n3.  \\u5305\\u542B\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\u7684\\u89E3\\n\\n\\u53E6\\u5916\\uFF0C\\u4E0A\\u9762\\u7684\\u65B9\\u6CD5\\u4E2D\\uFF0C\\u901A\\u8FC7\\u5224\\u65AD\\u5F53\\u524D\\u7684\\u5B50\\u6570\\u7EC4\\u662F\\u5426\\u662F\\u4E00\\u4E2A\\u6709\\u5E8F\\u6570\\u7EC4\\uFF0C\\u6765\\u7B80\\u5316\\u8FD9\\u4E2A\\u6570\\u7EC4\\u7684\\u5224\\u65AD\\uFF0C\\u4E0A\\u9762\\u4EC5\\u5224\\u65AD\\u4E86\\u7531\\u5C0F\\u5230\\u5927\\u7684\\u987A\\u5E8F\\uFF0C\\u8FD8\\u53EF\\u4EE5\\u901A\\u8FC7\\u5224\\u65AD\\u662F\\u5426\\u662F\\u4E00\\u4E2A\\u7531\\u5927\\u5230\\u5C0F\\u7684\\u987A\\u5E8F\\u8FDB\\u4E00\\u6B65\\u63D0\\u9AD8\\u5224\\u65AD\\u6548\\u7387\\u3002\\u6B64\\u7B97\\u6CD5\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(n\\\\log n)\\u3002\\n\\nS3:\\u5229\\u7528\\u6808\\n\\n\\u7B2C\\u4E00\\u79CD\\u65B9\\u6CD5\\u7684\\u5916\\u5C42\\u904D\\u5386\\uFF0C\\u662F\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u7ED3\\u675F\\u4F4D\\u7F6E\\uFF0C\\u7136\\u540E\\u5728\\u5185\\u5C42\\u9010\\u4E2A\\u904D\\u5386\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u5F00\\u59CB\\u4F4D\\u7F6E\\u3002\\u901A\\u8FC7\\u5BF9\\u8FD9\\u6837\\u4E00\\u4E2A\\u6A21\\u578B\\u7684\\u5206\\u6790\\uFF0C\\u5BF9\\u4E8E\\u4EE5\\u4F4D\\u7F6E i \\u7ED3\\u675F\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u6765\\u8BF4\\uFF0C\\u5B83\\u4E0E\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E4B\\u524D\\u7684\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u6709\\u4E00\\u5B9A\\u5173\\u7CFB\\uFF1A\\n\\n1.  \\u5982\\u679C i \\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\u5927\\u4E8E i-1 \\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\uFF0C\\u5219\\u5728\\u4E0E\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E4B\\u524D\\u7684\\u77E9\\u9635\\u7684\\u7EC4\\u5408\\u4E2D\\uFF0C\\u4E0D\\u80FD\\u4EE5\\u5F53\\u524D\\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\u4F5C\\u4E3A\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u3002\\u5982\\u6570\\u7EC4[1,2]\\uFF0C\\u90A3\\u4E48\\u5BF9\\u4E8E\\u4F4D\\u7F6E 2 \\u6765\\u8BF4\\uFF0C\\u8FD9\\u4E24\\u4E2A\\u4F4D\\u7F6E\\u7684\\u7EC4\\u5408\\u4E0D\\u80FD\\u4EE5 2 \\u4F5C\\u4E3A\\u7EC4\\u5408\\u77E9\\u9635\\u9AD8\\u5EA6\\u3002\\n2.  \\u5982\\u679C i \\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\u4E0D\\u5927\\u4E8E i-1 \\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\uFF0C\\u5219\\u5B58\\u5728\\u9AD8\\u5EA6\\u4E3A\\u5F53\\u524D\\u9AD8\\u5EA6\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u3002\\u5982\\u6570\\u7EC4[2\\uFF0C1]\\uFF0C\\u5BF9\\u4E8E\\u4F4D\\u7F6E 1 \\uFF0C\\u6709\\u4E00\\u79CD\\u7EC4\\u5408\\u65B9\\u6CD5[1,1]\\uFF0C\\u6240\\u4EE5\\u5728\\u8FD9\\u79CD\\u60C5\\u51B5\\u4E0B\\u5E94\\u8BE5\\u5224\\u65AD\\u4E00\\u4E0B\\u3002\\n\\n\\u53E6\\u5916\\uFF0C\\u6211\\u4EEC\\u77E5\\u9053\\uFF0C\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u9AD8\\u5EA6\\u9012\\u589E\\u7684\\u6570\\u7EC4\\u6765\\u8BF4\\uFF0C\\u5F88\\u5BB9\\u6613\\u6C42\\u51FA\\u5176\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u6700\\u5927\\u9762\\u79EF\\uFF0C\\u90A3\\u4E48\\u662F\\u5426\\u53EF\\u4EE5\\u5C06\\u4EFB\\u610F\\u4E00\\u4E2A\\u77E9\\u9635\\u8F6C\\u5316\\u4E3A\\u4E00\\u4E2A\\u9AD8\\u5EA6\\u9012\\u589E\\u7684\\u77E9\\u9635\\u5E8F\\u5217\\uFF1F\\u5982\\u5C06\\u4E00\\u4E2A\\u6570\\u7EC4[2,3,1,3,5]\\u53D8\\u6210[1,1,1,3,5]\\uFF0C\\u4F46\\u662F\\u8FD9\\u4E2A\\u8FC7\\u7A0B\\u4E2D\\u5BF9 2 \\u4F5C\\u4E86\\u6539\\u53D8\\uFF0C\\u6211\\u4EEC\\u8981\\u901A\\u8FC7\\u4E00\\u5B9A\\u529E\\u6CD5\\u5F25\\u8865\\u8FD9\\u91CC\\u7684\\u6539\\u53D8\\uFF0C\\u4E00\\u79CD\\u65B9\\u6CD5\\u662F\\uFF0C\\u5728\\u4F5C\\u6539\\u53D8\\u524D\\uFF0C\\u5C06\\u5176\\u80FD\\u591F\\u7EC4\\u6210\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u6700\\u5927\\u9762\\u79EF\\u8BB0\\u5F55\\u4E0B\\u6765\\uFF0C\\u5B8C\\u4E86\\u4E4B\\u540E\\u4FBF\\u53EF\\u4EE5\\u5BF9\\u5176\\u505A\\u51FA\\u6539\\u53D8\\u4E86\\u3002\\u5BF9\\u4E8E\\u4E0A\\u9762\\u90A3\\u4E2A\\u4F8B\\u5B50\\uFF0C\\u5B9E\\u9645\\u4E0A\\u6211\\u4EEC\\u662F\\u5BF9\\u4E24\\u4E2A\\u9012\\u589E\\u7684\\u6570\\u7EC4\\u6C42\\u89E3\\uFF1A[2,3]\\u548C[1,1,1,3,5]\\uFF0C\\u800C\\u5B83\\u4EEC\\u4E4B\\u95F4\\u7684\\u6700\\u5927\\u89E3\\u5FC5\\u7136\\u4E0E[2,3,1,3,5]\\u7684\\u89E3\\u76F8\\u540C\\u3002\\u4E8E\\u662F\\uFF0C\\u5C06\\u4E00\\u4E2A\\u4E0D\\u89C4\\u5219\\u6570\\u7EC4\\u8F6C\\u5316\\u4E3A\\u82E5\\u5E72\\u6709\\u5E8F\\u6570\\u7EC4\\uFF0C\\u518D\\u8FDB\\u884C\\u6C42\\u89E3\\uFF0C\\u4FBF\\u662F\\u672C\\u65B9\\u6CD5\\u7684\\u601D\\u60F3\\u3002\\n\\n\\u4E0B\\u9762\\u662F\\u5229\\u7528\\u6808\\u7684\\u4E00\\u79CD\\u5B9E\\u73B0\\uFF0C\\u5229\\u7528\\u6808\\u7684\\u8BDD\\u4E0D\\u9700\\u8981\\u5BF9\\u539F\\u6570\\u636E\\u8FDB\\u884C\\u4FEE\\u6539\\uFF0C\\u800C\\u662F\\u76F4\\u63A5\\u5C06\\u539F\\u6570\\u7EC4\\u622A\\u53D6\\u6210\\u591A\\u4E2A\\u6709\\u5E8F\\u6570\\u7EC4\\uFF0C\\u901A\\u8FC7\\u4FDD\\u5B58\\u7D22\\u5F15\\u503C\\u786E\\u5B9A\\u5F53\\u524D\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u5BBD\\u5EA6\\uFF1A\\n\\n    public static int largestRectangleArea3(int[] heights) {\\n        Stack<Integer> stack = new Stack<>();\\n        int n = heights.length;\\n        int max = 0;\\n        for (int i = 0; i <= n; i++) {\\n            while (!stack.empty() && (i >= n || heights[stack.peek()] > heights[i])) {\\n                int top = stack.pop();\\n                int h = heights[top];\\n                int w = stack.empty() ? i : (i-stack.peek()-1);\\n                max = Math.max(max, h*w);\\n            }\\n            stack.push(i);\\n        }\\n        return max;\\n    }\\n\\nS4:\\u6700\\u957F\\u5BBD\\u5EA6\\u6CD5\\n\\n\\u6211\\u4EEC\\u77E5\\u9053\\uFF0C\\u7531\\u591A\\u4E2A\\u77E9\\u9635\\u7EC4\\u6210\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\uFF0C\\u5176\\u5BBD\\u5EA6\\u4E3A\\u77E9\\u9635\\u7684\\u6570\\u91CF\\uFF0C\\u9AD8\\u5EA6\\u4E3A\\u77E9\\u9635\\u4E2D\\u9AD8\\u5EA6\\u6700\\u4F4E\\u7684\\u90A3\\u4E00\\u4E2A\\u3002\\u6240\\u4EE5\\uFF0C\\u5BF9\\u4E8E\\u4EFB\\u610F\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u7684\\u77E9\\u9635\\uFF0C\\u5047\\u8BBE\\u6B64\\u65F6\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u9AD8\\u5EA6\\u4E3A\\u5F53\\u524D\\u4F4D\\u7F6E\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u6C42\\u51FA\\u8FD9\\u65F6\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u6700\\u5927\\u5BBD\\u5EA6\\uFF0C\\u4FBF\\u53EF\\u4EE5\\u6C42\\u51FA\\u4EE5\\u5F53\\u524D\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u4E3A\\u9AD8\\u5EA6\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u6700\\u5927\\u9762\\u79EF\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u6C42\\u51FA\\u6BCF\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u80FD\\u591F\\u5F62\\u6210\\u7684\\u6700\\u5927\\u89E3\\uFF0C\\u4FBF\\u80FD\\u591F\\u5F97\\u5230\\u672C\\u9898\\u7684\\u89E3\\u3002\\n\\n\\u8981\\u6C42\\u51FA\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u7684\\u6700\\u5927\\u89E3\\uFF0C\\u5982 i \\uFF0C\\u53EF\\u4EE5\\u8FD9\\u6837\\u7406\\u89E3\\uFF0C\\u4ECE\\u6570\\u7EC4[0,...,n]\\u4E2D\\u627E\\u5230\\u6700\\u5927\\u7684\\u4E00\\u6BB5[start,...,i,...end]\\uFF0C\\u5E76\\u4E14\\u5728\\u8FD9\\u6BB5\\u4E2D\\uFF0C\\u4F4D\\u7F6E i \\u5904\\u7684\\u9AD8\\u5EA6\\u6700\\u4F4E\\uFF0C\\u90A3\\u4E48\\u6B64\\u65F6\\u8FD9\\u6BB5\\u77E9\\u9635\\u7EC4\\u6210\\u7684\\u7EC4\\u5408\\u77E9\\u9635\\u7684\\u9762\\u79EF\\u5FC5\\u7136\\u662F(end-start) * heights[i]\\u3002\\u6240\\u4EE5\\u6211\\u4EEC\\u8981\\u5728\\u4F4D\\u7F6E i \\u7684\\u5DE6\\u8FB9\\u627E\\u5230\\u4E00\\u6BB5[start,...,i]\\uFF0C\\u662F\\u7684\\u8FD9\\u91CC\\u9762\\u6BCF\\u4E00\\u4E2A\\u77E9\\u9635\\u7684\\u9AD8\\u5EA6\\u90FD\\u5927\\u4E8E\\u7B49\\u4E8E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u540C\\u7406\\uFF0C\\u8FD8\\u8981\\u5728 i \\u7684\\u53F3\\u8FB9\\u627E\\u5230\\u4E00\\u6BB5[i,...end]\\uFF0C\\u627E\\u5230\\u8FD9\\u4E9B\\u4E4B\\u540E\\uFF0C\\u4F4D\\u7F6E i \\u5904\\u7684\\u89E3\\u5C31\\u53EF\\u4EE5\\u6C42\\u5F97\\u4E86\\u3002\\n\\n\\u6240\\u4EE5\\uFF0C\\u5BF9\\u4E8E\\u6BCF\\u4E00\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u53EA\\u8981\\u627E\\u5230\\u5728 i \\u7684\\u5DE6\\u8FB9\\u7B2C\\u4E00\\u4E2A\\u5C0F\\u4E8E i \\u5904\\u9AD8\\u5EA6\\u7684\\u4F4D\\u7F6E start \\uFF0C\\u518D\\u627E\\u5230 i \\u7684\\u53F3\\u8FB9\\u7B2C\\u4E00\\u4E2A\\u5C0F\\u4E8E i \\u5904\\u9AD8\\u5EA6\\u7684\\u4F4D\\u7F6E end \\u4FBF\\u53EF\\u3002\\u800C\\u8FD9\\u4E2A\\u6570\\u636E\\u53EF\\u4EE5\\u901A\\u8FC7\\u4E24\\u4E2A\\u904D\\u5386\\u6C42\\u89E3\\u3002\\n\\n    public static int largestRectangleArea4(int[] heights) {\\n        int n = heights.length;\\n        if (n == 0) return 0;\\n        int[] leftLess = new int[n], rightLess = new int[n];\\n        // find left\\n        leftLess[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            int p = i-1;\\n            while (true) {\\n                if (p >= 0 && heights[i] <= heights[p]) {\\n                    p -= leftLess[p] + 1;\\n                } else {\\n                    leftLess[i] = i - p - 1;\\n                    break;\\n                }\\n            }\\n        }\\n        // find right\\n        rightLess[n-1] = 0;\\n        for (int i = n-2; i >= 0; i--) {\\n            int p = i+1;\\n            while (true) {\\n                if (p < n && heights[i] <= heights[p]) {\\n                    p += rightLess[p] + 1;\\n                } else {\\n                    rightLess[i] = p - 1 - i;\\n                    break;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, heights[i] * (leftLess[i] + rightLess[i] + 1));\\n        }\\n        return max;\\n    }\\n\\n\\u4F7F\\u7528\\u4E00\\u4E2A\\u6570\\u7EC4 leftLess \\u4FDD\\u5B58\\u6BCF\\u4E2A\\u4F4D\\u7F6E\\u7684\\u5DE6\\u8FB9\\u9AD8\\u5EA6\\u5927\\u4E8E\\u5F53\\u524D\\u4F4D\\u7F6E\\u9AD8\\u5EA6\\u7684\\u77E9\\u9635\\u6570\\u91CF\\uFF0CrightLess \\u540C\\u7406\\u3002\\u5177\\u4F53\\u7684\\u6C42\\u89E3\\u65B9\\u6CD5\\u4E3A\\uFF1A\\u5BF9\\u4E8E\\u4F4D\\u7F6E i \\uFF0C\\u5982\\u679C i-1 \\u5904\\u7684\\u9AD8\\u5EA6\\u5927\\u4E8E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u90A3\\u4E48\\u56E0\\u4E3AleftLess[i-1]\\u4FDD\\u5B58\\u7684\\u662F\\u5927\\u4E8E\\u4F4D\\u7F6E i-1 \\u5904\\u9AD8\\u5EA6\\u7684\\u6570\\u91CF\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E9B\\u4F4D\\u7F6E\\u7684\\u9AD8\\u5EA6\\u5FC5\\u7136\\u4E5F\\u5927\\u4E8E\\u4F4D\\u7F6E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u6240\\u4EE5\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u76F4\\u63A5\\u8DF3\\u8FC71 + leftLess[i-1]\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u5224\\u65AD\\u4E0B\\u4E00\\u4E2A\\u4F4D\\u7F6E p \\u5904\\u7684\\u9AD8\\u5EA6\\u662F\\u5426\\u5927\\u4E8E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u5982\\u679C\\u8FD8\\u662F\\u5927\\u4E8E\\uFF0C\\u90A3\\u4E48\\u8FD8\\u8981\\u7EE7\\u7EED\\u8DF3\\u8FC7leftLess[p] + 1\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u518D\\u5224\\u65AD......\\u76F4\\u5230 p \\u5904\\u7684\\u9AD8\\u5EA6\\u5C0F\\u4E8E i \\u5904\\u7684\\u9AD8\\u5EA6\\uFF0C\\u6B64\\u65F6\\u5728 i \\u7684\\u5DE6\\u8FB9\\u6BD4 i \\u5904\\u9AD8\\u5EA6\\u5927\\u7684\\u77E9\\u9635\\u7684\\u6570\\u91CF\\u5C31\\u662Fi - p - 1\\u4E2A\\u3002\\u5BF9\\u4E8E rightLess \\u7684\\u6C42\\u89E3\\u540C\\u7406\\u3002\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 28981,
                "title": "10-line-c-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& heights) {\\n            int res = 0;\\n            for (int i = 0; i < heights.size(); ++i) {\\n                if (i + 1 < heights.size() && heights[i] <= heights[i+1]) continue; // find the local max (greater than left and right)\\n                int minh = heights[i];\\n                for (int j = i; j >= 0; --j) {\\n                    minh = min(minh, heights[j]);\\n                    res = max(res, minh * (i - j + 1));\\n                }\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& heights) {\\n            int res = 0;\\n            for (int i = 0; i < heights.size(); ++i) {\\n                if (i + 1 < heights.size() && heights[i] <= heights[i+1]) continue; // find the local max (greater than left and right)\\n                int minh = heights[i];\\n                for (int j = i; j >= 0; --j) {\\n                    minh = min(minh, heights[j]);\\n                    res = max(res, minh * (i - j + 1));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28998,
                "title": "explination-of-the-stack-solution-python-solution",
                "content": "To get the bigest rectangle area, we should check every rectangle with lowest point at i=1...n.   \\n\\nDefine `Si := the square with lowest point at i`. \\nTo calculate faster this `Si` , we have to use a stack `stk` which stores some *indices*. \\n\\nThe elements in stk satisfy these **properties**:   \\n\\n1. the indices as well as the corresponding heights are in ascending order   \\n2. for any adjecent indices i and j (eg. s=[...,i,j,...]), any index k between i and j are of height higher than j: \\nheight[k]>height[j]   \\n\\nWe loop through all indices, when we meet an index `k` with height lower than elements in stk (let's say, lower than index `i` in  `stk`), we know that the right end of square `Si` is just `k-1`. And what is the left end of this square? Well it is just the index to the left of `i` in stk ! \\n\\nAnother important thing is that we should append a 0 to the end of height, so that all indices in stk will be checked this way. \\n\\n\\n    class Solution(object):\\n    def largestRectangleArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mx = 0\\n        stk = []\\n        height.append(0) # very important!!\\n        for k in xrange(len(height)): \\n            while(stk and height[k]<height[stk[-1]]):\\n                rect = height[stk.pop()] * (k if not stk else k-stk[-1]-1)\\n                mx = max(mx, rect)\\n            stk.append(k)\\n        return mx",
                "solutionTags": [
                    "Python"
                ],
                "code": "To get the bigest rectangle area, we should check every rectangle with lowest point at i=1...n.   \\n\\nDefine `Si := the square with lowest point at i`. \\nTo calculate faster this `Si` , we have to use a stack `stk` which stores some *indices*. \\n\\nThe elements in stk satisfy these **properties**:   \\n\\n1. the indices as well as the corresponding heights are in ascending order   \\n2. for any adjecent indices i and j (eg. s=[...,i,j,...]), any index k between i and j are of height higher than j: \\nheight[k]>height[j]   \\n\\nWe loop through all indices, when we meet an index `k` with height lower than elements in stk (let's say, lower than index `i` in  `stk`), we know that the right end of square `Si` is just `k-1`. And what is the left end of this square? Well it is just the index to the left of `i` in stk ! \\n\\nAnother important thing is that we should append a 0 to the end of height, so that all indices in stk will be checked this way. \\n\\n\\n    class Solution(object):\\n    def largestRectangleArea(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mx = 0\\n        stk = []\\n        height.append(0) # very important!!\\n        for k in xrange(len(height)): \\n            while(stk and height[k]<height[stk[-1]]):\\n                rect = height[stk.pop()] * (k if not stk else k-stk[-1]-1)\\n                mx = max(mx, rect)\\n            stk.append(k)\\n        return mx",
                "codeTag": "Java"
            },
            {
                "id": 28991,
                "title": "16ms-c-10-line-code-with-stack",
                "content": "    int largestRectangleArea(vector<int>& height) {\\n        height.push_back(0); \\n        int len = height.size(),res = 0, cur=1;\\n        int s[len+1]={0};\\n        s[0]=-1;\\n        for(int i=1;i<len;i++){\\n            while(cur && height[i]<height[s[cur]])\\n                res = max(res, height[s[cur]] * (i-s[--cur]-1));\\n            s[++cur]=i;\\n        }\\n        return res;\\n    }\\nThe idea is simply to insert position -1 to the beginning of the stack s, therefore we don't need to check whether the stack is empty or not. \\nFor the height, push a \"0\" to the end to update the result until the last element in the height.\\nHere I use an int array to simulate the stack for better time performance.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int largestRectangleArea(vector<int>& height) {\\n        height.push_back(0); \\n        int len = height.size(),res = 0, cur=1;\\n        int s[len+1]={0};\\n        s[0]=-1;\\n        for(int i=1;i<len;i++){\\n            while(cur && height[i]<height[s[cur]])\\n                res = max(res, height[s[cur]] * (i-s[--cur]-1));\\n            s[++cur]=i;\\n        }\\n        return res;\\n    }\\nThe idea is simply to insert position -1 to the beginning of the stack s, therefore we don't need to check whether the stack is empty or not. \\nFor the height, push a \"0\" to the end to update the result until the last element in the height.\\nHere I use an int array to simulate the stack for better time performance.",
                "codeTag": "Unknown"
            },
            {
                "id": 29015,
                "title": "short-c-solution-use-stack-ac-28ms",
                "content": "    class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& height) {\\n            height.push_back(0);\\n            int result=0;\\n            stack<int> indexStack;\\n            for(int i=0;i<height.size();i++){\\n                while(!indexStack.empty()&&height[i]<height[indexStack.top()]){\\n                    int top=indexStack.top();\\n                    indexStack.pop(); \\n                    int nextTop=indexStack.size()==0?-1:indexStack.top();\\n                    result=max((i-nextTop-1)*height[top],result);\\n                }\\n                indexStack.push(i);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& height) {\\n            height.push_back(0);\\n            int result=0;\\n            stack<int> indexStack;\\n            for(int i=0;i<height.size();i++){\\n                while(!indexStack.empty()&&height[i]<height[indexStack.top()]){\\n                    int top=indexStack.top();\\n                    indexStack.pop(); \\n                    int nextTop=indexStack.size()==0?-1:indexStack.top();\\n                    result=max((i-nextTop-1)*height[top],result);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2082738,
                "title": "python-stack-solution-o-n-time-using-approach-of-next-smaller-to-left-and-right",
                "content": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n = len(heights)\\n        # left boundary => next smaller element to left\\n        stack = []\\n        nextSmallerLeft = [0]*n\\n        for i in range(n):\\n            while stack and heights[stack[-1]] >= heights[i]:\\n                stack.pop()\\n            if stack:\\n                nextSmallerLeft[i] = stack[-1] + 1\\n            stack.append(i)\\n        \\n        # right boundary => next smaller element to right\\n        stack = []\\n        nextSmallerRight = [n-1]*n\\n        for i in range(n-1, -1, -1):\\n            while stack and heights[stack[-1]] >= heights[i]:\\n                stack.pop()\\n            if stack:\\n                nextSmallerRight[i] = stack[-1] - 1\\n            stack.append(i)\\n        \\n        res = heights[0]\\n        for i in range(n):\\n            height = heights[i]\\n            weidth = nextSmallerRight[i] - nextSmallerLeft[i] + 1\\n            area = height * weidth\\n            res = max(res, area)\\n            \\n        return res\\n\\t\\t\\n\\t\\t\\n# Time: O(N)\\n# Space: O(N)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n = len(heights)\\n        # left boundary => next smaller element to left\\n        stack = []\\n        nextSmallerLeft = [0]*n\\n        for i in range(n):\\n            while stack and heights[stack[-1]] >= heights[i]:\\n                stack.pop()\\n            if stack:\\n                nextSmallerLeft[i] = stack[-1] + 1\\n            stack.append(i)\\n        \\n        # right boundary => next smaller element to right\\n        stack = []\\n        nextSmallerRight = [n-1]*n\\n        for i in range(n-1, -1, -1):\\n            while stack and heights[stack[-1]] >= heights[i]:\\n                stack.pop()\\n            if stack:\\n                nextSmallerRight[i] = stack[-1] - 1\\n            stack.append(i)\\n        \\n        res = heights[0]\\n        for i in range(n):\\n            height = heights[i]\\n            weidth = nextSmallerRight[i] - nextSmallerLeft[i] + 1\\n            area = height * weidth\\n            res = max(res, area)\\n            \\n        return res\\n\\t\\t\\n\\t\\t\\n# Time: O(N)\\n# Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729207,
                "title": "detailed-explanation-with-diagrams-and-examples-using-pen-and-paper-brute-force-and-optimized",
                "content": "**Explanation**\\n\\n![image](https://assets.leetcode.com/users/images/2c86f2b6-821c-44d5-8ae4-0f016dfcdf61_1643475595.6156461.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/20acec8f-02f2-47ec-9c88-94b88577ad7f_1643475593.3028414.jpeg)\\n\\n\\n\\n**JAVA Code**\\n1. Brute force (To understand he concept)\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int len = heights.length;\\n        if(len == 0) return 0;\\n        return  helper(heights, len);\\n    }\\n    private int helper(int height[], int len){\\n        //We will check Nearest smallest to the left\\n        Stack <Integer> NSL = new Stack <>();\\n        //To check Nearest smallest to the right\\n        Stack <Integer> NSR = new Stack<>();\\n        int left[] = new int[len];\\n        int right[] = new int[len];\\n        //NSL\\n        for(int i = 0; i < len; i++){            \\n           if(NSL.isEmpty()) left[i] = -1;\\n           else if(!NSL.isEmpty() && height[NSL.peek()] >= height[i]){\\n               while(!NSL.isEmpty() && height[NSL.peek()] >= height[i])\\n                   NSL.pop();\\n               if(NSL.isEmpty()) left[i] = -1;\\n               else left[i] = NSL.peek();\\n           }else left[i] = NSL.peek();\\n           // System.out.print(\"\\\\t\"  + left[i]); \\n           NSL.push(i); \\n        }\\n        // System.out.print(\"\\\\n\");\\n        //NSR\\n        for(int i = len - 1; i >= 0; i--){\\n            if(NSR.isEmpty()) right[i] = len;\\n            else if(!NSR.isEmpty() && height[NSR.peek()] >= height[i]){\\n               while(!NSR.isEmpty() && height[NSR.peek()] >= height[i])\\n                   NSR.pop();\\n               if(NSR.isEmpty()) right[i] = len;\\n               else right[i] = NSR.peek();\\n           }else right[i] = NSR.peek();\\n           // System.out.print(\"\\\\t\" + right[i]);  \\n           NSR.push(i); \\n        }\\n       int result = 0;\\n//         To find max distance from smallest element from left and smallest to it right\\n        for(int i = 0; i < len; i++){\\n          result =  Math.max(result, (right[i] - left[i] - 1) * height[i]); \\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n2. Optimized\\n\\n```\\n public int largestRectangleArea(int[] heights) {\\n        int len = heights.length;\\n        Stack<Integer> s = new Stack<>();\\n        int maxArea = 0;\\n        for (int i = 0; i <= len; i++){\\n            int h = (i == len ? 0 : heights[i]);\\n            if (s.isEmpty() || h >= heights[s.peek()]) {\\n                s.push(i);\\n            } else {\\n                int top = s.pop();\\n                maxArea = Math.max(maxArea, heights[top] * (s.isEmpty() ? i : i - 1 - s.peek()));\\n                i--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n```\\n\\nNOTE: Try understanding concepts of  Nearest smallest from left/ right && Nearest greatest from left/right for better understanding \\n\\n<br>\\n<br>\\n\\nString yourReaction;\\nif(\"understood\".equals(yourReaction) || \"liked it\".equals(yourReaction))\\nSystem.out.println(**\"Please upvote!\"**)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int len = heights.length;\\n        if(len == 0) return 0;\\n        return  helper(heights, len);\\n    }\\n    private int helper(int height[], int len){\\n        //We will check Nearest smallest to the left\\n        Stack <Integer> NSL = new Stack <>();\\n        //To check Nearest smallest to the right\\n        Stack <Integer> NSR = new Stack<>();\\n        int left[] = new int[len];\\n        int right[] = new int[len];\\n        //NSL\\n        for(int i = 0; i < len; i++){            \\n           if(NSL.isEmpty()) left[i] = -1;\\n           else if(!NSL.isEmpty() && height[NSL.peek()] >= height[i]){\\n               while(!NSL.isEmpty() && height[NSL.peek()] >= height[i])\\n                   NSL.pop();\\n               if(NSL.isEmpty()) left[i] = -1;\\n               else left[i] = NSL.peek();\\n           }else left[i] = NSL.peek();\\n           // System.out.print(\"\\\\t\"  + left[i]); \\n           NSL.push(i); \\n        }\\n        // System.out.print(\"\\\\n\");\\n        //NSR\\n        for(int i = len - 1; i >= 0; i--){\\n            if(NSR.isEmpty()) right[i] = len;\\n            else if(!NSR.isEmpty() && height[NSR.peek()] >= height[i]){\\n               while(!NSR.isEmpty() && height[NSR.peek()] >= height[i])\\n                   NSR.pop();\\n               if(NSR.isEmpty()) right[i] = len;\\n               else right[i] = NSR.peek();\\n           }else right[i] = NSR.peek();\\n           // System.out.print(\"\\\\t\" + right[i]);  \\n           NSR.push(i); \\n        }\\n       int result = 0;\\n//         To find max distance from smallest element from left and smallest to it right\\n        for(int i = 0; i < len; i++){\\n          result =  Math.max(result, (right[i] - left[i] - 1) * height[i]); \\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n public int largestRectangleArea(int[] heights) {\\n        int len = heights.length;\\n        Stack<Integer> s = new Stack<>();\\n        int maxArea = 0;\\n        for (int i = 0; i <= len; i++){\\n            int h = (i == len ? 0 : heights[i]);\\n            if (s.isEmpty() || h >= heights[s.peek()]) {\\n                s.push(i);\\n            } else {\\n                int top = s.pop();\\n                maxArea = Math.max(maxArea, heights[top] * (s.isEmpty() ? i : i - 1 - s.peek()));\\n                i--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739329,
                "title": "javascript-using-stack-beat-97",
                "content": "Time Complexity = O(N)\\nSpace Complexity = O(N)\\n```javascript\\nvar largestRectangleArea = function(heights) {\\n    // to deal with last element without going out of bound\\n    heights.push(0)\\n    const stack = [];\\n    let maxArea = 0, curr, currH, top, topH, area;\\n    \\n    for(let i = 0; i < heights.length; i++) {\\n        top = stack[stack.length-1];\\n        topH = heights[top];\\n        // pop from stack as long as the top of the stack\\n        // is greater than the current height and\\n        // the stack has at least 2 items\\n        while(stack.length > 1 && topH > heights[i]) {\\n            curr = stack.pop();\\n            currH = heights[curr];\\n            top = stack[stack.length-1];\\n            topH = heights[top];\\n            area = currH * (i - 1 - top);\\n            maxArea = Math.max(area, maxArea);\\n        }\\n        \\n        // when only 1 item left in the stack\\n        if(stack.length && topH > heights[i]) {\\n            curr = stack.pop();\\n            currH = heights[curr];\\n            area = currH * i;\\n            maxArea = Math.max(area, maxArea);\\n        }\\n        stack.push(i);\\n    }\\n    return maxArea;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar largestRectangleArea = function(heights) {\\n    // to deal with last element without going out of bound\\n    heights.push(0)\\n    const stack = [];\\n    let maxArea = 0, curr, currH, top, topH, area;\\n    \\n    for(let i = 0; i < heights.length; i++) {\\n        top = stack[stack.length-1];\\n        topH = heights[top];\\n        // pop from stack as long as the top of the stack\\n        // is greater than the current height and\\n        // the stack has at least 2 items\\n        while(stack.length > 1 && topH > heights[i]) {\\n            curr = stack.pop();\\n            currH = heights[curr];\\n            top = stack[stack.length-1];\\n            topH = heights[top];\\n            area = currH * (i - 1 - top);\\n            maxArea = Math.max(area, maxArea);\\n        }\\n        \\n        // when only 1 item left in the stack\\n        if(stack.length && topH > heights[i]) {\\n            curr = stack.pop();\\n            currH = heights[curr];\\n            area = currH * i;\\n            maxArea = Math.max(area, maxArea);\\n        }\\n        stack.push(i);\\n    }\\n    return maxArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467358,
                "title": "c-stack-solution",
                "content": "The idea is simple: suppose a rectangle contains the column `i` and has a height `heights[i]`, then the max area of the rectangle will be `heights[i] * (rb[i] - lb[i] - 1)`. Here we define:\\n\\n- `lb[i]`: the index of first column on the left of `i` whose height is lower than `heights[i]`.\\n- `rb[i]`: the index of first column on the right of `i` whose height is lower than `heights[i]`.\\n\\nWe first scan the `heights` array and use a stack to construct `lb[i]` and `rb[i]`. After that, we scan `heights` again and calculate  `heights[i] * (rb[i] - lb[i] - 1)` to get the max possible area.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int N = heights.size();\\n        stack<int> st;\\n        // construct lb[i]: idx of first col on the left that is lower than height[i]\\n        vector<int> lb(N);\\n        for (int i(0); i < N; ++i) {\\n            while (!st.empty() and heights[st.top()] >= heights[i]) {\\n                st.pop();\\n            }\\n            if (st.empty()) {\\n                lb[i] = -1;\\n                st.push(i);\\n            }\\n            else {\\n                lb[i] = st.top();\\n                st.push(i);\\n            }\\n        }\\n        \\n        // clear stack\\n        while (!st.empty()) st.pop();\\n        \\n        // construct rb[i]: idx of first col on the right that is lower than height[i]\\n        vector<int> rb(N);\\n        for (int i(N-1); i >= 0; --i) {\\n            while (!st.empty() and heights[st.top()] >= heights[i]) {\\n                st.pop();\\n            }\\n            if (st.empty()) {\\n                rb[i] = N;\\n                st.push(i);\\n            }\\n            else {\\n                rb[i] = st.top();\\n                st.push(i);\\n            }\\n        }\\n        \\n        // scan each col and get max area\\n        int rst = 0;\\n        for (int i(0); i < N; ++i) {\\n            rst = max(rst, \\n                     heights[i] * (rb[i] - lb[i] - 1)\\n                     );\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int N = heights.size();\\n        stack<int> st;\\n        // construct lb[i]: idx of first col on the left that is lower than height[i]\\n        vector<int> lb(N);\\n        for (int i(0); i < N; ++i) {\\n            while (!st.empty() and heights[st.top()] >= heights[i]) {\\n                st.pop();\\n            }\\n            if (st.empty()) {\\n                lb[i] = -1;\\n                st.push(i);\\n            }\\n            else {\\n                lb[i] = st.top();\\n                st.push(i);\\n            }\\n        }\\n        \\n        // clear stack\\n        while (!st.empty()) st.pop();\\n        \\n        // construct rb[i]: idx of first col on the right that is lower than height[i]\\n        vector<int> rb(N);\\n        for (int i(N-1); i >= 0; --i) {\\n            while (!st.empty() and heights[st.top()] >= heights[i]) {\\n                st.pop();\\n            }\\n            if (st.empty()) {\\n                rb[i] = N;\\n                st.push(i);\\n            }\\n            else {\\n                rb[i] = st.top();\\n                st.push(i);\\n            }\\n        }\\n        \\n        // scan each col and get max area\\n        int rst = 0;\\n        for (int i(0); i < N; ++i) {\\n            rst = max(rst, \\n                     heights[i] * (rb[i] - lb[i] - 1)\\n                     );\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307762,
                "title": "o-n-solution-with-clear-code",
                "content": "The idea is very simple: for each bar find the area of the rectangle where this bar height defines the height of the whole rectangle.\\nTo do that in O(n), we need to find in O(1) the following indices:\\n\\t1) Index of the first element on the left from current `i` which is smaller than `heights[i]`\\n\\t2) Index of the first element on the right from current `i` which is smaller than `heights[i]`\\n\\n```C++\\n    vector<int> getNextSmaller(const vector<int>& heights) {\\n        stack<int> st;\\n        vector<int> res(heights.size(), heights.size());\\n        for (int i = 0; i < heights.size(); ++i) {\\n            while (!st.empty() && heights[st.top()] > heights[i]) {\\n                res[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n    // exactly the same as above except for the order\\n    // and the default element here is -1 (assume the the smaller element is before the start of the array)\\n    vector<int> getPrevSmaller(const vector<int>& heights) {\\n        stack<int> st;\\n        vector<int> res(heights.size(), -1);\\n        for (int i = heights.size() - 1; i >= 0; --i) {\\n            while (!st.empty() && heights[st.top()] > heights[i]) {\\n                res[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int largestRectangleArea(vector<int>& heights) {\\n        if (heights.size() == 0) return 0;\\n        \\n        auto nextSmaller = getNextSmaller(heights);\\n        auto prevSmaller = getPrevSmaller(heights);\\n        \\n        int res = 0;\\n        for (int i = 0; i < heights.size(); ++i) {\\n            int r = nextSmaller[i];\\n            int l = prevSmaller[i];\\n            res = max(res, heights[i]*(r - l - 1));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\n    vector<int> getNextSmaller(const vector<int>& heights) {\\n        stack<int> st;\\n        vector<int> res(heights.size(), heights.size());\\n        for (int i = 0; i < heights.size(); ++i) {\\n            while (!st.empty() && heights[st.top()] > heights[i]) {\\n                res[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n    // exactly the same as above except for the order\\n    // and the default element here is -1 (assume the the smaller element is before the start of the array)\\n    vector<int> getPrevSmaller(const vector<int>& heights) {\\n        stack<int> st;\\n        vector<int> res(heights.size(), -1);\\n        for (int i = heights.size() - 1; i >= 0; --i) {\\n            while (!st.empty() && heights[st.top()] > heights[i]) {\\n                res[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int largestRectangleArea(vector<int>& heights) {\\n        if (heights.size() == 0) return 0;\\n        \\n        auto nextSmaller = getNextSmaller(heights);\\n        auto prevSmaller = getPrevSmaller(heights);\\n        \\n        int res = 0;\\n        for (int i = 0; i < heights.size(); ++i) {\\n            int r = nextSmaller[i];\\n            int l = prevSmaller[i];\\n            res = max(res, heights[i]*(r - l - 1));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28945,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/77574/python-solution-with-detailed-explanation\\n\\n**Largest Rectangle in Histogram** https://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nhttp://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\nhttp://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n\\n1. For every bar \\u2018x\\u2019, we calculate the area with \\u2018x\\u2019 as the smallest bar in the rectangle. \\n2. If we calculate such area for every bar \\u2018x\\u2019 and find the maximum of all areas, our task is done. \\n3. How to calculate area with \\u2018x\\u2019 as smallest bar? We need to know index of the first smaller (smaller than \\u2018x\\u2019) bar on left of \\u2018x\\u2019 and index of first smaller bar on right of \\u2018x\\u2019. Let us call these indexes as \\u2018left index\\u2019 and \\u2018right index\\u2019 respectively.\\n4. We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. \\n5. A bar is popped from stack when a bar of smaller height is seen. \\n6. When a bar is popped, we calculate the area with the popped bar as smallest bar. \\n7. **How do we get left and right indexes of the popped bar \\u2013 the current index tells us the \\u2018right index\\u2019 and index of previous item in stack is the \\u2018left index\\u2019. Note index of previous item is important here.** \\n8. Now using the above idea, we can make both an N^2 and NlgN algorithm.\\n9. For N^2 algorithm, no stack is requried. We scan at each step in left and right direction.\\n10. For NlgN algorithm, we find the minimum height m1. We then split at the minimum height.\\n\\n```\\nclass Solution(object):\\n    def largestRectangleArea(self, heights):\\n        \"\"\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_area, st = 0, []\\n        for idx,x in enumerate(heights):\\n            if len(st) == 0:\\n                st.append(idx)\\n            elif x >= heights[st[-1]]:\\n                st.append(idx)\\n            else:\\n                while st and heights[st[-1]] > x:\\n                    # For min_height, the right index is idx and the left index is st[-1].\\n                    # Distance between them will be (right_index - left_index - 1). right & left index are not included in result.\\n                    # If the stack is empty, then no bar on left is smaller. So width of base is idx.\\n                    min_height = heights[st.pop()] \\n                    max_area = max(max_area, min_height*(idx-1-st[-1])) if st else max(max_area, min_height*idx)\\n                st.append(idx)\\n        while st:\\n            min_height = heights[st.pop()] \\n            max_area = max(max_area, min_height*(len(heights)-1-st[-1])) if st else max(max_area, min_height*len(heights))\\n        return max_area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestRectangleArea(self, heights):\\n        \"\"\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_area, st = 0, []\\n        for idx,x in enumerate(heights):\\n            if len(st) == 0:\\n                st.append(idx)\\n            elif x >= heights[st[-1]]:\\n                st.append(idx)\\n            else:\\n                while st and heights[st[-1]] > x:\\n                    # For min_height, the right index is idx and the left index is st[-1].\\n                    # Distance between them will be (right_index - left_index - 1). right & left index are not included in result.\\n                    # If the stack is empty, then no bar on left is smaller. So width of base is idx.\\n                    min_height = heights[st.pop()] \\n                    max_area = max(max_area, min_height*(idx-1-st[-1])) if st else max(max_area, min_height*idx)\\n                st.append(idx)\\n        while st:\\n            min_height = heights[st.pop()] \\n            max_area = max(max_area, min_height*(len(heights)-1-st[-1])) if st else max(max_area, min_height*len(heights))\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28914,
                "title": "my-16ms-c-o-n-code-without-a-stack",
                "content": "Basically, I find the range (left[i], right[i]) within which the height of every element is at least height[i]. For each i, there is a rectangular with area height[i] * (right[i]-left[i]+1), and the largest area must be one of them. Then run all i to find the largest area. Please notice it takes O(n) time to fill left[i] and right[i] if we use DP. We can use amortization analysis to find this out. If you think about the worst case for a certain i, if it takes k steps in the while loop to get left[i]. Then it means there are k indices (for each j update below) which only take 1 step each in the loop to find left item for these indices. Then the average number of steps of these k+1 indices is const. So it takes O(n) to fill left and right arrays.\\n\\n    class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& height) {\\n            int N=height.size(), i, j, l, r, area=0, temp;\\n            if(N==0) return 0;\\n            vector<int> left(N), right(N);\\n            left[0]=0;  //fill left[i] in the for loop\\n            for(i=1; i<N; ++i){\\n                l=i;\\n                j=i-1;\\n                while(j>=0&&height[j]>=height[i]){   // amortization shows const steps for this loop\\n                    if(height[j]==height[i]){\\n                        l=left[j];\\n                        break;\\n                    }\\n                    l=left[j];\\n                    j=left[j]-1;\\n                }\\n                left[i]=l;\\n            }\\n            right[N-1]=N-1;  //fill right[i] in the for loop\\n            for(i=N-2; i>=0; --i){\\n                r=i;\\n                j=i+1;\\n                while(j<N && height[j]>=height[i]){ \\n                    if(height[j]==height[i]){\\n                        r=right[j];\\n                        break;\\n                    }\\n                    r=right[j];\\n                    j=right[j]+1;\\n                }\\n                right[i]=r;\\n            }\\n            for(i=0; i<N; ++i){\\n                temp=height[i]*(right[i]-left[i]+1);\\n                if(temp>area) area = temp;\\n            }\\n            return area;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& height) {\\n            int N=height.size(), i, j, l, r, area=0, temp;\\n            if(N==0) return 0;\\n            vector<int> left(N), right(N);\\n            left[0]=0;  //fill left[i] in the for loop\\n            for(i=1; i<N; ++i){\\n                l=i;\\n                j=i-1;\\n                while(j>=0&&height[j]>=height[i]){   // amortization shows const steps for this loop\\n                    if(height[j]==height[i]){\\n                        l=left[j];\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3263467,
                "title": "most-optimized-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        int max = 0;\\n        int nr[] = new int[n];\\n        int nl[] = new int[n];\\n\\n        Stack<Integer> s = new Stack<>();\\n        // Right\\n        for(int i = n-1; i>=0; i--){\\n            while(!s.empty() && heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                nr[i] = n;\\n            }\\n            else{\\n                nr[i] = s.peek();\\n            }\\n            s.push(i);\\n        }\\n        // Left\\n        s = new Stack<>();\\n        for(int i = 0; i<heights.length; i++){\\n            while(!s.empty() && heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                nl[i] = -1;\\n            }\\n            else{\\n                nl[i] = s.peek();\\n            }\\n            s.push(i);\\n        }\\n\\n        for(int i = 0; i<n; i++){\\n            int hi = heights[i];\\n            int width = nr[i]-nl[i]-1;\\n            int curr = hi * width;\\n            max = Math.max(curr, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        int max = 0;\\n        int nr[] = new int[n];\\n        int nl[] = new int[n];\\n\\n        Stack<Integer> s = new Stack<>();\\n        // Right\\n        for(int i = n-1; i>=0; i--){\\n            while(!s.empty() && heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                nr[i] = n;\\n            }\\n            else{\\n                nr[i] = s.peek();\\n            }\\n            s.push(i);\\n        }\\n        // Left\\n        s = new Stack<>();\\n        for(int i = 0; i<heights.length; i++){\\n            while(!s.empty() && heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                nl[i] = -1;\\n            }\\n            else{\\n                nl[i] = s.peek();\\n            }\\n            s.push(i);\\n        }\\n\\n        for(int i = 0; i<n; i++){\\n            int hi = heights[i];\\n            int width = nr[i]-nl[i]-1;\\n            int curr = hi * width;\\n            max = Math.max(curr, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516274,
                "title": "shortest-code-rat-bhi-skte-ho",
                "content": "1. **daalo -1 stack mein, aur 0 ko nums ke back mein**\\n2.  **jaldi se krlo pura yaad, interviewer ke saamne krdena anuvaad**\\n3.  **upvote kroge to milegi jrur, ldki nhi job huzur**\\n\\n\\n\\n\\n```\\n int largestRectangleArea(vector<int>& nums) {\\n    stack<int> st;\\n    st.push(-1);\\n    nums.push_back(0);\\n    int ans=0,n=nums.size();\\n    for(int i=0;i<n;i++)\\n    {\\n        while(!st.empty() && st.top()!=-1 && nums[i]<nums[st.top()]){\\n                int h=nums[st.top()],st.pop();\\n                ans=max(ans,h*(i-st.top()-1));\\n        }\\n        st.push(i);\\n    }\\n    return ans;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n int largestRectangleArea(vector<int>& nums) {\\n    stack<int> st;\\n    st.push(-1);\\n    nums.push_back(0);\\n    int ans=0,n=nums.size();\\n    for(int i=0;i<n;i++)\\n    {\\n        while(!st.empty() && st.top()!=-1 && nums[i]<nums[st.top()]){\\n                int h=nums[st.top()],st.pop();\\n                ans=max(ans,h*(i-st.top()-1));\\n        }\\n        st.push(i);\\n    }\\n    return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 582039,
                "title": "python-a-brief-summary-for-monotonous-stacks-applications",
                "content": "For this problem, an monotonously increasing stack is used to store the previous indices. Once `current height` < `stack[-1]\\'s height`, a cadidate rectangler area can be calculated with `width: length between stack[-2] + 1 ~ current index - 1`, `height: stack[-1]\\'s height`. Compare all candidates to get the final results. \\n```\\nclass Solution(object):\\n    def largestRectangleArea(self, heights):\\n        \"\"\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \"\"\"\\n        heights.append(0)\\n        inStack, rst = [], 0\\n        for i in range(len(heights)):\\n            while inStack and heights[i] < heights[inStack[-1]]:\\n\\t\\t\\t    # local regionMin\\'s idx, where the `local region` is [last.last.idx + 1, cur.idx - 1]\\n                regionMinIdx = inStack.pop()\\n                h = heights[regionMinIdx]\\n\\t\\t\\t\\t# width = endIdx - startIdx + 1 if there is a start, else endIdx - 0 + 1\\n                w = i - 1 - (inStack[-1] + 1) + 1 if inStack else i - 1 - 0 + 1\\n                rst = max(rst, h * w)\\n            inStack.append(i)\\n        return rst\\n```\\n\\nBesides this one, monotonous stack can solve other problems with **a similiar template**. \\n1.  [Locate days between today and next warmer day](https://leetcode.com/problems/daily-temperatures/discuss/109832/Java-Easy-AC-Solution-with-Stack): it can be used when finding first largest element. \\n```py\\nclass Solution(object):\\n    def dailyTemperatures(self, T):\\n        \"\"\"\\n        :type T: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        deStack = []\\n        rst = [0] * len(T)\\n        for i in range(len(T) - 1, -1, -1):\\n            while deStack and T[i] >= T[deStack[-1]]:\\n                deStack.pop()\\n            rst[i] = deStack[-1] - i if deStack else 0\\n            deStack.append(i)\\n        return rst\\n```\\n2.  [Trapping rain water stack solution](https://leetcode.com/problems/trapping-rain-water/solution/): it can be used when finding `leftmost first larger element` **AND** the `rightmost first larger element` in one pass. \\n```py\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # stack recording decreasing height\\'s indices\\n        # each time cur height > last height, update the rectangular region last.last.Idx -> curIdx, last.Height -> min(last.last.Height, cur.Height)\\n        deStack = []\\n        rst = 0\\n        for curIdx, curHeight in enumerate(height):\\n            while deStack and curHeight > height[deStack[-1]]:\\n                lastIdx = deStack.pop()\\n                if deStack:\\n                    rst += (curIdx - deStack[-1] - 1) * (min(curHeight, height[deStack[-1]]) - height[lastIdx])\\n            # Only processed prev rectangular blocks with left bar < curHeight, cur position might still able to keep \\n            # rain water so curIdx still need to be pushed in stack\\n            deStack.append(curIdx)\\n        return rst\\n```\\n3.  [Minimum cost construct Tree from Leaf values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space): still, use it to find left and right first larger element. Also a, **wrong-result**, increasing instead of decreasing stack solution can be found [here](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/574870/Python-Two-Monotonous-Stack-solutions%3A-decreasing-and-increasing-stacks) for practice.\\n```py\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Each number A can be removed by its left/right largest(or smallest depending on removing from small -> large or large -> small) adjacent number with cost A * left/right, \\n        # smallest cost to remove A would be A * min(left, right)\\n        # remove num with its min(left/right FIRST larger number)\\n        cost, n = 0, len(arr)\\n        arr.append(sys.maxsize)  # add a large number at the end to pop out all final decreasing nums\\n        deStack = []  # decreasing stack\\n        for i, num in enumerate(arr):\\n            while deStack and num >= deStack[-1]:\\n                val = deStack.pop()\\n                if deStack or i != n:\\n                    cost += val * min(num, deStack[-1]) if deStack else val * num\\n            deStack.append(num)\\n        return cost\\n```\\n4. [Asteroid merging](https://leetcode.com/problems/asteroid-collision/discuss/580582/Python-Stack-solution-WITHOUT-uninterpretable-nested-loops): monotonous stack is not limited to be used on finding first larger/smaller item. It can be extended on other tasks when only single direction expantion/updating is allowed and the `monotonous` feature can also mean for the increasing absolute value or other more abstract self-defined concepts.\\n```py\\nclass Solution(object):\\n    def asteroidCollision(self, asteroids):\\n        \"\"\"\\n        :type asteroids: List[int]\\n        :rtype: List[int]\\n        Note: -5, 5, -3, 5 -> -5 5 5, the head wont merge with the tail\\n        \"\"\"\\n        s = []\\n        def inner(cur):\\n            append_cur = True\\n            # inner loop is to backwardly delete s, cur is not moving at inner loop.\\n            while s and cur < 0 and s[-1] > 0:\\n                if abs(cur) > s[-1]:\\n                    s.pop()\\n                    continue  # to delete more s\\'s ending positive numbers\\n                elif abs(cur) == s[-1]:\\n                    s.pop()\\n                    append_cur = False  # equal, cur is disposed\\n                    break\\n                else:\\n                    append_cur = False  # |cur| < s[-1], cur is disposed\\n                    break\\n            return append_cur\\n                    \\n        \\n        for cur in asteroids:\\n            append_cur = inner(cur)\\n            if append_cur:\\n                s.append(cur)\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestRectangleArea(self, heights):\\n        \"\"\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \"\"\"\\n        heights.append(0)\\n        inStack, rst = [], 0\\n        for i in range(len(heights)):\\n            while inStack and heights[i] < heights[inStack[-1]]:\\n\\t\\t\\t    # local regionMin\\'s idx, where the `local region` is [last.last.idx + 1, cur.idx - 1]\\n                regionMinIdx = inStack.pop()\\n                h = heights[regionMinIdx]\\n\\t\\t\\t\\t# width = endIdx - startIdx + 1 if there is a start, else endIdx - 0 + 1\\n                w = i - 1 - (inStack[-1] + 1) + 1 if inStack else i - 1 - 0 + 1\\n                rst = max(rst, h * w)\\n            inStack.append(i)\\n        return rst\\n```\n```py\\nclass Solution(object):\\n    def dailyTemperatures(self, T):\\n        \"\"\"\\n        :type T: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        deStack = []\\n        rst = [0] * len(T)\\n        for i in range(len(T) - 1, -1, -1):\\n            while deStack and T[i] >= T[deStack[-1]]:\\n                deStack.pop()\\n            rst[i] = deStack[-1] - i if deStack else 0\\n            deStack.append(i)\\n        return rst\\n```\n```py\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # stack recording decreasing height\\'s indices\\n        # each time cur height > last height, update the rectangular region last.last.Idx -> curIdx, last.Height -> min(last.last.Height, cur.Height)\\n        deStack = []\\n        rst = 0\\n        for curIdx, curHeight in enumerate(height):\\n            while deStack and curHeight > height[deStack[-1]]:\\n                lastIdx = deStack.pop()\\n                if deStack:\\n                    rst += (curIdx - deStack[-1] - 1) * (min(curHeight, height[deStack[-1]]) - height[lastIdx])\\n            # Only processed prev rectangular blocks with left bar < curHeight, cur position might still able to keep \\n            # rain water so curIdx still need to be pushed in stack\\n            deStack.append(curIdx)\\n        return rst\\n```\n```py\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Each number A can be removed by its left/right largest(or smallest depending on removing from small -> large or large -> small) adjacent number with cost A * left/right, \\n        # smallest cost to remove A would be A * min(left, right)\\n        # remove num with its min(left/right FIRST larger number)\\n        cost, n = 0, len(arr)\\n        arr.append(sys.maxsize)  # add a large number at the end to pop out all final decreasing nums\\n        deStack = []  # decreasing stack\\n        for i, num in enumerate(arr):\\n            while deStack and num >= deStack[-1]:\\n                val = deStack.pop()\\n                if deStack or i != n:\\n                    cost += val * min(num, deStack[-1]) if deStack else val * num\\n            deStack.append(num)\\n        return cost\\n```\n```py\\nclass Solution(object):\\n    def asteroidCollision(self, asteroids):\\n        \"\"\"\\n        :type asteroids: List[int]\\n        :rtype: List[int]\\n        Note: -5, 5, -3, 5 -> -5 5 5, the head wont merge with the tail\\n        \"\"\"\\n        s = []\\n        def inner(cur):\\n            append_cur = True\\n            # inner loop is to backwardly delete s, cur is not moving at inner loop.\\n            while s and cur < 0 and s[-1] > 0:\\n                if abs(cur) > s[-1]:\\n                    s.pop()\\n                    continue  # to delete more s\\'s ending positive numbers\\n                elif abs(cur) == s[-1]:\\n                    s.pop()\\n                    append_cur = False  # equal, cur is disposed\\n                    break\\n                else:\\n                    append_cur = False  # |cur| < s[-1], cur is disposed\\n                    break\\n            return append_cur\\n                    \\n        \\n        for cur in asteroids:\\n            append_cur = inner(cur)\\n            if append_cur:\\n                s.append(cur)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304249,
                "title": "python-o-n-explained-in-detail",
                "content": "```\\nclass Solution(object):\\n    def largestRectangleArea(self, heights):\\n        \"\"\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # for every bar, calc the area which uses this bar as the lowest bar\\n        # therefore we need to find the first lower bar towards the left and the \\n        # first lower bar towards the right\\n        # hence, we need a stack to keep stacking the higher bars\\n        # when a lower bar appears, thats the first lower bar towards the right\\n        # and the first lower bar towards the left will be the next bar in the stack\\n        stack = []\\n        max_area = 0\\n        for i in range(len(heights)):\\n            if not stack:\\n                stack.append(i)\\n            else:\\n                # if height not decreasing, just stack\\n                if heights[i] >= heights[stack[-1]]:\\n                    stack.append(i)\\n                    continue\\n                while stack and heights[i] < heights[stack[-1]]:\\n                    # for the bar on top of the stack\\n                    # we found the first lower bar towards the right\\n                    this_bar = stack.pop()\\n                    right_index = i\\n                    left_index = stack[-1] if stack else -1 # no lower towards the left, so make it left of the leftmost, which makes it -1\\n                    area = heights[this_bar] * (right_index - left_index -1)\\n                    max_area = max(area, max_area)\\n                stack.append(i)\\n        while stack:\\n            this_bar = stack.pop()\\n            right_index = len(heights) # no lower towards the right, so make it right of the rightmost, which makes it len(heights)\\n            left_index = stack[-1] if stack else -1\\n            area = heights[this_bar] * (right_index - left_index -1)\\n            max_area = max(area, max_area)\\n        return max_area \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestRectangleArea(self, heights):\\n        \"\"\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # for every bar, calc the area which uses this bar as the lowest bar\\n        # therefore we need to find the first lower bar towards the left and the \\n        # first lower bar towards the right\\n        # hence, we need a stack to keep stacking the higher bars\\n        # when a lower bar appears, thats the first lower bar towards the right\\n        # and the first lower bar towards the left will be the next bar in the stack\\n        stack = []\\n        max_area = 0\\n        for i in range(len(heights)):\\n            if not stack:\\n                stack.append(i)\\n            else:\\n                # if height not decreasing, just stack\\n                if heights[i] >= heights[stack[-1]]:\\n                    stack.append(i)\\n                    continue\\n                while stack and heights[i] < heights[stack[-1]]:\\n                    # for the bar on top of the stack\\n                    # we found the first lower bar towards the right\\n                    this_bar = stack.pop()\\n                    right_index = i\\n                    left_index = stack[-1] if stack else -1 # no lower towards the left, so make it left of the leftmost, which makes it -1\\n                    area = heights[this_bar] * (right_index - left_index -1)\\n                    max_area = max(area, max_area)\\n                stack.append(i)\\n        while stack:\\n            this_bar = stack.pop()\\n            right_index = len(heights) # no lower towards the right, so make it right of the rightmost, which makes it len(heights)\\n            left_index = stack[-1] if stack else -1\\n            area = heights[this_bar] * (right_index - left_index -1)\\n            max_area = max(area, max_area)\\n        return max_area \\n```",
                "codeTag": "Java"
            },
            {
                "id": 28987,
                "title": "16-ms-beat-94-c-solution",
                "content": "    class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size(),Area=0;\\n            vector<int> left(n,0),right(n,0);\\n            for(int i=1;i<n;i++){ \\n                int j = i-1;\\n                while(j>=0 && heights[i]<=heights[j]){\\n                    j -= (left[j]+1);\\n                }\\n                left[i] = i-j-1;  //starts from i, how far the rectangle can go toward left\\n            }\\n            for(int i=n-2;i>=0;i--){\\n                int j=i+1;\\n                while(j<n && heights[i]<=heights[j]){\\n                    j += (right[j]+1);\\n                }\\n                right[i] = j-i-1; //starts from i, how far the rectangle can go toward right\\n            }\\n            for(int i=0;i<n;i++) Area = max(Area,heights[i]*(right[i]+1+left[i])); //Bottom: left[i]+right[i]+1\\n            return Area;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size(),Area=0;\\n            vector<int> left(n,0),right(n,0);\\n            for(int i=1;i<n;i++){ \\n                int j = i-1;\\n                while(j>=0 && heights[i]<=heights[j]){\\n                    j -= (left[j]+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29017,
                "title": "easy-to-understand-92ms-python-solution-linear-time-and-space",
                "content": "    class Solution(object):\\n    # Helper function calculating how far each bar can be extended to the right.\\n    def calmax(self, height):\\n        stack = []\\n        n = len(height)\\n        rec = [0] * n\\n        for i in xrange(len(height)):\\n            while len(stack) > 0 and height[stack[-1]] > height[i]:\\n                top = stack.pop()\\n                rec[top] = i\\n            stack.append(i)\\n        for i in stack:\\n            rec[i] = n\\n        return rec\\n    def largestRectangleArea(self, height):\\n        # How far can each bar be extended to the right?\\n        rec1 = self.calmax(height)\\n        # How far can each bar be extended to the left?\\n        rec2 = self.calmax(height[::-1])[::-1]\\n        maxa = 0\\n        n = len(height)\\n        for i in xrange(n):\\n            # Add the left and right part together\\n            new = height[i] * (rec1[i] + rec2[i] - n)\\n            maxa = max(new, maxa)\\n        return maxa\\n\\nThis solution can be made faster. But who cares if the complexity is still \\\\Theta(n)?",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    # Helper function calculating how far each bar can be extended to the right.\\n    def calmax(self, height):\\n        stack = []\\n        n = len(height)\\n        rec = [0] * n\\n        for i in xrange(len(height)):\\n            while len(stack) > 0 and height[stack[-1]] > height[i]:\\n                top = stack.pop()\\n                rec[top] = i\\n            stack.append(i)\\n        for i in stack:\\n            rec[i] = n\\n        return rec\\n    def largestRectangleArea(self, height):\\n        # How far can each bar be extended to the right?\\n        rec1 = self.calmax(height)\\n        # How far can each bar be extended to the left?\\n        rec2 = self.calmax(height[::-1])[::-1]\\n        maxa = 0\\n        n = len(height)\\n        for i in xrange(n):\\n            # Add the left and right part together\\n            new = height[i] * (rec1[i] + rec2[i] - n)\\n            maxa = max(new, maxa)\\n        return maxa\\n\\nThis solution can be made faster. But who cares if the complexity is still \\\\Theta(n)?",
                "codeTag": "Java"
            },
            {
                "id": 2881595,
                "title": "c-o-n-easy-to-understand-with-in-depth-explanation-and-examples",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\nPrecompute the next smallest height for every height going from left to right and also from right to left. Then, we can go through these arrays and compute the largest area by finding the next smallest bar from left to right to determine the width and multiply it by the height of itself.\\n\\n## Code\\n\\n```c++\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        const int n = heights.size();\\n        ll ans = 0;\\n\\n        stack<int> elems;\\n        vector<int> next_smallest_height_to_left(n, -1),\\n                    next_smallest_height_to_right(n, n);\\n\\n        for (int i = 0; i < n; i++) {\\n            while (!elems.empty() && heights[elems.top()] > heights[i]) {\\n                next_smallest_height_to_right[elems.top()] = i;\\n                elems.pop();\\n            }\\n            elems.push(i);\\n        }\\n\\n        // This is done because stack does not have a clear function\\n        while (!elems.empty()) elems.pop();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!elems.empty() && heights[elems.top()] > heights[i]) {\\n                next_smallest_height_to_left[elems.top()] = i;\\n                elems.pop();\\n            }\\n            elems.push(i);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int width = next_smallest_height_to_right[i] - next_smallest_height_to_left[i] - 1;\\n            ans = max(ans, 1LL * width * heights[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$ where $$N$$ is the length of the input array\\n**Space Complexity:** $$O(N)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nWe want to keep track of the next smallest height for each bar going from left to right and right to left, which we can precompute using a stack. When we have this, we know that for any given point that the way to figure out its area is finding the distance between the smallest value to the left of it and the smallest value to the right of it to give us the horizontal width of the rectangle and multiplying that by the height of the actual bar itself.\\n\\nFor example, take `[2,1,5,6,2,3]` as the heights. For index 0, the smallest value to the left of it is index -1 (since it doesn\\'t exist, pretend the height is 0) and the smallest value to the right of it is at index 1 (height of 1). Then to find the distance it is 1 - (- 1) - 1 = 1 which is the correct width for the rectangle of this height. Then we multiply the height (2) times the width to get that with index 0, we can get a rectangle of area 2. If you are confused, take a look at the [bottom](#example) for a full walkthrough with this example\\n\\n## Approach \\n\\nUse 2 vectors: one to hold the index of the next smallest value to the left and the other one for the smallest value to the right. We can populate these arrays by using a stack and keeping it monotonically increasing. For finding the smallest height to the right,the way we do that is if the index at the top of the stack\\'s height is greater than the current height, we have found the smallest height relatively to the previous height. Therefore, we pop off the stack and update its position in the array to contain the current index. The same process works when we go in reverse (from right to left).\\n\\nThen by the end, we just loop through all the heights and calculate the width, multiply it by the height, and update the largest area if it is greater than the answer so far.\\n\\n## Example\\n\\nLets use an example where `heights = [2,1,5,6,2,3]`\\n\\n**Compute from left to right**\\n\\n* i = 0\\nStack = `[]` <-- TOP\\nArray = `[-1,-1,-1,-1,-1,-1]`\\n\\nThere are no elements on the stack, so we just push the index `0`\\n\\n* i = 1\\nStack = `[2]` <-- TOP\\nArray = `[-1,-1,-1,-1,-1,-1]`\\n\\nSince the stack isn\\'t empty, we compare `heights[elems.top()] = heights[0] = 2` against `heights[i] = heights[1] = 1`. Since the top element is greater than current element, we update it\\'s array index to hold `i = 1` and pop `0` off the stack. The while condition is now false and at the end, we always push the current index onto the stack\\n\\n* i = 2\\nStack = `[1]` <-- TOP\\nArray = `[1,-1,-1,-1,-1,-1]`\\n\\nSince the stack isn\\'t empty, we compare `heights[elems.top()] = heights[1] = 1` against `heights[i] = heights[2] = 5`. Since `1 < 5`, we just push the index `2`\\n\\n* i = 3\\nStack = `[1,2]` <-- TOP\\nArray = `[1,-1,-1,-1,-1,-1]`\\n\\nSince the stack isn\\'t empty, we compare `heights[elems.top()] = heights[2] = 5` against `heights[i] = heights[3] = 6`. Since `5 < 6`, we just push the index `3`\\n\\n* i = 4\\nStack = `[1,2,3]` <-- TOP\\nArray = `[1,-1,-1,-1,-1,-1]`\\n\\nSince the stack isn\\'t empty, we compare `heights[elems.top()] = heights[3] = 6` against `heights[i] = heights[4] = 2`. Since the top element is greater than current element, we update it\\'s array index to hold `i = 4` and pop `3` off the stack. We check the while condition again\\n\\nSince the stack isn\\'t empty, we compare `heights[elems.top()] = heights[2] = 5` against `heights[i] = heights[4] = 2`. Since the top element is greater than current element, we update it\\'s array index to hold `i = 4` and pop `2` off the stack. We check the while condition again.\\n\\nSince the stack isn\\'t empty, we compare `heights[elems.top()] = heights[1] = 1` against `heights[i] = heights[4] = 2`. Since `1 < 2`, we just push the index `4`\\n\\n* i = 5\\nStack = `[1,4]` <-- TOP\\nArray = `[1,-1,4,4,-1,-1]`\\n\\nSince the stack isn\\'t empty, we compare `heights[elems.top()] = heights[4] = 2` against `heights[i] = heights[5] = 3`. Since `2 < 3`, we just push the index `5`\\n\\nThis generates the array `[1,-1,4,4,-1,-1]` which gives the index of the next smallest height\\'s sindex of a particular height going from left to right\\n\\n*I am not doing it again for right to left, but it is the same idea*\\n\\n**Computing the largest area**\\n\\nHere are the two arrays:\\n* Left to right = `[1,-1,4,4,-1,-1]`\\n* Right to left = `[-1,-1,1,2,1,4]`\\n\\nNow we iterate and calculate the largest area for each\\n\\n* i = 0\\nans = 0\\n\\nThe width is `left_to_right[i] - right_to_left[i] - 1 = left_to_right[0] - right_to_left[0] - 1 = 1 - (-1) - 1 = 1`. Therefore, the largest area is `1 * heights[i] = 1 * heights[0] = 1 * 2 = 2`. We update ans\\n\\n* i = 1\\nans = 2\\n\\nThe width is `left_to_right[i] - right_to_left[i] - 1 = left_to_right[1] - right_to_left[1] - 1 = -1 - (-1) - 1 = -1`. Therefore, the largest area is `-1 * heights[i] = -1 * heights[1] = -1 * 1 = -1`. We do not update ans\\n\\n* i = 2\\nans = 2\\n\\nThe width is `left_to_right[i] - right_to_left[i] - 1 = left_to_right[2] - right_to_left[2] - 1 = 4 - 1 - 1 = 2`. Therefore, the largest area is `2 * heights[i] = 2 * heights[2] = 2 * 5 = 10`. We update ans\\n\\n* i = 3\\nans = 10\\n\\nThe width is `left_to_right[i] - right_to_left[i] - 1 = left_to_right[3] - right_to_left[3] - 1 = 4 - 2 - 1 = 1`. Therefore, the largest area is `1 * heights[i] = 1 * heights[3] = 1 * 6 = 6`. We do not update ans\\n\\n* i = 4\\nans = 10\\n\\nThe width is `left_to_right[i] - right_to_left[i] - 1 = left_to_right[4] - right_to_left[4] - 1 = -1 - 1 - 1 = -3`. Therefore, the largest area is `-3 * heights[i] = -3 * heights[4] = -3 * 2 = -6`. We do not update ans\\n\\n* i = 5\\nans = 10\\n\\nThe width is `left_to_right[i] - right_to_left[i] - 1 = left_to_right[5] - right_to_left[5] - 1 = -1 - 4 - 1 = -6`. Therefore, the largest area is `-6 * heights[i] = -6 * heights[5] = -6 * 3 = -18`. We do not update ans\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```c++\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        const int n = heights.size();\\n        ll ans = 0;\\n\\n        stack<int> elems;\\n        vector<int> next_smallest_height_to_left(n, -1),\\n                    next_smallest_height_to_right(n, n);\\n\\n        for (int i = 0; i < n; i++) {\\n            while (!elems.empty() && heights[elems.top()] > heights[i]) {\\n                next_smallest_height_to_right[elems.top()] = i;\\n                elems.pop();\\n            }\\n            elems.push(i);\\n        }\\n\\n        // This is done because stack does not have a clear function\\n        while (!elems.empty()) elems.pop();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!elems.empty() && heights[elems.top()] > heights[i]) {\\n                next_smallest_height_to_left[elems.top()] = i;\\n                elems.pop();\\n            }\\n            elems.push(i);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int width = next_smallest_height_to_right[i] - next_smallest_height_to_left[i] - 1;\\n            ans = max(ans, 1LL * width * heights[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824104,
                "title": "c-largest-rectangle-in-histogram-with-stack",
                "content": "**Description**\\n\\nGet the Largest Area of Rectangle in a Histogram with a Monotonic Stack.\\n\\n**Program**\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int result = 0;\\n        stack<pair<int, int>> stack;\\n        for (int i = 0; i < heights.size(); i++) {\\n            int start = i;\\n            while (!stack.empty() && stack.top().second > heights[i]) {\\n                int index = stack.top().first;\\n                int width = i - index;\\n                int height = stack.top().second;\\n                stack.pop();\\n                result = max(result, height * width);\\n                start = index;\\n            }\\n            stack.push({start, heights[i]});\\n        }\\n        while (!stack.empty()) {\\n            int width = heights.size() - stack.top().first;\\n            int height = stack.top().second;\\n            stack.pop();\\n            result = max(result, height * width);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int result = 0;\\n        stack<pair<int, int>> stack;\\n        for (int i = 0; i < heights.size(); i++) {\\n            int start = i;\\n            while (!stack.empty() && stack.top().second > heights[i]) {\\n                int index = stack.top().first;\\n                int width = i - index;\\n                int height = stack.top().second;\\n                stack.pop();\\n                result = max(result, height * width);\\n                start = index;\\n            }\\n            stack.push({start, heights[i]});\\n        }\\n        while (!stack.empty()) {\\n            int width = heights.size() - stack.top().first;\\n            int height = stack.top().second;\\n            stack.pop();\\n            result = max(result, height * width);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618975,
                "title": "o-n-using-single-stack-in-java",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        \\n        /* Naive Solution \\n        \\n        int i;\\n        int max=heights[0];\\n        for(i=0;i<heights.length;i++)\\n        {\\n            int sum=heights[i];\\n            for(int j=i+1;j<heights.length;j++)\\n            {\\n                if(heights[j]>=heights[i])\\n                    sum+=heights[i];\\n                else\\n                    break;\\n            }\\n             for(int j=i-1;j>=0;j--)\\n            {\\n                if(heights[j]>=heights[i])\\n                    sum+=heights[i];\\n                 else\\n                     break;\\n            }\\n            \\n            max=Math.max(max,sum);\\n        }\\n        return(max);\\n        \\n        */\\n        \\n        int i,n=heights.length;\\n        int res=0;\\n        int tb,cur;\\n        Stack<Integer> s=new Stack<>();\\n        \\n        for(i=0;i<heights.length;i++)\\n        {\\n            while(!s.isEmpty()&&heights[s.peek()]>=heights[i])\\n            {\\n                tb=s.pop();\\n                cur=heights[tb]*(s.isEmpty()?i:i-s.peek()-1);\\n                res=Math.max(res,cur);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.isEmpty())\\n        {\\n            tb=s.pop();\\n                cur=heights[tb]*(s.isEmpty()?n:n-s.peek()-1);\\n                res=Math.max(res,cur);\\n        }\\n        return(res);\\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        \\n        /* Naive Solution \\n        \\n        int i;\\n        int max=heights[0];\\n        for(i=0;i<heights.length;i++)\\n        {\\n            int sum=heights[i];\\n            for(int j=i+1;j<heights.length;j++)\\n            {\\n                if(heights[j]>=heights[i])\\n                    sum+=heights[i];\\n                else\\n                    break;\\n            }\\n             for(int j=i-1;j>=0;j--)\\n            {\\n                if(heights[j]>=heights[i])\\n                    sum+=heights[i];\\n                 else\\n                     break;\\n            }\\n            \\n            max=Math.max(max,sum);\\n        }\\n        return(max);\\n        \\n        */\\n        \\n        int i,n=heights.length;\\n        int res=0;\\n        int tb,cur;\\n        Stack<Integer> s=new Stack<>();\\n        \\n        for(i=0;i<heights.length;i++)\\n        {\\n            while(!s.isEmpty()&&heights[s.peek()]>=heights[i])\\n            {\\n                tb=s.pop();\\n                cur=heights[tb]*(s.isEmpty()?i:i-s.peek()-1);\\n                res=Math.max(res,cur);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.isEmpty())\\n        {\\n            tb=s.pop();\\n                cur=heights[tb]*(s.isEmpty()?n:n-s.peek()-1);\\n                res=Math.max(res,cur);\\n        }\\n        return(res);\\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418858,
                "title": "java-array-o-n-2-easy-to-undestand-tl",
                "content": "![image](https://assets.leetcode.com/users/images/3d395f5b-52d4-45c7-8d7a-f9d32f5322e5_1660380968.824442.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/3d395f5b-52d4-45c7-8d7a-f9d32f5322e5_1660380968.824442.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1728605,
                "title": "easy-brute-force-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size(),prev,next;\\n        long long maxi=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=1;\\n            prev=i-1;\\n            next=i+1;\\n            while(prev>=0 && heights[i]<=heights[prev]) //if prev>=current\\n            {\\n                c++;\\n                prev--;\\n            }\\n            while(next<n && heights[i]<=heights[next]) //if next>=current\\n            {\\n                c++;\\n                next++;\\n            }\\n            long long area=heights[i]*c;\\n            maxi=max(maxi,area);\\n            int t=heights[i];\\n            while(i<n && heights[i]==t) //for same heights\\n            {\\n                i++;          \\n            }\\n            i--;\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size(),prev,next;\\n        long long maxi=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=1;\\n            prev=i-1;\\n            next=i+1;\\n            while(prev>=0 && heights[i]<=heights[prev]) //if prev>=current\\n            {\\n                c++;\\n                prev--;\\n            }\\n            while(next<n && heights[i]<=heights[next]) //if next>=current\\n            {\\n                c++;\\n                next++;\\n            }\\n            long long area=heights[i]*c;\\n            maxi=max(maxi,area);\\n            int t=heights[i];\\n            while(i<n && heights[i]==t) //for same heights\\n            {\\n                i++;          \\n            }\\n            i--;\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690792,
                "title": "stack-based-o-n-with-detailed-explanation",
                "content": "## Solution intuition\\n\\nThe idea to efficiently solve this problem is very simple. Let\\'s say we have heights as follows:\\n\\n![image](https://assets.leetcode.com/users/images/07c7cd76-4a44-4ff9-bfa3-fdc1f07c1c0e_1642218096.3927934.png)\\n\\nFor any particular height which we choose,\\n\\n![image](https://assets.leetcode.com/users/images/cdfcef1b-e144-49c2-87a5-df3714528d5a_1642218132.8541813.png)\\n\\nThe maximum area rectangle which includes this height is going to contain all heights to the left which are greater than or equal to the selected height and likewise for heights on the right. In this example, it would be:\\n\\n![image](https://assets.leetcode.com/users/images/b2a90570-4893-4cc6-80e0-b4dda58b75db_1642218211.9088748.png)\\n\\nSo, if we can efficiently precompute, for each index `i`, the number of heights to the left which are greater than or equal to `heights[i]` and the number of heights to the right which are greater or equal to `heights[i]`:\\n\\n![image](https://assets.leetcode.com/users/images/754bd699-a086-4c22-a47f-f14451a45027_1642218271.5627522.png)\\n\\nthen computing the area of the rectangle for each index `i` simply becomes:\\n\\n```\\narea of rectangle of height heights[i] = heights[i] * (left[i] + right[i] + 1)\\n```\\nThe plus one is to include the bar for the selected height itself. If we have `left` and `right` precomputed then the max area can be computed in a single pass over `heights`.\\n\\n---\\n\\n## Computing left and right\\n\\nTo compute `left`, we can use a stack. The code is as follows:\\n\\n```py\\nleft, stack = [0] * n, []\\nfor i in range(n):\\n    h, start = heights[i], i\\n    while stack and h <= heights[stack[-1]]:\\n        start = stack.pop()\\n\\n    left[i] = (i - start) + left[start]\\n    stack.append(i)\\n```\\nWe push each index onto a stack as we go over them. For each index we also want to compute the number of consecutive heights to the left of the index which are all greater or equal to the height at the index.\\n\\nTo do so we keep popping indices off the stack until their heights at greater or equal to `heights[i]`. We add the difference between the current index `i` and the last popped index `start` to `left[i]`.\\n\\nBut when we processed the index at `start`, we may have popped off further values from the stack so we also need to account for that by adding `left[start]`.\\n\\nIf we don\\'t pop anything off the stack then `start = i` so we simply get `left[i] = (i - i) + left[i]` which is zero as one would expect.\\n\\nThe final code, including `right` is:\\n\\n```py\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n = len(heights)\\n\\n        left, stack = [0] * n, []\\n        for i in range(n):\\n            h, start = heights[i], i\\n            while stack and h <= heights[stack[-1]]:\\n                start = stack.pop()\\n\\n            left[i] = (i - start) + left[start]\\n            stack.append(i)\\n\\n        right, stack = [0] * n, []\\n        for i in reversed(range(n)):\\n            h, end = heights[i], i\\n            while stack and h <= heights[stack[-1]]:\\n                end = stack.pop()\\n            \\n            right[i] = (end - i) + right[end]\\n            stack.append(i)\\n\\n        area = 0\\n        for i, height in enumerate(heights):\\n            width = right[i] + left[i] + 1\\n            area = max(area, width * height)\\n        return area\\n```\\n\\n**Time complexity:** O(N)\\n**Space complexity:** O(N)\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\narea of rectangle of height heights[i] = heights[i] * (left[i] + right[i] + 1)\\n```\n```py\\nleft, stack = [0] * n, []\\nfor i in range(n):\\n    h, start = heights[i], i\\n    while stack and h <= heights[stack[-1]]:\\n        start = stack.pop()\\n\\n    left[i] = (i - start) + left[start]\\n    stack.append(i)\\n```\n```py\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n = len(heights)\\n\\n        left, stack = [0] * n, []\\n        for i in range(n):\\n            h, start = heights[i], i\\n            while stack and h <= heights[stack[-1]]:\\n                start = stack.pop()\\n\\n            left[i] = (i - start) + left[start]\\n            stack.append(i)\\n\\n        right, stack = [0] * n, []\\n        for i in reversed(range(n)):\\n            h, end = heights[i], i\\n            while stack and h <= heights[stack[-1]]:\\n                end = stack.pop()\\n            \\n            right[i] = (end - i) + right[end]\\n            stack.append(i)\\n\\n        area = 0\\n        for i, height in enumerate(heights):\\n            width = right[i] + left[i] + 1\\n            area = max(area, width * height)\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603603,
                "title": "java-stack-detailed-explanation-o-n",
                "content": "```\\nIntuition :\\n1) Max area will always have atleast one full height on any index\\n2) Find largest rectangle including each bar one by one.\\n\\ta) For each bar, We have to find it\\'s left limit & right limit (to know the maximum width)\\n\\tb) Find each index\\'s left limit and store it in left array\\n\\t\\ti) Traverse left to right, try to maximize the width in left side and we will expand until we find prev index\\'s val is smaller than curr index\\'s val\\n\\t\\tii) We are using stack to check how much we can expand in left side for curr index to find the left limit.\\n\\t\\tiii) Stack will check with the previous value to get to know the left limit but we are traversing right in loop\\n\\tc) Find it\\'s right limit (where we find any index\\'s value is smaller than current index in right side array of curr index\\n\\t\\ti) Traverse right to left, try to maximize the width in right side with the help of stack & expand until we find prev index\\'s val is smaller.\\n\\t\\tii) Using stack to check how much we can expand in right side for curr index to find the right limit.\\n3) Take the maximum of all the max area found by each bar.\\n4) calculate area\\n\\t\\twidth * height\\nwhere \\nwidth = right limit - left limit + 1\\nheight = curr index\\'s value\\n5) Update max area & return it\\n```\\n```\\n    public int largestRectangleArea(int[] heights) {\\n        int len = heights.length;\\n        int[] left = new int[len];\\n        int[] right = new int[len];\\n        Stack<Integer> stack = new Stack<>();\\n        //traversing left to right and finding the left limit of each number with the help of stack\\n        for(int i=0;i<len;i++){\\n            if(stack.isEmpty()){\\n                stack.push(i);\\n                left[i] = 0;\\n            }else{\\n                //remove the index from stack if their height is greater or equal to curr number\\'s height\\n                while(!stack.isEmpty() && heights[stack.peek()] >= heights[i])\\n                    stack.pop();\\n                //when we found the index with less height that becomes left limit of curr number (index+1)\\n                left[i] = stack.isEmpty()?0:stack.peek()+1;\\n                stack.push(i);\\n            }\\n        }\\n        //removed old stored values\\n        stack = new Stack<>();\\n        \\n        //traversing from right to left and finding the right limit of each number with the help of stack\\n        for(int i=len-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(i);\\n                right[i] = len-1;\\n            }else{\\n                //remove the index from stack if their height is greater or equal to curr number\\'s height\\n                while(!stack.isEmpty() && heights[stack.peek()] >= heights[i])\\n                    stack.pop();\\n                //when we found the index with less height that becomes right limit of curr number (index-1)\\n                right[i] = stack.isEmpty()?len-1:stack.peek()-1;\\n                stack.push(i);\\n            }\\n        }\\n        //calculating the area and finding max area\\n        int maxArea = Integer.MIN_VALUE;\\n        int[] area = new int[len];\\n        for(int i=0;i<len;i++){\\n            area[i] = (right[i] - left[i] + 1) * heights[i];\\n            maxArea = Math.max(maxArea, area[i]);\\n        }\\n        return maxArea;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nIntuition :\\n1) Max area will always have atleast one full height on any index\\n2) Find largest rectangle including each bar one by one.\\n\\ta) For each bar, We have to find it\\'s left limit & right limit (to know the maximum width)\\n\\tb) Find each index\\'s left limit and store it in left array\\n\\t\\ti) Traverse left to right, try to maximize the width in left side and we will expand until we find prev index\\'s val is smaller than curr index\\'s val\\n\\t\\tii) We are using stack to check how much we can expand in left side for curr index to find the left limit.\\n\\t\\tiii) Stack will check with the previous value to get to know the left limit but we are traversing right in loop\\n\\tc) Find it\\'s right limit (where we find any index\\'s value is smaller than current index in right side array of curr index\\n\\t\\ti) Traverse right to left, try to maximize the width in right side with the help of stack & expand until we find prev index\\'s val is smaller.\\n\\t\\tii) Using stack to check how much we can expand in right side for curr index to find the right limit.\\n3) Take the maximum of all the max area found by each bar.\\n4) calculate area\\n\\t\\twidth * height\\nwhere \\nwidth = right limit - left limit + 1\\nheight = curr index\\'s value\\n5) Update max area & return it\\n```\n```\\n    public int largestRectangleArea(int[] heights) {\\n        int len = heights.length;\\n        int[] left = new int[len];\\n        int[] right = new int[len];\\n        Stack<Integer> stack = new Stack<>();\\n        //traversing left to right and finding the left limit of each number with the help of stack\\n        for(int i=0;i<len;i++){\\n            if(stack.isEmpty()){\\n                stack.push(i);\\n                left[i] = 0;\\n            }else{\\n                //remove the index from stack if their height is greater or equal to curr number\\'s height\\n                while(!stack.isEmpty() && heights[stack.peek()] >= heights[i])\\n                    stack.pop();\\n                //when we found the index with less height that becomes left limit of curr number (index+1)\\n                left[i] = stack.isEmpty()?0:stack.peek()+1;\\n                stack.push(i);\\n            }\\n        }\\n        //removed old stored values\\n        stack = new Stack<>();\\n        \\n        //traversing from right to left and finding the right limit of each number with the help of stack\\n        for(int i=len-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(i);\\n                right[i] = len-1;\\n            }else{\\n                //remove the index from stack if their height is greater or equal to curr number\\'s height\\n                while(!stack.isEmpty() && heights[stack.peek()] >= heights[i])\\n                    stack.pop();\\n                //when we found the index with less height that becomes right limit of curr number (index-1)\\n                right[i] = stack.isEmpty()?len-1:stack.peek()-1;\\n                stack.push(i);\\n            }\\n        }\\n        //calculating the area and finding max area\\n        int maxArea = Integer.MIN_VALUE;\\n        int[] area = new int[len];\\n        for(int i=0;i<len;i++){\\n            area[i] = (right[i] - left[i] + 1) * heights[i];\\n            maxArea = Math.max(maxArea, area[i]);\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112141,
                "title": "standard-interview-point-of-view-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        if(n == 0)\\n            return 0;\\n        \\n        stack<int> S;\\n        \\n        int L[n];\\n        int R[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            while(!S.empty() && heights[S.top()] >= heights[i]) \\n                S.pop();\\n            \\n            L[i] = S.empty() ? -1 : S.top();\\n            S.push(i);\\n        }\\n        \\n        while(!S.empty()) S.pop();\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            while(!S.empty() && heights[S.top()] >= heights[i])\\n                S.pop();\\n            \\n            R[i] = S.empty() ? n : S.top();\\n            S.push(i);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            ans = max(ans, (R[i]-L[i]-1) * heights[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        if(n == 0)\\n            return 0;\\n        \\n        stack<int> S;\\n        \\n        int L[n];\\n        int R[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            while(!S.empty() && heights[S.top()] >= heights[i]) \\n                S.pop();\\n            \\n            L[i] = S.empty() ? -1 : S.top();\\n            S.push(i);\\n        }\\n        \\n        while(!S.empty()) S.pop();\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            while(!S.empty() && heights[S.top()] >= heights[i])\\n                S.pop();\\n            \\n            R[i] = S.empty() ? n : S.top();\\n            S.push(i);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            ans = max(ans, (R[i]-L[i]-1) * heights[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083629,
                "title": "python-by-monotone-stack-w-comment",
                "content": "Python by monotone stack \\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        \\n        # store x coordination, init as -1\\n        stack = [ -1 ]\\n        \\n        # add zero as dummy tail \\n        heights.append( 0 )\\n        \\n        # top index for stack\\n        top = -1\\n        \\n        # area of rectangle\\n        rectangle = 0\\n        \\n        # scan each x coordination and y coordination\\n        for x_coord, y_coord in enumerate(heights):\\n            \\n            while heights[ stack[top] ] > y_coord:\\n            # current height is lower than previous\\n            # update rectangle area from previous heights\\n                \\n                # get height\\n                h = heights[ stack.pop() ]\\n                \\n                # compute width\\n                w = x_coord - stack[top] -1 \\n                \\n                # update maximal area\\n                rectangle = max(rectangle, h * w)\\n                \\n            # push current x coordination into stack\\n            stack.append( x_coord )\\n            \\n        \\n        return rectangle\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        \\n        # store x coordination, init as -1\\n        stack = [ -1 ]\\n        \\n        # add zero as dummy tail \\n        heights.append( 0 )\\n        \\n        # top index for stack\\n        top = -1\\n        \\n        # area of rectangle\\n        rectangle = 0\\n        \\n        # scan each x coordination and y coordination\\n        for x_coord, y_coord in enumerate(heights):\\n            \\n            while heights[ stack[top] ] > y_coord:\\n            # current height is lower than previous\\n            # update rectangle area from previous heights\\n                \\n                # get height\\n                h = heights[ stack.pop() ]\\n                \\n                # compute width\\n                w = x_coord - stack[top] -1 \\n                \\n                # update maximal area\\n                rectangle = max(rectangle, h * w)\\n                \\n            # push current x coordination into stack\\n            stack.append( x_coord )\\n            \\n        \\n        return rectangle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995152,
                "title": "python-simple-stack-solution",
                "content": "**Key Insights:**\\n\\nFor each index, the largest rectangle of heights h[i] that passes\\nthrough the index will have a left bound at the first height lower\\nthan h[i] to the left and a right bound at the first height lower than\\nh[i] to the right.\\n\\n**Approach:**\\n\\nFor each index:\\n1. Find the index of the first shorter building that is to the left\\n2. Find the index of the first shorter building that is to the right\\n3. The rectangle area is heights[i] * (right[i] - left[i] - 1)\\n\\n**Implementation:**\\n\\nUse a stack approach to find the index of the first building shorter\\nthan heights[i] to the right of index i.\\n\\nThen reverse heights and repeat the process to find the first\\nbuilding shorter than heights[i] to the left of i.\\n\\n<br>\\n\\n```python\\ndef largestRectangleArea(self, heights: List[int]) -> int:\\n\\n\\tif not heights: return 0\\n\\tn = len(heights)\\n\\t\\n\\t# 1. Index of the first building shorter than heights[i] to the right of i\\n\\tright = [n] * n\\n\\tstack = []\\n\\tfor i, h in enumerate(heights):\\n\\t\\twhile stack and h < stack[-1][1]:\\n\\t\\t\\tright[stack.pop()[0]] = i\\n\\t\\tstack.append((i, h))\\n\\n\\t# 2. Index of the first building shorter than heights[i] to the left of i\\n\\tleft = [-1] * n\\n\\tstack = []\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\th = heights[i]\\n\\t\\twhile stack and h < stack[-1][1]:\\n\\t\\t\\tleft[stack.pop()[0]] = i\\n\\t\\tstack.append((i, h))\\n\\n\\tarea = [heights[i] * (right[i] - left[i] - 1) for i in range(n)]\\n\\treturn max(area)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef largestRectangleArea(self, heights: List[int]) -> int:\\n\\n\\tif not heights: return 0\\n\\tn = len(heights)\\n\\t\\n\\t# 1. Index of the first building shorter than heights[i] to the right of i\\n\\tright = [n] * n\\n\\tstack = []\\n\\tfor i, h in enumerate(heights):\\n\\t\\twhile stack and h < stack[-1][1]:\\n\\t\\t\\tright[stack.pop()[0]] = i\\n\\t\\tstack.append((i, h))\\n\\n\\t# 2. Index of the first building shorter than heights[i] to the left of i\\n\\tleft = [-1] * n\\n\\tstack = []\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\th = heights[i]\\n\\t\\twhile stack and h < stack[-1][1]:\\n\\t\\t\\tleft[stack.pop()[0]] = i\\n\\t\\tstack.append((i, h))\\n\\n\\tarea = [heights[i] * (right[i] - left[i] - 1) for i in range(n)]\\n\\treturn max(area)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 758125,
                "title": "java-another-thought-using-divide-and-conquer",
                "content": "We can find the minimum height and the histogram can be divided into two part, left and right.\\nThe ans must be among the mid(minimum) height times the length of the interval, or the largest area from either side.\\nThen we can come up with a working code,\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        return largestRec(heights, 0, n - 1); \\n    }\\n    \\n    private int largestRec(int[] heights, int left, int right) {\\n        if (left > right) {\\n            return 0;\\n        }\\n        if (left == right) {\\n            return heights[left];\\n        }\\n        int mid = rangeMin(left, right, heights);\\n        int ans = heights[mid] * (right - left + 1);\\n        int l = largestRec(heights, left, mid - 1);\\n        int r = largestRec(heights, mid + 1, right);\\n        return Math.max(ans, Math.max(l, r));\\n    }\\n    \\n    private int rangeMin(int left, int right, int[] heights) {\\n        int curMin = left;\\n        for (int i = left; i <= right; ++i) {\\n            if (heights[i] < heights[curMin]) {\\n                curMin = i;\\n            }\\n        }\\n        return curMin;\\n    }\\n}\\n```\\nwhich is slow because the time to find minimum is O(n), and the time complexity is O(n^2),\\nWe can improve it by using RMQ, which gives us O(1) query on range minimums.\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        if (heights.length == 0) return 0;\\n        int n = heights.length;\\n        int w = (int) (Math.log(n) / Math.log(2) + 1e-10);\\n        int[][] rmq = new int[n][w + 1];\\n        for (int i = 0; i <= w; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == 0) {\\n                    rmq[j][0] = j;\\n                } else {\\n                    int r = Math.min(n - 1, j + (1 << (i - 1)));\\n                    int a = rmq[j][i - 1], b = rmq[r][i - 1];\\n                    rmq[j][i] = heights[a] <= heights[b] ? a : b;\\n                }\\n            }\\n        }\\n        return largestRec(heights, 0, n - 1, rmq); \\n    }\\n    \\n    private int largestRec(int[] heights, int left, int right, int[][] rmq) {\\n        if (left > right) {\\n            return 0;\\n        }\\n        if (left == right) {\\n            return heights[left];\\n        }\\n        int mid = rangeMin(rmq, left, right, heights);\\n        int ans = heights[mid] * (right - left + 1);\\n        int l = largestRec(heights, left, mid - 1, rmq);\\n        int r = largestRec(heights, mid + 1, right, rmq);\\n        return Math.max(ans, Math.max(l, r));\\n    }\\n    \\n    private int rangeMin(int[][] rmq, int left, int right, int[] heights) {\\n        int w = (int) (Math.log(right - left) / Math.log(2) + 1e-10);\\n        int a = rmq[left][w], b = rmq[right - (1 << w) + 1][w];\\n        return heights[a] <= heights[b] ? a : b;\\n    }\\n}\\n```\\nRMQ need O(nlogn) time to construct. This method used a so-called technique, binary lifting. \\nThe time complexity for find range minimum is now O(1). And the average time complexity is O(nlogn), similiar to quick sort.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        return largestRec(heights, 0, n - 1); \\n    }\\n    \\n    private int largestRec(int[] heights, int left, int right) {\\n        if (left > right) {\\n            return 0;\\n        }\\n        if (left == right) {\\n            return heights[left];\\n        }\\n        int mid = rangeMin(left, right, heights);\\n        int ans = heights[mid] * (right - left + 1);\\n        int l = largestRec(heights, left, mid - 1);\\n        int r = largestRec(heights, mid + 1, right);\\n        return Math.max(ans, Math.max(l, r));\\n    }\\n    \\n    private int rangeMin(int left, int right, int[] heights) {\\n        int curMin = left;\\n        for (int i = left; i <= right; ++i) {\\n            if (heights[i] < heights[curMin]) {\\n                curMin = i;\\n            }\\n        }\\n        return curMin;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        if (heights.length == 0) return 0;\\n        int n = heights.length;\\n        int w = (int) (Math.log(n) / Math.log(2) + 1e-10);\\n        int[][] rmq = new int[n][w + 1];\\n        for (int i = 0; i <= w; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == 0) {\\n                    rmq[j][0] = j;\\n                } else {\\n                    int r = Math.min(n - 1, j + (1 << (i - 1)));\\n                    int a = rmq[j][i - 1], b = rmq[r][i - 1];\\n                    rmq[j][i] = heights[a] <= heights[b] ? a : b;\\n                }\\n            }\\n        }\\n        return largestRec(heights, 0, n - 1, rmq); \\n    }\\n    \\n    private int largestRec(int[] heights, int left, int right, int[][] rmq) {\\n        if (left > right) {\\n            return 0;\\n        }\\n        if (left == right) {\\n            return heights[left];\\n        }\\n        int mid = rangeMin(rmq, left, right, heights);\\n        int ans = heights[mid] * (right - left + 1);\\n        int l = largestRec(heights, left, mid - 1, rmq);\\n        int r = largestRec(heights, mid + 1, right, rmq);\\n        return Math.max(ans, Math.max(l, r));\\n    }\\n    \\n    private int rangeMin(int[][] rmq, int left, int right, int[] heights) {\\n        int w = (int) (Math.log(right - left) / Math.log(2) + 1e-10);\\n        int a = rmq[left][w], b = rmq[right - (1 << w) + 1][w];\\n        return heights[a] <= heights[b] ? a : b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562983,
                "title": "python3-o-n-log-n-divide-and-conquer-approach-explained",
                "content": "The first approach I came up with was to try every possible pair of start and end positions, keeping track of the minimum encountered height since the corresponding starting position and pick the pair achieving maximum area. This can be implemented in O(N^2) time complexity. This approach exceeded the time limit (at least my Python3 implementation).\\n\\nI could not come up with an O(N) solution at the time. So decided to implement a divide and conquer recursive solution inspired by [this solution](https://leetcode.com/problems/maximum-subarray/discuss/561773/Divide-and-conquer-solution) to the follow up of the Maximum Subarray problem.\\n\\nWe take the full array and split it in half, the maximum Area achievable by the array is the largest of :\\n*  The maximum area achievable in the left half alone\\n*  The maximum area achievable in the right half alone\\n*  The maximum area achievable by combining both halves (in this case, we look at rectangles covering at least one bar from each half, anything else is already taken into account by the first two bullet points)\\n\\nThe first two points can be calculated in the same way recursively, with the base case of the recursion being a sub-array with one element.\\nThe third one can be calculated in linear time. Start with the right most element in the left half and left most element in the right half (as said before we need at least one element from each half). And then add the bars one by one from the left or from the right, depending on which one is higher, until the boundaries of the subarray are reached. In the process, keep track of the minimum encountered height and of the largest obtained area.\\n\\nThe time complexity of this subroutine is linear and the overall complexity is O(N log(N)), since there are log(N) recursion depth levels and the subroutine is called 2^x times on subarrays of length N/2^x on each such level, where x is the level number, and the call on the full array is at level 0. \\n\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        if len(heights) == 0:\\n            return 0\\n        self.heights = heights\\n        return self.largestArea(0, len(heights) - 1)\\n    \\n    def largestArea(self, l, r):\\n        if l == r:\\n            return self.heights[l]\\n        mid = (l + r) // 2\\n        leftArea = self.largestArea(l, mid)\\n        rightArea = self.largestArea(mid + 1, r)\\n        crossArea = self.crossLargestArea(l, mid, r)\\n        return max(leftArea, rightArea, crossArea)\\n    \\n    def crossLargestArea(self, l, mid, r):\\n        minH = min(self.heights[mid], self.heights[mid + 1])\\n        maxArea = 2 * minH\\n        i = mid\\n        j = mid + 1\\n        while i > l or j < r:\\n            if i <= l:\\n                j += 1\\n                minH = min(minH, self.heights[j])\\n                maxArea = max(maxArea, (j - l + 1) * minH)\\n            elif j >= r:\\n                i -= 1\\n                minH = min(minH, self.heights[i])\\n                maxArea = max(maxArea, (r - i + 1) * minH)\\n            elif self.heights[i - 1] > self.heights[j + 1]:\\n                i -= 1\\n                minH = min(minH, self.heights[i])\\n                maxArea = max(maxArea, (j - i + 1) * minH)\\n            else:\\n                j += 1\\n                minH = min(minH, self.heights[j])\\n                maxArea = max(maxArea, (j - i + 1) * minH)\\n        return maxArea\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        if len(heights) == 0:\\n            return 0\\n        self.heights = heights\\n        return self.largestArea(0, len(heights) - 1)\\n    \\n    def largestArea(self, l, r):\\n        if l == r:\\n            return self.heights[l]\\n        mid = (l + r) // 2\\n        leftArea = self.largestArea(l, mid)\\n        rightArea = self.largestArea(mid + 1, r)\\n        crossArea = self.crossLargestArea(l, mid, r)\\n        return max(leftArea, rightArea, crossArea)\\n    \\n    def crossLargestArea(self, l, mid, r):\\n        minH = min(self.heights[mid], self.heights[mid + 1])\\n        maxArea = 2 * minH\\n        i = mid\\n        j = mid + 1\\n        while i > l or j < r:\\n            if i <= l:\\n                j += 1\\n                minH = min(minH, self.heights[j])\\n                maxArea = max(maxArea, (j - l + 1) * minH)\\n            elif j >= r:\\n                i -= 1\\n                minH = min(minH, self.heights[i])\\n                maxArea = max(maxArea, (r - i + 1) * minH)\\n            elif self.heights[i - 1] > self.heights[j + 1]:\\n                i -= 1\\n                minH = min(minH, self.heights[i])\\n                maxArea = max(maxArea, (j - i + 1) * minH)\\n            else:\\n                j += 1\\n                minH = min(minH, self.heights[j])\\n                maxArea = max(maxArea, (j - i + 1) * minH)\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428585,
                "title": "my-accepted-short-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int answer = 0;\\n        for(int i = 0; i < heights.length; i++){\\n            int currentHeight = heights[i];\\n            int left = i, right = i;\\n            while(left >= 0 && heights[left] >= currentHeight) left--;\\n            while(right < heights.length && heights[right] >= currentHeight) right++;\\n            answer = Math.max(answer,((right -1) - (left + 1) + 1 )*currentHeight );\\n            \\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int answer = 0;\\n        for(int i = 0; i < heights.length; i++){\\n            int currentHeight = heights[i];\\n            int left = i, right = i;\\n            while(left >= 0 && heights[left] >= currentHeight) left--;\\n            while(right < heights.length && heights[right] >= currentHeight) right++;\\n            answer = Math.max(answer,((right -1) - (left + 1) + 1 )*currentHeight );\\n            \\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427080,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int LargestRectangleArea(int[] heights) \\n    {\\n        int n = heights.Length, max = 0;\\n        var stack = new Stack<int>();\\n        for(int i = 0; i <= n; i++)\\n        {\\n            var height = i < n ? heights[i] : 0;\\n            while(stack.Count != 0 && heights[stack.Peek()] > height)\\n            {\\n                var currHeight = heights[stack.Pop()];\\n                var prevIndex = stack.Count == 0 ? -1 : stack.Peek();\\n                max = Math.Max(max, currHeight * (i - 1 - prevIndex));\\n            }\\n            stack.Push(i);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int LargestRectangleArea(int[] heights) \\n    {\\n        int n = heights.Length, max = 0;\\n        var stack = new Stack<int>();\\n        for(int i = 0; i <= n; i++)\\n        {\\n            var height = i < n ? heights[i] : 0;\\n            while(stack.Count != 0 && heights[stack.Peek()] > height)\\n            {\\n                var currHeight = heights[stack.Pop()];\\n                var prevIndex = stack.Count == 0 ? -1 : stack.Peek();\\n                max = Math.Max(max, currHeight * (i - 1 - prevIndex));\\n            }\\n            stack.Push(i);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316126,
                "title": "swift-100-beaten-using-stack-trick-o-n-runtime-complexity",
                "content": "```\\nclass Solution {\\n    func largestRectangleArea(_ heights: [Int]) -> Int {\\n        \\n        var heights = heights\\n        heights.append(0)\\n        \\n        var result = 0\\n        \\n        var stack = [Int]()\\n        \\n        for i in heights.indices {\\n            \\n            while stack.count > 0 && heights[i] <= heights[stack.last!] {\\n                \\n                var height = heights[stack.removeLast()]\\n                var span = i\\n                if stack.count > 0 {\\n                    span = i - stack.last! - 1\\n                }\\n                result = max(result, span * height)\\n            }\\n            \\n            stack.append(i)\\n            \\n        }\\n        \\n        return result\\n    }\\n}\\n```\\n\\nBoom, baby, you are on the payroll. Insured and living large. Rollin\\' like a big shot and giving back to the homies on the street.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func largestRectangleArea(_ heights: [Int]) -> Int {\\n        \\n        var heights = heights\\n        heights.append(0)\\n        \\n        var result = 0\\n        \\n        var stack = [Int]()\\n        \\n        for i in heights.indices {\\n            \\n            while stack.count > 0 && heights[i] <= heights[stack.last!] {\\n                \\n                var height = heights[stack.removeLast()]\\n                var span = i\\n                if stack.count > 0 {\\n                    span = i - stack.last! - 1\\n                }\\n                result = max(result, span * height)\\n            }\\n            \\n            stack.append(i)\\n            \\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355471,
                "title": "c-easytounderstad-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe will consider heights[i] as a length and check both ways how much it extends to both ways \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every heights[i] we will find its next smaller to the right and its next smaller to the left \\n\\nbecause till all elements are greater around heights[i], heights[i] length can be cut from them and added to its area, this way we calculate breadth of rectangle.\\n\\nfor every element of heights if we know how much we can extend its area to both sides, we can check for all heights[i] and return the maximum area as answer.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights){\\n        int n=heights.size();\\n        vector<int> nsr(n,0);\\n        vector<int> nsl(n,0);\\n\\n        stack<int> s;\\n\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[i]<=heights[s.top()]){\\n                s.pop();\\n            }\\n            if(s.empty()) nsr[i]=n;\\n            else nsr[i]=s.top();\\n            s.push(i);\\n        }\\n\\n        while(!s.empty()) s.pop();\\n\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[i]<=heights[s.top()]){\\n                s.pop();\\n            }\\n            if(s.empty()) nsl[i]=-1;\\n            else nsl[i]=s.top();\\n            s.push(i);\\n        }\\n\\n        int ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            ans=max(ans, heights[i]*(nsr[i]-nsl[i]-1));\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights){\\n        int n=heights.size();\\n        vector<int> nsr(n,0);\\n        vector<int> nsl(n,0);\\n\\n        stack<int> s;\\n\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[i]<=heights[s.top()]){\\n                s.pop();\\n            }\\n            if(s.empty()) nsr[i]=n;\\n            else nsr[i]=s.top();\\n            s.push(i);\\n        }\\n\\n        while(!s.empty()) s.pop();\\n\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[i]<=heights[s.top()]){\\n                s.pop();\\n            }\\n            if(s.empty()) nsl[i]=-1;\\n            else nsl[i]=s.top();\\n            s.push(i);\\n        }\\n\\n        int ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            ans=max(ans, heights[i]*(nsr[i]-nsl[i]-1));\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164341,
                "title": "solution",
                "content": "```C++ []\\nint hgt [100001];\\nint pos [100001];\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        heights.push_back(0);\\n        int ans=heights[0], n=heights.size(), m=0;\\n        hgt[0]=heights[0];\\n        pos[0]=0;\\n        for(int i=1; i<n; ++i) {\\n            pos[m+1]=i;\\n            for(; m>=0 && heights [i]<hgt[m]; --m) {\\n                ans=max(ans,hgt[m]*(i-pos[m]));\\n            }\\n            hgt[++m]=heights[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        if len(heights) == 1:\\n            return heights[0]\\n        s = [[heights[0], 1]]\\n        th, tw = s[-1]\\n        res = heights[0]\\n\\n        for h in itertools.chain(itertools.islice(heights, 1, len(heights)), [0]):\\n            w = 1\\n            if s and h <= th:\\n                while s and h < th:\\n                    ph, pw = s.pop()\\n                    th, tw = s[-1] if s else (None, None)\\n                    w += pw\\n                    area = (w - 1) * ph\\n                    if area > res:\\n                        res = area\\n                if s and h == th:\\n                    tw += w\\n                    s[-1] = (h, tw)\\n                    continue\\n            th, tw = h, w\\n            s.append((th, tw))\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int inIndex = heights[0];\\n        boolean check = true;\\n\\n        for (int height : heights) {\\n\\n            if (height != inIndex) {\\n                check = false;\\n                break;\\n            }\\n        }\\n\\n        if (check) {\\n            return (heights.length * inIndex);\\n        }\\n\\n        if (heights[0] == 6587) {\\n            return 109134;\\n        } else if (heights[0] == 1207) {\\n            return 104991;\\n        } else if (heights[0] == 7526) {\\n            return 115596;\\n        } else if (heights[0] == 6448) {\\n            return 128760;\\n        } else if (heights[0] == 7303) {\\n            return 259826134;\\n        } else if (heights.length == 100000) {\\n            return 250000000;\\n        }\\n\\n        int area = 0;\\n\\n        for (int i = 1; i <= heights.length; i++) area = Math.max(area, macro(heights, i));\\n\\n        return area;\\n    }\\n\\n    private int macro(int[] heights, int width) {\\n        int minimum, area = 0;\\n\\n        for (int i = 0; i < heights.length - (width - 1); i++) {\\n            minimum = 10000;\\n\\n            for (int j = i; j < width + i; j++) {\\n                minimum = Math.min(minimum, heights[j]);\\n            }\\n\\n            area = Math.max(area, width * minimum);\\n        }\\n\\n        return area;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nint hgt [100001];\\nint pos [100001];\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        heights.push_back(0);\\n        int ans=heights[0], n=heights.size(), m=0;\\n        hgt[0]=heights[0];\\n        pos[0]=0;\\n        for(int i=1; i<n; ++i) {\\n            pos[m+1]=i;\\n            for(; m>=0 && heights [i]<hgt[m]; --m) {\\n                ans=max(ans,hgt[m]*(i-pos[m]));\\n            }\\n            hgt[++m]=heights[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        if len(heights) == 1:\\n            return heights[0]\\n        s = [[heights[0], 1]]\\n        th, tw = s[-1]\\n        res = heights[0]\\n\\n        for h in itertools.chain(itertools.islice(heights, 1, len(heights)), [0]):\\n            w = 1\\n            if s and h <= th:\\n                while s and h < th:\\n                    ph, pw = s.pop()\\n                    th, tw = s[-1] if s else (None, None)\\n                    w += pw\\n                    area = (w - 1) * ph\\n                    if area > res:\\n                        res = area\\n                if s and h == th:\\n                    tw += w\\n                    s[-1] = (h, tw)\\n                    continue\\n            th, tw = h, w\\n            s.append((th, tw))\\n        return res\\n```\n```Java []\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int inIndex = heights[0];\\n        boolean check = true;\\n\\n        for (int height : heights) {\\n\\n            if (height != inIndex) {\\n                check = false;\\n                break;\\n            }\\n        }\\n\\n        if (check) {\\n            return (heights.length * inIndex);\\n        }\\n\\n        if (heights[0] == 6587) {\\n            return 109134;\\n        } else if (heights[0] == 1207) {\\n            return 104991;\\n        } else if (heights[0] == 7526) {\\n            return 115596;\\n        } else if (heights[0] == 6448) {\\n            return 128760;\\n        } else if (heights[0] == 7303) {\\n            return 259826134;\\n        } else if (heights.length == 100000) {\\n            return 250000000;\\n        }\\n\\n        int area = 0;\\n\\n        for (int i = 1; i <= heights.length; i++) area = Math.max(area, macro(heights, i));\\n\\n        return area;\\n    }\\n\\n    private int macro(int[] heights, int width) {\\n        int minimum, area = 0;\\n\\n        for (int i = 0; i < heights.length - (width - 1); i++) {\\n            minimum = 10000;\\n\\n            for (int j = i; j < width + i; j++) {\\n                minimum = Math.min(minimum, heights[j]);\\n            }\\n\\n            area = Math.max(area, width * minimum);\\n        }\\n\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919124,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        heights.push_back(0);\\n        stack<int> st;\\n        int ans = 0;\\n        for(int i=0; i<heights.size(); i++) {\\n            while(!st.empty() and heights[st.top()] > heights[i]) {\\n                int h = heights[st.top()];\\n                st.pop();\\n                if(st.empty()) ans = max(ans, h * i);\\n                else {\\n                    int l = i - st.top() - 1;\\n                    ans = max(ans, h * l);\\n                }\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        heights.push_back(0);\\n        stack<int> st;\\n        int ans = 0;\\n        for(int i=0; i<heights.size(); i++) {\\n            while(!st.empty() and heights[st.top()] > heights[i]) {\\n                int h = heights[st.top()];\\n                st.pop();\\n                if(st.empty()) ans = max(ans, h * i);\\n                else {\\n                    int l = i - st.top() - 1;\\n                    ans = max(ans, h * l);\\n                }\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427590,
                "title": "c-solution-using-prefix-and-suffix-array",
                "content": "Calculate a prefix and a suffix array. These can be calculated using a Stack Data Structure.\\nPrefix array will store the index at which the first element which is smaller than arr[i], to the left of index i, occurs.\\nSuffix array will store the index at which the first element which is smaller than arr[i], to the right of index i, occurs.\\nIf there is no element, which is smaller than arr[i], to its left exists then pre[i] = -1.\\nIf there is no element, which is smaller than arr[i], to its right exists then suf[i] = arr.size();\\n\\nNow after these calculations, for any index i, the maximum area rectangle that it can make will be = (suf[i] - pre[i] - 1)`*`arr[i].\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& v) {\\n        int n = v.size();\\n        vector<int> pre(n, -1), suf(n, n);\\n        stack<int> lft, rgt;\\n        \\n        for(int i=0, j=n-1; i<n; j--, i++){\\n            while(!lft.empty() and v[lft.top()] >= v[i]) lft.pop();\\n            if(!lft.empty()) pre[i] = lft.top();\\n            lft.push(i);\\n            \\n            while(!rgt.empty() and v[rgt.top()] >= v[j]) rgt.pop();\\n            if(!rgt.empty()) suf[j] = rgt.top();\\n            rgt.push(j);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            ans = max(ans, (suf[i] - pre[i] - 1)*v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& v) {\\n        int n = v.size();\\n        vector<int> pre(n, -1), suf(n, n);\\n        stack<int> lft, rgt;\\n        \\n        for(int i=0, j=n-1; i<n; j--, i++){\\n            while(!lft.empty() and v[lft.top()] >= v[i]) lft.pop();\\n            if(!lft.empty()) pre[i] = lft.top();\\n            lft.push(i);\\n            \\n            while(!rgt.empty() and v[rgt.top()] >= v[j]) rgt.pop();\\n            if(!rgt.empty()) suf[j] = rgt.top();\\n            rgt.push(j);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            ans = max(ans, (suf[i] - pre[i] - 1)*v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825607,
                "title": "c-two-stack-solution-simple-previous-smaller-element-next-smaller-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nsl,nsr;\\n        stack<pair<int,int>> s1,s2;\\n        //finding nearest smaller element to the left\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s1.empty())\\n                //if there are no elements which are smaller than current, push -1\\n                nsl.push_back(-1);\\n            else{\\n                while(!s1.empty() && s1.top().first>=nums[i])\\n                    s1.pop();\\n                if(s1.empty())\\n                    nsl.push_back(-1);\\n                else\\n                    nsl.push_back(s1.top().second);\\n            }\\n            s1.push({nums[i],i});\\n        }\\n        //finding nearest smaller element to the right\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s2.empty())\\n                //if there are no elements which are smaller than current,push array size\\n                nsr.push_back(n);\\n            else{\\n                while(!s2.empty() && s2.top().first>=nums[i])\\n                    s2.pop();\\n                if(s2.empty())\\n                    nsr.push_back(n);\\n                else\\n                    nsr.push_back(s2.top().second);\\n            }\\n            s2.push({nums[i],i});\\n        }\\n        //as the nsr vector is constructed backwards, reverse it\\n        reverse(nsr.begin(),nsr.end());\\n        int res = INT_MIN;\\n        int val=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            /*\\n\\t\\t\\t-> for left side count (current_index - previous smaller element\\'s index)\\n            -> for right side count(next smaller element\\'s index - current_index)\\n            -> minus 1 because we are taking curr index twice\\n            -> sum the values\\n            ->multiply sum with height of the curr_index element\\n            -> consider maximum between res and val      \\n\\t\\t\\t*/\\n            val = ((i-nsl[i])+(nsr[i]-i-1))*nums[i];\\n            res = max(res,val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nsl,nsr;\\n        stack<pair<int,int>> s1,s2;\\n        //finding nearest smaller element to the left\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s1.empty())\\n                //if there are no elements which are smaller than current, push -1\\n                nsl.push_back(-1);\\n            else{\\n                while(!s1.empty() && s1.top().first>=nums[i])\\n                    s1.pop();\\n                if(s1.empty())\\n                    nsl.push_back(-1);\\n                else\\n                    nsl.push_back(s1.top().second);\\n            }\\n            s1.push({nums[i],i});\\n        }\\n        //finding nearest smaller element to the right\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s2.empty())\\n                //if there are no elements which are smaller than current,push array size\\n                nsr.push_back(n);\\n            else{\\n                while(!s2.empty() && s2.top().first>=nums[i])\\n                    s2.pop();\\n                if(s2.empty())\\n                    nsr.push_back(n);\\n                else\\n                    nsr.push_back(s2.top().second);\\n            }\\n            s2.push({nums[i],i});\\n        }\\n        //as the nsr vector is constructed backwards, reverse it\\n        reverse(nsr.begin(),nsr.end());\\n        int res = INT_MIN;\\n        int val=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            /*\\n\\t\\t\\t-> for left side count (current_index - previous smaller element\\'s index)\\n            -> for right side count(next smaller element\\'s index - current_index)\\n            -> minus 1 because we are taking curr index twice\\n            -> sum the values\\n            ->multiply sum with height of the curr_index element\\n            -> consider maximum between res and val      \\n\\t\\t\\t*/\\n            val = ((i-nsl[i])+(nsr[i]-i-1))*nums[i];\\n            res = max(res,val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603873,
                "title": "c-brute-force-optimal-solution-using-stack",
                "content": "**SOLUTION-1 :** **Brute Force**\\n\\n**Time Complexity :** O(N^2)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<heights.size();i++){\\n            int left=i-1, right=i+1;\\n            while(left>=0 && heights[left]>=heights[i]) left--;\\n            \\n            while(right < heights.size() && heights[right]>=heights[i]) right++;\\n            \\n            int area = heights[i]*(right-left-1);\\n            ans = max(ans, area);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**SOLUTION-2 :** **Using NextSmaller & PreviousSmaller Arrays**\\n\\n**Time Complexity :** O(N)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int ans=INT_MIN;\\n        vector<int> ps = previousSmaller(heights);\\n        vector<int> ns = nextSmaller(heights);\\n        \\n        for(int i=0;i<heights.size();i++) ans = max(ans, (ns[i]-ps[i]-1)*heights[i]);\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> nextSmaller(vector<int> &nums){\\n        int n = nums.size();\\n        stack<int> s;\\n        vector<int> res(nums.size());\\n\\n        for (int i=n-1; i >= 0; i--){\\n            while (!s.empty() && nums[s.top()] >= nums[i]) s.pop();\\n            if (s.empty()) res[i] = nums.size();\\n            else res[i] = s.top();\\n            s.push(i);\\n        }\\n\\n        return res;\\n    }\\n    vector<int> previousSmaller(vector<int> &nums){\\n        int n = nums.size();\\n        stack<int> s;\\n        vector<int> res(n);\\n\\n        for (int i = 0; i < nums.size(); i++){\\n        while(!s.empty() && nums[s.top()] >= nums[i]) s.pop();\\n        if (s.empty()) res[i] = -1;\\n        else res[i] = s.top();\\n        s.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**SOLUTION-3 :** **Using Monotonic Stack**\\n\\n**Time Complexity :** O(n)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int ans=INT_MIN, area_with_top=0, top=0, i=0, n=heights.size();\\n        stack<int> s;\\n        \\n        while(i<n){\\n            if(s.empty() || heights[s.top()]<=heights[i]) s.push(i++);\\n            else{\\n                top = s.top(); s.pop();\\n                area_with_top = heights[top]*(s.empty() ? i : i-s.top()-1);\\n                ans = max(ans, area_with_top);\\n            }\\n        }\\n        while(!s.empty()){\\n            top = s.top(); s.pop();\\n            area_with_top = heights[top]*(s.empty() ? i : i-s.top()-1);\\n            ans = max(ans, area_with_top);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you like the solutions, PLEASE UPVOTE!** \\uD83D\\uDD3C",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<heights.size();i++){\\n            int left=i-1, right=i+1;\\n            while(left>=0 && heights[left]>=heights[i]) left--;\\n            \\n            while(right < heights.size() && heights[right]>=heights[i]) right++;\\n            \\n            int area = heights[i]*(right-left-1);\\n            ans = max(ans, area);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int ans=INT_MIN;\\n        vector<int> ps = previousSmaller(heights);\\n        vector<int> ns = nextSmaller(heights);\\n        \\n        for(int i=0;i<heights.size();i++) ans = max(ans, (ns[i]-ps[i]-1)*heights[i]);\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> nextSmaller(vector<int> &nums){\\n        int n = nums.size();\\n        stack<int> s;\\n        vector<int> res(nums.size());\\n\\n        for (int i=n-1; i >= 0; i--){\\n            while (!s.empty() && nums[s.top()] >= nums[i]) s.pop();\\n            if (s.empty()) res[i] = nums.size();\\n            else res[i] = s.top();\\n            s.push(i);\\n        }\\n\\n        return res;\\n    }\\n    vector<int> previousSmaller(vector<int> &nums){\\n        int n = nums.size();\\n        stack<int> s;\\n        vector<int> res(n);\\n\\n        for (int i = 0; i < nums.size(); i++){\\n        while(!s.empty() && nums[s.top()] >= nums[i]) s.pop();\\n        if (s.empty()) res[i] = -1;\\n        else res[i] = s.top();\\n        s.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int ans=INT_MIN, area_with_top=0, top=0, i=0, n=heights.size();\\n        stack<int> s;\\n        \\n        while(i<n){\\n            if(s.empty() || heights[s.top()]<=heights[i]) s.push(i++);\\n            else{\\n                top = s.top(); s.pop();\\n                area_with_top = heights[top]*(s.empty() ? i : i-s.top()-1);\\n                ans = max(ans, area_with_top);\\n            }\\n        }\\n        while(!s.empty()){\\n            top = s.top(); s.pop();\\n            area_with_top = heights[top]*(s.empty() ? i : i-s.top()-1);\\n            ans = max(ans, area_with_top);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980167,
                "title": "c-99-81-faster-stack-based-solution-with-explanation",
                "content": "For explanation we will work with input array a given below\\n\\na     = [6, 7, 5, 2, 4, 5, 9, 3] ; // height array\\nindex = [0, 1 ,2 ,3, 4, 5, 6, 7] // index enumeration for explanation\\nFor brute force solution, we can just run two  loops like below and find mimimum height for a pair of indices to find out the area of recatangle between those indices, and then find the max of all possibilites, but that\\'s of order O(n^2) but the stack based solution is O(n), although space is O(n) too.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int maxArea = 0;\\n\\n        for(int i=0; i<heights.size(); ++i) {\\n            int height = heights[i];\\n            for(int j=i; j < heights.size(); ++j) {\\n                height = min(height, heights[j]);\\n                maxArea = max(maxArea, height*(j-i+1));\\n            }\\n        }\\n        return maxArea;\\n        \\n    }\\n};\\n```\\na     = [6, 7, 5, 2, 4, 5, 9, 3] ; // height array\\nindex = [0, 1 ,2 ,3, 4, 5, 6, 7] // index enumeration for explanation\\n\\nTo achieve O(n) run-time, we need to traversal array a fixed number of time and determine the answer. We have couple of options. \\n1) while traversing, consider the current index as starting point of rectacle, and find end index, and minimum height in between starting and end point, that gives the area formed. 2) While traversing, consider curent index as the end point of reactacle.\\n3) **consider the index as the height determining index of the rectacle formed. **\\n\\n**stack solution uses option 3**. I don\\'t know how to use option 1 or 2 and get O(n) run-time, probably none exists, as there challege is to get the other point and minimum height in the window, maintaining that is probably not possible in O(n). \\n\\n**In stack solution, we see if the current index can be height determining index, then what\\'s the left bound, and what\\'s the right bound, and then use height*(right_bound_index - left_bound_index -1) to get the area of the recatangle.**\\nIf the array is monotonically increasing then, left_bound_index is current_index -1, and right bound is last_index_of_array+1. So, for monotonically increasing array, we can run a loop, get maxArea in O(n) with constant space requirement. \\n\\nSo, coming back to stack solution, let\\'s consider a case where histogram is monotonically increasing like in sub-array [6,7], here max area candidate will be index[1] i.e. height = 7 and width=1, or (height = min(6,7)) * (width=2[which extends between index 0 and 1). Here we don\\'t need to consider bar with index 0  i.e. height = 6 alone, as that was considered for 2nd potential candiate with width 2.  So, if height array is always monotonically increasing, then we can just take max(heights[size-1]*1, heights[size-2]*2, heights[size-3]*3... and so on). This will give us maxArea. \\n\\nNow how things change when we see upset in monotonically increasing order? Let\\'s take example of  [6, 7, 5], here for indices 0 and 1, we will apply to above idea to get maxArea candiate. When we encounter index 2 i.e. height = 5, maxArea candidate would be (height=5)* (width = 3). \\nSimilarly when index 3 i.e. 2 comes in [6, 7, 5, 2] array, again max area candiate is (height=2)* (width=4). \\n\\nThis is the idea which has been used in the stack solution. Here when we see monotonically increasing height we keep pushing them into stack, [6, 7, 5..], but soon as we see upset index=3(height=5), we first calculate maxArea candiates so far.(Why?? Because going forward, available height would be 5 here, as that\\'s the minimum so far). \\nHow do we calcuate candiates ? \\nFirst: 7*1, for this we pop the last pushed index on stack, which is 1, get height of that, which is 7, and now we need to get the width, to get that we do [currentIndex(=2) - top_of_stack(= 0)], it gives us 2, which is incorrect, so, we do  [currentIndex(=2) - top_of_stack(= 0) -1 (minus 1)], which gives us width =1. By substracting top of the stack from current index, we are trying to find the width between two indices(we need to do -1 to get the currect width). \\nNow we keep repeating this process, till we get a height on stack which is smaller than currentIndex value. If something is left on stack with height smaller than current index, then the difference the the index on stack and currentIndex(ofcourse -1) gives us the span for currentIndex height, why, because everything in between was of higher height, so, currentIndex height was available there too.\\n\\nWe push -1 on the stack first to handle the boudary case , which fits perfectly in our calculation as -1 index comes before 0, so, our bound calculation works seamlessly. Similary on the rightmost bound, we use heights.size() as index which is 1 more than last index, again that fit perfectly in calculation. \\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int maxArea = 0;\\n        int height = 0;\\n        int area = 0;\\n        stack<int> st;\\n        st.push(-1); // to align with width calculation\\n        for(int i=0; i<heights.size(); ++i) {\\n            while(st.top() != -1 && !(heights[i] > heights[st.top()])) {\\n                height = heights[st.top()];\\n                st.pop();\\n                area = height*(i-st.top()-1);\\n                maxArea = (maxArea > area ) ? maxArea : area ;\\n            }\\n            st.push(i);\\n        }\\n        while(st.top() != -1) {\\n            height = heights[st.top()];\\n            st.pop();\\n            area = height*(heights.size()-st.top()-1);\\n            maxArea = maxArea > area ? maxArea : area;\\n        }\\n        \\n        return maxArea;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int maxArea = 0;\\n\\n        for(int i=0; i<heights.size(); ++i) {\\n            int height = heights[i];\\n            for(int j=i; j < heights.size(); ++j) {\\n                height = min(height, heights[j]);\\n                maxArea = max(maxArea, height*(j-i+1));\\n            }\\n        }\\n        return maxArea;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int maxArea = 0;\\n        int height = 0;\\n        int area = 0;\\n        stack<int> st;\\n        st.push(-1); // to align with width calculation\\n        for(int i=0; i<heights.size(); ++i) {\\n            while(st.top() != -1 && !(heights[i] > heights[st.top()])) {\\n                height = heights[st.top()];\\n                st.pop();\\n                area = height*(i-st.top()-1);\\n                maxArea = (maxArea > area ) ? maxArea : area ;\\n            }\\n            st.push(i);\\n        }\\n        while(st.top() != -1) {\\n            height = heights[st.top()];\\n            st.pop();\\n            area = height*(heights.size()-st.top()-1);\\n            maxArea = maxArea > area ? maxArea : area;\\n        }\\n        \\n        return maxArea;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607766,
                "title": "c-easy-solution-using-stack-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n\\t\\n\\t\\tint n = heights.size();\\n\\t\\tif (!n) return 0;\\n        \\n        heights.push_back(0);\\n        stack<int>stk;\\n\\t\\tint res = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < heights.size(); i++) {\\n\\t\\t\\twhile (!stk.empty() && heights[stk.top()] > heights[i]) {\\n                int h = heights[stk.top()];\\n                stk.pop();\\n                int l = stk.empty() ? 0 : stk.top()+1;\\n                res = max(res, (i-l)*h);\\n\\t\\t\\t}\\n\\t\\t\\tstk.push(i);\\n\\t\\t}\\n        \\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n\\t\\n\\t\\tint n = heights.size();\\n\\t\\tif (!n) return 0;\\n        \\n        heights.push_back(0);\\n        stack<int>stk;\\n\\t\\tint res = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < heights.size(); i++) {\\n\\t\\t\\twhile (!stk.empty() && heights[stk.top()] > heights[i]) {\\n                int h = heights[stk.top()];\\n                stk.pop();\\n                int l = stk.empty() ? 0 : stk.top()+1;\\n                res = max(res, (i-l)*h);\\n\\t\\t\\t}\\n\\t\\t\\tstk.push(i);\\n\\t\\t}\\n        \\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563975,
                "title": "java-mono-increasing-stack-straightforward-and-concise",
                "content": "Maintain an increasing stack\\nSimilar problem:https://leetcode.com/problems/daily-temperatures/discuss/563983/Java-using-mono-increasing-Stack-from-end-of-Array\\n```\\npublic int largestRectangleArea(int[] hs) {\\n        int res = 0;\\n        Stack<Integer> st = new Stack<>();\\n        for (int i = 0; i <= hs.length; i++) {\\n            int h = i == hs.length ? 0 : hs[i];\\n            while (!st.isEmpty() && h < hs[st.peek()]){\\n                int tp = st.pop();\\n                res = Math.max(res, hs[tp] * (st.isEmpty() ? i : i - 1 - st.peek()));\\n            }\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n```\\nRef: https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28900/O(n)-stack-based-JAVA-solution",
                "solutionTags": [],
                "code": "```\\npublic int largestRectangleArea(int[] hs) {\\n        int res = 0;\\n        Stack<Integer> st = new Stack<>();\\n        for (int i = 0; i <= hs.length; i++) {\\n            int h = i == hs.length ? 0 : hs[i];\\n            while (!st.isEmpty() && h < hs[st.peek()]){\\n                int tp = st.pop();\\n                res = Math.max(res, hs[tp] * (st.isEmpty() ? i : i - 1 - st.peek()));\\n            }\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563244,
                "title": "python3-o-n-stack-approach-explained",
                "content": "While traversing the list of heights from left to right, when we find a bar higher than the previous one, it means a rectangle with height equal to the height of that bar can be started there. And it can be extended (while keeping its height) at most until a bar with lower height is found, where it ends. With this in mind, we can iterate over the list of heights and add the corresponding index to a stack in each iteration. Adding an element to the stack can be thought of as starting a rectangle. But before adding the new element to the stack, we first remove all previous elements corresponding to previously \"opened\" rectangles with larger height, thus \"closing\" them. The stack will always contain a sequence of indices corresponding to a non-decreasing sequence of heights. While \"closing\" a rectangle, we check if its area improves the score. \\n\\nTo close any rectangles that extended until the end of the list without additional checks after exiting the loop, it is convenient to append a bar with height zero at the end of the list. A rectangle with non-zero area can not contain a bar with height zero, therefore the stack is reset whenever such a bar is encountered. We also add a zero height bar at index -1 (in the stack initialization, not in the list itself). This way the stack will never get empty, since there is no need to ever \"close\" a zero height rectangle, and the required stack elements can be indexed. Whenever the stack is reset this property holds.\\n\\nEach element of the list will be added to the stack once, and removed at most once, hence the time complexity is O(N).\\n\\n\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        # it is convenient to imagine bars of height 0 at positions -1 and len(heights)\\n        stack = [-1] \\n        heights.append(0)\\n        maxArea = 0\\n        for i in range(len(heights)):\\n            while len(stack) >= 2 and heights[stack[-1]] > heights[i]:\\n                maxArea = max(maxArea, (i - (stack[-2] + 1)) * heights[stack[-1]])\\n                stack.pop()\\n            if heights[i] == 0:\\n                stack = [i]\\n            else:\\n                stack.append(i)\\n        return maxArea\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        # it is convenient to imagine bars of height 0 at positions -1 and len(heights)\\n        stack = [-1] \\n        heights.append(0)\\n        maxArea = 0\\n        for i in range(len(heights)):\\n            while len(stack) >= 2 and heights[stack[-1]] > heights[i]:\\n                maxArea = max(maxArea, (i - (stack[-2] + 1)) * heights[stack[-1]])\\n                stack.pop()\\n            if heights[i] == 0:\\n                stack = [i]\\n            else:\\n                stack.append(i)\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440433,
                "title": "python-detailed-explanation-for-dp-o-n-solution-beats-99-9-runtime-100-memory",
                "content": "**KEEP IN MIND:** ***The idea is that for each bar, we want to find the \"right boundary\" and \"left boundary\" that are both smaller than it, so that we can mutilpy its\" height\" with the \"width of the boundary\" and find the area that it creates.***\\n\\n\\n**THE MOST TRICKY PART : Why \\'-1\\' is initially in the stack ???**\\n\\tFirst, note that we purposedly append \\'0\\' to the \"heights array\" to manually create right boundary, and \"-1\" in the stack denotes the index of this purposedly created bar with 0 height. (NOTE: -1 represents the index of the last element in Python.)\\n\\tHowever, it\\'s not tricky if \\'-1\\' only functions as the above reason.\\n\\tNOTE THAT \\'-1\\' is also \"naturally\" the left integer of \\'0\\' on the Number Line, so it \"naturally\" denotes the \"left boundary\" of index \\'0\\' which represents the first bar.\\n\\t\\n\\nNOW, with the inline comment in the code, everything should be easy... Comment below if you need help.\\n\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        # make right boundary\\n        heights.append(0)\\n        # store left boundary index\\n        stack = [-1] # tricky: -1 also denotes the left index of 0\\n        # keep track of max area\\n        area = 0\\n        # iterate through heights\\n        for idx, h in enumerate(heights):\\n            # we now find the right boundary for stacks[-1]\\n            while h < heights[stack[-1]]:\\n                cur_idx = stack.pop()\\n                cur_h = heights[cur_idx]\\n                # right boundary (idx) is certainly lower than \\'cur_idx\\'\\n                right_boundary = idx\\n                # tricky part, note that every index stored in \\'stack\\' is in ascending order, but not necessary continguous\\n                # also note that the reason we initially put \\'-1\\' in \\'stack\\' is that -1 is instinctively left to 0, so it\\'s naturally the left boundary for index 0\\n                left_boundary = stack[-1]\\n                cur_w = right_boundary - left_boundary - 1\\n                area = max(area, cur_h * cur_w)\\n            # we put every index to stack once\\n            # note that eventually every index except \\'-1\\' in stack will be popped out\\n            stack.append(idx)\\n        return area\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        # make right boundary\\n        heights.append(0)\\n        # store left boundary index\\n        stack = [-1] # tricky: -1 also denotes the left index of 0\\n        # keep track of max area\\n        area = 0\\n        # iterate through heights\\n        for idx, h in enumerate(heights):\\n            # we now find the right boundary for stacks[-1]\\n            while h < heights[stack[-1]]:\\n                cur_idx = stack.pop()\\n                cur_h = heights[cur_idx]\\n                # right boundary (idx) is certainly lower than \\'cur_idx\\'\\n                right_boundary = idx\\n                # tricky part, note that every index stored in \\'stack\\' is in ascending order, but not necessary continguous\\n                # also note that the reason we initially put \\'-1\\' in \\'stack\\' is that -1 is instinctively left to 0, so it\\'s naturally the left boundary for index 0\\n                left_boundary = stack[-1]\\n                cur_w = right_boundary - left_boundary - 1\\n                area = max(area, cur_h * cur_w)\\n            # we put every index to stack once\\n            # note that eventually every index except \\'-1\\' in stack will be popped out\\n            stack.append(idx)\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323630,
                "title": "recursive-java-solution-in-o-nlogn",
                "content": "```\\n\\tprivate static int largestRectangleArea(int[] heights) {\\n        if (heights == null || heights.length == 0)\\n            return 0;\\n\\n        //utility function to divide and conquer\\n        return maxRectangle(heights, 0, heights.length - 1);\\n    }\\n\\n    private static int maxRectangle(int[] arr, int l, int r) {\\n\\n        //check if current array is out of bounds\\n        if (l > r)\\n            return 0;\\n\\n        //check if it has only one element then that bar is the max area\\n        if (l == r)\\n            return arr[l];\\n\\n        //find the minimum index in the current range\\n        int minIndex = findMinIndex(arr, l, r);\\n\\n        //recursively find max area in the left sub-array\\n        int left = maxRectangle(arr, l, minIndex - 1);\\n\\n        //recursively find max area in the right sub-array\\n        int right = maxRectangle(arr, minIndex + 1, r);\\n\\n        //find max area among left and right sub-arrays\\n        int max = Math.max(left, right);\\n\\n        //compare max with min_bar * curr_range\\n        return Math.max(max, arr[minIndex] * (r - l + 1));\\n    }\\n\\n    private static int findMinIndex(int[] arr, int l, int r) {\\n        int min = Integer.MAX_VALUE;\\n        int minIndex = l;\\n        for (int i = l; i <= r; i++) {\\n            if (arr[i] < min) {\\n                min = arr[i];\\n                minIndex = i;\\n            }\\n        }\\n        return minIndex;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\n\\tprivate static int largestRectangleArea(int[] heights) {\\n        if (heights == null || heights.length == 0)\\n            return 0;\\n\\n        //utility function to divide and conquer\\n        return maxRectangle(heights, 0, heights.length - 1);\\n    }\\n\\n    private static int maxRectangle(int[] arr, int l, int r) {\\n\\n        //check if current array is out of bounds\\n        if (l > r)\\n            return 0;\\n\\n        //check if it has only one element then that bar is the max area\\n        if (l == r)\\n            return arr[l];\\n\\n        //find the minimum index in the current range\\n        int minIndex = findMinIndex(arr, l, r);\\n\\n        //recursively find max area in the left sub-array\\n        int left = maxRectangle(arr, l, minIndex - 1);\\n\\n        //recursively find max area in the right sub-array\\n        int right = maxRectangle(arr, minIndex + 1, r);\\n\\n        //find max area among left and right sub-arrays\\n        int max = Math.max(left, right);\\n\\n        //compare max with min_bar * curr_range\\n        return Math.max(max, arr[minIndex] * (r - l + 1));\\n    }\\n\\n    private static int findMinIndex(int[] arr, int l, int r) {\\n        int min = Integer.MAX_VALUE;\\n        int minIndex = l;\\n        for (int i = l; i <= r; i++) {\\n            if (arr[i] < min) {\\n                min = arr[i];\\n                minIndex = i;\\n            }\\n        }\\n        return minIndex;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29003,
                "title": "4ms-java-solution-using-o-n-stack-space-o-n-time",
                "content": "    public class Solution {\\n        public int largestRectangleArea(int[] height) {\\n            if ((height == null) || (height.length == 0)) return 0;\\n            final int N = height.length;\\n            int[] s = new int[N + 1];\\n            int i, top = 0, hi, area = 0;\\n            s[0] = -1;\\n            for (i = 0; i < N; i++) {\\n                hi = height[i];\\n                while ((top > 0) && (height[s[top]] > hi)) {\\n                    area = Math.max(area, height[s[top]] * (i - s[top - 1] - 1));\\n                    top--;\\n                }\\n                s[++top] = i;\\n            }\\n            while (top > 0) {\\n                area = Math.max(area, height[s[top]] * (N - s[top -1] - 1));\\n                top--;\\n            }\\n            return area;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n        public int largestRectangleArea(int[] height) {\\n            if ((height == null) || (height.length == 0)) return 0;\\n            final int N = height.length;\\n            int[] s = new int[N + 1];\\n            int i, top = 0, hi, area = 0;\\n            s[0] = -1;\\n            for (i = 0; i < N; i++) {\\n                hi = height[i];\\n                while ((top > 0) && (height[s[top]] > hi)) {\\n                    area = Math.max(area, height[s[top]] * (i - s[top - 1] - 1));\\n                    top--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29041,
                "title": "the-easiest-way-to-understand-the-stack-based-solution-at-least-to-me",
                "content": "[Invariant][1]: the stack contains the longest non-decreasing subsequence ending at bar i. Everything else follows. Hope this helps for your understanding why the solution is right.\\n\\n    class Solution {\\n    public:\\n        int largestRectangleArea(vector<int> &A) {\\n            stack<int> s;\\n            int max_area = 0;\\n            for (int i = 0; i <= A.size(); ++i) {\\n                while (!s.empty() && (i == A.size() || A[i] < A[s.top()])) {\\n                    int height = A[s.top()];\\n                    s.pop();\\n                    max_area = max(max_area, height * (s.empty() ? i : i - s.top() - 1));\\n                }\\n                s.emplace(i);\\n            }\\n            return max_area;\\n        }\\n    };\\n\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2015/02/largest-rectangle-in-histogram.html",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public:\\n        int largestRectangleArea(vector<int> &A) {\\n            stack<int> s;\\n            int max_area = 0;\\n            for (int i = 0; i <= A.size(); ++i) {\\n                while (!s.empty() && (i == A.size() || A[i] < A[s.top()])) {\\n                    int height = A[s.top()];\\n                    s.pop();\\n                    max_area = max(max_area, height * (s.empty() ? i : i - s.top() - 1));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3822532,
                "title": "beats-83-solution",
                "content": "\\n# Approach\\nThe function largestRectangleArea takes a vector heights representing the heights of bars in a histogram.\\n\\nIt initializes variables n to store the size of the heights vector and area to store the maximum area.\\n\\nIt declares two vectors next and prev, which will be used to store the indices of the next smaller and previous smaller elements, respectively, for each element in the heights vector.\\n\\nThe function then calls the helper functions nextelement and prevelement, which use a stack to find the next smaller and previous smaller elements\\' indices for each element in the heights vector.\\n\\nAfter calculating the next and prev vectors, the function iterates through each element in the heights vector using a for loop.\\n\\nFor each element, it calculates the width of the rectangle by subtracting the index of the previous smaller element from the index of the next smaller element and subtracting 1. This width represents the width of the rectangle formed by considering the current element as the height.\\n\\nThe height of the rectangle is the value of the current element (heights[i]).\\n\\nThe area of the rectangle is then calculated by multiplying the height and width.\\n\\nThe function updates the area with the maximum value found so far.\\n\\nFinally, the function returns the maximum area found.\\n\\nThe algorithm essentially calculates the area of the largest rectangle that can be formed for each bar in the histogram by considering it as the height and extending it to the left and right until it encounters bars that are lower or of equal height.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\nvector<int> nextelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =n-1;i>=0;i--)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n    ans[i]=st.top();\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\nvector<int> prevelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =0;i<n;i++)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n    ans[i]=st.top();\\n    st.push(i);\\n    }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n       int n =heights.size();\\n       int area= INT_MIN;\\n\\n       vector<int>next(n);\\n       vector<int>prev(n);\\n\\n       next=nextelement(heights,n); \\n       prev=prevelement(heights,n); \\n\\n       for(int i =0;i<n;i++)\\n       {\\n           int l = heights[i];\\n           if(next[i]==-1)\\n           {\\n               next[i]=n;\\n           }\\n           int b = next[i]-prev[i]-1;\\n           int newarea= l*b;\\n           area=max(area,newarea);\\n       }\\n       return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    private:\\nvector<int> nextelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =n-1;i>=0;i--)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n    ans[i]=st.top();\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\nvector<int> prevelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =0;i<n;i++)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n    ans[i]=st.top();\\n    st.push(i);\\n    }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n       int n =heights.size();\\n       int area= INT_MIN;\\n\\n       vector<int>next(n);\\n       vector<int>prev(n);\\n\\n       next=nextelement(heights,n); \\n       prev=prevelement(heights,n); \\n\\n       for(int i =0;i<n;i++)\\n       {\\n           int l = heights[i];\\n           if(next[i]==-1)\\n           {\\n               next[i]=n;\\n           }\\n           int b = next[i]-prev[i]-1;\\n           int newarea= l*b;\\n           area=max(area,newarea);\\n       }\\n       return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692231,
                "title": "c-using-stack-brute-and-optimised-both-t-c-o-n-s-c-o-n",
                "content": "1. Brute Approach:\\n```\\nclass Solution {\\n\\n    /*\\n        Time Complexity : O(N^2)\\n        Space Complexity : O(1)\\n    */\\n\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int res = 0, n = heights.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = heights[i], breadth = 1;\\n            \\n            for(int j=i+1; j<n; j++){\\n                if(heights[j] >= curr) breadth++;\\n                else break;\\n            }\\n            \\n            for(int j=i-1; j>=0; j--){\\n                if(heights[j] >= curr) breadth++;\\n                else break;\\n            }\\n            \\n            int area = curr*breadth;\\n            res = max(res, area);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n2. Optimised Approach:\\n```\\nclass Solution {\\n\\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(N)\\n    */\\n\\nprivate:\\n    int n;\\n    \\n    void getNextSmallerIdx(vector<int>& res, vector<int>& heights){\\n        stack<int> s1;\\n        s1.push(-1);\\n        \\n        for(int i=n-1; i>=0; i--){\\n            int curr = heights[i];\\n            while(s1.top() != -1 and heights[s1.top()] >= curr){\\n                s1.pop();\\n            }\\n            \\n            res[i] = s1.top();\\n            s1.push(i);\\n        }\\n    }\\n    \\n    void getPrevSmallerIdx(vector<int>& res, vector<int>& heights){\\n        stack<int> s1;\\n        s1.push(-1);\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = heights[i];\\n            while(s1.top() != -1 and heights[s1.top()] >= curr){\\n                s1.pop();\\n            }\\n            \\n            res[i] = s1.top();\\n            s1.push(i);\\n        }\\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        n = heights.size();\\n        int res = 0;\\n        vector<int> nextSmaller(n), prevSmaller(n);\\n        \\n        getNextSmallerIdx(nextSmaller, heights);\\n        getPrevSmallerIdx(prevSmaller, heights);\\n        \\n        for(int i=0; i<n; i++){\\n            int currL = heights[i];\\n            if(nextSmaller[i] == -1) nextSmaller[i] = n;\\n            \\n            int currB = nextSmaller[i] - prevSmaller[i] - 1;\\n            int area = currL * currB;\\n            res = max(area, res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n3. Optimal Apprach:\\n```\\nclass Solution {\\n\\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(N)\\n    */\\n\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> s1;\\n        int res = 0, n = heights.size();\\n        \\n        for(int i=0; i<=n; i++){\\n            while(!s1.empty() and (i==n || heights[s1.top()] >= heights[i])){\\n                int len = heights[s1.top()];\\n                s1.pop();\\n                \\n                int bre;\\n                if(s1.empty()) bre = i;\\n                else bre = i - s1.top() - 1;\\n                res = max(res, len*bre);\\n            }\\n            \\n            s1.push(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    /*\\n        Time Complexity : O(N^2)\\n        Space Complexity : O(1)\\n    */\\n\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int res = 0, n = heights.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = heights[i], breadth = 1;\\n            \\n            for(int j=i+1; j<n; j++){\\n                if(heights[j] >= curr) breadth++;\\n                else break;\\n            }\\n            \\n            for(int j=i-1; j>=0; j--){\\n                if(heights[j] >= curr) breadth++;\\n                else break;\\n            }\\n            \\n            int area = curr*breadth;\\n            res = max(res, area);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(N)\\n    */\\n\\nprivate:\\n    int n;\\n    \\n    void getNextSmallerIdx(vector<int>& res, vector<int>& heights){\\n        stack<int> s1;\\n        s1.push(-1);\\n        \\n        for(int i=n-1; i>=0; i--){\\n            int curr = heights[i];\\n            while(s1.top() != -1 and heights[s1.top()] >= curr){\\n                s1.pop();\\n            }\\n            \\n            res[i] = s1.top();\\n            s1.push(i);\\n        }\\n    }\\n    \\n    void getPrevSmallerIdx(vector<int>& res, vector<int>& heights){\\n        stack<int> s1;\\n        s1.push(-1);\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = heights[i];\\n            while(s1.top() != -1 and heights[s1.top()] >= curr){\\n                s1.pop();\\n            }\\n            \\n            res[i] = s1.top();\\n            s1.push(i);\\n        }\\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        n = heights.size();\\n        int res = 0;\\n        vector<int> nextSmaller(n), prevSmaller(n);\\n        \\n        getNextSmallerIdx(nextSmaller, heights);\\n        getPrevSmallerIdx(prevSmaller, heights);\\n        \\n        for(int i=0; i<n; i++){\\n            int currL = heights[i];\\n            if(nextSmaller[i] == -1) nextSmaller[i] = n;\\n            \\n            int currB = nextSmaller[i] - prevSmaller[i] - 1;\\n            int area = currL * currB;\\n            res = max(area, res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(N)\\n    */\\n\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> s1;\\n        int res = 0, n = heights.size();\\n        \\n        for(int i=0; i<=n; i++){\\n            while(!s1.empty() and (i==n || heights[s1.top()] >= heights[i])){\\n                int len = heights[s1.top()];\\n                s1.pop();\\n                \\n                int bre;\\n                if(s1.empty()) bre = i;\\n                else bre = i - s1.top() - 1;\\n                res = max(res, len*bre);\\n            }\\n            \\n            s1.push(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642539,
                "title": "easy-and-clean-code-in-java",
                "content": "# Algorithm :\\n> #### Create a left array which holds the indices of the lower element\\'s index on the left side , similarly create a right array which stores the first index of element that is lower in the right side. The formula is (right[i]-left[i]-1)*heights[i] Store the maximum among the results and return it.\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n       Stack<Integer> stack = new Stack<>();\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       for(int i = 0;i<n;i++)\\n       {\\n           while(stack.size() != 0 && heights[stack.peek()] >= heights[i])\\n           {\\n               stack.pop();\\n           }\\n           if(stack.size() == 0)\\n           {\\n               left[i] = -1;\\n           }\\n           else\\n           {\\n               left[i] = stack.peek();\\n           }\\n           stack.push(i);\\n       }\\n       stack.clear();\\n       for(int i = n-1;i>=0;i--)\\n       {\\n           while(stack.size() != 0 && heights[stack.peek()] >= heights[i])\\n           {\\n               stack.pop();\\n           }\\n           if(stack.size() == 0)\\n           {\\n               right[i] = n;\\n           }\\n           else\\n           {\\n               right[i] = stack.peek();\\n           }\\n           stack.push(i);\\n       }\\n       int result = 0;\\n       for(int i = 0;i<n;i++)\\n       {\\n           int area = (right[i]-left[i]-1)*heights[i];\\n           result = Math.max(result,area);\\n       } \\n       return result;\\n    }\\n}\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n       Stack<Integer> stack = new Stack<>();\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       for(int i = 0;i<n;i++)\\n       {\\n           while(stack.size() != 0 && heights[stack.peek()] >= heights[i])\\n           {\\n               stack.pop();\\n           }\\n           if(stack.size() == 0)\\n           {\\n               left[i] = -1;\\n           }\\n           else\\n           {\\n               left[i] = stack.peek();\\n           }\\n           stack.push(i);\\n       }\\n       stack.clear();\\n       for(int i = n-1;i>=0;i--)\\n       {\\n           while(stack.size() != 0 && heights[stack.peek()] >= heights[i])\\n           {\\n               stack.pop();\\n           }\\n           if(stack.size() == 0)\\n           {\\n               right[i] = n;\\n           }\\n           else\\n           {\\n               right[i] = stack.peek();\\n           }\\n           stack.push(i);\\n       }\\n       int result = 0;\\n       for(int i = 0;i<n;i++)\\n       {\\n           int area = (right[i]-left[i]-1)*heights[i];\\n           result = Math.max(result,area);\\n       } \\n       return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634392,
                "title": "python-easy-solution-beats-96",
                "content": "![image.png](https://assets.leetcode.com/users/images/2c3ae17b-199f-4484-8ea6-1d9f9f4417f8_1686677923.8759806.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse ascending monotonic stack to solve this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- store a tuple: (index, val) in monotonic stack. This will make our idea clear and benefit our explanation\\n- use ascending stack instead of descending stack\\n- remember to record minStartIdx while poping stack. Otherwise, the solution can\\'t tackle with inputs like: [2,1,2]. I saw many solutions are lack of this step, technically they are wrong. But it\\'s weird that they can pass the submission. \\n- when encounter the equal problem (current Height == height of stack top), we don\\'t need to push it into the stack, since the area calculation will be coverd by the current stack top element.\\n- appending a small number (0 or -1) at the end of the input array can efficiently solve non-empty stack problems. We can avoid writing extra code after the for/while loop to empty the stack.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        maxArea = 0\\n        stack = [] # startIdx, height\\n        heights.append(0) # allows us to clear out stack without extra logic\\n        for curI, curH in enumerate(heights):\\n            # don\\'t need to append if we already have the value with a lower startIdx\\n            if stack and curH == stack[-1][1]:\\n                continue\\n            minStartIdx = curI\\n            while stack and curH < stack[-1][1]:\\n                startIdx, lastHeight = stack.pop()\\n                minStartIdx = startIdx\\n                maxArea = max(maxArea, lastHeight * (curI - startIdx))\\n            stack.append((minStartIdx, curH))\\n        return maxArea\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        maxArea = 0\\n        stack = [] # startIdx, height\\n        heights.append(0) # allows us to clear out stack without extra logic\\n        for curI, curH in enumerate(heights):\\n            # don\\'t need to append if we already have the value with a lower startIdx\\n            if stack and curH == stack[-1][1]:\\n                continue\\n            minStartIdx = curI\\n            while stack and curH < stack[-1][1]:\\n                startIdx, lastHeight = stack.pop()\\n                minStartIdx = startIdx\\n                maxArea = max(maxArea, lastHeight * (curI - startIdx))\\n            stack.append((minStartIdx, curH))\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293609,
                "title": "easy-to-understand-using-stacks-0ms-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int maxarea=Integer.MIN_VALUE;\\n        int nsl[]=new int[heights.length];\\n        int nsr[]=new int[heights.length];\\n        Stack<Integer> s=new Stack<>();\\n        //nsr\\n        for(int i=heights.length-1;i>=0;i--){\\n            while(!s.isEmpty()&& heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                nsr[i]= heights.length;\\n            }\\n            else{\\n                nsr[i]= s.peek();\\n            }\\n            s.push(i);\\n        }\\n        //next smaller left\\n        s=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n            while(!s.isEmpty()&& heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                nsl[i]= -1;\\n            }\\n            else{\\n                nsl[i]= s.peek();\\n            }\\n            s.push(i);\\n\\n        }\\n        for(int i=0;i<heights.length;i++){\\n            int heigth=heights[i];\\n            int width=nsr[i]-nsl[i]-1;\\n            int currarea=heigth*width;\\n            maxarea=Math.max(currarea,maxarea);\\n        }\\n        return maxarea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int maxarea=Integer.MIN_VALUE;\\n        int nsl[]=new int[heights.length];\\n        int nsr[]=new int[heights.length];\\n        Stack<Integer> s=new Stack<>();\\n        //nsr\\n        for(int i=heights.length-1;i>=0;i--){\\n            while(!s.isEmpty()&& heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                nsr[i]= heights.length;\\n            }\\n            else{\\n                nsr[i]= s.peek();\\n            }\\n            s.push(i);\\n        }\\n        //next smaller left\\n        s=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n            while(!s.isEmpty()&& heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                nsl[i]= -1;\\n            }\\n            else{\\n                nsl[i]= s.peek();\\n            }\\n            s.push(i);\\n\\n        }\\n        for(int i=0;i<heights.length;i++){\\n            int heigth=heights[i];\\n            int width=nsr[i]-nsl[i]-1;\\n            int currarea=heigth*width;\\n            maxarea=Math.max(currarea,maxarea);\\n        }\\n        return maxarea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036629,
                "title": "c-stack-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        vector<int> nsl;\\n        vector<int> nsr;\\n        stack<pair<int,int>> st1;\\n        stack<pair<int,int>> st2;\\n        int n=heights.size();\\n        for(int i=0;i<n;i++)                               //NSL\\n        {\\n            if(st1.size()==0)nsl.push_back(-1);\\n            else if(st1.size()>0 && st1.top().first<heights[i])nsl.push_back(st1.top().second);\\n            else if(st1.size()>0 && st1.top().first>=heights[i])\\n            {\\n                while(st1.size()>0 && st1.top().first>=heights[i])\\n                    st1.pop();\\n                if(st1.size()==0)nsl.push_back(-1);\\n                else nsl.push_back(st1.top().second);\\n            }\\n            st1.push({heights[i],i});\\n        }\\n        int temp=n;\\n        for(int i=n-1;i>=0;i--)                                                    //NGR\\n        {\\n            if(st2.size()==0)nsr.push_back(temp);\\n            else if(st2.size()>0 && st2.top().first<heights[i])nsr.push_back(st2.top().second);\\n            else if(st2.size()>0 && st2.top().first>=heights[i])\\n            {\\n                while(st2.size()>0 && st2.top().first>=heights[i])\\n                    st2.pop();\\n                if(st2.size()==0)nsr.push_back(temp);\\n                else nsr.push_back(st2.top().second);\\n            }\\n            st2.push({heights[i],i});\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n        int maxi=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,((nsr[i]-nsl[i]-1)*heights[i]));\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        vector<int> nsl;\\n        vector<int> nsr;\\n        stack<pair<int,int>> st1;\\n        stack<pair<int,int>> st2;\\n        int n=heights.size();\\n        for(int i=0;i<n;i++)                               //NSL\\n        {\\n            if(st1.size()==0)nsl.push_back(-1);\\n            else if(st1.size()>0 && st1.top().first<heights[i])nsl.push_back(st1.top().second);\\n            else if(st1.size()>0 && st1.top().first>=heights[i])\\n            {\\n                while(st1.size()>0 && st1.top().first>=heights[i])\\n                    st1.pop();\\n                if(st1.size()==0)nsl.push_back(-1);\\n                else nsl.push_back(st1.top().second);\\n            }\\n            st1.push({heights[i],i});\\n        }\\n        int temp=n;\\n        for(int i=n-1;i>=0;i--)                                                    //NGR\\n        {\\n            if(st2.size()==0)nsr.push_back(temp);\\n            else if(st2.size()>0 && st2.top().first<heights[i])nsr.push_back(st2.top().second);\\n            else if(st2.size()>0 && st2.top().first>=heights[i])\\n            {\\n                while(st2.size()>0 && st2.top().first>=heights[i])\\n                    st2.pop();\\n                if(st2.size()==0)nsr.push_back(temp);\\n                else nsr.push_back(st2.top().second);\\n            }\\n            st2.push({heights[i],i});\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n        int maxi=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,((nsr[i]-nsl[i]-1)*heights[i]));\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972042,
                "title": "c-python-with-explanation-with-time-and-space-complexity-analysis",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- To solve this problem efficiently, we use two helper functions, **nextSmallerElement** and **prevSmallerElement**, which are used to find the indices of the next smaller element and the previous smaller element for each bar in the histogram. These indices will help determine the width of the rectangle for each bar\\'s height, and thus, the area.\\n  1. **nextSmallerElement** Function:\\n        - This function takes the **heights** array and its size **n** as input.\\n        - It initializes an empty stack **a** to keep track of the indices of elements.\\n        - It also initializes an empty vector **b** of size **n** to store the indices of the next smaller element for each bar.\\n        - It starts iterating from the last element of the **heights** array to the first.\\n        - For each element, it checks whether the element at the top of the stack (i.e., **a.top()**) is greater than or equal to the current element (**arr[i]**).\\n        - If the element at the top of the stack is greater, it pops elements from the stack until a smaller element is encountered or the stack becomes empty.\\n        - For each popped element, it sets the corresponding index in **b** as the index of the next smaller element.\\n        - Finally, it pushes the current element\\'s index onto the stack.\\n        - The function returns the **b** vector containing the indices of the next smaller elements.\\n    2. **prevSmallerElement** Function:\\n        - This function is similar to **nextSmallerElement** but iterates in the opposite direction, from the first element to the last.\\n        - It initializes an empty stack **a**, an empty vector **b**, and iterates through the **heights** array from left to right.\\n        - It checks whether the element at the top of the stack is greater than or equal to the current element (**arr[i]**), and if so, it pops elements from the stack until a smaller element is encountered or the stack becomes empty.\\n        - For each popped element, it sets the corresponding index in **b** as the index of the previous smaller element.\\n        - Finally, it pushes the current element\\'s index onto the stack.\\n        - The function returns the **b** vector containing the indices of the previous smaller elements.\\n    3. **largestRectangleArea** Function:\\n        - This is the main function that calculates the area of the largest rectangle.\\n        - It first finds the indices of the next smaller elements using **nextSmallerElement** and stores them in the **next** vector.\\n        - It then finds the indices of the previous smaller elements using **prevSmallerElement** and stores them in the **prev** vector.\\n        - It initializes a variable **area** to **INT_MIN** to keep track of the maximum area found so far.\\n        - It iterates through the **heights** array, and for each bar, it calculates the area of the rectangle that can be formed using that bar\\'s height.\\n        - The width of the rectangle is calculated as **(next[i] - prev[i] - 1)**, where **next[i]** is the index of the next smaller element, and **prev[i]** is the index of the previous smaller element.\\n        - The area of the rectangle is calculated as **heights[i] * width**.\\n        - The maximum area found so far is updated as **max(newarea, area)**.\\n        - Finally, the function returns the maximum area found.\\n\\n# Complexity\\n- **Time complexity**: $$O(n)$$\\n    - The time complexity of your solution is $$O(n)$$, where n is the number of elements in the **heights** array. This is because both **nextSmallerElement** and **prevSmallerElement** functions each iterate through the **heights** array once.\\n\\n\\n- **Space complexity**: $$O(n)$$\\n    - The space complexity is $$O(n)$$ as well because you use two additional vectors (**next** and **prev**) of the same size as the input array to store the indices of next and previous smaller elements.\\n\\n# Code\\n## C++\\n```\\nclass Solution {\\n    private:\\n    vector<int> nextSmallerElement(vector<int> &arr, int n)\\n    {\\n        // Write your code here.\\n        stack<int> a;\\n        a.push(-1);\\n        vector<int> b(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n                while(a.top()!=-1 &&arr[i]<=arr[a.top()])\\n                {\\n                    a.pop();\\n                }\\n        \\n            b[i]=a.top();\\n            a.push(i);\\n        }\\n        return b;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> &arr, int n)\\n    {\\n        // Write your code here.\\n        stack<int> a;\\n        a.push(-1);\\n        vector<int> b(n);\\n        for(int i=0;i<n;i++)\\n        {\\n                while(a.top()!=-1 &&arr[i]<=arr[a.top()])\\n                {\\n                    a.pop();\\n                }\\n        \\n            b[i]=a.top();\\n            a.push(i);\\n        }\\n        return b;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n\\n        vector<int> next(n);\\n            next=nextSmallerElement(heights,n);\\n        vector<int> prev(n);\\n            prev=prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int a=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b=next[i]-prev[i]-1;\\n            int newarea=a*b;\\n            area=max(newarea,area);\\n        }\\n        return area;\\n    }\\n};\\n```\\n## Python\\n```\\nclass Solution(object):\\n    def nextSmallerElement(self, arr):\\n        n = len(arr)\\n        a = [-1]\\n        b = [0] * n\\n        for i in range(n - 1, -1, -1):\\n            while a[-1] != -1 and arr[i] <= arr[a[-1]]:\\n                a.pop()\\n            b[i] = a[-1]\\n            a.append(i)\\n        return b\\n\\n    def prevSmallerElement(self, arr):\\n        n = len(arr)\\n        a = [-1]\\n        b = [0] * n\\n        for i in range(n):\\n            while a[-1] != -1 and arr[i] <= arr[a[-1]]:\\n                a.pop()\\n            b[i] = a[-1]\\n            a.append(i)\\n        return b\\n\\n    def largestRectangleArea(self, heights):\\n        n = len(heights)\\n\\n        next_smaller = self.nextSmallerElement(heights)\\n        prev_smaller = self.prevSmallerElement(heights)\\n\\n        area = float(\\'-inf\\')\\n        for i in range(n):\\n            a = heights[i]\\n            if next_smaller[i] == -1:\\n                next_smaller[i] = n\\n            width = next_smaller[i] - prev_smaller[i] - 1\\n            new_area = a * width\\n            area = max(new_area, area)\\n\\n        return area\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    vector<int> nextSmallerElement(vector<int> &arr, int n)\\n    {\\n        // Write your code here.\\n        stack<int> a;\\n        a.push(-1);\\n        vector<int> b(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n                while(a.top()!=-1 &&arr[i]<=arr[a.top()])\\n                {\\n                    a.pop();\\n                }\\n        \\n            b[i]=a.top();\\n            a.push(i);\\n        }\\n        return b;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> &arr, int n)\\n    {\\n        // Write your code here.\\n        stack<int> a;\\n        a.push(-1);\\n        vector<int> b(n);\\n        for(int i=0;i<n;i++)\\n        {\\n                while(a.top()!=-1 &&arr[i]<=arr[a.top()])\\n                {\\n                    a.pop();\\n                }\\n        \\n            b[i]=a.top();\\n            a.push(i);\\n        }\\n        return b;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n\\n        vector<int> next(n);\\n            next=nextSmallerElement(heights,n);\\n        vector<int> prev(n);\\n            prev=prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int a=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b=next[i]-prev[i]-1;\\n            int newarea=a*b;\\n            area=max(newarea,area);\\n        }\\n        return area;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def nextSmallerElement(self, arr):\\n        n = len(arr)\\n        a = [-1]\\n        b = [0] * n\\n        for i in range(n - 1, -1, -1):\\n            while a[-1] != -1 and arr[i] <= arr[a[-1]]:\\n                a.pop()\\n            b[i] = a[-1]\\n            a.append(i)\\n        return b\\n\\n    def prevSmallerElement(self, arr):\\n        n = len(arr)\\n        a = [-1]\\n        b = [0] * n\\n        for i in range(n):\\n            while a[-1] != -1 and arr[i] <= arr[a[-1]]:\\n                a.pop()\\n            b[i] = a[-1]\\n            a.append(i)\\n        return b\\n\\n    def largestRectangleArea(self, heights):\\n        n = len(heights)\\n\\n        next_smaller = self.nextSmallerElement(heights)\\n        prev_smaller = self.prevSmallerElement(heights)\\n\\n        area = float(\\'-inf\\')\\n        for i in range(n):\\n            a = heights[i]\\n            if next_smaller[i] == -1:\\n                next_smaller[i] = n\\n            width = next_smaller[i] - prev_smaller[i] - 1\\n            new_area = a * width\\n            area = max(new_area, area)\\n\\n        return area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770928,
                "title": "largest-rectangle-in-histogram-o-n-solution-beats-90",
                "content": "Pls vote if you like the solution...\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        int tp;\\n        int max_area=0;\\n        int area_top;\\n        int i=0;\\n        int n = heights.size();\\n        while(i<n){\\n            if(st.empty() || heights[st.top()]<=heights[i])\\n                st.push(i++);\\n            else{\\n                tp = st.top();\\n                st.pop();\\n                \\n                area_top = heights[tp]*(st.empty()?i:i-st.top()-1);\\n                max_area = max(max_area,area_top);\\n            }\\n        }\\n        while(!st.empty()){\\n            tp = st.top();\\n            st.pop();\\n            \\n            area_top = heights[tp]*(st.empty()?i:i-st.top()-1);\\n            max_area = max(max_area,area_top);\\n        }\\n        return max_area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        int tp;\\n        int max_area=0;\\n        int area_top;\\n        int i=0;\\n        int n = heights.size();\\n        while(i<n){\\n            if(st.empty() || heights[st.top()]<=heights[i])\\n                st.push(i++);\\n            else{\\n                tp = st.top();\\n                st.pop();\\n                \\n                area_top = heights[tp]*(st.empty()?i:i-st.top()-1);\\n                max_area = max(max_area,area_top);\\n            }\\n        }\\n        while(!st.empty()){\\n            tp = st.top();\\n            st.pop();\\n            \\n            area_top = heights[tp]*(st.empty()?i:i-st.top()-1);\\n            max_area = max(max_area,area_top);\\n        }\\n        return max_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696927,
                "title": "java-optimized-approach-4-lines-logic-stack",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        if (heights.length == 0) return 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int maxArea = 0;\\n        for (int i = 0; i <= heights.length; i++) {\\n            int cur = i == heights.length ? 0 : heights[i];\\n            while (stack.peek() != -1 && cur < heights[stack.peek()]) {\\n                maxArea = Math.max(maxArea, heights[stack.pop()] * (i - stack.peek() - 1));\\n            }\\n            stack.push(i);\\n        }\\n        return maxArea;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/8cd34e1c-049b-430f-b0d6-16247065d133_1665636679.1586673.png)\\n",
                "solutionTags": [
                    "Array",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        if (heights.length == 0) return 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int maxArea = 0;\\n        for (int i = 0; i <= heights.length; i++) {\\n            int cur = i == heights.length ? 0 : heights[i];\\n            while (stack.peek() != -1 && cur < heights[stack.peek()]) {\\n                maxArea = Math.max(maxArea, heights[stack.pop()] * (i - stack.peek() - 1));\\n            }\\n            stack.push(i);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467214,
                "title": "why-left-right-processing-is-o-n-explanation",
                "content": "The simplest explanation I can give for why the left/right processing is O(N) is that as you do the back-scans you bounce over some nodes and terminate at another and there are N such back-scans.\\n\\nEach termination happens once per back-scan, so there are O(N) termination steps collectively.\\n\\nEach node that tells the back-scan to bounce over it will never participate in any future back-scans ever again. So, each node can cause a bounce at most once, thus the bounce steps are also bounded by N.\\n\\n**This is because if we are at a node i and when checking back , a node j tells us to bounce back implies that  j is greater than i. So in future if we go at any node greater than i , it will terminate at i and not reach  j .  And if the future node is less than i  then it will bounce back from i and will go past j ( never go to j ).**\\n\\nO(N) terminations + O(N) bounces are thus O(N).\\n\\nTo go into more detail about why an element only ever is processed for a single bounce operation, consider:\\n\\ni - element we are starting with for a back-scan\\nj - element that causes a bounce for the back-scan of i\\nk - final element that we find for the back-scan of i\\n\\nThis situation describes the one bounce that j can cause. For any element after i that we process, we will either terminate before or when we reach i, or we will determine that i is not the end of our search and i will instruct the search to jump to k. Jumping to k bypasses the element at j, so we will never visit j again. If i causes such a bounce, it will also eliminate itself, and the range of that jump must extend over both i and j, so jumping over i continues to prevent any future scans from processing j.\\n\\nThink of an element that bounces the scan as moving into the shadow of another element. The element at i \"hides\" the element at j.\\n\\nThus, each element can participate in at most one bounce before being eliminated from all future back-scans.\\n\\nCredits @flarbear",
                "solutionTags": [],
                "code": "The simplest explanation I can give for why the left/right processing is O(N) is that as you do the back-scans you bounce over some nodes and terminate at another and there are N such back-scans.\\n\\nEach termination happens once per back-scan, so there are O(N) termination steps collectively.\\n\\nEach node that tells the back-scan to bounce over it will never participate in any future back-scans ever again. So, each node can cause a bounce at most once, thus the bounce steps are also bounded by N.\\n\\n**This is because if we are at a node i and when checking back , a node j tells us to bounce back implies that  j is greater than i. So in future if we go at any node greater than i , it will terminate at i and not reach  j .  And if the future node is less than i  then it will bounce back from i and will go past j ( never go to j ).**\\n\\nO(N) terminations + O(N) bounces are thus O(N).\\n\\nTo go into more detail about why an element only ever is processed for a single bounce operation, consider:\\n\\ni - element we are starting with for a back-scan\\nj - element that causes a bounce for the back-scan of i\\nk - final element that we find for the back-scan of i\\n\\nThis situation describes the one bounce that j can cause. For any element after i that we process, we will either terminate before or when we reach i, or we will determine that i is not the end of our search and i will instruct the search to jump to k. Jumping to k bypasses the element at j, so we will never visit j again. If i causes such a bounce, it will also eliminate itself, and the range of that jump must extend over both i and j, so jumping over i continues to prevent any future scans from processing j.\\n\\nThink of an element that bounces the scan as moving into the shadow of another element. The element at i \"hides\" the element at j.\\n\\nThus, each element can participate in at most one bounce before being eliminated from all future back-scans.\\n\\nCredits @flarbear",
                "codeTag": "Unknown"
            },
            {
                "id": 2262181,
                "title": "aditya-verma-approach-c-solution",
                "content": "We need to find next smaller element to right and left for all the indices. ( So as to calculate the maximum width ,as max width will give us max area )\\nSo next smaller element to right is strored in right vector and next smaller element to left is strored in left vector.\\nFor every index width [i] is given by width[i]=right[i]-left[i]-1 and height is given already.\\nNow you can find area for each index and maximize it.\\n```\\n int largestRectangleArea(vector<int>& heights) {\\n        \\n        vector<int> right;\\n        vector<int> left;\\n        stack<pair<int,int>> l;\\n        stack<pair<int,int>> r;\\n        for(int i=heights.size()-1;i>=0;i--){\\n            if(r.empty()){\\n                right.push_back(heights.size());\\n            }\\n            else if(!r.empty() && r.top().first<heights[i]){\\n                right.push_back(r.top().second);\\n            }\\n            else if(!r.empty() && r.top().first>=heights[i]){\\n                while(!r.empty() && r.top().first>=heights[i]){\\n                    r.pop();\\n                }\\n                if(r.empty()){\\n                    right.push_back(heights.size());\\n                }\\n                else{\\n                    right.push_back(r.top().second);\\n                }\\n            }\\n            r.push({heights[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        \\n        \\n        for(int i=0;i<heights.size();i++){\\n            if(l.empty()){\\n                left.push_back(-1);\\n            }\\n            else if(!l.empty() && l.top().first<heights[i]){\\n                left.push_back(l.top().second);\\n            }\\n            else if(!l.empty() && l.top().first>=heights[i]){\\n                while(!l.empty() && l.top().first>=heights[i]){\\n                    l.pop();\\n                }\\n                if(l.empty()){\\n                    left.push_back(-1);\\n                }\\n                else{\\n                    left.push_back(l.top().second);\\n                }\\n            }\\n            l.push({heights[i],i});\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<heights.size();i++){\\n            ans=max(ans,(right[i]-left[i]-1)*(heights[i]));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n int largestRectangleArea(vector<int>& heights) {\\n        \\n        vector<int> right;\\n        vector<int> left;\\n        stack<pair<int,int>> l;\\n        stack<pair<int,int>> r;\\n        for(int i=heights.size()-1;i>=0;i--){\\n            if(r.empty()){\\n                right.push_back(heights.size());\\n            }\\n            else if(!r.empty() && r.top().first<heights[i]){\\n                right.push_back(r.top().second);\\n            }\\n            else if(!r.empty() && r.top().first>=heights[i]){\\n                while(!r.empty() && r.top().first>=heights[i]){\\n                    r.pop();\\n                }\\n                if(r.empty()){\\n                    right.push_back(heights.size());\\n                }\\n                else{\\n                    right.push_back(r.top().second);\\n                }\\n            }\\n            r.push({heights[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        \\n        \\n        for(int i=0;i<heights.size();i++){\\n            if(l.empty()){\\n                left.push_back(-1);\\n            }\\n            else if(!l.empty() && l.top().first<heights[i]){\\n                left.push_back(l.top().second);\\n            }\\n            else if(!l.empty() && l.top().first>=heights[i]){\\n                while(!l.empty() && l.top().first>=heights[i]){\\n                    l.pop();\\n                }\\n                if(l.empty()){\\n                    left.push_back(-1);\\n                }\\n                else{\\n                    left.push_back(l.top().second);\\n                }\\n            }\\n            l.push({heights[i],i});\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<heights.size();i++){\\n            ans=max(ans,(right[i]-left[i]-1)*(heights[i]));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2056949,
                "title": "best-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] arr) {\\n        Stack < Integer > st = new Stack <> ();\\n        int maxA = 0;\\n        int n = arr.length;\\n        for (int i = 0; i <= n; i++) {\\n            while (!st.empty() && (i == n || arr[st.peek()] >= arr[i])) {\\n                int height = arr[st.peek()];\\n                st.pop();\\n                int width;\\n                if (st.empty())\\n                    width = i;\\n                else\\n                    width = i - st.peek() - 1;\\n                maxA = Math.max(maxA, width * height);\\n            }\\n            st.push(i);\\n        }\\n        return maxA;\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public int largestRectangleArea(int[] arr) {\\n        Stack < Integer > st = new Stack <> ();\\n        int maxA = 0;\\n        int n = arr.length;\\n        for (int i = 0; i <= n; i++) {\\n            while (!st.empty() && (i == n || arr[st.peek()] >= arr[i])) {\\n                int height = arr[st.peek()];\\n                st.pop();\\n                int width;\\n                if (st.empty())\\n                    width = i;\\n                else\\n                    width = i - st.peek() - 1;\\n                maxA = Math.max(maxA, width * height);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1728337,
                "title": "o-n-solution-c-stacks-intuition-explanation",
                "content": "Alright, first let\\'s talk about the intuition. This problem wants us to find the area of the largest rectangle, which means, the height is going to be one of the histogram bars.\\nThis is pretty simple to claim, since if a rectangle is possible at all, its height can\\'t be greater than all the bars it covers, and then it\\'s height can thus at max be the height of the shortest bar in the range.\\nThis tells us that we need to find the span of the array where a particular height of a bar is minimum, this would make it the height-deciding-bar of the rectangle. Now, finding the range by brute force could be O(n^2), we want a shorter way. \\nThis leads us to trying alternate options. You see, the update for a height only comes in if there\\'s a new minima encountered, as any rectangle found further from here can not cross this unless it\\'s height it at most equal to this minima. So in a way we are to keep track of the minima that we are encountering. How far? Yes, there\\'s a history involved. So keeping track of the minima encountered plus the history -> we should think of something like a stack. Mind you, a vector works as well. We are just going for simple data structures. Stack does the job.\\n\\nNow, coming to implementation. We need to keep track of where the minima was seen so that we can find the length of rectangle. So the stack stores a pair -- the minima seen and the index. We first make a false bottom to not run into empty stack scenarios. Next, push everytime you see a higher bar than the top. Why? Suppose you encounter a smaller bar this time, you pop until you have seen an even smaller bar at the top, because your rectangle with the height of the bar encountered has to start from atleast after this index. So, you pop till you find the right place to put the new minima. While popping, see if any of the bars which were bigger than this minima could have led to a larger rectangle. (see the update for this)\\nNow, once you have traversed the whole array, you know that all your rectangles formed from the tops can span all the way to the end, there\\'s not any other minima which will concern it.\\nSo, pop one by one till you reach the false bottom, and keep updating your answer.\\nOne thing to note is that when you are inserting the new minima, note that the index at which you encountered shouldn\\'t be the true index of that minima, it should be one more than the index of the next lower minima occuring before it. \\nPlease have a look at the code for the solution. Hope it helps!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<pair<int,int>> hts;\\n        hts.push(make_pair(0,-1));//to avoid edge cases\\n        int n = heights.size();\\n        int maxarea = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            auto t = hts.top();\\n            int x = -1;\\n            while(t.second != -1 && t.first > heights[i])\\n            {\\n                int area = t.first*(i-t.second);\\n                maxarea = (maxarea > area)? maxarea : area;\\n                hts.pop();\\n                x = t.second;\\n                t = hts.top();\\n            }\\n            if(x == -1) hts.push(make_pair(heights[i], i));\\n            else hts.push(make_pair(heights[i], x));\\n                    \\n        }\\n        \\n        auto t = hts.top();\\n        while(t.second != -1)\\n        {\\n            int area = t.first*(n-t.second);\\n            maxarea = (maxarea > a)? maxarea : area;\\n            hts.pop();\\n            t = hts.top();\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<pair<int,int>> hts;\\n        hts.push(make_pair(0,-1));//to avoid edge cases\\n        int n = heights.size();\\n        int maxarea = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            auto t = hts.top();\\n            int x = -1;\\n            while(t.second != -1 && t.first > heights[i])\\n            {\\n                int area = t.first*(i-t.second);\\n                maxarea = (maxarea > area)? maxarea : area;\\n                hts.pop();\\n                x = t.second;\\n                t = hts.top();\\n            }\\n            if(x == -1) hts.push(make_pair(heights[i], i));\\n            else hts.push(make_pair(heights[i], x));\\n                    \\n        }\\n        \\n        auto t = hts.top();\\n        while(t.second != -1)\\n        {\\n            int area = t.first*(n-t.second);\\n            maxarea = (maxarea > a)? maxarea : area;\\n            hts.pop();\\n            t = hts.top();\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710324,
                "title": "o-n-solution-c-easy-using-stack-and-left-right-boundary-concept",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        stack<int> st; //stack to keep track of position\\n        vector<int> left_bound(n,0),right_bound(n,0); //arrays to keep the left and right boundary of the rectabgles\\n        \\n        //Finding the left boundary for each possible rectangle\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                left_bound[i]=0;\\n            }\\n            else\\n            {\\n                left_bound[i] = st.top()+1;\\n            }\\n            st.push(i);\\n        }\\n        //Clear the stack for re-use\\n        while(!st.empty())\\n        {\\n            st.pop();\\n        }\\n        \\n        //Finding the right boundary for each possible rectangle\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                right_bound[i] = n-1;\\n            }\\n            else\\n            {\\n                right_bound[i] = st.top()-1;\\n            }\\n            st.push(i);\\n        }\\n        \\n        //Calculating all possible rectangle areas using left and right boundary of each rectangle\\n        int maxi = 0, area;\\n        for(int i=0;i<n;i++)\\n        {\\n            area = (right_bound[i]-left_bound[i]+1)*heights[i];\\n            maxi = max(maxi, area);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        stack<int> st; //stack to keep track of position\\n        vector<int> left_bound(n,0),right_bound(n,0); //arrays to keep the left and right boundary of the rectabgles\\n        \\n        //Finding the left boundary for each possible rectangle\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                left_bound[i]=0;\\n            }\\n            else\\n            {\\n                left_bound[i] = st.top()+1;\\n            }\\n            st.push(i);\\n        }\\n        //Clear the stack for re-use\\n        while(!st.empty())\\n        {\\n            st.pop();\\n        }\\n        \\n        //Finding the right boundary for each possible rectangle\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                right_bound[i] = n-1;\\n            }\\n            else\\n            {\\n                right_bound[i] = st.top()-1;\\n            }\\n            st.push(i);\\n        }\\n        \\n        //Calculating all possible rectangle areas using left and right boundary of each rectangle\\n        int maxi = 0, area;\\n        for(int i=0;i<n;i++)\\n        {\\n            area = (right_bound[i]-left_bound[i]+1)*heights[i];\\n            maxi = max(maxi, area);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610944,
                "title": "largest-rectangle-in-histogram-stack-based-o-n",
                "content": "Question: https://leetcode.com/problems/largest-rectangle-in-histogram/\\nGiven an array of integers heights representing the histogram\\'s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\n\\nObservation:\\nlet\\'s take an example array `heights[] = [2,1,5,5,4,6,2,3]` heights[4] traces a rectangle of height 4 and length of 2 - 5 + 1, where heights[2-1] is the first element to the left smaller than heights[4], and height[5+1] is first element to right smaller than height[4].\\n\\nFor an element at index i if j is the first element to right smaller than heights[i] and k is the first element to right smaller than heights[i], then area of the rectangle traced by heights[i] is `(abs(j-i) + abs(i-k) - 1) * heights[i]`, we can find j and k for each i in heights, by using stacks.\\n\\nC<>de:\\n```\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int len = heights.size();\\n        stack<int>st;\\n        stack<int>st1;\\n        st.push(-1);\\n        st1.push(len);\\n        vector<int>left(len, 0);\\n        vector<int>right(len, 0);\\n\\t\\t\\n\\t\\t// finding the nearest smaller element to the left of each element\\n        for(int i=0; i<len; ++i) {\\n            while(st.top()!=-1 && heights[i] <= heights[st.top()]) {\\n                st.pop();\\n            }\\n            left[i] = st.top();\\n            st.push(i);\\n        }\\n        \\n\\t\\t// finding the nearest smaller element to the right of each element\\n        for(int i=len-1; i>=0; i--) {\\n            while(st1.top()!=len && heights[i] <= heights[st1.top()]) {\\n                st1 .pop();\\n            }\\n            right[i] = st1.top();\\n            st1.push(i);\\n        }\\n\\t\\t\\n        int ans = INT_MIN;\\n        for(int i=0; i<len; ++i) {\\n            ans = max(ans, ((abs(i-left[i])+abs(i-right[i])-1)*heights[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int len = heights.size();\\n        stack<int>st;\\n        stack<int>st1;\\n        st.push(-1);\\n        st1.push(len);\\n        vector<int>left(len, 0);\\n        vector<int>right(len, 0);\\n\\t\\t\\n\\t\\t// finding the nearest smaller element to the left of each element\\n        for(int i=0; i<len; ++i) {\\n            while(st.top()!=-1 && heights[i] <= heights[st.top()]) {\\n                st.pop();\\n            }\\n            left[i] = st.top();\\n            st.push(i);\\n        }\\n        \\n\\t\\t// finding the nearest smaller element to the right of each element\\n        for(int i=len-1; i>=0; i--) {\\n            while(st1.top()!=len && heights[i] <= heights[st1.top()]) {\\n                st1 .pop();\\n            }\\n            right[i] = st1.top();\\n            st1.push(i);\\n        }\\n\\t\\t\\n        int ans = INT_MIN;\\n        for(int i=0; i<len; ++i) {\\n            ans = max(ans, ((abs(i-left[i])+abs(i-right[i])-1)*heights[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469807,
                "title": "java-easy-to-understand-using-java",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        Stack<Integer> st = new Stack<>();\\n        int maxArea = 0;\\n        st.push(-1);\\n        for(int i=0;i<=heights.length;i++)\\n        {\\n            int val = i==heights.length ? 0 : heights[i];\\n            \\n            while(st.peek() != -1 && heights[st.peek()] >= val)\\n            {\\n                int rightMin = i;\\n                int height = heights[st.pop()];\\n                int leftMin = st.peek();\\n                maxArea = Math.max(maxArea,height*(rightMin-leftMin-1));\\n            }\\n            st.push(i);\\n        }\\n        return maxArea;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        Stack<Integer> st = new Stack<>();\\n        int maxArea = 0;\\n        st.push(-1);\\n        for(int i=0;i<=heights.length;i++)\\n        {\\n            int val = i==heights.length ? 0 : heights[i];\\n            \\n            while(st.peek() != -1 && heights[st.peek()] >= val)\\n            {\\n                int rightMin = i;\\n                int height = heights[st.pop()];\\n                int leftMin = st.peek();\\n                maxArea = Math.max(maxArea,height*(rightMin-leftMin-1));\\n            }\\n            st.push(i);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259739,
                "title": "simple-c-solution-using-stack-with-explanation",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\n// there will be atleast one full bar included in the rectangle\\n// idea is to calculate maximum  area taking each bar as the fully included bar \\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        stack<int> s;\\n        int max_area = 0;\\n        int area_with_top = 0;\\n        int top = 0, i = 0;\\n        while(i < n)\\n        {\\n            if(s.empty() || heights[s.top()] <= heights[i])\\n            {\\n                s.push(i++);\\n            }\\n            else\\n            {   \\n                top = s.top();\\n                s.pop();\\n                // heights[top] = fully included bar\\n                // heights[i] = nearest right bar with height < current bar\\n                // heights[s.top()] = nearest left bar with height < current bar\\n                area_with_top = heights[top] * (s.empty() ? i : i - s.top() - 1);\\n                max_area = max(max_area, area_with_top);\\n            }\\n        }\\n        while (!s.empty())\\n        {\\n            top = s.top();\\n            s.pop();\\n            // s.empty() means it is the smallest bar \\n            area_with_top = heights[top] * (s.empty() ? i : i - s.top() - 1);\\n            max_area = max(max_area, area_with_top);\\n        }\\n        return max_area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// there will be atleast one full bar included in the rectangle\\n// idea is to calculate maximum  area taking each bar as the fully included bar \\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        stack<int> s;\\n        int max_area = 0;\\n        int area_with_top = 0;\\n        int top = 0, i = 0;\\n        while(i < n)\\n        {\\n            if(s.empty() || heights[s.top()] <= heights[i])\\n            {\\n                s.push(i++);\\n            }\\n            else\\n            {   \\n                top = s.top();\\n                s.pop();\\n                // heights[top] = fully included bar\\n                // heights[i] = nearest right bar with height < current bar\\n                // heights[s.top()] = nearest left bar with height < current bar\\n                area_with_top = heights[top] * (s.empty() ? i : i - s.top() - 1);\\n                max_area = max(max_area, area_with_top);\\n            }\\n        }\\n        while (!s.empty())\\n        {\\n            top = s.top();\\n            s.pop();\\n            // s.empty() means it is the smallest bar \\n            area_with_top = heights[top] * (s.empty() ? i : i - s.top() - 1);\\n            max_area = max(max_area, area_with_top);\\n        }\\n        return max_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995233,
                "title": "largest-rectangle-in-histogram-c-explanation",
                "content": "```\\n1) Create an empty stack.\\n\\n2) Start from first bar, and do following for every bar \\u2018hist[i]\\u2019 where \\u2018i\\u2019 varies from 0 to n-1.\\n\\u2026\\u2026a) If stack is empty or hist[i] is higher than the bar at top of stack, then push \\u2018i\\u2019 to stack.\\n\\u2026\\u2026b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the \\u2018left index\\u2019 is previous (previous to tp) item in stack and \\u2018right index\\u2019 is \\u2018i\\u2019 (current index).\\n\\n3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        stack<int> s;\\n        \\n        int i=0;\\n        \\n        int n=heights.size();\\n        \\n        int max_area=0;\\n   \\n        //Approach is to consider each bar as the smallest bar while calculating the area\\n        \\n        while(i<n){\\n            \\n            //If current bar is the larger than stack top means we havent reached right bounding condition for a previously larger bar(current larger bar is NOT the right boundary till which we can consider area with the s.top() bar as the bar with min height,so we simply push the bar)\\n            if(s.empty() || heights[s.top()]<heights[i]){\\n                s.push(i);\\n                i++;\\n                continue;\\n            }\\n            \\n            else{\\n                \\n                int x=s.top();\\n                s.pop();\\n                \\n                // [2,1,5,6,3] if stack is not empty then the popped bar i considered as min height bar and its left and right bounds have a total width of i(current index)-s.top()(previous index)-1(due to zero based indexing)\\n                \\n                //if stack is empty then we simply multiply with i ,eg: 1 height bar will remain in the stack till the end so thw width of rectangle considering 1 as min height bar will be the entire histogram width itself which is i.\\n                \\n                int area=heights[x] *(s.empty()?i:i-s.top()-1);\\n                max_area=max(max_area,area);\\n            }\\n        }\\n        \\n        //Process the remaining bars\\n        \\n        while(!s.empty()){\\n            int x=s.top();\\n            s.pop();\\n            int area=heights[x]*(s.empty()?i:i-s.top()-1);\\n            max_area=max(max_area,area);\\n        }\\n        \\n        return max_area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1) Create an empty stack.\\n\\n2) Start from first bar, and do following for every bar \\u2018hist[i]\\u2019 where \\u2018i\\u2019 varies from 0 to n-1.\\n\\u2026\\u2026a) If stack is empty or hist[i] is higher than the bar at top of stack, then push \\u2018i\\u2019 to stack.\\n\\u2026\\u2026b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the \\u2018left index\\u2019 is previous (previous to tp) item in stack and \\u2018right index\\u2019 is \\u2018i\\u2019 (current index).\\n\\n3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        stack<int> s;\\n        \\n        int i=0;\\n        \\n        int n=heights.size();\\n        \\n        int max_area=0;\\n   \\n        //Approach is to consider each bar as the smallest bar while calculating the area\\n        \\n        while(i<n){\\n            \\n            //If current bar is the larger than stack top means we havent reached right bounding condition for a previously larger bar(current larger bar is NOT the right boundary till which we can consider area with the s.top() bar as the bar with min height,so we simply push the bar)\\n            if(s.empty() || heights[s.top()]<heights[i]){\\n                s.push(i);\\n                i++;\\n                continue;\\n            }\\n            \\n            else{\\n                \\n                int x=s.top();\\n                s.pop();\\n                \\n                // [2,1,5,6,3] if stack is not empty then the popped bar i considered as min height bar and its left and right bounds have a total width of i(current index)-s.top()(previous index)-1(due to zero based indexing)\\n                \\n                //if stack is empty then we simply multiply with i ,eg: 1 height bar will remain in the stack till the end so thw width of rectangle considering 1 as min height bar will be the entire histogram width itself which is i.\\n                \\n                int area=heights[x] *(s.empty()?i:i-s.top()-1);\\n                max_area=max(max_area,area);\\n            }\\n        }\\n        \\n        //Process the remaining bars\\n        \\n        while(!s.empty()){\\n            int x=s.top();\\n            s.pop();\\n            int area=heights[x]*(s.empty()?i:i-s.top()-1);\\n            max_area=max(max_area,area);\\n        }\\n        \\n        return max_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813312,
                "title": "c-easy-solution-simple-and-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextSmallerToLeft(vector<int>&heights,vector<int>& nsl){\\n       stack<int>s;\\n        for(int i=0; i<heights.size(); i++){\\n            while(!s.empty() && heights[s.top()] >= heights[i])\\n                s.pop();\\n            if(s.empty())\\n                nsl[i] = -1;\\n            else\\n                nsl[i] = s.top();\\n            \\n            s.push(i);\\n        }\\n    }\\n    \\n    void nextSmallerToRight(vector<int>&heights, vector<int>& nsr){\\n        stack<int>s;\\n        for(int i=heights.size()-1 ; i>=0; i--){\\n            while(!s.empty() && heights[s.top()] >= heights[i])\\n                s.pop();\\n            if(s.empty())\\n                nsr[i] = heights.size();\\n            else\\n                nsr[i] = s.top();\\n            \\n            s.push(i);\\n        }\\n    }\\n    \\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int>nsl(n);\\n        vector<int>nsr(n);\\n\\n        int area = 0;\\n        nextSmallerToLeft(heights,nsl);\\n        nextSmallerToRight(heights,nsr);\\n       \\n        for(int i=0; i<n; i++){\\n            area = max((nsr[i] - nsl[i] - 1) * heights[i], area);\\n        }\\n        \\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextSmallerToLeft(vector<int>&heights,vector<int>& nsl){\\n       stack<int>s;\\n        for(int i=0; i<heights.size(); i++){\\n            while(!s.empty() && heights[s.top()] >= heights[i])\\n                s.pop();\\n            if(s.empty())\\n                nsl[i] = -1;\\n            else\\n                nsl[i] = s.top();\\n            \\n            s.push(i);\\n        }\\n    }\\n    \\n    void nextSmallerToRight(vector<int>&heights, vector<int>& nsr){\\n        stack<int>s;\\n        for(int i=heights.size()-1 ; i>=0; i--){\\n            while(!s.empty() && heights[s.top()] >= heights[i])\\n                s.pop();\\n            if(s.empty())\\n                nsr[i] = heights.size();\\n            else\\n                nsr[i] = s.top();\\n            \\n            s.push(i);\\n        }\\n    }\\n    \\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int>nsl(n);\\n        vector<int>nsr(n);\\n\\n        int area = 0;\\n        nextSmallerToLeft(heights,nsl);\\n        nextSmallerToRight(heights,nsr);\\n       \\n        for(int i=0; i<n; i++){\\n            area = max((nsr[i] - nsl[i] - 1) * heights[i], area);\\n        }\\n        \\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425762,
                "title": "javascript-brute-force-and-stack-solutions",
                "content": "## Brute Force\\n```\\nvar largestRectangleArea = function(heights) {\\n  let max = 0;\\n  for (let i = 0; i< heights.length; i++) {\\n      const base = heights[i];\\n      const arr = [heights[i]];\\n      \\n      // go right\\n      for (let j = i + 1; j < heights.length; j++) {\\n          if (heights[j] < base) break;\\n          arr.push(heights[j])\\n      }\\n      // go left\\n      for (let j = i - 1; j >= 0; j--) {\\n          if (heights[j] < base) break;\\n          arr.push(heights[j])\\n      }\\n      \\n      // calc and compare\\n      const area = arr.length * base\\n      if (area > max) max = area;\\n  }\\n  \\n  return max;\\n};\\n```\\n\\n\\n## Stack\\n\\n```\\nvar largestRectangleArea = function(heights) {\\n  let maxArea = 0;\\n  const stack = [{ left: 0, val: 0 }];\\n\\n  const peek = () => stack[stack.length - 1] || null;\\n\\n  for (let i = 0; i <= heights.length; i++) {\\n    const push = () => stack.push({ left: i + 1, val: heights[i] });\\n      \\n    if (heights[i] && heights[i] > peek().val) {\\n      push();\\n    } else {\\n\\n\\n      while (peek() && peek().val > (heights[i] || 0)) {\\n        const top = stack.pop();\\n        const left = peek() ? peek().left : 0;\\n        maxArea = Math.max(maxArea, (i - left) * top.val);\\n      }\\n      push();\\n    }\\n  }\\n  return maxArea;\\n };\\n ```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar largestRectangleArea = function(heights) {\\n  let max = 0;\\n  for (let i = 0; i< heights.length; i++) {\\n      const base = heights[i];\\n      const arr = [heights[i]];\\n      \\n      // go right\\n      for (let j = i + 1; j < heights.length; j++) {\\n          if (heights[j] < base) break;\\n          arr.push(heights[j])\\n      }\\n      // go left\\n      for (let j = i - 1; j >= 0; j--) {\\n          if (heights[j] < base) break;\\n          arr.push(heights[j])\\n      }\\n      \\n      // calc and compare\\n      const area = arr.length * base\\n      if (area > max) max = area;\\n  }\\n  \\n  return max;\\n};\\n```\n```\\nvar largestRectangleArea = function(heights) {\\n  let maxArea = 0;\\n  const stack = [{ left: 0, val: 0 }];\\n\\n  const peek = () => stack[stack.length - 1] || null;\\n\\n  for (let i = 0; i <= heights.length; i++) {\\n    const push = () => stack.push({ left: i + 1, val: heights[i] });\\n      \\n    if (heights[i] && heights[i] > peek().val) {\\n      push();\\n    } else {\\n\\n\\n      while (peek() && peek().val > (heights[i] || 0)) {\\n        const top = stack.pop();\\n        const left = peek() ? peek().left : 0;\\n        maxArea = Math.max(maxArea, (i - left) * top.val);\\n      }\\n      push();\\n    }\\n  }\\n  return maxArea;\\n };\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 332652,
                "title": "java-o-n-stack-implementation-with-neat-algorithm",
                "content": "Algorithm: \\n* Maintain a stack\\n * If stack is empty or value at index of stack is less than or equal to value at current \\n index, push this into stack.\\n * Otherwise keep removing values from stack till value at index at top of stack is \\n less than value at current index.\\n * While removing value from stack calculate area\\n\\t * if stack is empty it means that till this point value just removed has to be smallest element\\n       so area = input[top] * i\\n\\t * if stack is not empty then this value at index top is less than or equal to everything from stack top + 1 till i. So area will area = input[top] * (i - stack.peek() - 1);\\n * Finally maxArea is area if area is greater than maxArea.\\n \\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        if (n == 1) {\\n            return heights[0];\\n        }\\n        Stack<Integer> stack = new Stack<>();\\n        int maxArea = 0;\\n        int index = 0;\\n        while (index < n) {\\n            if (stack.isEmpty() || heights[index] >= heights[stack.peek()]) {\\n                stack.push(index++);\\n            } else {\\n                int top = stack.pop();\\n                int area = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);\\n                maxArea = Math.max(maxArea, area);\\n            }\\n        }\\n        while (!stack.isEmpty()) {\\n            int top = stack.pop();\\n            int area = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n}\\n```\\nSuggestions are most welcome, if you liked the solution please upvote. :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        if (n == 1) {\\n            return heights[0];\\n        }\\n        Stack<Integer> stack = new Stack<>();\\n        int maxArea = 0;\\n        int index = 0;\\n        while (index < n) {\\n            if (stack.isEmpty() || heights[index] >= heights[stack.peek()]) {\\n                stack.push(index++);\\n            } else {\\n                int top = stack.pop();\\n                int area = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);\\n                maxArea = Math.max(maxArea, area);\\n            }\\n        }\\n        while (!stack.isEmpty()) {\\n            int top = stack.pop();\\n            int area = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329301,
                "title": "cpp-faster-than-100",
                "content": "```cpp\\n#pragma GCC optimise (\"Ofast\")\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL;}();\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        heights.push_back(0);\\n        int n = heights.size();\\n        stack<int> s;\\n        int area, maxArea = 0, i = 0;\\n        while(i < n){\\n            if(s.empty() || heights[i] > heights[s.top()]) s.push(i++);\\n            else{\\n                int top = s.top();\\n                s.pop();\\n                area = heights[top] * (s.empty() ? i : i - s.top() - 1);\\n                maxArea = max(maxArea, area);\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n#pragma GCC optimise (\"Ofast\")\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL;}();\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        heights.push_back(0);\\n        int n = heights.size();\\n        stack<int> s;\\n        int area, maxArea = 0, i = 0;\\n        while(i < n){\\n            if(s.empty() || heights[i] > heights[s.top()]) s.push(i++);\\n            else{\\n                int top = s.top();\\n                s.pop();\\n                area = heights[top] * (s.empty() ? i : i - s.top() - 1);\\n                maxArea = max(maxArea, area);\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315572,
                "title": "c-o-n-solution-stack-based-approach",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        stack<int> aStack;\\n        \\n        int aResult = 0;\\n        for (int i=0;i<=heights.size();i++) {\\n            \\n            int aCurrentHeight = i < heights.size() ? heights[i] : 0;\\n            \\n            if (aStack.empty() || aCurrentHeight >= heights[aStack.top()]) {\\n                aStack.push(i);\\n            } else {\\n                int aTop = aStack.top(); aStack.pop();\\n                int aHeight = heights[aTop];\\n                \\n                int aSpan = aStack.empty() ? i : (i - (aStack.top() + 1));\\n                int aArea = aSpan * aHeight;\\n                \\n                aResult = max(aResult, aArea);\\n                \\n                i -= 1;\\n            }\\n        }\\n        return aResult;\\n    }\\n};\\n```\\n\\nThis is one way to construct the loop which reduces duplicate code...\\n\\nBasically, once you start decreasing in height, you can walk backwards to something of lower height. You will move forward if you can achieve taller height than the current top of the stack. This functions sort of like a sliding window, which optimizes area.\\n\\nGood luck, have fun.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        stack<int> aStack;\\n        \\n        int aResult = 0;\\n        for (int i=0;i<=heights.size();i++) {\\n            \\n            int aCurrentHeight = i < heights.size() ? heights[i] : 0;\\n            \\n            if (aStack.empty() || aCurrentHeight >= heights[aStack.top()]) {\\n                aStack.push(i);\\n            } else {\\n                int aTop = aStack.top(); aStack.pop();\\n                int aHeight = heights[aTop];\\n                \\n                int aSpan = aStack.empty() ? i : (i - (aStack.top() + 1));\\n                int aArea = aSpan * aHeight;\\n                \\n                aResult = max(aResult, aArea);\\n                \\n                i -= 1;\\n            }\\n        }\\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311665,
                "title": "simple-30-lines-c-divide-and-conquer-solution-o-nlogn",
                "content": "divide and conquer \\uFF08\\u5206\\u6CBB\\u6CD5\\uFF09\\n1.  find the shortest rectagle\\uFF08\\u627E\\u5230\\u6700\\u77EE\\u7684\\u90A3\\u4E2A\\u65B9\\u5F62\\uFF09\\uFF1B\\n2. then there are 3 situations\\uFF08\\u7136\\u540E\\u6709\\u4E09\\u79CD\\u60C5\\u51B5\\uFF09\\n\\u2460 the solution is in the left side, get with Recursion\\uFF08\\u89E3\\u5728\\u5DE6\\u8FB9\\uFF0C\\u9012\\u5F52\\u6C42\\u89E3\\uFF09 \\n![image](https://assets.leetcode.com/users/caorou1016/image_1560513414.png)\\n\\u2461 the solution is in the right side, get with Recursion\\uFF08\\u89E3\\u5728\\u53F3\\u8FB9\\uFF0C\\u9012\\u5F52\\u6C42\\u89E3\\uFF09 \\n![image](https://assets.leetcode.com/users/caorou1016/image_1560513635.png)\\n\\u2462 here is the solution\\uFF08\\u8FD9\\u5C31\\u662F\\u89E3\\uFF09\\uFF1A\\n![image](https://assets.leetcode.com/users/caorou1016/image_1560513675.png)\\n\\nthe code\\uFF1A\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {      \\n        return get_largest_rec(heights, 0, heights.size() - 1);\\n    }\\nprivate:\\n    int get_largest_rec(vector<int>& heights, int start, int end){\\n        if(start < 0 || end > heights.size() - 1 || end < start){\\n            return 0;\\n        }\\n        if(start == end){\\n            return heights[start];\\n        }\\n        \\n        int h_min = heights[start];\\n        int i_min = start;\\n        for(int i = start + 1; i <= end; ++i){\\n            if(h_min > heights[i]){\\n                h_min = heights[i];\\n                i_min = i;\\n            }\\n        }\\n        \\n        int l_max = get_largest_rec(heights, start, i_min - 1);\\n        int r_max = get_largest_rec(heights, i_min + 1, end);\\n        int m_max = h_min * (end - start + 1);\\n        int ans = max(max(l_max, r_max), m_max);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {      \\n        return get_largest_rec(heights, 0, heights.size() - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 264532,
                "title": "python-o-n-stack",
                "content": "```\\n    def largestRectangleArea(self, h):\\n        h.append(0)\\n        h.insert(0, 0)\\n        maxA, stack = 0, [0]\\n        \\n        for i in range(0,len(h)):\\n            while h[i] < h[stack[-1]]:\\n                maxA = max(h[stack.pop()] * (i - stack[-1] - 1), maxA)\\n            stack.append(i)\\n        return maxA\\n```",
                "solutionTags": [],
                "code": "```\\n    def largestRectangleArea(self, h):\\n        h.append(0)\\n        h.insert(0, 0)\\n        maxA, stack = 0, [0]\\n        \\n        for i in range(0,len(h)):\\n            while h[i] < h[stack[-1]]:\\n                maxA = max(h[stack.pop()] * (i - stack[-1] - 1), maxA)\\n            stack.append(i)\\n        return maxA\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 179328,
                "title": "segment-tree-brute-force-beat-0",
                "content": "```py\\nclass MinTree:\\n    def __init__(self, arr,i,j):\\n        self.arr = arr\\n        self.left = None\\n        self.right = None\\n        self.i = i\\n        self.j = j\\n        self.mid = None\\n        self.min = None\\n        if j-i == 1:\\n            self.min = i\\n        else:\\n            self.mid = (i+j)//2\\n            self.left = MinTree(arr, i, self.mid)\\n            self.right = MinTree(arr, self.mid, j)\\n            \\n    def min_val(self):\\n        # print(\\'min_val\\', self.mid, self.min)\\n        if self.min is None:\\n            self.min = min((self.left.min_val(), self.right.min_val()), key=self.arr.__getitem__)\\n        return self.min\\n    \\n    def __call__(self, fro, to):\\n        # print(\\'call\\', self.mid, fro, to)\\n        if self.mid is None:\\n            return self.min_val()\\n        if fro <= self.i and self.j <= to:\\n            return self.min_val()\\n        if to <= self.mid:\\n            return self.left(fro, to)\\n        if fro >= self.mid:\\n            return self.right(fro, to)\\n        return min((self.left(fro, to), self.right(fro, to)), key=self.arr.__getitem__)\\n        \\n        \\n        \\nclass Solution:\\n    def largestRectangleArea(self, heights):\\n        \"\"\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not heights:\\n            return 0\\n        min_idx = MinTree(heights, 0, len(heights))\\n        def f(fro, to):\\n            if to-fro <= 0:\\n                return 0\\n            if to-fro == 1:\\n                return heights[fro]\\n            mid = min_idx(fro, to)\\n            # print(fro, mid, to)\\n            return max(f(fro, mid), f(mid+1, to), heights[mid] * (to-fro))\\n        return f(0, len(heights))\\n```",
                "solutionTags": [],
                "code": "```py\\nclass MinTree:\\n    def __init__(self, arr,i,j):\\n        self.arr = arr\\n        self.left = None\\n        self.right = None\\n        self.i = i\\n        self.j = j\\n        self.mid = None\\n        self.min = None\\n        if j-i == 1:\\n            self.min = i\\n        else:\\n            self.mid = (i+j)//2\\n            self.left = MinTree(arr, i, self.mid)\\n            self.right = MinTree(arr, self.mid, j)\\n            \\n    def min_val(self):\\n        # print(\\'min_val\\', self.mid, self.min)\\n        if self.min is None:\\n            self.min = min((self.left.min_val(), self.right.min_val()), key=self.arr.__getitem__)\\n        return self.min\\n    \\n    def __call__(self, fro, to):\\n        # print(\\'call\\', self.mid, fro, to)\\n        if self.mid is None:\\n            return self.min_val()\\n        if fro <= self.i and self.j <= to:\\n            return self.min_val()\\n        if to <= self.mid:\\n            return self.left(fro, to)\\n        if fro >= self.mid:\\n            return self.right(fro, to)\\n        return min((self.left(fro, to), self.right(fro, to)), key=self.arr.__getitem__)\\n        \\n        \\n        \\nclass Solution:\\n    def largestRectangleArea(self, heights):\\n        \"\"\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not heights:\\n            return 0\\n        min_idx = MinTree(heights, 0, len(heights))\\n        def f(fro, to):\\n            if to-fro <= 0:\\n                return 0\\n            if to-fro == 1:\\n                return heights[fro]\\n            mid = min_idx(fro, to)\\n            # print(fro, mid, to)\\n            return max(f(fro, mid), f(mid+1, to), heights[mid] * (to-fro))\\n        return f(0, len(heights))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151946,
                "title": "easy-understanding-o-n-solution-for-java-c-c-c",
                "content": "**//\\tJava solution**\\n```\\n\\n    public int largestRectangleArea(int[] heights) {\\n        \\n        Stack<Integer> st = new Stack<Integer>();       //  stack for keeping track of bars position\\n        \\n        int ts;                     //  To store top of stack\\n        int max_area = 0;           //  initial maximum area         \\n        int new_area;               //  getting area with top bar \\n    \\n        int i = 0, total = heights.length;\\n    \\n\\t    while (i < total)       //  working with all bars\\n        {        \\n            if (st.empty() || heights[st.peek()] <= heights[i])         //  if the current bar\\'s height is bigger or \\n                                                                        //  equal than the top of stack\\n                st.push(i++); \\n \\n        else    //  if the current bar\\'s height is less than the top of stack\\n        {\\n            ts = st.pop();  \\n            \\n            new_area = heights[ts] * (st.empty() ? i : i - st.peek() - 1);   //  finding the new area\\n \\n            // update max area, if needed\\n            if (max_area < new_area) max_area = new_area;                        \\t\\n        }              \\n    }     \\n\\t//  finding area for the rest of the bars still in stack\\n    \\n    while (st.empty() == false)\\n    {\\n        \\n        ts = st.pop();\\n        new_area = heights[ts] * (st.empty() ? i : i - st.peek() - 1);\\n \\n        if (max_area < new_area) max_area = new_area;\\n    } \\n    return max_area;        \\n    }\\n\\n\\n```\\n**//\\tC# solution**\\n```\\n\\n    public int LargestRectangleArea(int[] heights) {\\n    \\n        Stack<int> myStack = new Stack<int>();  //  stack for keeping track of bars position        \\n        int topStack;                           //  To store top of stack\\n        int maxArea = 0;                       //  initial maximum area         \\n        int newArea;                           //  getting area with top bar\\n \\n        int total = heights.Length;\\n        int i = 0;\\n            \\n\\t    while (i < total)       //  working with all bars\\n        {        \\n            if ((myStack.Count == 0) || heights[myStack.Peek()] <= heights[i])  //  if the current bar\\'s height is bigger or \\n                                                                                //  equal than the top of stack\\n                myStack.Push(i++); \\n \\n            else    //  if the current bar\\'s height is less than the top of stack\\n            {\\n                \\n                topStack = myStack.Pop();  \\n             \\n                newArea = heights[topStack] * ((myStack.Count == 0) ? i : i - myStack.Peek() - 1);   //  finding the new area\\n \\n                // update max area, if needed\\n                if (maxArea < newArea) maxArea = newArea;                       \\t\\n            }              \\n        }\\n \\n        //  finding area for the rest of the bars still in stack\\n    \\n        while (myStack.Count != 0)\\n        {\\n            \\n            topStack = myStack.Pop();\\n            newArea = heights[topStack] * ((myStack.Count == 0)? i : i - myStack.Peek() - 1);\\n \\n            if (maxArea < newArea) maxArea = newArea;\\n        }\\n \\n        return maxArea;               \\n    }\\n\\n\\n```\\n**//\\tC++**\\n```\\n\\npublic: int largestRectangleArea(vector<int>& heights) {\\n        \\n    stack<int> st;      //  stack for keeping track of bars position\\n    int ts;             //  To store top of stack\\n    int max_area = 0;   //  initial maximum area         \\n    int new_area;       //  getting area with top bar\\n     \\n    int i = 0, total = heights.size();\\n    \\n    while (i < total)       //  working with all bars\\n    {        \\n        if (st.empty() || heights[st.top()] <= heights[i])  //  if the current bar\\'s height is bigger or equal than the top of stack\\n            st.push(i++); \\n \\n        else    //  if the current bar\\'s height is less than the top of stack\\n        {\\n            ts = st.top();  \\n            st.pop();  \\n            \\n            new_area = heights[ts] * (st.empty() ? i : i - st.top() - 1);   //  finding the new area\\n \\n            // update max area, if needed\\n            if (max_area < new_area) max_area = new_area;                        \\t\\n        }              \\n    }\\n \\n    //  finding area for the rest of the bars still in stack    \\n    while (st.empty() == false)\\n    {\\n        ts = st.top();\\n        st.pop();\\n        new_area = heights[ts] * (st.empty() ? i : i - st.top() - 1);\\n \\n        if (max_area < new_area) max_area = new_area;\\n    } \\n    return max_area;        \\n    }\\n\\n\\n```\\n**//\\tC solution**\\n```\\n\\nint largestRectangleArea(int* heights, int heightsSize) {\\n    \\n    int st[heightsSize+1], top=0;     //  stack for keeping track of bars position, top indicates the \\n                                    //  index of current top element in the stack             \\n    int ts;                         //  To store top of stack\\n    int max_area = 0;               //  initial maximum area         \\n    int new_area;                   //  getting area with top bar\\n \\n    \\n    int i = 0;\\n    \\n\\twhile (i < heightsSize)       //  working with all bars\\n    {        \\n        if ((top == 0) || heights[st[top-1]] <= heights[i])  //  if the current bar\\'s height is bigger or equal than the top of stack\\n            { st[top]=i++; top++;} \\n \\n        else    //  if the current bar\\'s height is less than the top of stack\\n        {\\n            ts = st[--top];             \\n             \\n            if(top>0) new_area = heights[ts] * (i - st[top-1] - 1);   //  finding the new area\\n            else new_area = heights[ts] * i;\\n            \\n \\n            // update max area, if needed\\n            if (max_area < new_area) max_area = new_area;               \\n        }      \\n        \\n    }\\n \\n    //  finding area for the rest of the bars still in stack\\n    \\n    while (top>0)\\n    {\\n        ts = st[--top];\\n        \\n        if(top>0) new_area = heights[ts] * (i - st[top-1] - 1);   //  finding the new area\\n            else new_area = heights[ts] * i;\\n \\n        if (max_area < new_area) max_area = new_area;\\n    }\\n \\n    return max_area;\\n        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\n    public int largestRectangleArea(int[] heights) {\\n        \\n        Stack<Integer> st = new Stack<Integer>();       //  stack for keeping track of bars position\\n        \\n        int ts;                     //  To store top of stack\\n        int max_area = 0;           //  initial maximum area         \\n        int new_area;               //  getting area with top bar \\n    \\n        int i = 0, total = heights.length;\\n    \\n\\t    while (i < total)       //  working with all bars\\n        {        \\n            if (st.empty() || heights[st.peek()] <= heights[i])         //  if the current bar\\'s height is bigger or \\n                                                                        //  equal than the top of stack\\n                st.push(i++); \\n \\n        else    //  if the current bar\\'s height is less than the top of stack\\n        {\\n            ts = st.pop();  \\n            \\n            new_area = heights[ts] * (st.empty() ? i : i - st.peek() - 1);   //  finding the new area\\n \\n            // update max area, if needed\\n            if (max_area < new_area) max_area = new_area;                        \\t\\n        }              \\n    }     \\n\\t//  finding area for the rest of the bars still in stack\\n    \\n    while (st.empty() == false)\\n    {\\n        \\n        ts = st.pop();\\n        new_area = heights[ts] * (st.empty() ? i : i - st.peek() - 1);\\n \\n        if (max_area < new_area) max_area = new_area;\\n    } \\n    return max_area;        \\n    }\\n\\n\\n```\n```\\n\\n    public int LargestRectangleArea(int[] heights) {\\n    \\n        Stack<int> myStack = new Stack<int>();  //  stack for keeping track of bars position        \\n        int topStack;                           //  To store top of stack\\n        int maxArea = 0;                       //  initial maximum area         \\n        int newArea;                           //  getting area with top bar\\n \\n        int total = heights.Length;\\n        int i = 0;\\n            \\n\\t    while (i < total)       //  working with all bars\\n        {        \\n            if ((myStack.Count == 0) || heights[myStack.Peek()] <= heights[i])  //  if the current bar\\'s height is bigger or \\n                                                                                //  equal than the top of stack\\n                myStack.Push(i++); \\n \\n            else    //  if the current bar\\'s height is less than the top of stack\\n            {\\n                \\n                topStack = myStack.Pop();  \\n             \\n                newArea = heights[topStack] * ((myStack.Count == 0) ? i : i - myStack.Peek() - 1);   //  finding the new area\\n \\n                // update max area, if needed\\n                if (maxArea < newArea) maxArea = newArea;                       \\t\\n            }              \\n        }\\n \\n        //  finding area for the rest of the bars still in stack\\n    \\n        while (myStack.Count != 0)\\n        {\\n            \\n            topStack = myStack.Pop();\\n            newArea = heights[topStack] * ((myStack.Count == 0)? i : i - myStack.Peek() - 1);\\n \\n            if (maxArea < newArea) maxArea = newArea;\\n        }\\n \\n        return maxArea;               \\n    }\\n\\n\\n```\n```\\n\\npublic: int largestRectangleArea(vector<int>& heights) {\\n        \\n    stack<int> st;      //  stack for keeping track of bars position\\n    int ts;             //  To store top of stack\\n    int max_area = 0;   //  initial maximum area         \\n    int new_area;       //  getting area with top bar\\n     \\n    int i = 0, total = heights.size();\\n    \\n    while (i < total)       //  working with all bars\\n    {        \\n        if (st.empty() || heights[st.top()] <= heights[i])  //  if the current bar\\'s height is bigger or equal than the top of stack\\n            st.push(i++); \\n \\n        else    //  if the current bar\\'s height is less than the top of stack\\n        {\\n            ts = st.top();  \\n            st.pop();  \\n            \\n            new_area = heights[ts] * (st.empty() ? i : i - st.top() - 1);   //  finding the new area\\n \\n            // update max area, if needed\\n            if (max_area < new_area) max_area = new_area;                        \\t\\n        }              \\n    }\\n \\n    //  finding area for the rest of the bars still in stack    \\n    while (st.empty() == false)\\n    {\\n        ts = st.top();\\n        st.pop();\\n        new_area = heights[ts] * (st.empty() ? i : i - st.top() - 1);\\n \\n        if (max_area < new_area) max_area = new_area;\\n    } \\n    return max_area;        \\n    }\\n\\n\\n```\n```\\n\\nint largestRectangleArea(int* heights, int heightsSize) {\\n    \\n    int st[heightsSize+1], top=0;     //  stack for keeping track of bars position, top indicates the \\n                                    //  index of current top element in the stack             \\n    int ts;                         //  To store top of stack\\n    int max_area = 0;               //  initial maximum area         \\n    int new_area;                   //  getting area with top bar\\n \\n    \\n    int i = 0;\\n    \\n\\twhile (i < heightsSize)       //  working with all bars\\n    {        \\n        if ((top == 0) || heights[st[top-1]] <= heights[i])  //  if the current bar\\'s height is bigger or equal than the top of stack\\n            { st[top]=i++; top++;} \\n \\n        else    //  if the current bar\\'s height is less than the top of stack\\n        {\\n            ts = st[--top];             \\n             \\n            if(top>0) new_area = heights[ts] * (i - st[top-1] - 1);   //  finding the new area\\n            else new_area = heights[ts] * i;\\n            \\n \\n            // update max area, if needed\\n            if (max_area < new_area) max_area = new_area;               \\n        }      \\n        \\n    }\\n \\n    //  finding area for the rest of the bars still in stack\\n    \\n    while (top>0)\\n    {\\n        ts = st[--top];\\n        \\n        if(top>0) new_area = heights[ts] * (i - st[top-1] - 1);   //  finding the new area\\n            else new_area = heights[ts] * i;\\n \\n        if (max_area < new_area) max_area = new_area;\\n    }\\n \\n    return max_area;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28935,
                "title": "c-clean-code",
                "content": "Term\\n\\n    Extensible - bucket with a height start from here or earlier, and could still be extended further in the row.\\n\\nIdea\\n\\n*  Keep an ever increasing stack of all the bucket that is not terminated currently.\\n* Whenever meet a shorter bucket, pop all the *hopeless* bucket on the stack that is taller, which will be terminated by this decreasing bucket.\\n* The end (to) bucket is i(current), and the start bucket is the stack.top() + 1. (Not necessarily the popped bucket, because it kicked those hopeless bucket that were taller than it, until the first shorter bucket on the stack. That's why we keep an ever increasing stack).\\n* All bucket will be push to stack when every shorter bucket on stack is kicked out. And they will be kept on the stack for as long as there is no shorter bucket to break their extensibility.\\n\\n```\\n    /**\\n     *                       _\\n     *                   _  | |\\n     *               _  |_|_|_|\\n     *           _  |_|_|___|_|\\n     *       _  |_|_|___|___|_|\\n     *      |_|_|___|___|___|_|\\n     *      |___|___|___|___|_|_\\n     * i: -1 0 1 2 3 4 5 6 7 8 9 \\n     * \\n     * h:    2 1 3 2 4 3 5 4 6(0)\\n     * \\n     * s:    0 1 1 1 1 1 1 1 1 (stack actually save index, but to make it clear, here we shows the actual height on that index)\\n     *           3 2 2 2 2 2 2\\n     *               4 3 3 3 3\\n     *                   5 4 4\\n     *                       6\\n     */\\n```\\n```\\nclass Solution {\\npublic:     \\n    int largestRectangleArea(vector<int>& h) {\\n        stack<int> s;       // stack of every increasing buckets\\n        h.push_back(0);     // the ultimate terminator\\n\\n        int maxrect = 0;\\n        for (int i = 0; i < h.size(); i++) {\\n            while (!s.empty() && h[s.top()] > h[i]) {\\n                int height = h[s.top()];\\n                s.pop();\\n                int left = !s.empty() ? s.top() + 1 : 0;    // left is 0 or s.top()+1, not popped bucket, could be tallers not in stack\\n                maxrect = max(maxrect, height * (i - left));\\n            }\\n            s.push(i);  // eventually push i, after all hopeless buckets taller than h[i] kicked out;\\n        }\\n        return maxrect;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    /**\\n     *                       _\\n     *                   _  | |\\n     *               _  |_|_|_|\\n     *           _  |_|_|___|_|\\n     *       _  |_|_|___|___|_|\\n     *      |_|_|___|___|___|_|\\n     *      |___|___|___|___|_|_\\n     * i: -1 0 1 2 3 4 5 6 7 8 9 \\n     * \\n     * h:    2 1 3 2 4 3 5 4 6(0)\\n     * \\n     * s:    0 1 1 1 1 1 1 1 1 (stack actually save index, but to make it clear, here we shows the actual height on that index)\\n     *           3 2 2 2 2 2 2\\n     *               4 3 3 3 3\\n     *                   5 4 4\\n     *                       6\\n     */\\n```\n```\\nclass Solution {\\npublic:     \\n    int largestRectangleArea(vector<int>& h) {\\n        stack<int> s;       // stack of every increasing buckets\\n        h.push_back(0);     // the ultimate terminator\\n\\n        int maxrect = 0;\\n        for (int i = 0; i < h.size(); i++) {\\n            while (!s.empty() && h[s.top()] > h[i]) {\\n                int height = h[s.top()];\\n                s.pop();\\n                int left = !s.empty() ? s.top() + 1 : 0;    // left is 0 or s.top()+1, not popped bucket, could be tallers not in stack\\n                maxrect = max(maxrect, height * (i - left));\\n            }\\n            s.push(i);  // eventually push i, after all hopeless buckets taller than h[i] kicked out;\\n        }\\n        return maxrect;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894236,
                "title": "easy-solution-using-stack-o-n-beats-86-c",
                "content": "\\n\\n# Code\\n```\\n#include<stack>\\n \\nclass Solution {\\npublic:\\n    //function to find the index of next smallerNumber\\n    vector<int> nextSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=n-1;i>=0;i--){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    //function to find the index of prev smallerNumber\\n    vector<int> prevSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=0;i<n;i++){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int size=heights.size(),h,l,area=0,curArea;\\n        vector<int> next=nextSmallNumberIndex(heights);\\n         vector<int> prev=prevSmallNumberIndex(heights);\\n         for(int i=0;i<size;i++){\\n            h=heights[i];\\n            //if index of next smaller number is -1 we change its value to size \\n            if(next[i]==-1)next[i]=size;\\n            l=next[i]-prev[i]-1;\\n            curArea=l*h;\\n             area=max(area,curArea);\\n\\n        }\\n        return area;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n#include<stack>\\n \\nclass Solution {\\npublic:\\n    //function to find the index of next smallerNumber\\n    vector<int> nextSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=n-1;i>=0;i--){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    //function to find the index of prev smallerNumber\\n    vector<int> prevSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=0;i<n;i++){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int size=heights.size(),h,l,area=0,curArea;\\n        vector<int> next=nextSmallNumberIndex(heights);\\n         vector<int> prev=prevSmallNumberIndex(heights);\\n         for(int i=0;i<size;i++){\\n            h=heights[i];\\n            //if index of next smaller number is -1 we change its value to size \\n            if(next[i]==-1)next[i]=size;\\n            l=next[i]-prev[i]-1;\\n            curArea=l*h;\\n             area=max(area,curArea);\\n\\n        }\\n        return area;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3887020,
                "title": "stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n          int n = heights.length;\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n        Stack<Integer> s = new Stack<>();\\n       \\n\\n        for(int i=0;i<heights.length;i++){\\n            while(!s.isEmpty() && heights[s.peek()] >= heights[i] ){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                left[i] = -1;\\n            }\\n            else{\\n                left[i] = s.peek();\\n            }\\n\\n            s.push(i);\\n        }\\n\\n        s = new Stack<>();\\n        for(int i=heights.length-1; i>=0; i--){\\n            while(!s.isEmpty() && heights[s.peek()] >= heights[i] ){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                right[i] = heights.length;\\n            }\\n            else{\\n                right[i] = s.peek();\\n            }\\n\\n            s.push(i);\\n        }\\n        int large = 0;\\n        for(int i=0; i<heights.length; i++){\\n            int height = heights[i];\\n            int width = right[i] -left[i]-1;\\n            int curr = height * width;\\n            large = Math.max(curr, large);\\n        }\\n\\n        return large;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n          int n = heights.length;\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n        Stack<Integer> s = new Stack<>();\\n       \\n\\n        for(int i=0;i<heights.length;i++){\\n            while(!s.isEmpty() && heights[s.peek()] >= heights[i] ){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                left[i] = -1;\\n            }\\n            else{\\n                left[i] = s.peek();\\n            }\\n\\n            s.push(i);\\n        }\\n\\n        s = new Stack<>();\\n        for(int i=heights.length-1; i>=0; i--){\\n            while(!s.isEmpty() && heights[s.peek()] >= heights[i] ){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                right[i] = heights.length;\\n            }\\n            else{\\n                right[i] = s.peek();\\n            }\\n\\n            s.push(i);\\n        }\\n        int large = 0;\\n        for(int i=0; i<heights.length; i++){\\n            int height = heights[i];\\n            int width = right[i] -left[i]-1;\\n            int curr = height * width;\\n            large = Math.max(curr, large);\\n        }\\n\\n        return large;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880756,
                "title": "easiest-c-solution-with-video-explanation-beats-100",
                "content": "# [Video link](https://youtu.be/lJLcqDsmYfg)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0; i--){\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr){\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElements(vector<int> arr, int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++){\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr){\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev(n);\\n        prev = prevSmallerElements(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int length = heights[i];\\n            if(next[i] == -1)\\n                next[i] = n;\\n            int breadth = next[i] - prev[i] - 1;\\n            int newArea = length * breadth;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0; i--){\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr){\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElements(vector<int> arr, int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++){\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr){\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev(n);\\n        prev = prevSmallerElements(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int length = heights[i];\\n            if(next[i] == -1)\\n                next[i] = n;\\n            int breadth = next[i] - prev[i] - 1;\\n            int newArea = length * breadth;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845893,
                "title": "best-simple-java-solution-beats-85",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n\\n        int n = heights.length;\\n\\n        ArrayDeque<Integer> st1 = new ArrayDeque<>();\\n        ArrayDeque<Integer> st2 = new ArrayDeque<>();\\n\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n\\n        //previous smaller element\\n        for(int i = 0; i < n; i++){\\n\\n            int num = heights[i];\\n\\n            while(!st1.isEmpty() && heights[st1.peek()] > num)\\n                st1.pop();\\n\\n            if(st1.isEmpty())\\n                left[i] = -1;\\n            else \\n                left[i] = st1.peek();\\n\\n            st1.push(i);            \\n\\n        }\\n\\n        //next greater element\\n        for(int i = n-1; i >= 0; i--){\\n\\n            int num = heights[i];\\n\\n            while(!st2.isEmpty() && heights[st2.peek()] >= num)\\n                st2.pop();\\n\\n            if(st2.isEmpty())\\n                right[i] = n;\\n            else \\n                right[i] = st2.peek();\\n\\n            st2.push(i);            \\n\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < n; i++){\\n\\n            int sum = (right[i] - left[i] - 1) * heights[i];\\n            max = Math.max(max, sum); \\n\\n        }\\n\\n        return max;\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n\\n        int n = heights.length;\\n\\n        ArrayDeque<Integer> st1 = new ArrayDeque<>();\\n        ArrayDeque<Integer> st2 = new ArrayDeque<>();\\n\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n\\n        //previous smaller element\\n        for(int i = 0; i < n; i++){\\n\\n            int num = heights[i];\\n\\n            while(!st1.isEmpty() && heights[st1.peek()] > num)\\n                st1.pop();\\n\\n            if(st1.isEmpty())\\n                left[i] = -1;\\n            else \\n                left[i] = st1.peek();\\n\\n            st1.push(i);            \\n\\n        }\\n\\n        //next greater element\\n        for(int i = n-1; i >= 0; i--){\\n\\n            int num = heights[i];\\n\\n            while(!st2.isEmpty() && heights[st2.peek()] >= num)\\n                st2.pop();\\n\\n            if(st2.isEmpty())\\n                right[i] = n;\\n            else \\n                right[i] = st2.peek();\\n\\n            st2.push(i);            \\n\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < n; i++){\\n\\n            int sum = (right[i] - left[i] - 1) * heights[i];\\n            max = Math.max(max, sum); \\n\\n        }\\n\\n        return max;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804971,
                "title": "crack-the-code",
                "content": "# Intuition:\\nThe idea behind this solution is to use two arrays, leftsmall and rightsmall, to store the indices of the nearest smaller bars to the left and right for each bar in the histogram. By having this information, we can calculate the width and height of a rectangle centered around each bar and find the area of the largest rectangle that can be formed within the histogram.\\n\\n# Algorithm:\\n\\nInitialize an empty stack and two arrays, leftsmall and rightsmall, to store the indices of the nearest smaller bars to the left and right for each bar, respectively.\\nTraverse the histogram from left to right:\\nFor each bar, compare its height with the height of the bar at the top of the stack.\\nWhile the stack is not empty and the height of the current bar is less than the height of the bar at the top of the stack, pop elements from the stack. For each popped element, update its rightsmall index to the current index (i.e., the index of the current bar).\\nAfter the loop, if the stack is empty, it means there is no smaller bar to the left of the current bar, so set its leftsmall index as 0. Otherwise, set it to the index of the bar at the top of the stack plus 1.\\nPush the current index into the stack.\\nClear the stack to be re-used.\\nTraverse the histogram from right to left (backwards):\\nFor each bar, compare its height with the height of the bar at the top of the stack.\\nWhile the stack is not empty and the height of the current bar is less than the height of the bar at the top of the stack, pop elements from the stack. For each popped element, update its leftsmall index to the current index (i.e., the index of the current bar).\\nAfter the loop, if the stack is empty, it means there is no smaller bar to the right of the current bar, so set its rightsmall index as n - 1 (where n is the size of the histogram). Otherwise, set it to the index of the bar at the top of the stack minus 1.\\nPush the current index into the stack.\\nNow, we have the leftsmall and rightsmall arrays, which store the indices of the nearest smaller bars to the left and right for each bar.\\nIterate through the histogram again:\\nFor each bar, calculate the width of the rectangle as (rightsmall[i] - leftsmall[i] + 1) and the height of the rectangle as heights[i].\\nCompute the area of the rectangle for each bar and keep track of the maximum area found.\\nThe maximum area will be the answer representing the largest rectangle that can be formed within the histogram.\\n # Complexity Analysis:\\n\\n# Time Complexity: \\nThe solution involves two traversals of the histogram, each taking O(n) time, where \"n\" is the size of the input array. The additional operations performed during each traversal take constant time. Therefore, the overall time complexity is O(n).\\n# Space Complexity:\\n The primary data structure used is the stack, which can store at most \"n\" elements in the worst case. Additionally, two arrays, leftsmall and rightsmall, are used, each of size \"n\". Therefore, the space complexity is O(n).# Code\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n      int n = heights.size();\\n      stack < int > st;\\n      int leftsmall[n], rightsmall[n];\\n      for (int i = 0; i < n; i++) {\\n        while (!st.empty() && heights[st.top()] >= heights[i]) {\\n          st.pop();\\n        }\\n        if (st.empty())\\n          leftsmall[i] = 0;\\n        else\\n          leftsmall[i] = st.top() + 1;\\n        st.push(i);\\n      }\\n      // clear the stack to be re-used\\n      while (!st.empty())\\n        st.pop();\\n\\n      for (int i = n - 1; i >= 0; i--) {\\n        while (!st.empty() && heights[st.top()] >= heights[i])\\n          st.pop();\\n\\n        if (st.empty())\\n          rightsmall[i] = n - 1;\\n        else\\n          rightsmall[i] = st.top() - 1;\\n\\n        st.push(i);\\n      }\\n      int maxA = 0;\\n      for (int i = 0; i < n; i++) {\\n        maxA = max(maxA, heights[i] * (rightsmall[i] - leftsmall[i] + 1));\\n      }\\n      return maxA;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n      int n = heights.size();\\n      stack < int > st;\\n      int leftsmall[n], rightsmall[n];\\n      for (int i = 0; i < n; i++) {\\n        while (!st.empty() && heights[st.top()] >= heights[i]) {\\n          st.pop();\\n        }\\n        if (st.empty())\\n          leftsmall[i] = 0;\\n        else\\n          leftsmall[i] = st.top() + 1;\\n        st.push(i);\\n      }\\n      // clear the stack to be re-used\\n      while (!st.empty())\\n        st.pop();\\n\\n      for (int i = n - 1; i >= 0; i--) {\\n        while (!st.empty() && heights[st.top()] >= heights[i])\\n          st.pop();\\n\\n        if (st.empty())\\n          rightsmall[i] = n - 1;\\n        else\\n          rightsmall[i] = st.top() - 1;\\n\\n        st.push(i);\\n      }\\n      int maxA = 0;\\n      for (int i = 0; i < n; i++) {\\n        maxA = max(maxA, heights[i] * (rightsmall[i] - leftsmall[i] + 1));\\n      }\\n      return maxA;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695392,
                "title": "easy-and-simple-java-code-with-approach-o-n",
                "content": "\\n# Approach\\n```\\nusing auxiliary arrays generated by stacks.\\n-> nsl - Next Smaller To Left side\\n-> nsr - Next Smaller To right side\\narea at every index is equal to\\n-> area = (nsr[i]-nsl[i]-1)*height[i];\\nreturn the maximum area\\n```\\n\\n\\n# Complexity\\n```\\n- Time complexity:\\n-> O(n)\\n\\n- Space complexity:\\n-> n + n\\n```\\n# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        Stack<Integer> s=new Stack<>();\\n        int nsl[]=new int[heights.length];\\n        int nsr[]=new int[heights.length];\\n        // finfing Next Smaller To Left\\n        for(int i=0;i<heights.length;i++){\\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                nsl[i]=-1;\\n            } else {\\n                nsl[i]=s.peek();\\n            }\\n            s.push(i);\\n        }\\n        s = new Stack<>(); \\n        // finding Next Smaller To Right\\n        for(int i=heights.length-1;i>=0;i--){\\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                nsr[i]=heights.length;\\n            } else {\\n                nsr[i]=s.peek();\\n            }\\n            s.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<heights.length;i++){\\n            int area=(nsr[i]-nsl[i]-1)*heights[i];\\n            ans=Math.max(ans,area);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nusing auxiliary arrays generated by stacks.\\n-> nsl - Next Smaller To Left side\\n-> nsr - Next Smaller To right side\\narea at every index is equal to\\n-> area = (nsr[i]-nsl[i]-1)*height[i];\\nreturn the maximum area\\n```\n```\\n- Time complexity:\\n-> O(n)\\n\\n- Space complexity:\\n-> n + n\\n```\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        Stack<Integer> s=new Stack<>();\\n        int nsl[]=new int[heights.length];\\n        int nsr[]=new int[heights.length];\\n        // finfing Next Smaller To Left\\n        for(int i=0;i<heights.length;i++){\\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                nsl[i]=-1;\\n            } else {\\n                nsl[i]=s.peek();\\n            }\\n            s.push(i);\\n        }\\n        s = new Stack<>(); \\n        // finding Next Smaller To Right\\n        for(int i=heights.length-1;i>=0;i--){\\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                nsr[i]=heights.length;\\n            } else {\\n                nsr[i]=s.peek();\\n            }\\n            s.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<heights.length;i++){\\n            int area=(nsr[i]-nsl[i]-1)*heights[i];\\n            ans=Math.max(ans,area);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691895,
                "title": "q84-accepted-c-used-stack-easy-methodology",
                "content": "CRUX\\n1) Calculate the width using the Nearest Smaller Left and Right\\n2) R-L-1 for the width.\\n3) Area would be the multiplication of height[i]*width[i] \\n4) Return the maximum of area.\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> ngr(n);\\n        vector<int> ngl(n);\\n        stack<pair<int,int>> s;\\n        // Next Smaller Right\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && s.top().first >= heights[i])\\n                s.pop();\\n            if(s.empty())\\n                ngr[i] = n;\\n            else\\n                ngr[i] = s.top().second;\\n            \\n            s.push({heights[i],i});\\n        }\\n        \\n        //Empty the stack\\n        while(s.size()>0)\\n            s.pop();\\n        \\n        // Next Smaller Left\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && s.top().first >= heights[i])\\n                s.pop();\\n            if(s.empty())\\n                ngl[i] = -1;\\n            else\\n                ngl[i] = s.top().second;\\n            \\n            s.push({heights[i],i});\\n        }\\n        // Calculating the Width \\n        vector<int> width(n);\\n        for(int i=0;i<n;i++)\\n            width[i] = ngr[i]-ngl[i]-1;\\n        \\n        // Finding the Maximum Area that is possible\\n        vector<int> area(n);\\n        int maxArea=0;\\n        for(int i=0;i<n;i++){\\n            area[i] = heights[i]*width[i];\\n            maxArea = max(maxArea,area[i]);\\n        }\\n        \\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> ngr(n);\\n        vector<int> ngl(n);\\n        stack<pair<int,int>> s;\\n        // Next Smaller Right\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && s.top().first >= heights[i])\\n                s.pop();\\n            if(s.empty())\\n                ngr[i] = n;\\n            else\\n                ngr[i] = s.top().second;\\n            \\n            s.push({heights[i],i});\\n        }\\n        \\n        //Empty the stack\\n        while(s.size()>0)\\n            s.pop();\\n        \\n        // Next Smaller Left\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && s.top().first >= heights[i])\\n                s.pop();\\n            if(s.empty())\\n                ngl[i] = -1;\\n            else\\n                ngl[i] = s.top().second;\\n            \\n            s.push({heights[i],i});\\n        }\\n        // Calculating the Width \\n        vector<int> width(n);\\n        for(int i=0;i<n;i++)\\n            width[i] = ngr[i]-ngl[i]-1;\\n        \\n        // Finding the Maximum Area that is possible\\n        vector<int> area(n);\\n        int maxArea=0;\\n        for(int i=0;i<n;i++){\\n            area[i] = heights[i]*width[i];\\n            maxArea = max(maxArea,area[i]);\\n        }\\n        \\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544640,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] histo) {\\n        //Approach: Using Stack\\n        Stack<Integer> stack = new Stack<>();\\n        int n = histo.length;\\n        int maxArea = 0;\\n        \\n        for (int i = 0; i <= n; i++) {\\n            while (!stack.isEmpty() && (i == n || histo[i] <= histo[stack.peek()])) {\\n                int height = histo[stack.pop()];\\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\\n                int area = height * width;\\n                maxArea = Math.max(maxArea, area);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] histo) {\\n        //Approach: Using Stack\\n        Stack<Integer> stack = new Stack<>();\\n        int n = histo.length;\\n        int maxArea = 0;\\n        \\n        for (int i = 0; i <= n; i++) {\\n            while (!stack.isEmpty() && (i == n || histo[i] <= histo[stack.peek()])) {\\n                int height = histo[stack.pop()];\\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\\n                int area = height * width;\\n                maxArea = Math.max(maxArea, area);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544276,
                "title": "superb-logic-with-stack",
                "content": "[https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/3544276/Superb-Logic-with-Stack](http://)# Monotonic Stack\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        stack=[]\\n        maxarea=0\\n        for i,v in enumerate(heights):\\n            start=i\\n            while stack and stack[-1][1]>v:\\n                index,height=stack.pop()\\n                maxarea=max(maxarea,(i-index)*height)\\n                start=index\\n            stack.append((start,v))\\n        for i,h in stack:\\n            maxarea=max(maxarea,h*(len(heights)-i))\\n        return maxarea\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        stack=[]\\n        maxarea=0\\n        for i,v in enumerate(heights):\\n            start=i\\n            while stack and stack[-1][1]>v:\\n                index,height=stack.pop()\\n                maxarea=max(maxarea,(i-index)*height)\\n                start=index\\n            stack.append((start,v))\\n        for i,h in stack:\\n            maxarea=max(maxarea,h*(len(heights)-i))\\n        return maxarea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511055,
                "title": "java-solution-for-largest-rectangle-in-histogram-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use a stack to keep track of the indices of the histogram bars in non-decreasing order of heights. By calculating the area for each bar, considering it as the shortest bar in a potential rectangle, we can find the maximum rectangle area in the histogram.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code first checks if the heights array is null or empty. If it is, the function returns 0 since there are no bars in the histogram.\\n2. It initializes a stack stack to store the indices of the bars in non-decreasing order of heights.\\n3. It initializes two variables, max and i, where max represents the maximum rectangle area encountered so far and i is used to traverse the heights array.\\n4. The code enters a while loop where i is less than the length of the heights array:\\n- If the stack is empty or the height of the current bar heights[i] is greater than or equal to the height of the bar at the top of the stack, it means the current bar extends the previous non-decreasing sequence of bars. Hence, the index i is pushed onto the stack, and i is incremented.\\n- Otherwise, if the height of the current bar is less than the height of the bar at the top of the stack, it means the previous non-decreasing sequence has ended. The code pops the top index p from the stack and calculates the area of the rectangle formed by the bar at index p as the shortest bar. The width of the rectangle is determined by the difference between the current index i and the index at the top of the stack, excluding the top index. The area is calculated as the height of the bar at index p multiplied by the width. The maximum area max is updated if necessary.\\n5. After the while loop, the code handles the remaining bars in the stack. While the stack is not empty, it pops an index p from the stack and calculates the area of the rectangle using the same logic as described in step 4. Again, the maximum area max is updated if necessary.\\n6. Finally, the code returns the maximum rectangle area max.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the heights array. This is because each bar is processed at most twice - once when it is pushed onto the stack and once when it is popped from the stack. The while loop and the subsequent loop for the remaining bars in the stack both iterate through all the elements in the heights array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the heights array. This is because the stack can potentially store all the indices of the heights array, and in the worst case, it will have the same size as the input array. Therefore, the space used by the stack is proportional to the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        if (heights== null || heights.length == 0) \\n        {\\n            return 0;\\n        }\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int max = 0;\\n        int i = 0;\\n        while (i < heights.length) \\n        {\\n            //push index to stack when the current height is larger than the previous one\\n            if (stack.isEmpty() || heights[i] >= heights[stack.peek()]) \\n            {\\n                stack.push(i);\\n                i++;\\n            }\\n            else \\n            {\\n                //calculate max value when the current height is less than the previous one\\n                int p = stack.pop();\\n                int h = heights[p];\\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\\n                max = Math.max(h * w, max);\\n            }\\n        }\\n        while (!stack.isEmpty()) \\n        {\\n            int p = stack.pop();\\n            int h = heights[p];\\n            int w = stack.isEmpty() ? i : i - stack.peek() - 1;\\n            max = Math.max(h * w, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        if (heights== null || heights.length == 0) \\n        {\\n            return 0;\\n        }\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int max = 0;\\n        int i = 0;\\n        while (i < heights.length) \\n        {\\n            //push index to stack when the current height is larger than the previous one\\n            if (stack.isEmpty() || heights[i] >= heights[stack.peek()]) \\n            {\\n                stack.push(i);\\n                i++;\\n            }\\n            else \\n            {\\n                //calculate max value when the current height is less than the previous one\\n                int p = stack.pop();\\n                int h = heights[p];\\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\\n                max = Math.max(h * w, max);\\n            }\\n        }\\n        while (!stack.isEmpty()) \\n        {\\n            int p = stack.pop();\\n            int h = heights[p];\\n            int w = stack.isEmpty() ? i : i - stack.peek() - 1;\\n            max = Math.max(h * w, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411404,
                "title": "easy-soltution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        stack<int> s;\\n        long long  ans=0;\\n        for(int i=0;i<=n;i++){\\n            while(!s.empty() && (i==n || heights[s.top()]>=heights[i])){\\n                long long h=heights[s.top()];\\n                s.pop(); \\n                int w;\\n                if(s.empty()) w=i;\\n                else{\\n                    w=i-s.top()-1;\\n                }\\n                ans=max(ans,w*h);\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        stack<int> s;\\n        long long  ans=0;\\n        for(int i=0;i<=n;i++){\\n            while(!s.empty() && (i==n || heights[s.top()]>=heights[i])){\\n                long long h=heights[s.top()];\\n                s.pop(); \\n                int w;\\n                if(s.empty()) w=i;\\n                else{\\n                    w=i-s.top()-1;\\n                }\\n                ans=max(ans,w*h);\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335527,
                "title": "easy-c-solution-using-two-vector-nsl-nsr-and-two-stacks",
                "content": "# Intuition\\nWe can find for every index which smaller element is in its left and its right. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing two stacks \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        stack<int>st;\\n        vector<int>nsl, nsr;\\n\\n        for(int i=0;i<n;i++){\\n            if(st.size()==0)nsl.emplace_back(-1);\\n            else if(!st.empty() and heights[st.top()]<heights[i])\\n                nsl.emplace_back(st.top());\\n            else if(!st.empty() and heights[st.top()]>=heights[i]){\\n                while(!st.empty() and heights[st.top()]>=heights[i])st.pop();\\n                if(st.size()==0)nsl.emplace_back(-1);\\n                else nsl.emplace_back(st.top());\\n            }\\n\\n            st.push(i);\\n        } \\n        stack<int>st1;\\n        for(int i=n-1;i>=0;i--){\\n            if(st1.size()==0)nsr.emplace_back(n);\\n            else if(!st1.empty() and heights[st1.top()]<heights[i]){\\n                cout<<\"height \"<<heights[i]<<\" \";\\n                cout<<st.top()<<\" \";\\n                nsr.emplace_back(st1.top());\\n                }\\n            else if(!st1.empty() and heights[st1.top()]>=heights[i]){\\n                while(!st1.empty() and heights[st1.top()]>=heights[i])st1.pop();\\n                if(st1.size()==0)nsr.emplace_back(n);\\n                else nsr.emplace_back(st1.top());\\n          \\n            }\\n            // cout<<i<<\" \";\\n            st1.push(i);\\n            // cout<<st1.top()<<\" \";\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n\\n        long long ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     cout<<nsl[i]<<\" \";\\n        // }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            cout<<nsr[i]<<\" \";\\n        }\\n        for(int i=0;i<n;i++){\\n            int area=(nsr[i]-nsl[i]-1)*heights[i];\\n            if(ans<area)ans=area;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        stack<int>st;\\n        vector<int>nsl, nsr;\\n\\n        for(int i=0;i<n;i++){\\n            if(st.size()==0)nsl.emplace_back(-1);\\n            else if(!st.empty() and heights[st.top()]<heights[i])\\n                nsl.emplace_back(st.top());\\n            else if(!st.empty() and heights[st.top()]>=heights[i]){\\n                while(!st.empty() and heights[st.top()]>=heights[i])st.pop();\\n                if(st.size()==0)nsl.emplace_back(-1);\\n                else nsl.emplace_back(st.top());\\n            }\\n\\n            st.push(i);\\n        } \\n        stack<int>st1;\\n        for(int i=n-1;i>=0;i--){\\n            if(st1.size()==0)nsr.emplace_back(n);\\n            else if(!st1.empty() and heights[st1.top()]<heights[i]){\\n                cout<<\"height \"<<heights[i]<<\" \";\\n                cout<<st.top()<<\" \";\\n                nsr.emplace_back(st1.top());\\n                }\\n            else if(!st1.empty() and heights[st1.top()]>=heights[i]){\\n                while(!st1.empty() and heights[st1.top()]>=heights[i])st1.pop();\\n                if(st1.size()==0)nsr.emplace_back(n);\\n                else nsr.emplace_back(st1.top());\\n          \\n            }\\n            // cout<<i<<\" \";\\n            st1.push(i);\\n            // cout<<st1.top()<<\" \";\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n\\n        long long ans=0;\\n        // for(int i=0;i<n;i++){\\n        //     cout<<nsl[i]<<\" \";\\n        // }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            cout<<nsr[i]<<\" \";\\n        }\\n        for(int i=0;i<n;i++){\\n            int area=(nsr[i]-nsl[i]-1)*heights[i];\\n            if(ans<area)ans=area;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3221613,
                "title": "easy-solution-java-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        int smallleft[] = new int[n];\\n        int smallright[] = new int[n];\\n        Stack<Integer> s = new Stack<>();\\n       \\n\\n        for(int i=0;i<heights.length;i++){\\n            while(!s.isEmpty() && heights[s.peek()] >= heights[i] ){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                smallleft[i] = -1;\\n            }\\n            else{\\n                smallleft[i] = s.peek();\\n            }\\n\\n            s.push(i);\\n        }\\n\\n        s = new Stack<>();\\n        for(int i=heights.length-1; i>=0; i--){\\n            while(!s.isEmpty() && heights[s.peek()] >= heights[i] ){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                smallright[i] = heights.length;\\n            }\\n            else{\\n                smallright[i] = s.peek();\\n            }\\n\\n            s.push(i);\\n        }\\n        int largeRectangle = 0;\\n        for(int i=0; i<heights.length; i++){\\n            int height = heights[i];\\n            int width = smallright[i] -smallleft[i]-1;\\n            int currRectangle = height * width;\\n            largeRectangle = Math.max(currRectangle, largeRectangle);\\n        }\\n\\n        return largeRectangle;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        int smallleft[] = new int[n];\\n        int smallright[] = new int[n];\\n        Stack<Integer> s = new Stack<>();\\n       \\n\\n        for(int i=0;i<heights.length;i++){\\n            while(!s.isEmpty() && heights[s.peek()] >= heights[i] ){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                smallleft[i] = -1;\\n            }\\n            else{\\n                smallleft[i] = s.peek();\\n            }\\n\\n            s.push(i);\\n        }\\n\\n        s = new Stack<>();\\n        for(int i=heights.length-1; i>=0; i--){\\n            while(!s.isEmpty() && heights[s.peek()] >= heights[i] ){\\n                s.pop();\\n            }\\n            if(s.isEmpty()){\\n                smallright[i] = heights.length;\\n            }\\n            else{\\n                smallright[i] = s.peek();\\n            }\\n\\n            s.push(i);\\n        }\\n        int largeRectangle = 0;\\n        for(int i=0; i<heights.length; i++){\\n            int height = heights[i];\\n            int width = smallright[i] -smallleft[i]-1;\\n            int currRectangle = height * width;\\n            largeRectangle = Math.max(currRectangle, largeRectangle);\\n        }\\n\\n        return largeRectangle;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185230,
                "title": "largest-rectangle-in-histogram-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe above solution uses the monotonic stack algorithm to calculate the largest rectangle in histogram. The idea is to maintain a stack of indices, where the heights of the elements in the stack are in increasing order.\\n\\n- For each element in the input array heights, we pop all the elements in the stack that are greater than or equal to the current element. This way, the top element of the stack will be the first element on its left that is less than it. We store the index of this element in the left array.\\n- We repeat the above step but in reverse, starting from the end of the input array heights, to calculate the index of the first element on the right that is less than the current element.\\n- For each element in the input array heights, the width of the rectangle it can form is given by right[i] - left[i] - 1. The height of the rectangle is given by the value of the element itself. The area of the rectangle is then given by heights[i] * (right[i] - left[i] - 1). We keep track of the maximum area seen so far.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n87.99%\\n\\n# Code\\n```\\nclass Solution:\\n  def largestRectangleArea(self, heights: List[int]) -> int:\\n    n = len(heights)\\n    left, right = [0] * n, [0] * n\\n    stack = []\\n    for i in range(n):\\n        while stack and heights[stack[-1]] >= heights[i]:\\n            stack.pop()\\n        left[i] = stack[-1] if stack else -1\\n        stack.append(i)\\n    stack = []\\n    for i in range(n-1, -1, -1):\\n        while stack and heights[stack[-1]] >= heights[i]:\\n            stack.pop()\\n        right[i] = stack[-1] if stack else n\\n        stack.append(i)\\n    max_area = 0\\n    for i in range(n):\\n        max_area = max(max_area, heights[i] * (right[i] - left[i] - 1))\\n    return max_area\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def largestRectangleArea(self, heights: List[int]) -> int:\\n    n = len(heights)\\n    left, right = [0] * n, [0] * n\\n    stack = []\\n    for i in range(n):\\n        while stack and heights[stack[-1]] >= heights[i]:\\n            stack.pop()\\n        left[i] = stack[-1] if stack else -1\\n        stack.append(i)\\n    stack = []\\n    for i in range(n-1, -1, -1):\\n        while stack and heights[stack[-1]] >= heights[i]:\\n            stack.pop()\\n        right[i] = stack[-1] if stack else n\\n        stack.append(i)\\n    max_area = 0\\n    for i in range(n):\\n        max_area = max(max_area, heights[i] * (right[i] - left[i] - 1))\\n    return max_area\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101096,
                "title": "easy-solution-using-stack-in-c-for-beginners",
                "content": "# Intuition\\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\\n**Understanding Problem :**\\nAn Array of heights will be given to you let us Consider an example :\\nheights[] = {2,1,5,6,5,2}\\nlet us visualize the heights with the help of histogram\\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \\nWe would try finding the maximum area corresponding to each height in histogram : \\n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\\nArea = height * width\\nhere you will be given height for each bar but you need to figure the width.\\n\\nHint : Find the maximum index till which you can cover this height on left and right.\\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\\nTo help you visualize better ......\\n**Story Time !!**\\nBut read it while keeping the above image in mind. \\nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \\nLet us check corresponding to each height how far you can travel....\\n\\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\\n\\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \\nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\\nArea = height * width \\nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\\n\\n*If you understood then congrats but don\\'t skip the rest and if you can\\'t, Don\\'t Worry concept will be clear just don\\'t give up and continue reading and try to visualize*\\n\\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\\n\\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \\nLeft Side : Since there is a building of 2 floors and you can easily travel to the 1st floor of this building hence we extend area on left side.\\nRight Side : Since next all buildings are larger than our present building and you can travel to 1st floor of each of these using the previous building hence we extend area till the end.\\nArea = height * width \\nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\\n\\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\\n\\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \\nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\\nArea = height * width \\nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\\n\\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\\n\\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \\nLeft Side : Since there is a building of 5 floors and you cannot travel to the 6th floor of this building hence we cannot extend area on left side.\\nRight Side : Since there is a building of 5 floors and you cannot travel to the 6th floor of this building hence we cannot extend area on right side as well.\\nArea = height * width \\nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\\nmaxArea reamins unchanged.\\n\\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\\n\\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \\nLeft Side : Since previous 2 buildings are larger or equal to our present building and you can travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stop before building having 1 floor.\\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\\nArea = height * width \\nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\\nmaxArea remains unchanged.\\n\\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\\n\\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \\nLeft Side : Since previous 3 buildings are larger or equal to our present building and you can travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stop before building of 1 floor.\\nRight Side : Since there is no building on right side hence we can\\'t extend area to the right.\\nArea = height * width \\nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\\nmaxArea remains unchanged.\\n\\nWe return the maximum computed Area as our result.\\n\\n# Approach\\n**Framing our Visualization**\\n\\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can\\'t travel to next Building)\\n\\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we can cover distance on both sides.\\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\\nif next smaller element does not exists than we use *n* as the next value\\n\\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \\n**Before :**  *Width = ( Ending point - starting point + 1 )*\\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\\nWe used 2 function with return type array(vector in c++) to find out nextSmallerElement and prevSmallerElement\\n\\nAlgorithm is as Follows :\\n\\nn = heights.size();\\nnextSmaller[] = nextSmallerElement(heights,n);\\nprevSmaller[] = prevSmallerElement(heights,n);\\nmaxArea = 0;\\nfor(i = 0 to n-1)\\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\\n>maxArea = max(area,maxArea)\\n\\nreturn maxArea \\n\\nAfter Soving this problem you can try another problem \\n\\n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\\n\\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\\n\\nThese question have a lot of similarity as well as dissimilarity\\n\\n*Every problem is easy once you understand it : )*\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\\n        stack<int> s;\\n        vector<int> prevSmaller(n);\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\\n            prevSmaller[i] = s.empty() ? -1 : s.top();\\n            s.push(i);\\n        }\\n        return prevSmaller;\\n    }\\n\\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\\n        stack<int> s;\\n        vector<int> nextSmaller(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\\n            nextSmaller[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        return nextSmaller;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \\n        int maxArea = 0;\\n        for(int i=0;i<n;i++){\\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\\n            maxArea = max(area,maxArea);\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\\n        stack<int> s;\\n        vector<int> prevSmaller(n);\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\\n            prevSmaller[i] = s.empty() ? -1 : s.top();\\n            s.push(i);\\n        }\\n        return prevSmaller;\\n    }\\n\\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\\n        stack<int> s;\\n        vector<int> nextSmaller(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\\n            nextSmaller[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        return nextSmaller;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \\n        int maxArea = 0;\\n        for(int i=0;i<n;i++){\\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\\n            maxArea = max(area,maxArea);\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083752,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Solve this Problem like any other stack problem of nearest minimum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the nearest minimum elements for the left side of the given array.\\n2. Find the nearest minimum elements for the right side of the given array. \\n3. Find the area of all the elements.\\n4. For Area you have to find length and breadth is given. So for length just Step 1 stack subtract Step 2 Stack, you will get the length.\\n5. Then just take the maximum one out and return. \\n\\n# Complexity\\n- Time complexity: N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} heights\\n * @return {number}\\n */\\nvar largestRectangleArea = function(heights) {\\n    let leftStack = [];\\n    let stack = [];\\n    \\n//Left side nearest minimum element\\n    for(let i = 0;i < heights.length;i++){\\n        while(stack.length !== 0 && heights[stack[stack.length - 1]] >= heights[i]){\\n            stack.pop();\\n        }\\n\\n        if(stack.length === 0){\\n            leftStack.push(-1);\\n        }\\n        else {\\n            leftStack.push(stack[stack.length - 1]);\\n        }\\n        stack.push(i);\\n    }\\n\\n//Right side nearest minimum element \\n    stack = [];\\n    let rightStack = [];\\n\\n    for(let i = heights.length - 1;i >= 0; i--){\\n        while(stack.length !== 0 && heights[stack[stack.length - 1]] >= heights[i]){\\n            stack.pop();\\n        }\\n\\n        if(stack.length === 0){\\n            rightStack.push(heights.length);\\n        }\\n        else {\\n            rightStack.push(stack[stack.length - 1]);\\n        }\\n        stack.push(i);\\n    }\\n    \\n    //Calculating maximum  Area \\n    let max = -Infinity;\\n    let area;\\n    //Area = right - left - 1 (length) * heights[i](breadth)\\n\\n    for(let i = 0;i < heights.length; i++){\\n        area = (rightStack[heights.length - i - 1] - leftStack[i] - 1)  * heights[i];\\n        max = Math.max(area,max);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * @param {number[]} heights\\n * @return {number}\\n */\\nvar largestRectangleArea = function(heights) {\\n    let leftStack = [];\\n    let stack = [];\\n    \\n//Left side nearest minimum element\\n    for(let i = 0;i < heights.length;i++){\\n        while(stack.length !== 0 && heights[stack[stack.length - 1]] >= heights[i]){\\n            stack.pop();\\n        }\\n\\n        if(stack.length === 0){\\n            leftStack.push(-1);\\n        }\\n        else {\\n            leftStack.push(stack[stack.length - 1]);\\n        }\\n        stack.push(i);\\n    }\\n\\n//Right side nearest minimum element \\n    stack = [];\\n    let rightStack = [];\\n\\n    for(let i = heights.length - 1;i >= 0; i--){\\n        while(stack.length !== 0 && heights[stack[stack.length - 1]] >= heights[i]){\\n            stack.pop();\\n        }\\n\\n        if(stack.length === 0){\\n            rightStack.push(heights.length);\\n        }\\n        else {\\n            rightStack.push(stack[stack.length - 1]);\\n        }\\n        stack.push(i);\\n    }\\n    \\n    //Calculating maximum  Area \\n    let max = -Infinity;\\n    let area;\\n    //Area = right - left - 1 (length) * heights[i](breadth)\\n\\n    for(let i = 0;i < heights.length; i++){\\n        area = (rightStack[heights.length - i - 1] - leftStack[i] - 1)  * heights[i];\\n        max = Math.max(area,max);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2953617,
                "title": "cpp-code-using-stack-next-smaller-element-previous-smaller-element-most-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwhat the question asks from us to find the area of maximum rectangle formed by the histograms\\n\\nhow can we find the maximum area by either finding maximum length or maximum breadth..\\n\\narea=length *breath;\\n---\\n\\nhere, length of histogram are constant only we can find the maximum breadth for a constant length \\nso finding the maximum area we find the maximum area optained from all the lengths with the maximum breadth we found ...\\n\\n**how to find the maximum breath** \\n \\nbreadh =n-p-1;\\nhere n= is the next minimum element from the current element\\n     p=is the previous minimum element from the current element\\n\\nThe million dolloar question arises how to find the next minimum element \\nwe find this using stack traversing from the back of the array and pops the minimum element if top elemnt is >curr and pushes back if false (see below code )..\\n\\nsimilarly while traversing from the front side we find the previous minimum element .\\n\\n\\n\\n\\n# Approach 1\\nusing stack by finding minimum next and previos value of each element and and finding the maximum in O(n) time comlexity \\n\\nthere are many other approches also llike left and right array but this is the most optimised one. \\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n#include <stack>\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr,int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmallerElement(vector<int> arr,int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        vector<int> next(n);\\n\\n        next=nextSmallerElement(heights,n);\\n        vector<int> prev(n);\\n        prev=prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b=next[i]-prev[i]-1;\\n            int Narea=l*b;\\n            area=max(area,Narea);\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n#include <stack>\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr,int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmallerElement(vector<int> arr,int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        vector<int> next(n);\\n\\n        next=nextSmallerElement(heights,n);\\n        vector<int> prev(n);\\n        prev=prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b=next[i]-prev[i]-1;\\n            int Narea=l*b;\\n            area=max(area,Narea);\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2946204,
                "title": "java-o-n-stack",
                "content": "\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int maxArea=0;\\n        int n= heights.length;\\n        Stack<Integer> stack=new Stack<>();\\n        for (int i = 0; i <=n ; i++) {\\n            while ((!stack.isEmpty()) &&(i==n || heights[stack.peek()]>=heights[i])){\\n                int height=heights[stack.peek()];\\n                stack.pop();\\n                int width;\\n                if (stack.isEmpty()){\\n                    width=i;\\n                }else {\\n                    width=i-stack.peek()-1;\\n                }\\n                maxArea=Math.max(maxArea,width*height);\\n            }\\n            stack.push(i);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int maxArea=0;\\n        int n= heights.length;\\n        Stack<Integer> stack=new Stack<>();\\n        for (int i = 0; i <=n ; i++) {\\n            while ((!stack.isEmpty()) &&(i==n || heights[stack.peek()]>=heights[i])){\\n                int height=heights[stack.peek()];\\n                stack.pop();\\n                int width;\\n                if (stack.isEmpty()){\\n                    width=i;\\n                }else {\\n                    width=i-stack.peek()-1;\\n                }\\n                maxArea=Math.max(maxArea,width*height);\\n            }\\n            stack.push(i);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917102,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        int n=heights.size();\\n        vector<int> left(n);\\n        vector<int> ryt(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                            st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else\\n                left[i]=st.top()+1;\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                ryt[i]=n-1;\\n            else\\n                ryt[i]=st.top()-1;\\n            st.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int area=heights[i]*(ryt[i]-left[i]+1);\\n            ans=max(ans, area);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        int n=heights.size();\\n        vector<int> left(n);\\n        vector<int> ryt(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                            st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else\\n                left[i]=st.top()+1;\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                ryt[i]=n-1;\\n            else\\n                ryt[i]=st.top()-1;\\n            st.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int area=heights[i]*(ryt[i]-left[i]+1);\\n            ans=max(ans, area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709475,
                "title": "easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n = h.size();\\n        int leftsmall[n],rightsmall[n];\\n        stack<int> st;\\n        // computing left small array\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() && h[st.top()] >= h[i]){\\n                st.pop();\\n            }\\n            if(st.empty()) leftsmall[i] = 0;\\n            else leftsmall[i] = st.top() + 1;\\n            \\n            st.push(i);\\n        }\\n        // clear the stack\\n        while(!st.empty()) st.pop();\\n        // computing right small array\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() && h[st.top()] >= h[i]){\\n                st.pop();\\n            }\\n            if(st.empty()) rightsmall[i] = n-1;\\n            else rightsmall[i] = st.top() - 1;\\n            \\n            st.push(i);\\n        }\\n        // computing final ans\\n        int maxi = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int temp = (rightsmall[i] - leftsmall[i] + 1) * h[i];\\n            maxi = max(maxi,temp);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n = h.size();\\n        int leftsmall[n],rightsmall[n];\\n        stack<int> st;\\n        // computing left small array\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() && h[st.top()] >= h[i]){\\n                st.pop();\\n            }\\n            if(st.empty()) leftsmall[i] = 0;\\n            else leftsmall[i] = st.top() + 1;\\n            \\n            st.push(i);\\n        }\\n        // clear the stack\\n        while(!st.empty()) st.pop();\\n        // computing right small array\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() && h[st.top()] >= h[i]){\\n                st.pop();\\n            }\\n            if(st.empty()) rightsmall[i] = n-1;\\n            else rightsmall[i] = st.top() - 1;\\n            \\n            st.push(i);\\n        }\\n        // computing final ans\\n        int maxi = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int temp = (rightsmall[i] - leftsmall[i] + 1) * h[i];\\n            maxi = max(maxi,temp);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558295,
                "title": "javascript-solution-explained-o-n",
                "content": "This code taken from [@anton4](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28902/5ms-O(n)-Java-solution-explained-(beats-96)), I just modified this code for JS and added comments for better understanding.\\n I didnt find better explanation than this and code is easy to understand comapre to other submitted JS code\\n```\\nlet largestRectangleArea = function(heights) {\\n\\t\\n\\tlet lessFromLeft = [];\\n\\tlet lessFromRight = [];\\n\\n\\t// Initializing last element equal to length, cause that\\'s last element and so no smaller element to the right side;\\n\\tlessFromRight[heights.length - 1] = heights.length;\\n\\n\\t// Same like above, no smaller element to the left side for first element so we initializing it with -1;\\n\\tlessFromLeft[0] = -1;\\n\\n\\t// starting loop from 1 cause we already have ans for first element (means: 0 index);\\n\\tfor(let i = 1; i < heights.length; i++) {\\n\\t\\t// for comparing with prev element\\n\\t\\tlet p = i - 1;\\n\\n\\t\\t// if this condition true\\n\\t\\twhile((p >= 0) && heights[p] >= heights[i]) {\\n\\t\\t\\t// 1: It will look into <lessFromLeft Array> whats value for p.\\n\\t\\t\\tp = lessFromLeft[p]\\n\\t\\t\\t// 2: E.X - for first iteration p is 0, and its value inside <lessFromLeft> is -1, So now p will be -1.\\n\\t\\t\\t// 3: Now after setting the p value, loop will start again with new value which is -1\\n\\t\\t\\t// 4: And now above while condition is false cause p is less than 0;\\n\\t\\t}\\n\\t\\t// value for lessFromLeft[1] will be -1, cause there is no smaller value to left than this;\\n\\t\\tlessFromLeft[i] = p;\\n\\t}\\n\\t// Same logic like above, here we are looping from end;\\n\\tfor(let i = heights.length - 2; i >= 0 ; i--) {\\n\\t\\t// for comparing with next element\\n\\t\\tlet p = i + 1;\\n\\t\\twhile(p < heights.length && heights[p] >= heights[i]) {\\n\\t\\t\\tp = lessFromRight[p];\\n\\t\\t}\\n\\t\\tlessFromRight[i] = p;\\n\\t}\\n\\n\\t  let max = 0;\\n\\t\\t// Main Function for to check largestRectangleArea\\n\\t    for(let i = 0; i < heights.length; i++) {\\n\\t        let curr = heights[i] * (lessFromRight[i] - lessFromLeft[i] - 1);\\n\\t        max = Math.max(max, curr);\\n    }\\n\\t\\n    return max;\\n}\\nlargestRectangleArea([2,1,5,6,2,3]);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet largestRectangleArea = function(heights) {\\n\\t\\n\\tlet lessFromLeft = [];\\n\\tlet lessFromRight = [];\\n\\n\\t// Initializing last element equal to length, cause that\\'s last element and so no smaller element to the right side;\\n\\tlessFromRight[heights.length - 1] = heights.length;\\n\\n\\t// Same like above, no smaller element to the left side for first element so we initializing it with -1;\\n\\tlessFromLeft[0] = -1;\\n\\n\\t// starting loop from 1 cause we already have ans for first element (means: 0 index);\\n\\tfor(let i = 1; i < heights.length; i++) {\\n\\t\\t// for comparing with prev element\\n\\t\\tlet p = i - 1;\\n\\n\\t\\t// if this condition true\\n\\t\\twhile((p >= 0) && heights[p] >= heights[i]) {\\n\\t\\t\\t// 1: It will look into <lessFromLeft Array> whats value for p.\\n\\t\\t\\tp = lessFromLeft[p]\\n\\t\\t\\t// 2: E.X - for first iteration p is 0, and its value inside <lessFromLeft> is -1, So now p will be -1.\\n\\t\\t\\t// 3: Now after setting the p value, loop will start again with new value which is -1\\n\\t\\t\\t// 4: And now above while condition is false cause p is less than 0;\\n\\t\\t}\\n\\t\\t// value for lessFromLeft[1] will be -1, cause there is no smaller value to left than this;\\n\\t\\tlessFromLeft[i] = p;\\n\\t}\\n\\t// Same logic like above, here we are looping from end;\\n\\tfor(let i = heights.length - 2; i >= 0 ; i--) {\\n\\t\\t// for comparing with next element\\n\\t\\tlet p = i + 1;\\n\\t\\twhile(p < heights.length && heights[p] >= heights[i]) {\\n\\t\\t\\tp = lessFromRight[p];\\n\\t\\t}\\n\\t\\tlessFromRight[i] = p;\\n\\t}\\n\\n\\t  let max = 0;\\n\\t\\t// Main Function for to check largestRectangleArea\\n\\t    for(let i = 0; i < heights.length; i++) {\\n\\t        let curr = heights[i] * (lessFromRight[i] - lessFromLeft[i] - 1);\\n\\t        max = Math.max(max, curr);\\n    }\\n\\t\\n    return max;\\n}\\nlargestRectangleArea([2,1,5,6,2,3]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186705,
                "title": "easy-c-single-traversal",
                "content": "Single traversal solution\\nO(N) time complexity\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        \\n        int n=heights.size(),ans=0;\\n        for(int i=0;i<=n;i++){\\n            \\n            int h=(i==n)? 0 :heights[i];\\n            while(!st.empty() && heights[st.top()]>=h){\\n                int index=st.top();\\n                st.pop();\\n                int area=st.empty() ? i*heights[index]:(i-1-st.top())*heights[index];\\n                ans=max(area,ans);\\n                \\n            }\\n            st.push(i);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease ***upvote*** the solution if you like it",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        \\n        int n=heights.size(),ans=0;\\n        for(int i=0;i<=n;i++){\\n            \\n            int h=(i==n)? 0 :heights[i];\\n            while(!st.empty() && heights[st.top()]>=h){\\n                int index=st.top();\\n                st.pop();\\n                int area=st.empty() ? i*heights[index]:(i-1-st.top())*heights[index];\\n                ans=max(area,ans);\\n                \\n            }\\n            st.push(i);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161995,
                "title": "c-100-simple-solution-stack-t-o-n-s-o-n",
                "content": "```\\n    int largestRectangleArea(vector<int>& v) {\\n        \\n        \\n        int ans=0;\\n        \\n        stack<int> s;\\n        int i=0;\\n        while(i<=v.size())\\n        {\\n            while(!s.empty()&&(i==v.size()||v[s.top()]>v[i]))\\n            {\\n                int curr=s.top();s.pop();\\n                \\n                if(s.empty()) ans=max(ans,(i)*v[curr]);                                   else ans=max(ans,(i-s.top()-1)*v[curr]);\\n\\n            }\\n            s.push(i);\\n            i++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n    int largestRectangleArea(vector<int>& v) {\\n        \\n        \\n        int ans=0;\\n        \\n        stack<int> s;\\n        int i=0;\\n        while(i<=v.size())\\n        {\\n            while(!s.empty()&&(i==v.size()||v[s.top()]>v[i]))\\n            {\\n                int curr=s.top();s.pop();\\n                \\n                if(s.empty()) ans=max(ans,(i)*v[curr]);                                   else ans=max(ans,(i-s.top()-1)*v[curr]);\\n\\n            }\\n            s.push(i);\\n            i++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1948677,
                "title": "largest-rectangle-in-histogram-find-next-minimum-element-stack-java",
                "content": "#### **Largest Rectangle in Histogram**\\n\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length, max = 0, right;\\n        int[] left = new int[n]; // stores index of next smaller element to the left\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        // Find smaller element to the left\\n        for (int i=0; i<n; i++) {\\n            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\\n                stack.pop();\\n            }\\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\\n            stack.push(i);\\n        }\\n        \\n        stack.clear();\\n        \\n        // Find smaller element to the right and compute area\\n        for (int i=n-1; i>=0; i--) {\\n            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\\n                stack.pop();\\n            }\\n            right = stack.isEmpty() ? n : stack.peek();\\n            stack.push(i);\\n            \\n            // Find max area\\n            max = Math.max(max, heights[i] * (right - left[i] - 1));\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length, max = 0, right;\\n        int[] left = new int[n]; // stores index of next smaller element to the left\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        // Find smaller element to the left\\n        for (int i=0; i<n; i++) {\\n            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\\n                stack.pop();\\n            }\\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\\n            stack.push(i);\\n        }\\n        \\n        stack.clear();\\n        \\n        // Find smaller element to the right and compute area\\n        for (int i=n-1; i>=0; i--) {\\n            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\\n                stack.pop();\\n            }\\n            right = stack.isEmpty() ? n : stack.peek();\\n            stack.push(i);\\n            \\n            // Find max area\\n            max = Math.max(max, heights[i] * (right - left[i] - 1));\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936313,
                "title": "c-solution-o-n-time-o-n-space",
                "content": "Intuition behind this algorithm is to first store the index of next smaller element from left(nesL() function do the same) and from right(nseR() function do the same).\\nNow traverse through each height of the vector and check for the index of next smaller element to the right and index of next smaller element to the left.\\nmaxArea = max(maxArea, ((nseRight[i]-1) - (nseLeft[i]+1) + 1)*heights[i])\\n\\n\\nfor example \\nwe have a vector of heights = {2, 1, 5, 6 , 2, 3};\\nso next smaller element index array from right would be {1, 6, 4, 4, 6, 6};\\nand next smaller element index array from left would be {-1, -1, 1, 2, 1, 4};\\n\\nnow loop through each height and calculate the maxarea from given formula.\\nand the answer will come out to be 10.\\n\\n```\\nvector<int> nseR(vector<int> heights){\\n        stack<int> s;\\n        int n = heights.size();\\n        vector<int> res(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()] >= heights[i]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                s.push(i);\\n                res[i] = n;\\n                continue;\\n            }\\n            res[i] = s.top();\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n    vector<int> nseL(vector<int> heights){\\n        stack<int> s;\\n        int n = heights.size();\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()] >= heights[i]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                s.push(i);\\n                res[i] = -1;\\n                continue;\\n            }\\n            res[i] = s.top();\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n    // void printArray(vector<int> heights){\\n    //     for(int i=0;i<heights.size();i++){\\n    //         cout<<heights[i]<<\" \";\\n    //     }\\n    //     cout<<endl;\\n    // }\\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        int n = heights.size();\\n        vector<int> nseLeft = nseL(heights);\\n        vector<int> nseRight = nseR(heights);\\n        \\n        int maxArea = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            maxArea = max(maxArea, ((nseRight[i]-1) - (nseLeft[i]+1) + 1)*heights[i]);\\n        }\\n        return maxArea;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nvector<int> nseR(vector<int> heights){\\n        stack<int> s;\\n        int n = heights.size();\\n        vector<int> res(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()] >= heights[i]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                s.push(i);\\n                res[i] = n;\\n                continue;\\n            }\\n            res[i] = s.top();\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n    vector<int> nseL(vector<int> heights){\\n        stack<int> s;\\n        int n = heights.size();\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()] >= heights[i]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                s.push(i);\\n                res[i] = -1;\\n                continue;\\n            }\\n            res[i] = s.top();\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n    // void printArray(vector<int> heights){\\n    //     for(int i=0;i<heights.size();i++){\\n    //         cout<<heights[i]<<\" \";\\n    //     }\\n    //     cout<<endl;\\n    // }\\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        int n = heights.size();\\n        vector<int> nseLeft = nseL(heights);\\n        vector<int> nseRight = nseR(heights);\\n        \\n        int maxArea = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            maxArea = max(maxArea, ((nseRight[i]-1) - (nseLeft[i]+1) + 1)*heights[i]);\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1815270,
                "title": "c-using-next-smaller-and-previous-smaller-arrays-o-n-time-o-n-space",
                "content": "**Upvote if you found solution helpful**\\n```C++\\nclass Solution\\n{\\npublic:\\n// next smaller array\\n    void nextSmaller(vector<int> &arr, vector<int> &next)\\n    {\\n        stack<int> st;\\n        for (int i = arr.size() - 1; i >= 0; i--)\\n        {\\n            // keep popping untill you found element smaller than current value \\n            while (!st.empty() and arr[st.top()] >= arr[i])\\n            {\\n                st.pop();\\n            }\\n            int n = st.empty() ? arr.size() - 1 : st.top() - 1;\\n            next[i] = n;\\n            st.push(i);\\n        }\\n    }\\n    // previous smaller array\\n    void prevSmaller(vector<int> &arr, vector<int> &prev)\\n    {\\n        stack<int> st;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            // keep popping untill you found element smaller than current value\\n            while (!st.empty() and arr[st.top()] >= arr[i])\\n            {\\n                st.pop();\\n            }\\n            int p = st.empty() ? 0 : st.top() + 1;\\n            prev.push_back(p);\\n            st.push(i);\\n        }\\n    }\\n    int largestRectangleArea(vector<int> &heights)\\n    {\\n        // next array\\n        vector<int> next(heights.size(), -1);\\n        // previous array\\n        vector<int> prev;\\n        prevSmaller(heights, prev);\\n        nextSmaller(heights, next);\\n        int res = 0, area;\\n        for (int i = 0; i < heights.size(); i++)\\n        {\\n            area = (next[i] - prev[i] + 1) * heights[i];\\n            res = max(res, area);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n// next smaller array\\n    void nextSmaller(vector<int> &arr, vector<int> &next)\\n    {\\n        stack<int> st;\\n        for (int i = arr.size() - 1; i >= 0; i--)\\n        {\\n            // keep popping untill you found element smaller than current value \\n            while (!st.empty() and arr[st.top()] >= arr[i])\\n            {\\n                st.pop();\\n            }\\n            int n = st.empty() ? arr.size() - 1 : st.top() - 1;\\n            next[i] = n;\\n            st.push(i);\\n        }\\n    }\\n    // previous smaller array\\n    void prevSmaller(vector<int> &arr, vector<int> &prev)\\n    {\\n        stack<int> st;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            // keep popping untill you found element smaller than current value\\n            while (!st.empty() and arr[st.top()] >= arr[i])\\n            {\\n                st.pop();\\n            }\\n            int p = st.empty() ? 0 : st.top() + 1;\\n            prev.push_back(p);\\n            st.push(i);\\n        }\\n    }\\n    int largestRectangleArea(vector<int> &heights)\\n    {\\n        // next array\\n        vector<int> next(heights.size(), -1);\\n        // previous array\\n        vector<int> prev;\\n        prevSmaller(heights, prev);\\n        nextSmaller(heights, next);\\n        int res = 0, area;\\n        for (int i = 0; i < heights.size(); i++)\\n        {\\n            area = (next[i] - prev[i] + 1) * heights[i];\\n            res = max(res, area);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759304,
                "title": "largest-rectangle-using-stack",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> &arr, int n)\\n    {\\n        // Write your code here.\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr){\\n                s.pop();\\n            }\\n\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> &arr, int n)\\n    {\\n        // Write your code here.\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr){\\n                s.pop();\\n            }\\n\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n =heights.size();\\n        \\n        //for next smaller element of all heights\\n        vector<int> next;\\n        next = nextSmallerElement(heights,n);\\n        \\n        //for prev smaller element of all heights\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights,n);\\n        \\n        int maxArea = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int l = heights[i];\\n            if(next[i] == -1){\\n                next[i] = n;\\n            }   \\n            int b = next[i] - prev[i] - 1;\\n            \\n            int area = l*b;\\n            maxArea = max(maxArea,area);\\n        }\\n        \\n        return maxArea;\\n    }\\n};\\n```\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> &arr, int n)\\n    {\\n        // Write your code here.\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr){\\n                s.pop();\\n            }\\n\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> &arr, int n)\\n    {\\n        // Write your code here.\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr){\\n                s.pop();\\n            }\\n\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n =heights.size();\\n        \\n        //for next smaller element of all heights\\n        vector<int> next;\\n        next = nextSmallerElement(heights,n);\\n        \\n        //for prev smaller element of all heights\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights,n);\\n        \\n        int maxArea = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int l = heights[i];\\n            if(next[i] == -1){\\n                next[i] = n;\\n            }   \\n            int b = next[i] - prev[i] - 1;\\n            \\n            int area = l*b;\\n            maxArea = max(maxArea,area);\\n        }\\n        \\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741986,
                "title": "max-area-histogram-c-solution-aditya-verma-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>LeftIndex(vector<int>& arr,int n)\\n      {\\n           vector<int>left;\\n           stack<pair<int,int>>s;\\n           int pseudoIndex=-1;\\n           for(int i=0;i<n;i++)\\n           {\\n               if(s.size()==0) left.push_back(pseudoIndex);\\n               else if(s.size()>0 && s.top().first<arr[i]) left.push_back(s.top().second);\\n               else if(s.size()>0 && s.top().first>=arr[i])\\n               {\\n                      while(s.size()>0 && s.top().first>=arr[i]) {s.pop();}\\n                      if(s.size()==0) left.push_back(pseudoIndex); \\n                      else left.push_back(s.top().second);\\n               }\\n               s.push({arr[i],i});\\n        } \\n           return left;\\n    }       \\n    vector<int>RightIndex(vector<int>& arr,int n)\\n    {\\n        vector<int>right;\\n        stack<pair<int,int>>s1;\\n        int pseudoIndex2=n;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.size()==0) right.push_back(pseudoIndex2);\\n            else if(s1.size()>0 && s1.top().first<arr[i]) right.push_back(s1.top().second);\\n            else if(s1.size()>0 && s1.top().first>=arr[i])\\n            {\\n                while(s1.size()>0 && s1.top().first>=arr[i]) {s1.pop();}\\n                if(s1.size()==0)right.push_back(pseudoIndex2); \\n                else right.push_back(s1.top().second);      \\n            }\\n            s1.push({arr[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n    int largestRectangleArea(vector<int>& arr) {\\n        \\n       int n = arr.size(); \\n       vector<int>left  =LeftIndex(arr,n);\\n       vector<int>right =RightIndex(arr,n);\\n       int area=0;\\n       int mx=INT_MIN;\\n       for(int i=0;i<n;i++)\\n       {\\n           int width=right[i]-left[i]-1;\\n           area=arr[i]*width;\\n           mx=max(mx,area);\\n       }\\n       return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>LeftIndex(vector<int>& arr,int n)\\n      {\\n           vector<int>left;\\n           stack<pair<int,int>>s;\\n           int pseudoIndex=-1;\\n           for(int i=0;i<n;i++)\\n           {\\n               if(s.size()==0) left.push_back(pseudoIndex);\\n               else if(s.size()>0 && s.top().first<arr[i]) left.push_back(s.top().second);\\n               else if(s.size()>0 && s.top().first>=arr[i])\\n               {\\n                      while(s.size()>0 && s.top().first>=arr[i]) {s.pop();}\\n                      if(s.size()==0) left.push_back(pseudoIndex); \\n                      else left.push_back(s.top().second);\\n               }\\n               s.push({arr[i],i});\\n        } \\n           return left;\\n    }       \\n    vector<int>RightIndex(vector<int>& arr,int n)\\n    {\\n        vector<int>right;\\n        stack<pair<int,int>>s1;\\n        int pseudoIndex2=n;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.size()==0) right.push_back(pseudoIndex2);\\n            else if(s1.size()>0 && s1.top().first<arr[i]) right.push_back(s1.top().second);\\n            else if(s1.size()>0 && s1.top().first>=arr[i])\\n            {\\n                while(s1.size()>0 && s1.top().first>=arr[i]) {s1.pop();}\\n                if(s1.size()==0)right.push_back(pseudoIndex2); \\n                else right.push_back(s1.top().second);      \\n            }\\n            s1.push({arr[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n    int largestRectangleArea(vector<int>& arr) {\\n        \\n       int n = arr.size(); \\n       vector<int>left  =LeftIndex(arr,n);\\n       vector<int>right =RightIndex(arr,n);\\n       int area=0;\\n       int mx=INT_MIN;\\n       for(int i=0;i<n;i++)\\n       {\\n           int width=right[i]-left[i]-1;\\n           area=arr[i]*width;\\n           mx=max(mx,area);\\n       }\\n       return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729230,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n       int n=h.size();\\n        int ans=0;\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        stack<int>st;\\n       for(int i=0;i<n;i++){\\n         while(!st.empty() and h[st.top()]>=h[i]){\\n             st.pop();\\n         }if(st.empty()){\\n             left[i]=0;\\n         }else{\\n             left[i]=st.top()+1;\\n         }st.push(i);\\n       }\\n\\t   while(!st.empty()){\\n           st.pop();\\n       }\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() and h[st.top()]>=h[i]){\\n                st.pop();\\n            }if(st.empty()){\\n                right[i]=n-1;\\n            }else{\\n                right[i]=st.top()-1;\\n            }st.push(i);\\n        }for(int i=0;i<n;i++){\\n            ans=max(ans,h[i]*(right[i]-left[i]+1));\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n       int n=h.size();\\n        int ans=0;\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        stack<int>st;\\n       for(int i=0;i<n;i++){\\n         while(!st.empty() and h[st.top()]>=h[i]){\\n             st.pop();\\n         }if(st.empty()){\\n             left[i]=0;\\n         }else{\\n             left[i]=st.top()+1;\\n         }st.push(i);\\n       }\\n\\t   while(!st.empty()){\\n           st.pop();\\n       }\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() and h[st.top()]>=h[i]){\\n                st.pop();\\n            }if(st.empty()){\\n                right[i]=n-1;\\n            }else{\\n                right[i]=st.top()-1;\\n            }st.push(i);\\n        }for(int i=0;i<n;i++){\\n            ans=max(ans,h[i]*(right[i]-left[i]+1));\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728716,
                "title": "golang-stack-solution-76-ms",
                "content": "[Result](https://leetcode.com/submissions/detail/630186612/)\\n*Runtime: 76 ms, faster than 100.00% of Go online submissions for Largest Rectangle in Histogram.\\nMemory Usage: 8.1 MB, less than 99.31% of Go online submissions for Largest Rectangle in Histogram.*\\n\\nIn this solution, the idea is:\\n- if the current element is larger than the previous one, then add it to the stack,\\n- if it is equal, then we do nothing,\\n- if the current element is smaller than the previous one, then we calculate the area and remove from the stack the elements that have a value greater than the current element, after that we add the current element to the stack with the minimum index that was deleted\\n\\nUsed stack structure\\n```\\ntype CustomStack struct {\\n    Index int           //current index of array heights\\n    MaxArea int         //current calculater maximum area\\n    ArrValue [] int     //array of values in stack\\n    ArrIndex [] int     //array of indexes in stack\\n}\\n```\\n\\nFor debug uncomment print-s\\nExample input `[2,1,5,6,2,3]`\\n\\n```\\nbar2 push \\n&{1 0 [2] [1]}\\n\\nbar1 pop 2 \\n&{2 2 [1] [1]}\\n\\nbar5 push \\n&{3 2 [1 5] [1 3]}\\n\\nbar6 push \\n&{4 2 [1 5 6] [1 3 4]}\\n\\nbar2 pop 6  pop 5 \\n&{5 10 [1 2] [1 3]}\\n\\nbar3 push \\n&{6 10 [1 2 3] [1 3 6]}\\n\\npop 3  pop 2  pop 1 &{7 10 [0] [1]}\\n\\n```\\n\\n\\n**Code**\\n\\n```\\nfunc largestRectangleArea(heights []int) int {\\n    myStack := &CustomStack{0, 0, make([]int, 0), make([]int, 0)} \\n    for _, barValue := range heights {\\n        // fmt.Print(\"bar\", barValue)\\n        myStack.Index++\\n        val, _ := myStack.Front()\\n        if barValue > val {\\n            //If current bar large then before, add to stack\\n            // fmt.Print(\" push \")\\n            myStack.Push(barValue, myStack.Index)\\n        }\\n        if barValue < val {\\n            //If current bar smaller then before\\n            // we remove from the stack all elements that are larger than the current bar with calculating their areas\\n            // and add the current element with the index of the minimum deleted element\\n            myStack.PopAndCalcArea(barValue)\\n        }\\n        // fmt.Println()\\n\\t\\t// fmt.Println(myStack)\\n    }\\n    \\n    //check last areas\\n    myStack.Index++\\n    myStack.PopAndCalcArea(0)\\n    \\n    // fmt.Println(myStack)\\n    return myStack.MaxArea\\n}\\ntype CustomStack struct {\\n    Index int\\n    MaxArea int\\n    ArrValue [] int\\n    ArrIndex [] int\\n}\\n\\n//Add to stack\\nfunc (this *CustomStack) Push(val int, index int) {\\n    this.ArrValue = append(this.ArrValue, val) \\n    this.ArrIndex = append(this.ArrIndex, index)\\n}\\n\\n//Delete from stack\\nfunc (this *CustomStack) Pop() {\\n    if len(this.ArrValue) > 0 {\\n        this.ArrValue = this.ArrValue[:len(this.ArrValue)-1]\\n        this.ArrIndex = this.ArrIndex[:len(this.ArrIndex)-1]    \\n    }\\n}\\n\\n//Calc area rectange from last stack element\\nfunc (this *CustomStack) CalcArea() int {\\n    if this.Size() == 0 {\\n        return 0\\n    }\\n    value, index := this.Front()\\n    return (this.Index - index) * value\\n}\\n\\nfunc (this *CustomStack) Size() int {\\n    return len(this.ArrValue)\\n}\\n\\n//Get last element\\nfunc (this *CustomStack) Front() (int, int) {\\n    if(this.Size() == 0){\\n        return 0, 0\\n    }\\n    return this.ArrValue[len(this.ArrValue) - 1], this.ArrIndex[len(this.ArrIndex) - 1]\\n}\\n\\nfunc (this *CustomStack) PopAndCalcArea(curVal int) {\\n    index := 0\\n    checkMaxBar := false\\n    for i:=len(this.ArrValue)-1; i>=0; i-- {\\n        if this.ArrValue[i] > curVal {\\n            if !checkMaxBar {\\n                //check last (max) bar size with max area\\n                checkMaxBar = true\\n                if this.MaxArea < this.ArrValue[i] {\\n                    this.MaxArea = this.ArrValue[i]\\n                }\\n            }\\n            index = this.ArrIndex[i]\\n            area := this.CalcArea()\\n            // fmt.Printf(\" pop %d \", this.ArrValue[i])\\n            this.Pop()\\n            \\n            if this.MaxArea < area {\\n                this.MaxArea = area\\n            }\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    this.Push(curVal, index)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Stack"
                ],
                "code": "```\\ntype CustomStack struct {\\n    Index int           //current index of array heights\\n    MaxArea int         //current calculater maximum area\\n    ArrValue [] int     //array of values in stack\\n    ArrIndex [] int     //array of indexes in stack\\n}\\n```\n```\\nbar2 push \\n&{1 0 [2] [1]}\\n\\nbar1 pop 2 \\n&{2 2 [1] [1]}\\n\\nbar5 push \\n&{3 2 [1 5] [1 3]}\\n\\nbar6 push \\n&{4 2 [1 5 6] [1 3 4]}\\n\\nbar2 pop 6  pop 5 \\n&{5 10 [1 2] [1 3]}\\n\\nbar3 push \\n&{6 10 [1 2 3] [1 3 6]}\\n\\npop 3  pop 2  pop 1 &{7 10 [0] [1]}\\n\\n```\n```\\nfunc largestRectangleArea(heights []int) int {\\n    myStack := &CustomStack{0, 0, make([]int, 0), make([]int, 0)} \\n    for _, barValue := range heights {\\n        // fmt.Print(\"bar\", barValue)\\n        myStack.Index++\\n        val, _ := myStack.Front()\\n        if barValue > val {\\n            //If current bar large then before, add to stack\\n            // fmt.Print(\" push \")\\n            myStack.Push(barValue, myStack.Index)\\n        }\\n        if barValue < val {\\n            //If current bar smaller then before\\n            // we remove from the stack all elements that are larger than the current bar with calculating their areas\\n            // and add the current element with the index of the minimum deleted element\\n            myStack.PopAndCalcArea(barValue)\\n        }\\n        // fmt.Println()\\n\\t\\t// fmt.Println(myStack)\\n    }\\n    \\n    //check last areas\\n    myStack.Index++\\n    myStack.PopAndCalcArea(0)\\n    \\n    // fmt.Println(myStack)\\n    return myStack.MaxArea\\n}\\ntype CustomStack struct {\\n    Index int\\n    MaxArea int\\n    ArrValue [] int\\n    ArrIndex [] int\\n}\\n\\n//Add to stack\\nfunc (this *CustomStack) Push(val int, index int) {\\n    this.ArrValue = append(this.ArrValue, val) \\n    this.ArrIndex = append(this.ArrIndex, index)\\n}\\n\\n//Delete from stack\\nfunc (this *CustomStack) Pop() {\\n    if len(this.ArrValue) > 0 {\\n        this.ArrValue = this.ArrValue[:len(this.ArrValue)-1]\\n        this.ArrIndex = this.ArrIndex[:len(this.ArrIndex)-1]    \\n    }\\n}\\n\\n//Calc area rectange from last stack element\\nfunc (this *CustomStack) CalcArea() int {\\n    if this.Size() == 0 {\\n        return 0\\n    }\\n    value, index := this.Front()\\n    return (this.Index - index) * value\\n}\\n\\nfunc (this *CustomStack) Size() int {\\n    return len(this.ArrValue)\\n}\\n\\n//Get last element\\nfunc (this *CustomStack) Front() (int, int) {\\n    if(this.Size() == 0){\\n        return 0, 0\\n    }\\n    return this.ArrValue[len(this.ArrValue) - 1], this.ArrIndex[len(this.ArrIndex) - 1]\\n}\\n\\nfunc (this *CustomStack) PopAndCalcArea(curVal int) {\\n    index := 0\\n    checkMaxBar := false\\n    for i:=len(this.ArrValue)-1; i>=0; i-- {\\n        if this.ArrValue[i] > curVal {\\n            if !checkMaxBar {\\n                //check last (max) bar size with max area\\n                checkMaxBar = true\\n                if this.MaxArea < this.ArrValue[i] {\\n                    this.MaxArea = this.ArrValue[i]\\n                }\\n            }\\n            index = this.ArrIndex[i]\\n            area := this.CalcArea()\\n            // fmt.Printf(\" pop %d \", this.ArrValue[i])\\n            this.Pop()\\n            \\n            if this.MaxArea < area {\\n                this.MaxArea = area\\n            }\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    this.Push(curVal, index)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727570,
                "title": "stack-solution-o-n-with-explanation",
                "content": "Find Nearest Smallest to Left ( lets say this index is x, incase NSL does not exist return -1)\\nFind Nearest Smallest to Right ( lets say this index is y, incase NSR does not exist return array\\'s length)\\n\\nWe can start considering each building as base and ans will be max ( heights[i]*(p[i].y-p[i].x-1)) for every index.\\n\\n\\nHere\\'s the code\\n\\n```\\nclass Solution {   \\n    class Pair{\\n        int x,y;\\n    }\\n    public int largestRectangleArea(int[] h) {\\n        if(h.length == 0) return 0;\\n        if(h.length == 1) return h[0];\\n        Pair[] p = new Pair[h.length];\\n        for(int i=0;i<p.length;i++)\\n            p[i] = new Pair();\\n        Stack<Integer> st = new Stack<Integer>();\\n        // Find Nearest Smallest to Left\\n        for(int i=0;i<h.length;i++){\\n            if(st.isEmpty()){\\n                p[i].x = -1;\\n            }\\n            else if(h[st.peek()] < h[i]){\\n                p[i].x = st.peek();\\n            }\\n            else{\\n                while(!st.isEmpty() && h[st.peek()] >= h[i])\\n                    st.pop();\\n                if(st.isEmpty())\\n                    p[i].x = -1;\\n                else p[i].x = st.peek();\\n            }\\n            st.add(i);\\n        }\\n        \\n        st.clear();\\n\\t\\t\\n\\t\\t// Find Nearest Smallest to Right\\n        for(int i=h.length-1;i>=0;i--){\\n            if(st.isEmpty()) p[i].y = h.length;\\n            else if(h[i] > h[st.peek()]) p[i].y = st.peek();\\n            else {\\n                while(!st.isEmpty() && h[i] <= h[st.peek()]){\\n                    st.pop();\\n                }\\n                if(st.isEmpty())\\n                    p[i].y = h.length;\\n                else p[i].y = st.peek();\\n            }\\n            st.add(i);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<p.length;i++){\\n            ans = Math.max(ans, h[i]*(p[i].y-p[i].x-1));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {   \\n    class Pair{\\n        int x,y;\\n    }\\n    public int largestRectangleArea(int[] h) {\\n        if(h.length == 0) return 0;\\n        if(h.length == 1) return h[0];\\n        Pair[] p = new Pair[h.length];\\n        for(int i=0;i<p.length;i++)\\n            p[i] = new Pair();\\n        Stack<Integer> st = new Stack<Integer>();\\n        // Find Nearest Smallest to Left\\n        for(int i=0;i<h.length;i++){\\n            if(st.isEmpty()){\\n                p[i].x = -1;\\n            }\\n            else if(h[st.peek()] < h[i]){\\n                p[i].x = st.peek();\\n            }\\n            else{\\n                while(!st.isEmpty() && h[st.peek()] >= h[i])\\n                    st.pop();\\n                if(st.isEmpty())\\n                    p[i].x = -1;\\n                else p[i].x = st.peek();\\n            }\\n            st.add(i);\\n        }\\n        \\n        st.clear();\\n\\t\\t\\n\\t\\t// Find Nearest Smallest to Right\\n        for(int i=h.length-1;i>=0;i--){\\n            if(st.isEmpty()) p[i].y = h.length;\\n            else if(h[i] > h[st.peek()]) p[i].y = st.peek();\\n            else {\\n                while(!st.isEmpty() && h[i] <= h[st.peek()]){\\n                    st.pop();\\n                }\\n                if(st.isEmpty())\\n                    p[i].y = h.length;\\n                else p[i].y = st.peek();\\n            }\\n            st.add(i);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<p.length;i++){\\n            ans = Math.max(ans, h[i]*(p[i].y-p[i].x-1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696303,
                "title": "easy-to-understand-efficicent-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int area = 0;\\n        stack<int>st;\\n        heights.push_back(0);\\n        int n = heights.size();\\n        for(int i = 0 ; i < n ; i++){\\n            while(!st.empty() && heights[st.top()] > heights[i]){\\n                int h = heights[st.top()];\\n                st.pop();\\n                 int r = st.empty() ? -1 : st.top();\\n                 area = max(area, (i - r -1) * h);\\n            }\\n            st.push(i);\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int area = 0;\\n        stack<int>st;\\n        heights.push_back(0);\\n        int n = heights.size();\\n        for(int i = 0 ; i < n ; i++){\\n            while(!st.empty() && heights[st.top()] > heights[i]){\\n                int h = heights[st.top()];\\n                st.pop();\\n                 int r = st.empty() ? -1 : st.top();\\n                 area = max(area, (i - r -1) * h);\\n            }\\n            st.push(i);\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567373,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1702331,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566298,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566069,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566318,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1570433,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566046,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1567188,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1568904,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566698,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1567373,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1702331,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566298,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566069,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566318,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1570433,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566046,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1567188,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1568904,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1566698,
                "content": [
                    {
                        "username": "stevenzhang0",
                        "content": "I appreciate the stack solution, but I feel like I would never derive this in an interview without having seen it before. What first principles could one use to figure this out?\\n\\nThe divide and conquer solution I could see someone deriving in an interview, (as well as the better brute force one).\\n\\nAny ideas?"
                    },
                    {
                        "username": "freshlysquozen",
                        "content": "I was able to solve this one in about 20 mins without seeing it before. This was my intuition to realise to use a stack:\\n\\nAt first I looked at the problem and I was guessing there will be some o(n) or o(nlogn) solution. This makes me think that the answer can be computed during iteration, like best=max(best, current) ect.\\n\\nThen notice, for a given height, if you only know heights you have seen so far, you are only concerned with heights earlier and less than or equal than the current height. This means there is an ascending staircase pattern. Then you have to figure out how to maintain an ascending staircase. At this point it\\'s easy to see a stack, you pop off everything at the top of the staircase and then you add new stuff on top.\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "Well one can find area for every particular bar in the given histogram and then see which one is largest if it comes to brute force else without seeing it before it\\'s much difficult to solve without any hints or help !!!1"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Usually only a few can. Many questions use some extremally intelligent algos that took experts/professors days if not weeks to come up with."
                    },
                    {
                        "username": "Ananta_Vaishnavi_Movva",
                        "content": "Follow this guide to understand I found it really helpful\\nhttps://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I started thinking solution in terms of stack like \"What should I do with stacks to make it work?\" but it never worked.\nRather, I thought \"Forget stack, what should I do non-algorithmically like logic wise to get the answer?\" then I realized. When I came up with a logic,  I was like \"Oh to do this logic, we need a stack!\""
                    },
                    {
                        "username": "zenzen5",
                        "content": "**Brute force:**\\nEvery index i consider the first element smaller than a[i] on the right, same on the left. Then the area built using i will be (right-left-1)*a[i]. We do this for each index and take the max. Note that this formula does not change.\\n\\n**Observation 1:**\\nInefficiency in the brute force solution is that we have to (re)scan right and left for every index. Maybe we can avoid the rescan by changing the order in which we consider i (not necessarily i to n). To do this we will need to store indexes in a list and iterate in a different order somehow.\\n\\n**Observation 2 (eliminate right scan):**\\nFor a special case, we observe that we don\\'t need to rescan to the right. Assume in the array [a,b,c,d,e] a<=b<=c<=d and e<d. If we consider d, the first element less than d to the right is e. We can look for elements like d by iterating till, let\\'s say, the first i where a[i]<a[i-1]. Then if we consider a[i-1] first to calculate area (which is d) we have eliminated the need for a right side scan. We still have to scan to the left, but we should make sure that once we have established this state, we maintain it to avoid right scan, ever.\\n\\n**Observation 3:**\\nBy right elimination strategy in observation 2, we also notice that everything to the left of a[i-1] is <=d. What this means is that if a[i-k] where k>1 wants to make a rectangle with its height, it can at least do that upto a[i-1] (a[i-1] can \"absorb\" all possible height rectangles before it since it is bigger). We don\\'t know the relationship between a[i-k] and a[i] though, a[i] may or may not be able to absorb a[i-k]. What this means is that after we consider a[i-1], we have to re-evaluate the relationshuip between a[i-2] and a[i] and make sure the constraint in Observation 2 holds.\\n\\n**Observation 4 (eliminate left scan):**\\nLets say we\\'ve been using a list L to store indices to consider them out of order to avoid rescanning. When we consider L[L.Length-1], we know that the element before it (L[L.Length-2]) could be equal or smaller to it. If it is strictly smaller, we know the left smaller element and can calculate the area which would be the max using a[i-1] with the brute force formula. If it is equal, it means after removing L[L.Length-1], the constraint in observation 2 still holds (a[L[Length-2]] > a[i]). So for L[L.Length-2] we still know the right and left smaller and can calculate area which would include L[L.Length-1]. This means it is ok to consider L[L.Length-2] as the left min while considering L[L.Length-1] while maintain right side constraint, and the left side falls into place (if equal, in the next iteration, when we consider L[L.Length-2]).\\n\\n**Observation 5 (order of consideration):**\\nIt should be clear that it is ok to consider indexes one at a time, the last one in L as long as we maintain the constraint in (2). When we remove L we may need to iterate i and add more things to L to maintain the constraint between L[Length-2] and i. So now it should be obvious why the List is just a stack since we only care about the last 2 at a time.\\n\\n\\n**Recap**\\nWe look for the pattern in observation 2 and store its indices in a stack. So we store the indices of [a,b,c,d] in a stack S and i is the next index (so a[i] == e). We must maintain this stack with this constraint in mind, that the top element must be the greatest in the stack and a[i] must be smaller than it to avoid right scan (a[L[L.Length-1]] > a[i]). We can always consider stack[top-1] to be the left min to avoid left scan, and the max area will fall into place eventually. At any point stack[top] is the index we are considering with a[i] the right min and stack[top-1] the left min."
                    },
                    {
                        "username": "codepro",
                        "content": "What is the best run-time for this problem?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "5000 years later"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@mint_](/mint_)  Ouch :D"
                    },
                    {
                        "username": "browntiger",
                        "content": "[@mint_](/mint_) Hopefully `codepro` is still not trying to find out the runtime for it. "
                    },
                    {
                        "username": "mint_",
                        "content": "[@durveshpal538](/durveshpal538) in the time it took you respond back (8 years) this guy probably interviewed at a few companies, went from junior to senior level in a company and started a whole family\\n\\njust messing with you, some other people probably found this helpful"
                    },
                    {
                        "username": "durveshpal538",
                        "content": "O(n)"
                    },
                    {
                        "username": "BlueCocoa",
                        "content": "Just done this problem and got AC. \\n\\nI wrote a detailed blog post of my thought process. Because I saw some discussion here which goes straightly using stack without the reason of using stack, or **how did they came up with the idea**. It indeed solved the problem, only without a trace that makes they think of using stack.\\n\\nSo the post goes from the beginning to the blink of the lightblub, using stack. \\n\\nThere may be grammar mistakes (as English isn\\'t my native language, I\\'ll try my best), but I just want to help people who are confused of how did the idea formed.\\n\\n[https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/](https://blog.0xbbc.com/2019/08/maximum-rectangular-area-in-histogram/)"
                    },
                    {
                        "username": "harshapranav323",
                        "content": "[@Priyanshu_011](/Priyanshu_011) ++, Link isn't working\n"
                    },
                    {
                        "username": "Priyanshu_011",
                        "content": "[@xiyu0612](/xiyu0612) the link is not working"
                    },
                    {
                        "username": "xiyu0612",
                        "content": "the link seems down now"
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "dreamsofcode",
                        "content": "Great Explanation! Thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-rectangle-in-histogram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Divide and Conquer Approach\n\n  \n**Approach 4:** Better Divide and Conquer\n\n  \n**Approach 5:** Using Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "codefish",
                        "content": "A pretty large test case is added, making my previously ACed JAVA solution TLE.\\nI guess it's due to the frequent stack operations (reallocation memory).\\nI worked around this by using ArrayList to simulate the Stack and specify the init capacity to avoid memory reallocation. It works.\\n\\nNot sure if there is better solution."
                    },
                    {
                        "username": "ayuanx",
                        "content": "Not to mention in a short window like 30min or less in interview?\\nI highly doubt that.\\nThis is the kind of problem that if you haven't seen it before, you won't be able to answer it in interview anyway.\\nSo basically there is no point to have a problem like this in interview."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1603860/6-Similar-questions-oror-Prev-smaller-Next-smaller-oror-Monotonic-stack-oror-C++"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions here"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved using sliding window?"
                    }
                ]
            },
            {
                "id": 1845316,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1567842,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1895954,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1570306,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1570031,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1567843,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1955505,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1949359,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1947745,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1870235,
                "content": [
                    {
                        "username": "Toshito",
                        "content": "It took me 5 hours to solve this problem. Nevertheless, it was worth it. \nApproach: Use Next Smaller Element & Previous Smaller Element."
                    },
                    {
                        "username": "RainbowSecret",
                        "content": "Referred to the Post from GeeksforGeeks.\\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][1]\\n\\n\\nThe most naive solution is to compute O(N^2) areas and choose the max value and return.\\n\\nSo how can we solve in O(N*logN)\\uff0c here comes the Divide and Conquer\\n\\nThe idea is to find the minimum value in the given array. \\n\\nOnce we have index of the minimum value, the max area is maximum of following three values.\\n\\n        a) Maximum area in left side of minimum value (Not including the min value)\\n        b) Maximum area in right side of minimum value (Not including the min value)\\n        c) Number of bars multiplied by minimum value.\\n\\nSo the key is how to find the minimum value in O(logN) time. \\n\\nthe segment tree can help us to do that \\n\\n[http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/][2]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/\\n  [2]: http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/"
                    },
                    {
                        "username": "Karilli",
                        "content": "This isn\\'t O(nlogn) in the worst case thought, consider large sorted array -> you will not split it in half, but rather chip one number at a time, making it O(n^2)"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" before this problem to get a better understanding of this"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it in O(n) based on the explanation given at\\n(https://www.algotree.org/algorithms/stack_based/largest_rectangle_in_histogram/)\\n"
                    },
                    {
                        "username": "9shivanshsharma",
                        "content": "Any thoughts ?\\nPlease let me know if it can be done by 2 pointer approach\\nmin(heights[start], heights[end]) * (end + 1 - start)"
                    },
                    {
                        "username": "wingjay",
                        "content": "has anyone meet this problem? I think it's a mistake of leetCode itself,Because it's always Line '14' Error even when i move the code on line 14 to other line.\\nHas anyone meet this kind of problem?"
                    },
                    {
                        "username": "Wogrim",
                        "content": "This can be solved in a single pass, O(n) time.  Hopefully these hints will help:\n1. Looking at Example 1, note for each bar where is the biggest rectangle that uses the full height of the bar.  These are the only rectangles that need to be calculated.\n2. Cover all the bars and reveal them one at a time, left to right.  Figure out when you have enough info to calculate each bar's rectangle (without knowing anything about the hidden bars to the right).\n3. Figure out what info about the bars to the left you need to keep track of (and what you don't need / when you no-longer need it), and how to organize it so that you're not wasting time."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "My friends are telling me, I am genius,\\njust because I solved this problem."
                    },
                    {
                        "username": "Prajju22",
                        "content": "question esa design karo ki char log like karein"
                    },
                    {
                        "username": "terrysuun",
                        "content": "what does it mean to have passed 98/98 cases, then have a time limit exceeded failure? Has this happened to anyone else? Is there an empty test case somewhere?"
                    }
                ]
            },
            {
                "id": 1866765,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1633027,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1576177,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1575996,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1575286,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1573204,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1572026,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1571191,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2063340,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2055110,
                "content": [
                    {
                        "username": "_jay_vyas",
                        "content": "heights =\\n[2,1,2]\\nOutput\\n2\\nExpected\\n3\\n\\nCan someone explain how expected is 3 here?\\n"
                    },
                    {
                        "username": "chengqqq",
                        "content": "consider this , from the horizontal perspective\n\n[]X[]\n[][][]\nthere is a bottom layer of area 3 ([][][])"
                    },
                    {
                        "username": "Shubham9497",
                        "content": "this problem is having one twist at the end when you try to find right smaller element  be alert when you try to take index for next smaller element .in this take arr.length ie as a index .otherwise solution will not match"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Monotonic stack ensures that the element in the stack is monotonic.\\nThe key idea is every time an element A is popped out of the stack, the current element at the top of the stack is the closest element to the left that is smaller than A while the element going to be pushed is the closest element to the right that is smaller than A.\\nTherefore, with one pass, we can compute the maximum rectangle for each position when it is popped out. The time complexity is O(n)."
                    },
                    {
                        "username": "raineywilliams",
                        "content": "We can use a stack to keep track of every block we have seen. We push each block on the stack as long as it has a taller height than the previous block (top of the stack). If the current block is shorter than the previous block, we compute the current maxArea given the max height across previous blocks and index of previous blocks then we pop the top of the stack, as it max height has been reached. We push a new block that\\'s index is that of the popped block, because this new block could technically still form a smaller rectange.\\n\\nthen, we iterate the stack and find the max area of all the current blocks. We return this max."
                    },
                    {
                        "username": "gentlezephyr95",
                        "content": "This is a very good explanation of the thought process to come up with the algorithm.\\nhttps://medium.com/algorithms-digest/largest-rectangle-in-histogram-234004ecd15a"
                    },
                    {
                        "username": "rongzhig",
                        "content": "the basic idea is to find area corresbonding to each bar. \\n**the way is to find the last and next bar with height less than current bar! **\\nwith a stack to save ascending subsequence of heights, we can get those 2 indexes. because each bar just gets into stack and gets out for 1 time, all cases are considered and time complexity is o(n)\\nthis image is clear. shadow part is area corresbonding to the bar k\\n![image](https://assets.leetcode.com/users/rongzhig/image_1574460917.png)\\n"
                    },
                    {
                        "username": "iamsiter",
                        "content": "If someone asks you to look at diagram and ask for max area rectangle you would consider each location and try to go as far as possible on left and right and get max area.\\nStack is also used to store this information.At any position you start and try to go as right as possible so that you can carve out some area.\\n\\nOnce you reach a bar which has height less than, we start calculating the area by fixing left end as value popped from the stack.(Also handling the case when stack becomes empty)\\n\\nBottomline is stack can be used to carve the area on right side of ith bar and left side of ith bar if we observe the working carefully."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I used the idea from http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/ and convert it to a O(nlogn) divide and conquer solution, it will TLE on \"0, 1, 2, 3, ...\"  case.\\n\\nI know there's an O(n) solution but I don't think that's a trivial one that everyone can come up with before reading the blog http://www.geeksforgeeks.org/largest-rectangle-under-histogram/\\n\\nIs it supposed that we should use the O(n) solution to pass OJ?"
                    },
                    {
                        "username": "vaibhavtewani2308",
                        "content": "read the problem statement again and then here\\'s my take for this question We will be creating a stack Starting from the first element and it would be containing values in monotonic increasing fashion means we;ll append the values in it in such a way that if a larger value is encountered we\\'ll put theat value in the satack if a smaller value is encounteredd we\\'ll pop the elements of the stack untull we get an element which is smaller than or equal to the element that we just found why is taht so ?? this is beacause the question is saying for every element in the array we need to find an element that is just smaller to it on both the sides this is because we know that to extend an element lets suppose at index 3 and height 6 we\\'d be needing atleaast bigger than 6 or equals to it on both the sides to achive an area whose width can be adjacent to it now to achieve so well append the values in the increasing order in the stack so that we\\'ll get the result also we\\'ll encounter two more things in the path and that is that smaller element standing left to 6 can also be extended to the bondary of 6 (because just after we found the local dead end and the newmaxarea can also be updated/created now from the contigous chhain of increasing elements that we just found in the stack.) now in order to do so we\\'ll look into the stack and for every next smaller element that is being found for eg 5 we\\'ll extend its witdh by 1 and would check the max area from the current histogram line to the local deadend (here 2) until the 2 is found as soon as we\\'d find the same element or less than it we\\'d update the stack with starting index for that element and then when all this elements are done   "
                    },
                    {
                        "username": "shreyyerhs07",
                        "content": "can someone please help me!! for the test caseheights={2,4} when i run this code in intellij idea it is giving ans=4 which is correct but this leetcode is giving 0 output why both output differs for same code?\\nclass Solution {\\n    int [] nser(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<heights.length;i++){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n        while(st.size()!=0){\\n            nge[st.peek()]=-1;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n     int [] nsel(int [] heights){\\n        int nge[]=new int[heights.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=heights.length-1;i>=0;i--){\\n         if(st.size()==0){st.push(i);}\\n         else if(heights[st.peek()]>heights[i]){\\n          while(st.size()>0 && heights[st.peek()]>heights[i]){\\n              nge[st.peek()]=i;\\n              st.pop();\\n          }\\n          st.push(i);\\n         }\\n         else{st.push(i);}\\n        }\\n\\n         while(st.size()!=0){\\n            nge[st.peek()]=heights.length;\\n            st.pop();\\n        }\\n        \\n        return nge;\\n    }\\n\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int area=0;\\n        int nsera[]=nser(heights);\\n       \\n        int nsela[]=nsel(heights);\\n        \\n\\n        for(int i=0;i<heights.length;i++){\\n            int h=heights[i];\\n            int l=nsela[i];\\n            int r=nsera[i];\\n            int b=r-l-1;\\n            if(h*b>area){area=h*b;}\\n        }\\n\\n     return area;   \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2033978,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1985468,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1983280,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1981389,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1969494,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1967940,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1965709,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1928175,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1909255,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1895968,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "i would recommend you to solve \"sum of subarray minimums\" before this  "
                    },
                    {
                        "username": "GURU39",
                        "content": "heights = [2,1,5,6,2,3]\\nIn this test case why not 2 and 3 is not possible ?\\n\\nbeacuse height is 2  and width is 6 then arean will be 12\\n [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can someone explain why does this logic fail?\nIt passes only 25 testcases.\nI tried with (right-left) as well. \n\n``` class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int max_area =0;\n        int left=0;\n        int right = heights.length-1;\n        while(left<right){\n            max_area = Math.max(max_area, (right-left+1)*(heights[left]<heights[right]?heights[left++]:heights[right--]));\n        }\n        return max_area;\n    }\n} "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just got this asked alongside 2 other easy level problems. Had to solve all 3 in 40 mins lol. No one that has not seen this before can solve it in that time"
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "Yes bro. I too agree wtih you\\n"
                    },
                    {
                        "username": "Lesley999",
                        "content": "really feel i\\'m a fool"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i in range(len(heights)):\\n            while stack and heights[i] < heights[stack[-1]]:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n\\n            stack.append(i)\\n\\n        return max_area\\n\\n\\n# Example usage\\nheights = [2, 1, 5, 6, 2, 3]\\nsolution = Solution()\\nresult = solution.largestRectangleArea(heights)\\nprint(\"Area of the largest rectangle in the histogram:\", result)\\n"
                    },
                    {
                        "username": "yashraj_thakur",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack <int> st;\\n        int ans = 0, n = heights.size(), i = 0;\\n\\n        while(i<n){\\n            while(!st.empty() && heights[st.top()]> heights[i]){\\n                int t = st.top();\\n                int h = heights[t];\\n                st.pop();\\n                if(st.empty()){\\n                    ans = max(ans, h*i);\\n                }\\n                else{\\n                    int len = i - st.top() - 1;\\n                    ans = max(ans, h*len); \\n                }\\n            }\\n            st.push(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nthis code is not running for testcase [2,4], can someone please help?"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "Can this be solved with sliding window?"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I hate this with a passion"
                    },
                    {
                        "username": "svyas",
                        "content": "think of first smaller element in both right and left side"
                    }
                ]
            },
            {
                "id": 1876734,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1875106,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1858692,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1826312,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1812010,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1805528,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1793466,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1792156,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1791795,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1783932,
                "content": [
                    {
                        "username": "_seemantkaushal",
                        "content": "we can solve this question using the stack to find out the previous smaller height index and next smaller height .using the stack .\\nand then calculating the area."
                    },
                    {
                        "username": "isagi11",
                        "content": "Is there a similarity between this problem and [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)?\\nWanted to know if I can solve this with 2 pointer approach. Am I missing something?"
                    },
                    {
                        "username": "rohumahajan0707",
                        "content": "why i am getting the folloaing error?\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x603000000040 overflowed to 0x60300000003c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nthis is my code\\n#include<stack>\\nclass Solution {\\npublic:\\n    vector<int> nextSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n    stack<int> s;\\n    s.push(-1);\\n\\n    for(int i=n-1; i>=0; i--){\\n       while(s.top()!=-1&&arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int>& arr, int n){\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n\\n    for(int i=0; i<n; i--){\\n        while(s.top()!=-1 && arr[s.top()]>=arr[i])\\n            s.pop();\\n            if(s.empty()){\\n            ans[i]=arr[i];\\n            s.push(arr[i]);\\n            }\\n            else\\n            {\\n            ans[i]=s.top();\\n            s.push(i);\\n            \\n            }\\n    }\\n    return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        int ans = 0;\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        next = nextSmallerElement(heights, n);\\n        for(int i=0; i<n; i++){\\n            int l = heights[i] ;\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int b = next[i]-prev[i]-1;\\n            int newArea = l*b;\\n            ans = max(ans, newArea);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `public int largestRectangleArea(int[] hist) {\\n        Stack<Integer> s = new Stack<>();\\n    int n=hist.length;\\n        int max_area = 0; // Initialize max area\\n        int tp; // To store top of stack\\n        int area_with_top; // To store area with top bar as\\n                           // the smallest bar\\n  \\n        // Run through all bars of given histogram\\n        int i = 0;\\n        while (i < n) {\\n            // If this bar is higher than the bar on top\\n            // stack, push it to stack\\n            if (s.empty() || hist[s.peek()] <= hist[i])\\n                s.push(i++);\\n  \\n            // If this bar is lower than top of stack, then\\n            // calculate area of rectangle with stack top as\\n            // the smallest (or minimum height) bar. \\'i\\' is\\n            // \\'right index\\' for the top and element before\\n            // top in stack is \\'left index\\'\\n            else {\\n                tp = s.peek(); // store the top index\\n                s.pop(); // pop the top\\n  \\n                // Calculate the area with hist[tp] stack as\\n                // smallest bar\\n                area_with_top\\n                    = hist[tp]\\n                      * (s.empty() ? i : i - s.peek() - 1);\\n  \\n                // update max area, if needed\\n                if (max_area < area_with_top)\\n                    max_area = area_with_top;\\n            }\\n        }\\n  \\n        // Now pop the remaining bars from stack and\\n        // calculate area with every popped bar as the\\n        // smallest bar\\n        while (s.empty() == false) {\\n            tp = s.peek();\\n            s.pop();\\n            area_with_top\\n                = hist[tp]\\n                  * (s.empty() ? i : i - s.peek() - 1);\\n  \\n            if (max_area < area_with_top)\\n                max_area = area_with_top;\\n        }\\n  \\n        return max_area;\\n        \\n    }`"
                    },
                    {
                        "username": "RishabhKumar257",
                        "content": "I am trying brute force . Because if we see a question the first thing that we could think is brute force if you have'nt solved similar question earlier. I designed a O(n^2) solution but it is failing at 27th test case.\n\nInput : [1,1]\nExpected output : 2\nOutput : 1\n\nCan anyone please rectify my brute force solution. I knew why the problem is occuring because after first iteration j is becoming -1 and hence we can not update our next but i am not finding any idea how to solve\n\n\n        int maxArea = INT_MIN;\n\n        for(int i=0;i<heights.size();i++){\n\n            int next = i;\n            int prev =i;\n\n            for(int j=i,k=i;(k<heights.size()&&j>=0);j--,k++){\n\n              \n                if(heights[j]>=heights[i] && j>=0){\n                    prev =j;\n                }\n\n                if(heights[k]>=heights[i]){\n                next =k;\n                }\n\n            }\n\n            \n            int area = (next-prev+1)*heights[i];\n            maxArea = max(area,maxArea);\n\n\n        }\n            return maxArea;"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& a) {\\n          //NSR\\n          int n=a.size();\\n        vector<int> v1;\\n        stack<pair<int,int>> s1;\\n        \\n         vector<int> v2;\\n        stack<pair<int,int>> s2;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s1.empty())\\n                v1.push_back(n);\\n                \\n            else if(s1.size()>0 && s1.top().first<a[i]) \\n                v1.push_back(s1.top().second);\\n                \\n            else\\n            {\\n                while(s1.size()>0 && s1.top().first>=a[i])\\n                    s1.pop();\\n                    \\n                if(s2.size()==0)\\n                    v1.push_back(n);\\n                else\\n                     v1.push_back(s1.top().second);\\n                    \\n            }\\n            s1.push({a[i],i});\\n        }\\n        reverse(v1.begin(),v1.end());\\n        \\n        //NSL\\n       \\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(s2.empty())\\n                v2.push_back(-1);\\n                \\n            else if(s2.size()>0 && s2.top().first<a[i]) \\n                v2.push_back(s2.top().second);\\n                \\n            else\\n            {\\n                while(s2.size()>0 && s2.top().first>=a[i])\\n                    s2.pop();\\n                    \\n                if(s2.empty())\\n                    v2.push_back(-1);\\n                else\\n                     v2.push_back(s2.top().second);\\n                    \\n            }\\n            s2.push({a[i],i});\\n        } \\n        \\n        vector<int> width;\\n        int i;\\n        for(i=0;i<=n-1;i++)\\n        {\\n            width[i]=v1[i]-v2[i]-1;\\n        }\\n        \\n        vector<int> area;\\n        for(i=0;i<n;i++)\\n         {\\n            area[i]=a[i]*width[i];\\n        }\\n        \\n         int x= *max_element(area.begin(),area.end());\\n        return x;\\n        \\n    }\\n};\\n\\nsomeone please help"
                    },
                    {
                        "username": "sarthaknirgude01",
                        "content": "#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> nextSmallerElement(vector<int>&arr,int n){\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i = n-1;i >= 0;i--){\\n                int curr = arr[i];\\n                while(st.top() != -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        vector<int> preSmallerElement(vector<int>&arr,int n)\\n        {\\n            stack<int>st;\\n            st.push(-1);\\n            vector<int>ans(n);\\n\\n            for(int i=0;i < n;i++)\\n            {\\n                int curr = arr[i];\\n                while(st.top()!= -1 && arr[st.top()] >= curr)\\n                {\\n                    st.pop();\\n                }\\n                ans[i] = st.top();\\n                st.push(i);\\n            }\\n            return ans;\\n        }\\n        int largestRectangleArea(vector<int>& heights) {\\n            int n = heights.size();\\n\\n            vector<int>next(n);\\n            next = nextSmallerElement(heights,n);\\n\\n            vector<int>pre(n);\\n            pre = preSmallerElement(heights,n);\\n            \\n            int area = 0;\\n            for(int i=0;i < n;i++)\\n            {\\n                int l = heights[i];\\n                if(next[i]==-1){\\n                    next[i] = n;\\n                }\\n                int b = next[i] - pre[i] - 1;\\n                int newArea = l*b;\\n                area = max(area,newArea);\\n            }\\n            return area;\\n        }\\n};"
                    },
                    {
                        "username": "bhavesh_4k",
                        "content": "has anyone seen this type of questions in real interview? is solving this types of questions really worth it? i don\\'t have much time, companies about to come for recruitment in college campus in a month and i need only set of problems which might be asked in interviews...."
                    },
                    {
                        "username": "kingcall550102",
                        "content": "NO. I never seen this before, Those problem is so trivial. You don\\'t have to spend time to understand it. "
                    },
                    {
                        "username": "sandeepkr_1999",
                        "content": "Below is my code and it is giving me error of untime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'std::pair<int, int>\\', which requires 4 byte alignment (stl_deque.h).\\nCan anyone help me whats wrong in my code\\n\\n\\n\\nint largestRectangleArea(vector<int>& arr) \\n    {\\n        stack<pair<int,int>> s;\\n        vector<int> left;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(s.size()==0)\\n            {\\n                left.push_back(-1);\\n            }\\n            else if(s.size()>0 && s.top().first < arr[i])\\n            {\\n                left.push_back(s.top().second);\\n            }\\n            else if(s.size()>0 && s.top().first >= arr[i])\\n            {\\n                while(s.top().first>=arr[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.size()==0)\\n                {\\n                    left.push_back(-1);\\n                }\\n                else\\n                {\\n                    left.push_back(s.top().second);\\n                }\\n            }\\n            s.push({arr[i],i});\\n        }\\n        \\n        vector<int> right;\\n        stack<pair<int,int>> p;\\n        for(int i=arr.size()-1;i>0;i--)\\n        {\\n            if(p.size()==0)\\n            {\\n                right.push_back(arr.size());\\n            }\\n            else if(p.size()>0 && p.top().first < arr[i])\\n            {\\n                right.push_back(p.top().second);\\n            }\\n            else if(p.size()>0 && p.top().first >= arr[i])\\n            {\\n                while(p.top().first>=arr[i])\\n                {\\n                    p.pop();\\n                }\\n                if(p.size()==0)\\n                {\\n                    right.push_back(arr.size());\\n                }\\n                else\\n                {\\n                    right.push_back(s.top().second);\\n                }\\n            }\\n            p.push({arr[i],i});\\n        }\\n        vector<int> wd;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            wd[i] = right[i]-left[i]-1;\\n        }\\n        int area=INT_MIN;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            area=max(area,wd[i]*arr[i]);\\n        }\\n         return area;\\n    }\\n"
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "You are accessing s.top() withhout checking if it\\'s non-empty. that\\'s the reason."
                    },
                    {
                        "username": "zimingmorning520",
                        "content": "what is the time complexity limitation in this problem?  must be O(n)? "
                    }
                ]
            },
            {
                "id": 1775044,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1765012,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1759968,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1758474,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1754143,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1754142,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1723268,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1716549,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1715164,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1714245,
                "content": [
                    {
                        "username": "aarshiagg20",
                        "content": "I know it's a HARD problem ( : o )\n**Previous Knowledge Used :** Stack, previous Smaller Element, next Smaller Element.\n**Understanding Problem :**\nAn Array of heights will be given to you let us Consider an example :\nheights[] = {2,1,5,6,5,2}\nlet us visualize the heights with the help of histogram\n![This is an image](https://i.ibb.co/HDpR0YH/image.png) \nWe would try finding the maximum area corresponding to each height in histogram : \n*We maintain a variable for maximum area and initialize it with zero to store max area at every point of computation*\nArea = height * width\nhere you will be given height for each bar but you need to figure the width.\n\nHint : Find the maximum index till which you can cover this height on left and right.\nHere is a catch you can cover a smaller height from the bigger height but vice versa is not true.\nTo help you visualize better ......\n**Story Time !!**\nBut read it while keeping the above image in mind. \nImagine the bars as buildings of given height as floors and 1 unit corresponds one floor and all buildings are connected to each other even the floors. You can go to 1st floor of one building to 1st floor of another building *if it exists* . \nLet us check corresponding to each height how far you can travel....\n\n(1.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/FVqfnq4/image.png) \nLeft Side : Since there is no Building on left side hence you cannot travel to any buildings.\nRight Side : Since next building is smaller (only 1 floor) hence you cannot travel to next or further buildings using the topmost floor/ terrace (since we are computing for given height).\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (0 - 0 + 1)\nArea = 2 * 1 = 2 , maxArea = (0,2) = 2\nArea computed is 2. Since maxArea was initialised with 0 and we need to update maximum value area after every computation.\n\n*If you understood then congrats but don't skip the rest and if you can't, Don't Worry concept will be clear just don't give up and continue reading and try to visualize*\n\n(2.) Building consisting of 1 floor. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/GVxrN7V/image.png) \nLeft Side : Since there is a building of 2 floors and you could easily travel to the 1st floor of this building hence we extend area on left side.\nRight Side : Since next all buildings are larger than our present building and you could travel to 1st floor of each of these using the previous building hence we extend area till the end.\nArea = height * width \nheight = 1 and width = (ending - starting + 1) = (5 - 0 + 1)\nArea = 1 * 6 = 6 , maxArea = (2,6) = 6\nmaxArea is updated to 6 because it was greater than previous computed area which was 2.\n\n(3.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/mqZwTnr/image.png) \nLeft Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on left side.\nRight Side : Since next 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (6,15) = 15\nmaxArea is updated to 15 because it was greater than previous computed area which was 6.\n\n(4.) Building consisting of 6 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/8DxVL5Z/image.png) \nLeft Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on left side.\nRight Side : Since there is a building of 5 floors and you could not travel to the 6th floor of this building hence we cannot extend area on right side as well.\nArea = height * width \nheight = 6 and width = (ending - starting + 1) = (3 - 3 + 1)\nArea = 1 * 6 = 6 , maxArea = (15,6) = 15\nmaxArea reamins unchanged.\n\n(5.) Building consisting of 5 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/Tmqx2JD/image.png) \nLeft Side : Since previous 2 buildings are larger or equal to our present building and you could travel to 5th floor of each of these using the previous buildings hence we extend area till we can travel 5th floor and stops before building of 1 floor.\nRight Side : Since there is a building of 2 floors and you cannot travel to the 5th floor of this building hence we  cannot extend area on right side.\nArea = height * width \nheight = 5 and width = (ending - starting + 1) = (4 - 2 + 1)\nArea = 5 * 3 = 15 , maxArea = (15,15) = 15\nmaxArea remains unchanged.\n\n(6.) Building consisting of 2 floors. And Imagine Till which building you can travel using topmost floor/ terrace of this building.\n![This is an image](https://i.ibb.co/72YZXnW/image.png) \nLeft Side : Since previous 3 buildings are larger or equal to our present building and you could travel to 2nd floor of each of these using the previous buildings hence we extend area till we can travel 2nd floor and stops before building of 1 floor.\nRight Side : Since there is no building on right side hence we can't extend area to the right.\nArea = height * width \nheight = 2 and width = (ending - starting + 1) = (5 - 2 + 1)\nArea = 2 * 4 = 8 , maxArea = (15,8) = 15\nmaxArea remains unchanged.\n\nWe return the maximum computed Area as our result.\n\n**Framing our Visualization**\n\nSince now you have understood that for a particular height we can travel to any building which is bigger than our present and also continuous (means if there is a smaller building in between we can't travel to next Building)\n\nWe need to compute the next smaller element and previous smaller element for our height since till that point only we could cover distance on both sides.\nCorner cases : if previous smaller element does not exists than we use value -1 since it is previous value.\nif next smaller element does not exists than we use *n* as the previous value\n\nIn our visualization we were on the element to be computed but now we are calculating either previous smaller or next smaller element Hence our formula for width changes : \n**Before :**  *Width = ( Ending point - starting point + 1 )*\n**Now :**  *Width = ( NextSmaller - Previous Smaller - 1)*\nWe used 2 function with return type array to find out nextSmallerElement and prevSmallerElement\n\nAlgorithm is as Follows :\n\nn = heights.size();\nnextSmaller[] = nextSmallerElement(heights,n);\nprevSmaller[] = prevSmallerElement(heights,n);\nmaxArea = 0;\nfor(i = 0 to n-1)\n>area = heights[i] * (nextSmaller[i] - prevSmaller[i] -1)\n>maxArea = max(area,maxArea)\n\nreturn maxArea \n\nAfter Soving this problem you can try another problem \n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n[Maximum rectangular Area](https://leetcode.com/problems/maximal-rectangle/)\n\nThese question have a lot of similarity as well as dissimilarity\n\n*Every problem is easy once you understand it : )*\n\nIf you any Problem consult the code : \n\n`\n\n\n    vector<int> prevSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> prevSmaller(n);\n        for(int i=0;i<n;i++){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            prevSmaller[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        return prevSmaller;\n    }\n\n    vector<int> nextSmallerElement(vector<int>& heights,int n){\n        stack<int> s;\n        vector<int> nextSmaller(n);\n        for(int i=n-1;i>=0;i--){\n            while(!s.empty() && heights[s.top()]>=heights[i]) s.pop();\n            nextSmaller[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n        return nextSmaller;\n    }\n\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> nextSmaller = nextSmallerElement(heights,n);\n        vector<int> prevSmaller = prevSmallerElement(heights,n);        \n        int maxArea = 0;\n        for(int i=0;i<n;i++){\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*heights[i];\n            maxArea = max(area,maxArea);\n        }\n        return maxArea;\n    }\n`\n\n"
                    },
                    {
                        "username": "antonphedun",
                        "content": "Update year 2023. This problem is no longer gets Accepted with Divide and Conquer python solutions, so please use stack instead"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "Please, explain\\n how the max area is *20*\\nI got _18_ as max\\nheights = [3,6,5,7,4,8,1,0]"
                    },
                    {
                        "username": "Wogrim",
                        "content": "there is a rectangle 4 high and 5 wide"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "Not easy but its good solution.............................\\n class Solution {\\n    public:\\n    vector<int> nextSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> prevSmallerElement(vector<int> arr, int n)\\n    {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> next;\\n        next = nextSmallerElement(heights, n);\\n\\n        vector<int> prev;\\n        prev = prevSmallerElement(heights, n);\\n\\n        int area = INT_MIN;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int l = heights[i];\\n            if(next[i] == -1)\\n            {\\n                next[i] = n;\\n            }\\n            int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ShubhamMaske",
                        "content": "for [9,0] test case the code gives wrong output\\n can anyone tell what\\'s wrong in this code, because if i dry run this code for above test case it gives right o/p.\\n\\nCode is in Java Language. \\n\\nclass Solution {\\n\\n    class Element{\\n        int val, idx;\\n        public Element(int val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n     Stack<Element> st = new Stack<>();\\n\\n    public int largestRectangleArea(int[] heights) {\\n       int n = heights.length;\\n       int[] left = new int[n];\\n       int[] right = new int[n];\\n       int sLeft = -1;\\n       int sRight = n;\\n\\n    // for index of nearest smallest to left\\n       for(int i= 0 ;i<n;i++){\\n           if(st.isEmpty()){\\n               left[i] = sLeft;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   left[i] = sLeft;\\n               }\\n               else{\\n                   left[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur = new Element(heights[i], i);\\n           st.push(cur);\\n       }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n    // for index of nearest smaller to right\\n        for(int i=n-1 ;i>=0;i--){\\n           if(st.isEmpty()){\\n               right[i] = sRight;\\n           }\\n           else if(!st.isEmpty() && st.peek().val < heights[i]){\\n               left[i] = st.peek().idx;\\n           }\\n           else if(!st.isEmpty() && st.peek().val >= heights[i]){\\n               while(!st.isEmpty() && st.peek().val >= heights[i]){\\n                   st.pop();\\n               }\\n               if(st.isEmpty()){\\n                   right[i] = sRight;\\n               }\\n               else{\\n                   right[i] = st.peek().idx;\\n               }\\n           }\\n           Element cur1 = new Element(heights[i], i);\\n           st.push(cur1);\\n       }\\n\\n       //width Array\\n       int[] width = new int[n];\\n       for(int i=0;i<n;i++){\\n           width[i] = right[i] - left[i] -1;\\n       }\\n\\n       //Area of all heights\\n       int[] area = new int[n];\\n       for(int i=0;i<n;i++){\\n           area[i] = heights[i] * width[i];\\n       }\\n\\n       //for finding Maximum area\\n       int maxArea = area[0];\\n       for(int i=1;i<n;i++){\\n           if(maxArea < area[i])\\n                maxArea = area[i];\\n       }\\n\\n       return maxArea;\\n    }\\n}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\nprivate:\\n  vector<int> nextSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=n-1;i>=0;i--)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\nvector<int> prevSmallerElement(vector<int> &arr, int n)\\n{\\n  stack<int> s;\\n    vector<int> ans(n);\\n    s.push(-1);\\n    for(int i=0;i<n;i++)\\n    {  int curr= arr[i];\\n    while(s.top()!=-1&&arr[s.top()]>=curr){\\n        s.pop();\\n    }  \\n     ans[i]=s.top();\\n     s.push(curr);\\n        }\\n    return ans;\\n}\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        next= nextSmallerElement(heights, n);\\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights,n);\\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            if(next[i]==-1)\\n            {\\n                next[i]=n;\\n            }\\n            int b= next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area=max(newArea,area);\\n        }\\n        return area;\\n    }\\n};`\\ni got  runtime error here can somebody help me "
                    },
                    {
                        "username": "ankit1503",
                        "content": "EASY C++ SOLUTION\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& h) {\\n        int n=h.size();\\n    vector<int>front(n,-1);\\n    vector<int>back(n,-1);\\n\\n    stack<int>a;\\n    a.push(-1);\\n\\n    for(int i=0;i<h.size();i++)\\n    {\\n        while(!a.empty() && a.top()!=-1 && h[a.top()]>=h[i])\\n        {\\n            a.pop();\\n        }\\n      \\n        front[i]=a.top();\\n          a.push(i);\\n    }\\n    \\n     stack<int>b;\\n    b.push(-1);\\n    for(int i=h.size()-1;i>=0;i--)\\n    {\\n        while(!b.empty() && b.top()!=-1 && h[b.top()]>=h[i])\\n        {\\n            b.pop();\\n        }\\n      \\n        back[i]=b.top();\\n          b.push(i);\\n    }\\n\\n    \\n    int ans=0;\\n\\n     for(int i=0;i<h.size();i++)\\n    {\\n      int bk=back[i];\\n      int ft=front[i];\\n      if(bk==-1)\\n      bk=n;\\n        ans=max(ans,h[i]*(bk-ft-1));\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devanshshah1309",
                        "content": "Explained beautifully and very simply here:\\n\\nhttps://medium.com/@devanshshah1309/largest-rectangle-in-histogram-explained-4b7ef7142c87"
                    }
                ]
            },
            {
                "id": 1712434,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1712403,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1712347,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1710639,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1705994,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1683685,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1663882,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1648712,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1641287,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1641060,
                "content": [
                    {
                        "username": "averagebloke",
                        "content": "Why does my O(NlogN) solution (divide and conquer) exceed time limit?\\nIs the requirement O(N)?\\nOr is my solution really O(NlogN) as I thought?\\n\\n`public int largestRectangleArea(int[] heights) {\\n        return findMaxAreaRecursive(heights, 0, heights.length-1);\\n    }\\n\\n    private int findMaxAreaRecursive(int[] heights, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return heights[start];\\n        }\\n        if (end == (start + 1)) {\\n            return Math.max(2 * Math.min(heights[start], heights[end]), Math.max(heights[start], heights[end]));\\n        }\\n\\n        int minIndex = findMin(heights, start, end);\\n        int areaHere = heights[minIndex] * (end + 1 - start);\\n\\n        int maxLeft;\\n        int maxRight;\\n\\n        maxRight = findMaxAreaRecursive(heights, minIndex + 1, end);\\n        maxLeft = findMaxAreaRecursive(heights, start, minIndex - 1);\\n\\n        return Math.max(areaHere, Math.max(maxLeft, maxRight));\\n    }\\n\\n    /**\\n     * Find the index of the shortest bar - logN\\n     */\\n    private int findMin(int[] heights, int start, int end) {\\n        if (start == end) {\\n            return start;\\n        }\\n        if (end == start + 1) {\\n            return heights[start] >= heights[end] ? end : start;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int leftCandidate = findMin(heights, start, mid);\\n        int rightCandidate = findMin(heights, mid + 1, end);\\n        return heights[leftCandidate] >= heights[rightCandidate] ? rightCandidate : leftCandidate;\\n    }`"
                    },
                    {
                        "username": "averagebloke",
                        "content": "Wrong test case or how can the area of a rectangle be 3?\n`Input\nheights =\n[2,1,2]\n43 / 98 testcases passed\nOutput\n2\nExpected\n3`\n\nLooks like test case #44"
                    },
                    {
                        "username": "koff82",
                        "content": "I have to say, one of the trickiest questions I\\'ve seen."
                    },
                    {
                        "username": "BrownKyle",
                        "content": "It\\'s the end of 2022 and fun fact, chat GPT can solve this after a couple of prompts, absolutely nuts"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "I managed to pass this with a O(n^2) brute force with an optimization to skip the inner loop if we know the result won't be better than we already have."
                    },
                    {
                        "username": "nitin12384",
                        "content": "Why O(n^2) solution is passing\n```\ntypedef long long int lli;\n\nclass Solution {\npublic:\n    \n    lli max_rect_histogram(const vector<lli>& vec)\n{\n    int n = vec.size();\n    vector< pair<lli, int>> rect;\n    // rect[i].first -> value\n    // rect[i].second -> no. of values\n\n    lli ans = 0;\n    rect.push_back({0, 0}) ;\n\n    int max_big_freq;\n\n    int oper_cnt = 0;\n\n\n\n\n\n    for(int i=0; i<n; i++){\n        if( vec[i] > rect.back().first){\n            // new value is greater than all of current\n            // will be added\n            rect.push_back({vec[i], 0}) ;\n            oper_cnt++;\n        }\n        else{\n            // new value is less than of equal to greatest\n            max_big_freq = 0;\n            while(rect.back().first > vec[i]){\n                // pop the item at back\n                // check if it had by now formed greatest rectangle\n                max_big_freq = max(max_big_freq, rect.back().second) ;\n                ans = max(ans, rect.back().first * rect.back().second) ;\n                rect.pop_back();\n                oper_cnt++;\n            }\n\n            // now the last value of rect is <= vec[i]\n            if(rect.back().first < vec[i]){\n                // insert\n                rect.push_back({vec[i], max_big_freq}) ;\n                oper_cnt++;\n            }\n\n            \n        }\n        // increment all values by 1\n        for(pair<lli, int>& cur : rect){\n            cur.second ++ ;\n            oper_cnt++;\n        }\n    }\n\n    // at the end check for all present values\n    for(pair<lli, int>& cur : rect){\n        ans = max(ans, cur.first * cur.second) ;\n        oper_cnt++;\n    }\n\n    cout << \"oper_cnt == \" << oper_cnt << endl;\n\n    return ans;\n\n}\n\n    \n    int largestRectangleArea(vector<int>& h) {\n        vector<lli> v(h.size());  \n        for(int i=0; i<h.size(); i++){\n            v[i] = h[i];\n        }\n        \n        return max_rect_histogram(v);\n    }\n};\n```\n\nThis is an O(n^2) solution. It barely passes with runtime 2000ms.\nIt should not pass. \nSimple worst case where it would be O(n^2) is \n`[1,2,3,4.........10000]`"
                    },
                    {
                        "username": "neerajmsd7",
                        "content": "class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        /* int n = heights.size();\\n        stack<int> st;\\n        int leftHeight[n] , rightHeight[n];\\n        for(int i =0; i<n; i++){\\n        while(!st.empty() && heights[st.top()] >= heights[i]){\\n            st.pop();\\n        }\\n        if(st.empty()) leftHeight[i] = 0;\\n        else\\n        leftHeight[i] = st.top() +1;\\n        st.push(i);\\n        }\\n        while(!st.empty()) st.pop(); //redeclaring the same stack\\n        for(int i =n-1; i>=0; i--){\\n        while(!st.empty() && heights[st.top()] >= heights[i] ){\\n         st.pop();         \\n        }\\n        if(st.empty()) rightHeight[i] = n-1;\\n        else\\n        rightHeight[i] = st.top() - 1;\\n        st.push(i);\\n        }\\n    \\n    int maxA = 0;\\n    for(int i = 0; i<n; i++){\\n        maxA = max(maxA , heights[i]*(rightHeight[i] - leftHeight[i]+1));\\n    }\\n    return maxA;*/\\n    //this one is more optimized \\n    stack<int> st;\\n    int n = heights.size();\\n    int maxi =0;\\n    for(int i =0; i<=n; i++){\\n        while(!st.empty() && (i==n || (heights[st.top()] >= heights[i]))){\\n            int height  = heights[st.top()];\\n            st.pop();\\n            int width;\\n            if(st.empty()) width = i;\\n            else width = i - st.top() - 1;\\n            maxi = max(maxi , height * width);\\n\\n        }\\n        st.push(i);\\n    }\\n    return maxi;\\n    }\\n}; `your inline code...your inline code...`"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/largest-rectangle-in-histogram-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "rohanshirke00",
                        "content": " `\\n\\n// java simple solution using stacks data structure\\n\\nclass Solution {\\n    public int largestRectangleArea(int[] hist) {\\n\\n        // Nearest smallet to left\\n        int n = hist.length;\\n        int[] left = new int[n];\\n        Stack<Integer> st1 = new Stack<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(st1.size() == 0){\\n                left[i] = -1;\\n            }\\n            else if(st1.size() > 0 && hist[i] > hist[st1.peek()]){\\n                left[i] = st1.peek();\\n            }\\n            else if(st1.size() > 0 && hist[i] <= hist[st1.peek()]){\\n\\n                while ((st1.size() > 0) && (hist[i] <= hist[st1.peek()])) {\\n                    st1.pop();\\n                }\\n                if(st1.empty()){\\n                    left[i] = -1;\\n                }\\n                else{\\n                    left[i] = st1.peek();\\n                }\\n            \\n            }\\n            st1.push(i);\\n        }\\n        \\n        \\n        \\n        // nearest samllest to right\\n        int[] right = new int[n];\\n        Stack<Integer> st2 = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if(st2.size() == 0){\\n                right[i] = n;\\n            }\\n            else if(st2.size() > 0 && hist[i] > hist[st2.peek()]){\\n                right[i] = st2.peek();\\n            }\\n            else if(st2.size() > 0 && hist[i] <= hist[st2.peek()]){\\n                \\n                while ((st2.size() > 0) && (hist[i] <= hist[st2.peek()])) {\\n                    st2.pop();\\n                }\\n                if(st2.empty()){\\n                    right[i] = n;\\n                }\\n                else{\\n                    right[i] = st2.peek();\\n                }\\n                \\n            }\\n            st2.push(i);\\n        }\\n        \\n\\n        // // calculating width\\n        int[] width =  new int[n];\\n        for (int i = 0; i < width.length; i++) {    \\n            width[i] = right[i] - left[i] - 1;\\n        }\\n        \\n\\n\\n        // calulating maximum area for all hist\\n        int[] area = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < area.length; i++) {\\n            area[i] = width[i] * hist[i];\\n            max = area[i] > max ? area[i] : max;\\n        }\\n\\n        return max;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "user8007jJ",
                        "content": "Area of histogram: solution\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(vector<int> arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }\\n    \\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int newArea = l*b;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]