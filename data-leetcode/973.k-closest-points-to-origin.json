[
    {
        "title": "K Closest Points to Origin",
        "question_content": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., &radic;(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\n&nbsp;\nExample 1:\n\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\nExample 2:\n\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= points.length <= 104\n\t-104 <= xi, yi <= 104",
        "solutions": [
            {
                "id": 220235,
                "title": "java-three-solutions-to-this-classical-k-th-problem",
                "content": "This is a very classical problem, so-called K-th problem.\\nHere I will share some summaries and some classical solutions to this kind of problem.\\n\\n**I.** The very naive and simple solution is sorting the all points by their distance to the origin point directly, then get the top k closest points. We can use the sort function and the code is very short. \\n\\n**Theoretically**, the time complexity is **O(NlogN)**, **pratically**, the real time it takes on leetcode is **104ms**.\\n\\nThe **advantages** of this solution are **short**, intuitive and easy to implement.\\nThe **disadvatages** of this solution are not very efficient and have to know all of the points previously, and it is unable to deal with real-time(online) case, it is an **off-line** solution.\\n\\nThe short code shows as follows: \\n\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, (p1, p2) -> p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1]);\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n\\n\\n**II.** The second solution is based on the first one. We don\\'t have to sort all points.\\n\\tInstead, we can maintain a **max-heap** with size K. Then for each point, we add it to the heap. Once the size of the heap is greater than K, we are supposed to extract one from the max heap to ensure the size of the heap is always K. Thus, the max heap is always maintain top K smallest elements from the first one to crruent one. Once the size of the heap is over its maximum capacity, it will exclude the maximum element in it, since it can not be the proper candidate anymore.\\n\\t\\n**Theoretically**, the time complexity is **O(NlogK)**, but **pratically**, the real time it takes on leetcode is **134ms**. \\n\\nThe **advantage** of this solution is it can deal with **real-time(online) stream data**. It does not have to know the size of the data previously.\\nThe **disadvatage** of this solution is it is not the most efficient solution.\\n\\nThe short code shows as follows:\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((p1, p2) -> p2[0] * p2[0] + p2[1] * p2[1] - p1[0] * p1[0] - p1[1] * p1[1]);\\n        for (int[] p : points) {\\n            pq.offer(p);\\n            if (pq.size() > K) {\\n                pq.poll();\\n            }\\n        }\\n        int[][] res = new int[K][2];\\n        while (K > 0) {\\n            res[--K] = pq.poll();\\n        }\\n        return res;\\n    }\\n\\n**III.** The last solution is based on quick sort, we can also call it **quick select**. In the quick sort, we will always choose a pivot to compare with other elements. After one iteration, we will get an array that  all elements smaller than the pivot are on the left side of the pivot and all elements greater than the pivot are on the right side of the pviot (assuming we sort the array in ascending order). So, inspired from this, each iteration, we choose a pivot and then find the position **p** the pivot should be. Then we compare  **p** with the **K**, if the **p** is smaller than the **K**, meaning the all element on the left of the pivot are all proper candidates but it is not adequate, we have to do the same thing on right side, and vice versa. If the **p**  is exactly equal to the **K**, meaning that we\\'ve found the K-th position. Therefore, we just return the first K elements, since they are not greater than the pivot.\\n\\n**Theoretically**, the average time complexity is **O(N)** , but just like quick sort, in the worst case, this solution would be degenerated to **O(N^2)**, and **pratically**, the real time it takes on leetcode is **15ms**.\\n\\nThe **advantage** of this solution is it is very efficient.\\nThe **disadvatage** of this solution are it is neither an online solution nor a stable one. And the K elements closest are **not sorted** in ascending order.\\n\\nThe short code shows as follows:\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        int len =  points.length, l = 0, r = len - 1;\\n        while (l <= r) {\\n            int mid = helper(points, l, r);\\n            if (mid == K) break;\\n            if (mid < K) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n    \\n    private int helper(int[][] A, int l, int r) {\\n        int[] pivot = A[l];\\n        while (l < r) {\\n            while (l < r && compare(A[r], pivot) >= 0) r--;\\n            A[l] = A[r];\\n            while (l < r && compare(A[l], pivot) <= 0) l++;\\n            A[r] = A[l];\\n        }\\n        A[l] = pivot;\\n        return l;\\n    }\\n    \\n    private int compare(int[] p1, int[] p2) {\\n        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];\\n    }\\n",
                "solutionTags": [],
                "code": "This is a very classical problem, so-called K-th problem.\\nHere I will share some summaries and some classical solutions to this kind of problem.\\n\\n**I.** The very naive and simple solution is sorting the all points by their distance to the origin point directly, then get the top k closest points. We can use the sort function and the code is very short. \\n\\n**Theoretically**, the time complexity is **O(NlogN)**, **pratically**, the real time it takes on leetcode is **104ms**.\\n\\nThe **advantages** of this solution are **short**, intuitive and easy to implement.\\nThe **disadvatages** of this solution are not very efficient and have to know all of the points previously, and it is unable to deal with real-time(online) case, it is an **off-line** solution.\\n\\nThe short code shows as follows: \\n\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, (p1, p2) -> p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1]);\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n\\n\\n**II.** The second solution is based on the first one. We don\\'t have to sort all points.\\n\\tInstead, we can maintain a **max-heap** with size K. Then for each point, we add it to the heap. Once the size of the heap is greater than K, we are supposed to extract one from the max heap to ensure the size of the heap is always K. Thus, the max heap is always maintain top K smallest elements from the first one to crruent one. Once the size of the heap is over its maximum capacity, it will exclude the maximum element in it, since it can not be the proper candidate anymore.\\n\\t\\n**Theoretically**, the time complexity is **O(NlogK)**, but **pratically**, the real time it takes on leetcode is **134ms**. \\n\\nThe **advantage** of this solution is it can deal with **real-time(online) stream data**. It does not have to know the size of the data previously.\\nThe **disadvatage** of this solution is it is not the most efficient solution.\\n\\nThe short code shows as follows:\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((p1, p2) -> p2[0] * p2[0] + p2[1] * p2[1] - p1[0] * p1[0] - p1[1] * p1[1]);\\n        for (int[] p : points) {\\n            pq.offer(p);\\n            if (pq.size() > K) {\\n                pq.poll();\\n            }\\n        }\\n        int[][] res = new int[K][2];\\n        while (K > 0) {\\n            res[--K] = pq.poll();\\n        }\\n        return res;\\n    }\\n\\n**III.** The last solution is based on quick sort, we can also call it **quick select**. In the quick sort, we will always choose a pivot to compare with other elements. After one iteration, we will get an array that  all elements smaller than the pivot are on the left side of the pivot and all elements greater than the pivot are on the right side of the pviot (assuming we sort the array in ascending order). So, inspired from this, each iteration, we choose a pivot and then find the position **p** the pivot should be. Then we compare  **p** with the **K**, if the **p** is smaller than the **K**, meaning the all element on the left of the pivot are all proper candidates but it is not adequate, we have to do the same thing on right side, and vice versa. If the **p**  is exactly equal to the **K**, meaning that we\\'ve found the K-th position. Therefore, we just return the first K elements, since they are not greater than the pivot.\\n\\n**Theoretically**, the average time complexity is **O(N)** , but just like quick sort, in the worst case, this solution would be degenerated to **O(N^2)**, and **pratically**, the real time it takes on leetcode is **15ms**.\\n\\nThe **advantage** of this solution is it is very efficient.\\nThe **disadvatage** of this solution are it is neither an online solution nor a stable one. And the K elements closest are **not sorted** in ascending order.\\n\\nThe short code shows as follows:\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        int len =  points.length, l = 0, r = len - 1;\\n        while (l <= r) {\\n            int mid = helper(points, l, r);\\n            if (mid == K) break;\\n            if (mid < K) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n    \\n    private int helper(int[][] A, int l, int r) {\\n        int[] pivot = A[l];\\n        while (l < r) {\\n            while (l < r && compare(A[r], pivot) >= 0) r--;\\n            A[l] = A[r];\\n            while (l < r && compare(A[l], pivot) <= 0) l++;\\n            A[r] = A[l];\\n        }\\n        A[l] = pivot;\\n        return l;\\n    }\\n    \\n    private int compare(int[] p1, int[] p2) {\\n        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 294389,
                "title": "easy-to-read-python-min-heap-solution-beat-99-python-solutions",
                "content": "We keep a min heap of size K.\\nFor each item, we insert an item to our heap.\\nIf inserting an item makes heap size larger than k, then we immediately pop an item after inserting ( `heappushpop` ).\\n\\nRuntime: \\nInserting an item to a heap of size k take `O(logK)` time.\\nAnd we do this for each item points.\\nSo runtime is `O(N * logK)` where N is the length of `points`.\\n\\nSpace: O(K) for our heap.\\n```\\nimport heapq\\n\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        heap = []\\n        \\n        for (x, y) in points:\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, x, y))\\n            else:\\n                heapq.heappush(heap, (dist, x, y))\\n        \\n        return [(x,y) for (dist,x, y) in heap]\\n```\\n\\nI found it interesting that my solution ran much faster than \"Divide And Conquer\" solution under \"Solution\" tab which is supposed to run in O(N). \\nMine ran at 316ms while D&C solution ran at 536 ms.\\n\\nI am guessing that the D&C solution ran much slower than mine because it used recursions which would involved creating callstacks.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        heap = []\\n        \\n        for (x, y) in points:\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, x, y))\\n            else:\\n                heapq.heappush(heap, (dist, x, y))\\n        \\n        return [(x,y) for (dist,x, y) in heap]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221532,
                "title": "c-stl-quickselect-priority-queue-and-multiset",
                "content": "The simplest solution is to use `partial_sort` or `nth_element` to order the `K` closest points at the beginning of `points`. Here we need a custom comparator to compare the *closeness* of points. This solution is of `O(nlogK)` time. If we ignore the space of the output since that is inevitable, this solution is of `O(1)` space.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        partial_sort(points.begin(), points.begin() + K, points.end(), [](vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        });\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\n};\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        nth_element(points.begin(), points.begin() + K - 1, points.end(), [](vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        });\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\n};\\n```\\n\\nYou may also implement the underlying quickselect algorithm yourself.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        int l = 0, r = points.size() - 1;\\n        while (true) {\\n            int p = partition(points, l, r);\\n            if (p == K - 1) {\\n                break;\\n            }\\n            if (p < K - 1) {\\n                l = p + 1;\\n            } else {\\n                r = p - 1;\\n            }\\n        }\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\nprivate:\\n    bool farther(vector<int>& p, vector<int>& q) {\\n        return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n    }\\n    \\n    bool closer(vector<int>& p, vector<int>& q) {\\n        return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n    }\\n    \\n    int partition(vector<vector<int>>& points, int left, int right) {\\n        int pivot = left, l = left + 1, r = right;\\n        while (l <= r) {\\n            if (farther(points[l], points[pivot]) && closer(points[r], points[pivot])) {\\n                swap(points[l++], points[r--]);\\n            }\\n            if (!farther(points[l], points[pivot])) {\\n                l++;\\n            }\\n            if (!closer(points[r], points[pivot])) {\\n                r--;\\n            }\\n        }\\n        swap(points[pivot], points[r]);\\n        return r;\\n    }\\n};\\n```\\n\\nIf you would not like to modify `points`, you may maintain the `K` closest points so far in a separate data structure. We can use a **max** heap to maintain the `K` closest points. A max heap has its largest element in the root. Each time we add a point to the heap, if its size exceeds `K`, we pop the root, which means we get rid of the farthest point and keep the closest ones. This solution is also of `O(nlogK)` time.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        for (vector<int>& point : points) {\\n            pq.push(point);\\n            if (pq.size() > K) {\\n                pq.pop();\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while (!pq.empty()) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\\n\\nWe can also use a min heap. A min heap has the smallest element in the root. We add all the points to the heap, and then pop the first `K` ones, we are just the closest ones. This makes the code shorter. Now this one is of `O(n + Klogn)` time. The `n` part is on adding all points to the heap (building a min heap for all the points) and the `Klogn` part is on fetching the top `K` points from the heap.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq(points.begin(), points.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < K; i++) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\\n\\nNote that for `priority_queue`, if you would like to use it as a max heap, the comparator should be `<` and if as a min heap, the comparator is `>`.\\n\\nMax/min heaps can also be implemented using `multiset`. For `multiset`, max heap has `>` and min heap has `<` in the comparator. The following two solutions are respectively max/min heap using `multiset`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        multiset<vector<int>, compare> mset;\\n        for (vector<int>& point : points) {\\n            mset.insert(point);\\n            if (mset.size() > K) {\\n                mset.erase(mset.begin());\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        copy_n(mset.begin(), K, back_inserter(ans));\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) const {\\n            return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        multiset<vector<int>, compare> mset(points.begin(), points.end());\\n        vector<vector<int>> ans;\\n        copy_n(mset.begin(), K, back_inserter(ans));\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) const {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        partial_sort(points.begin(), points.begin() + K, points.end(), [](vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        });\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        nth_element(points.begin(), points.begin() + K - 1, points.end(), [](vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        });\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        int l = 0, r = points.size() - 1;\\n        while (true) {\\n            int p = partition(points, l, r);\\n            if (p == K - 1) {\\n                break;\\n            }\\n            if (p < K - 1) {\\n                l = p + 1;\\n            } else {\\n                r = p - 1;\\n            }\\n        }\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\nprivate:\\n    bool farther(vector<int>& p, vector<int>& q) {\\n        return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n    }\\n    \\n    bool closer(vector<int>& p, vector<int>& q) {\\n        return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n    }\\n    \\n    int partition(vector<vector<int>>& points, int left, int right) {\\n        int pivot = left, l = left + 1, r = right;\\n        while (l <= r) {\\n            if (farther(points[l], points[pivot]) && closer(points[r], points[pivot])) {\\n                swap(points[l++], points[r--]);\\n            }\\n            if (!farther(points[l], points[pivot])) {\\n                l++;\\n            }\\n            if (!closer(points[r], points[pivot])) {\\n                r--;\\n            }\\n        }\\n        swap(points[pivot], points[r]);\\n        return r;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        for (vector<int>& point : points) {\\n            pq.push(point);\\n            if (pq.size() > K) {\\n                pq.pop();\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while (!pq.empty()) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq(points.begin(), points.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < K; i++) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        multiset<vector<int>, compare> mset;\\n        for (vector<int>& point : points) {\\n            mset.insert(point);\\n            if (mset.size() > K) {\\n                mset.erase(mset.begin());\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        copy_n(mset.begin(), K, back_inserter(ans));\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) const {\\n            return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        multiset<vector<int>, compare> mset(points.begin(), points.end());\\n        vector<vector<int>> ans;\\n        copy_n(mset.begin(), K, back_inserter(ans));\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) const {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217999,
                "title": "java-c-python-o-n",
                "content": "**Java:**\\nSort all points and return `K` first, `O(NlogN)`\\n```java\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, Comparator.comparing(p -> p[0] * p[0] + p[1] * p[1]));\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n```\\n\\n**Python:**\\nSort using heap of size `K`, `O(NlogK)`\\n```cpp\\n    def kClosest(self, points, K):\\n        return heapq.nsmallest(K, points, lambda (x, y): x * x + y * y)\\n```\\n\\n**C++**\\n`O(N)` quick select\\n```cpp\\n    vector<vector<int>> kClosest(vector<vector<int>>& A, int K) {\\n        nth_element(A.begin(), A.begin() + K, A.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1];\\n        });\\n        return vector<vector<int>>(A.begin(), A.begin() + K);\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, Comparator.comparing(p -> p[0] * p[0] + p[1] * p[1]));\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n```\n```cpp\\n    def kClosest(self, points, K):\\n        return heapq.nsmallest(K, points, lambda (x, y): x * x + y * y)\\n```\n```cpp\\n    vector<vector<int>> kClosest(vector<vector<int>>& A, int K) {\\n        nth_element(A.begin(), A.begin() + K, A.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1];\\n        });\\n        return vector<vector<int>>(A.begin(), A.begin() + K);\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 576025,
                "title": "python-3-lines-knn-search-using-kd-tree-for-large-number-of-queries",
                "content": "Using a kd-tree to solve this problem is an overkill. However, it will be a nice approach for discussion if this follow up question comes up during interview.\\n**What if I have 10 million points now and I have to perform the search 10000 times? How would you optimize it?**\\n\\nLet\\'s first have a review of some solutions that we have already come across:\\n1. **Sorting - O(NlogN)**, since we need to sort the entire list of points\\n2. **Max Heap - O(NlogK)**, since we need to maintain a priority queue of size K and extract the closest K points with a bunch of heap push and pop\\n3. **Quick Select - O(N) on average**, a modified quick-sort like algorithm (proof of complexity not shown here)\\n\\nAs we can see, if we have `N=10000000` and we have to perform the search over a large number of times, even **O(N)** solution may seem to be inefficient in this extreme case.\\n\\nSo, what can we do? We can make use of a data structure called **kd-tree** which are particularly good at searching 2D (or 3D,...,KD) points in **logarithmic time**.\\nSince the points on the 2D planes aren\\'t going to change (in most cases) during the query, we can **prepocess** the points by constructing a kd-tree to store them for later queries.\\n\\nkd-tree has the following comeplexity:\\n1. **Build the tree - O(NlogN)**, building the tree requires presorting the points and find the medians (but we only need to do this once).\\n2. **Search, Insert, Delete - O(logN)**, similar to how a normal binary tree works (with a tree balancing mechanism)\\n\\nNow, as we can see, it greatly reduces the time complexity for each nearest neighbor query to **O(logN)**, and if we need to find the K closest points, the total complexity will be **O(KlogN)**. This is great if we have a lof of points and we are only interested in a few neighbors.\\n\\nCoding a kd-tree seems daunting and not feasible in a 45-min interviews. However, in Python, there is some data science library which allows you to build a tree and perform the search in just a few lines of code! Since interviewers typically don\\'t expect you to code an actual kd-tree, using the following code may not only show that you have insights of more advanced data structure, but also demostrate that you have practical experience implementing them with pre-existing libraries.\\n\\n```\\nfrom scipy import spatial\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        tree = spatial.KDTree(points)\\n\\t\\t# x is the origin, k is the number of closest neighbors, p=2 refers to choosing l2 norm (euclidean distance)\\n        distance, idx = tree.query(x=[0,0], k=K, p=2) \\n        return [points[i] for i in idx] if K > 1 else [points[idx]]\\n```\\n\\nReference: https://en.wikipedia.org/wiki/K-d_tree\\n",
                "solutionTags": [],
                "code": "```\\nfrom scipy import spatial\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        tree = spatial.KDTree(points)\\n\\t\\t# x is the origin, k is the number of closest neighbors, p=2 refers to choosing l2 norm (euclidean distance)\\n        distance, idx = tree.query(x=[0,0], k=K, p=2) \\n        return [points[i] for i in idx] if K > 1 else [points[idx]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647773,
                "title": "c-python-simple-solutions-w-explanation-sort-heap-randomized-quickselect-o-n",
                "content": "We are given array of points and we need to return `k` closest points to the origin.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Sort by Euclidean Distance)***\\n\\nWe can simply sort the points by their euclidean distance from the origin and select the 1st `k` points from the sorted array. For a slightly more efficient implementation, we can choose squared euclidean distance as a comparator while sorting instead of euclidean distance itself which would help avoid calculating `sqrt` everytime and not affect result either since if an euclidean distance `a > b`, then we will also have <code>a<sup>2</sup> > b<sup>2</sup></code>\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        sort(begin(P), end(P), [&](auto& a, auto& b) { return euclidean(a) < euclidean(b); });\\n        P.resize(k);\\n        return P;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        return sorted(P, key=lambda p: p[0]**2 + p[1]**2)[:k]\\n```\\n\\n***Time Complexity :*** `O(NlogN)`, where `N` is the number of elements in `P`. It is required for sorting\\n***Space Complexity :*** `O(sort)`, space used by in-built sort algorithms\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Max-Heap / Priority Queue)***\\n\\nA better solution would be to use max-heap solution. This would allow us iterate over array and to only maintain `k` elements in the heap. If it exceeds `k` element, we pop the largest element. At the end of iteration, we would only be left with `k` smallest elements (since we popped off larger distanced elements whenever number of elements in heap exceeded `k`).  \\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < size(P); i++) {\\n            pq.emplace(euclidean(P[i]), i);\\n            if(size(pq) > k) pq.pop();\\n        }\\n        vector<vector<int>> ans(k);\\n        for(int i = 0; i < k; i++) \\n            ans[i] = P[pq.top().second], pq.pop();\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        heap, euclidean = [], lambda x, y : x*x + y*y\\n        for i, (x, y) in enumerate(P):\\n            d = euclidean(x, y)\\n            if len(heap) == k:\\n                heappushpop(heap, (-d, i))     # -d to convert to max-heap (default is min)\\n            else: \\n                heappush(heap, (-d, i))\\n        return [P[i] for (_, i) in heap]\\n```\\n\\n***Time Complexity :*** `O(Nlogk)`, where `N` is the number of elements in the array and `k` is the number of closest elements we need to find. Since there are a max of `O(k)` elements at any point in the heap, the `push` and `pop` operation only take `O(logk)` and this happens `O(N)` times leading to total time complexity of `O(Nlogk)`\\n***Space Complexity :*** `O(k)`, for maintain heap\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Min-Heap)***\\n\\nAnother way to use heap would be to construct a min-heap and pop the min elements `k` times. \\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        auto comp = [&](auto& a, auto& b) { return euclidean(a) > euclidean(b); };\\n        make_heap(begin(P), end(P), comp);\\n        \\n        vector<vector<int>> ans(k);\\n        for(int i = 0; i < k; i++) {\\n            ans[i] = P[0];\\n            pop_heap(begin(P), end(P), comp);\\n            P.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nor even like this -\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        auto comp = [&](auto& a, auto& b) { return euclidean(a) > euclidean(b); };\\n        make_heap(begin(P), end(P), comp);\\n        \\n        for(int i = 0; i < k; i++) \\n            pop_heap(begin(P), end(P)-i, comp);\\n\\n        return vector<vector<int>>(begin(P)+size(P)-k, end(P));\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        euclidean = lambda x, y : x*x + y*y\\n        for p in P:\\n            p.insert(0, euclidean(p[0], p[1]))\\n        heapify(P)\\n        return [heappop(P)[1:] for i in range(k)]\\n```\\n\\n***Time Complexity :*** `O(N + klogN)`, constructing the heap from given array of points `P` can be done in `O(N)` time. Then each heap pop operation would take `O(logN)` time which will be called for `k` times. Thus overall time will be `O(N + klogN)`\\n***Space Complexity :*** `O(1)`, we are doing it in-place. If input modification is not allowed, use a copy of `P` and that would take `O(N)` space\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Randomized QuickSelect)***\\n\\nThis solution is a modifed version of Quick-sort meant to be used when we need to find k(or kth) smallest(or largest) elements (based on some comparator) but not in any particular order. Most of the partition logic used in this algorithm remains the same as in quicksort but we just modify the recursive part of quicksort to suit our use case.\\n\\nEach time, we choose a pivot and partition the array around that pivot using a comparator. In this case, we will choose a randomized pivot (the choice of pivot majorly affects the performace of algorithm and we need to try to choose a pivot that partitions the range roughly equally for best result. Without any knowledge of the way that elements occur in array, it\\'s best to choose randomized pivot each time to avoid worst case) and for comparator, we will use the squared euclidean distance.\\n\\nInitially we start with whole range of array `[L, R] = [0, size(P)-1]`. After each partition, the `partition` function will return the pivot index (denoted as `p` below) which is basically the element which separates all the elements <= than it to left side and all elements > than it to the right side (not in particular order). We have:\\n* If `p < k`, then we now have `p` elements which are closest to origin (although they aren\\'t sorted in any particular order) but we still need some more elements to get `k` points in total. Thus, we iterate again and partition the array from indices `[p+1, R]` till we find `k` elements (by getting pivot at `k`th index)\\n* If `p > k`, then we now have more than `k` elements with us that are closest to origin. But we are sure that any element to the right of `p` wont be ever in our answer. So we iterate again and partition just the range `[L, p-1]` till we find `k` elements\\n* If `p == k`, we now have exactly `k` elements with us which are closest to origin. Thus,  we return the 1st `k` elements of array\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        int L = 0, R = size(P)-1, p = size(P);\\n        while(p != k) {\\n            p = partition(P, L, R);\\n            if(p < k)   L = p + 1;\\n            else        R = p - 1;\\n        }\\n        P.resize(k);\\n        return P;\\n    }\\n\\t// randomized partition algorithm similar to the one used in quicksort\\n    int partition(vector<vector<int>>& P, int L, int R) {\\n\\t\\tauto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        srand(time(0));\\n        swap(P[R], P[L + rand() % (R-L+1)]);       // choose a random pivot and swap with last element. Then partition with last element as pivot\\n        int i = L, pivotDist = euclidean(P[R]);\\n        for(int j = L; j <= R; j++) \\n            if(euclidean(P[j]) <= pivotDist)       // move all points having less distance to the left\\n                swap(P[i++], P[j]);\\n        return i-1;                                // returns final position of pivot after partition\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        euclidean = lambda p : p[0]**2 + p[1]**2\\n        def partition(L, R):\\n            random = randint(L, R)                 # choosing random pivot\\n            P[R], P[random] = P[random], P[R]      # and swapping it to the end\\n            i, pivotDist = L, euclidean(P[R])\\n            for j in range(L, R+1):\\n                if euclidean(P[j]) <= pivotDist:\\n                    P[i], P[j] = P[j], P[i]\\n                    i += 1\\n            return i-1\\n        \\n        L, R, p = 0, len(P)-1, len(P)\\n        while p != k:\\n            p = partition(L, R)\\n            if p < k:   L = p + 1\\n            else    :   R = p - 1\\n        return P[:k]\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, at each partition, we are eliminating one end and re-partitioning the other end till we get pivot at `k`th index. On average, the partitions  roughly eliminate half of remaining elements each time thus leading to `N + N/2 + N/4 + ... + 1 = O(2N)` iterations. However, in the worst case, there\\'s still a chance (although very low) that we choose the worst pivot at each partition and this leads to <code>N + N-1 + N-2 + ... + 1 = N<sup>2</sup></code> total iterations leading to time complexity of <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`, only constant extra space is being used\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (nth_element)***\\n\\nThe same functionality as above is provided by an built-in STL method in C++: **[`std::nth_element`](https://en.cppreference.com/w/cpp/algorithm/nth_element)**. The array is rearranged in a way that nth element would occur at position same as if array was sorted and all elements before it are less than or equal (based on provided comparator) to elements after nth element.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p){return p[0] * p[0] + p[1] * p[1];};\\n        nth_element(begin(P), begin(P)+k, end(P), [&](auto& a, auto& b) { return euclidean(a) < euclidean(b); });\\n        P.resize(k);\\n        return P;\\n    }\\n};\\n```\\n\\n\\n***Time Complexity :*** `O(N)`, same as above\\n***Space Complexity :*** `O(1)`, same as above\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        sort(begin(P), end(P), [&](auto& a, auto& b) { return euclidean(a) < euclidean(b); });\\n        P.resize(k);\\n        return P;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        return sorted(P, key=lambda p: p[0]**2 + p[1]**2)[:k]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < size(P); i++) {\\n            pq.emplace(euclidean(P[i]), i);\\n            if(size(pq) > k) pq.pop();\\n        }\\n        vector<vector<int>> ans(k);\\n        for(int i = 0; i < k; i++) \\n            ans[i] = P[pq.top().second], pq.pop();\\n        \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        heap, euclidean = [], lambda x, y : x*x + y*y\\n        for i, (x, y) in enumerate(P):\\n            d = euclidean(x, y)\\n            if len(heap) == k:\\n                heappushpop(heap, (-d, i))     # -d to convert to max-heap (default is min)\\n            else: \\n                heappush(heap, (-d, i))\\n        return [P[i] for (_, i) in heap]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        auto comp = [&](auto& a, auto& b) { return euclidean(a) > euclidean(b); };\\n        make_heap(begin(P), end(P), comp);\\n        \\n        vector<vector<int>> ans(k);\\n        for(int i = 0; i < k; i++) {\\n            ans[i] = P[0];\\n            pop_heap(begin(P), end(P), comp);\\n            P.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        auto comp = [&](auto& a, auto& b) { return euclidean(a) > euclidean(b); };\\n        make_heap(begin(P), end(P), comp);\\n        \\n        for(int i = 0; i < k; i++) \\n            pop_heap(begin(P), end(P)-i, comp);\\n\\n        return vector<vector<int>>(begin(P)+size(P)-k, end(P));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        euclidean = lambda x, y : x*x + y*y\\n        for p in P:\\n            p.insert(0, euclidean(p[0], p[1]))\\n        heapify(P)\\n        return [heappop(P)[1:] for i in range(k)]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        int L = 0, R = size(P)-1, p = size(P);\\n        while(p != k) {\\n            p = partition(P, L, R);\\n            if(p < k)   L = p + 1;\\n            else        R = p - 1;\\n        }\\n        P.resize(k);\\n        return P;\\n    }\\n\\t// randomized partition algorithm similar to the one used in quicksort\\n    int partition(vector<vector<int>>& P, int L, int R) {\\n\\t\\tauto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        srand(time(0));\\n        swap(P[R], P[L + rand() % (R-L+1)]);       // choose a random pivot and swap with last element. Then partition with last element as pivot\\n        int i = L, pivotDist = euclidean(P[R]);\\n        for(int j = L; j <= R; j++) \\n            if(euclidean(P[j]) <= pivotDist)       // move all points having less distance to the left\\n                swap(P[i++], P[j]);\\n        return i-1;                                // returns final position of pivot after partition\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        euclidean = lambda p : p[0]**2 + p[1]**2\\n        def partition(L, R):\\n            random = randint(L, R)                 # choosing random pivot\\n            P[R], P[random] = P[random], P[R]      # and swapping it to the end\\n            i, pivotDist = L, euclidean(P[R])\\n            for j in range(L, R+1):\\n                if euclidean(P[j]) <= pivotDist:\\n                    P[i], P[j] = P[j], P[i]\\n                    i += 1\\n            return i-1\\n        \\n        L, R, p = 0, len(P)-1, len(P)\\n        while p != k:\\n            p = partition(L, R)\\n            if p < k:   L = p + 1\\n            else    :   R = p - 1\\n        return P[:k]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p){return p[0] * p[0] + p[1] * p[1];};\\n        nth_element(begin(P), begin(P)+k, end(P), [&](auto& a, auto& b) { return euclidean(a) < euclidean(b); });\\n        P.resize(k);\\n        return P;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647428,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations",
                "content": "# **This are the reasons behind why we should not to use Sort function, minHeap and why we should use a maxHeap .**\\n\\n\\nThe basic gist of the question is that we need to find the k closest point from the origin . \\n**Intuition :-**\\n* The intuition we all got at first was to sort the points in increasing order and just do the math. But this is not a viable solution, i believe this the worst solution beacause let\\'s think of a scenerio were there will be streaming of online data. Everytime a new data[points] comes, we need to sort the entire inputs till that point and since it\\'s online we all know how much data could have been there in just one sec .\\n* So a good solution can be a heap approach. To be specific a maxheap since in minheap It will store all the array elements and this can be costly for large elemented arrays while in maxheap we just need to store k elements.\\n\\n***ALWAYS REMEMBER* :-*Whenever a question asks for k closest or k smallest or k largest it\\'s a heap question .Though these questions might be implemented using other algorithms as well but heap will allow to simplify the problem as well as code and your code will have a achievement unlocked known as erorr resistnace , lol.***\\n\\n\\n\\n**Before starting with algo let\\'s take a example from the description of this question:-**\\n```\\nInput: points = [[1,3],[-2,2]], k = 1\\n\\nThe way to judge whether a point is close or not is to find the euclidean distance.\\nwe dont have to perform square root and make the code look complex moreover it\\'s more prone to errors . we can simply just use `dist = x*x+y*y`\\n\\nNow let\\'s calculate the distance:\\n\\ndist = 1*1 + 3*3 = 10\\ndist = -2*-2 + 2*2 = 8\\n\\nWe can see that dist of the 2nd element is smaller so we need to pushback that element into our result vector.\\n```\\n\\n**Algorithm:-**\\n1. Initialize a priority queue for storing the maxheap data. let\\'s name this as `maxHeap` and initialize a `result` vector .\\n2. let `x` and `y` be the co-ordinates of point `p` .\\n3. Main logic behind maxHeap is that, we will maintain a maxHeap of size k Thus after addding new points to our maxHeap we need to check the size of heap if it is greater than k or not .If the size is greater than k we will remove remove the root element  to ensure the size of the heap is always k . Thus, the max heap is always maintain top K smallest elements from the first one to current one. \\n4. In short The maxheap will show true potential once the size of the heap is over its maximum capacity i.e it will exclude the maximum element in it as it can not be the proper candidate anymore.\\n\\n**Code:-**\\n```\\n//Upvote and Comment\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n         //Answer vector\\n        vector<vector<int>> result(k);\\n        //maxheap storage initialization\\n        priority_queue<vector<int>> maxHeap;\\n        //Construction of maxheap\\n        for (auto& p : points) {\\n            int x = p[0], y = p[1];\\n            maxHeap.push({x*x + y*y, x, y});\\n            if (maxHeap.size() > k) {\\n                maxHeap.pop();\\n            }\\n        }\\n        \\n        for (int i = 0; i < k; ++i) {\\n            vector<int> top = maxHeap.top();\\n            maxHeap.pop();\\n            result[i] = {top[1], top[2]};\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Time Complexity:-** *`O(NlogK)`*\\n**Space Complexity:-** *`O(K) [Since in maxheap we will be maintaining just k elements]`*\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n.......Continuation from previous posts ...\\nAfter yomru reached to the east end, he saw a text in black, the text was \\'ALL SPECIES...\\' . Meanwhile Doggo, Dogelina and JThree also reached their ending location .All of them saw some texts . Doggo saw the text saying \\'POTENTIAL,..\\' ,Dogelina saw the text saying \\'SHOULD HAVE EQUAL....\\' and JThree saw the text saying \\'THE QUICK BROWN FOX JUMPS OVER A LAZY DOG \\'. After seeing all this text\\'s which were located at all four diections. All of them took a picture of their respective texts . When JThree was clicking the picture of the text because of the flash of camera a new text appeared which was \\'  ~ ! @ # $ % ^ & * ( _ ) + = - { : > } ? | \\\\ ; \\' , . ]  \\' ..\\nTo be continued in the next post........\\n\\n**Feel free to comment or upvote if you liked my post**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nInput: points = [[1,3],[-2,2]], k = 1\\n\\nThe way to judge whether a point is close or not is to find the euclidean distance.\\nwe dont have to perform square root and make the code look complex moreover it\\'s more prone to errors . we can simply just use `dist = x*x+y*y`\\n\\nNow let\\'s calculate the distance:\\n\\ndist = 1*1 + 3*3 = 10\\ndist = -2*-2 + 2*2 = 8\\n\\nWe can see that dist of the 2nd element is smaller so we need to pushback that element into our result vector.\\n```\n```\\n//Upvote and Comment\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n         //Answer vector\\n        vector<vector<int>> result(k);\\n        //maxheap storage initialization\\n        priority_queue<vector<int>> maxHeap;\\n        //Construction of maxheap\\n        for (auto& p : points) {\\n            int x = p[0], y = p[1];\\n            maxHeap.push({x*x + y*y, x, y});\\n            if (maxHeap.size() > k) {\\n                maxHeap.pop();\\n            }\\n        }\\n        \\n        for (int i = 0; i < k; ++i) {\\n            vector<int> top = maxHeap.top();\\n            maxHeap.pop();\\n            result[i] = {top[1], top[2]};\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219442,
                "title": "python-with-quicksort-algorithm",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        self.sort(points, 0, len(points)-1, K)\\n        return points[:K]\\n    \\n    def sort(self, points, l, r, K):\\n        if l < r:\\n            p = self.partition(points, l, r)\\n            if p == K:\\n                return\\n            elif p < K:\\n                self.sort(points, p+1, r, K)\\n            else:\\n                self.sort(points, l, p-1, K)\\n            \\n    def partition(self, points, l, r):\\n        pivot = points[r]\\n        a = l\\n        for i in range(l, r):\\n            if (points[i][0]**2 + points[i][1]**2) <= (pivot[0]**2 + pivot[1]**2):\\n                points[a], points[i] = points[i], points[a]\\n                a += 1\\n        points[a], points[r] = points[r], points[a]                \\n        return a\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        self.sort(points, 0, len(points)-1, K)\\n        return points[:K]\\n    \\n    def sort(self, points, l, r, K):\\n        if l < r:\\n            p = self.partition(points, l, r)\\n            if p == K:\\n                return\\n            elif p < K:\\n                self.sort(points, p+1, r, K)\\n            else:\\n                self.sort(points, l, p-1, K)\\n            \\n    def partition(self, points, l, r):\\n        pivot = points[r]\\n        a = l\\n        for i in range(l, r):\\n            if (points[i][0]**2 + points[i][1]**2) <= (pivot[0]**2 + pivot[1]**2):\\n                points[a], points[i] = points[i], points[a]\\n                a += 1\\n        points[a], points[r] = points[r], points[a]                \\n        return a\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 660317,
                "title": "c-java-python-2-solutions-max-heap-minheap-clean-code-o-nlogk",
                "content": "**\\u2714\\uFE0F Solution 1: Max Heap**\\n- Same problem: **[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1349609)**.\\n- We use `maxHeap` to keep `k` smallest elements in array `n` elements. In the max heap, the top is the max element of the heap and it costs in `O(1)` in time complexity. By using max heap, we can remove `(n-k)` largest elements and keep `k` smallest elements in array.\\n\\n<iframe src=\"https://leetcode.com/playground/LjhEydzH/shared\" frameBorder=\"0\" width=\"100%\" height=\"410\"></iframe>\\n\\n**Complexity**\\n- Time: `O(NlogK)`, where `N <= 10^4` is number of points.\\n- Extra Space (don\\'t count output as space): `O(K)`, it\\'s size of maxHeap.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Min Heap**\\n- Same problem: **[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1349609)**.\\n\\n<iframe src=\"https://leetcode.com/playground/CpasNhUz/shared\" frameBorder=\"0\" width=\"100%\" height=\"440\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N + KlogN)`, where `N <= 10^4` is number of points.\\n- Extra Space (don\\'t count output as space): `O(N)`.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Max Heap**\\n- Same problem: **[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1349609)**.\\n- We use `maxHeap` to keep `k` smallest elements in array `n` elements. In the max heap, the top is the max element of the heap and it costs in `O(1)` in time complexity. By using max heap, we can remove `(n-k)` largest elements and keep `k` smallest elements in array.\\n\\n<iframe src=\"https://leetcode.com/playground/LjhEydzH/shared\" frameBorder=\"0\" width=\"100%\" height=\"410\"></iframe>\\n\\n**Complexity**\\n- Time: `O(NlogK)`, where `N <= 10^4` is number of points.\\n- Extra Space (don\\'t count output as space): `O(K)`, it\\'s size of maxHeap.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Min Heap**\\n- Same problem: **[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1349609)**.\\n\\n<iframe src=\"https://leetcode.com/playground/CpasNhUz/shared\" frameBorder=\"0\" width=\"100%\" height=\"440\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N + KlogN)`, where `N <= 10^4` is number of points.\\n- Extra Space (don\\'t count output as space): `O(N)`.",
                "codeTag": "Unknown"
            },
            {
                "id": 348171,
                "title": "python3-sort-o-nlogn-minimum-heap-o-nlogn-and-maximum-heap-o-nlogk",
                "content": "*  Time complexity: O(NlogN)\\n\\tSort the list according to the distance to origin.  Apparently, we did more than the question asked. We sorted all the distance, the question only ask for top k. To improve time complexity, we need to think about how to get we ask without extra effort. This is where heap data structure comes in.\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        points.sort(key = lambda P:P[0]**2+P[1]**2)\\n        return points[:K]\\n```\\n\\n\\n* Time complexity: O(nlogn), intuitively use minimum Heap:\\n\\t1. make a maximum-heap to store distance, (point\\'s distance to original, point)\\n\\t2. each time call heapq.heappop (distance), it will pop the smallest item in the heap. So heappop K times will be the result.\\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        distance = []\\n        for i in points:\\n            heapq.heappush(distance,(i[0]**2+i[1]**2,i))\\n        K_points = []\\n        for i in range(K):\\n            K_points.append(heapq.heappop(distance)[1])\\n        return K_points\\n```\\n* \\tAs we can see here, we used heap, but the problem is we still sorted all the element, the time complexity is O(NlogN) .Still we only need the top k smallest element. We don\\'t need to take of other elements\\' order. So if we keep a size of k\\'s heap,  use the heap[0] element as threshhold, interate through the array, only those meet the requirment element get into the heap. \\n```\\n[1,5,3,4,10]  k = 3\\n\\ncur = 1\\nmaximum heap = [1]\\ncur =5 \\nmaximum heap = [5,1]\\ncur = 3 \\nmaximum heap = [5,3,1]\\ncur = 4 peek = 5\\ncur < peek:\\n\\tmaximum heap. pop\\n\\tmaximum heap = [3,1]\\n\\tmaximum heap.push(4)\\n\\tmaximum heap = [4,3,1]\\ncur = 10 peek = 4\\ncur > peek:\\n\\tmaximum heap = [4,3,1]\\n## python 3 doesn\\'t have maximum heap pop to the best of my knowledge.\\n```\\n* Time compiexity: O(NlogK)\\n\\tSince python3 doesn\\'t have a build-in maximum heap, so I use the minimum heap to achieve maximum heap\\'s property as shown above. Here, we keep a heap with size of K. So we can improve the time complexity to O(NlogK).\\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        distance = []\\n        for p in points:\\n            if len(distance) <= K-1:\\n                heapq.heappush(distance,(-p[0]**2-p[1]**2,p))\\n            else:\\n                if -p[0]**2-p[1]**2 > distance[0][0]:\\n                    heapq.heappop(distance)\\n                    heapq.heappush(distance,(-p[0]**2-p[1]**2,p))\\n        res = []\\n        for i in range (K):\\n            res.append(heapq.heappop(distance)[1])\\n        return res\\n```\\n\\tTime compiexity: O(NlogK)\\n\\theapq is a binary heap, with O(log n) push and O(log n) pop. n is the size of the minimum heap. In this case, n = K.\\n\\tSo the time complexit is Nlog(K)\\n\\t\\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        h = []\\n        for p in points:\\n            if len(h) <= K-1:\\n                heapq.heappush(h,(-p[0]**2-p[1]**2,p))\\n            else:\\n                if -p[0]**2-p[1]**2 > h[0][0]:\\n                    heapq.heapreplace(h,(-p[0]**2-p[1]**2,p))\\n        res = []\\n        for i in range(K):\\n            res.append(heapq.heappop(h)[1])\\n        return res\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        points.sort(key = lambda P:P[0]**2+P[1]**2)\\n        return points[:K]\\n```\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        distance = []\\n        for i in points:\\n            heapq.heappush(distance,(i[0]**2+i[1]**2,i))\\n        K_points = []\\n        for i in range(K):\\n            K_points.append(heapq.heappop(distance)[1])\\n        return K_points\\n```\n```\\n[1,5,3,4,10]  k = 3\\n\\ncur = 1\\nmaximum heap = [1]\\ncur =5 \\nmaximum heap = [5,1]\\ncur = 3 \\nmaximum heap = [5,3,1]\\ncur = 4 peek = 5\\ncur < peek:\\n\\tmaximum heap. pop\\n\\tmaximum heap = [3,1]\\n\\tmaximum heap.push(4)\\n\\tmaximum heap = [4,3,1]\\ncur = 10 peek = 4\\ncur > peek:\\n\\tmaximum heap = [4,3,1]\\n## python 3 doesn\\'t have maximum heap pop to the best of my knowledge.\\n```\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        distance = []\\n        for p in points:\\n            if len(distance) <= K-1:\\n                heapq.heappush(distance,(-p[0]**2-p[1]**2,p))\\n            else:\\n                if -p[0]**2-p[1]**2 > distance[0][0]:\\n                    heapq.heappop(distance)\\n                    heapq.heappush(distance,(-p[0]**2-p[1]**2,p))\\n        res = []\\n        for i in range (K):\\n            res.append(heapq.heappop(distance)[1])\\n        return res\\n```\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        h = []\\n        for p in points:\\n            if len(h) <= K-1:\\n                heapq.heappush(h,(-p[0]**2-p[1]**2,p))\\n            else:\\n                if -p[0]**2-p[1]**2 > h[0][0]:\\n                    heapq.heapreplace(h,(-p[0]**2-p[1]**2,p))\\n        res = []\\n        for i in range(K):\\n            res.append(heapq.heappop(h)[1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217966,
                "title": "c-3-lines-nth-element-o-n",
                "content": "Here, I am showing four solutions:\\n1. Na\\xEFve sorting solution, O(n log n)\\n2. Short and efficient O(n) solution using ```nth_element``` <-- recommended\\n3. Simple implementation of ```quickselect```, with O(n) *average case* complexity\\n4. Improved ```quickselect``` with O(n) *worst case* complexity\\n\\n# Solution 1: Sorting\\nWe can just sort our points by the distance using a multimap (value is the index in the input array). Then we can take K first elements from the multimap and build the result vector.\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  multimap<int, int> m;\\n  for (int i = 0; i < ps.size(); ++i)\\n    m.insert({ ps[i][0] * ps[i][0] + ps[i][1] * ps[i][1], i });\\n  vector<vector<int>> res;\\n  for (auto it = m.begin(); K > 0; ++it, --K) res.push_back(ps[it->second]);\\n  return res;\\n}\\n```\\n# Solution 2: nth_element\\nHowever, multimap sorts all elements, and what we need is just re-arrange elements so that none of the elements preceding Kth are greater than it, and none of the elements following it are less. To accomplish this, we could use ```partial_sort``` or ```nth_element``` functions, and the latter is better suited for this problem as we do not care about the order of the returning elements.\\n\\nThe ```nth_element``` function is typically implemented using [Introselect](https://en.wikipedia.org/wiki/Introselect), which brings the *average* complexity down to O(n).\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  nth_element(begin(ps), begin(ps) + K, end(ps), [](vector<int> &a, vector<int> &b) {\\n      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];\\n  });\\n  ps.resize(K);\\n  return ps;\\n}\\n```\\n# Solution 3: Quickselect\\nIf you don\\'t want to use the library function, below is a sample implementation using [quickselect](https://en.wikipedia.org/wiki/Quickselect). I implemented it in a generic way to keep the same signature as for ```nth_element```. You can have a simpler implementation without using generics, like [Approach 2: Divide and Conquer](https://leetcode.com/problems/k-closest-points-to-origin/solution/).\\n\\nFor this implementation, we use the last element as a pivot. This gives us *average* O(n) complexity.\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  quickselect(begin(ps), end(ps), K, [](vector<int> &a, vector<int> &b) {\\n      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];\\n  });\\n  ps.resize(K);\\n  return ps;\\n}\\ntemplate<class RndIt, class Compare> void quickselect(RndIt first, RndIt end, int K, Compare cmp) {\\n  auto p = partition(first, end, cmp);\\n  if (p - first + 1 == K) return;\\n  if (p - first + 1 < K) \\n      quickselect(p + 1, end, K - (p - first + 1), cmp);\\n  else \\n      quickselect(first, p, K, cmp);\\n}\\ntemplate<class RndIt, class Compare> RndIt partition(RndIt first, RndIt end, Compare cmp) {\\n  auto last = next(end, -1);\\n  auto pivot = *last;\\n  while (first < last) {\\n    while (cmp(*first, pivot))\\n        ++first;\\n    while (cmp(pivot, *last)) \\n        --last;\\n    if (first < last) {\\n        swap(*first, *last);\\n        if (!cmp(*first, *last))\\n            --last;\\n    }\\n  }\\n  return first;\\n}\\n```\\n# Solution 4: Improved quickselect\\nIn the previsou solution, we used the last element as a pivot. It\\'s a simple approach, but in the worst case the runtime can be O(n * n). To combat that, we coluld use the [median-of-median](https://en.wikipedia.org/wiki/Median_of_medians) method to pick our pivot.",
                "solutionTags": [],
                "code": "```nth_element```\n```quickselect```\n```quickselect```\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  multimap<int, int> m;\\n  for (int i = 0; i < ps.size(); ++i)\\n    m.insert({ ps[i][0] * ps[i][0] + ps[i][1] * ps[i][1], i });\\n  vector<vector<int>> res;\\n  for (auto it = m.begin(); K > 0; ++it, --K) res.push_back(ps[it->second]);\\n  return res;\\n}\\n```\n```partial_sort```\n```nth_element```\n```nth_element```\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  nth_element(begin(ps), begin(ps) + K, end(ps), [](vector<int> &a, vector<int> &b) {\\n      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];\\n  });\\n  ps.resize(K);\\n  return ps;\\n}\\n```\n```nth_element```\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  quickselect(begin(ps), end(ps), K, [](vector<int> &a, vector<int> &b) {\\n      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];\\n  });\\n  ps.resize(K);\\n  return ps;\\n}\\ntemplate<class RndIt, class Compare> void quickselect(RndIt first, RndIt end, int K, Compare cmp) {\\n  auto p = partition(first, end, cmp);\\n  if (p - first + 1 == K) return;\\n  if (p - first + 1 < K) \\n      quickselect(p + 1, end, K - (p - first + 1), cmp);\\n  else \\n      quickselect(first, p, K, cmp);\\n}\\ntemplate<class RndIt, class Compare> RndIt partition(RndIt first, RndIt end, Compare cmp) {\\n  auto last = next(end, -1);\\n  auto pivot = *last;\\n  while (first < last) {\\n    while (cmp(*first, pivot))\\n        ++first;\\n    while (cmp(pivot, *last)) \\n        --last;\\n    if (first < last) {\\n        swap(*first, *last);\\n        if (!cmp(*first, *last))\\n            --last;\\n    }\\n  }\\n  return first;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762781,
                "title": "javascript-sort-minheap-and-maxheap-solutions",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\n/*\\nsort approach:\\n- need to compute all distances, we can just omit the sqrt and just do x^2 + y^2\\n- need to sort by the distance: best: n log(n)\\n- do quicksort with a custom sorting function, then take the first k elements from the array\\nruntime: O(N log(N))\\nspace: O(1)\\n*/\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1]))\\n\\n    return points.slice(0,K)\\n};\\n\\n/*\\nmin heap approach:\\nwe can create a minHeap of the whole data set in O(n) time if we start from n/2 and heapify down each parent (see floyd method https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap)\\n\\nthen we remove k times from the heap -> k * log(n) (need to heapify down on each removal)\\nruntime: O(N + k log (N))\\nspace: O(1) since we are doing it in place\\n*/\\nvar kClosest = function(points, k) {\\n    // we can build the heap in place\\n    let p = Math.floor((points.length - 2) / 2) // last parent\\n    for(let i = p; i >= 0; i--) {\\n        heapifyDown(points, i, distance)\\n    }\\n    \\n    // now we need to remove the smallest (points[0]) k times\\n    let solution = []\\n    for(let i=0; i<k; i++) {\\n        solution.push(remove(points, distance))\\n    }\\n    \\n    return solution\\n    \\n    // read 0, replace 0 with last position, heapifyDown\\n    function remove(heap, weightFunction) {\\n        let val = heap[0]\\n        heap[0] = heap.pop()\\n        heapifyDown(heap, 0, weightFunction)\\n        return val\\n    }\\n    \\n    // compare with children, swap with smallest, repeat\\n    function heapifyDown(heap, idx, weightFunction) {\\n        let left = 2*idx + 1\\n        let right = 2*idx + 2\\n        let smallest = left\\n        \\n        if(left >= heap.length) return\\n        \\n        if(right < heap.length && weightFunction(heap[left]) > weightFunction(heap[right])) {\\n            smallest = right\\n        }\\n        \\n        if (weightFunction(heap[idx]) > weightFunction(heap[smallest])) {\\n            [heap[idx], heap[smallest]] = [heap[smallest], heap[idx]]\\n            heapifyDown(heap, smallest, weightFunction)\\n        }\\n    }\\n    \\n    function distance(point) {\\n        return point[0] * point[0] + point[1] * point[1]\\n    }\\n}\\n\\n\\n/*\\nmax heap approach:\\nhave a max heap of size k, so we would do N insertions that take log(k)\\nfor this case we would need to implement heapify up (insert) and heapify down (remove)\\n\\nruntime: O(N log(k))\\nspace: O(k)\\n*/\\nvar kClosest = function(points, k) {\\n    let heap = []\\n    \\n    // now we need to try to add all points to the heap\\n    for(let i=0; i<points.length; i++) {\\n        if(heap.length >= k && distance(points[i]) > distance(heap[0])) { // it\\'s bigger than the max, we can just skip it\\n            continue\\n        }\\n        add(heap, points[i], distance)\\n        if(heap.length > k) {\\n            remove(heap, distance)\\n        }\\n    }\\n    \\n    return heap\\n    \\n    // add at end, heapify up\\n    function add(heap, node, weightFunction) {\\n        heap.push(node)\\n        heapifyUp(heap, heap.length - 1, weightFunction)\\n    }\\n    \\n    // compare with parent and swap if needed, repeat\\n    function heapifyUp(heap, idx, weightFunction) {\\n        if(idx === 0) return\\n        let parent = Math.floor((idx-1) / 2)\\n        if(weightFunction(heap[idx]) > weightFunction(heap[parent])) {\\n            [heap[idx], heap[parent]] = [heap[parent], heap[idx]]\\n            heapifyUp(heap, parent, weightFunction)\\n        }\\n    }\\n    \\n    // read 0, replace 0 with last position, heapifyDown\\n    function remove(heap, weightFunction) {\\n        let val = heap[0]\\n        heap[0] = heap.pop()\\n        heapifyDown(heap, 0, weightFunction)\\n        return val\\n    }\\n    \\n    // compare with children, swap with biggest, repeat\\n    function heapifyDown(heap, idx, weightFunction) {\\n        let left = 2*idx + 1\\n        let right = 2*idx + 2\\n        let biggest = left\\n        \\n        if(left >= heap.length) return\\n        \\n        if(right < heap.length && weightFunction(heap[left]) < weightFunction(heap[right])) {\\n            biggest = right\\n        }\\n        \\n        if (weightFunction(heap[idx]) < weightFunction(heap[biggest])) {\\n            [heap[idx], heap[biggest]] = [heap[biggest], heap[idx]]\\n            heapifyDown(heap, biggest, weightFunction)\\n        }\\n    }\\n    \\n    function distance(point) {\\n        return point[0] * point[0] + point[1] * point[1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\n/*\\nsort approach:\\n- need to compute all distances, we can just omit the sqrt and just do x^2 + y^2\\n- need to sort by the distance: best: n log(n)\\n- do quicksort with a custom sorting function, then take the first k elements from the array\\nruntime: O(N log(N))\\nspace: O(1)\\n*/\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1]))\\n\\n    return points.slice(0,K)\\n};\\n\\n/*\\nmin heap approach:\\nwe can create a minHeap of the whole data set in O(n) time if we start from n/2 and heapify down each parent (see floyd method https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap)\\n\\nthen we remove k times from the heap -> k * log(n) (need to heapify down on each removal)\\nruntime: O(N + k log (N))\\nspace: O(1) since we are doing it in place\\n*/\\nvar kClosest = function(points, k) {\\n    // we can build the heap in place\\n    let p = Math.floor((points.length - 2) / 2) // last parent\\n    for(let i = p; i >= 0; i--) {\\n        heapifyDown(points, i, distance)\\n    }\\n    \\n    // now we need to remove the smallest (points[0]) k times\\n    let solution = []\\n    for(let i=0; i<k; i++) {\\n        solution.push(remove(points, distance))\\n    }\\n    \\n    return solution\\n    \\n    // read 0, replace 0 with last position, heapifyDown\\n    function remove(heap, weightFunction) {\\n        let val = heap[0]\\n        heap[0] = heap.pop()\\n        heapifyDown(heap, 0, weightFunction)\\n        return val\\n    }\\n    \\n    // compare with children, swap with smallest, repeat\\n    function heapifyDown(heap, idx, weightFunction) {\\n        let left = 2*idx + 1\\n        let right = 2*idx + 2\\n        let smallest = left\\n        \\n        if(left >= heap.length) return\\n        \\n        if(right < heap.length && weightFunction(heap[left]) > weightFunction(heap[right])) {\\n            smallest = right\\n        }\\n        \\n        if (weightFunction(heap[idx]) > weightFunction(heap[smallest])) {\\n            [heap[idx], heap[smallest]] = [heap[smallest], heap[idx]]\\n            heapifyDown(heap, smallest, weightFunction)\\n        }\\n    }\\n    \\n    function distance(point) {\\n        return point[0] * point[0] + point[1] * point[1]\\n    }\\n}\\n\\n\\n/*\\nmax heap approach:\\nhave a max heap of size k, so we would do N insertions that take log(k)\\nfor this case we would need to implement heapify up (insert) and heapify down (remove)\\n\\nruntime: O(N log(k))\\nspace: O(k)\\n*/\\nvar kClosest = function(points, k) {\\n    let heap = []\\n    \\n    // now we need to try to add all points to the heap\\n    for(let i=0; i<points.length; i++) {\\n        if(heap.length >= k && distance(points[i]) > distance(heap[0])) { // it\\'s bigger than the max, we can just skip it\\n            continue\\n        }\\n        add(heap, points[i], distance)\\n        if(heap.length > k) {\\n            remove(heap, distance)\\n        }\\n    }\\n    \\n    return heap\\n    \\n    // add at end, heapify up\\n    function add(heap, node, weightFunction) {\\n        heap.push(node)\\n        heapifyUp(heap, heap.length - 1, weightFunction)\\n    }\\n    \\n    // compare with parent and swap if needed, repeat\\n    function heapifyUp(heap, idx, weightFunction) {\\n        if(idx === 0) return\\n        let parent = Math.floor((idx-1) / 2)\\n        if(weightFunction(heap[idx]) > weightFunction(heap[parent])) {\\n            [heap[idx], heap[parent]] = [heap[parent], heap[idx]]\\n            heapifyUp(heap, parent, weightFunction)\\n        }\\n    }\\n    \\n    // read 0, replace 0 with last position, heapifyDown\\n    function remove(heap, weightFunction) {\\n        let val = heap[0]\\n        heap[0] = heap.pop()\\n        heapifyDown(heap, 0, weightFunction)\\n        return val\\n    }\\n    \\n    // compare with children, swap with biggest, repeat\\n    function heapifyDown(heap, idx, weightFunction) {\\n        let left = 2*idx + 1\\n        let right = 2*idx + 2\\n        let biggest = left\\n        \\n        if(left >= heap.length) return\\n        \\n        if(right < heap.length && weightFunction(heap[left]) < weightFunction(heap[right])) {\\n            biggest = right\\n        }\\n        \\n        if (weightFunction(heap[idx]) < weightFunction(heap[biggest])) {\\n            [heap[idx], heap[biggest]] = [heap[biggest], heap[idx]]\\n            heapifyDown(heap, biggest, weightFunction)\\n        }\\n    }\\n    \\n    function distance(point) {\\n        return point[0] * point[0] + point[1] * point[1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217969,
                "title": "java-python-3-6-1-liner-using-priorityqueue-heapq",
                "content": "1. Put the points into a PriorityQueue, and the order is by their distance to origin `descendingly`;\\n2. Whenever the size reaches K + 1, poll the farthest point out.\\n\\n**Analysis:**\\n\\n**Time: O(nlogK), space: O(K).**\\n\\n```java\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparing(a -> -a[0] * a[0] - a[1] * a[1]));\\n        for (int[] p : points) { \\n            pq.offer(p); \\n            if (pq.size() > K) { pq.poll(); } // poll out the farthest among the K + 1 points.\\n        }\\n        // int[][] ans = new int[K][2];\\n        // while (K-- > 0) { ans[K] = pq.poll(); }\\n        // return ans; // the above 3 lines can be replaced by the following line.\\n        return pq.toArray(new int[K][2]); // credit to @roolerzz, who make the code neat.\\n    }\\n```\\n\\n----\\n\\n**Analysis:**\\n\\n**Time: O(nlogK), space: O(n).**\\n```python\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        return heapq.nsmallest(K, points, lambda p: p[0] * p[0] + p[1] * p[1])\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparing(a -> -a[0] * a[0] - a[1] * a[1]));\\n        for (int[] p : points) { \\n            pq.offer(p); \\n            if (pq.size() > K) { pq.poll(); } // poll out the farthest among the K + 1 points.\\n        }\\n        // int[][] ans = new int[K][2];\\n        // while (K-- > 0) { ans[K] = pq.poll(); }\\n        // return ans; // the above 3 lines can be replaced by the following line.\\n        return pq.toArray(new int[K][2]); // credit to @roolerzz, who make the code neat.\\n    }\\n```\n```python\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        return heapq.nsmallest(K, points, lambda p: p[0] * p[0] + p[1] * p[1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 367136,
                "title": "very-simple-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K == points.length) return points;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(K, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]);\\n            }\\n        });\\n        \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > K) pq.poll();\\n        }\\n        return pq.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K == points.length) return points;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(K, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]);\\n            }\\n        });\\n        \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > K) pq.poll();\\n        }\\n        return pq.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518968,
                "title": "cpp-quickselect-avg-o-n-clean-and-concise-beats-98",
                "content": "```\\nclass Solution {\\n    static inline int getsum(const vector<int> &v){ return v[0]*v[0]+v[1]*v[1]; }\\n    static inline bool comp(const vector<int> &l, const vector<int> &r) { return getsum(l)<=getsum(r); }\\n     \\n    //standard Quicksort(Lomuto) partition\\n    int partition(vector<vector<int>>& arr, int left, int right){\\n        vector<int> pivot = arr[right];\\n        int partitionIndex = left;\\n        for(int i = left; i<right; i++){\\n            if (comp(arr[i], pivot)) {//custom comparator for point (x, y)\\n                swap(arr[i],arr[partitionIndex]);\\n                partitionIndex++;\\n            }\\n        }\\n        swap(arr[partitionIndex], arr[right]);\\n        return partitionIndex;\\n    }\\n    void quickselect(vector<vector<int>>&v, int l, int r, int K){\\n        while(l<=r){\\n             int mid = partition(v, l, r);\\n             if (mid==K) return;\\n             if (mid<K) l = mid+1;\\n             else r = mid - 1;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        quickselect(points, 0, points.size()-1, K);\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }    \\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n    static inline int getsum(const vector<int> &v){ return v[0]*v[0]+v[1]*v[1]; }",
                "codeTag": "Java"
            },
            {
                "id": 1578232,
                "title": "all-possible-3-python-solutions-interviewer-expectations",
                "content": "### So this problem, has 3 possible solutions:\\n\\n**1) Basic sorting:** -->`* Time: O(NlogN), Space=O(1)*`\\nWe sort the whole array and return the first k elements\\n```\\n        return sorted(points, key=lambda x:(x[0]**2+x[1]**2))[:k] \\n```\\n\\nIf we look at the sorting solution, we will find that we are sorting the WHOLE array while the problem is asking for K-nearest, so we are doing extra work than we need to!\\nSo can we reduce it by only sorting the K we need, yes thats is ahieved using heaps.\\n\\n**2) Heaps**  -->` Time O(nlogK), Space=O(K)`\\nThis problem can easily be solved using Max heaps, why max heaps ? because we are intrested in keeping the smallest elements, so we want to pop the largest ones from the top of the stack. So make the heap pop biggest elements first, we multiply the calculated distance by -1.\\n\\n ```\\n    h=[]\\n\\n\\tfor x,y in points:\\n\\t\\tdist=math.sqrt(x**2+y**2)\\n\\t\\tif len(h)<k:\\n\\t\\t\\theapq.heappush(h,(-dist,[x,y]))\\n\\t\\telse:\\n\\t\\t\\theapq.heappushpop(h,(-dist,[x,y]))\\n\\treturn [h[i][1] for i  in range(k)]\\n```\\n\\nNow, the interviewer might ask for a different solution that *might* achieve a better time complexity, which is quick select. (Note: The interviewer might stop at the heap solution but there has been cases where the interviewer need to hear about the quick select and how it would work. So in my opinion it is important to know it.\\n\\n\\n**3) Quick-Select:** ---> `Time: O(N) best-case, O(N^2) worst case, O(1) Space`\\nQuick select implementation during an interview is not the nicest thing, but I guess walking through the solution and discussing how it would work (like what the parition function would do, what the select function does and the general idea) even if it was not  implemented fully, in my opinion it would still be a good sign, then you know how to approach this problem in different ways, trading-off time complexity and space complexity.\\n\\n```\\nimport heapq\\nimport math\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        #quick select O(n), worst case O(n2)\\n        def partition(l,r,pivot_index):\\n\\t\\t\\n            #1. move pivot to end\\n            pivot=points[pivot_index][0]**2 +points[pivot_index][1]**2\\n            points[pivot_index],points[r]=points[r],points[pivot_index]\\n            \\n            #2. now start moving elements less than pivot to left and greater to right\\n            store_index=l\\n            for i in range(l,r):\\n                if (points[i][0]**2+points[i][1]**2)<pivot:\\n                    points[store_index],points[i]=points[i],points[store_index]\\n                    store_index+=1\\n\\t\\t\\t\\t\\t\\n            #3. now store_index has the place that pivot should be stored in, swap with pivot elemnted which is stored in index r (last element)\\n            points[store_index],points[r]=points[r],points[store_index]\\n            return store_index\\n\\n        \\n        def select(l,r,k):\\n            if l<r:\\n                pivot_index=random.randint(l,r)\\n                pivot_index=partition(l,r,pivot_index)\\n\\t\\t\\t\\t\\n                if pivot_index==k:\\n                    return \\n                if pivot_index<k:\\n                    select(pivot_index+1,r,k)\\n                else:\\n                    select(l,pivot_index-1,k)\\n                \\n\\n        select(0,len(points)-1,k)\\n        \\n        return points[:k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        return sorted(points, key=lambda x:(x[0]**2+x[1]**2))[:k] \\n```\n```\\n    h=[]\\n\\n\\tfor x,y in points:\\n\\t\\tdist=math.sqrt(x**2+y**2)\\n\\t\\tif len(h)<k:\\n\\t\\t\\theapq.heappush(h,(-dist,[x,y]))\\n\\t\\telse:\\n\\t\\t\\theapq.heappushpop(h,(-dist,[x,y]))\\n\\treturn [h[i][1] for i  in range(k)]\\n```\n```\\nimport heapq\\nimport math\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        #quick select O(n), worst case O(n2)\\n        def partition(l,r,pivot_index):\\n\\t\\t\\n            #1. move pivot to end\\n            pivot=points[pivot_index][0]**2 +points[pivot_index][1]**2\\n            points[pivot_index],points[r]=points[r],points[pivot_index]\\n            \\n            #2. now start moving elements less than pivot to left and greater to right\\n            store_index=l\\n            for i in range(l,r):\\n                if (points[i][0]**2+points[i][1]**2)<pivot:\\n                    points[store_index],points[i]=points[i],points[store_index]\\n                    store_index+=1\\n\\t\\t\\t\\t\\t\\n            #3. now store_index has the place that pivot should be stored in, swap with pivot elemnted which is stored in index r (last element)\\n            points[store_index],points[r]=points[r],points[store_index]\\n            return store_index\\n\\n        \\n        def select(l,r,k):\\n            if l<r:\\n                pivot_index=random.randint(l,r)\\n                pivot_index=partition(l,r,pivot_index)\\n\\t\\t\\t\\t\\n                if pivot_index==k:\\n                    return \\n                if pivot_index<k:\\n                    select(pivot_index+1,r,k)\\n                else:\\n                    select(l,pivot_index-1,k)\\n                \\n\\n        select(0,len(points)-1,k)\\n        \\n        return points[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660016,
                "title": "python-oneliner-using-sort",
                "content": "Even though this algorighm has not optimal algorithmic complexity (it is `O(n log n)` vs heaps `O(n log k)`, on leetcode it can work faster. Just sort points by distances and choose the smallest `K` of them\\n\\n```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        return sorted(points, key = lambda x: x[0]**2 + x[1]**2)[:K]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        return sorted(points, key = lambda x: x[0]**2 + x[1]**2)[:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600936,
                "title": "c-o-nlogk-high-speed-solution-with-detailed-explanation",
                "content": "```\\nThe give away to a heap question is whenever a question asks for k closest or k smallest or k largest.\\nThough these questions might me implemented using other algorithms heap will allow to simply the problem as well as code.\\nYour code will look compact and u can rectify ur mistakes quickly.\\nThis can be solved using miheap or maxheap.\\nThe only probem with min heap is space.It will store all the array elements and this can be costly of large elemented arrays.\\nHowever using a maxheap we just need to be storing k elements.\\nThat is all the difference between them.\\n\\nLet points = [[1,3],[-2,2]], K = 1\\nThe way to judge whether a point is clore or not is to find the euclidean distance.\\nNote:u dont have to perform square root and make the code look complex moreover it s more prone to errors.\\n\\ndist = x*x+y*y\\nWe have the choose the k smallest distance values.\\n\\nLets see the above question:\\n\\ndist = 1*1 + 3*3 = 10\\ndist = -2*-2 + 2*2 = 8\\n\\nWe can see that dist of the 2nd element is smaller and question asks for only 1 so we pushback that element into our ans array.\\n    \\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> ans;\\n        if(points.size()==0)return ans;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int dist=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            if(pq.size()<k)\\n            pq.push({dist,{points[i][0],points[i][1]}});\\n            else\\n            {\\n                if(dist<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({dist,{points[i][0],points[i][1]}});\\n                }\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nThe give away to a heap question is whenever a question asks for k closest or k smallest or k largest.\\nThough these questions might me implemented using other algorithms heap will allow to simply the problem as well as code.\\nYour code will look compact and u can rectify ur mistakes quickly.\\nThis can be solved using miheap or maxheap.\\nThe only probem with min heap is space.It will store all the array elements and this can be costly of large elemented arrays.\\nHowever using a maxheap we just need to be storing k elements.\\nThat is all the difference between them.\\n\\nLet points = [[1,3],[-2,2]], K = 1\\nThe way to judge whether a point is clore or not is to find the euclidean distance.\\nNote:u dont have to perform square root and make the code look complex moreover it s more prone to errors.\\n\\ndist = x*x+y*y\\nWe have the choose the k smallest distance values.\\n\\nLets see the above question:\\n\\ndist = 1*1 + 3*3 = 10\\ndist = -2*-2 + 2*2 = 8\\n\\nWe can see that dist of the 2nd element is smaller and question asks for only 1 so we pushback that element into our ans array.\\n    \\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> ans;\\n        if(points.size()==0)return ans;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int dist=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            if(pq.size()<k)\\n            pq.push({dist,{points[i][0],points[i][1]}});\\n            else\\n            {\\n                if(dist<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({dist,{points[i][0],points[i][1]}});\\n                }\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455176,
                "title": "java-quick-select-for-beginner",
                "content": "Here is a very good entity visualization video:\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/MZaf_9IZCrc\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        int i = 0, j = points.length - 1;\\n        while(i < j) {\\n            int mid = partition(points, i, j);\\n            if(mid == K) break;\\n            if(mid < K) {\\n                i = mid + 1;\\n            } else {\\n                j = mid - 1;\\n            }\\n        }\\n        return Arrays.copyOf(points, K);\\n    }\\n    \\n    private int partition(int[][] points, int start, int end) {\\n        int[] pivot = points[end];\\n        int swapIndex = start - 1;\\n        for(int i = start; i < end; i++) {\\n            if(value(points[i]) < value(pivot)) {\\n                swapIndex++;\\n                swap(points, swapIndex, i);\\n            }\\n        }\\n        swap(points, ++swapIndex, end);\\n        return swapIndex;\\n    }\\n    \\n    private int value(int[] a) {\\n        return a[0] * a[0] + a[1] * a[1];\\n    }\\n    \\n    private void swap(int[][] points, int i, int j) {\\n        int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        int i = 0, j = points.length - 1;\\n        while(i < j) {\\n            int mid = partition(points, i, j);\\n            if(mid == K) break;\\n            if(mid < K) {\\n                i = mid + 1;\\n            } else {\\n                j = mid - 1;\\n            }\\n        }\\n        return Arrays.copyOf(points, K);\\n    }\\n    \\n    private int partition(int[][] points, int start, int end) {\\n        int[] pivot = points[end];\\n        int swapIndex = start - 1;\\n        for(int i = start; i < end; i++) {\\n            if(value(points[i]) < value(pivot)) {\\n                swapIndex++;\\n                swap(points, swapIndex, i);\\n            }\\n        }\\n        swap(points, ++swapIndex, end);\\n        return swapIndex;\\n    }\\n    \\n    private int value(int[] a) {\\n        return a[0] * a[0] + a[1] * a[1];\\n    }\\n    \\n    private void swap(int[][] points, int i, int j) {\\n        int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268190,
                "title": "python-quick-select-o-n",
                "content": "Time complexity: **O(n)** (even at worst case thanks to the median of median method)\\nSpace complexity: **O(n)**. It can be improved to **O(1)** with in-place swap.\\n\\nThis quick select method has better time complexity than heap method ( O(n log k) ). However, heap method can handle in-stream data (i.e., not given all at once). So, if you are asked this question in interview, you can implement either one but make sure to mention the other and talk about suitable use case. Also, this sub-optimal space complexity implemention is enough in the interview, coz you need enough time to explain clearly on what you are doing. Just make sure to mention in-place swap can improve space complexity to constant.\\n\\nCodes are straightforward. See in-line comments.\\n\\n```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def quick_select(lst, k):\\n            \"\"\"\\n            This function is to get the k-th order statistics.\\n            Time complexity is O(n) even at worst case.\\n            \"\"\"\\n            \\n            # handle the part at the end of the recursion\\n            if k==0: return min(lst)\\n            if k==len(lst): return max(lst)\\n            if len(lst)<=10:\\n                return sorted(lst)[k-1]\\n\\n            # select pivot - using median of median to make sure worst case O(n) complexity\\n            medians = [sorted(lst[i*5:i*5+5])[2] for i in range(len(lst)//5)]\\n            pivot = quick_select(medians, len(medians)//2)\\n\\n            # separate lst by values smaller, equal or larger than pivot\\n            # here I don\\'t use in-place swap to make codes easy and clean. \\n            smaller = [i for i in lst if i<pivot]\\n            equal = [i for i in lst if i==pivot]\\n            larger = [i for i in lst if i>pivot]\\n\\n            # recursion\\n            if len(smaller)>=k:\\n                return quick_select(smaller, k)\\n            elif len(smaller)+len(equal) >= k:\\n                return pivot\\n            else:\\n                return quick_select(larger, k-len(smaller)-len(equal))\\n            \\n        distance = [i[0]**2+i[1]**2 for i in points]\\n        kth_order_stat = quick_select(distance, K)\\n        return [points[i] for i in range(len(points)) if distance[i] <= kth_order_stat]\\n```",
                "solutionTags": [
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def quick_select(lst, k):\\n            \"\"\"\\n            This function is to get the k-th order statistics.\\n            Time complexity is O(n) even at worst case.\\n            \"\"\"\\n            \\n            # handle the part at the end of the recursion\\n            if k==0: return min(lst)\\n            if k==len(lst): return max(lst)\\n            if len(lst)<=10:\\n                return sorted(lst)[k-1]\\n\\n            # select pivot - using median of median to make sure worst case O(n) complexity\\n            medians = [sorted(lst[i*5:i*5+5])[2] for i in range(len(lst)//5)]\\n            pivot = quick_select(medians, len(medians)//2)\\n\\n            # separate lst by values smaller, equal or larger than pivot\\n            # here I don\\'t use in-place swap to make codes easy and clean. \\n            smaller = [i for i in lst if i<pivot]\\n            equal = [i for i in lst if i==pivot]\\n            larger = [i for i in lst if i>pivot]\\n\\n            # recursion\\n            if len(smaller)>=k:\\n                return quick_select(smaller, k)\\n            elif len(smaller)+len(equal) >= k:\\n                return pivot\\n            else:\\n                return quick_select(larger, k-len(smaller)-len(equal))\\n            \\n        distance = [i[0]**2+i[1]**2 for i in points]\\n        kth_order_stat = quick_select(distance, K)\\n        return [points[i] for i in range(len(points)) if distance[i] <= kth_order_stat]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659966,
                "title": "python-easy-heap-o-n-log-k-solution-explained",
                "content": "When you see in the statement of the problem that you need you find k biggest or k smallest elements, you should immediately think about heaps or sort. Here we need to find the k smallest elements, and hence we need to keep **max** heap. Why max and not min? We always keep in the root of our heap the `k`-th smallest element. Let us go through example: `points = [[1,2],[2,3],[0,1]], [3,4]`, `k = 2`. \\n1. First we put points `[1,2]` and `[2,3]` into our heap. In the root of the heap we have maximum element `[2,3]`\\n2. Now, we see new element `[0,1]`, what should we do? We compare it with the root, see, that it is smaller than root, so we need to remove it from our heap and put new element instead, now we have elements `[1,2]` and `[0,1]` in our heap, root is `[1,2]`\\n3. Next element is `[3,4]` and it is greater than our root, it means we do not need to do anything.\\n\\n### Complexity\\nWe process elements one by one, there are `n` of them and push it into heap and pop root from our heap, both have `O(log k)` complexity, so finally we have `O(n log k)` complexity, which is faster than `O(n log n)` algorighm using sorting.\\n\\n### Code:\\nFirst, we create heap (which is by definition **min** heap in python, so we use negative distances). Then we visit all the rest elements one by one and update our heap if needed.\\n\\n```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        heap = [[-i*i-j*j, i, j] for i,j in points[:K]]\\n        rest_elem = [[-i*i-j*j, i, j] for i,j in points[K:]]\\n        heapq.heapify(heap)\\n        for s, x, y in rest_elem:\\n            if s > heap[0][0]:\\n                heapq.heappush(heap, [s,x,y])\\n                heapq.heappop(heap)\\n\\n        return [[x,y] for s,x,y in heap]\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        heap = [[-i*i-j*j, i, j] for i,j in points[:K]]\\n        rest_elem = [[-i*i-j*j, i, j] for i,j in points[K:]]\\n        heapq.heapify(heap)\\n        for s, x, y in rest_elem:\\n            if s > heap[0][0]:\\n                heapq.heappush(heap, [s,x,y])\\n                heapq.heappop(heap)\\n\\n        return [[x,y] for s,x,y in heap]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411088,
                "title": "java-solutions-with-exp-comments-sorting-heap-quickselect",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/k-closest-points-to-origin/) <span class=\"gray\">EPI 10.4</span>\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> We have a list of `points` on the plane.  Find the `K` closest points to the origin `(0, 0)`.\\n\\n> (Here, the distance between two points on a plane is the Euclidean distance.)\\n\\n> You may return the answer `in any order`.  The answer is guaranteed to be unique (except for the order that it is in.)\\n\\n**Example:** \\n\\n```java\\nInput: points = [[1,3],[-2,2]], K = 1\\nOutput: [[-2,2]]\\n```\\n\\n```java\\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\\nOutput: [[3,3],[-2,4]]\\n```\\n\\n## Analysis\\n\\n\\n### Sorting\\n\\nFirst let\\'s define the distance calculation method.\\n\\n```java\\nprivate int dis(int[] p) { // square\\n  return p[0] * p[0] + p[1] * p[1];\\n}\\n```\\n\\n\\n```java\\n// input: [[3,3],[5,-1],[-2,4]]\\npublic int[][] kClosest(int[][] points, int K) {\\n  Arrays.sort(points, (p1, p2) -> {  // comparator\\n    return dis(p1) - dis(p2); // <\\n  });\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    result[i] = new int[] { points[i][0], points[i][1] };\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N\\\\log{N})`\\n**Space:** `O(K)`\\n\\n\\n\\n### Max Heap\\n\\nSince we want K smallest elements, we use a K-size max heap. We repeatedly add elements to the heap. When the size is greater than K, we remove the largest element.\\n\\n\\n```java\\npublic int[][] kClosest(int[][] points, int K) {\\n  PriorityQueue<Integer> pq = new PriorityQueue<>((i1, i2) -> {\\n    return dis(points[i2]) - dis(points[i1]);\\n  });\\n  for (int i = 0; i < points.length; ++i) {\\n    pq.add(i);\\n    if (pq.size() > K) {\\n      pq.remove();\\n    }\\n  }\\n  // result\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    int idx = pq.remove();\\n    result[i] = points[idx]; // can be returned in any order\\n  }\\n  return result;\\n}\\n```\\n\\nWe can also write the comparator like this.\\n\\n```java\\nComparator<int[]> comp = (p1, p2) -> (\\n  return dis(p2) - dis(p1);\\n);\\nPriorityQueue<int[]> pq = new PriorityQueue<>(comp);\\n```\\n\\n**Time:** `O(N\\\\log{K})`\\n**Space:** `O(K)`\\n\\n\\n\\n\\n### Quick Select\\n\\nThe idea of Quick Select is to find the K-th element, make elements on the left less than the K-th element, and make elements on the right greater than the K-th element.\\n\\nWe randomly pick an element. If it turns out to be the actual K-th element, we can stop at the first step. So it depends on luck.\\n\\nAfter swapping, if this element turns out to be an element to the left of the K-th element, we recursively solve the subproblem for the right subarray; if it is to the right, we solve it for the left subarray.\\n\\n**Note:** To make code cleaner, after we pick the random index, we place the element at the beginning before doing swapping.\\n\\n\\n```java\\n// quickSelect\\npublic int[][] kClosest(int[][] points, int K) {\\n  int n = points.length;\\n  quickSelect(points, K - 1, 0, n - 1); // index from 0\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    result[i] = points[i];\\n  }\\n  return result;\\n}\\n\\n// find the k-th element (from 0 ~ hi - 1)\\nprivate void quickSelect(int[][] points, int k, int lo, int hi) {\\n  if (lo == hi) {\\n    return;\\n  }\\n  Random rand = new Random();\\n  int randIdx = lo + rand.nextInt(hi - lo + 1); // lo + (0 ~ #element)\\n  // place the key to the beginning\\n  swap(points, lo, randIdx);\\n  int key = lo;\\n  int i = lo, j = hi + 1; // one index offset\\n\\n  while (true) {\\n    while (dis(points[++i]) < dis(points[key])) { // move i\\n      if (i == hi) break;\\n    }\\n    while (dis(points[--j]) > dis(points[key])) { // move j\\n      if (j == lo) break;\\n    }\\n    if (i >= j) break;\\n    swap(points, i, j);\\n  }\\n  swap(points, key, j); // put [key] to the correct place [<key] [key] [>key]\\n\\n  // notice that k = K - 1\\n  // j is now where [key] is\\n  if (j > k) quickSelect(points, k, lo, j - 1); // left\\n  if (j < k) quickSelect(points, k, j + 1, hi); // right\\n  // if j == k, finish.\\n}\\n\\nprivate void swap(int[][] points, int i, int j) {\\n  int[] temp = points[i];\\n  points[i] = points[j];\\n  points[j] = temp;\\n}\\n```\\n\\n**Time:** `O(\\\\log{N})` in average; `O(N)` in the worst case.\\n**Space:** `O(\\\\log{N})` in average; `O(N)` in the worst case (call stack).",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```java\\nInput: points = [[1,3],[-2,2]], K = 1\\nOutput: [[-2,2]]\\n```\n```java\\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\\nOutput: [[3,3],[-2,4]]\\n```\n```java\\nprivate int dis(int[] p) { // square\\n  return p[0] * p[0] + p[1] * p[1];\\n}\\n```\n```java\\n// input: [[3,3],[5,-1],[-2,4]]\\npublic int[][] kClosest(int[][] points, int K) {\\n  Arrays.sort(points, (p1, p2) -> {  // comparator\\n    return dis(p1) - dis(p2); // <\\n  });\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    result[i] = new int[] { points[i][0], points[i][1] };\\n  }\\n  return result;\\n}\\n```\n```java\\npublic int[][] kClosest(int[][] points, int K) {\\n  PriorityQueue<Integer> pq = new PriorityQueue<>((i1, i2) -> {\\n    return dis(points[i2]) - dis(points[i1]);\\n  });\\n  for (int i = 0; i < points.length; ++i) {\\n    pq.add(i);\\n    if (pq.size() > K) {\\n      pq.remove();\\n    }\\n  }\\n  // result\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    int idx = pq.remove();\\n    result[i] = points[idx]; // can be returned in any order\\n  }\\n  return result;\\n}\\n```\n```java\\nComparator<int[]> comp = (p1, p2) -> (\\n  return dis(p2) - dis(p1);\\n);\\nPriorityQueue<int[]> pq = new PriorityQueue<>(comp);\\n```\n```java\\n// quickSelect\\npublic int[][] kClosest(int[][] points, int K) {\\n  int n = points.length;\\n  quickSelect(points, K - 1, 0, n - 1); // index from 0\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    result[i] = points[i];\\n  }\\n  return result;\\n}\\n\\n// find the k-th element (from 0 ~ hi - 1)\\nprivate void quickSelect(int[][] points, int k, int lo, int hi) {\\n  if (lo == hi) {\\n    return;\\n  }\\n  Random rand = new Random();\\n  int randIdx = lo + rand.nextInt(hi - lo + 1); // lo + (0 ~ #element)\\n  // place the key to the beginning\\n  swap(points, lo, randIdx);\\n  int key = lo;\\n  int i = lo, j = hi + 1; // one index offset\\n\\n  while (true) {\\n    while (dis(points[++i]) < dis(points[key])) { // move i\\n      if (i == hi) break;\\n    }\\n    while (dis(points[--j]) > dis(points[key])) { // move j\\n      if (j == lo) break;\\n    }\\n    if (i >= j) break;\\n    swap(points, i, j);\\n  }\\n  swap(points, key, j); // put [key] to the correct place [<key] [key] [>key]\\n\\n  // notice that k = K - 1\\n  // j is now where [key] is\\n  if (j > k) quickSelect(points, k, lo, j - 1); // left\\n  if (j < k) quickSelect(points, k, j + 1, hi); // right\\n  // if j == k, finish.\\n}\\n\\nprivate void swap(int[][] points, int i, int j) {\\n  int[] temp = points[i];\\n  points[i] = points[j];\\n  points[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 659927,
                "title": "python-sorting-by-distance-w-visualization",
                "content": "Python sorting by distance\\n\\n---\\n\\n**Hint**:\\n\\nRecall the definition of [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance).\\n\\nLaunch customized sorting to sort points by distance to origin.\\n\\n---\\n\\n**Illustration** and **Visualization**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1590842183.png)\\n\\n\\n---\\n\\n**Implementation** by sorting with distance:\\n\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        # sort by the distance to origin, in ascending order\\n        points.sort( key = lambda point: (point[0]**2 + point[1]**2) )\\n        \\n        return points[:K]\\n```\\n\\n---\\n\\n**Implementation** by heap sort with distance:\\n\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n                \\n        # sort by the distance to origin, in ascending order\\n        k_closet = heapq.nsmallest( K, points, key = lambda point: point[0]**2 + point[1]**2  )\\n        \\n        return k_closet\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about sorting as well as customized sorting](https://docs.python.org/3/howto/sorting.html#sorting-how-to)\\n\\n[2] [Python official docs about heap and heap sort](https://docs.python.org/3.8/library/heapq.html)",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        # sort by the distance to origin, in ascending order\\n        points.sort( key = lambda point: (point[0]**2 + point[1]**2) )\\n        \\n        return points[:K]\\n```\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n                \\n        # sort by the distance to origin, in ascending order\\n        k_closet = heapq.nsmallest( K, points, key = lambda point: point[0]**2 + point[1]**2  )\\n        \\n        return k_closet\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218911,
                "title": "two-types-of-python-1-linear-o-n-lgn-and-o-n-lgk",
                "content": "#### *O(N.lgN)*\\n```\\ndef kClosest(self, points, K):\\n\\treturn sorted(points,key=lambda x:x[0]**2+x[1]**2)[:K]\\n```\\n#### *O(N.lgK), 1-Linear* \\nheapq.nsmallest(n, iterable[, key])\\nReturn a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in the iterable: key=str.lower Equivalent to: sorted(iterable, key=key[:n]\\nResource: https://docs.python.org/2/library/heapq.html\\n```\\ndef kClosest(self, points, K):\\n\\treturn heapq.nsmallest(K, points, lambda x: x[0]**2+x[1]**2)\\n```\\n\\n#### *O(N.lgK), Other type of second type* \\n```\\ndef kClosest(self, points, K):\\n\\theap=[]\\n    for a,b in points:\\n\\t\\td=a*a+b*b\\n\\t\\theapq.heappush(heap,(-d,a,b)) # -d is for inverse value of data ( pop minimum distance instead of maximum )\\n        if len(heap)>K: # Keep length of heap in size K\\n\\t\\t\\theapq.heappop(heap)\\n\\treturn [[b,c] for a,b,c in heap]\\n```\\nWhat\\'s the \"lambda\" ?\\nSmall anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: lambda a, b: a+b. Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Semantically, they are just syntactic sugar for a normal function definition. Like nested function definitions, lambda functions can reference variables from the containing scope:\\n```\\n>> def make_incrementor(n):\\n>> return lambda x: x + n\\n...\\n>> f = make_incrementor(42)\\n>> f(0)\\n42\\n>> f(1)\\n43\\n```\\nResource : https://docs.python.org/3/tutorial/controlflow.html",
                "solutionTags": [],
                "code": "```\\ndef kClosest(self, points, K):\\n\\treturn sorted(points,key=lambda x:x[0]**2+x[1]**2)[:K]\\n```\n```\\ndef kClosest(self, points, K):\\n\\treturn heapq.nsmallest(K, points, lambda x: x[0]**2+x[1]**2)\\n```\n```\\ndef kClosest(self, points, K):\\n\\theap=[]\\n    for a,b in points:\\n\\t\\td=a*a+b*b\\n\\t\\theapq.heappush(heap,(-d,a,b)) # -d is for inverse value of data ( pop minimum distance instead of maximum )\\n        if len(heap)>K: # Keep length of heap in size K\\n\\t\\t\\theapq.heappop(heap)\\n\\treturn [[b,c] for a,b,c in heap]\\n```\n```\\n>> def make_incrementor(n):\\n>> return lambda x: x + n\\n...\\n>> f = make_incrementor(42)\\n>> f(0)\\n42\\n>> f(1)\\n43\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 662072,
                "title": "c-short-and-easy-to-understand-using-vectors",
                "content": "The idea is to find distance of each point from origin and store it in an array of pairs consisting of distance and the point in each pair.Then sort the array according to distance and then store the first K  points in the answer array and return it .\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        vector<vector<int>> answer;\\n        vector<pair<double,vector<int>>> distances;\\n        for(auto i:points){\\n            double distance=sqrt(pow(i[0],2)+pow(i[1],2));\\n            distances.push_back(make_pair(distance,i));\\n        }\\n        sort(distances.begin(),distances.end());\\n        for(int i=0;i<K;i++)answer.push_back(distances[i].second);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        vector<vector<int>> answer;\\n        vector<pair<double,vector<int>>> distances;\\n        for(auto i:points){\\n            double distance=sqrt(pow(i[0],2)+pow(i[1],2));\\n            distances.push_back(make_pair(distance,i));\\n        }\\n        sort(distances.begin(),distances.end());\\n        for(int i=0;i<K;i++)answer.push_back(distances[i].second);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377034,
                "title": "python-sort-heap-divide-and-conquer-solutions",
                "content": "1. Sort the distance, O(nlogn); O(n)\\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        points.sort(key = lambda p: p[0]**2 + p[1] ** 2)\\n        return points[:K]\\n```\\n2. heapq, O(nlogk); O(k)\\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        import heapq\\n        heap = []\\n        for p in points:\\n            x, y = p[0], p[1]\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, p))\\n            else:\\n                heapq.heappush(heap, (dist, p))\\n        return [p for (dist, p) in heap]\\n```\\n3. divide and conquer, avg O(n), worst (n^2); O(n), can be further reduced using in-place\\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n\\t\\tdef findK(Points, K):\\n            if K == 0:\\n                return []\\n            if len(Points) <= K:\\n                return [p[1] for p in Points]\\n\\n            pivot, left, right = Points[0], [], []\\n            for p in Points:\\n                if p[0] > pivot[0]:\\n                    right.append(p)\\n                elif p[0] < pivot[0]:\\n                    left.append(p)\\n            \\n            if len(left) >= K:\\n                return findK(left, K)\\n            else:\\n                return [l[1] for l in left] + [pivot[1]] + findK(right, K - 1 - len(left))\\n            \\n        Points = [[p[0]**2 + p[1]**2, p] for p in points]\\n        return findK(Points, K)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        points.sort(key = lambda p: p[0]**2 + p[1] ** 2)\\n        return points[:K]\\n```\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        import heapq\\n        heap = []\\n        for p in points:\\n            x, y = p[0], p[1]\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, p))\\n            else:\\n                heapq.heappush(heap, (dist, p))\\n        return [p for (dist, p) in heap]\\n```\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n\\t\\tdef findK(Points, K):\\n            if K == 0:\\n                return []\\n            if len(Points) <= K:\\n                return [p[1] for p in Points]\\n\\n            pivot, left, right = Points[0], [], []\\n            for p in Points:\\n                if p[0] > pivot[0]:\\n                    right.append(p)\\n                elif p[0] < pivot[0]:\\n                    left.append(p)\\n            \\n            if len(left) >= K:\\n                return findK(left, K)\\n            else:\\n                return [l[1] for l in left] + [pivot[1]] + findK(right, K - 1 - len(left))\\n            \\n        Points = [[p[0]**2 + p[1]**2, p] for p in points]\\n        return findK(Points, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659955,
                "title": "c-priority-queue-solution",
                "content": "```\\nint dist( vector<int> &point ) {\\n        return point[0]*point[0] + point[1]*point[1];    \\n    }\\n    \\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        typedef pair<int, int> pi;\\n        \\n        int distance;\\n        priority_queue< pi > maxHeap; // <distance, index> pair\\n        for( int i=0; i < points.size(); i++ ) {\\n            distance = dist( points[i] );\\n            if( maxHeap.size() < K )\\n                maxHeap.push( { distance, i } );\\n            else if( distance < maxHeap.top().first ) {\\n                    maxHeap.push( { distance, i } );\\n                    maxHeap.pop();\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        while( !maxHeap.empty() ) {\\n            result.push_back( points[ maxHeap.top().second ] );\\n            maxHeap.pop();\\n        }\\n        return result;\\n    }\\n```\\nUpvotes are encouraging",
                "solutionTags": [],
                "code": "```\\nint dist( vector<int> &point ) {\\n        return point[0]*point[0] + point[1]*point[1];    \\n    }\\n    \\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        typedef pair<int, int> pi;\\n        \\n        int distance;\\n        priority_queue< pi > maxHeap; // <distance, index> pair\\n        for( int i=0; i < points.size(); i++ ) {\\n            distance = dist( points[i] );\\n            if( maxHeap.size() < K )\\n                maxHeap.push( { distance, i } );\\n            else if( distance < maxHeap.top().first ) {\\n                    maxHeap.push( { distance, i } );\\n                    maxHeap.pop();\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        while( !maxHeap.empty() ) {\\n            result.push_back( points[ maxHeap.top().second ] );\\n            maxHeap.pop();\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 375452,
                "title": "javascript-very-simple-and-easy-to-understand",
                "content": "I felt the one liner solution is not how I write actual code. This is much easier to reason about.\\n\\n```javascript\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => getLength(a) - getLength(b)).slice(0, K);\\n};\\n\\n// we don\\'t need to find square root of c here\\n// squared length is enough to determine order\\nvar getLength = function([a, b]) {\\n    return (a * a) + (b * b);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => getLength(a) - getLength(b)).slice(0, K);\\n};\\n\\n// we don\\'t need to find square root of c here\\n// squared length is enough to determine order\\nvar getLength = function([a, b]) {\\n    return (a * a) + (b * b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703675,
                "title": "c-aditya-verma-type-of-code-priority-queue",
                "content": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        \\n        int n = points.size();\\n        //ans to contain the answer\\n        vector<vector<int>> ans;\\n        //loop through the matrix\\n        for(int i = 0;i<n;i++){\\n            //Push x^2+y^2 as it is relative\\n            //Push distance, coordinate in max heap\\n         pq.push({(points[i][0]*points[i][0]) + (points[i][1]*points[i][1]),\\n         {points[i][0],points[i][1]}});\\n            //max heap keep the largest value at top \\n            //we can remove the larger values than k until the size is < k\\n                while(pq.size()>k)\\n                    pq.pop(); //pop the > k value\\n            //sorting is done on the basis on distance\\n            \\n        }\\n        \\n        //The left over elements in priority queue is the answer\\n        while(pq.size()>0){\\n        pair<int,int> p = pq.top().second; //store the second value which is coordinate in a pair\\n        ans.push_back({p.first,p.second}); //push the pair\\'s first and second value, basically the coordinates\\n        pq.pop(); //pop then and update the top\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        \\n        int n = points.size();\\n        //ans to contain the answer\\n        vector<vector<int>> ans;\\n        //loop through the matrix\\n        for(int i = 0;i<n;i++){\\n            //Push x^2+y^2 as it is relative\\n            //Push distance, coordinate in max heap\\n         pq.push({(points[i][0]*points[i][0]) + (points[i][1]*points[i][1]),\\n         {points[i][0],points[i][1]}});\\n            //max heap keep the largest value at top \\n            //we can remove the larger values than k until the size is < k\\n                while(pq.size()>k)\\n                    pq.pop(); //pop the > k value\\n            //sorting is done on the basis on distance\\n            \\n        }\\n        \\n        //The left over elements in priority queue is the answer\\n        while(pq.size()>0){\\n        pair<int,int> p = pq.top().second; //store the second value which is coordinate in a pair\\n        ans.push_back({p.first,p.second}); //push the pair\\'s first and second value, basically the coordinates\\n        pq.pop(); //pop then and update the top\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507637,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n        (p1, p2) -> getDistance(p1).compareTo(getDistance(p2)));\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            pq.add(points[i]);\\n        }\\n        \\n        int[][] result = new int[k][2];\\n        \\n        for(int i = 0; i < k; i++) {\\n            result[i] = pq.poll();    \\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Double getDistance(int[] point) {\\n        return Math.sqrt((point[0] * point[0]) + (point[1] * point[1]));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n        (p1, p2) -> getDistance(p1).compareTo(getDistance(p2)));\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            pq.add(points[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 218888,
                "title": "java-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Queue<int[]> queue=new PriorityQueue<>((a, b) -> (a[0]*a[0]+a[1]*a[1])-(b[0]*b[0]+b[1]*b[1]));\\n        int[][] res=new int[K][2];\\n        int index=0;\\n        for(int[] arr:points) {\\n            queue.add(arr);\\n        }\\n        while(index<K) {\\n            res[index]=queue.poll();\\n            index++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Queue<int[]> queue=new PriorityQueue<>((a, b) -> (a[0]*a[0]+a[1]*a[1])-(b[0]*b[0]+b[1]*b[1]));\\n        int[][] res=new int[K][2];\\n        int index=0;\\n        for(int[] arr:points) {\\n            queue.add(arr);\\n        }\\n        while(index<K) {\\n            res[index]=queue.poll();\\n            index++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661175,
                "title": "java-clean-code-o-n-log-n-solution-hashmap-sorting-and-minheap-approach",
                "content": "### **Approach 1: HashMap **\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        HashMap<Integer, Double> map = new HashMap<>();\\n        for(int i = 0; i < points.length; i++) {\\n            double distance = Math.sqrt(points[i][0] * points[i][0] + points[i][1] * points[i][1]);\\n            map.put(i, distance);\\n        }\\n        \\n        List<Map.Entry<Integer, Double>> sortList = new LinkedList<>(map.entrySet());\\n        Collections.sort(sortList, (a, b) -> a.getValue().compareTo(b.getValue()));\\n        \\n        int[][] ans = new int[K][2];\\n        int i = 0;\\n        for(Map.Entry entry : sortList) {\\n            int key = (int) entry.getKey();\\n            ans[i][0] = points[key][0];\\n            ans[i][1] = points[key][1];\\n            i++;\\n            if(i == K) break;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n## Approach 2: Sorting ****\\n```\\nclass Solution {\\n \\n\\tprivate int calculateDistance(int[] point) {\\n\\t\\treturn point[0] * point[0] + point[1] * point[1];\\n\\t}\\n \\n\\tpublic int[][] kClosest(int[][] points, int K) {\\n \\n\\t\\tint[] distance = new int[points.length];\\n\\t\\tfor(int i = 0; i < points.length; i++) \\n            distance[i] = calculateDistance(points[i]);\\n \\n\\t\\tArrays.sort(distance);\\n\\t\\tint kthDistance = distance[K - 1];\\n\\t\\tint[][] kClosestPoints = new int[K][2];\\n \\n\\t\\tfor(int i = 0, j = 0; i < points.length && j < K; i++) \\n\\t\\t\\tif(calculateDistance(points[i]) <= kthDistance)\\n\\t\\t\\t\\tkClosestPoints[j++] = points[i];\\n \\n\\t\\treturn kClosestPoints;\\n\\t}\\n}\\n\\n```\\n\\n\\n## **Approach 3 : Min Heap **\\n```\\nclass Solution {\\n \\n\\tprivate int calculateDistance(int[] point) {\\n\\t\\treturn point[0] * point[0] + point[1] * point[1];\\n\\t}\\n \\n\\tpublic int[][] kClosest(int[][] points, int K) {\\n \\n\\t\\tPriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> calculateDistance(a) - calculateDistance(b));\\n \\n        for(int[] point : points) \\n            minHeap.offer(point);\\n        \\n\\t\\tint[][] kClosestPoints = new int[K][2];\\n        int i = 0;\\n        while(K-- != 0) \\n            kClosestPoints[i++] = minHeap.poll();\\n\\t\\t\\n\\t\\treturn kClosestPoints;\\n\\t}\\n}\\n\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        HashMap<Integer, Double> map = new HashMap<>();\\n        for(int i = 0; i < points.length; i++) {\\n            double distance = Math.sqrt(points[i][0] * points[i][0] + points[i][1] * points[i][1]);\\n            map.put(i, distance);\\n        }\\n        \\n        List<Map.Entry<Integer, Double>> sortList = new LinkedList<>(map.entrySet());\\n        Collections.sort(sortList, (a, b) -> a.getValue().compareTo(b.getValue()));\\n        \\n        int[][] ans = new int[K][2];\\n        int i = 0;\\n        for(Map.Entry entry : sortList) {\\n            int key = (int) entry.getKey();\\n            ans[i][0] = points[key][0];\\n            ans[i][1] = points[key][1];\\n            i++;\\n            if(i == K) break;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n \\n\\tprivate int calculateDistance(int[] point) {\\n\\t\\treturn point[0] * point[0] + point[1] * point[1];\\n\\t}\\n \\n\\tpublic int[][] kClosest(int[][] points, int K) {\\n \\n\\t\\tint[] distance = new int[points.length];\\n\\t\\tfor(int i = 0; i < points.length; i++) \\n            distance[i] = calculateDistance(points[i]);\\n \\n\\t\\tArrays.sort(distance);\\n\\t\\tint kthDistance = distance[K - 1];\\n\\t\\tint[][] kClosestPoints = new int[K][2];\\n \\n\\t\\tfor(int i = 0, j = 0; i < points.length && j < K; i++) \\n\\t\\t\\tif(calculateDistance(points[i]) <= kthDistance)\\n\\t\\t\\t\\tkClosestPoints[j++] = points[i];\\n \\n\\t\\treturn kClosestPoints;\\n\\t}\\n}\\n\\n```\n```\\nclass Solution {\\n \\n\\tprivate int calculateDistance(int[] point) {\\n\\t\\treturn point[0] * point[0] + point[1] * point[1];\\n\\t}\\n \\n\\tpublic int[][] kClosest(int[][] points, int K) {\\n \\n\\t\\tPriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> calculateDistance(a) - calculateDistance(b));\\n \\n        for(int[] point : points) \\n            minHeap.offer(point);\\n        \\n\\t\\tint[][] kClosestPoints = new int[K][2];\\n        int i = 0;\\n        while(K-- != 0) \\n            kClosestPoints[i++] = minHeap.poll();\\n\\t\\t\\n\\t\\treturn kClosestPoints;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625549,
                "title": "c-quickselect-solution",
                "content": "**Intuition**\\nQuickselect is a selection algorithm to find the Kth smallest/largest element in an unsorted list. \\n\\nQuickselect uses the same overall approach as Quicksort, choosing one element as the pivot and then partition the elements in two parts: numbers smaller than the pivot are in the first group, numbers greater than or equal to the pivot are in the second group. Unlike Quicksort, Quickselect only recurses into one side that has the element it is searching for.\\n\\n**Complexity**\\n- Time: O(n) in average, O(n^2) in the worst case.\\n   - In worst case, each partitioning only excludes one elements, so the time complexity is n + (n-1) + (n-2) + ... + 2 + 1 = n*(n+1)/2, which is O(n^2).\\n  - In average case, each partitioning excludes half of all the elements, so the time complexity is n + n/2 + n/4 + ... + 1 = 2n*[1-(1/2)^n] < 2n, which is O(n).\\n\\n**Implementation**\\n* C#\\n```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int k) {\\n        \\n        int m = points.Length, n = points[0].Length;\\n        \\n        int left = 0, right = m - 1;\\n        \\n        while(left < right)\\n        {\\n            int pivotIdx = partition(points, left, right);\\n\\n            // the first k points are sorted in non-decreasing order\\n            if(pivotIdx == k - 1)\\n                break;\\n            else if(pivotIdx < k - 1)\\n                left = pivotIdx + 1;\\n            else\\n                right = pivotIdx - 1;\\n        }\\n                \\n        int[][] res = new int[k][];\\n        // copy the first k points from points to res\\n        Array.Copy(points, res, k);\\n        return res;\\n    }\\n    \\n    private int partition(int[][] points, int left, int right)\\n    {\\n        int pivot = distance(points[right]);\\n        \\n        // ensure all points before j are <= pivot\\n        // j always points at the next-to-be-swapped point\\n        int j = left;\\n        for(int i = left ; i < right; i++)\\n        {\\n            if(distance(points[i]) <= pivot)\\n            {\\n                swap(points, i, j);\\n                j++;\\n            }\\n        }\\n        swap(points, j, right);\\n        return j;\\n    }\\n    \\n    private void swap(int[][] points, int i, int j)\\n    {\\n        var tmp = points[i];\\n        points[i] = points[j];\\n        points[j] = tmp;\\n    }\\n    \\n    private int distance(int[] point)\\n    {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n}\\n```\\n\\n* Java\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int m = points.length, n = points[0].length;\\n        \\n        int left = 0, right = m - 1;\\n        \\n        while(left < right)\\n        {\\n            int pivotIdx = partition(points, left, right);\\n\\n            // the first k points are sorted in non-decreasing order\\n            if(pivotIdx == k - 1)\\n                break;\\n            else if(pivotIdx < k - 1)\\n                left = pivotIdx + 1;\\n            else\\n                right = pivotIdx - 1;\\n        }\\n                \\n        int[][] res = new int[k][];\\n        // copy the first k points from points to res\\n        // System.arraycopy(points, 0, res, 0, k);\\n        res = Arrays.copyOf(points, k);\\n        return res;\\n    }\\n    \\n    private int partition(int[][] points, int left, int right)\\n    {\\n        int pivot = distance(points[right]);\\n        \\n        // ensure all points before j are <= pivot\\n        // j always points at the next-to-be-swapped point\\n        int j = left;\\n        for(int i = left ; i < right; i++)\\n        {\\n            if(distance(points[i]) <= pivot)\\n            {\\n                swap(points, i, j);\\n                j++;\\n            }\\n        }\\n        swap(points, j, right);\\n        return j;\\n    }\\n    \\n    private void swap(int[][] points, int i, int j)\\n    {\\n        var tmp = points[i];\\n        points[i] = points[j];\\n        points[j] = tmp;\\n    }\\n    \\n    private int distance(int[] point)\\n    {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int k) {\\n        \\n        int m = points.Length, n = points[0].Length;\\n        \\n        int left = 0, right = m - 1;\\n        \\n        while(left < right)\\n        {\\n            int pivotIdx = partition(points, left, right);\\n\\n            // the first k points are sorted in non-decreasing order\\n            if(pivotIdx == k - 1)\\n                break;\\n            else if(pivotIdx < k - 1)\\n                left = pivotIdx + 1;\\n            else\\n                right = pivotIdx - 1;\\n        }\\n                \\n        int[][] res = new int[k][];\\n        // copy the first k points from points to res\\n        Array.Copy(points, res, k);\\n        return res;\\n    }\\n    \\n    private int partition(int[][] points, int left, int right)\\n    {\\n        int pivot = distance(points[right]);\\n        \\n        // ensure all points before j are <= pivot\\n        // j always points at the next-to-be-swapped point\\n        int j = left;\\n        for(int i = left ; i < right; i++)\\n        {\\n            if(distance(points[i]) <= pivot)\\n            {\\n                swap(points, i, j);\\n                j++;\\n            }\\n        }\\n        swap(points, j, right);\\n        return j;\\n    }\\n    \\n    private void swap(int[][] points, int i, int j)\\n    {\\n        var tmp = points[i];\\n        points[i] = points[j];\\n        points[j] = tmp;\\n    }\\n    \\n    private int distance(int[] point)\\n    {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int m = points.length, n = points[0].length;\\n        \\n        int left = 0, right = m - 1;\\n        \\n        while(left < right)\\n        {\\n            int pivotIdx = partition(points, left, right);\\n\\n            // the first k points are sorted in non-decreasing order\\n            if(pivotIdx == k - 1)\\n                break;\\n            else if(pivotIdx < k - 1)\\n                left = pivotIdx + 1;\\n            else\\n                right = pivotIdx - 1;\\n        }\\n                \\n        int[][] res = new int[k][];\\n        // copy the first k points from points to res\\n        // System.arraycopy(points, 0, res, 0, k);\\n        res = Arrays.copyOf(points, k);\\n        return res;\\n    }\\n    \\n    private int partition(int[][] points, int left, int right)\\n    {\\n        int pivot = distance(points[right]);\\n        \\n        // ensure all points before j are <= pivot\\n        // j always points at the next-to-be-swapped point\\n        int j = left;\\n        for(int i = left ; i < right; i++)\\n        {\\n            if(distance(points[i]) <= pivot)\\n            {\\n                swap(points, i, j);\\n                j++;\\n            }\\n        }\\n        swap(points, j, right);\\n        return j;\\n    }\\n    \\n    private void swap(int[][] points, int i, int j)\\n    {\\n        var tmp = points[i];\\n        points[i] = points[j];\\n        points[j] = tmp;\\n    }\\n    \\n    private int distance(int[] point)\\n    {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224542,
                "title": "python-3-faster-than-100-one-line",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return sorted(points, key=lambda e: e[0]**2+e[1]**2)[0:K]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return sorted(points, key=lambda e: e[0]**2+e[1]**2)[0:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664669,
                "title": "priority-queue-c-beats-95",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple just calculate the distance from the origin and use Priority Queue to store the distance and index value.\\n\\n# Complexity\\n- Time complexity:O(N * Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& p, int k) {\\n\\n        priority_queue<pair<int,int>> pq;\\n        for(int i = 0;i<p.size();i++)\\n        {\\n            int dist = p[i][0]*p[i][0]+p[i][1]*p[i][1];\\n            pq.push({-1*dist,i});\\n        }\\n        vector<vector<int>> ans;\\n        while(k--)\\n        {\\n            auto x = pq.top();\\n            pq.pop();\\n            ans.push_back(p[x.second]);\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/3a00f256-670c-47a7-bc3b-edbc68341162_1687333025.0930696.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& p, int k) {\\n\\n        priority_queue<pair<int,int>> pq;\\n        for(int i = 0;i<p.size();i++)\\n        {\\n            int dist = p[i][0]*p[i][0]+p[i][1]*p[i][1];\\n            pq.push({-1*dist,i});\\n        }\\n        vector<vector<int>> ans;\\n        while(k--)\\n        {\\n            auto x = pq.top();\\n            pq.pop();\\n            ans.push_back(p[x.second]);\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648763,
                "title": "python-simple-quick-select-detailed-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* **Standard QuickSelect Algorithm**(like QuickSort)\\n* Given a sequence `seq` and a positive number `k`, we need to find out the top `k` elements from `seq`.\\n\\t* **Randomly** select a `pivot` from the current `seq`\\n\\t\\t* random selection is very important, on average, this can effectively deal with the worst case.\\n\\t* Traverse `seq` one by one, count how many elements less than or greater than or equal to the pivot respectively.\\n\\t* There are 3 different situations\\n\\t\\t* `k <= len(less)`\\n\\t\\t\\t* that means you can find all top `k` elements in `less` recursively.\\n\\t\\t* `len(less) < k <= len(less) + len(equal)`\\n\\t\\t\\t* congratulations! `pivot` is the k-th element, note to handle equal situations carefully.\\n\\t\\t* `k > len(less) + len(equal)`\\n\\t\\t\\t* Not bad. you have already found the top `len(less) + len(equal)` elements.\\n\\t\\t\\t* you can find out the left `k - len(less) + len(equal)` top elements from `greater` recursively.\\n\\n```\\nclass Solution(object):\\n    def kClosest(self, points, k):\\n        def quickSelect(points, k):\\n            less, equal, greater = [], [], []\\n            pivot = random.choice(points)\\n            pivot_l2 = pivot[0] ** 2 + pivot[1] ** 2\\n            for p in points:\\n                p_l2 = p[0] ** 2 + p[1] ** 2\\n                if p_l2 < pivot_l2:\\n                    less.append(p)\\n                elif p_l2 > pivot_l2:\\n                    greater.append(p)\\n                else:\\n                    equal.append(p)\\n            if len(less) < k <= len(less) + len(equal):\\n                return less + equal[:k - len(less)]\\n            elif k <= len(less):\\n                return quickSelect(less, k)\\n            else:\\n                return less + equal + quickSelect(greater, k - len(less) - len(equal))\\n\\t\\t\\t\\t\\n        return quickSelect(points, k)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def kClosest(self, points, k):\\n        def quickSelect(points, k):\\n            less, equal, greater = [], [], []\\n            pivot = random.choice(points)\\n            pivot_l2 = pivot[0] ** 2 + pivot[1] ** 2\\n            for p in points:\\n                p_l2 = p[0] ** 2 + p[1] ** 2\\n                if p_l2 < pivot_l2:\\n                    less.append(p)\\n                elif p_l2 > pivot_l2:\\n                    greater.append(p)\\n                else:\\n                    equal.append(p)\\n            if len(less) < k <= len(less) + len(equal):\\n                return less + equal[:k - len(less)]\\n            elif k <= len(less):\\n                return quickSelect(less, k)\\n            else:\\n                return less + equal + quickSelect(greater, k - len(less) - len(equal))\\n\\t\\t\\t\\t\\n        return quickSelect(points, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659832,
                "title": "c-presice-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n         vector<vector<int>> kClosest(vector<vector<int>> &p, int k) {\\n         multimap<int,int> m;\\n         for(int i=0; i<p.size();i++)\\n         m.insert({p[i][0]*p[i][0]+p[i][1]*p[i][1],i});\\n         vector<vector<int>>v;\\n         for(auto it=m.begin();k>0;it++,k--) \\n         v.push_back(p[it->second]);\\n         return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n         vector<vector<int>> kClosest(vector<vector<int>> &p, int k) {\\n         multimap<int,int> m;\\n         for(int i=0; i<p.size();i++)\\n         m.insert({p[i][0]*p[i][0]+p[i][1]*p[i][1],i});\\n         vector<vector<int>>v;\\n         for(auto it=m.begin();k>0;it++,k--) \\n         v.push_back(p[it->second]);\\n         return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218691,
                "title": "o-n-java-using-quick-select-beats-100",
                "content": "Similar to LC 215\\n```\\nclass Solution {\\n    private Random random = new Random();\\n    public int[][] kClosest(int[][] points, int K) {\\n        int start = 0, end = points.length - 1;\\n        int index = 0;\\n        while (start <= end) {\\n            index = partition(points, start, end);\\n            if (index == K) {\\n                break;\\n            }\\n            if (index > K) {\\n                end = index - 1;\\n            } else {\\n                start = index + 1;\\n            }\\n        }\\n        int[][] result = new int[index][2];\\n        for (int i = 0; i < index; i++) {\\n            result[i] = points[i];\\n        }\\n        return result;\\n    }\\n    \\n    private int partition(int[][] points, int start, int end) {\\n        int rd = start + random.nextInt(end - start + 1);\\n        int[] target = points[rd];\\n        swap(points, rd, end);\\n        int left = start, right = end - 1;\\n        while (left <= right) {\\n            while (left <= right && !isLarger(points[left], target)) left++;\\n            while (left <= right && isLarger(points[right], target)) right--;\\n            if (left <= right) {\\n                swap(points, left, right);\\n                left++;\\n                right--;\\n            }\\n        }\\n        swap(points, left, end);\\n        return left;\\n    }\\n    \\n    private void swap(int[][] points, int i1, int i2) {\\n        int[] temp = points[i1];\\n        points[i1] = points[i2];\\n        points[i2] = temp;\\n    }\\n    \\n    // return true if p1 dist is larger than p2\\n    private boolean isLarger(int[] p1, int[] p2) {\\n        return p1[0] * p1[0] + p1[1] * p1[1] > p2[0] * p2[0] + p2[1] * p2[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Random random = new Random();\\n    public int[][] kClosest(int[][] points, int K) {\\n        int start = 0, end = points.length - 1;\\n        int index = 0;\\n        while (start <= end) {\\n            index = partition(points, start, end);\\n            if (index == K) {\\n                break;\\n            }\\n            if (index > K) {\\n                end = index - 1;\\n            } else {\\n                start = index + 1;\\n            }\\n        }\\n        int[][] result = new int[index][2];\\n        for (int i = 0; i < index; i++) {\\n            result[i] = points[i];\\n        }\\n        return result;\\n    }\\n    \\n    private int partition(int[][] points, int start, int end) {\\n        int rd = start + random.nextInt(end - start + 1);\\n        int[] target = points[rd];\\n        swap(points, rd, end);\\n        int left = start, right = end - 1;\\n        while (left <= right) {\\n            while (left <= right && !isLarger(points[left], target)) left++;\\n            while (left <= right && isLarger(points[right], target)) right--;\\n            if (left <= right) {\\n                swap(points, left, right);\\n                left++;\\n                right--;\\n            }\\n        }\\n        swap(points, left, end);\\n        return left;\\n    }\\n    \\n    private void swap(int[][] points, int i1, int i2) {\\n        int[] temp = points[i1];\\n        points[i1] = points[i2];\\n        points[i2] = temp;\\n    }\\n    \\n    // return true if p1 dist is larger than p2\\n    private boolean isLarger(int[] p1, int[] p2) {\\n        return p1[0] * p1[0] + p1[1] * p1[1] > p2[0] * p2[0] + p2[1] * p2[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239208,
                "title": "javascript-solution",
                "content": "```\\nvar kClosest = function(points, K) {\\n    quickSelect(points, K, 0, points.length - 1)\\n    return points.slice(0, K)\\n};\\n\\nfunction quickSelect(points, K, low, high) {\\n    if (low >= high) {\\n        return\\n    }\\n    \\n    const partPoint = partition(points, low, high)\\n    \\n    if (partPoint === K - 1) {\\n        return\\n    }\\n    if (partPoint < K - 1) {\\n        quickSelect(points, K, partPoint + 1, high)\\n    } else {\\n        quickSelect(points, K, low, partPoint - 1)\\n    }\\n}\\n\\nfunction partition(points, low, high) {\\n    const pivot = points[high]\\n    let i = low\\n    let j = low\\n    while (i < high) {\\n        if (getDist(points[i]) < getDist(pivot)) {\\n            swap(points, i, j)\\n            j++\\n        }\\n        i++\\n    }\\n    swap(points, high, j)\\n    return j\\n}\\n\\nfunction getDist(point) {\\n    return point[0] * point[0] + point[1] * point[1]\\n}\\n\\nfunction swap(arr, i, j) {\\n    const temp = arr[i] \\n    arr[i] = arr[j]\\n    arr[j] = temp\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar kClosest = function(points, K) {\\n    quickSelect(points, K, 0, points.length - 1)\\n    return points.slice(0, K)\\n};\\n\\nfunction quickSelect(points, K, low, high) {\\n    if (low >= high) {\\n        return\\n    }\\n    \\n    const partPoint = partition(points, low, high)\\n    \\n    if (partPoint === K - 1) {\\n        return\\n    }\\n    if (partPoint < K - 1) {\\n        quickSelect(points, K, partPoint + 1, high)\\n    } else {\\n        quickSelect(points, K, low, partPoint - 1)\\n    }\\n}\\n\\nfunction partition(points, low, high) {\\n    const pivot = points[high]\\n    let i = low\\n    let j = low\\n    while (i < high) {\\n        if (getDist(points[i]) < getDist(pivot)) {\\n            swap(points, i, j)\\n            j++\\n        }\\n        i++\\n    }\\n    swap(points, high, j)\\n    return j\\n}\\n\\nfunction getDist(point) {\\n    return point[0] * point[0] + point[1] * point[1]\\n}\\n\\nfunction swap(arr, i, j) {\\n    const temp = arr[i] \\n    arr[i] = arr[j]\\n    arr[j] = temp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 660023,
                "title": "javascript",
                "content": "```\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0] ** 2 + a[1] ** 2) - (b[0] ** 2 + b[1] ** 2));\\n    return points.slice(0, K);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0] ** 2 + a[1] ** 2) - (b[0] ** 2 + b[1] ** 2));\\n    return points.slice(0, K);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482892,
                "title": "c",
                "content": "```\\npublic int[][] KClosest(int[][] points, int K)\\n\\t=> points.OrderBy(p => p[0] * p[0] + p[1] * p[1]).Take(K).ToArray();\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] KClosest(int[][] points, int K)\\n\\t=> points.OrderBy(p => p[0] * p[0] + p[1] * p[1]).Take(K).ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218974,
                "title": "c-1-line",
                "content": "```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int K) {\\n        return points.OrderBy(p => p[0] * p[0] + p[1] * p[1]).Take(K).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int K) {\\n        return points.OrderBy(p => p[0] * p[0] + p[1] * p[1]).Take(K).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556983,
                "title": "python3-maxheap-short-beats-97",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        maxHeap = []\\n        for id, p in enumerate(points):\\n            d = p[0] * p[0] + p[1] * p[1]\\n            if len(maxHeap) < k:\\n                heappush(maxHeap, (-d, id))\\n            else:\\n                heappushpop(maxHeap, (-d, id))\\n\\n        return [points[id] for _, id in maxHeap]        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        maxHeap = []\\n        for id, p in enumerate(points):\\n            d = p[0] * p[0] + p[1] * p[1]\\n            if len(maxHeap) < k:\\n                heappush(maxHeap, (-d, id))\\n            else:\\n                heappushpop(maxHeap, (-d, id))\\n\\n        return [points[id] for _, id in maxHeap]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252785,
                "title": "javascript-min-heap-priorityqueue-east-and-clean",
                "content": "```\\nvar kClosest = function(points, k) {\\n    const res = []\\n    const minHeap = new MinPriorityQueue()\\n    points.forEach(p => {\\n        const distanceFromOrigin = Math.sqrt(p[0] * p[0] + p[1] * p[1])\\n        minHeap.enqueue(p, distanceFromOrigin)\\n    })\\n    while(res.length < k) res.push(minHeap.dequeue().element)\\n    return res\\n    // O(Nlog(K)) time O(N) space\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kClosest = function(points, k) {\\n    const res = []\\n    const minHeap = new MinPriorityQueue()\\n    points.forEach(p => {\\n        const distanceFromOrigin = Math.sqrt(p[0] * p[0] + p[1] * p[1])\\n        minHeap.enqueue(p, distanceFromOrigin)\\n    })\\n    while(res.length < k) res.push(minHeap.dequeue().element)\\n    return res\\n    // O(Nlog(K)) time O(N) space\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647325,
                "title": "python3-one-liner-explained",
                "content": "We sort the given list of points by their distance from the origin and then return k first results.\\n\\nTime: **O(NlogN)** - for the sorting\\nSpace: **O(N)** - Python sorting\\n\\nRuntime: 628 ms, faster than **93.32%** of Python3 online submissions for K Closest Points to Origin.\\nMemory Usage: 19.5 MB, less than **99.08%** of Python3 online submissions for K Closest Points to Origin.\\n\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[0:k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[0:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271187,
                "title": "easy-c-solution-commented",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        //we will store the distance of each point from the origin with the index in the max heap\\n        priority_queue<pair<int,int>> pq;\\n        \\n        //if sqrt(x) > sqrt(y) then obviously x>y\\n        //so we dont need to do the sqrt operation for finding the distance\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            int dist=(x*x)+(y*y);\\n            pq.push({dist,i});\\n            //we only need k closest \\n            //so we only consider the k points to store in the pq\\n            //as pq is max heap the longest distance from the origin is popped out\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        vector<vector<int>> res;\\n        while(!pq.empty())\\n        {\\n            auto [val,ind]=pq.top();\\n            pq.pop();\\n            res.push_back(points[ind]);\\n        }\\n        return res;\\n        \\n    }\\n    \\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        //we will store the distance of each point from the origin with the index in the max heap\\n        priority_queue<pair<int,int>> pq;\\n        \\n        //if sqrt(x) > sqrt(y) then obviously x>y\\n        //so we dont need to do the sqrt operation for finding the distance\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            int dist=(x*x)+(y*y);\\n            pq.push({dist,i});\\n            //we only need k closest \\n            //so we only consider the k points to store in the pq\\n            //as pq is max heap the longest distance from the origin is popped out\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        vector<vector<int>> res;\\n        while(!pq.empty())\\n        {\\n            auto [val,ind]=pq.top();\\n            pq.pop();\\n            res.push_back(points[ind]);\\n        }\\n        return res;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174480,
                "title": "java-explaining-maxheap-and-quickselect-approaches-with-detailed-comments-and-intuition",
                "content": "First, we need to understand the rationale of using efficient algorithm to solve the problem. An algorithm better than quadratic time is not good enough because in real world, N can be a very large number compared to k. In that case, if we use pure sorting, NlogN time complexity will actually be pretty bad. \\nNow we also need to understand that the problem did not ask us to return all the points in sorted fashion, they just wanted \"k\" closest in *any* order. This is really our biggest clue.\\n\\nAs a first option, we can think of using a **heap** which tracks the min or max element of the set with constant retrieval complexity. The trick here is we need to limit the size of the heap to \\'k\\' again for the above reason, since insertion time is logarithmic to the number of elements in the heap. Rest of the logic is explained in the code.\\n\\nThe runtime of this algorithm is approximately bounded by Nlog(k) since we are doing N heap insertions with the heap size growing to max of k + 1 ~ k.\\nI would say this is our preferred solution if we do not need to know the full data set in advance, like a streaming data set. Also, the output of the solution will be sorted because every time we are retrieving the maximum element from the heap and are adding it to the back of our array. So the sorting is **stable**.\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        if (points.length < k) {\\n            // We can never have a solution since not enough points\\n            return new int[0][0];\\n        }\\n        \\n        // Important: we maintain a maxHeap instead of a minHeap. With max heap, we can\\n        // use an important invariant: the top element of max heap is ALWAYS the largest element\\n        // So as we insert points, and the maxHeap grows larger than k, we can pop off\\n        // the largest element found so far - this signifies the furthest point in our set\\n        // That way we are left with points that are least furthest, or in other words the points\\n        // that are nearest\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(\\n        (p1, p2) -> Double.compare(Math.sqrt(p2[0]*p2[0] + p2[1]*p2[1]), Math.sqrt(p1[0]*p1[0] + p1[1]*p1[1])));\\n        for (int[] point : points) {\\n            maxHeap.offer(point);\\n            if (maxHeap.size() > k) {\\n                maxHeap.poll();\\n            }\\n        }\\n        // Returning the elements from the max heap\\n        int[][] closestPoints = new int[k][];\\n        while (k > 0) {\\n            closestPoints[k - 1] = maxHeap.poll();\\n            k--;\\n        }\\n        return closestPoints;\\n    }\\n}\\n```\\n\\nThe above solution is good, but we can make it better if we consider the returned points need not be in any order and if the whole data set is already available to us for our analysis beforehand. There is a nifty algorithm called QuickSelect which is a variation of QuickSort. I have found wikipedia has a fairly good explanation of the algorithm.\\n\\nThis algorithm runs with O(n) time complexity in average, but like QuickSort has worst case time complexity of O(n^2). This is an **unstable** sort algorithm, but it works well in our case. In LeetCode this approach easily beats 80-84% of other solutions depending on when you are running the solution!\\n\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        if (points.length < k) {\\n            return new int[0][0];\\n        }\\n        Comparator<int[]> comp = (p1, p2) ->\\n            Double.compare(Math.sqrt(p1[0]*p1[0] + p1[1]*p1[1]), Math.sqrt(p2[0]*p2[0] + p2[1]*p2[1]));\\n        int left = 0;\\n        int right = points.length - 1;\\n        \\n        while (left < right) {\\n            int pivot = findPartition(points, left, right, comp);\\n            if (pivot < k) {\\n                // Our answer lies to the right of the pivot\\n                left = pivot + 1;\\n            }\\n            else if (pivot > k) {\\n                // our answer lies to the left of the pivot\\n                right = pivot - 1;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n    \\n    // Core QuickSelect algorithm\\n    // I found Wikipedia article explains it pretty well, and most\\n    // helpful for me was the GIF explaining the process\\n    // https://en.wikipedia.org/wiki/Quickselect#/media/File:Selecting_quickselect_frames.gif\\n    // Basically, we compare ALL elements in our range with the extreme right element of the range\\n    // This explains why \\'index\\' DOES NOT include \\'right\\'\\n    // After the loop runs, we ensure that every element within our range and to the left\\n    // of the \\'left\\' index are less than the element at the \\'right\\' index\\n    // After the loop, we bring the element of the \\'right\\' index at \\'left\\' index.\\n    // All placements are in-place swapping\\n    // We can use lambda to define a one-line comparator and we can pass this comparator\\n    // every time we call this function. This saves us from defining another function\\n    // Also, better not define an anonymous custom comparator every time this function is called\\n    // as this is not the best use of CPU and memory\\n    public int findPartition(int[][] points, int left, int right, Comparator<int[]> comp) {\\n        for (int index = left; index < right; index++) {\\n            if (comp.compare(points[index], points[right]) < 0) {\\n                // We make sure \\'left\\' is the boundary of all elements which are lesser than\\n                // the element at \\'right\\'\\n                swap(points, left, index);\\n                left++;\\n            }\\n        }\\n        swap(points, left, right);\\n        return left;\\n    }\\n    \\n    // Simple swap function. I still prefer this over the XOR way of swapping\\n    // since this is more explicit and less error prone especially in interview\\n    // context\\n    public void swap(int[][] points, int left, int right) {\\n        int tempx = points[left][0];\\n        int tempy = points[left][1];\\n        \\n        points[left][0] = points[right][0];\\n        points[left][1] = points[right][1];\\n        points[right][0] = tempx;\\n        points[right][1] = tempy;\\n    }\\n}\\n```\\n\\nAnother note: please refrain from using a \"-\" while comparing values in comparator, and rely on standard functions to do so. This is to prevent (unlikely) overflows, and also better readability of the code.\\n\\nLike I explained in some of my other articles, it is important to \"arrive\" at a solution during the interview instead of just memorizing solutions. The thought process is as important to the interviewer as the working code. When I am interviewing, I put more weight on thought process over the working code (or syntactical errors). Hope this article helps!",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        if (points.length < k) {\\n            // We can never have a solution since not enough points\\n            return new int[0][0];\\n        }\\n        \\n        // Important: we maintain a maxHeap instead of a minHeap. With max heap, we can\\n        // use an important invariant: the top element of max heap is ALWAYS the largest element\\n        // So as we insert points, and the maxHeap grows larger than k, we can pop off\\n        // the largest element found so far - this signifies the furthest point in our set\\n        // That way we are left with points that are least furthest, or in other words the points\\n        // that are nearest\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(\\n        (p1, p2) -> Double.compare(Math.sqrt(p2[0]*p2[0] + p2[1]*p2[1]), Math.sqrt(p1[0]*p1[0] + p1[1]*p1[1])));\\n        for (int[] point : points) {\\n            maxHeap.offer(point);\\n            if (maxHeap.size() > k) {\\n                maxHeap.poll();\\n            }\\n        }\\n        // Returning the elements from the max heap\\n        int[][] closestPoints = new int[k][];\\n        while (k > 0) {\\n            closestPoints[k - 1] = maxHeap.poll();\\n            k--;\\n        }\\n        return closestPoints;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        if (points.length < k) {\\n            return new int[0][0];\\n        }\\n        Comparator<int[]> comp = (p1, p2) ->\\n            Double.compare(Math.sqrt(p1[0]*p1[0] + p1[1]*p1[1]), Math.sqrt(p2[0]*p2[0] + p2[1]*p2[1]));\\n        int left = 0;\\n        int right = points.length - 1;\\n        \\n        while (left < right) {\\n            int pivot = findPartition(points, left, right, comp);\\n            if (pivot < k) {\\n                // Our answer lies to the right of the pivot\\n                left = pivot + 1;\\n            }\\n            else if (pivot > k) {\\n                // our answer lies to the left of the pivot\\n                right = pivot - 1;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n    \\n    // Core QuickSelect algorithm\\n    // I found Wikipedia article explains it pretty well, and most\\n    // helpful for me was the GIF explaining the process\\n    // https://en.wikipedia.org/wiki/Quickselect#/media/File:Selecting_quickselect_frames.gif\\n    // Basically, we compare ALL elements in our range with the extreme right element of the range\\n    // This explains why \\'index\\' DOES NOT include \\'right\\'\\n    // After the loop runs, we ensure that every element within our range and to the left\\n    // of the \\'left\\' index are less than the element at the \\'right\\' index\\n    // After the loop, we bring the element of the \\'right\\' index at \\'left\\' index.\\n    // All placements are in-place swapping\\n    // We can use lambda to define a one-line comparator and we can pass this comparator\\n    // every time we call this function. This saves us from defining another function\\n    // Also, better not define an anonymous custom comparator every time this function is called\\n    // as this is not the best use of CPU and memory\\n    public int findPartition(int[][] points, int left, int right, Comparator<int[]> comp) {\\n        for (int index = left; index < right; index++) {\\n            if (comp.compare(points[index], points[right]) < 0) {\\n                // We make sure \\'left\\' is the boundary of all elements which are lesser than\\n                // the element at \\'right\\'\\n                swap(points, left, index);\\n                left++;\\n            }\\n        }\\n        swap(points, left, right);\\n        return left;\\n    }\\n    \\n    // Simple swap function. I still prefer this over the XOR way of swapping\\n    // since this is more explicit and less error prone especially in interview\\n    // context\\n    public void swap(int[][] points, int left, int right) {\\n        int tempx = points[left][0];\\n        int tempy = points[left][1];\\n        \\n        points[left][0] = points[right][0];\\n        points[left][1] = points[right][1];\\n        points[right][0] = tempx;\\n        points[right][1] = tempy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988655,
                "title": "java-quick-select-o-n-avg-2ms",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        //one method is to use PQ of size k, O(NlogK)\\n        //other is quick select avg case O(n), worse O(n^2)\\n        \\n        quick(points, 0, points.length - 1,K);   \\n        return Arrays.copyOfRange(points, 0 ,K);\\n    }\\n    \\n\\t//similar to quick sort algo. but we recurse for either left or right side\\n    private void quick(int[][] arr, int l, int h, int k ){\\n        if(l>=h) return;\\n        int p = partition(arr, l, h);\\n        \\n        if(p== (k-1))\\n            return;\\n        else if(p < k-1)\\n            quick(arr, p+1,h,k);\\n        else\\n            quick(arr, l, p-1,k);\\n            \\n    }\\n    \\n    private int partition(int[][] arr, int l, int h){\\n       int pivot = distance(arr[h]);\\n        int i = l-1;\\n        for(int j = l; j<h; j++){\\n            if(distance(arr[j]) < pivot){\\n                swap(arr, ++i, j);\\n            }\\n        }\\n        swap(arr, ++i, h);\\n        return i;\\n    }\\n    \\n    private void swap(int[][] arr, int i, int j){\\n        int[] temp =arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int distance(int[] x) {\\n        return x[0]*x[0] + x[1]*x[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        //one method is to use PQ of size k, O(NlogK)\\n        //other is quick select avg case O(n), worse O(n^2)\\n        \\n        quick(points, 0, points.length - 1,K);   \\n        return Arrays.copyOfRange(points, 0 ,K);\\n    }\\n    \\n\\t//similar to quick sort algo. but we recurse for either left or right side\\n    private void quick(int[][] arr, int l, int h, int k ){\\n        if(l>=h) return;\\n        int p = partition(arr, l, h);\\n        \\n        if(p== (k-1))\\n            return;\\n        else if(p < k-1)\\n            quick(arr, p+1,h,k);\\n        else\\n            quick(arr, l, p-1,k);\\n            \\n    }\\n    \\n    private int partition(int[][] arr, int l, int h){\\n       int pivot = distance(arr[h]);\\n        int i = l-1;\\n        for(int j = l; j<h; j++){\\n            if(distance(arr[j]) < pivot){\\n                swap(arr, ++i, j);\\n            }\\n        }\\n        swap(arr, ++i, h);\\n        return i;\\n    }\\n    \\n    private void swap(int[][] arr, int i, int j){\\n        int[] temp =arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int distance(int[] x) {\\n        return x[0]*x[0] + x[1]*x[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234204,
                "title": "swift-no-brainer",
                "content": "```\\nfinal class Solution {\\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\\n        let sortedPoints = points.sorted {\\n            ($0[0] * $0[0] + $0[1] * $0[1]) < ($1[0] * $1[0] + $1[1] * $1[1])\\n        }\\n        return Array(sortedPoints.prefix(K))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfinal class Solution {\\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\\n        let sortedPoints = points.sorted {\\n            ($0[0] * $0[0] + $0[1] * $0[1]) < ($1[0] * $1[0] + $1[1] * $1[1])\\n        }\\n        return Array(sortedPoints.prefix(K))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647721,
                "title": "c-sorting-using-comparator-function-easiest-to-understand",
                "content": "```\\nbool comp(vector<int>&a,vector<int>&b){\\n    int d1=a[0]*a[0]+a[1]*a[1]; \\n    int d2=b[0]*b[0]+b[1]*b[1]; \\n    \\n    return d1<d2; \\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n   \\n        vector<vector<int>>ans; \\n\\t\\t\\n        sort(points.begin(),points.end(),comp); \\n        \\n        for(int i=0;i<k;i++){\\n            ans.push_back(points[i]); \\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>&a,vector<int>&b){\\n    int d1=a[0]*a[0]+a[1]*a[1]; \\n    int d2=b[0]*b[0]+b[1]*b[1]; \\n    \\n    return d1<d2; \\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n   \\n        vector<vector<int>>ans; \\n\\t\\t\\n        sort(points.begin(),points.end(),comp); \\n        \\n        for(int i=0;i<k;i++){\\n            ans.push_back(points[i]); \\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461651,
                "title": "python-solutions-in-o-n-o-nlogk-o-klogn-and-o-nlogn",
                "content": "__Solution 1__: Sort array based on distances.\\n```\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(nlogn)\\n\\t res = [([x,y], x**2+y**2) for x,y in points]\\n\\t res, _ = zip(*sorted(res, key=lambda x:x[1]))\\n\\t return res[:k]\\t\\t\\n```\\n__Solution 2__: Use a heap of size N and pop the K smallest elements. Time complexity is `O(KlogN)`. This is possible because heapify runs in `O(N)`. \\n```       \\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(klogn)\\n\\t res = [0]*k\\n\\t q = [(x**2+y**2, [x,y]) for x,y in points]\\n\\t heapq.heapify(q)\\n\\t for i in range(k):\\n\\t\\t _, point = heapq.heappop(q)\\n\\t\\t res[i] = point\\n\\t return res\\n```\\n__Solution 3__: Use a heap of size K and iterate over N. The time complexity is `O(NlogK)`.\\n```   \\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(nlogk)\\n\\t q = [(-x**2-y**2, [x,y]) for x,y in points]\\n\\t h = q[:k]\\n\\t heapq.heapify(h)\\n\\t for w,point in q[k:]:\\n\\t\\t if w > h[0][0]:\\n\\t\\t\\t heapq.heapreplace(h, (w, point))\\n\\t _, p = zip(*h)\\n\\t return p\\n```\\n__Solution 4__: Standard quickselect algorithm to find nlargest or nsmallest element in an array. Time complexity is `O(N)`. We are on average halving the search space every iteration. \\n```\\t\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(n)\\n\\t def quickselect(arr, l, r, k):\\n\\t\\t p = partition(arr, l, r)\\n\\t\\t if p < k: \\n\\t\\t\\t return quickselect(arr, p+1, r, k)\\n\\t\\t elif p > k: \\n\\t\\t\\t return quickselect(arr, l, p-1, k)\\n\\t\\t else:\\n\\t\\t\\t _, ans = zip(*arr[:k+1])\\n\\t\\t\\t return ans\\n\\t \\n\\t def partition(arr, l, r):\\n\\t\\t rand = random.randint(l, r)\\n\\t\\t arr[rand], arr[r] = arr[r], arr[rand]\\n\\t\\t pivot = arr[r]\\n\\t\\t i = l\\n\\t\\t for j in range(l, r):\\n\\t\\t\\t if arr[j][0] <= pivot[0]:\\n\\t\\t\\t\\t arr[j], arr[i] = arr[i], arr[j]\\n\\t\\t\\t\\t i += 1\\n\\t\\t arr[r], arr[i] = arr[i], arr[r]\\n\\t\\t return i\\n\\t q = [(x**2+y**2, [x,y]) for x,y in points]\\n\\t return quickselect(q, 0, len(points)-1, k-1)\\n```\\n",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(nlogn)\\n\\t res = [([x,y], x**2+y**2) for x,y in points]\\n\\t res, _ = zip(*sorted(res, key=lambda x:x[1]))\\n\\t return res[:k]\\t\\t\\n```\n```       \\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(klogn)\\n\\t res = [0]*k\\n\\t q = [(x**2+y**2, [x,y]) for x,y in points]\\n\\t heapq.heapify(q)\\n\\t for i in range(k):\\n\\t\\t _, point = heapq.heappop(q)\\n\\t\\t res[i] = point\\n\\t return res\\n```\n```   \\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(nlogk)\\n\\t q = [(-x**2-y**2, [x,y]) for x,y in points]\\n\\t h = q[:k]\\n\\t heapq.heapify(h)\\n\\t for w,point in q[k:]:\\n\\t\\t if w > h[0][0]:\\n\\t\\t\\t heapq.heapreplace(h, (w, point))\\n\\t _, p = zip(*h)\\n\\t return p\\n```\n```\\t\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(n)\\n\\t def quickselect(arr, l, r, k):\\n\\t\\t p = partition(arr, l, r)\\n\\t\\t if p < k: \\n\\t\\t\\t return quickselect(arr, p+1, r, k)\\n\\t\\t elif p > k: \\n\\t\\t\\t return quickselect(arr, l, p-1, k)\\n\\t\\t else:\\n\\t\\t\\t _, ans = zip(*arr[:k+1])\\n\\t\\t\\t return ans\\n\\t \\n\\t def partition(arr, l, r):\\n\\t\\t rand = random.randint(l, r)\\n\\t\\t arr[rand], arr[r] = arr[r], arr[rand]\\n\\t\\t pivot = arr[r]\\n\\t\\t i = l\\n\\t\\t for j in range(l, r):\\n\\t\\t\\t if arr[j][0] <= pivot[0]:\\n\\t\\t\\t\\t arr[j], arr[i] = arr[i], arr[j]\\n\\t\\t\\t\\t i += 1\\n\\t\\t arr[r], arr[i] = arr[i], arr[r]\\n\\t\\t return i\\n\\t q = [(x**2+y**2, [x,y]) for x,y in points]\\n\\t return quickselect(q, 0, len(points)-1, k-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1255142,
                "title": "c-easy-production-ready-code-solution-using-priority-queue-and-operator-overloading",
                "content": "Since we can do operator overloading on user defined objects so create a class `Point` and do` <` opeartor overloading to sort elements in priority queue using distance formula. Please read comments for more explanation. \\n```\\n/*\\n* Point class, used to overload \\n* operator< for used defined object of \\n* class Point.\\n*/\\nclass Point {\\n  public:\\n    int x;\\n    int y;\\n    Point(int x, int y) {\\n        this->x = x;\\n        this->y = y;\\n    }\\n};\\n\\n/*\\n* Opeartor< overloading -> when this(<) operator is \\n* used to compare two objects in priority queue\\n* it will compare based on distance formula \\n* if (x1*x1 y1*y1) > (x2*x2 + y2*y2) means first point\\n* is more near to origion than second point\\n*/\\nbool operator<(const Point &v1, const Point &v2){\\n    return (v1.x * v1.x + v1.y * v1.y) > (v2.x * v2.x + v2.y * v2.y);\\n}\\n    \\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        /*\\n        * Put all points in priority queue\\n        */\\n        priority_queue<Point> pq;\\n        for(int i=0;i<points.size();i++){\\n            pq.push(Point(points[i][0], points[i][1]));\\n        }\\n        \\n        /*\\n        * Add top k elements from priority queue to \\n        * ans vector\\n        */\\n        vector<vector<int>>  ans;\\n        int i = 0;\\n        while(i++ < k) {\\n            // Add point to ans vector by constructing a vector\\n            vector<int> temp = {pq.top().x, pq.top().y};\\n            ans.push_back(temp);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Another similar implementation could be as below:**\\n```\\n/*\\n* Define class template to pass in priority queue \\n* constructor, it overrides () operator\\n*/\\nclass Compare {\\npublic:\\n    bool operator()(const vector<int> &v1, const vector<int> &v2) {\\n        return (v1[0] * v1[0] + v1[1] * v1[1]) > (v2[0] * v2[0] + v2[1] * v2[1]);\\n    }\\n};\\n    \\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        /*\\n        * Pass Compare class template\\n        * Note it shouldn\\'t be a function as we use in sort() \\n        * method cause priority queue accepts this last param\\n        * only as class template\\n        */\\n        priority_queue<vector<int>, vector<vector<int>>, Compare> pq;\\n        for(int i=0;i<points.size();i++){\\n            pq.push(points[i]);\\n        }\\n        \\n        // Add top k elements from queue to ans vector\\n        vector<vector<int>>  ans;\\n        int i = 0;\\n        while(i++ < k) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Thanks for reading. Hope it helps. Please hit upvote button if you really find it helpful. Cheers!!**\\n*~Sadul Khod*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\n* Point class, used to overload \\n* operator< for used defined object of \\n* class Point.\\n*/\\nclass Point {\\n  public:\\n    int x;\\n    int y;\\n    Point(int x, int y) {\\n        this->x = x;\\n        this->y = y;\\n    }\\n};\\n\\n/*\\n* Opeartor< overloading -> when this(<) operator is \\n* used to compare two objects in priority queue\\n* it will compare based on distance formula \\n* if (x1*x1 y1*y1) > (x2*x2 + y2*y2) means first point\\n* is more near to origion than second point\\n*/\\nbool operator<(const Point &v1, const Point &v2){\\n    return (v1.x * v1.x + v1.y * v1.y) > (v2.x * v2.x + v2.y * v2.y);\\n}\\n    \\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        /*\\n        * Put all points in priority queue\\n        */\\n        priority_queue<Point> pq;\\n        for(int i=0;i<points.size();i++){\\n            pq.push(Point(points[i][0], points[i][1]));\\n        }\\n        \\n        /*\\n        * Add top k elements from priority queue to \\n        * ans vector\\n        */\\n        vector<vector<int>>  ans;\\n        int i = 0;\\n        while(i++ < k) {\\n            // Add point to ans vector by constructing a vector\\n            vector<int> temp = {pq.top().x, pq.top().y};\\n            ans.push_back(temp);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/*\\n* Define class template to pass in priority queue \\n* constructor, it overrides () operator\\n*/\\nclass Compare {\\npublic:\\n    bool operator()(const vector<int> &v1, const vector<int> &v2) {\\n        return (v1[0] * v1[0] + v1[1] * v1[1]) > (v2[0] * v2[0] + v2[1] * v2[1]);\\n    }\\n};\\n    \\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        /*\\n        * Pass Compare class template\\n        * Note it shouldn\\'t be a function as we use in sort() \\n        * method cause priority queue accepts this last param\\n        * only as class template\\n        */\\n        priority_queue<vector<int>, vector<vector<int>>, Compare> pq;\\n        for(int i=0;i<points.size();i++){\\n            pq.push(points[i]);\\n        }\\n        \\n        // Add top k elements from queue to ans vector\\n        vector<vector<int>>  ans;\\n        int i = 0;\\n        while(i++ < k) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258395,
                "title": "quickselect-thinking-process",
                "content": "> [Quickselect Selection Algorithm Definition](https://en.wikipedia.org/wiki/Quickselect)\\n\\n> Distance from a point(x, y) to (0, 0) is sqrt(x * x + y * y)\\n\\n> To get K closest points to origin is to find K smallest distance = x * x + y * y.\\n\\n> If we save each point\\'s distance in distances and mapped to its index in points(because we are asked to get the point coordinate finally), the problem becomes find K smallest elements in an array, which can be solved by **Quickselect** algorithm.\\n\\n> In both Quicksort and Quickselect, we specify a pivot element and put it into the right position. The pivot divides the array in half, where elements to the left of pivot is smaller than pivot, elements to the right of pivot is larger than pivot. \\n>\\n> The difference is that we follow the above approach to sort these two halves in Quicksort, but in Quickselect, we choose one half only.\\n****\\n```\\n    public int[][] kClosest(int[][] points, int K) {\\n        int pointsLen = points.length;\\n        // distances[i][0] is distance, distances[i][1] is index in points\\n        int[][] distances = new int[pointsLen][2];\\n        \\n        // Get all distances\\n        for (int i = 0; i < pointsLen; i++) {\\n            int distance = getDistance(points[i]);\\n            distances[i][0] = distance;\\n            distances[i][1] = i;\\n        }\\n        \\n        quickSelect(K, distances, 0, pointsLen - 1);\\n        \\n        // Get first K\\n        int[][] result = new int[K][2];\\n        for (int i = 0; i < K; i++) {\\n            result[i] = points[distances[i][1]];\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // Find smallest K distances\\n    private void quickSelect(int K, int[][] distances, int start, int end) {\\n        if (start >= end) return;\\n        \\n        // Choose the element at start as pivot.\\n        int pivot = distances[start][0];\\n        // Put pivot into right position wall\\n        int wall = end + 1;\\n        for (int i = end; i > start; i--) {\\n            if (distances[i][0] >= pivot) {\\n                wall--;\\n                swap(i, wall, distances);\\n            }\\n        }\\n        wall--;\\n        swap(start, wall, distances);\\n        \\n        if (wall + 1 == K) return;\\n        else if (wall + 1 < K) quickSelect(K, distances, wall + 1, end);\\n        else quickSelect(K, distances, start, wall - 1);\\n    }\\n    \\n    private int getDistance(int[] point) {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n    \\n    private void swap(int i, int j, int[][] distances) {\\n        int[] temp = distances[i];\\n        distances[i] = distances[j];\\n        distances[j] = temp;\\n    }\\n```",
                "solutionTags": [
                    "Quickselect"
                ],
                "code": "```\\n    public int[][] kClosest(int[][] points, int K) {\\n        int pointsLen = points.length;\\n        // distances[i][0] is distance, distances[i][1] is index in points\\n        int[][] distances = new int[pointsLen][2];\\n        \\n        // Get all distances\\n        for (int i = 0; i < pointsLen; i++) {\\n            int distance = getDistance(points[i]);\\n            distances[i][0] = distance;\\n            distances[i][1] = i;\\n        }\\n        \\n        quickSelect(K, distances, 0, pointsLen - 1);\\n        \\n        // Get first K\\n        int[][] result = new int[K][2];\\n        for (int i = 0; i < K; i++) {\\n            result[i] = points[distances[i][1]];\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // Find smallest K distances\\n    private void quickSelect(int K, int[][] distances, int start, int end) {\\n        if (start >= end) return;\\n        \\n        // Choose the element at start as pivot.\\n        int pivot = distances[start][0];\\n        // Put pivot into right position wall\\n        int wall = end + 1;\\n        for (int i = end; i > start; i--) {\\n            if (distances[i][0] >= pivot) {\\n                wall--;\\n                swap(i, wall, distances);\\n            }\\n        }\\n        wall--;\\n        swap(start, wall, distances);\\n        \\n        if (wall + 1 == K) return;\\n        else if (wall + 1 < K) quickSelect(K, distances, wall + 1, end);\\n        else quickSelect(K, distances, start, wall - 1);\\n    }\\n    \\n    private int getDistance(int[] point) {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n    \\n    private void swap(int i, int j, int[][] distances) {\\n        int[] temp = distances[i];\\n        distances[i] = distances[j];\\n        distances[j] = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217971,
                "title": "java-comparator-sort",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, new PointCompare());\\n        int[][] res = new int[K][2];\\n        for(int i = 0; i < K; i++) res[i] = points[i];\\n        return res;\\n    }\\n}\\nclass PointCompare implements Comparator<int[]>{\\n   public int compare(int[] a, int[]b){\\n        int distA = a[0]*a[0] + a[1]*a[1];\\n        int distB = b[0]*b[0] + b[1]*b[1];\\n        \\n        return distA < distB ? -1 : 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, new PointCompare());\\n        int[][] res = new int[K][2];\\n        for(int i = 0; i < K; i++) res[i] = points[i];\\n        return res;\\n    }\\n}\\nclass PointCompare implements Comparator<int[]>{\\n   public int compare(int[] a, int[]b){\\n        int distA = a[0]*a[0] + a[1]*a[1];\\n        int distB = b[0]*b[0] + b[1]*b[1];\\n        \\n        return distA < distB ? -1 : 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648338,
                "title": "java-2-line-solution-super-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        Arrays.sort(points,  Comparator.comparingInt(o -> o[0] * o[0] + o[1] * o[1]));\\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        Arrays.sort(points,  Comparator.comparingInt(o -> o[0] * o[0] + o[1] * o[1]));\\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647620,
                "title": "three-different-solutions",
                "content": "Approach 1: Sorting\\nWe need to find **k**-points that are closest to origin.\\nWe sort them in increasing order on the basis of their distances to origin and then return the first **k** points;\\n\\nHere\\'s the code:\\n```\\nbool comp(vector<int> a, vector<int> b){\\n    /* since sqrt(a) < sqrt(b) implies a < b, therefore here we compare square of distance\\n\\t\\tto avoid floating point comparisons\\n\\t*/\\n    return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\tsort(points.begin(), points.end(), comp);\\n\\treturn vector<vector<int>>(points.begin(), points.begin()+k);\\n}\\n\\n```\\nTime complexity: O(nlogn)\\nSpace complexity: O(1)\\n\\nApproach 2: Using heaps(priority queues)\\nSince we need to find **k** smallest distances, we can maintain a max heap of **k** elements and insert new element if we found it to be smaller than the largest element of heap. This way, we would get the points with **k** smallest distances with respect to origin.\\n\\nHere\\'s the code.\\n```\\nclass compare{\\n    public:\\n    bool operator()(vector<int> a, vector<int> b){\\n        return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);\\n    }\\n};\\n\\nint distance(vector<int> a){\\n    //returns square of distance to avoid floating point comparisons\\n    return a[0]*a[0] + a[1]*a[1];\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\tpriority_queue<vector<int>, vector<vector<int>>, compare> q;\\n\\tfor(int i=0;i<k;++i){\\n\\t\\tq.push(points[i]);\\n\\t}\\n\\tint n = points.size();\\n\\tfor(int i=k;i<n;++i){\\n\\t\\tvector<int> top  = q.top();\\n\\t\\tif(distance(top) > distance(points[i])){\\n\\t\\t\\tq.pop();\\n\\t\\t\\tq.push(points[i]);\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>>  ans;\\n\\twhile(q.size()){\\n\\t\\tans.push_back(q.top());\\n\\t\\tq.pop();\\n\\t}\\n\\treturn ans;\\n}\\n```\\nTime complexity: O(nlogk)\\nSpace complexity: O(k)\\n\\nApproach 3: Binary search\\nWe can find smallest distance **d** such that that are **exactly k-points** that are strictly less than **d**.\\nWe can find d using binary search.\\n**Again here, we will deal with square of distances.**\\nwe set the lower bound to 0 as 0 is the least possible distance and upper bound to 2 * 100000000 (2*10^8).\\nWe update value of **l** and **r** on the basis of count of points with distances that are strictly less than mid.\\n\\nHere\\'s the code:\\n\\n```\\n int getcount(vector<vector<int>> &points, int dist){\\n        //returns count of points with distance strictly less than dist\\n        int _count = 0;\\n        for(auto point: points){\\n            if(point[0]*point[0] + point[1]*point[1] < dist)\\n                ++_count;\\n        }\\n        return _count;\\n    }\\n\\n vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int l = 0, r = 200000000;\\n        vector<vector<int>>  ans;\\n        while(l < r){\\n            int mid = l + (r-l+1)/2;\\n            if(getcount(points,mid) > k) r = mid - 1;\\n            else l = mid;\\n        }\\n        for(auto point: points){\\n            if(point[0]*point[0] + point[1]*point[1] < l)\\n                ans.push_back(point);\\n        }\\n        return ans;\\n    }\\n```\\nTime complexity: O(nlog(max(xi)^2 + max(yi)^2) ) \\nSpace complexity: O(1)",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nbool comp(vector<int> a, vector<int> b){\\n    /* since sqrt(a) < sqrt(b) implies a < b, therefore here we compare square of distance\\n\\t\\tto avoid floating point comparisons\\n\\t*/\\n    return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\tsort(points.begin(), points.end(), comp);\\n\\treturn vector<vector<int>>(points.begin(), points.begin()+k);\\n}\\n\\n```\n```\\nclass compare{\\n    public:\\n    bool operator()(vector<int> a, vector<int> b){\\n        return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);\\n    }\\n};\\n\\nint distance(vector<int> a){\\n    //returns square of distance to avoid floating point comparisons\\n    return a[0]*a[0] + a[1]*a[1];\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\tpriority_queue<vector<int>, vector<vector<int>>, compare> q;\\n\\tfor(int i=0;i<k;++i){\\n\\t\\tq.push(points[i]);\\n\\t}\\n\\tint n = points.size();\\n\\tfor(int i=k;i<n;++i){\\n\\t\\tvector<int> top  = q.top();\\n\\t\\tif(distance(top) > distance(points[i])){\\n\\t\\t\\tq.pop();\\n\\t\\t\\tq.push(points[i]);\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>>  ans;\\n\\twhile(q.size()){\\n\\t\\tans.push_back(q.top());\\n\\t\\tq.pop();\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\n int getcount(vector<vector<int>> &points, int dist){\\n        //returns count of points with distance strictly less than dist\\n        int _count = 0;\\n        for(auto point: points){\\n            if(point[0]*point[0] + point[1]*point[1] < dist)\\n                ++_count;\\n        }\\n        return _count;\\n    }\\n\\n vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int l = 0, r = 200000000;\\n        vector<vector<int>>  ans;\\n        while(l < r){\\n            int mid = l + (r-l+1)/2;\\n            if(getcount(points,mid) > k) r = mid - 1;\\n            else l = mid;\\n        }\\n        for(auto point: points){\\n            if(point[0]*point[0] + point[1]*point[1] < l)\\n                ans.push_back(point);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803851,
                "title": "my-java-solution-using-priorityqueue-or-just-a-maxheap",
                "content": "Here we make use of a maxHeap;\\n1. A max heap is initialised which compares the eucledean distance of the points.(It uses a comparator)\\n2. For each of the point from the points array, we just add the distance into the heap.\\n3. If the size of heap become greater than the value of K, we just remove the element, which is the maximum distance.We remove it because we dont want to consider it and we are only interested in the minimum distance, and we only need K number of values.\\n4. At the end, whatever remains in the max heap is moved onto an array of array and returns it.\\n\\n\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> (b[0]*b[0] + b[1]*b[1] - (a[0]*a[0] + a[1]*a[1])));\\n        for (int [] point: points){\\n            heap.add(point);\\n            if (heap.size() > K)\\n                heap.remove();\\n        }\\n        int [][] result = new int[K][2];\\n        while (K-- > 0){\\n            result[K] = heap.remove();\\n        } \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> (b[0]*b[0] + b[1]*b[1] - (a[0]*a[0] + a[1]*a[1])));\\n        for (int [] point: points){\\n            heap.add(point);\\n            if (heap.size() > K)\\n                heap.remove();\\n        }\\n        int [][] result = new int[K][2];\\n        while (K-- > 0){\\n            result[K] = heap.remove();\\n        } \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661163,
                "title": "python-heap-o-n-log-k-o-k",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        import heapq\\n        max_heap = []\\n        \\n        find_distance = lambda x,y: x**2 + y**2 \\n\\n        for point in points[:k]:\\n            max_heap.append((-find_distance(*point), point)) #Default heap is a min-heap, making it negative to get a max-heap\\n\\n        heapq.heapify(max_heap)\\n\\n        for point in points[k:]:\\n            heapq.heappushpop(max_heap, (-find_distance(*point), point))  #For the next set of points, push point into the heap, and pop out the top one. Eventually the heap will contain the K closest points to origin\\n\\n        return [point for _,point in max_heap]\\n```\\n\\nTime: O(N log (K)) \\nO(K) for making the initial heap + O((N-K)(log K)) for pushing and popping N-K elements into and from a K-sized heap\\nSpace: O(K) for the heap",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        import heapq\\n        max_heap = []\\n        \\n        find_distance = lambda x,y: x**2 + y**2 \\n\\n        for point in points[:k]:\\n            max_heap.append((-find_distance(*point), point)) #Default heap is a min-heap, making it negative to get a max-heap\\n\\n        heapq.heapify(max_heap)\\n\\n        for point in points[k:]:\\n            heapq.heappushpop(max_heap, (-find_distance(*point), point))  #For the next set of points, push point into the heap, and pop out the top one. Eventually the heap will contain the K closest points to origin\\n\\n        return [point for _,point in max_heap]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659957,
                "title": "python-1-liner",
                "content": "```\\ndef kClosest(self, points, K):\\n        points.sort(key = lambda K: K[0]**2 + K[1]**2) \\n\\n        return points[:K] \\n```\\n**Upvotes are encouraging**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kClosest(self, points, K):\\n        points.sort(key = lambda K: K[0]**2 + K[1]**2) \\n\\n        return points[:K] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 541026,
                "title": "javascript-quickselect",
                "content": "FYI, this is not my original solution. I rewrote the answer from the fastest sample solution.\\n```js\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n  const swap = (i1, i2) => {\\n    [points[i1], points[i2]] = [points[i2], points[i1]];\\n  };\\n  const distance = point => point[0] ** 2 + point[1] ** 2;\\n\\n  const partition = (lo, hi) => {\\n    // pick last one as pivot\\n    const pivotDist = distance(points[hi]);\\n    let targetPivotIdx = lo,\\n      searchIdx = lo;\\n    // compare from lo to hi\\n    while (searchIdx < hi) {\\n      const dist = distance(points[searchIdx]);\\n      if (dist <= pivotDist) {\\n        swap(searchIdx, targetPivotIdx);\\n        targetPivotIdx += 1;\\n      }\\n      searchIdx += 1;\\n    }\\n\\t// hi goes to target pivot\\n    swap(hi, targetPivotIdx);\\n    return targetPivotIdx;\\n  };\\n\\n  const quickSelect = (lo, hi, target) => {\\n    const pivot = partition(lo, hi);\\n    if (pivot === target - 1) return;\\n    if (pivot < target - 1) {\\n      quickSelect(pivot + 1, hi, target);\\n    } else {\\n      quickSelect(lo, pivot - 1, target);\\n    }\\n  };\\n\\n  quickSelect(0, points.length - 1, K);\\n  return points.slice(0, K);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n  const swap = (i1, i2) => {\\n    [points[i1], points[i2]] = [points[i2], points[i1]];\\n  };\\n  const distance = point => point[0] ** 2 + point[1] ** 2;\\n\\n  const partition = (lo, hi) => {\\n    // pick last one as pivot\\n    const pivotDist = distance(points[hi]);\\n    let targetPivotIdx = lo,\\n      searchIdx = lo;\\n    // compare from lo to hi\\n    while (searchIdx < hi) {\\n      const dist = distance(points[searchIdx]);\\n      if (dist <= pivotDist) {\\n        swap(searchIdx, targetPivotIdx);\\n        targetPivotIdx += 1;\\n      }\\n      searchIdx += 1;\\n    }\\n\\t// hi goes to target pivot\\n    swap(hi, targetPivotIdx);\\n    return targetPivotIdx;\\n  };\\n\\n  const quickSelect = (lo, hi, target) => {\\n    const pivot = partition(lo, hi);\\n    if (pivot === target - 1) return;\\n    if (pivot < target - 1) {\\n      quickSelect(pivot + 1, hi, target);\\n    } else {\\n      quickSelect(lo, pivot - 1, target);\\n    }\\n  };\\n\\n  quickSelect(0, points.length - 1, K);\\n  return points.slice(0, K);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506066,
                "title": "multimap-max-heap-nth-element-random-quickselect-solution",
                "content": "Finally cleared my doubt about heaps, I always confused min and max heaps, now I understand, for min k values I should use max heap and max k values min heap, it\\'s a little confusing!!! Of course you could use sort/ partial sort too.\\nI\\'ve written them in order of worst to best.\\nMultimap/ Min heap O(nlgn) + O(n) space:\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n    multimap<int, pair<int, int>> st;\\n    vector<vector<int>> ans;\\n    for(int i = 0; i < points.size(); i++) {\\n        int sq = (points[i][0]) * (points[i][0]) + (points[i][1]) * (points[i][1]);\\n        st.insert({sq, {points[i][0], points[i][1]}});\\n    }\\n    for(const auto &i: st) {\\n        if(K--) ans.push_back({i.second.first, i.second.second});\\n        else break;\\n    }\\n    return ans;\\n}\\n```\\nMax Heap O(nlgk) + O(k) space:\\n```\\npriority_queue<pair<int, int>> pq;\\nvector<vector<int>> ans;\\nfor(int i = 0 ; i != points.size(); i++) {\\n    int sq = points[i][0] * points[i][0] + points[i][1] * points[i][1];\\n    if(pq.size() < K) pq.push({sq, i});\\n    else {\\n        if(sq < pq.top().first) {\\n            pq.pop();\\n            pq.push({sq, i});\\n        }\\n    }\\n}\\nwhile(!pq.empty()) {\\n    ans.push_back(points[pq.top().second]);\\n    pq.pop();\\n}\\nreturn ans;\\n```\\nNth Element O(n) avg:\\n```\\nnth_element(points.begin(), points.begin() + K, points.end(), [] (const auto &a, const auto &b) {\\n    return (a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1]);\\n} );\\nreturn {points.begin(), points.begin() + K}; \\n```\\nQuickselect O(n) avg:\\n```\\nint partition(vector<vector<int>> &v, int lo, int hi) {\\n    int pivot = v[hi][0] * v[hi][0] + v[hi][1] * v[hi][1];\\n    int i = lo, j = lo;\\n    for(; j < hi; j++) if(pivot >= v[j][0] * v[j][0] + v[j][1] * v[j][1]) swap(v[i++], v[j]);\\n    swap(v[i], v[hi]);\\n    return i;   \\n}\\n\\nint partitionR(vector<vector<int>> &v, int lo, int hi) {\\n    random_device rd;\\n    default_random_engine gen(rd());\\n    int pivotIdx = uniform_int_distribution<int>{lo, hi}(gen);\\n    swap(v[hi], v[pivotIdx]);\\n    return partition(v, lo, hi);\\n}\\n\\nvoid quickSelect(vector<vector<int>> &v, int K) {\\n    int lo = 0; int hi = v.size() - 1;\\n    for(;;) {\\n        int pivot = partitionR(v, lo, hi);\\n        if(pivot == K) return;\\n        else if(pivot > K) hi = pivot - 1;\\n        else lo = pivot + 1;\\n    }\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n    quickSelect(points, K - 1);\\n    return {points.begin(), points.begin() + K}; \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n    multimap<int, pair<int, int>> st;\\n    vector<vector<int>> ans;\\n    for(int i = 0; i < points.size(); i++) {\\n        int sq = (points[i][0]) * (points[i][0]) + (points[i][1]) * (points[i][1]);\\n        st.insert({sq, {points[i][0], points[i][1]}});\\n    }\\n    for(const auto &i: st) {\\n        if(K--) ans.push_back({i.second.first, i.second.second});\\n        else break;\\n    }\\n    return ans;\\n}\\n```\n```\\npriority_queue<pair<int, int>> pq;\\nvector<vector<int>> ans;\\nfor(int i = 0 ; i != points.size(); i++) {\\n    int sq = points[i][0] * points[i][0] + points[i][1] * points[i][1];\\n    if(pq.size() < K) pq.push({sq, i});\\n    else {\\n        if(sq < pq.top().first) {\\n            pq.pop();\\n            pq.push({sq, i});\\n        }\\n    }\\n}\\nwhile(!pq.empty()) {\\n    ans.push_back(points[pq.top().second]);\\n    pq.pop();\\n}\\nreturn ans;\\n```\n```\\nnth_element(points.begin(), points.begin() + K, points.end(), [] (const auto &a, const auto &b) {\\n    return (a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1]);\\n} );\\nreturn {points.begin(), points.begin() + K}; \\n```\n```\\nint partition(vector<vector<int>> &v, int lo, int hi) {\\n    int pivot = v[hi][0] * v[hi][0] + v[hi][1] * v[hi][1];\\n    int i = lo, j = lo;\\n    for(; j < hi; j++) if(pivot >= v[j][0] * v[j][0] + v[j][1] * v[j][1]) swap(v[i++], v[j]);\\n    swap(v[i], v[hi]);\\n    return i;   \\n}\\n\\nint partitionR(vector<vector<int>> &v, int lo, int hi) {\\n    random_device rd;\\n    default_random_engine gen(rd());\\n    int pivotIdx = uniform_int_distribution<int>{lo, hi}(gen);\\n    swap(v[hi], v[pivotIdx]);\\n    return partition(v, lo, hi);\\n}\\n\\nvoid quickSelect(vector<vector<int>> &v, int K) {\\n    int lo = 0; int hi = v.size() - 1;\\n    for(;;) {\\n        int pivot = partitionR(v, lo, hi);\\n        if(pivot == K) return;\\n        else if(pivot > K) hi = pivot - 1;\\n        else lo = pivot + 1;\\n    }\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n    quickSelect(points, K - 1);\\n    return {points.begin(), points.begin() + K}; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374652,
                "title": "c-nth-element-concise-solution",
                "content": "**Updated:**\\n* Utilized Lambda expression\\n* Utilized non-member begin/end\\n* Index corrected from ```points.begin() + K```  to ```points.begin() + K - 1```, credit to [@Evg](https://leetcode.com/evg/).\\n\\n```\\nclass Solution {   \\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        auto isCloser = [](const vector<int>& lhs, const vector<int>& rhs){\\n            return lhs[0]*lhs[0] + lhs[1]*lhs[1] < rhs[0]*rhs[0] + rhs[1]*rhs[1];\\n        };\\n\\t\\t\\n        nth_element(begin(points), begin(points) + K - 1, end(points), isCloser);\\n        return vector<vector<int>>(begin(points), begin(points) + K);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```points.begin() + K```\n```points.begin() + K - 1```\n```\\nclass Solution {   \\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        auto isCloser = [](const vector<int>& lhs, const vector<int>& rhs){\\n            return lhs[0]*lhs[0] + lhs[1]*lhs[1] < rhs[0]*rhs[0] + rhs[1]*rhs[1];\\n        };\\n\\t\\t\\n        nth_element(begin(points), begin(points) + K - 1, end(points), isCloser);\\n        return vector<vector<int>>(begin(points), begin(points) + K);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289200,
                "title": "using-heap-time-o-k-n-k-logk-space-o-k",
                "content": "\\n\\tfrom heapq import heappush, heappop, heappushpop\\n\\timport math \\n\\tclass Solution:\\n    \\n    def getDistanceFromOrigin(self, point: List[int]) -> float:\\n        \\n        return point[0]**2 + point[1]**2\\n    \\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        kClosestPointsToOrigin = []\\n        \\n        # add first k points\\n        for i in range(K):  # O(K)\\n            heappush(kClosestPointsToOrigin, (-self.getDistanceFromOrigin(points[i]), points[i]))\\n \\n        \\n        # maintain size of heap to k \\n        for i in range(K, len(points)): #O(N-k)\\n            heappushpop(kClosestPointsToOrigin, (-self.getDistanceFromOrigin(points[i]), points[i])) #O(log k)\\n\\n       \\n        # return each point in the heap\\n        return [heappop(kClosestPointsToOrigin)[1] for _ in range(K)] #O(k)\\n    \\n\\n    \\n\\n        \\n        \\n        \\n                \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n\\tfrom heapq import heappush, heappop, heappushpop\\n\\timport math \\n\\tclass Solution:\\n    \\n    def getDistanceFromOrigin(self, point: List[int]) -> float:\\n        \\n        return point[0]**2 + point[1]**2\\n    \\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        kClosestPointsToOrigin = []\\n        \\n        # add first k points\\n        for i in range(K):  # O(K)\\n            heappush(kClosestPointsToOrigin, (-self.getDistanceFromOrigin(points[i]), points[i]))\\n \\n        \\n        # maintain size of heap to k \\n        for i in range(K, len(points)): #O(N-k)\\n            heappushpop(kClosestPointsToOrigin, (-self.getDistanceFromOrigin(points[i]), points[i])) #O(log k)\\n\\n       \\n        # return each point in the heap\\n        return [heappop(kClosestPointsToOrigin)[1] for _ in range(K)] #O(k)\\n    \\n\\n    \\n\\n        \\n        \\n        \\n                \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3586995,
                "title": "using-max-heap-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe word k-closest give us a hint to use heap.Basically if distance between points can be stored and arranged in ascending order then we can easily pick k closest element among them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of storing square root of ans we directly store the sum of squares i.e x^2 +y^2 instead of sqrt(x^2+y^2) to save complexity of code.\\nA priority queue is maintained which stores pair of dist and the current point. A max heap is created with k elements and as soon as the size of maxheap is greater than k we remove the topmost element because it is of no use as we need the least distance k element only which are already in the heap.\\nThen we pop out elements one by one and pair.second gives us the point from which the dist is stored in pair.first so we pop out the top element and pair.second gives the point which we finally store in the final ans vector that is to be returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogk)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)    \\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        vector<vector<int>> ans;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int dist=pow(points[i][0],2)+pow(points[i][1],2);\\n            pq.push({dist,{points[i][0],points[i][1]}});\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top().second;\\n            pq.pop();\\n            vector<int> temp;\\n            temp.push_back(it.first);\\n            temp.push_back(it.second);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        vector<vector<int>> ans;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int dist=pow(points[i][0],2)+pow(points[i][1],2);\\n            pq.push({dist,{points[i][0],points[i][1]}});\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top().second;\\n            pq.pop();\\n            vector<int> temp;\\n            temp.push_back(it.first);\\n            temp.push_back(it.second);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364033,
                "title": "java-simple-priorityqueue",
                "content": "```\\nclass Solution {\\n \\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\\n    \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > k) pq.poll();\\n        }\\n        \\n        return pq.toArray(new int[k][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n \\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\\n    \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > k) pq.poll();\\n        }\\n        \\n        return pq.toArray(new int[k][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817272,
                "title": "python-clean-and-simple-sort-with-lambda-beat-99",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        if points is None or len(points[0]) == 0:\\n            return []\\n        \\n        if len(points) <= K:\\n            return points\\n        \\n        points.sort(key=lambda x: x[0]*x[0] + x[1]*x[1])\\n        \\n        return points[0:K]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        if points is None or len(points[0]) == 0:\\n            return []\\n        \\n        if len(points) <= K:\\n            return points\\n        \\n        points.sort(key=lambda x: x[0]*x[0] + x[1]*x[1])\\n        \\n        return points[0:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508408,
                "title": "simple-java-priorityqueue-minheap-solution-w-comments-clean-code",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n\\t\\t// Handle null/empty edge cases\\n        if (points == null || points.length == 0) return new int[0][0];\\n        \\n        /* We\\'re using the Distance formula to calculate the distance of a set of x/y points to another set of x/y points.\\n           Formula: sqrt(x1^2 + x2^2 - y1^2 + y2^2), where x2 and y2 is the origin (0,0) in this case. \\n           So our formula is: sqrt(x1^2 + 0 - y1^2 + 0)\\n           We can ignore the sqrt() part and just simplify to: x1^2 - y1^2. \\n           Now remember that x1^2 is x1 * x1. So our formula for calculating distance becomes: x1 * x1 + y1 * y2\\n        */\\n        \\n        // We use a priorityQueue to implement a minHeap (calculates disatance for a and b and the sorts by shortest to farthest distance)\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]) );\\n            \\n        // Now load each set of points on to the minHead\\n        for (int i = 0; i < points.length; i++) {\\n            minHeap.offer(points[i]);\\n        }\\n        \\n        // Next we create an array to contain points up to K\\n        int[][] results = new int[K][2];\\n        \\n        // Then iterate and add elements from our minHeap up to K\\n        for (int i = 0; i < K; i++) {\\n            results[i] = minHeap.poll();\\n        }\\n        \\n        return results;\\n    }\\n}\\n```\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n\\t\\t// Handle null/empty edge cases\\n        if (points == null || points.length == 0) return new int[0][0];\\n        \\n        /* We\\'re using the Distance formula to calculate the distance of a set of x/y points to another set of x/y points.\\n           Formula: sqrt(x1^2 + x2^2 - y1^2 + y2^2), where x2 and y2 is the origin (0,0) in this case. \\n           So our formula is: sqrt(x1^2 + 0 - y1^2 + 0)\\n           We can ignore the sqrt() part and just simplify to: x1^2 - y1^2. \\n           Now remember that x1^2 is x1 * x1. So our formula for calculating distance becomes: x1 * x1 + y1 * y2\\n        */\\n        \\n        // We use a priorityQueue to implement a minHeap (calculates disatance for a and b and the sorts by shortest to farthest distance)\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]) );\\n            \\n        // Now load each set of points on to the minHead\\n        for (int i = 0; i < points.length; i++) {\\n            minHeap.offer(points[i]);\\n        }\\n        \\n        // Next we create an array to contain points up to K\\n        int[][] results = new int[K][2];\\n        \\n        // Then iterate and add elements from our minHeap up to K\\n        for (int i = 0; i < K; i++) {\\n            results[i] = minHeap.poll();\\n        }\\n        \\n        return results;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255165,
                "title": "python-clear-solution-with-heap-and-explanation",
                "content": "1. The distance from origin is the Euclidean distance that is \\'c\\' in  `c^2 = x^2 + y^2` (Pythagorean theorem)\\n2. Create max heap ordered by distance, and fill it with the first K points\\n3. Loop over the rest of the points and check for each one: if its distance is smaller than max in heap, extract_max() from heap and push this point\\n\\nRT: O(K + (P - K) * lg K)\\nK is for creating initial heap\\nFor the remaining (P - K) points, we may do that many calls to extract_Max() (lg K)\\n\\nSpc: O(K)\\n\\n```\\nfrom math import sqrt\\nfrom heapq import heappush, heappop\\n\\nclass HeapElem:\\n    def __init__(self, dist, point):\\n        self.dist = dist\\n        self.point = point\\n        \\n    def __lt__(self, other):\\n        return self.dist < other.dist\\n\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        heap = []\\n        # Put first K elements into heap.\\n        for i in range(0, K):\\n            heappush(heap, HeapElem(-get_dist(points[i]), points[i]))\\n            \\n        for i in range(K, len(points)):\\n            dist = get_dist(points[i])\\n            # If dist is less than the max we have in heap, replace the max\\n            # with this smaller distance.\\n            if dist < -heap[0].dist:\\n                heappop(heap)\\n                heappush(heap, HeapElem(-dist, points[i]))\\n        return [elem.point for elem in heap]\\n                \\ndef get_dist(p):\\n    x = p[0]\\n    y = p[1]\\n    return sqrt(x**2 + y**2)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom math import sqrt\\nfrom heapq import heappush, heappop\\n\\nclass HeapElem:\\n    def __init__(self, dist, point):\\n        self.dist = dist\\n        self.point = point\\n        \\n    def __lt__(self, other):\\n        return self.dist < other.dist\\n\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        heap = []\\n        # Put first K elements into heap.\\n        for i in range(0, K):\\n            heappush(heap, HeapElem(-get_dist(points[i]), points[i]))\\n            \\n        for i in range(K, len(points)):\\n            dist = get_dist(points[i])\\n            # If dist is less than the max we have in heap, replace the max\\n            # with this smaller distance.\\n            if dist < -heap[0].dist:\\n                heappop(heap)\\n                heappush(heap, HeapElem(-dist, points[i]))\\n        return [elem.point for elem in heap]\\n                \\ndef get_dist(p):\\n    x = p[0]\\n    y = p[1]\\n    return sqrt(x**2 + y**2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220326,
                "title": "python3-solution-using-quickselect-and-priorityqueue",
                "content": "###  QuickSelect solution:\\n\\nSee classical QuickSort algorithm in  _Data Structures and Algorithm Analysis in C(Second Edition)_ 7.7.  \\n**Shortcut to learn [Slide of FSU\\'s CS](http://www.cs.fsu.edu/~breno/COP-4530/slides/21-anim.pdf)**\\n\\nThe following code is basically the same as the source code in the book.  \\n* *QuickSort algorithm* is faster when dealing with larger arrays.  \\nTime Complexity: Best O(N); Average O(NlogN); Worst O(N^2)\\nSpace Complexity: O(1)\\n\\n* Using *Median-of-Three Partitioning* is the better way to get pivot, eliminating the bad situation of pre-sorting, and reducing the fast sorting by about 5% of the run time.\\n\\n* Using *Insertion Sort* to handle small array(Len < 20) leads to a better submission.\\n\\n```py\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        dist = lambda i: points[i][0]**2 + points[i][1]**2\\n\\t\\t\\n\\t\\t# Median-of-Three Partitioning: \\n\\t\\t# Use the median of the three elements on the left, right, \\n\\t\\t# and middle positions as the pivot element.\\n\\t\\t# Hide pivot finally\\n        def Medium3(left, right):\\n            center = (left + right) // 2\\n            if dist(left) > dist(center):\\n                points[left], points[center] = points[center], points[left]\\n            if dist(left) > dist(right):\\n                points[left], points[right] = points[right], points[left]\\n            if dist(center) > dist(right):\\n                points[center], points[right] = points[right], points[center]\\n            # Invariant: points[left] <= points[center] <= points[right]\\n            points[center], points[right - 1] = points[right - 1], points[center] # Hide pivot in the penultimate position\\n            return dist(right - 1) # Return pivot\\n\\n        def Qselect(k, left, right, cutoff):\\n            if left + cutoff <= right:\\n                if left < right:\\n                    pivot = Medium3(left, right)\\n                    i = left; j = right - 1\\n                    while i < j:\\n                        # plus 1 first to avoid infinite loop\\n                        i += 1\\n                        while dist(i) < pivot: i += 1\\n                        j -= 1\\n                        while dist(j) > pivot: j -= 1\\n                        if i < j:\\n                            points[i], points[j] = points[j], points[i]\\n                    # restore pivot\\n                    points[i], points[right - 1] = points[right - 1], points[i]\\n                    if k <= i:\\n                        Qselect(k, left, i - 1, cutoff)\\n                    elif k > i + 1:\\n                        Qselect(k, i + 1, right, cutoff)\\n            else:\\n                # Do a insertion sort on the subarray(len<cutoff)\\n                InsertionSort(left, right)\\n       \\n        def InsertionSort(left, right):\\n            for i in range(left, right+1):\\n                tmp = points[i]\\n                tmp_dist = dist(i)\\n                j = i\\n                while j > 0:\\n                    if dist(j-1) < tmp_dist: break\\n                    points[j] = points[j-1]\\n                    j -= 1\\n                points[j] = tmp\\n        \\n        # In general, set cutoff 20.    \\n        Qselect(K, 0, len(points) - 1, 20)\\n        return points[:K]\\n```\\n\\n###  PriorityQueue solution:\\nTC: O(N + Nlogk)\\nSC: \\xA0O(k)\\n```py\\nimport queue\\nclass Solution:\\n    def kClosest(self, points, K):\\n        dist = [point[0]**2 + point[1]**2 for point in points]\\n        q = queue.PriorityQueue()\\n        \\n        for i in range(len(points)):\\n            q.put((-dist[i], points[i]))\\n            if q.qsize() > K:\\n                q.get()\\n        \\n\\t\\tres = []\\n        while K > 0:\\n            point = q.get()[1]\\n            res.append(point)\\n            K -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        dist = lambda i: points[i][0]**2 + points[i][1]**2\\n\\t\\t\\n\\t\\t# Median-of-Three Partitioning: \\n\\t\\t# Use the median of the three elements on the left, right, \\n\\t\\t# and middle positions as the pivot element.\\n\\t\\t# Hide pivot finally\\n        def Medium3(left, right):\\n            center = (left + right) // 2\\n            if dist(left) > dist(center):\\n                points[left], points[center] = points[center], points[left]\\n            if dist(left) > dist(right):\\n                points[left], points[right] = points[right], points[left]\\n            if dist(center) > dist(right):\\n                points[center], points[right] = points[right], points[center]\\n            # Invariant: points[left] <= points[center] <= points[right]\\n            points[center], points[right - 1] = points[right - 1], points[center] # Hide pivot in the penultimate position\\n            return dist(right - 1) # Return pivot\\n\\n        def Qselect(k, left, right, cutoff):\\n            if left + cutoff <= right:\\n                if left < right:\\n                    pivot = Medium3(left, right)\\n                    i = left; j = right - 1\\n                    while i < j:\\n                        # plus 1 first to avoid infinite loop\\n                        i += 1\\n                        while dist(i) < pivot: i += 1\\n                        j -= 1\\n                        while dist(j) > pivot: j -= 1\\n                        if i < j:\\n                            points[i], points[j] = points[j], points[i]\\n                    # restore pivot\\n                    points[i], points[right - 1] = points[right - 1], points[i]\\n                    if k <= i:\\n                        Qselect(k, left, i - 1, cutoff)\\n                    elif k > i + 1:\\n                        Qselect(k, i + 1, right, cutoff)\\n            else:\\n                # Do a insertion sort on the subarray(len<cutoff)\\n                InsertionSort(left, right)\\n       \\n        def InsertionSort(left, right):\\n            for i in range(left, right+1):\\n                tmp = points[i]\\n                tmp_dist = dist(i)\\n                j = i\\n                while j > 0:\\n                    if dist(j-1) < tmp_dist: break\\n                    points[j] = points[j-1]\\n                    j -= 1\\n                points[j] = tmp\\n        \\n        # In general, set cutoff 20.    \\n        Qselect(K, 0, len(points) - 1, 20)\\n        return points[:K]\\n```\n```py\\nimport queue\\nclass Solution:\\n    def kClosest(self, points, K):\\n        dist = [point[0]**2 + point[1]**2 for point in points]\\n        q = queue.PriorityQueue()\\n        \\n        for i in range(len(points)):\\n            q.put((-dist[i], points[i]))\\n            if q.qsize() > K:\\n                q.get()\\n        \\n\\t\\tres = []\\n        while K > 0:\\n            point = q.get()[1]\\n            res.append(point)\\n            K -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219115,
                "title": "python-heap-o-nlogk",
                "content": "```\\nfrom heapq import heappush, heappop, heappushpop\\n\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        kClosestPointsToOrigin = []\\n        \\n        # add first k points\\n        for i in range(K):\\n            heappush(kClosestPointsToOrigin, (-Solution.getDistanceFromOrigin(points[i]), points[i]))\\n        \\n        # maintain k closest in heap for the remaining points\\n        for i in range(K, len(points)):\\n            heappushpop(kClosestPointsToOrigin, (-Solution.getDistanceFromOrigin(points[i]), points[i]))\\n        \\n        # return each point in the heap\\n        return [heappop(kClosestPointsToOrigin)[1] for _ in range(K)]\\n        \\n    \\n    @staticmethod\\n    def getDistanceFromOrigin(point):\\n        return math.sqrt(point[0]**2 + point[1]**2)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop, heappushpop\\n\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        kClosestPointsToOrigin = []\\n        \\n        # add first k points\\n        for i in range(K):\\n            heappush(kClosestPointsToOrigin, (-Solution.getDistanceFromOrigin(points[i]), points[i]))\\n        \\n        # maintain k closest in heap for the remaining points\\n        for i in range(K, len(points)):\\n            heappushpop(kClosestPointsToOrigin, (-Solution.getDistanceFromOrigin(points[i]), points[i]))\\n        \\n        # return each point in the heap\\n        return [heappop(kClosestPointsToOrigin)[1] for _ in range(K)]\\n        \\n    \\n    @staticmethod\\n    def getDistanceFromOrigin(point):\\n        return math.sqrt(point[0]**2 + point[1]**2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968473,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<pair<int, int>> v;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            v.push_back({(x*x+y*y),i});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(points[v[i].second]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<pair<int, int>> v;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            v.push_back({(x*x+y*y),i});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(points[v[i].second]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617329,
                "title": "c-clean-and-easy-to-understand-code",
                "content": "***\\uD83D\\uDD25\\u2705If u find this useful , please consider to give a upvote!!\\uD83D\\uDD25\\u2705***\\n\\n\\t\\tunordered_map<int,vector<int>>mp; vector<vector<int>>vec;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int ori=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            points[i].push_back(ori);\\n        }\\n        for(int i=0;i<points.size();i++)\\n        {\\n            swap(points[i][0],points[i][2]);\\n        }\\n        sort(points.begin(),points.end()); \\n        for(int i=0;i<k;i++)\\n        {\\n            vec.push_back({points[i][2],points[i][1]});\\n        }\\n        return vec;",
                "solutionTags": [],
                "code": "***\\uD83D\\uDD25\\u2705If u find this useful , please consider to give a upvote!!\\uD83D\\uDD25\\u2705***\\n\\n\\t\\tunordered_map<int,vector<int>>mp; vector<vector<int>>vec;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int ori=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            points[i].push_back(ori);\\n        }\\n        for(int i=0;i<points.size();i++)\\n        {\\n            swap(points[i][0],points[i][2]);\\n        }\\n        sort(points.begin(),points.end()); \\n        for(int i=0;i<k;i++)\\n        {\\n            vec.push_back({points[i][2],points[i][1]});\\n        }\\n        return vec;",
                "codeTag": "Unknown"
            },
            {
                "id": 2252373,
                "title": "java-simple-priority-queue-beats-92",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K == points.length) return points;\\n        \\n        //create a PQ witha comparator that puts the greates Euclid distance at the top so that we can remove it when the PQ size exceeds k.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\\n            \\n       \\n        \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > K) pq.poll();\\n        }\\n        return pq.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K == points.length) return points;\\n        \\n        //create a PQ witha comparator that puts the greates Euclid distance at the top so that we can remove it when the PQ size exceeds k.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\\n            \\n       \\n        \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > K) pq.poll();\\n        }\\n        return pq.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838137,
                "title": "c-heap-priorityqueue",
                "content": "\\n\\n\\t public class Solution {\\n    public int[][] KClosest(int[][] points, int k) {\\n        // Result Array initialization\\n        int[][] results = new int[k][];\\n        for(int i = 0 ; i <  k ; i++)\\n        {\\n            results[i] = new int[2];\\n        }\\n        \\n        // Priority Queue initialization\\n        PriorityQueue<int[], double> queue = new PriorityQueue<int[], double>(new ReverseComp());\\n        foreach(int[] point in points)\\n        {\\n            // Adding in heap.\\n            double distance = Math.Sqrt( (point[0] * point[0] ) + (point[1] * point[1]));\\n            queue.Enqueue(point, distance);\\n            if(queue.Count > k)\\n                queue.Dequeue();\\n        }\\n        \\n        // adding in results.\\n        int iter = 0;\\n        while(queue.Count != 0)\\n        {\\n            results[iter++] = queue.Dequeue();\\n        }\\n        return results ;\\n\\t}\\n\\t}\\n\\tpublic class ReverseComp : IComparer<double>\\n\\t{\\n    public int Compare(double x, double y)\\n    {\\n        return y.CompareTo(x);\\n    }\\n\\t}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[][] KClosest(int[][] points, int k) {\\n        // Result Array initialization\\n        int[][] results = new int[k][];\\n        for(int i = 0 ; i <  k ; i++)\\n        {\\n            results[i] = new int[2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1647306,
                "title": "python-one-line-code-easy",
                "content": "```\\ndef kClosest(self, points, k):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return sorted(points, key = lambda x : x[0]**2 + x[1]**2 )[:k]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kClosest(self, points, k):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return sorted(points, key = lambda x : x[0]**2 + x[1]**2 )[:k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1516061,
                "title": "python3-o-nlogk",
                "content": "```\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:       \\n        heap = []\\n        for x,y in points: # N\\n            \\n            dis = -(x**2 + y**2)\\n            heapq.heappush(heap,(dis,x,y))\\n            \\n            if len(heap) > k:   # logK\\n                heapq.heappop(heap)       \\n                \\n        return [[x,y] for _,x,y in heap]\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#you can find more my solution using #happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:       \\n        heap = []\\n        for x,y in points: # N\\n            \\n            dis = -(x**2 + y**2)\\n            heapq.heappush(heap,(dis,x,y))\\n            \\n            if len(heap) > k:   # logK\\n                heapq.heappop(heap)       \\n                \\n        return [[x,y] for _,x,y in heap]\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1016100,
                "title": "c-max-heap-solution-faster-than-100-137ms",
                "content": "class Solution {\\npublic:\\n    \\n    float distance(int x2,int y2)\\n    {\\n        float value= sqrt(pow((x2),2)+pow((y2),2));\\n        \\n        return value;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n        priority_queue<pair<float,int>>maxh;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            maxh.push({distance(points[i][0],points[i][1]),i});\\n            \\n            if(maxh.size()>K) maxh.pop();\\n            \\n        }\\n        \\n        vector<vector<int>>ans;\\n        while(maxh.size()!=0)\\n        {\\n            ans.push_back(points[maxh.top().second]);\\n            maxh.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    float distance(int x2,int y2)\\n    {\\n        float value= sqrt(pow((x2),2)+pow((y2),2));\\n        \\n        return value;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 995284,
                "title": "ruby-one-line",
                "content": "```\\ndef k_closest(points, k)\\n  points.sort_by{|x, y| x*x + y*y}[0...k]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef k_closest(points, k)\\n  points.sort_by{|x, y| x*x + y*y}[0...k]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 887836,
                "title": "cpp-85-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n\\t\\t//min priority queue syntax\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\n        vector<vector<int>> answer;\\n        \\n        for (int i = 0; i < points.size(); i++) {\\n            pq.push({points[i][0]*points[i][0] + points[i][1]*points[i][1], i});\\n        }\\n        \\n        while (K--) {\\n            answer.push_back(points[pq.top().second]);\\n            pq.pop();\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n\\t\\t//min priority queue syntax\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\n        vector<vector<int>> answer;\\n        \\n        for (int i = 0; i < points.size(); i++) {\\n            pq.push({points[i][0]*points[i][0] + points[i][1]*points[i][1], i});\\n        }\\n        \\n        while (K--) {\\n            answer.push_back(points[pq.top().second]);\\n            pq.pop();\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659991,
                "title": "python3-oneliner-using-sorted-and-lambda-which-beats-98",
                "content": "```python\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        return sorted(points, key=lambda p: p[0]*p[0] + p[1]*p[1])[:K]\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        return sorted(points, key=lambda p: p[0]*p[0] + p[1]*p[1])[:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609013,
                "title": "python-with-heap-explained-o-klogn-o-n",
                "content": "```\\n#how to run start\\n# kClosest([[1,3],[-2,2], [0,8],[7,1]], 2)\\n#how to run end\\n\\n### Time complexity in big O notation:\\n\\n#Algorithm\\tAverage\\t     Worst case\\n#Space\\t\\tO(n)\\t        O(n)\\n#Search\\t\\tO(n)\\t        O(n)\\n#Insert\\t\\tO(1)\\t        O(log n)\\n#Delete\\t\\tO(log n)\\t    O(log n)\\n#Peek\\t\\tO(1)\\t        O(1)\\n\\n\\nimport heapq\\n\\ndef kClosest(points, K):\\n    heap = []\\n    \\n#for every pair in points, find the distance\\n    for point in points:\\n        dist = (point[0]**2+point[1]**2)**0.5\\n#add the -distance, point pair to heap (since this is a min heap, and by addin the \"-\" we make the largest distance to be the min heap, for popping later)         \\n        heapq.heappush(heap,(-dist,point))\\n        if len(heap)>K:\\n#if heap size exceeds the K, then there is no point of keeping them as we only need the Kth closest element, so remove the access by popping.\\n# pop removes the smalles element, so in this case it will remove the larger actual distance as we declared distance as negative above. \\n            heapq.heappop(heap)\\n# return the second elements of the tuple(which is the point pairs, first being the distance), for the K closest elements. \\n# as we deleted the elements that where more than K, when we return everything here it serves the purpose. \\n\\n    print(heap)\\n    \\n#return the point pair of all the elements in the heap, tuple[0] is the -distance so we do not need it for the answer here \\n    return [tuple[1] for tuple in heap]\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#how to run start\\n# kClosest([[1,3],[-2,2], [0,8],[7,1]], 2)\\n#how to run end\\n\\n### Time complexity in big O notation:\\n\\n#Algorithm\\tAverage\\t     Worst case\\n#Space\\t\\tO(n)\\t        O(n)\\n#Search\\t\\tO(n)\\t        O(n)\\n#Insert\\t\\tO(1)\\t        O(log n)\\n#Delete\\t\\tO(log n)\\t    O(log n)\\n#Peek\\t\\tO(1)\\t        O(1)\\n\\n\\nimport heapq\\n\\ndef kClosest(points, K):\\n    heap = []\\n    \\n#for every pair in points, find the distance\\n    for point in points:\\n        dist = (point[0]**2+point[1]**2)**0.5\\n#add the -distance, point pair to heap (since this is a min heap, and by addin the \"-\" we make the largest distance to be the min heap, for popping later)         \\n        heapq.heappush(heap,(-dist,point))\\n        if len(heap)>K:\\n#if heap size exceeds the K, then there is no point of keeping them as we only need the Kth closest element, so remove the access by popping.\\n# pop removes the smalles element, so in this case it will remove the larger actual distance as we declared distance as negative above. \\n            heapq.heappop(heap)\\n# return the second elements of the tuple(which is the point pairs, first being the distance), for the K closest elements. \\n# as we deleted the elements that where more than K, when we return everything here it serves the purpose. \\n\\n    print(heap)\\n    \\n#return the point pair of all the elements in the heap, tuple[0] is the -distance so we do not need it for the answer here \\n    return [tuple[1] for tuple in heap]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 541208,
                "title": "c-very-short-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    static int distance(const vector<int>& p) {\\n        return p[0] * p[0] + p[1] * p[1];\\n    }\\n    \\n    static bool cmp(const vector<int>& p1, const vector<int>& p2) {\\n        return distance(p1) < distance(p2);\\n    }\\n    \\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, const int& K) {\\n        nth_element(points.begin(), points.begin() + K, points.end(), cmp);\\n        return vector(points.begin(), points.begin() + K);\\n    }\\n};\\n```\\nWe use quickselect base on the Euclidean distance to the origin.\\nEditted: we can just use the square of the points to compare.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    static int distance(const vector<int>& p) {\\n        return p[0] * p[0] + p[1] * p[1];\\n    }\\n    \\n    static bool cmp(const vector<int>& p1, const vector<int>& p2) {\\n        return distance(p1) < distance(p2);\\n    }\\n    \\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, const int& K) {\\n        nth_element(points.begin(), points.begin() + K, points.end(), cmp);\\n        return vector(points.begin(), points.begin() + K);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498448,
                "title": "python-maxheap",
                "content": "## 973. K Closest Points to Origin\\n\\n\\n### Problem Solving\\n![image](https://user-images.githubusercontent.com/6414741/73693862-d9ff3100-468b-11ea-947d-54b42feefc7e.png)\\n\\n-----\\n\\n![image](https://user-images.githubusercontent.com/6414741/73693985-0fa41a00-468c-11ea-8cee-38afcdf2a032.png)\\n\\n\\n#### Buggy Code \\n\\nWhy fail: use distance as dictionary key can yields different value pair result, so dictionary here isn\\'t a good idea.\\nafter some research, realize heapify still works for tuple in python.... so let\\'s just use tuple to include x, y information instead\\n\\n\\n```python\\nfrom heapq import heapreplace, heapify\\nclass Solution(object):\\n    def kClosest(self, pairs, k):\\n        nums = []\\n        dic = {}\\n        self.getDist(pairs, nums, dic)\\n        nums = [-num for num in nums]\\n        heap = nums[:k]\\n        heapq.heapify(heap)\\n        \\n              \\n        for i in range(k, len(nums)):\\n            if nums[i] > heap[0]:\\n                heapq.heapreplace(heap, nums[i])\\n        \\n        res = []\\n        for num in heap:\\n            res.append(dic[-num])    \\n        return res\\n        \\n\\n        \\n        \\n    \\n    def getDist(self, pairs, nums, dic):\\n        for pair in pairs:\\n            x, y = pair\\n            dist = (x ** 2 + y ** 2) ** 0.5\\n            dic[dist] = [x, y]\\n            nums.append(dist)\\n            \\nFail:    \\n\\n\\nInput\\n[[0,1],[1,0]]\\n2\\nOutput\\n[[1,0],[1,0]]\\nExpected\\n[[0,1],[1,0]]\\n```\\n\\n\\n### Fixed Code\\n\\n```python\\nfrom heapq import heapreplace, heapify\\nclass Solution(object):\\n    def kClosest(self, pairs, k):\\n        nums = []\\n        self.getDist(pairs, nums)\\n        heap = nums[:k]\\n        heapq.heapify(heap)\\n        \\n        for i in range(k, len(nums)):\\n            if -nums[i][0] < -heap[0][0]:\\n                heapq.heapreplace(heap, nums[i])\\n        \\n        res = []\\n        for num, x, y in heap:\\n            res.append([x, y])    \\n        return res\\n        \\n    def getDist(self, pairs, nums):\\n        for pair in pairs:\\n            x, y = pair\\n            dist = (x ** 2 + y ** 2) ** 0.5\\n            nums.append((-dist, x, y))\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom heapq import heapreplace, heapify\\nclass Solution(object):\\n    def kClosest(self, pairs, k):\\n        nums = []\\n        dic = {}\\n        self.getDist(pairs, nums, dic)\\n        nums = [-num for num in nums]\\n        heap = nums[:k]\\n        heapq.heapify(heap)\\n        \\n              \\n        for i in range(k, len(nums)):\\n            if nums[i] > heap[0]:\\n                heapq.heapreplace(heap, nums[i])\\n        \\n        res = []\\n        for num in heap:\\n            res.append(dic[-num])    \\n        return res\\n        \\n\\n        \\n        \\n    \\n    def getDist(self, pairs, nums, dic):\\n        for pair in pairs:\\n            x, y = pair\\n            dist = (x ** 2 + y ** 2) ** 0.5\\n            dic[dist] = [x, y]\\n            nums.append(dist)\\n            \\nFail:    \\n\\n\\nInput\\n[[0,1],[1,0]]\\n2\\nOutput\\n[[1,0],[1,0]]\\nExpected\\n[[0,1],[1,0]]\\n```\n```python\\nfrom heapq import heapreplace, heapify\\nclass Solution(object):\\n    def kClosest(self, pairs, k):\\n        nums = []\\n        self.getDist(pairs, nums)\\n        heap = nums[:k]\\n        heapq.heapify(heap)\\n        \\n        for i in range(k, len(nums)):\\n            if -nums[i][0] < -heap[0][0]:\\n                heapq.heapreplace(heap, nums[i])\\n        \\n        res = []\\n        for num, x, y in heap:\\n            res.append([x, y])    \\n        return res\\n        \\n    def getDist(self, pairs, nums):\\n        for pair in pairs:\\n            x, y = pair\\n            dist = (x ** 2 + y ** 2) ** 0.5\\n            nums.append((-dist, x, y))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380195,
                "title": "python-using-quickselect",
                "content": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        results = []\\n        for i in range(len(points)):\\n            points[i] = (points[i][0]**2 + points[i][1]**2, points[i])  # (distance, point) tuple\\n        self.quickSelectHelper(points, 0, len(points)-1, K)\\n        for i in range(K):\\n            results.append(points[i][1])\\n        return results\\n\\n    def quickSelectHelper(self, arr, start, end, K):\\n        if start >= end: return\\n        mid = (start + end)//2\\n        arr[start], arr[mid] = arr[mid], arr[start]\\n        i, j = start + 1, end\\n        while i <= j:\\n            while i <= j and arr[i][0] <= arr[start][0]:  # compare the first element in tuple (distance)\\n                i += 1\\n            while i <= j and arr[j][0] >= arr[start][0]:  # compare the first element in tuple (distance)\\n                j -= 1\\n            if i < j: arr[i], arr[j] = arr[j], arr[i]\\n        arr[start], arr[j] = arr[j], arr[start]\\n        if K == j:\\n            return\\n        elif K < j:\\n            self.quickSelectHelper(arr, start, j-1, K)\\n        else:\\n            self.quickSelectHelper(arr, j+1, end, K)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        results = []\\n        for i in range(len(points)):\\n            points[i] = (points[i][0]**2 + points[i][1]**2, points[i])  # (distance, point) tuple\\n        self.quickSelectHelper(points, 0, len(points)-1, K)\\n        for i in range(K):\\n            results.append(points[i][1])\\n        return results\\n\\n    def quickSelectHelper(self, arr, start, end, K):\\n        if start >= end: return\\n        mid = (start + end)//2\\n        arr[start], arr[mid] = arr[mid], arr[start]\\n        i, j = start + 1, end\\n        while i <= j:\\n            while i <= j and arr[i][0] <= arr[start][0]:  # compare the first element in tuple (distance)\\n                i += 1\\n            while i <= j and arr[j][0] >= arr[start][0]:  # compare the first element in tuple (distance)\\n                j -= 1\\n            if i < j: arr[i], arr[j] = arr[j], arr[i]\\n        arr[start], arr[j] = arr[j], arr[start]\\n        if K == j:\\n            return\\n        elif K < j:\\n            self.quickSelectHelper(arr, start, j-1, K)\\n        else:\\n            self.quickSelectHelper(arr, j+1, end, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292640,
                "title": "concise-java-heap-solution",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K>=points.length) return points;\\n        PriorityQueue<int[]> heap=new PriorityQueue<>(new Comparator<int[]>(){public int compare(int[] p1,int[] p2){return (p1[0]*p1[0])+(p1[1]*p1[1])-(p2[0]*p2[0])-(p2[1]*p2[1]);}});\\n        for(int[] point:points) heap.offer(point);\\n        int[][] result=new int[K][2];\\n        for(int i=0;i<K;i++) result[i]=heap.poll();\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K>=points.length) return points;\\n        PriorityQueue<int[]> heap=new PriorityQueue<>(new Comparator<int[]>(){public int compare(int[] p1,int[] p2){return (p1[0]*p1[0])+(p1[1]*p1[1])-(p2[0]*p2[0])-(p2[1]*p2[1]);}});\\n        for(int[] point:points) heap.offer(point);\\n        int[][] result=new int[K][2];\\n        for(int i=0;i<K;i++) result[i]=heap.poll();\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239271,
                "title": "c-solution",
                "content": "```\\nint cmpFunc(const int** a, const int** b)\\n{\\n    return ((a[0][0]-b[0][0])*(a[0][0]+b[0][0]))+((a[0][1]-b[0][1])*(a[0][1]+b[0][1]));\\n}\\n\\nint** kClosest(int** points, int pointsRowSize, int *pointsColSizes, int K, int** columnSizes, int* returnSize) {\\n    int** ans = malloc(sizeof(int*)*K);\\n    *columnSizes = malloc(sizeof(int)*K);\\n    *returnSize = K;\\n    for (int i = 0; i < K; i++)\\n    {\\n        columnSizes[0][i] = 2;\\n    }\\n    \\n    qsort(points, pointsRowSize, sizeof(int*), cmpFunc);\\n    return points;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmpFunc(const int** a, const int** b)\\n{\\n    return ((a[0][0]-b[0][0])*(a[0][0]+b[0][0]))+((a[0][1]-b[0][1])*(a[0][1]+b[0][1]));\\n}\\n\\nint** kClosest(int** points, int pointsRowSize, int *pointsColSizes, int K, int** columnSizes, int* returnSize) {\\n    int** ans = malloc(sizeof(int*)*K);\\n    *columnSizes = malloc(sizeof(int)*K);\\n    *returnSize = K;\\n    for (int i = 0; i < K; i++)\\n    {\\n        columnSizes[0][i] = 2;\\n    }\\n    \\n    qsort(points, pointsRowSize, sizeof(int*), cmpFunc);\\n    return points;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899440,
                "title": "beats-91-priority-queue-c-solution-c-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class info{\\n        public:\\n        int x;\\n        int y;\\n        float distance; // int must be avoided as for decimals we will get equall distances for diff points\\n        info(int a , int b)\\n        {\\n            x = a;\\n            y = b;\\n        // as always we are finding the distance from the origin so\\n            distance = sqrt (x*x + y*y);\\n\\n        }\\n    };\\n\\nclass compare{\\n   public:\\n   bool operator()(info* point1 , info* point2)\\n   {\\n       if( point1->distance > point2->distance)\\n       {\\n           return true;\\n       }\\n       else{\\n           return false;\\n       }\\n   }\\n};\\n\\n\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        // as we want the min  distance so we can use the min heap to store the distance of the min points by using the class info\\n        priority_queue<info*,vector<info*>,compare> minheap;\\n\\n        for( int i = 0 ; i < points.size() ; i ++)\\n        {\\n            // current point\\n            int x1 = points[i][0];\\n            int y1 = points[i][1];\\n            info* newinfo = new info(x1,y1);\\n            minheap.push(newinfo);\\n        }\\n        vector<vector<int>> ans;\\n        while(k > 0)\\n        {\\n            // make point of the top element and push it into the ans\\n            info* temp = minheap.top();\\n            minheap.pop();\\n            int xval = temp->x;\\n            int yval = temp->y;\\n            // now push the point into the ans\\n            vector<int> temp2 ;\\n            temp2.push_back(xval);\\n            temp2.push_back(yval);\\n            ans.push_back(temp2);\\n            k--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    class info{\\n        public:\\n        int x;\\n        int y;\\n        float distance; // int must be avoided as for decimals we will get equall distances for diff points\\n        info(int a , int b)\\n        {\\n            x = a;\\n            y = b;\\n        // as always we are finding the distance from the origin so\\n            distance = sqrt (x*x + y*y);\\n\\n        }\\n    };\\n\\nclass compare{\\n   public:\\n   bool operator()(info* point1 , info* point2)\\n   {\\n       if( point1->distance > point2->distance)\\n       {\\n           return true;\\n       }\\n       else{\\n           return false;\\n       }\\n   }\\n};\\n\\n\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        // as we want the min  distance so we can use the min heap to store the distance of the min points by using the class info\\n        priority_queue<info*,vector<info*>,compare> minheap;\\n\\n        for( int i = 0 ; i < points.size() ; i ++)\\n        {\\n            // current point\\n            int x1 = points[i][0];\\n            int y1 = points[i][1];\\n            info* newinfo = new info(x1,y1);\\n            minheap.push(newinfo);\\n        }\\n        vector<vector<int>> ans;\\n        while(k > 0)\\n        {\\n            // make point of the top element and push it into the ans\\n            info* temp = minheap.top();\\n            minheap.pop();\\n            int xval = temp->x;\\n            int yval = temp->y;\\n            // now push the point into the ans\\n            vector<int> temp2 ;\\n            temp2.push_back(xval);\\n            temp2.push_back(yval);\\n            ans.push_back(temp2);\\n            k--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852739,
                "title": "clean-code-priority-queue-c-faster-than-100",
                "content": "# Intuition\\nUse of priority_queue<pair<int, pair<int,int>>>pq;\\n\\n# Complexity\\n- Time complexity: O(N+K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        priority_queue<pair<int, pair<int,int>>>pq;\\n\\n        for(int i = 0; i<points.size(); i++)\\n        {\\n            pair<int, int>p;\\n            p.first = points[i][0];\\n            p.second = points[i][1];\\n            int sq = ((points[i][0] *points[i][0]) +  (points[i][1]*points[i][1]));\\n            pair<int, pair<int, int>>ppp;\\n            ppp.first = sq;\\n            ppp.second = p;\\n            pq.push(ppp);\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        while(pq.size()>0)\\n        {\\n            v.push_back(pq.top().second.first);\\n            v.push_back(pq.top().second.second);\\n            ans.push_back(v);\\n            v.clear();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/d48de993-7725-4ff3-b62d-a578253d5673_1690973800.3004334.webp)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        priority_queue<pair<int, pair<int,int>>>pq;\\n\\n        for(int i = 0; i<points.size(); i++)\\n        {\\n            pair<int, int>p;\\n            p.first = points[i][0];\\n            p.second = points[i][1];\\n            int sq = ((points[i][0] *points[i][0]) +  (points[i][1]*points[i][1]));\\n            pair<int, pair<int, int>>ppp;\\n            ppp.first = sq;\\n            ppp.second = p;\\n            pq.push(ppp);\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        while(pq.size()>0)\\n        {\\n            v.push_back(pq.top().second.first);\\n            v.push_back(pq.top().second.second);\\n            ans.push_back(v);\\n            v.clear();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246014,
                "title": "python-code-beats-82",
                "content": "# Code\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\n        distances = []\\n        res = []\\n\\n        for i in range(len(points)):\\n            distance =  math.sqrt( ( points[i][0] ) **2 + ( points[i][1] ) **2  )\\n            distances.append([distance,points[i]])\\n        \\n        distances.sort()\\n            \\n        \\n        for i in range(k):\\n            res.append(distances[i][1])\\n\\n        \\n        return res\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\n        distances = []\\n        res = []\\n\\n        for i in range(len(points)):\\n            distance =  math.sqrt( ( points[i][0] ) **2 + ( points[i][1] ) **2  )\\n            distances.append([distance,points[i]])\\n        \\n        distances.sort()\\n            \\n        \\n        for i in range(k):\\n            res.append(distances[i][1])\\n\\n        \\n        return res\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200738,
                "title": "c-solution-with-comments-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& arr, int k) {\\n        // to store distance with index in sorted order\\n        priority_queue<pair<double,int>> temp;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            temp.push({ sqrt(pow(arr[i][0],2)+pow(arr[i][1],2)) , i});\\n            \\n            // if any point\\'s distance is greater than k smallest\\n            // distances, remove it from priority_queue\\n            if(temp.size()>k) temp.pop();\\n        }\\n        \\n        vector<vector<int>> ans;\\n\\n        while(!temp.empty()) {\\n            ans.push_back(arr[temp.top().second]);\\n            temp.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& arr, int k) {\\n        // to store distance with index in sorted order\\n        priority_queue<pair<double,int>> temp;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            temp.push({ sqrt(pow(arr[i][0],2)+pow(arr[i][1],2)) , i});\\n            \\n            // if any point\\'s distance is greater than k smallest\\n            // distances, remove it from priority_queue\\n            if(temp.size()>k) temp.pop();\\n        }\\n        \\n        vector<vector<int>> ans;\\n\\n        while(!temp.empty()) {\\n            ans.push_back(arr[temp.top().second]);\\n            temp.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101063,
                "title": "beats-99-90-quickselect-using-hoare-partition-scheme-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis kind of Kth problem can be solved using quickselect. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is adapted from the quicksort algorithm utilizing the Hoare partition scheme, as outlined in the reputable source, \"Introduction to Algorithms\" written by Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest, specifically in chapter 8, entitled \"Quicksort\".\\n\\nThe key to solving this problem is the Hoare partition scheme (as implemented in the code\\'s partition method). If you are unfamiliar with it, consider reading about it in the book or other online resources.\\n\\nIn simple words, the partition(arr, l, r) method divides the array from indices l to r into two partitions: [l, j] containing elements less than or equal to the pivot, and [j + 1, r] containing elements greater than or equal to the pivot.\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nRuntime: 3 ms (Beats 99.90%). \\n\\nAverage: O(n).\\n![image.png](https://assets.leetcode.com/users/images/7504f19f-d98d-475d-a098-2c1d21fb1d9b_1674944489.971776.png)\\n\\nWorst (it is highly unlikely to occur for a large array when using a random pivot): O(n^2).  \\n![image.png](https://assets.leetcode.com/users/images/964bc6b6-d881-4a10-b004-24d4ab9fcc43_1674723156.3340437.png)\\n\\nAccording to [another online source](https://cs.stackexchange.com/questions/35994/why-does-randomized-quicksort-have-on-log-n-worst-case-runtime-cost). \\n\"Randomized quicksort has a worst-case EXPECTED running time of O(nlogn). But the worst-case may still be O(n^2) time.\\n\\nChoosing the pivot randomly or randomly shuffling the array prior to sorting has the effect of rendering the worst-case very unlikely, particularly for large arrays.\\n\\nThe probability that quicksort will use a quadratic number of compares when sorting a large array on your computer is much less than the probability that your computer will be struck by lightning.\"\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMemory: 50.2 MB (Beats 97.75%).\\n\\nO(1). \\n\\n\\n# Code\\n```\\nclass Solution {\\n    private final Random rand = new Random();\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n        quickselect(points, 0, points.length - 1, k - 1);\\n        return Arrays.copyOf(points, k);\\n    }\\n\\n    private void quickselect(int[][] points, int l, int r, int k) {\\n        while (l < r) {\\n            int p = partition(points, l, r);\\n\\n            if (p == k) return;\\n            else if (p > k) r = p;\\n            else l = p + 1;\\n        }\\n    }\\n\\n    private int partition(int[][] points, int l, int r) {\\n        int pivot = getDist( points[ l + rand.nextInt(r - l + 1) ] );\\n        int i = l - 1, j = r + 1;\\n\\n        while (true) {\\n            while (getDist(points[--j]) > pivot);\\n            while (getDist(points[++i]) < pivot);\\n\\n            if (i >= j) return j;\\n\\n            swap(points, i, j);\\n        }\\n    }\\n\\n    private void swap(int[][] points, int i, int j) {\\n        int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n\\n    private int getDist(int[] p) {\\n        return p[0] * p[0] + p[1] * p[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    private final Random rand = new Random();\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n        quickselect(points, 0, points.length - 1, k - 1);\\n        return Arrays.copyOf(points, k);\\n    }\\n\\n    private void quickselect(int[][] points, int l, int r, int k) {\\n        while (l < r) {\\n            int p = partition(points, l, r);\\n\\n            if (p == k) return;\\n            else if (p > k) r = p;\\n            else l = p + 1;\\n        }\\n    }\\n\\n    private int partition(int[][] points, int l, int r) {\\n        int pivot = getDist( points[ l + rand.nextInt(r - l + 1) ] );\\n        int i = l - 1, j = r + 1;\\n\\n        while (true) {\\n            while (getDist(points[--j]) > pivot);\\n            while (getDist(points[++i]) < pivot);\\n\\n            if (i >= j) return j;\\n\\n            swap(points, i, j);\\n        }\\n    }\\n\\n    private void swap(int[][] points, int i, int j) {\\n        int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n\\n    private int getDist(int[] p) {\\n        return p[0] * p[0] + p[1] * p[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007186,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        l=[]\\n        heapq.heapify(l)\\n        for i in points:\\n            distance=math.sqrt(i[0]*i[0]+i[1]*i[1])\\n            heapq.heappush(l,[distance,i[0],i[1]])\\n        result=[]\\n        for i in range(k):\\n            dis,x1,y1=heapq.heappop(l)\\n            result.append([x1,y1])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        l=[]\\n        heapq.heapify(l)\\n        for i in points:\\n            distance=math.sqrt(i[0]*i[0]+i[1]*i[1])\\n            heapq.heappush(l,[distance,i[0],i[1]])\\n        result=[]\\n        for i in range(k):\\n            dis,x1,y1=heapq.heappop(l)\\n            result.append([x1,y1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593635,
                "title": "why-do-complications-when-its-simpler-than-you-think-hashmap-sol",
                "content": "```cpp\\nclass Solution {\\nprivate:\\n    double dist(const vector<int> &arr) {\\n        int sq = arr[0]*arr[0] + arr[1]*arr[1];\\n        return sqrt(sq);\\n    }\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>> &points, int k) {\\n        int n = points.size();\\n        if (k == n) return points;\\n        vector<vector<int>> res;\\n        map<double, vector<int>> mp;\\n        // O(n * log(n)) time\\n        for (int i = 0; i < n; i++) {\\n            double d = dist(points[i]);\\n            mp[d].push_back(i);\\n        }\\n        // O(k) time\\n        for (auto it = mp.begin(); it != mp.end(); it++) {\\n            vector<int> vec = it->second;\\n            for (int &x : vec) {\\n                res.push_back(points[x]);\\n                if (k == res.size()) return res;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\nTime Complexity : **O(n * log(n)) + O(k)**\\nSpace Complexity : **O(n) + O(k)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    double dist(const vector<int> &arr) {\\n        int sq = arr[0]*arr[0] + arr[1]*arr[1];\\n        return sqrt(sq);\\n    }\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>> &points, int k) {\\n        int n = points.size();\\n        if (k == n) return points;\\n        vector<vector<int>> res;\\n        map<double, vector<int>> mp;\\n        // O(n * log(n)) time\\n        for (int i = 0; i < n; i++) {\\n            double d = dist(points[i]);\\n            mp[d].push_back(i);\\n        }\\n        // O(k) time\\n        for (auto it = mp.begin(); it != mp.end(); it++) {\\n            vector<int> vec = it->second;\\n            for (int &x : vec) {\\n                res.push_back(points[x]);\\n                if (k == res.size()) return res;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566908,
                "title": "python3-1-liner",
                "content": "Upvote if you like it :)\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return [points[i] for d, i in sorted([(math.sqrt(x**2 + y**2), i) for i, [x, y] in enumerate(points)])[:k]]",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "Upvote if you like it :)\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return [points[i] for d, i in sorted([(math.sqrt(x**2 + y**2), i) for i, [x, y] in enumerate(points)])[:k]]",
                "codeTag": "Java"
            },
            {
                "id": 2535780,
                "title": "best-soln-brute-force-to-optimised",
                "content": "# Brute Force : O(N log N) + O(K)\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        ans=[]\\n        temp=[]\\n        for x,y in points:\\n            dist= x**2 + y**2\\n            temp.append([dist,[x,y]])\\n        #print(temp)                                        [[10, [1, 3]], [8, [-2, 2]]]\\n        temp.sort()\\n        #print(temp)                                        [[8, [-2, 2]], [10, [1, 3]]]\\n        for i in range(k):\\n            ans.append(temp[i][1])\\n        return ans\\n```\\n \\n# Optimised : O(K log N) \\n```\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        minheap=[]  \\n        for x,y in points:\\n            dist= x**2 + y**2\\n            minheap.append([dist,[x,y]])     \\n        # print(minheap)                      [[10, 1, 3], [8, -2, 2]]\\n       \\n        heapq.heapify(minheap)\\n        # print(minheap)                      [[8, -2, 2], [10, 1, 3]]\\n        \\n        ans=[]\\n        while k:\\n            dist,points=heapq.heappop(minheap)\\n            ans.append(points)\\n            k-=1\\n        return ans\\n```\\n\\n# Do Upvote If you Liked The Solution .\\uD83D\\uDC4D\\u2705",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        ans=[]\\n        temp=[]\\n        for x,y in points:\\n            dist= x**2 + y**2\\n            temp.append([dist,[x,y]])\\n        #print(temp)                                        [[10, [1, 3]], [8, [-2, 2]]]\\n        temp.sort()\\n        #print(temp)                                        [[8, [-2, 2]], [10, [1, 3]]]\\n        for i in range(k):\\n            ans.append(temp[i][1])\\n        return ans\\n```\n```\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        minheap=[]  \\n        for x,y in points:\\n            dist= x**2 + y**2\\n            minheap.append([dist,[x,y]])     \\n        # print(minheap)                      [[10, 1, 3], [8, -2, 2]]\\n       \\n        heapq.heapify(minheap)\\n        # print(minheap)                      [[8, -2, 2], [10, 1, 3]]\\n        \\n        ans=[]\\n        while k:\\n            dist,points=heapq.heappop(minheap)\\n            ans.append(points)\\n            k-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446353,
                "title": "java-min-heap-by-getting-the-first-k-elements",
                "content": "This version is quite fast and beats my original implementation based on a Max-Heap. Instead of pruning the queue for the minimum elements, I simply add the smallest elements to the head of the queue and add the first K elements of the queue into my final array. Any thoughts? I\\'m open to opposing thoughts as I\\'m not sure why one would use a Max-Heap over a natural ordering.\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\t\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<int[]>((a,b) -> (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0]+b[1]*b[1]));\\n        int[][] ans = new int[k][2];        \\n        \\n        for(int i = 0; i < points.length; i++){\\n            maxHeap.offer(points[i]);\\n        }\\n        \\n         for(int i = 0; i < k; i++){\\n            ans[i] = maxHeap.poll();\\n         }\\n        \\n        return ans;\\n        \\n    }\\n\\t\\n\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "This version is quite fast and beats my original implementation based on a Max-Heap. Instead of pruning the queue for the minimum elements, I simply add the smallest elements to the head of the queue and add the first K elements of the queue into my final array. Any thoughts? I\\'m open to opposing thoughts as I\\'m not sure why one would use a Max-Heap over a natural ordering.\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\t\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<int[]>((a,b) -> (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0]+b[1]*b[1]));\\n        int[][] ans = new int[k][2];        \\n        \\n        for(int i = 0; i < points.length; i++){\\n            maxHeap.offer(points[i]);\\n        }\\n        \\n         for(int i = 0; i < k; i++){\\n            ans[i] = maxHeap.poll();\\n         }\\n        \\n        return ans;\\n        \\n    }\\n\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2272538,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-nlogn",
                "content": "```\\n// Naive Solution :: Time : O(N) + O(NlogN) :: Aux_Space : O(N)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\n        int n = points.size();\\n\\n        vector<pair<int,pair<int,int>>> v;\\n\\n        for(auto it : points){\\n\\n            int d = it[0] * it[0] + it[1]*it[1];\\n\\n            v.push_back({d,{it[0],it[1]}});\\n\\n        }\\n\\n        sort(v.begin(),v.end());\\n\\n        vector<vector<int>> res(k);\\n\\n        for(int i=0;i<k;i++){\\n\\n            res[i].push_back(v[i].second.first);\\n            res[i].push_back(v[i].second.second);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n// Approach 2 Using Heap :: Time : O(NlogK) :: Aux_Space : O(K)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\n        int n = points.size();\\n\\n        vector<vector<int>> res(k);\\n\\n        priority_queue<vector<int>> pq;\\n\\n        for(auto p : points){\\n\\n            int x = p[0], y = p[1];\\n\\n            pq.push({x*x + y*y,x,y});\\n\\n            if(pq.size() > k){\\n                pq.pop();\\n            }\\n        }\\n\\n        int i=0;\\n\\n        while(!pq.empty()){\\n\\n            vector<int> v = pq.top();\\n            pq.pop();\\n\\n            res[i] = {v[1],v[2]};\\n            i++;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n// Approach 3 Using Multi-Map :: Time : O(NlogN) :: Aux_Space : O(N)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\n        int n = points.size();\\n\\n        multimap<int,int> mp;\\n\\n        vector<vector<int>> res;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int x = points[i][0], y = points[i][1];\\n\\n            mp.insert({x*x + y*y, i});\\n\\n        }\\n\\n        int cnt = 0;\\n\\n        for(auto it = mp.begin();cnt<k;cnt++,it++){\\n\\n            res.push_back(points[it->second]);\\n\\n        }\\n\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\n        int n = points.size();\\n\\n        vector<pair<int,pair<int,int>>> v;\\n\\n        for(auto it : points){\\n\\n            int d = it[0] * it[0] + it[1]*it[1];\\n\\n            v.push_back({d,{it[0],it[1]}",
                "codeTag": "Java"
            },
            {
                "id": 2243579,
                "title": "java-solution-using-treemap",
                "content": "Add distances to treemap, the keys are sorted in increasing order.\\n\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n          \\n        Map<Double, List<int[]>> map = new TreeMap<>();\\n\\n        for (int[] point : points) {\\n            int x2 = point[0];\\n            int y2 = point[1];\\n\\n            double distance = Math.sqrt(Math.pow((x2), 2) + Math.pow((y2), 2));\\n\\n            if (map.containsKey(distance))\\n                map.get(distance).add(point);\\n            else {\\n                ArrayList<int[]> list = new ArrayList<>();\\n                list.add(point);\\n                map.put(distance, list);\\n            }\\n        }\\n\\n        int[][] answer = new int[k][];\\n        int i = 0;\\n        for (Map.Entry<Double, List<int[]>> entry : map.entrySet()) {\\n            for (int[] values : entry.getValue()) {\\n                answer[i++] = values;\\n                if (i == k)\\n                    return answer;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n          \\n        Map<Double, List<int[]>> map = new TreeMap<>();\\n\\n        for (int[] point : points) {\\n            int x2 = point[0];\\n            int y2 = point[1];\\n\\n            double distance = Math.sqrt(Math.pow((x2), 2) + Math.pow((y2), 2));\\n\\n            if (map.containsKey(distance))\\n                map.get(distance).add(point);\\n            else {\\n                ArrayList<int[]> list = new ArrayList<>();\\n                list.add(point);\\n                map.put(distance, list);\\n            }\\n        }\\n\\n        int[][] answer = new int[k][];\\n        int i = 0;\\n        for (Map.Entry<Double, List<int[]>> entry : map.entrySet()) {\\n            for (int[] values : entry.getValue()) {\\n                answer[i++] = values;\\n                if (i == k)\\n                    return answer;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070390,
                "title": "python-quick-select-clean-solution-with-comments",
                "content": "My code is based on the implementation of NeetCode in this [video](https://www.youtube.com/watch?v=XEmy13g1Qxc)\\nIf you are not familiar with the quick select algorithm, I highly recommend that you\\'ll watch it before proceeding to my solution\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:        \\n        def calc_distance(point):\\n            return point[0]**2 + point[1]**2\\n        \\n        def quickselect(l, r):   \\n            # pick pivot at random, swap it to the right (random pivot improves performance substantially)\\n            rand_index = random.randrange(l, r+1)\\n            points[rand_index], points[r] = points[r], points[rand_index]\\n            \\n            # initalize pivot and p\\n            pivot_distance = calc_distance(points[r])\\n            p = l\\n            \\n            # iterate points in the range [l, r] (non inclusive of r)\\n            for i in range(l, r):\\n                # if current point dist <= pivot distance\\n                if calc_distance(points[i]) <= pivot_distance:\\n                    # swap point with current p location\\n                    points[p], points[i] = points[i], points[p]\\n                    p += 1\\n            \\n            # swap our pivot which located in r, to its correct position\\n            points[p], points[r] = points[r], points[p]\\n            \\n            # we want to return closest K points, which means that our p should actually be equal to index of k-1\\n            if p > k-1: return quickselect(l, p - 1)\\n            elif p < k-1: return quickselect(p+1, r)\\n            \\n            # now we return the first k elements\\n            return points[:k]\\n        \\n        return quickselect(0, len(points) - 1)     \\n                \\n        \\n \\n```",
                "solutionTags": [
                    "Python",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:        \\n        def calc_distance(point):\\n            return point[0]**2 + point[1]**2\\n        \\n        def quickselect(l, r):   \\n            # pick pivot at random, swap it to the right (random pivot improves performance substantially)\\n            rand_index = random.randrange(l, r+1)\\n            points[rand_index], points[r] = points[r], points[rand_index]\\n            \\n            # initalize pivot and p\\n            pivot_distance = calc_distance(points[r])\\n            p = l\\n            \\n            # iterate points in the range [l, r] (non inclusive of r)\\n            for i in range(l, r):\\n                # if current point dist <= pivot distance\\n                if calc_distance(points[i]) <= pivot_distance:\\n                    # swap point with current p location\\n                    points[p], points[i] = points[i], points[p]\\n                    p += 1\\n            \\n            # swap our pivot which located in r, to its correct position\\n            points[p], points[r] = points[r], points[p]\\n            \\n            # we want to return closest K points, which means that our p should actually be equal to index of k-1\\n            if p > k-1: return quickselect(l, p - 1)\\n            elif p < k-1: return quickselect(p+1, r)\\n            \\n            # now we return the first k elements\\n            return points[:k]\\n        \\n        return quickselect(0, len(points) - 1)     \\n                \\n        \\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961268,
                "title": "go-heap-clear-solution",
                "content": "```\\nfunc distance(point []int) int { return point[0]*point[0]+point[1]*point[1] }\\n\\ntype MaxHeap [][]int\\n\\nfunc (h MaxHeap) Len() int              { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool    { return distance(h[i]) > distance(h[j]) }\\nfunc (h MaxHeap) Swap(i, j int)         { h[i], h[j] = h[j], h[i] }\\nfunc (h *MaxHeap) Push(x interface{})   { *h = append(*h, x.([]int)) }\\nfunc (h *MaxHeap) Pop() interface{} {\\n    res := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n\\treturn res\\n}\\n\\nfunc kClosest(points [][]int, k int) [][]int {\\n    max := MaxHeap{}\\n    for _, point := range points {\\n        heap.Push(&max, point)\\n        if len(max) > k { heap.Pop(&max) }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc distance(point []int) int { return point[0]*point[0]+point[1]*point[1] }\\n\\ntype MaxHeap [][]int\\n\\nfunc (h MaxHeap) Len() int              { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool    { return distance(h[i]) > distance(h[j]) }\\nfunc (h MaxHeap) Swap(i, j int)         { h[i], h[j] = h[j], h[i] }\\nfunc (h *MaxHeap) Push(x interface{})   { *h = append(*h, x.([]int)) }\\nfunc (h *MaxHeap) Pop() interface{} {\\n    res := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n\\treturn res\\n}\\n\\nfunc kClosest(points [][]int, k int) [][]int {\\n    max := MaxHeap{}\\n    for _, point := range points {\\n        heap.Push(&max, point)\\n        if len(max) > k { heap.Pop(&max) }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649051,
                "title": "2-different-python-solutions-with-min-max-heap",
                "content": "**Short solution using min-heap**\\n\\nThe idea is simple. We construct a min heap and pop the first k nearest points based on euclidean distance.\\n\\nTime complexity: `O(nlogn)` since we\\'re pushing `n` elements consecutively into a heap \\nSpace complexity: `O(n)` to store `n` elements \\n\\n```\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        for i, p in enumerate(points):\\n            dist = math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], heapq.nsmallest(k, distances))\\n```\\n\\t\\t\\n**Better solution using max-heap**\\n\\nInstead of needing to store `n` elements in the heap, we notice that if we first push `k` elements into a max-heap first, the top most element will be the current point furthest from the origin. Thus, we can then iterate down the rest of the `points` array and if any point is closer than the top most element of the heap, we will replace the two points.\\n\\nThe resulting heap then contains `k` closest points to the origin\\n\\nTime complexity: `O(nlogk)` since the depth of the tree is at most `log(k)`\\nSpace complexity: `O(k)` as we only need to store `k` elements\\n\\n```\\n    # Solution utilizing max heap instead of min heap to reduce\\n    # time complexity from O(nlogn) to O(nlogk)\\n    # and space complexity from O(n) to O(k)\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        \\n        # First push the first k items\\n        for i in range(k):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            heapq.heappush(distances, (dist, p))\\n                 \\n        # If the next point is closer than the current farthest point,\\n        #   we replace the top element of the heap\\n        for i in range(k, len(points)):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            if dist > distances[0][0]:\\n                heapq.heappop(distances)\\n                heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], distances)\\n```\\n\\n**With heapify**\\n```\\nclass Solution:\\n    \\n    # Solution utilizing max heap instead of min heap to reduce\\n    # time complexity from O(nlogn) to O(nlogk)\\n    # and space complexity from O(n) to O(k)\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        \\n        # First push the first k items\\n        for i in range(k):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            distances.append((dist, p))\\n        \\n        # We can also use heapify, which takes O(2k) instead of O(klogk) to construct the initial heap\\n        heapq.heapify(distances)\\n        \\n        # If the next point is closer than the current farthest point,\\n        #   we replace the top element of the heap\\n        for i in range(k, len(points)):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            if dist > distances[0][0]:\\n                heapq.heappop(distances)\\n                heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], distances)\\n```\\nPlease upvote if this was helpful :)",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        for i, p in enumerate(points):\\n            dist = math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], heapq.nsmallest(k, distances))\\n```\n```\\n    # Solution utilizing max heap instead of min heap to reduce\\n    # time complexity from O(nlogn) to O(nlogk)\\n    # and space complexity from O(n) to O(k)\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        \\n        # First push the first k items\\n        for i in range(k):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            heapq.heappush(distances, (dist, p))\\n                 \\n        # If the next point is closer than the current farthest point,\\n        #   we replace the top element of the heap\\n        for i in range(k, len(points)):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            if dist > distances[0][0]:\\n                heapq.heappop(distances)\\n                heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], distances)\\n```\n```\\nclass Solution:\\n    \\n    # Solution utilizing max heap instead of min heap to reduce\\n    # time complexity from O(nlogn) to O(nlogk)\\n    # and space complexity from O(n) to O(k)\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        \\n        # First push the first k items\\n        for i in range(k):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            distances.append((dist, p))\\n        \\n        # We can also use heapify, which takes O(2k) instead of O(klogk) to construct the initial heap\\n        heapq.heapify(distances)\\n        \\n        # If the next point is closer than the current farthest point,\\n        #   we replace the top element of the heap\\n        for i in range(k, len(points)):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            if dist > distances[0][0]:\\n                heapq.heappop(distances)\\n                heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], distances)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496058,
                "title": "python-5-line-clean-solution",
                "content": "Time Complexity: O(NlogN)\\n```\\n class Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        def compare(pt):\\n            x, y = pt[0], pt[1]\\n            return x ** 2 + y ** 2 \\n        points = sorted(points, key=compare)\\n        return points[:k]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\n class Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        def compare(pt):\\n            x, y = pt[0], pt[1]\\n            return x ** 2 + y ** 2 \\n        points = sorted(points, key=compare)\\n        return points[:k]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411394,
                "title": "python-1-liner",
                "content": "```\\nreturn sorted(points, key = lambda coor: math.sqrt(math.pow(coor[0],2)+math.pow(coor[1],2)))[:k]\\n```",
                "solutionTags": [],
                "code": "```\\nreturn sorted(points, key = lambda coor: math.sqrt(math.pow(coor[0],2)+math.pow(coor[1],2)))[:k]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339309,
                "title": "python-one-liner-with-heap-super-easy-barely-an-inconvenience",
                "content": "```\\ndef kClosest(self, points, k):\\n\\treturn heapq.nsmallest(k, points, key=lambda x: x[0] ** 2 + x[1] ** 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kClosest(self, points, k):\\n\\treturn heapq.nsmallest(k, points, key=lambda x: x[0] ** 2 + x[1] ** 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1256189,
                "title": "2-lines-of-code-java-solution",
                "content": "```\\n public int[][] kClosest(int[][] points, int k) {\\n        \\n        Arrays.sort(points,(p1, p2) ->p1[0]*p1[0]+p1[1]*p1[1]-(p2[0]*p2[0]+p2[1]*p2[1]));\\n       \\n        return Arrays.copyOf(points,k);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[][] kClosest(int[][] points, int k) {\\n        \\n        Arrays.sort(points,(p1, p2) ->p1[0]*p1[0]+p1[1]*p1[1]-(p2[0]*p2[0]+p2[1]*p2[1]));\\n       \\n        return Arrays.copyOf(points,k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147308,
                "title": "js-es6-solution-runtime-160-ms-memory-usage-47-1-mb",
                "content": "JS solution using implicit returns / ES6 formatting. Runtime: 160 ms (faster than 93.36% of JavaScript submissions); memory usage: 47.1 MB (less than 97.45% of JavaScript submissions).\\n\\nTime complexity of `sort` is `O(nlogn)`, time complexity of `slice` is `O(n)`, so time complexity for this solution is `O(nlogn)`. \\n\\nBecause we are looking at distances from `(0, 0)`, we can simplify `\\u221A(x1 - x2)**2 + (y1 - y2)**2)` to `\\u221A(x1)**2 + (y1)**2)` to `x1**2 + y1**2`. \\n\\n1. Sort `points` array from smallest distance to largest distance.\\n2. Slice the sorted `points` array to get `k` elements. \\n\\n```\\nconst kClosest = (points, k) => (\\n    points.sort((a, b) => (\\n        (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1])\\n    )).slice(0, k)\\n);\\n```\\n\\nThis variation has a slower runtime, but uses array desconstruction and `Math.pow` for an arguably easier-to-read solution:\\n\\n```\\nconst kClosest = (points, k) => (\\n    points.sort(([x1, y1], [x2, y2]) => (\\n        (Math.pow(x1, 2) + Math.pow(y1, 2)) - (Math.pow(x2, 2) + Math.pow(y2, 2))\\n    )).slice(0, k)\\n);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kClosest = (points, k) => (\\n    points.sort((a, b) => (\\n        (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1])\\n    )).slice(0, k)\\n);\\n```\n```\\nconst kClosest = (points, k) => (\\n    points.sort(([x1, y1], [x2, y2]) => (\\n        (Math.pow(x1, 2) + Math.pow(y1, 2)) - (Math.pow(x2, 2) + Math.pow(y2, 2))\\n    )).slice(0, k)\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1098260,
                "title": "golang-solution-with-explanation-and-images",
                "content": "**Code on The Bottom, If This helps Please Up Vote**\\n\\n**The New Distance Formula:**\\n\\nThe Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don\\'t aline up when writen up in text)\\n\\n![image](https://assets.leetcode.com/users/images/5c63fa2c-9c2a-4c3f-b7f8-03708b8927d1_1615131535.4240034.png)\\n\\n\\nThis can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn\\'t need to be square rooted. The distance not needing to be square rooted can be shown by doing an experiment, for example let us take the square root of 10 and the square root of 8, we know that the square root of 10 will allways be greater than the square root of 8. We also know that 10 will always be greater than 8. Try this with any two positive numbers. *Note: I said positve numbers because any square number is positive.*\\n\\nSo now our equation for the distance is:\\n\\n![image](https://assets.leetcode.com/users/images/3cd5558c-18dc-4af0-a75b-632193cfd492_1615131556.5738633.png)\\n\\n\\nWe can simplify the equation again by taking out the x2 and the y2 because x2 and y2 will always be `0`. X2 and y2 will always be `0` because the first point is a regular point, but the second point will be `(0, 0)` because the second point will always be the origin. This can by shown by an example:\\n\\n![image](https://assets.leetcode.com/users/images/1fe1f804-189f-42a6-a12c-bceebfc6abc0_1615131571.9960535.png)\\n\\n\\nSo the new distance equation is:\\n\\n![image](https://assets.leetcode.com/users/images/357622dc-0655-4375-b39b-58d8894f54d6_1615131587.1393197.png)\\n\\n\\n****\\n\\n**The Idea Of This Solution:**\\n\\nNow that we know that we know the distance formula for this problem is `x^2 + y^2` we just have to sort the matrix array. \\n\\nThe way we sort the array is we check whether the current distance is smaller than the the previous distance, then if so we switch the two points, then we move back a space, to check whether the previous value is greater than the current value. This can be show by the following example:\\n\\n![image](https://assets.leetcode.com/users/images/69ee2c1b-b4f2-40a1-aa90-4f0c523ff85f_1615131609.5708025.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/9a7190b9-5d5f-4fc0-9a70-c4a0ef0b9baa_1615131625.1433806.png)\\n\\n\\nWe do nothing because `18 < 26`. So we continue:\\n\\n![image](https://assets.leetcode.com/users/images/9317c2ca-416d-4d0b-824a-50dd56ec2af3_1615131644.3956482.png)\\n\\n\\n`26` is greater than `20` so we have to switch them. We also have to subtract `2` from `i`. `i` will only go back by `1` even though we subtract `2` from `i` because the for loop adds `1` to `i`.\\n\\n![image](https://assets.leetcode.com/users/images/758db950-69d1-42a1-b84a-30eb588ae8c1_1615131662.4130182.png)\\n\\n\\n`18` is smaller than `20` so do nothing.\\n\\n![image](https://assets.leetcode.com/users/images/07cb8cda-7942-4242-9153-370ec9e28f83_1615131694.5103717.png)\\n\\n\\n`20` is smaller than `26` so do nothing again.\\n\\n![image](https://assets.leetcode.com/users/images/5319fe29-8ca8-41a3-8c06-f60d10e3336b_1615131709.9442105.png)\\n\\n\\n`26` is smaller than `130` so we do nothing again. Since `i` is at the end `points` is `[[3, 3], [-2, 4], [5, -1], [7, 9]]`.\\n\\n****\\n\\n```  go\\nfunc kClosest(points [][]int, k int) [][]int {\\n    for i := 1; i < len(points); i++ {\\n        if i >= 1 {\\n            distanceOfIMinusOne := square(points[i-1][0]) + square(points[i-1][1])\\n            distanceOfI := square(points[i][0]) + square(points[i][1])\\n            if distanceOfIMinusOne > distanceOfI {\\n                points[i-1], points[i] = points[i], points[i-1]\\n                i -= 2\\n            }\\n        }\\n    }\\n    return points[:k]\\n}\\n\\nfunc square(n int) int {\\n    return n * n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```  go\\nfunc kClosest(points [][]int, k int) [][]int {\\n    for i := 1; i < len(points); i++ {\\n        if i >= 1 {\\n            distanceOfIMinusOne := square(points[i-1][0]) + square(points[i-1][1])\\n            distanceOfI := square(points[i][0]) + square(points[i][1])\\n            if distanceOfIMinusOne > distanceOfI {\\n                points[i-1], points[i] = points[i], points[i-1]\\n                i -= 2\\n            }\\n        }\\n    }\\n    return points[:k]\\n}\\n\\nfunc square(n int) int {\\n    return n * n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065685,
                "title": "java-maxheap-solution",
                "content": "Time complexity: O(NlogK)\\nSpace complexity: O(K) we need to store \\u2018K\\u2019 points in the heap\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a,b)->( (b[0]*b[0]+b[1]*b[1]) - (a[0]*a[0]+a[1]*a[1])));\\n        //Store first K points in the maxHeap\\n        for(int i = 0; i < K; i++){\\n            maxHeap.add(points[i]);\\n        }\\n        //for the rest of the points in input array, compare each point with the max value in maxHeap, if points[i] distance is smaller than maxHeap.peek() distance, remove the max point in maxHeap and add the points[i] in maxHeap.\\n\\t\\t\\n        for(int i = K; i < points.length; i++){\\n            int pDist = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            int[] maxPoint = maxHeap.peek();\\n            int maxDist = maxPoint[0]*maxPoint[0] + maxPoint[1]*maxPoint[1];\\n            if(pDist < maxDist){\\n                maxHeap.poll();\\n                maxHeap.add(points[i]);\\n            }\\n        }\\n     \\n         int[][] res = new int[K][2];\\n            \\n         for(int i = 0; i < K; i++){\\n             res[i] = maxHeap.remove();\\n         }\\n        \\n        return res;\\n          \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a,b)->( (b[0]*b[0]+b[1]*b[1]) - (a[0]*a[0]+a[1]*a[1])));\\n        //Store first K points in the maxHeap\\n        for(int i = 0; i < K; i++){\\n            maxHeap.add(points[i]);\\n        }\\n        //for the rest of the points in input array, compare each point with the max value in maxHeap, if points[i] distance is smaller than maxHeap.peek() distance, remove the max point in maxHeap and add the points[i] in maxHeap.\\n\\t\\t\\n        for(int i = K; i < points.length; i++){\\n            int pDist = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            int[] maxPoint = maxHeap.peek();\\n            int maxDist = maxPoint[0]*maxPoint[0] + maxPoint[1]*maxPoint[1];\\n            if(pDist < maxDist){\\n                maxHeap.poll();\\n                maxHeap.add(points[i]);\\n            }\\n        }\\n     \\n         int[][] res = new int[K][2];\\n            \\n         for(int i = 0; i < K; i++){\\n             res[i] = maxHeap.remove();\\n         }\\n        \\n        return res;\\n          \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934685,
                "title": "easy-o-klogn-n-solution-better-than-o-nlogk",
                "content": "```\\ndef kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n\\tdist = lambda p: p[0]**2 + p[1]**2\\n\\n\\tdist_list = [ (dist(p), p) for p in points]\\n\\theapq.heapify(dist_list)\\n\\n\\treturn [heapq.heappop(dist_list)[1] for _ in range(K)\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n\\tdist = lambda p: p[0]**2 + p[1]**2\\n\\n\\tdist_list = [ (dist(p), p) for p in points]\\n\\theapq.heapify(dist_list)\\n\\n\\treturn [heapq.heappop(dist_list)[1] for _ in range(K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 764117,
                "title": "one-line-js",
                "content": "```\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => (a[1] * a[1] + a[0] * a[0]) - (b[1] * b[1] + b[0] * b[0])).slice(0, K)\\n};",
                "solutionTags": [],
                "code": "```\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => (a[1] * a[1] + a[0] * a[0]) - (b[1] * b[1] + b[0] * b[0])).slice(0, K)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 723446,
                "title": "c-one-liner-with-comments",
                "content": "Very simple one liner, explaination:\\n1. OrderBy(x => ((x[0] * x[0]) + (x[1] * x[1]))):\\n* A simple formula ot get an approximation of the distance is Square root of: X^2 + Y^2, for this example we don\\'t need the square root, just the result do the sum of the squares, these ones will result in a distance, like this:\\n* (2, -2) => 2 * 2 + -2 * -2 => 4 * 4 => 8\\n* This result will be used by the lambda function to sort the array, the result is the original array as an ISortedEnumerable. If the further points were required a simple .OrderByDescending will do.\\n2. Take(K)\\n* This will take the requested amount of items out of the list.\\n3. ToArray()\\n* We have an ISortedIEnumerable, we need an array, so we make it an array.\\n\\n```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int K) => points.OrderBy(x => ((x[0] * x[0]) + (x[1] * x[1]))).Take(K).ToArray();\\n}\\n```\\n\\nThat\\'s it, this solution was better than 80% in speed and better than 7X% in storage.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int K) => points.OrderBy(x => ((x[0] * x[0]) + (x[1] * x[1]))).Take(K).ToArray();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699173,
                "title": "swift-minheap",
                "content": "```\\nclass MinHeap<Point: Comparable> {\\n    var heap: [Point]\\n\\n    init() {\\n        heap = [Point]()\\n    }\\n\\n    func parent(_ i: Int) -> Int { return (i-1)/2 }\\n    func left(_ i: Int) -> Int { return ((2*i)+1) }\\n    func right(_ i: Int) -> Int { return ((2*i)+2) }\\n\\n    func heapify(_ i: Int) {\\n        let n = heap.count\\n        let l = left(i)\\n        let r = right(i)\\n        var smallest = i\\n\\n        // check if left index is within bounds\\n        // check if left child is smaller than the root\\n        if l < n && heap[l] < heap[i] {\\n            smallest = l\\n        }\\n\\n        // check if right index is within bounds\\n        // check if right child is smaller than the root\\n        if r < n && heap[r] < heap[smallest] {\\n            smallest = r\\n        }\\n\\n        // swap the child and the parent only\\n        // if any of the child is smaller\\n        if smallest != i {\\n            heap.swapAt(i, smallest)\\n            heapify(smallest)\\n        }\\n    }\\n\\n    // insert at the end of the list\\n    // and shift up to the root\\n    func insert(item: Point) {\\n        heap.append(item)\\n        var lastIndex = heap.count - 1\\n\\n        while heap[parent(lastIndex)] > item {\\n            heap.swapAt(lastIndex, parent(lastIndex))\\n            lastIndex = parent(lastIndex)\\n        }\\n    }\\n\\n    // swap the first and last item in the list\\n    // and shift down\\n    func extractMin() -> Point? {\\n        if heap.count == 0 {\\n            return nil\\n        }\\n        let root = heap[0]\\n        heap.swapAt(0, heap.count - 1)\\n        heap.removeLast()\\n        heapify(0)\\n        return root\\n    }\\n\\n    func removeItem(at index: Int) {\\n        if heap.isEmpty { return }\\n        heap.swapAt(index, heap.count - 1)\\n        heap.removeLast()\\n        heapify(index)\\n    }\\n    \\n    func peek() -> Point? {\\n        if heap.isEmpty { return nil }\\n        return heap[0]\\n    }\\n    \\n    func kThLargest(_ k: Int) -> Point? {\\n        while heap.count > k {\\n            removeItem(at: 0)\\n        }\\n        return peek()\\n    }\\n}\\n\\nstruct Point {\\n    let x: Int\\n    let y: Int\\n}\\n\\nextension Point: Comparable {\\n    static func < (lhs: Point, rhs: Point) -> Bool {\\n        let x1 = lhs.x * lhs.x;\\n        let y1 = lhs.y * lhs.y;\\n        let x2 = rhs.x * rhs.x;\\n        let y2 = rhs.y * rhs.y;\\n        \\n        return (x1 + y1) < (x2 + y2);\\n    }\\n}\\n\\nclass Solution {\\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\\n\\n        if points.count < K {\\n            return []\\n        }\\n\\n        let minHeap = MinHeap<Point>()\\n\\n        for point in points {\\n            minHeap.insert(item: Point(x: point[0], y: point[1]))\\n        }\\n        var result = [[Int]]()\\n\\n        var i = 0\\n\\n        while i < K {\\n            let n = minHeap.extractMin()!\\n            result.append([n.x,n.y])\\n            i+=1\\n        }\\n    \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass MinHeap<Point: Comparable> {\\n    var heap: [Point]\\n\\n    init() {\\n        heap = [Point]()\\n    }\\n\\n    func parent(_ i: Int) -> Int { return (i-1)/2 }\\n    func left(_ i: Int) -> Int { return ((2*i)+1) }\\n    func right(_ i: Int) -> Int { return ((2*i)+2) }\\n\\n    func heapify(_ i: Int) {\\n        let n = heap.count\\n        let l = left(i)\\n        let r = right(i)\\n        var smallest = i\\n\\n        // check if left index is within bounds\\n        // check if left child is smaller than the root\\n        if l < n && heap[l] < heap[i] {\\n            smallest = l\\n        }\\n\\n        // check if right index is within bounds\\n        // check if right child is smaller than the root\\n        if r < n && heap[r] < heap[smallest] {\\n            smallest = r\\n        }\\n\\n        // swap the child and the parent only\\n        // if any of the child is smaller\\n        if smallest != i {\\n            heap.swapAt(i, smallest)\\n            heapify(smallest)\\n        }\\n    }\\n\\n    // insert at the end of the list\\n    // and shift up to the root\\n    func insert(item: Point) {\\n        heap.append(item)\\n        var lastIndex = heap.count - 1\\n\\n        while heap[parent(lastIndex)] > item {\\n            heap.swapAt(lastIndex, parent(lastIndex))\\n            lastIndex = parent(lastIndex)\\n        }\\n    }\\n\\n    // swap the first and last item in the list\\n    // and shift down\\n    func extractMin() -> Point? {\\n        if heap.count == 0 {\\n            return nil\\n        }\\n        let root = heap[0]\\n        heap.swapAt(0, heap.count - 1)\\n        heap.removeLast()\\n        heapify(0)\\n        return root\\n    }\\n\\n    func removeItem(at index: Int) {\\n        if heap.isEmpty { return }\\n        heap.swapAt(index, heap.count - 1)\\n        heap.removeLast()\\n        heapify(index)\\n    }\\n    \\n    func peek() -> Point? {\\n        if heap.isEmpty { return nil }\\n        return heap[0]\\n    }\\n    \\n    func kThLargest(_ k: Int) -> Point? {\\n        while heap.count > k {\\n            removeItem(at: 0)\\n        }\\n        return peek()\\n    }\\n}\\n\\nstruct Point {\\n    let x: Int\\n    let y: Int\\n}\\n\\nextension Point: Comparable {\\n    static func < (lhs: Point, rhs: Point) -> Bool {\\n        let x1 = lhs.x * lhs.x;\\n        let y1 = lhs.y * lhs.y;\\n        let x2 = rhs.x * rhs.x;\\n        let y2 = rhs.y * rhs.y;\\n        \\n        return (x1 + y1) < (x2 + y2);\\n    }\\n}\\n\\nclass Solution {\\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\\n\\n        if points.count < K {\\n            return []\\n        }\\n\\n        let minHeap = MinHeap<Point>()\\n\\n        for point in points {\\n            minHeap.insert(item: Point(x: point[0], y: point[1]))\\n        }\\n        var result = [[Int]]()\\n\\n        var i = 0\\n\\n        while i < K {\\n            let n = minHeap.extractMin()!\\n            result.append([n.x,n.y])\\n            i+=1\\n        }\\n    \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672813,
                "title": "two-ways-to-solve-the-problem-in-python3-using-heaps-and-sorting",
                "content": "The first method is using heaps\\n```\\nfrom math import sqrt\\nimport heapq\\nclass Solution:\\n    \\n    def distance(self,x1,y1):\\n        return sqrt((x1**2)+(y1**2))\\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        heap = []\\n        for i in points:\\n            heapq.heappush(heap,(-self.distance(i[0],i[1]),i))\\n            if len(heap)>K:\\n                heapq.heappop(heap)\\n        result = []\\n        for i in heap:\\n            result.append(i[1])\\n        return result\\n```\\n\\nThe second method is to sort the list based on the distance\\n```\\nclass Solution:\\n    \\n    def distance(self,x1,y1):\\n        return sqrt((x1**2)+(y1**2))\\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        points.sort(key = lambda x:self.distance(x[0],x[1]))\\n        return points[:K]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import sqrt\\nimport heapq\\nclass Solution:\\n    \\n    def distance(self,x1,y1):\\n        return sqrt((x1**2)+(y1**2))\\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        heap = []\\n        for i in points:\\n            heapq.heappush(heap,(-self.distance(i[0],i[1]),i))\\n            if len(heap)>K:\\n                heapq.heappop(heap)\\n        result = []\\n        for i in heap:\\n            result.append(i[1])\\n        return result\\n```\n```\\nclass Solution:\\n    \\n    def distance(self,x1,y1):\\n        return sqrt((x1**2)+(y1**2))\\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        points.sort(key = lambda x:self.distance(x[0],x[1]))\\n        return points[:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660092,
                "title": "rust-3-idiomatic-solutions-explained-sort-heap-and-quickselect",
                "content": "#### 1. Sorting\\n\\nThis solution is the simplest, but the most expensive with a complexity of `O(n.log(n) + k)`.\\nN.B.: `distance` doesn\\'t need to be the Euclidian distance per-se and use `sqrt`, since the `sqrt` function is monotone and, therefore, wouldn\\'t change the ordering.\\n\\n```rust\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nimpl Solution {\\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let distance = |p: &Vec<i32>| p[X] * p[X] + p[Y] * p[Y];\\n        points.sort_by(|p1, p2| distance(p1).cmp(&distance(p2)));\\n        points[..k].to_vec()\\n    }\\n}\\n```\\n\\n##### Performance\\n\\n> Runtime: 40 ms, faster than 44.83% of Rust online submissions for K Closest Points to Origin.\\n> Memory Usage: 3 MB, less than 100.00% of Rust online submissions for K Closest Points to Origin.\\n\\n#### 2. Heap\\n\\nAnother approach is to keep adding items to a max heap capped at size `k`, removing the largest item every time the heap is \"full\", and returning the resulting content as a vector. This allows us reduce the complexity to be `O(n.log(k) + k)`.\\n\\nHowever, a `Point` struct and a fair bit of conversions and boilerplate is required to have an idiomatic solution.\\nN.B.: Depending on how idiomatic you want your solution to be, some of that boilerplate can be replaced by explicit conversions.\\n\\n```rust\\nuse std::iter::FromIterator;\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\nuse std::convert::From;\\n\\nimpl Solution {\\n    pub fn k_closest(points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let mut heap = BinaryHeap::with_capacity(k + 1);\\n        for point in points.iter() {\\n            heap.push(point.into()); // Enabled by: From<&Vec<i32>> for Point\\n            if heap.len() == k + 1 {\\n                heap.pop(); // Remove the point with largest distance to origin. Enabled by: Ord for Point\\n            } \\n        }\\n        heap.into_sorted_vec().iter().collect::<Vec<Vec<i32>>>() // Enabled by: FromIterator\\n    }\\n}\\n\\n#[derive(Eq, PartialEq)]\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    fn distance(&self) -> i32 {\\n        self.x * self.x + self.y * self.y\\n    }    \\n}\\n\\nimpl Ord for Point {\\n    fn cmp(&self, other: &Point) -> Ordering {\\n        self.distance().cmp(&other.distance())\\n    }\\n}\\n\\nimpl PartialOrd for Point {\\n    fn partial_cmp(&self, other: &Point) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nimpl From<&Vec<i32>> for Point {\\n    // Converts from a &Vec<i32> to a Point, which lets us call vec.into() when constructing the heap.\\n    fn from(point: &Vec<i32>) -> Self {\\n        Point{ x: point[X], y: point[Y] }\\n    }\\n}\\n\\nimpl From<&Point> for Vec<i32> {\\n    // Converts from a &Point to a Vec<i32>, which lets us call point.into() when converting from iterator of points into an iterator of Vec<i32>.\\n    fn from(point: &Point) -> Self {\\n        vec![point.x, point.y]\\n    }\\n}\\n\\nimpl<\\'a> FromIterator<&\\'a Point> for Vec<Vec<i32>> {\\n    fn from_iter<I: IntoIterator<Item=&\\'a Point>>(iter: I) -> Self {\\n        let mut points = Vec::new();\\n        for point in iter {\\n            points.push(point.into()); // Enabled by: From<&Point> for Vec<i32>\\n        }\\n        points\\n    }\\n}\\n```\\n\\n##### Performance\\n\\n> Runtime: 36 ms, faster than 82.76% of Rust online submissions for K Closest Points to Origin.\\n> Memory Usage: 3 MB, less than 100.00% of Rust online submissions for K Closest Points to Origin.\\n\\n#### 3. QuickSelect\\n\\nAnother solution is to implement the [QuickSelect](https://en.wikipedia.org/wiki/Quickselect) algorithm, which, in the average case, should give us `O(n + k)`:\\n\\n```rust\\nimpl Solution {\\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let (mut lo, mut hi) = (0, points.len() - 1);\\n        while lo <= hi {\\n            let pivot = partition(&mut points, lo, hi);\\n            if pivot < k {\\n                lo = pivot + 1;\\n            } else if pivot > k {\\n                hi = pivot - 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        points[..k].to_vec()\\n    }\\n}\\n\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nfn distance(point: &Vec<i32>) -> i32 {\\n    point[X] * point[X] + point[Y] * point[Y]\\n}\\n\\nfn partition(points: &mut Vec<Vec<i32>>, mut lo: usize, mut hi: usize) -> usize {\\n    // Approach: Hoare partitioning.\\n    let pivot = lo;\\n    while lo < hi {\\n        while lo < hi && distance(&points[pivot]) <= distance(&points[hi]) {\\n            hi -= 1;\\n        }\\n        while lo < hi && distance(&points[lo]) <= distance(&points[pivot]) {\\n            lo += 1;\\n        }\\n        points.swap(lo, hi);\\n    }\\n    points.swap(lo, pivot);\\n    lo\\n}\\n```\\n\\nAn alternative partitioning is the following one:\\n```rust\\nfn partition(points: &mut Vec<Vec<i32>>, mut lo: usize, mut hi: usize) -> usize {\\n    // Approach: Lomuto partitioning.\\n    // Partition points so that we end up with:\\n    //   lo            l        r  hi\\n    //   [ point <=, pivot, < point ]\\n    //\\n    // The pivot value can be chosen randomly in [lo, hi],\\n    // but here we just pick points[hi] for convenience.\\n    let mut l = lo;\\n    for r in lo..hi {\\n        if distance(&points[r]) <= distance(&points[hi]) {\\n            points.swap(l, r);\\n            l += 1;\\n        }\\n    }\\n    points.swap(l, hi);\\n    l\\n}\\n```\\n\\n\\n\\n##### Performance\\n\\n> Runtime: 24 ms, faster than 100.00% of Rust online submissions for K Closest Points to Origin.\\n> Memory Usage: 3 MB, less than 100.00% of Rust online submissions for K Closest Points to Origin.",
                "solutionTags": [
                    "Rust",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```rust\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nimpl Solution {\\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let distance = |p: &Vec<i32>| p[X] * p[X] + p[Y] * p[Y];\\n        points.sort_by(|p1, p2| distance(p1).cmp(&distance(p2)));\\n        points[..k].to_vec()\\n    }\\n}\\n```\n```rust\\nuse std::iter::FromIterator;\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\nuse std::convert::From;\\n\\nimpl Solution {\\n    pub fn k_closest(points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let mut heap = BinaryHeap::with_capacity(k + 1);\\n        for point in points.iter() {\\n            heap.push(point.into()); // Enabled by: From<&Vec<i32>> for Point\\n            if heap.len() == k + 1 {\\n                heap.pop(); // Remove the point with largest distance to origin. Enabled by: Ord for Point\\n            } \\n        }\\n        heap.into_sorted_vec().iter().collect::<Vec<Vec<i32>>>() // Enabled by: FromIterator\\n    }\\n}\\n\\n#[derive(Eq, PartialEq)]\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    fn distance(&self) -> i32 {\\n        self.x * self.x + self.y * self.y\\n    }    \\n}\\n\\nimpl Ord for Point {\\n    fn cmp(&self, other: &Point) -> Ordering {\\n        self.distance().cmp(&other.distance())\\n    }\\n}\\n\\nimpl PartialOrd for Point {\\n    fn partial_cmp(&self, other: &Point) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nimpl From<&Vec<i32>> for Point {\\n    // Converts from a &Vec<i32> to a Point, which lets us call vec.into() when constructing the heap.\\n    fn from(point: &Vec<i32>) -> Self {\\n        Point{ x: point[X], y: point[Y] }\\n    }\\n}\\n\\nimpl From<&Point> for Vec<i32> {\\n    // Converts from a &Point to a Vec<i32>, which lets us call point.into() when converting from iterator of points into an iterator of Vec<i32>.\\n    fn from(point: &Point) -> Self {\\n        vec![point.x, point.y]\\n    }\\n}\\n\\nimpl<\\'a> FromIterator<&\\'a Point> for Vec<Vec<i32>> {\\n    fn from_iter<I: IntoIterator<Item=&\\'a Point>>(iter: I) -> Self {\\n        let mut points = Vec::new();\\n        for point in iter {\\n            points.push(point.into()); // Enabled by: From<&Point> for Vec<i32>\\n        }\\n        points\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let (mut lo, mut hi) = (0, points.len() - 1);\\n        while lo <= hi {\\n            let pivot = partition(&mut points, lo, hi);\\n            if pivot < k {\\n                lo = pivot + 1;\\n            } else if pivot > k {\\n                hi = pivot - 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        points[..k].to_vec()\\n    }\\n}\\n\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nfn distance(point: &Vec<i32>) -> i32 {\\n    point[X] * point[X] + point[Y] * point[Y]\\n}\\n\\nfn partition(points: &mut Vec<Vec<i32>>, mut lo: usize, mut hi: usize) -> usize {\\n    // Approach: Hoare partitioning.\\n    let pivot = lo;\\n    while lo < hi {\\n        while lo < hi && distance(&points[pivot]) <= distance(&points[hi]) {\\n            hi -= 1;\\n        }\\n        while lo < hi && distance(&points[lo]) <= distance(&points[pivot]) {\\n            lo += 1;\\n        }\\n        points.swap(lo, hi);\\n    }\\n    points.swap(lo, pivot);\\n    lo\\n}\\n```\n```rust\\nfn partition(points: &mut Vec<Vec<i32>>, mut lo: usize, mut hi: usize) -> usize {\\n    // Approach: Lomuto partitioning.\\n    // Partition points so that we end up with:\\n    //   lo            l        r  hi\\n    //   [ point <=, pivot, < point ]\\n    //\\n    // The pivot value can be chosen randomly in [lo, hi],\\n    // but here we just pick points[hi] for convenience.\\n    let mut l = lo;\\n    for r in lo..hi {\\n        if distance(&points[r]) <= distance(&points[hi]) {\\n            points.swap(l, r);\\n            l += 1;\\n        }\\n    }\\n    points.swap(l, hi);\\n    l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 659855,
                "title": "c-sorting-with-lambda-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n        sort(points.begin(),points.end(),[](vector<int>p1,vector<int>p2) -> bool{ \\n            return (p1[0]*p1[0]+p1[1]*p1[1] <= p2[0]*p2[0]+p2[1]*p2[1]);\\n        });\\n        vector<vector<int>>res;\\n        for(int i = 0; i < K; i++) {\\n             res.push_back(points[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n        sort(points.begin(),points.end(),[](vector<int>p1,vector<int>p2) -> bool{ \\n            return (p1[0]*p1[0]+p1[1]*p1[1] <= p2[0]*p2[0]+p2[1]*p2[1]);\\n        });\\n        vector<vector<int>>res;\\n        for(int i = 0; i < K; i++) {\\n             res.push_back(points[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609303,
                "title": "python-quickselect-works-with-duplicates",
                "content": "I saw a few python quickselect accepted solutions simply don\\'t pass test cases with duplicates: points=[[2,2],[2,2],[2,2],[2,2],[1,1]]; K=3 \\n\\nTo not panic in the interview, strictly follow this [non in-place quick sort template](https://leetcode.com/problems/sort-an-array/discuss/277127/7-line-quicksort-to-write-in-interviews-(Python)).\\n\\nFor this question, the complete code:\\n```python\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        if len(points)<=1 or K >= len(points):\\n            return points\\n\\n        def dist(p):\\n            x,y = p\\n            return x*x+y*y\\n        \\n        def quickselect(n, k):\\n            if k == 1:\\n                return [min(n,key = dist)]\\n            \\n            if k == len(n):\\n                return n\\n\\n            pivot = choice(n)\\n            left = [i for i in n if dist(i) < dist(pivot)]\\n            mid = [i for i in n if dist(i) == dist(pivot)]\\n            right = [i for i in n if dist(i) > dist(pivot)]\\n            \\n            if len(left) > k:\\n                return quickselect(left,k)\\n            \\n            if len(left)<=k<=len(left)+len(mid):\\n                return left+mid[:k-len(left)]\\n            \\n            if len(left)+len(mid)<k:\\n                return left+mid+quickselect(right,k-len(left)-len(mid))\\n            \\n        return quickselect(points,K)",
                "solutionTags": [
                    "Python",
                    "Quickselect"
                ],
                "code": "I saw a few python quickselect accepted solutions simply don\\'t pass test cases with duplicates: points=[[2,2],[2,2],[2,2],[2,2],[1,1]]; K=3 \\n\\nTo not panic in the interview, strictly follow this [non in-place quick sort template](https://leetcode.com/problems/sort-an-array/discuss/277127/7-line-quicksort-to-write-in-interviews-(Python)).\\n\\nFor this question, the complete code:\\n```python\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        if len(points)<=1 or K >= len(points):\\n            return points\\n\\n        def dist(p):\\n            x,y = p\\n            return x*x+y*y\\n        \\n        def quickselect(n, k):\\n            if k == 1:\\n                return [min(n,key = dist)]\\n            \\n            if k == len(n):\\n                return n\\n\\n            pivot = choice(n)\\n            left = [i for i in n if dist(i) < dist(pivot)]\\n            mid = [i for i in n if dist(i) == dist(pivot)]\\n            right = [i for i in n if dist(i) > dist(pivot)]\\n            \\n            if len(left) > k:\\n                return quickselect(left,k)\\n            \\n            if len(left)<=k<=len(left)+len(mid):\\n                return left+mid[:k-len(left)]\\n            \\n            if len(left)+len(mid)<k:\\n                return left+mid+quickselect(right,k-len(left)-len(mid))\\n            \\n        return quickselect(points,K)",
                "codeTag": "Java"
            },
            {
                "id": 453148,
                "title": "javascript-sorting-based",
                "content": "```javascript\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => {\\n       return Math.sqrt(Math.pow(a[0],2) + Math.pow(a[1],2)) - Math.sqrt(Math.pow(b[0],2) + Math.pow(b[1],2));\\n    });\\n        \\n    const res = [];\\n    for (let i = 0; i < K; ++i) {\\n        res.push(points[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => {\\n       return Math.sqrt(Math.pow(a[0],2) + Math.pow(a[1],2)) - Math.sqrt(Math.pow(b[0],2) + Math.pow(b[1],2));\\n    });\\n        \\n    const res = [];\\n    for (let i = 0; i < K; ++i) {\\n        res.push(points[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429927,
                "title": "java-runtime-o-nlogn-memory-o-1-6-lines",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points,(a,b)->{\\n            int distA = a[0]*a[0]+a[1]*a[1];\\n            int distB = b[0]*b[0]+b[1]*b[1];\\n            return distA-distB;\\n        });\\n        return Arrays.copyOfRange(points,0,K);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points,(a,b)->{\\n            int distA = a[0]*a[0]+a[1]*a[1];\\n            int distB = b[0]*b[0]+b[1]*b[1];\\n            return distA-distB;\\n        });\\n        return Arrays.copyOfRange(points,0,K);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425375,
                "title": "java-priority-queue",
                "content": "According to the structure of heap, we can easily think of priority queue in solving getting k-max or k-min problems.\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n         PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a,b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]));\\n         for(int i=0;i<points.length;i++){\\n             pq.add(points[i]);\\n         }\\n        int res[][] = new int[K][2];\\n        for(int i=0;i<K;i++){\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n         PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a,b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]));\\n         for(int i=0;i<points.length;i++){\\n             pq.add(points[i]);\\n         }\\n        int res[][] = new int[K][2];\\n        for(int i=0;i<K;i++){\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382686,
                "title": "100-priority-queue-pqueue-optimised-partition-median-of-median-java-easy-to-understand",
                "content": "**Priority Queue:**\\n\\n```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 69 ms, faster than 8.87% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 60.2 MB, less than 65.22% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPriorityQueue {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final PriorityQueue<Pair<int[], Double>> pq = new PriorityQueue<>(Comparator.comparingDouble(Pair::getValue));\\n\\n        final List<Pair<int[], Double>> distanceList = new ArrayList<>(points.length);\\n        for (int[] point : points) {\\n            distanceList.add(new Pair<>(point, distance(point[0], point[1])));\\n        }\\n        pq.addAll(distanceList);\\n\\n        final int[][] result = new int[k][2];\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            int[] point = pq.poll().getKey();\\n            result[k - 1][0] = point[0];\\n            result[k - 1][1] = point[1];\\n\\n            k--;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```\\n\\n**Priority Queue optimized: **\\n\\n```\\n\\n/**\\n * O(k*log(n))\\n * Runtime: 66 ms, faster than 10.38% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 59.7 MB, less than 73.91% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPriorityQueueOptimized {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final PriorityQueue<int[]> pq = new PriorityQueue<>(((o1, o2) -> {\\n            double d1 = distance(o1[0], o1[1]);\\n            double d2 = distance(o2[0], o2[1]);\\n\\n            return -Double.compare(d1, d2);\\n        }));\\n\\n\\n        for (int[] point : points) {\\n            pq.offer(point);\\n\\n            if (pq.size() > k) pq.poll(); //remove greatest distance from pq\\n        }\\n\\n\\n        final int[][] result = new int[k][2];\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            result[k - 1] = pq.poll();\\n\\n            k--;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```\\n\\n**Partition Algo: Quick select **\\n\\nWorst case : O(n*log(n))\\n\\n```\\n\\n/**\\n * We\\'ll use Quicksort partition logic to partition the array based on \\'k\\' element in the array. This way we\\'ll avoid sorting complete array\\n * <p>\\n * Runtime: 4 ms, faster than 99.69% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 61.2 MB, less than 47.21% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPartition {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n        int l = 0, r = points.length - 1;\\n\\n\\n        while (l <= r) {\\n\\n            int partitionIndex = partition(points, l, r, points[l]);\\n\\n            if (partitionIndex == k)\\n                break;\\n\\n            if (partitionIndex > k)\\n                r = partitionIndex - 1;\\n            else\\n                l = partitionIndex + 1;\\n\\n        }\\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n\\n    private int partition(int[][] points, int l, int r, int[] pivot) {\\n        int i;\\n        for (i = l; i < r; i++) {\\n\\n            if (compare(points[i], pivot) == 0)\\n                break;\\n        }\\n        swap(points, i, r);\\n\\n        i = l;\\n        for (int j = l; j < r; j++) {\\n\\n            if (compare(points[j], pivot) <= 0) {\\n                swap(points, i, j);\\n                i++;\\n            }\\n        }\\n        swap(points, i, r);\\n        return i;\\n    }\\n\\n\\n    private int compare(int[] p1, int[] p2) {\\n        int x = p1[0] * p1[0] + p1[1] * p1[1]; //(x1^2 + y1^2)\\n        int y = p2[0] * p2[0] + p2[1] * p2[1]; //(x2^2 + y2^2)\\n        return x - y;\\n    }\\n\\n\\n    private void swap(int[][] points, int i, int j) {\\n\\n        final int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n}\\n```\\n\\n**Partition : Median of Median.**\\nWorst case O(n)\\n\\n```\\n\\n/**\\n * Avoid below algorithm as though its O(n) but has more computation then needed. Its good for very huge array.\\n * {@link Java.KthLargestElement} #KthSmallest\\n * We\\'ll apply same logic as finding the kthSmallest element. Once we partition the array at index \\'partition\\'\\n * 1. if partition = k then all the element on left side of this index would be lesser than elements on right side of partition\\n * 2. otherwise either we need to go left or right based on partition vs k\\n * <p>\\n * To find partition point efficiently we\\'ll use median of median algorithm\\n * <p>\\n * Runtime: 63 ms, faster than 16.80% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 63 MB, less than 34.16% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPartitionMedianOfMedian {\\n\\n    static class Pair {\\n        int key;\\n        double distance;\\n\\n        public Pair(int key, double distance) {\\n            this.key = key;\\n            this.distance = distance;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"key=\" + key +\\n                    \", distance=\" + distance +\\n                    \\'}\\';\\n        }\\n    }\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final Pair[] distanceList = new Pair[points.length];\\n\\n        for (int i = 0; i < points.length; i++) {\\n            int[] point = points[i];\\n            distanceList[i] = new Pair(i, distance(point[0], point[1]));\\n        }\\n\\n        if (distanceList.length <= 5) {\\n            Arrays.sort(distanceList, Comparator.comparingDouble(o -> o.distance));\\n            return getKValues(distanceList, points, k);\\n        }\\n\\n        int n = distanceList.length;\\n        final Double distance = kthLargestElement(distanceList, 0, n - 1, k);\\n\\n        final int[][] result = new int[k][2];\\n        int p = 0;\\n\\n        for (int i = 0; i < n && p < k; i++) {\\n            if (Double.compare(distanceList[i].distance, distance) <= 0)\\n                result[p++] = points[distanceList[i].key];\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    private int[][] getKValues(final Pair[] distanceList, int[][] points, int k) {\\n        final int[][] result = new int[k][2];\\n\\n        int i = 0;\\n        while (k > 0) {\\n            result[k - 1] = points[distanceList[i++].key];\\n            k--;\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    private Double kthLargestElement(Pair[] distanceList, int l, int r, int k) {\\n\\n        final int n = r - l + 1;\\n\\n        if (k > 0 && k <= n) {\\n\\n            final Pair[] median = new Pair[(n + 4) / 5];\\n            int i;\\n            for (i = 0; i < n / 5; i++) {\\n                median[i] = findMedian(distanceList, l + i * 5, 5);\\n            }\\n\\n            if (i * 5 < n) {\\n                median[i] = findMedian(distanceList, l + i * 5, n % 5);\\n                i++;\\n            }\\n\\n            final double medianOfMedian = (i == 1)\\n                    ? median[0].distance\\n                    : kthLargestElement(median, 0, i - 1, i / 2); //find median of median array\\n\\n            final int partitionIndex = partition(distanceList, l, r, medianOfMedian);\\n\\n            if (partitionIndex - l == k - 1)\\n                return distanceList[partitionIndex].distance;\\n            else if (partitionIndex - l > k - 1)\\n                return kthLargestElement(distanceList, l, partitionIndex - 1, k);\\n            else // k-1 > p - l => k > p -l+1 => k < -p+l-1 =>\\n                return kthLargestElement(distanceList, partitionIndex + 1, r, k - partitionIndex + l - 1);\\n        }\\n\\n\\n        return -1.0;\\n    }\\n\\n    private int partition(Pair[] distanceList, int l, int r, double pivot) {\\n\\n        int i;\\n        for (i = l; i < r; i++) {\\n\\n            if (Double.compare(distanceList[i].distance, pivot) == 0) {\\n                break;\\n            }\\n        }\\n\\n        swap(distanceList, i, r);\\n\\n        i = l;\\n        for (int j = l; j < r; j++) {\\n            if (Double.compare(distanceList[j].distance, pivot) <= 0) {\\n                swap(distanceList, i, j);\\n                i++;\\n            }\\n        }\\n        swap(distanceList, i, r);\\n        return i;\\n\\n    }\\n\\n    private void swap(Pair[] distanceList, int i, int j) {\\n\\n        final Pair temp = distanceList[i];\\n        distanceList[i] = distanceList[j];\\n        distanceList[j] = temp;\\n    }\\n\\n    private Pair findMedian(Pair[] distanceList, int i, int n) {\\n        Arrays.sort(distanceList, i, i + n, Comparator.comparingDouble(o -> o.distance));\\n        return distanceList[i + (n / 2)];\\n    }\\n\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 69 ms, faster than 8.87% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 60.2 MB, less than 65.22% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPriorityQueue {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final PriorityQueue<Pair<int[], Double>> pq = new PriorityQueue<>(Comparator.comparingDouble(Pair::getValue));\\n\\n        final List<Pair<int[], Double>> distanceList = new ArrayList<>(points.length);\\n        for (int[] point : points) {\\n            distanceList.add(new Pair<>(point, distance(point[0], point[1])));\\n        }\\n        pq.addAll(distanceList);\\n\\n        final int[][] result = new int[k][2];\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            int[] point = pq.poll().getKey();\\n            result[k - 1][0] = point[0];\\n            result[k - 1][1] = point[1];\\n\\n            k--;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * O(k*log(n))\\n * Runtime: 66 ms, faster than 10.38% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 59.7 MB, less than 73.91% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPriorityQueueOptimized {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final PriorityQueue<int[]> pq = new PriorityQueue<>(((o1, o2) -> {\\n            double d1 = distance(o1[0], o1[1]);\\n            double d2 = distance(o2[0], o2[1]);\\n\\n            return -Double.compare(d1, d2);\\n        }));\\n\\n\\n        for (int[] point : points) {\\n            pq.offer(point);\\n\\n            if (pq.size() > k) pq.poll(); //remove greatest distance from pq\\n        }\\n\\n\\n        final int[][] result = new int[k][2];\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            result[k - 1] = pq.poll();\\n\\n            k--;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * We\\'ll use Quicksort partition logic to partition the array based on \\'k\\' element in the array. This way we\\'ll avoid sorting complete array\\n * <p>\\n * Runtime: 4 ms, faster than 99.69% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 61.2 MB, less than 47.21% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPartition {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n        int l = 0, r = points.length - 1;\\n\\n\\n        while (l <= r) {\\n\\n            int partitionIndex = partition(points, l, r, points[l]);\\n\\n            if (partitionIndex == k)\\n                break;\\n\\n            if (partitionIndex > k)\\n                r = partitionIndex - 1;\\n            else\\n                l = partitionIndex + 1;\\n\\n        }\\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n\\n    private int partition(int[][] points, int l, int r, int[] pivot) {\\n        int i;\\n        for (i = l; i < r; i++) {\\n\\n            if (compare(points[i], pivot) == 0)\\n                break;\\n        }\\n        swap(points, i, r);\\n\\n        i = l;\\n        for (int j = l; j < r; j++) {\\n\\n            if (compare(points[j], pivot) <= 0) {\\n                swap(points, i, j);\\n                i++;\\n            }\\n        }\\n        swap(points, i, r);\\n        return i;\\n    }\\n\\n\\n    private int compare(int[] p1, int[] p2) {\\n        int x = p1[0] * p1[0] + p1[1] * p1[1]; //(x1^2 + y1^2)\\n        int y = p2[0] * p2[0] + p2[1] * p2[1]; //(x2^2 + y2^2)\\n        return x - y;\\n    }\\n\\n\\n    private void swap(int[][] points, int i, int j) {\\n\\n        final int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n}\\n```\n```\\n\\n/**\\n * Avoid below algorithm as though its O(n) but has more computation then needed. Its good for very huge array.\\n * {@link Java.KthLargestElement} #KthSmallest\\n * We\\'ll apply same logic as finding the kthSmallest element. Once we partition the array at index \\'partition\\'\\n * 1. if partition = k then all the element on left side of this index would be lesser than elements on right side of partition\\n * 2. otherwise either we need to go left or right based on partition vs k\\n * <p>\\n * To find partition point efficiently we\\'ll use median of median algorithm\\n * <p>\\n * Runtime: 63 ms, faster than 16.80% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 63 MB, less than 34.16% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPartitionMedianOfMedian {\\n\\n    static class Pair {\\n        int key;\\n        double distance;\\n\\n        public Pair(int key, double distance) {\\n            this.key = key;\\n            this.distance = distance;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"key=\" + key +\\n                    \", distance=\" + distance +\\n                    \\'}\\';\\n        }\\n    }\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final Pair[] distanceList = new Pair[points.length];\\n\\n        for (int i = 0; i < points.length; i++) {\\n            int[] point = points[i];\\n            distanceList[i] = new Pair(i, distance(point[0], point[1]));\\n        }\\n\\n        if (distanceList.length <= 5) {\\n            Arrays.sort(distanceList, Comparator.comparingDouble(o -> o.distance));\\n            return getKValues(distanceList, points, k);\\n        }\\n\\n        int n = distanceList.length;\\n        final Double distance = kthLargestElement(distanceList, 0, n - 1, k);\\n\\n        final int[][] result = new int[k][2];\\n        int p = 0;\\n\\n        for (int i = 0; i < n && p < k; i++) {\\n            if (Double.compare(distanceList[i].distance, distance) <= 0)\\n                result[p++] = points[distanceList[i].key];\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    private int[][] getKValues(final Pair[] distanceList, int[][] points, int k) {\\n        final int[][] result = new int[k][2];\\n\\n        int i = 0;\\n        while (k > 0) {\\n            result[k - 1] = points[distanceList[i++].key];\\n            k--;\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    private Double kthLargestElement(Pair[] distanceList, int l, int r, int k) {\\n\\n        final int n = r - l + 1;\\n\\n        if (k > 0 && k <= n) {\\n\\n            final Pair[] median = new Pair[(n + 4) / 5];\\n            int i;\\n            for (i = 0; i < n / 5; i++) {\\n                median[i] = findMedian(distanceList, l + i * 5, 5);\\n            }\\n\\n            if (i * 5 < n) {\\n                median[i] = findMedian(distanceList, l + i * 5, n % 5);\\n                i++;\\n            }\\n\\n            final double medianOfMedian = (i == 1)\\n                    ? median[0].distance\\n                    : kthLargestElement(median, 0, i - 1, i / 2); //find median of median array\\n\\n            final int partitionIndex = partition(distanceList, l, r, medianOfMedian);\\n\\n            if (partitionIndex - l == k - 1)\\n                return distanceList[partitionIndex].distance;\\n            else if (partitionIndex - l > k - 1)\\n                return kthLargestElement(distanceList, l, partitionIndex - 1, k);\\n            else // k-1 > p - l => k > p -l+1 => k < -p+l-1 =>\\n                return kthLargestElement(distanceList, partitionIndex + 1, r, k - partitionIndex + l - 1);\\n        }\\n\\n\\n        return -1.0;\\n    }\\n\\n    private int partition(Pair[] distanceList, int l, int r, double pivot) {\\n\\n        int i;\\n        for (i = l; i < r; i++) {\\n\\n            if (Double.compare(distanceList[i].distance, pivot) == 0) {\\n                break;\\n            }\\n        }\\n\\n        swap(distanceList, i, r);\\n\\n        i = l;\\n        for (int j = l; j < r; j++) {\\n            if (Double.compare(distanceList[j].distance, pivot) <= 0) {\\n                swap(distanceList, i, j);\\n                i++;\\n            }\\n        }\\n        swap(distanceList, i, r);\\n        return i;\\n\\n    }\\n\\n    private void swap(Pair[] distanceList, int i, int j) {\\n\\n        final Pair temp = distanceList[i];\\n        distanceList[i] = distanceList[j];\\n        distanceList[j] = temp;\\n    }\\n\\n    private Pair findMedian(Pair[] distanceList, int i, int n) {\\n        Arrays.sort(distanceList, i, i + n, Comparator.comparingDouble(o -> o.distance));\\n        return distanceList[i + (n / 2)];\\n    }\\n\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376730,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    // There no difference for sorting between a^2 or a\\n    const getDistanse = point => (point[0] ** 2) + (point[1] ** 2);\\n    return points.sort((a, b) => getDistanse(a) - getDistanse(b)).slice(0, K);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    // There no difference for sorting between a^2 or a\\n    const getDistanse = point => (point[0] ** 2) + (point[1] ** 2);\\n    return points.sort((a, b) => getDistanse(a) - getDistanse(b)).slice(0, K);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 337616,
                "title": "scala-solution-91-speed-100-memory-priorityqueue-solution",
                "content": "```\\nobject Solution {\\n\\n\\tcase class PointObj(c: Double, point: Array[Int])\\n\\n    def kClosest(points: Array[Array[Int]], K: Int): Array[Array[Int]] = {\\n        val pq = scala.collection.mutable.PriorityQueue.empty[PointObj](Ordering.by(_.c))        \\n        \\n        points.foreach { point =>\\n            val a = Math.pow(point.head, 2)\\n            val b = Math.pow(point.last, 2)\\n            val c = Math.sqrt(a + b)\\n            \\n            pq.enqueue(PointObj(c, point))\\n            if (pq.length > K) pq.dequeue\\n        }\\n        \\n        pq.dequeueAll.map(_.point).toArray\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n\\n\\tcase class PointObj(c: Double, point: Array[Int])\\n\\n    def kClosest(points: Array[Array[Int]], K: Int): Array[Array[Int]] = {\\n        val pq = scala.collection.mutable.PriorityQueue.empty[PointObj](Ordering.by(_.c))        \\n        \\n        points.foreach { point =>\\n            val a = Math.pow(point.head, 2)\\n            val b = Math.pow(point.last, 2)\\n            val c = Math.sqrt(a + b)\\n            \\n            pq.enqueue(PointObj(c, point))\\n            if (pq.length > K) pq.dequeue\\n        }\\n        \\n        pq.dequeueAll.map(_.point).toArray\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261028,
                "title": "python-solution-with-max-heap",
                "content": "Since Python\\'s heapq implementation does not have built in support for max heap, we can just invert the values stored into the heap so it functions as a max heap. Max heap is better than min heap because we don\\'t actually have to store all N points into the heap, we just need to keep K min points.\\n\\nTime Complexity: O(N Log(K))\\nSpace Complexity: O(K)\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        maxHeap = []\\n        \\n        for (x, y) in points:\\n            distance = math.sqrt(x*x + y*y)\\n            \\n            if len(maxHeap) >= K:\\n                if -1 * distance > maxHeap[0][0]:\\n                    heapq.heappushpop(maxHeap, [-1 * distance, [x, y]])\\n            else:\\n                heapq.heappush(maxHeap, [-1 * distance, [x, y]])\\n        \\n        resList = []\\n        \\n        for _ in range(K):\\n            resList.append(heapq.heappop(maxHeap)[1])\\n        \\n        # Return the list\\n        return resList\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        maxHeap = []\\n        \\n        for (x, y) in points:\\n            distance = math.sqrt(x*x + y*y)\\n            \\n            if len(maxHeap) >= K:\\n                if -1 * distance > maxHeap[0][0]:\\n                    heapq.heappushpop(maxHeap, [-1 * distance, [x, y]])\\n            else:\\n                heapq.heappush(maxHeap, [-1 * distance, [x, y]])\\n        \\n        resList = []\\n        \\n        for _ in range(K):\\n            resList.append(heapq.heappop(maxHeap)[1])\\n        \\n        # Return the list\\n        return resList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233694,
                "title": "python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        return sorted(points, key=lambda x: x[0]*x[0] + x[1]*x[1])[:K]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        return sorted(points, key=lambda x: x[0]*x[0] + x[1]*x[1])[:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224254,
                "title": "python3-with-o-2n-aux-space-faster-than-100",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        distanceDict = {}\\n        distanceList = []\\n        for x in points:\\n            u = math.sqrt(x[0]**2 + x[1]**2)\\n            distanceDict[u] = x\\n            distanceList.append(u)\\n        distanceList.sort()\\n        return [distanceDict[ distanceList[i] ] for i in range(K)]\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        distanceDict = {}\\n        distanceList = []\\n        for x in points:\\n            u = math.sqrt(x[0]**2 + x[1]**2)\\n            distanceDict[u] = x\\n            distanceList.append(u)\\n        distanceList.sort()\\n        return [distanceDict[ distanceList[i] ] for i in range(K)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219982,
                "title": "javascript-one-liner",
                "content": "```\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => a[0]*a[0]+a[1]*a[1] - b[0]*b[0] - b[1]*b[1]).slice(0,K);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => a[0]*a[0]+a[1]*a[1] - b[0]*b[0] - b[1]*b[1]).slice(0,K);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440705,
                "title": "very-easy-java-solution-o-n-lambda-function",
                "content": "# Intuition\\nsolving the problem using Priority Queue and sorting it with lambda function\\n\\n# Approach\\ncreate a class to store the distance , x coordinate and y coordinate of each points.\\n\\narrange them in ascending order of distance using priority queue.\\n\\nkeep the required no. of points(k).\\n\\n ```\\nex-\\n\\npoints = [1,1] , [2,3] , [0,0] , [2,0]\\n\\ndistance of points from [0,0]\\n \\ndis =     2   ,   13   ,  0    ,    4\\n\\nx   =     1   ,   2    ,  0    ,    2\\n\\nx   =     1   ,   3    ,  0    ,    0\\n```\\nnow arrange them in pq and put the required set in matrix.\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(Number of points)\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[][] kClosest(int[][] p, int k) {\\n        PriorityQueue<node> pq = new PriorityQueue<>((a,b) -> a.dis - b.dis);\\n        for(int i =0;i<p.length;i++){\\n            int total = p[i][0]*p[i][0] + p[i][1]*p[i][1];\\n            node n = new node(total,p[i][0],p[i][1]);\\n            pq.add(n);\\n        }\\n        int[][] ans = new int[k][2];\\n        for(int i =0;i<k && pq.size()>0;i++){\\n            node n = pq.poll();\\n            ans[i][0] = n.x; \\n            ans[i][1] = n.y;\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass node{\\n    node value;\\n    int dis;\\n    int x;\\n    int y;\\n    node(int dis, int x , int y){\\n        this.dis = dis;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nex-\\n\\npoints = [1,1] , [2,3] , [0,0] , [2,0]\\n\\ndistance of points from [0,0]\\n \\ndis =     2   ,   13   ,  0    ,    4\\n\\nx   =     1   ,   2    ,  0    ,    2\\n\\nx   =     1   ,   3    ,  0    ,    0\\n```\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[][] kClosest(int[][] p, int k) {\\n        PriorityQueue<node> pq = new PriorityQueue<>((a,b) -> a.dis - b.dis);\\n        for(int i =0;i<p.length;i++){\\n            int total = p[i][0]*p[i][0] + p[i][1]*p[i][1];\\n            node n = new node(total,p[i][0],p[i][1]);\\n            pq.add(n);\\n        }\\n        int[][] ans = new int[k][2];\\n        for(int i =0;i<k && pq.size()>0;i++){\\n            node n = pq.poll();\\n            ans[i][0] = n.x; \\n            ans[i][1] = n.y;\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass node{\\n    node value;\\n    int dis;\\n    int x;\\n    int y;\\n    node(int dis, int x , int y){\\n        this.dis = dis;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341366,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<pair<double, vector<int>>> v;\\n        for(auto x: points) {\\n            double dis = sqrt(x[0] * x[0] + x[1] * x[1]);\\n            v.push_back({dis, {x[0], x[1]}});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<vector<int>> ans;\\n        for(int i=0; i<k; i++) ans.push_back(v[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<pair<double, vector<int>>> v;\\n        for(auto x: points) {\\n            double dis = sqrt(x[0] * x[0] + x[1] * x[1]);\\n            v.push_back({dis, {x[0], x[1]}});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<vector<int>> ans;\\n        for(int i=0; i<k; i++) ans.push_back(v[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248328,
                "title": "heapq-maxheap-and-minheap-solution-nlogk",
                "content": "# Intuition\\nWhen thinking about kClosest, heap is most intuitive. Since we are getting the most closest, first solution that came to mind is to use minHeap, and push all elements on to the heap, and then pop each k elements.\\n\\nAfter thinking a bit, solution #2 (maxHeap) was a better solution as it optimize the Time Complexity to O(Nlogk) since we are able to pop from the heap whenever the heap goes above size k. \\n\\n# Complexity\\n- Time complexity: O(NlogN + klogN) where k < N\\n-  = O(NlogN)\\n\\n- Space complexity: O(N) for the heap\\n\\n# Code\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        distance = []\\n        heapq.heapify(distance)\\n        for [x,y] in points:\\n            newDistSq = x**2 + y**2\\n            heapq.heappush(distance,(newDistSq, [x,y]))\\n        res = []\\n        while len(res) < k:\\n            (_, loc) = heapq.heappop(distance)\\n            res.append(loc)\\n        return res\\n```\\n\\nSecond solution (Optimized when k << N)\\nTime complexity: O(Nlogk) where k < N\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        distance = [] # max heap\\n        heapq.heapify(distance)\\n        for [x,y] in points:\\n            newDistSq = x**2 + y**2\\n            heapq.heappush(distance,(-newDistSq, [x,y]))\\n            if len(distance) > k:\\n                heapq.heappop(distance)\\n            \\n        return map(lambda x: x[1], distance)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        distance = []\\n        heapq.heapify(distance)\\n        for [x,y] in points:\\n            newDistSq = x**2 + y**2\\n            heapq.heappush(distance,(newDistSq, [x,y]))\\n        res = []\\n        while len(res) < k:\\n            (_, loc) = heapq.heappop(distance)\\n            res.append(loc)\\n        return res\\n```\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        distance = [] # max heap\\n        heapq.heapify(distance)\\n        for [x,y] in points:\\n            newDistSq = x**2 + y**2\\n            heapq.heappush(distance,(-newDistSq, [x,y]))\\n            if len(distance) > k:\\n                heapq.heappop(distance)\\n            \\n        return map(lambda x: x[1], distance)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060864,
                "title": "c-min-heap-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        for(auto it: points){\\n            int dis=it[0]*it[0]+it[1]*it[1];\\n            //cout<<dis<<endl;\\n            q.push({dis, {it[0], it[1]}});\\n        }\\n        vector<vector<int>>ans;\\n        while(k--){\\n            ans.push_back({q.top().second.first, q.top().second.second});\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        for(auto it: points){\\n            int dis=it[0]*it[0]+it[1]*it[1];\\n            //cout<<dis<<endl;\\n            q.push({dis, {it[0], it[1]}});\\n        }\\n        vector<vector<int>>ans;\\n        while(k--){\\n            ans.push_back({q.top().second.first, q.top().second.second});\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2894395,
                "title": "simplest-3-solution-c-faster-than-85-of-c-online-submissions",
                "content": "****    **using pairs in Priority queue********\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n          vector<vector<int>> ans;\\n        priority_queue<pair<double,pair<int,int>>> st;\\n         for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            st.push({-dis,{points[i][0],points[i][1]}});\\n            \\n        }\\n        int j=0;\\n        while(j<k)\\n        {\\n            ans.push_back({st.top().second.first,st.top().second.second});\\n            st.pop();\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n****    **using vectors<int> in Priority queue********\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n          vector<vector<int>> ans;\\n        priority_queue<pair<double,vector<int>>> st;\\n         for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            st.push({-dis,points[i]});\\n            \\n        }\\n        int j=0;\\n        while(j<k)\\n        {\\n            ans.push_back(st.top().second);\\n            st.pop();\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***********using  vector<pair<vector<int>,double>>***********\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<vector<int>,double> a,pair<vector<int>,double> b)\\n    {\\n        return a.second<b.second;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n         vector<vector<int>> ans;\\n         vector<pair<vector<int>,double>> abc;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            abc.push_back({points[i],dis});\\n            \\n        }\\n        sort(abc.begin(),abc.end(),cmp);\\n        for(auto it:abc)\\n        {\\n            if(k>0){\\n            ans.push_back(it.first);\\n                k--;\\n                }\\n            for(int j=0;j<abc[0].first.size();++j){\\n               //  cout<<it.first[j]<<\" \";\\n        }\\n           // cout<<it.second<<endl;\\n        }\\n          \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n          vector<vector<int>> ans;\\n        priority_queue<pair<double,pair<int,int>>> st;\\n         for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            st.push({-dis,{points[i][0],points[i][1]}});\\n            \\n        }\\n        int j=0;\\n        while(j<k)\\n        {\\n            ans.push_back({st.top().second.first,st.top().second.second});\\n            st.pop();\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n          vector<vector<int>> ans;\\n        priority_queue<pair<double,vector<int>>> st;\\n         for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            st.push({-dis,points[i]});\\n            \\n        }\\n        int j=0;\\n        while(j<k)\\n        {\\n            ans.push_back(st.top().second);\\n            st.pop();\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<vector<int>,double> a,pair<vector<int>,double> b)\\n    {\\n        return a.second<b.second;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n         vector<vector<int>> ans;\\n         vector<pair<vector<int>,double>> abc;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            abc.push_back({points[i],dis});\\n            \\n        }\\n        sort(abc.begin(),abc.end(),cmp);\\n        for(auto it:abc)\\n        {\\n            if(k>0){\\n            ans.push_back(it.first);\\n                k--;\\n                }\\n            for(int j=0;j<abc[0].first.size();++j){\\n               //  cout<<it.first[j]<<\" \";\\n        }\\n           // cout<<it.second<<endl;\\n        }\\n          \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2844811,
                "title": "easy-java-solution-well-documented",
                "content": "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n\\t\\n        //designing max heap using custom comparator with array of coordinates with greatest distance from origin  at top of the heap followed by lower distance \\n        \\n        // PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() { \\n        //     @Override\\n        //     public int compare(int[] a, int[] b) {\\n        //         int distA=a[0]*a[0]+a[1]*a[1]; //by formula distanceFromOrigin = (X^2)-(Y^2)\\n        //         int distB=b[0]*b[0]+b[1]*b[1];\\n        //         return (distB-distA); //difference = secondDistance - firstDistance\\n        //     }\\n        // });\\n        \\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b) -> (b[0]*b[0]+b[1]*b[1]) - (a[0]*a[0]+a[1]*a[1])); //lambda version of the same comparator\\n        \\n        for(int[] point:points){\\n            pq.offer(point);\\n            if(pq.size()>k){ //removing untill k closest coordinates  \\n                pq.poll();\\n            }\\n        }\\n        \\n        int[][] res=new int[pq.size()][2]; //or int[][] res=new int[k][2]; //because there are k coordinates each of size 2\\n        \\n        int i=0;\\n        while(!pq.isEmpty()){\\n            res[i]=pq.poll();\\n            i++;\\n        }\\n\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n\\t\\n        //designing max heap using custom comparator with array of coordinates with greatest distance from origin  at top of the heap followed by lower distance \\n        \\n        // PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() { \\n        //     @Override\\n        //     public int compare(int[] a, int[] b) {\\n        //         int distA=a[0]*a[0]+a[1]*a[1]; //by formula distanceFromOrigin = (X^2)-(Y^2)\\n        //         int distB=b[0]*b[0]+b[1]*b[1];\\n        //         return (distB-distA); //difference = secondDistance - firstDistance\\n        //     }",
                "codeTag": "Java"
            },
            {
                "id": 2842267,
                "title": "easy-lambda-function-based-solution-o-nlogn-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe needed to sort the array elements according to their respective distances from the origin.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo what we can do is define a separate function (distance here) that takes the x & y coordinates and calculates each point\\'s distance from the origin.\\nwe then pass this distance function as the key parameter of the sort function. The key parameter of the sort function takes a function and sorts the iterable according to the values returned by that function(distance in this case)\\nhence, we obtain the points list sorted according to the points\\' distances from the origin.\\nand at last we return the first k elements of the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe in-built sort function is based on timsort which takes $$O(nlogn)$$ time for sorting.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nthe space complexity of this code is $$O(1)$$ as we\\'re not using any extra space.\\n\\n# Code\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        def distance(x,y):\\n            return (x**2 + y**2) ** 0.5\\n\\n        points.sort(key = lambda i : distance(i[0], i[1]))\\n\\n        return points[:k]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        def distance(x,y):\\n            return (x**2 + y**2) ** 0.5\\n\\n        points.sort(key = lambda i : distance(i[0], i[1]))\\n\\n        return points[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808360,
                "title": "c-priority-queue-solution",
                "content": "**Please connect with me if u like my solution**\\n**Please Upvote**\\nhttps://www.linkedin.com/in/shubham-roy-0b71a0220/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>>ans;\\n    \\n        priority_queue<pair<int,pair<int,int>>>mxh;\\n        for(int i=0;i<points.size();i++){\\n            \\n            mxh.push({(points[i][0]*points[i][0])+ (points[i][1]*points[i][1]),\\n                      {points[i][0],points[i][1]}});\\n            while(mxh.size()>k){\\n                mxh.pop();\\n            }\\n        }\\n        while(mxh.size()>0){\\n            pair<int,int>p=mxh.top().second;\\n            ans.push_back({p.first,p.second});\\n            mxh.pop();\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>>ans;\\n    \\n        priority_queue<pair<int,pair<int,int>>>mxh;\\n        for(int i=0;i<points.size();i++){\\n            \\n            mxh.push({(points[i][0]*points[i][0])+ (points[i][1]*points[i][1]),\\n                      {points[i][0],points[i][1]}});\\n            while(mxh.size()>k){\\n                mxh.pop();\\n            }\\n        }\\n        while(mxh.size()>0){\\n            pair<int,int>p=mxh.top().second;\\n            ans.push_back({p.first,p.second});\\n            mxh.pop();\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733717,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        HashMap<Double, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < points.length; i++){\\n            int [] point = points[i];\\n            int x = point[0];\\n            int y = point[1];\\n            double square = helper(x, y);\\n            \\n            List<Integer> al = map.getOrDefault(square, new ArrayList<>());\\n            al.add(i);\\n            map.put(square, al);\\n            if(pq.size() < k){\\n                pq.add(square);\\n            } else{\\n                if(pq.peek() > square){\\n                    pq.poll();\\n                    pq.offer(square);\\n                }\\n            }\\n        }\\n        \\n        int [][] ans = new int[k][2];\\n        int i = 0;\\n        while(pq.size() > 0){\\n            double val = pq.poll();\\n            if(map.containsKey(val)){\\n                List<Integer> al = map.get(val);\\n                for(int idx : al){\\n                    int [] point = points[idx];\\n                    ans[i++] = point;\\n                }\\n            }\\n            \\n            map.remove(val);\\n        }\\n        return ans;\\n    }\\n    private double helper(int x, int y){\\n        int x1 = Math.abs(x - 0);\\n        int y1 = Math.abs(y - 0);\\n        x1 *= x1;\\n        y1 *= y1;\\n        double ans = Math.sqrt(x1 + y1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        HashMap<Double, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < points.length; i++){\\n            int [] point = points[i];\\n            int x = point[0];\\n            int y = point[1];\\n            double square = helper(x, y);\\n            \\n            List<Integer> al = map.getOrDefault(square, new ArrayList<>());\\n            al.add(i);\\n            map.put(square, al);\\n            if(pq.size() < k){\\n                pq.add(square);\\n            } else{\\n                if(pq.peek() > square){\\n                    pq.poll();\\n                    pq.offer(square);\\n                }\\n            }\\n        }\\n        \\n        int [][] ans = new int[k][2];\\n        int i = 0;\\n        while(pq.size() > 0){\\n            double val = pq.poll();\\n            if(map.containsKey(val)){\\n                List<Integer> al = map.get(val);\\n                for(int idx : al){\\n                    int [] point = points[idx];\\n                    ans[i++] = point;\\n                }\\n            }\\n            \\n            map.remove(val);\\n        }\\n        return ans;\\n    }\\n    private double helper(int x, int y){\\n        int x1 = Math.abs(x - 0);\\n        int y1 = Math.abs(y - 0);\\n        x1 *= x1;\\n        y1 *= y1;\\n        double ans = Math.sqrt(x1 + y1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732072,
                "title": "c-solution-maxheap",
                "content": "**UPVOTE IF IT HELPS U**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> v;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<points.size();i++){\\n            int sq = points[i][0]*points[i][0]  + points[i][1]*points[i][1];\\n            pq.push({sq,{points[i][0],points[i][1]}});\\n        }\\n        int n = points.size()-k;\\n        \\n        while(n--){\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n            pair<int,pair<int,int>> p = pq.top();\\n            pq.pop();\\n            vector<int> ans = {p.second.first,p.second.second};\\n            v.push_back(ans);\\n        }\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> v;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<points.size();i++){\\n            int sq = points[i][0]*points[i][0]  + points[i][1]*points[i][1];\\n            pq.push({sq,{points[i][0],points[i][1]}});\\n        }\\n        int n = points.size()-k;\\n        \\n        while(n--){\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n            pair<int,pair<int,int>> p = pq.top();\\n            pq.pop();\\n            vector<int> ans = {p.second.first,p.second.second};\\n            v.push_back(ans);\\n        }\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721909,
                "title": "c-priority-queue-cleanest-code",
                "content": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pii>> pq;//max priority queue so that besi durot thaka point tu agot thake in the priorirty queue\\n        for(int i=0;i<points.size();i++){\\n            int d=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            pq.push(make_pair(d,make_pair(points[i][0],points[i][1])));\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        vector<vector<int>> res;\\n        while(pq.empty()==false){\\n            auto it=pq.top();\\n            pq.pop();\\n            res.push_back(vector<int> {it.second.first,it.second.second});\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pii>> pq;//max priority queue so that besi durot thaka point tu agot thake in the priorirty queue\\n        for(int i=0;i<points.size();i++){\\n            int d=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            pq.push(make_pair(d,make_pair(points[i][0],points[i][1])));\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        vector<vector<int>> res;\\n        while(pq.empty()==false){\\n            auto it=pq.top();\\n            pq.pop();\\n            res.push_back(vector<int> {it.second.first,it.second.second});\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661379,
                "title": "typescript-generalized-heap-yields-o-nlogk",
                "content": "# Goal\\nThe goal is to get the K closest points to origin. This means that we need to know two things: the distance of each point from origin, and how the distance of a point compares to distances of other points in the list.\\n\\n# Problem\\nWhat are our potential options?\\n1. Perhaps calculate the distance of each point, and sort the points by the distance? -> We\\'d end up doing unnecessary work when we only care about the first k elements. we don\\'t care about the order of the elements other than the first k elemtns.\\n2. Perhaps calculate the distance of each point, and use a map to associate the distance to each point? -> This won\\'t work because there could be multiple points with the same distance.\\n3. Perhaps calculate the distance of each point, and use a HashMap to keep track of all points and their distance? -> This has the same problem as the sorting case. The entries will need to be sorted by the distance.\\n\\nWhat is the problem? The problem is that we do not want to do unnecessary work when the amount of work is known (K).\\n\\n# Solution\\nWe only want to know the first K ones with the least distance. Given the Min/Max Heap excels at keeping elements in order as data is entered/removed, with some logic a heap can serve the first k mim/max values.\\n\\nThis solution uses a generalized heap. The benefit of a generalized solution is that it is trivial to change the comparison logic (i.e. K farthest points from origin). The comparison logic is injected into the class via the constructor.\\n```typescript\\ninterface IHeap<T> {\\n  get size(): number;\\n  offer(e: T): void;\\n  poll(): T;\\n}\\nclass Heap<T> implements IHeap<T> {\\n  private _items: T[];\\n  private _compare: (t1: T, t2: T) => boolean;\\n  \\n  constructor(compare: (t1: T, t2: T) => boolean) {\\n    this._items = [];\\n    this._compare = compare;\\n  }\\n\\n  public get size() {\\n    return this._items.length;\\n  }\\n\\n  private leftChildIndexOf(parentIndex: number): number { return 2 * parentIndex + 1; }\\n  private rightChildIndexOf(parentIndex: number): number { return 2 * parentIndex + 2; }\\n  private parentIndexOf(childIndex: number): number { return Math.floor((childIndex - 1) / 2); }\\n\\n  private hasLeftChild(index: number): boolean { return this.leftChildIndexOf(index) < this.size; }\\n  private hasRightChild(index: number): boolean { return this.rightChildIndexOf(index) < this.size; }\\n  private hasParent(index: number): boolean { return this.parentIndexOf(index) >= 0; }\\n\\n  private leftChildOf(index: number): T { return this._items[this.leftChildIndexOf(index)]; }\\n  private rightChildOf(index: number): T { return this._items[this.rightChildIndexOf(index)]; }\\n  private parentOf(index: number): T { return this._items[this.parentIndexOf(index)]; }\\n\\n  private swap(indexOne: number, indexTwo: number): void {\\n    const temp = this._items[indexOne];\\n    this._items[indexOne] = this._items[indexTwo];\\n    this._items[indexTwo] = temp;\\n  }\\n\\n  private heapifyDown(): void {\\n    let index = 0;\\n    while (this.hasLeftChild(index)) {\\n      let smallerChildIndex = this.leftChildIndexOf(index);\\n      if (this.hasRightChild(index) && this._compare(this.leftChildOf(index), this.rightChildOf(index))) {\\n        smallerChildIndex = this.rightChildIndexOf(index);\\n      }\\n      if (this._compare(this._items[smallerChildIndex], this._items[index])) {\\n        break;\\n      }\\n      else {\\n        this.swap(index, smallerChildIndex);\\n      }\\n      index = smallerChildIndex;\\n    }\\n  }\\n  public poll(): T {\\n    if (this.size === 0) throw new Error(\"Empty heap.\");\\n    if (this.size === 1) {\\n      return this._items.pop()!; \\n    }\\n    const item = this._items[0];\\n    this._items[0] = this._items.pop()!;\\n    this.heapifyDown();\\n    return item;\\n  }\\n\\n  private heapifyUp(): void {\\n    let index = this.size - 1;\\n    while (this.hasParent(index) && this._compare(this.parentOf(index), this._items[index])) {\\n      this.swap(this.parentIndexOf(index), index);\\n      index = this.parentIndexOf(index);\\n    }\\n  }\\n  public offer(t: T) {\\n    this._items.push(t);\\n    this.heapifyUp();\\n  }\\n};\\n```\\n\\nNow the algorithm can use the above heap to return the K closest points from origin.\\n```typescript\\nconst distance = (p: number[]) => {\\n  return p[0] * p[0] + p[1] * p[1];\\n}\\nconst compare = (p1: number[], p2: number[]) => {\\n  return distance(p2) > distance(p1); // max heap\\n};\\n\\nfunction kClosest(points: number[][], k: number): number[][] {\\n    const result = [];\\n    const minHeap = new Heap(compare);\\n    for (const p of points) {\\n        minHeap.offer(p);\\n        if (minHeap.size > k) {\\n            minHeap.poll();\\n        }\\n    }\\n    while (k > 0) {\\n        result.push(minHeap.poll());\\n        k--;\\n    }\\n    return result;\\n};\\n```\\n\\nThe reason for the max heap and the polling is that the heap\\'s size should never exceed K. As each point is offered to the heap, polling the max distance item if the heap size is greater than K guarantees that the heap will maintain the K least distanced points (closest from origin).",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\ninterface IHeap<T> {\\n  get size(): number;\\n  offer(e: T): void;\\n  poll(): T;\\n}\\nclass Heap<T> implements IHeap<T> {\\n  private _items: T[];\\n  private _compare: (t1: T, t2: T) => boolean;\\n  \\n  constructor(compare: (t1: T, t2: T) => boolean) {\\n    this._items = [];\\n    this._compare = compare;\\n  }\\n\\n  public get size() {\\n    return this._items.length;\\n  }\\n\\n  private leftChildIndexOf(parentIndex: number): number { return 2 * parentIndex + 1; }\\n  private rightChildIndexOf(parentIndex: number): number { return 2 * parentIndex + 2; }\\n  private parentIndexOf(childIndex: number): number { return Math.floor((childIndex - 1) / 2); }\\n\\n  private hasLeftChild(index: number): boolean { return this.leftChildIndexOf(index) < this.size; }\\n  private hasRightChild(index: number): boolean { return this.rightChildIndexOf(index) < this.size; }\\n  private hasParent(index: number): boolean { return this.parentIndexOf(index) >= 0; }\\n\\n  private leftChildOf(index: number): T { return this._items[this.leftChildIndexOf(index)]; }\\n  private rightChildOf(index: number): T { return this._items[this.rightChildIndexOf(index)]; }\\n  private parentOf(index: number): T { return this._items[this.parentIndexOf(index)]; }\\n\\n  private swap(indexOne: number, indexTwo: number): void {\\n    const temp = this._items[indexOne];\\n    this._items[indexOne] = this._items[indexTwo];\\n    this._items[indexTwo] = temp;\\n  }\\n\\n  private heapifyDown(): void {\\n    let index = 0;\\n    while (this.hasLeftChild(index)) {\\n      let smallerChildIndex = this.leftChildIndexOf(index);\\n      if (this.hasRightChild(index) && this._compare(this.leftChildOf(index), this.rightChildOf(index))) {\\n        smallerChildIndex = this.rightChildIndexOf(index);\\n      }\\n      if (this._compare(this._items[smallerChildIndex], this._items[index])) {\\n        break;\\n      }\\n      else {\\n        this.swap(index, smallerChildIndex);\\n      }\\n      index = smallerChildIndex;\\n    }\\n  }\\n  public poll(): T {\\n    if (this.size === 0) throw new Error(\"Empty heap.\");\\n    if (this.size === 1) {\\n      return this._items.pop()!; \\n    }\\n    const item = this._items[0];\\n    this._items[0] = this._items.pop()!;\\n    this.heapifyDown();\\n    return item;\\n  }\\n\\n  private heapifyUp(): void {\\n    let index = this.size - 1;\\n    while (this.hasParent(index) && this._compare(this.parentOf(index), this._items[index])) {\\n      this.swap(this.parentIndexOf(index), index);\\n      index = this.parentIndexOf(index);\\n    }\\n  }\\n  public offer(t: T) {\\n    this._items.push(t);\\n    this.heapifyUp();\\n  }\\n};\\n```\n```typescript\\nconst distance = (p: number[]) => {\\n  return p[0] * p[0] + p[1] * p[1];\\n}\\nconst compare = (p1: number[], p2: number[]) => {\\n  return distance(p2) > distance(p1); // max heap\\n};\\n\\nfunction kClosest(points: number[][], k: number): number[][] {\\n    const result = [];\\n    const minHeap = new Heap(compare);\\n    for (const p of points) {\\n        minHeap.offer(p);\\n        if (minHeap.size > k) {\\n            minHeap.poll();\\n        }\\n    }\\n    while (k > 0) {\\n        result.push(minHeap.poll());\\n        k--;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581563,
                "title": "sorting-javascript-solution-top-97-speed-200-ms",
                "content": "### Solution:\\n```js\\n/**\\n * @param {number[][]} points\\n * @param {number} k\\n * @return {number[][]}\\n */\\n\\nconst dist = (point) => {\\n  return point[0] * point[0] + point[1] * point[1];\\n}\\n\\nvar kClosest = function(points, k) {\\n  const n = points.length;\\n  let map = [];\\n\\n  for (let i = 0; i < n; ++i) {\\n    map.push({\\n      distance: dist(points[i]),\\n      points: points[i]\\n    })\\n  }\\n  map.sort((a, b) => a.distance - b.distance);\\n    \\n  let ans = [];\\n  for (let j = 0; j < k; j++) {\\n      ans.push(map[j].points)\\n  }\\n  return k === n ? points : ans\\n};\\n```\\n\\n### LeetCode Output\\nRuntime: **200 ms**, faster than **97.15%** of JavaScript online submissions for K Closest Points to Origin.\\nMemory Usage: **55.8 MB**, less than **93.10%** of JavaScript online submissions for K Closest Points to Origin.\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/800873393/)",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} points\\n * @param {number} k\\n * @return {number[][]}\\n */\\n\\nconst dist = (point) => {\\n  return point[0] * point[0] + point[1] * point[1];\\n}\\n\\nvar kClosest = function(points, k) {\\n  const n = points.length;\\n  let map = [];\\n\\n  for (let i = 0; i < n; ++i) {\\n    map.push({\\n      distance: dist(points[i]),\\n      points: points[i]\\n    })\\n  }\\n  map.sort((a, b) => a.distance - b.distance);\\n    \\n  let ans = [];\\n  for (let j = 0; j < k; j++) {\\n      ans.push(map[j].points)\\n  }\\n  return k === n ? points : ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105274,
                "title": "c-easy-max-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\ttypedef vector<int> v;\\n\\n\\tvector<vector<int>> kClosest(vector<vector<int>>& p, int k) {\\n\\t\\tpriority_queue<pair<int, v>> maxh;\\n\\t\\tfor (auto e : p) {\\n\\t\\t\\tint distance = e[0] * e[0] + e[1] * e[1];\\n\\t\\t\\tmaxh.push({distance, e});\\n\\t\\t\\tif (maxh.size() > k) maxh.pop();\\n\\t\\t}\\n\\t\\tvector<vector<int>> ans;\\n\\t\\twhile (!maxh.empty()) {\\n\\t\\t\\tans.push_back(maxh.top().second);\\n            maxh.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\ttypedef vector<int> v;\\n\\n\\tvector<vector<int>> kClosest(vector<vector<int>>& p, int k) {\\n\\t\\tpriority_queue<pair<int, v>> maxh;\\n\\t\\tfor (auto e : p) {\\n\\t\\t\\tint distance = e[0] * e[0] + e[1] * e[1];\\n\\t\\t\\tmaxh.push({distance, e});\\n\\t\\t\\tif (maxh.size() > k) maxh.pop();\\n\\t\\t}\\n\\t\\tvector<vector<int>> ans;\\n\\t\\twhile (!maxh.empty()) {\\n\\t\\t\\tans.push_back(maxh.top().second);\\n            maxh.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060892,
                "title": "solution-using-map-time-complexity-o-n-log-n-space-complexity-o-n",
                "content": "```\\n vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        map<int, vector<pair<int, int>>> mp;\\n        vector<vector<int>> ans;\\n        for(int i=0; i<points.size(); i++) {\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            int dis = x*x + y*y;\\n            mp[dis].push_back({x, y});\\n        }\\n        for(auto &i:mp) {\\n            for(auto &nu:i.second){\\n               if(!k) break;\\n                vector<int> temp;\\n                temp.push_back(nu.first);\\n                temp.push_back(nu.second);\\n                ans.push_back(temp);\\n                k--; \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        map<int, vector<pair<int, int>>> mp;\\n        vector<vector<int>> ans;\\n        for(int i=0; i<points.size(); i++) {\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            int dis = x*x + y*y;\\n            mp[dis].push_back({x, y});\\n        }\\n        for(auto &i:mp) {\\n            for(auto &nu:i.second){\\n               if(!k) break;\\n                vector<int> temp;\\n                temp.push_back(nu.first);\\n                temp.push_back(nu.second);\\n                ans.push_back(temp);\\n                k--; \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1648926,
                "title": "python3-o-n-klogn-time-o-n-space-3-lines-using-heapify-heappop",
                "content": "**Time Complexity Explanation:** We start by iterating through all the points to get the distance, which is O(n). Then we heapify which is in fact an O(n) operation, and more information on the algorithm can be found [here](https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity). What heapify does is that it builds the min heap of size n that we\\'re going to need. Every heappop operation is logn since the heap is of size n. But we heappop k times, and thus the time complexity of that would be O(klogn). Overall the time complexity would be O(n + klogn)\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        points = [(p[0]**2 + p[1]**2, p) for p in points]\\n        heapify(points)\\n        return [heappop(points)[1] for _ in range(k)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        points = [(p[0]**2 + p[1]**2, p) for p in points]\\n        heapify(points)\\n        return [heappop(points)[1] for _ in range(k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648102,
                "title": "golang",
                "content": "```\\nfunc kClosest(points [][]int, k int) [][]int {\\n    sort.Slice(points, func(i,j int) bool {\\n\\t\\treturn points[i][0] * points[i][0] + points[i][1] * points[i][1] <\\n\\t\\t\\tpoints[j][0] * points[j][0] + points[j][1] * points[j][1]\\n\\t})\\n\\treturn points[:k]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc kClosest(points [][]int, k int) [][]int {\\n    sort.Slice(points, func(i,j int) bool {\\n\\t\\treturn points[i][0] * points[i][0] + points[i][1] * points[i][1] <\\n\\t\\t\\tpoints[j][0] * points[j][0] + points[j][1] * points[j][1]\\n\\t})\\n\\treturn points[:k]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590753,
                "title": "concise-modernc-stl",
                "content": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        auto sd = [](vector<int>& point){return point[0]*point[0] + point[1]*point[1];};\\n        sort(points.begin(),points.end(),[sd](vector<int>& a,vector<int>& b){return sd(a)<sd(b);});\\n        return vector<vector<int>>(points.begin(),points.begin()+k);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        auto sd = [](vector<int>& point){return point[0]*point[0] + point[1]*point[1];};\\n        sort(points.begin(),points.end(),[sd](vector<int>& a,vector<int>& b){return sd(a)<sd(b);});\\n        return vector<vector<int>>(points.begin(),points.begin()+k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567322,
                "title": "python-oneline-quick-and-easy-99-runtime-and-memory",
                "content": "```\\n        return sorted(points, key=lambda x:(x[0]*x[0]+x[1]*x[1]))[:k]\\n",
                "solutionTags": [],
                "code": "```\\n        return sorted(points, key=lambda x:(x[0]*x[0]+x[1]*x[1]))[:k]\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1535036,
                "title": "c-easy-to-understand-fast-and-effiecient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> ans(k);\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int d=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            points[i].push_back(d);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        for(int i=0;i<k;i++)\\n        {\\n            ans[i].push_back(points[i][0]);\\n            ans[i].push_back(points[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> ans(k);\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int d=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            points[i].push_back(d);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        for(int i=0;i<k;i++)\\n        {\\n            ans[i].push_back(points[i][0]);\\n            ans[i].push_back(points[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489763,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int[][] closest = new int[k][2];\\n        \\n        // If there are no points or k is 0 there are no closest points\\n        if (points.length  == 0 || k == 0 || k > points.length) return closest;\\n        \\n        // Insert into heap based on the distance to the origin (less distance has high priority);\\n        PriorityQueue<int[]> min_heap = new PriorityQueue<>((p1, p2) -> Integer.compare(getDist(p2), getDist(p1)));\\n        \\n        // Start inserting points into heap\\n        for (int[] point: points) {\\n            min_heap.add(point);\\n            \\n            // If the size is greater than k, poll\\n            if (min_heap.size() > k) {\\n                min_heap.poll();\\n            }\\n        }\\n        \\n        // Finally insert k points into the result\\n        for (int i = 0; i < closest.length; i++) {\\n            closest[i] = min_heap.poll();\\n        }\\n        return closest;\\n    }\\n    \\n    public int getDist(int[] point) {\\n        return (point[0] * point[0]) + (point[1] * point[1]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int[][] closest = new int[k][2];\\n        \\n        // If there are no points or k is 0 there are no closest points\\n        if (points.length  == 0 || k == 0 || k > points.length) return closest;\\n        \\n        // Insert into heap based on the distance to the origin (less distance has high priority);\\n        PriorityQueue<int[]> min_heap = new PriorityQueue<>((p1, p2) -> Integer.compare(getDist(p2), getDist(p1)));\\n        \\n        // Start inserting points into heap\\n        for (int[] point: points) {\\n            min_heap.add(point);\\n            \\n            // If the size is greater than k, poll\\n            if (min_heap.size() > k) {\\n                min_heap.poll();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1432341,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<vector<int>> kClosest(vector<vector<int>>& A, int k) {\\n        using T = vector<int>;\\n        std::sort(A.begin(), A.end(), [](const T& a, const T& b) {\\n\\t\\t    // Sqrt is redundant, and since we\\'re comparing\\n\\t\\t\\t// with the origin one of the points is always 0,0.\\n\\t\\t\\t// This simplifies the formula to y1^2 + x1^2\\n            int da = a[0]*a[0] + a[1]*a[1];\\n            int db = b[0]*b[0] + b[1]*b[1];\\n            return da < db;\\n        });\\n        \\n        if (k > A.size()) {\\n            return A;\\n        }\\n        A.resize(k);\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<vector<int>> kClosest(vector<vector<int>>& A, int k) {\\n        using T = vector<int>;\\n        std::sort(A.begin(), A.end(), [](const T& a, const T& b) {\\n\\t\\t    // Sqrt is redundant, and since we\\'re comparing\\n\\t\\t\\t// with the origin one of the points is always 0,0.\\n\\t\\t\\t// This simplifies the formula to y1^2 + x1^2\\n            int da = a[0]*a[0] + a[1]*a[1];\\n            int db = b[0]*b[0] + b[1]*b[1];\\n            return da < db;\\n        });\\n        \\n        if (k > A.size()) {\\n            return A;\\n        }\\n        A.resize(k);\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428237,
                "title": "using-inbuilt-sort-in-stl-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> a,vector<int> b){\\n        int c = (a[0]*a[0]) + (a[1]*a[1]);\\n        int d = (b[0]*b[0]) + (b[1]*b[1]);\\n        if(c<d){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& v, int k) {\\n        sort(v.begin(),v.end(),cmp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> a,vector<int> b){\\n        int c = (a[0]*a[0]) + (a[1]*a[1]);\\n        int d = (b[0]*b[0]) + (b[1]*b[1]);\\n        if(c<d){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& v, int k) {\\n        sort(v.begin(),v.end(),cmp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323389,
                "title": "runtime-99-77-of-python3-memory-less-than-88-72",
                "content": "```python\\nfrom math import dist\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def kClosest(points: list[list[int]], k: int) -> list[list[int]]:\\n        if k >= len(points):\\n            return points\\n        return sorted(points, key=lambda i: dist(i, [0, 0]))[:k]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom math import dist\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def kClosest(points: list[list[int]], k: int) -> list[list[int]]:\\n        if k >= len(points):\\n            return points\\n        return sorted(points, key=lambda i: dist(i, [0, 0]))[:k]\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565273,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1569847,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1736193,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1805030,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1881393,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1569500,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1575541,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1954278,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1717589,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1639872,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1565273,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1569847,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1736193,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1805030,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1881393,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1569500,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1575541,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1954278,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1717589,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1639872,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1576576,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1974835,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1576125,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 2060816,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 2045762,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 2039487,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1998977,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1982259,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1944032,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1738803,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            }
        ]
    }
]