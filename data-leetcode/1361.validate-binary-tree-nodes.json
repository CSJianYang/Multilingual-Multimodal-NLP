[
    {
        "title": "Unique Email Addresses",
        "question_content": "Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\n\n\tFor example, in \"alice@leetcode.com\", \"alice\" is the local name, and \"leetcode.com\" is the domain name.\n\nIf you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\n\n\tFor example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\n\nIf you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\n\n\tFor example, \"m.y+name@email.com\" will be forwarded to \"my@email.com\".\n\nIt is possible to use both of these rules at the same time.\nGiven an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.\n&nbsp;\nExample 1:\n\nInput: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails.\n\nExample 2:\n\nInput: emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= emails.length <= 100\n\t1 <= emails[i].length <= 100\n\temails[i] consist of lowercase English letters, '+', '.' and '@'.\n\tEach emails[i] contains exactly one '@' character.\n\tAll local and domain names are non-empty.\n\tLocal names do not start with a '+' character.\n\tDomain names end with the \".com\" suffix.",
        "solutions": [
            {
                "id": 186798,
                "title": "java-python-3-7-and-6-liners-with-comment-and-analysis",
                "content": "```java\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> normalized = new HashSet<>(); // used to save simplified email address, cost O(n) sapce.\\n        for (String email : emails) {\\n            String[] parts = email.split(\"@\"); // split into local and domain parts.\\n            String[] local = parts[0].split(\"\\\\\\\\+\"); // split local by \\'+\\'.\\n            normalized.add(local[0].replace(\".\", \"\") + \"@\" + parts[1]); // remove all \\'.\\', and concatenate \\'@\\' and domain.        \\n        }\\n        return normalized.size();\\n    }\\n```\\n```python\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\') \\n            local = name.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            seen.add(local + \\'@\\' + domain)\\n        return len(seen)\\n```\\n**Analysis**\\nLet `n` be the total characters in the input array `emails`. The HashSet `normalized` and the for loop both cost `O(n)`, in terms of space and time, respectively. \\n\\n**Time & space: O(n).**\\n# --------------------\\n\\n**Q & A**\\n\\n**Q1**: What is Java metacharacter?\\n**A1**: A metacharacter \\u2014 a character with special meaning interpreted by the Java regular expression engine / matcher.\\nhttps://en.wikipedia.org/wiki/Metacharacter\\nhttps://docs.oracle.com/javase/tutorial/essential/regex/literals.html. \\n\\n**Q2**: Why does Java regular expression use `\\\\\\\\`, instead of `\\\\`, to escape metacharacter such as `+, ., *`, etc?\\n\\n**A2**: I guess the reason is that the backslash character is an escape character in Java String literals already. \\n\\n**Update:**\\n\\nCredit to @helengu1996 for her [link](https://stackoverflow.com/a/25145826/4150692):\\n\\n*\"There are two \"escapings\" going on here. The first backslash is to escape the second backslash for the Java language, to create an actual backslash character. The backslash character is what escapes the + or the s for interpretation by the regular expression engine. That\\'s why you need two backslashes -- one for Java, one for the regular expression engine. With only one backslash, Java reports \\\\s and \\\\+ as illegal escape characters -- not for regular expressions, but for an actual character in the Java language.\"*\\n\\n----\\n\\nSimilar solution:\\n\\n[1592. Rearrange Spaces Between Words](https://leetcode.com/problems/rearrange-spaces-between-words/discuss/855335/JavaPython-3-6-liners.)",
                "solutionTags": [],
                "code": "```java\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> normalized = new HashSet<>(); // used to save simplified email address, cost O(n) sapce.\\n        for (String email : emails) {\\n            String[] parts = email.split(\"@\"); // split into local and domain parts.\\n            String[] local = parts[0].split(\"\\\\\\\\+\"); // split local by \\'+\\'.\\n            normalized.add(local[0].replace(\".\", \"\") + \"@\" + parts[1]); // remove all \\'.\\', and concatenate \\'@\\' and domain.        \\n        }\\n        return normalized.size();\\n    }\\n```\n```python\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\') \\n            local = name.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            seen.add(local + \\'@\\' + domain)\\n        return len(seen)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 317207,
                "title": "c-concise-solution",
                "content": "For each email address in `emails`, clean up the local name, append the domain name, and add the cleaned up email to a set.\\n\\nReturn the size of the set.\\n \\n\\tint numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> st;\\n        for(string &email : emails) {\\n            string cleanEmail;\\n            for(char c : email) {\\n                if(c == \\'+\\' || c == \\'@\\') break;\\n                if(c == \\'.\\') continue;\\n                cleanEmail += c;\\n            }\\n            cleanEmail += email.substr(email.find(\\'@\\'));\\n            st.insert(cleanEmail);\\n        }\\n        return st.size();\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "For each email address in `emails`, clean up the local name, append the domain name, and add the cleaned up email to a set.\\n\\nReturn the size of the set.\\n \\n\\tint numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> st;\\n        for(string &email : emails) {\\n            string cleanEmail;\\n            for(char c : email) {\\n                if(c == \\'+\\' || c == \\'@\\') break;\\n                if(c == \\'.\\') continue;\\n                cleanEmail += c;\\n            }\\n            cleanEmail += email.substr(email.find(\\'@\\'));\\n            st.insert(cleanEmail);\\n        }\\n        return st.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 187527,
                "title": "python-solution",
                "content": "```\nclass Solution:\n    def numUniqueEmails(self, emails):\n        \"\"\"\n        :type emails: List[str]\n        :rtype: int\n        \"\"\"\n        email_set = set()\n        for email in emails:\n            local_name,domain_name = email.split(\"@\")\n            local_name =\"\".join(local_name.split('+')[0].split('.'))\n            email = local_name +'@' + domain_name\n            email_set.add(email)\n        return len(email_set)\n ```       ",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def numUniqueEmails(self, emails):\n        \"\"\"\n        :type emails: List[str]\n        :rtype: int\n        \"\"\"\n        email_set = set()\n        for email in emails:\n            local_name,domain_name = email.split(\"@\")\n            local_name =\"\".join(local_name.split('+')[0].split('.'))\n            email = local_name +'@' + domain_name\n            email_set.add(email)\n        return len(email_set)\n ```",
                "codeTag": "Java"
            },
            {
                "id": 198062,
                "title": "please-update-the-test-cases",
                "content": "Please add this or something similar to the test cases:\\n*[\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]*\\n\\nMany of the fastest accepted solutions look like this:\\n\\n```\\nSet<String> seen = new HashSet();\\n        for (String email: emails) {\\n            int i = email.indexOf(\\'@\\');\\n            String rest = email.substring(i);\\n            seen.add(rest);\\n        }\\n        return seen.size();\\n```\\n\\nThe fact that this is an accepted solution shows a gap in the test cases. E.g., the proposed test case fails with the above code even though the code is accepted.",
                "solutionTags": [],
                "code": "```\\nSet<String> seen = new HashSet();\\n        for (String email: emails) {\\n            int i = email.indexOf(\\'@\\');\\n            String rest = email.substring(i);\\n            seen.add(rest);\\n        }\\n        return seen.size();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195263,
                "title": "clean-java-beats-99-single-pass-without-split-replace-or-indexof",
                "content": "it seems best to just iterate once through each email string, since using String split() or replace() or indexOf() implicitly iterates through the email string at each usage.\\nAt each character:\\n1. If \\'.\\' is encountered: skip to check next character\\n2. If \\'+\\' is encountered: keep moving index to look for \\'@\\', then append rest of substring to StringBuilder; break\\n3. If \\'@\\' is encountered: append rest of substring to StringBuilder; break\\n4. For all other characters encountered, append to StringBuilder, then continue to check next character\\n5. Build email string and add to set\\n\\nThe set size is result.\\n```\\n    public int numUniqueEmails(String[] emails) {\\n      if (emails == null) {\\n        return 0;\\n      }\\n\\n      Set<String> addresses = new HashSet<>();\\n\\t  \\n      for (String email : emails) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < email.length(); i++) {\\n          char ch = email.charAt(i);\\n          switch (ch) {\\n            case \\'.\\':\\n              break;\\n            case \\'+\\':\\n              while (ch != \\'@\\') {\\n                ch = email.charAt(++i);\\n              }\\n              sb.append(email.substring(i));\\n              i = email.length();\\n              break;\\n            case \\'@\\':\\n              sb.append(email.substring(i));\\n              i = email.length();\\n            default:\\n              sb.append(ch);\\n          }\\n        }\\n        addresses.add(sb.toString());\\n      }\\n     \\n      return addresses.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numUniqueEmails(String[] emails) {\\n      if (emails == null) {\\n        return 0;\\n      }\\n\\n      Set<String> addresses = new HashSet<>();\\n\\t  \\n      for (String email : emails) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < email.length(); i++) {\\n          char ch = email.charAt(i);\\n          switch (ch) {\\n            case \\'.\\':\\n              break;\\n            case \\'+\\':\\n              while (ch != \\'@\\') {\\n                ch = email.charAt(++i);\\n              }\\n              sb.append(email.substring(i));\\n              i = email.length();\\n              break;\\n            case \\'@\\':\\n              sb.append(email.substring(i));\\n              i = email.length();\\n            default:\\n              sb.append(ch);\\n          }\\n        }\\n        addresses.add(sb.toString());\\n      }\\n     \\n      return addresses.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261959,
                "title": "easy-understanding-python-solution-44ms-faster-than-99-3",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        def parse(email):\\n            local, domain = email.split(\\'@\\')\\n            local = local.split(\\'+\\')[0].replace(\\'.\\',\"\")\\n            return f\"{local}@{domain}\"\\n        \\n        return len(set(map(parse, emails)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        def parse(email):\\n            local, domain = email.split(\\'@\\')\\n            local = local.split(\\'+\\')[0].replace(\\'.\\',\"\")\\n            return f\"{local}@{domain}\"\\n        \\n        return len(set(map(parse, emails)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210025,
                "title": "javascript-1-line-solution-and-explanation",
                "content": "```\\nconst numUniqueEmails = emails => new Set(emails.map(mail => `${mail.split(\\'@\\')[0].replace(/\\\\+.*$|\\\\./g, \\'\\')}@${mail.split(\\'@\\')[1]}`)).size\\n```\\n\\n* Skills:\\n\\t1. ES6(arrow function, template literals)\\n\\t2. Set\\n\\t3. \\tString(split, replace)\\n\\t4. \\tRegular Expression\\n* Explanation:\\n\\tIn this piece of code, I took lots of times to recall **regex**, and it is the most unreadable part, so let me explain: \\n\\t```\\n\\t\\t/\\\\+.*$|\\\\./g\\n\\t```\\n\\t1. `+` is a specail char, so adds `\\\\`.\\n\\t2. `.*` means any character after `+`.\\n\\t3. `$`, in regex, it represents the end of string.\\n\\t4. `|` equals to `or`.\\n\\t5. `.` is also a special char, so adds `\\\\`.\\n\\t6. In the end of regex, `g`, global search, means finding all matches in input and replace them.\\n\\t7. In sum, replace the substring that after sign `+` or the char `.` with empty string.\\n\\nI\\'m a Taiwanese, this is my first try to share my solution and explanation, please feel free to leave comments if you have any better approach or idea :).",
                "solutionTags": [],
                "code": "```\\nconst numUniqueEmails = emails => new Set(emails.map(mail => `${mail.split(\\'@\\')[0].replace(/\\\\+.*$|\\\\./g, \\'\\')}@${mail.split(\\'@\\')[1]}`)).size\\n```\n```\\n\\t\\t/\\\\+.*$|\\\\./g\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488812,
                "title": "python-short-solution-explained",
                "content": "What we need to do in this problem is carefully check cases and use functionality of strings in python.\\n1. First, split each `mail`, using `@` symbol.\\n2. Then, remove all `.` in local part of mail.\\n3. If we found `+` in string, remove all symbols after this symbol.\\n4. Finally, update `d[local + \"@\" + domain]`, increasing it by one.\\n5. In the end calculate number of unique clean emails.\\n\\n#### Complexity\\nIt is `O(m)` for time, where `m` is total length of all `emails`, space is potentially `O(m)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        d = Counter()\\n        for mail in emails:\\n            local, domain = mail.split(\"@\")\\n            local = local.replace(\".\", \"\")\\n            if \"+\" in local: local = local[:local.index(\"+\")]\\n            d[local + \"@\" + domain] += 1\\n            \\n        return len(d)\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        d = Counter()\\n        for mail in emails:\\n            local, domain = mail.split(\"@\")\\n            local = local.replace(\".\", \"\")\\n            if \"+\" in local: local = local[:local.index(\"+\")]\\n            d[local + \"@\" + domain] += 1\\n            \\n        return len(d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489525,
                "title": "fastest-and-easiest-in-place-c-solution-using-stl",
                "content": "The code is pretty self-explanatory due to variable names.\\n```\\nint numUniqueEmails(vector<string>& emails)\\n    {\\n        for(auto& email:emails){\\n            auto at_location = find(email.begin(),email.end(),\\'@\\');\\n            auto end_after_removing_dots = remove(email.begin(),at_location,\\'.\\');\\n\\t\\t\\tauto plus_location = find(email.begin(),end_after_removing_dots,\\'+\\');\\n            email.erase(plus_location,at_location);\\n        }\\n        return unordered_set(emails.begin(),emails.end()).size();\\n    }\\n```\\nIf you have any doubts or suggestions, feel free to comment.\\nIf you found this solution useful, you know where the upvote is :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numUniqueEmails(vector<string>& emails)\\n    {\\n        for(auto& email:emails){\\n            auto at_location = find(email.begin(),email.end(),\\'@\\');\\n            auto end_after_removing_dots = remove(email.begin(),at_location,\\'.\\');\\n\\t\\t\\tauto plus_location = find(email.begin(),end_after_removing_dots,\\'+\\');\\n            email.erase(plus_location,at_location);\\n        }\\n        return unordered_set(emails.begin(),emails.end()).size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488791,
                "title": "easy-simple-well-defined-code-for-beginners",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        \\n        res = set()\\n        for email in emails:\\n            local,domain = email.split(\\'@\\')\\n            tmp = \"\"\\n            for c in local:\\n                if c==\".\": continue\\n                elif c==\"+\": break\\n                else: tmp+=c\\n            res.add(tmp+\"@\"+domain)\\n        \\n        return len(res)\\n\\n### **If you got the idea please Upvote !!!\\uD83E\\uDD1E**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        \\n        res = set()\\n        for email in emails:\\n            local,domain = email.split(\\'@\\')\\n            tmp = \"\"\\n            for c in local:\\n                if c==\".\": continue\\n                elif c==\"+\": break\\n                else: tmp+=c\\n            res.add(tmp+\"@\"+domain)\\n        \\n        return len(res)\\n\\n### **If you got the idea please Upvote !!!\\uD83E\\uDD1E**",
                "codeTag": "Java"
            },
            {
                "id": 236993,
                "title": "python-solution-runtime-99-66-faster-memory-usage-100-lesser",
                "content": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        actual = set()\\n        for email in  emails:\\n            x = email.split(\"@\")\\n            y = x[0].split(\"+\")\\n            z = y[0].replace(\".\", \"\")\\n            x = z + \"@\" + x[1]\\n            actual.add(x)\\n        return len(actual)\\n```",
                "solutionTags": [
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        actual = set()\\n        for email in  emails:\\n            x = email.split(\"@\")\\n            y = x[0].split(\"+\")\\n            z = y[0].replace(\".\", \"\")\\n            x = z + \"@\" + x[1]\\n            actual.add(x)\\n        return len(actual)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310272,
                "title": "clean-javascript-4-lines-solution-without-regex",
                "content": "```js\\nvar numUniqueEmails = function(emails) {\\n  return (new Set(emails.map(email => {\\n    const [local, domain] = email.split(\\'@\\');\\n    return local.split(\\'+\\').shift().split(\\'.\\').join(\\'\\') + \\'@\\' + domain;\\n  }))).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar numUniqueEmails = function(emails) {\\n  return (new Set(emails.map(email => {\\n    const [local, domain] = email.split(\\'@\\');\\n    return local.split(\\'+\\').shift().split(\\'.\\').join(\\'\\') + \\'@\\' + domain;\\n  }))).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 474109,
                "title": "python-3-with-explanations",
                "content": "```Python 3\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n\\t\\t# Create set which may contain only unique values\\n\\t\\ts = set()\\n\\t\\t# For every entry in the list\\n        for e in emails:\\n\\t\\t\\t# If entry is not empty\\n            if len(e) > 0:\\n\\t\\t\\t\\t# Split entry into two parts - before and after @ sign\\n                a = e.split(\\'@\\')[0]\\n                b = e.split(\\'@\\')[1]\\n\\t\\t\\t\\t# If first part (local) contains + sign\\n                if \\'+\\' in a:\\n\\t\\t\\t\\t\\t# Split this part again into two parts - before and after + sign\\n\\t\\t\\t\\t\\t# and replace dots in the first part with nothing, i.e. remove them\\n\\t\\t\\t\\t\\t# then reconstruct mail address by adding @ and the second part\\n                    s.add(a.split(\\'+\\')[0].replace(\\'.\\', \\'\\') + \\'@\\' + b)\\n                else:\\n\\t\\t\\t\\t\\t# If there is no + sign in the first part, then only remove dots\\n\\t\\t\\t\\t\\t# and reconstruct mail address by adding @ and the second part\\n                    s.add(a.replace(\\'.\\', \\'\\') + \\'@\\' + b)\\n\\t\\t# Return length of our set, i.e. number of entries\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python 3\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n\\t\\t# Create set which may contain only unique values\\n\\t\\ts = set()\\n\\t\\t# For every entry in the list\\n        for e in emails:\\n\\t\\t\\t# If entry is not empty\\n            if len(e) > 0:\\n\\t\\t\\t\\t# Split entry into two parts - before and after @ sign\\n                a = e.split(\\'@\\')[0]\\n                b = e.split(\\'@\\')[1]\\n\\t\\t\\t\\t# If first part (local) contains + sign\\n                if \\'+\\' in a:\\n\\t\\t\\t\\t\\t# Split this part again into two parts - before and after + sign\\n\\t\\t\\t\\t\\t# and replace dots in the first part with nothing, i.e. remove them\\n\\t\\t\\t\\t\\t# then reconstruct mail address by adding @ and the second part\\n                    s.add(a.split(\\'+\\')[0].replace(\\'.\\', \\'\\') + \\'@\\' + b)\\n                else:\\n\\t\\t\\t\\t\\t# If there is no + sign in the first part, then only remove dots\\n\\t\\t\\t\\t\\t# and reconstruct mail address by adding @ and the second part\\n                    s.add(a.replace(\\'.\\', \\'\\') + \\'@\\' + b)\\n\\t\\t# Return length of our set, i.e. number of entries\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186655,
                "title": "a-few-solutions",
                "content": "Erase `\\'.\\'` chars and all chars following `\\'+\\'` inclusive from the user-part, then concatenate the user/domain-parts into a `unique` set.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun numUniqueEmails(A: Array<String>): Int {\\n        var unique = mutableSetOf<String>()\\n        for (email in A) {\\n            var (user, domain) = email.split(\"@\")\\n            user = user.split(\"\").filter{ it != \".\" }.joinToString(\"\")\\n            var i = user.indexOf(\\'+\\')\\n            if (-1 < i)\\n                user = user.substring(0, i)\\n            unique.add(\"$user@$domain\")\\n        }\\n        return unique.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numUniqueEmails = (A, unique = new Set()) => {\\n    for (let email of A) {\\n        let [user, domain] = email.split(\\'@\\');\\n        user = user.split(\\'\\').filter(c => c != \\'.\\').join(\\'\\');\\n        let i = user.indexOf(\\'+\\');\\n        if (-1 < i)\\n            user = user.substring(0, i);\\n        unique.add(`${user}@${domain}`);\\n    }\\n    return unique.size;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numUniqueEmails(self, A: List[str]) -> int:\\n        unique = set()\\n        for email in A:\\n            user, domain = email.split(\\'@\\')\\n            user = user.replace(\\'.\\', \\'\\')\\n            i = user.find(\\'+\\')\\n            if -1 < i:\\n                user = user[0 : i]\\n            unique.add(f\\'{user}@{domain}\\')\\n        return len(unique)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    int numUniqueEmails(VS& A, Set unique = {}) {\\n        for (auto& email: A) {\\n            auto pivot = email.find(\\'@\\');\\n            auto user = email.substr(0, pivot),\\n                 domain = email.substr(pivot + 1);\\n            user.erase(remove_if(user.begin(), user.end(), [](auto c) { return c == \\'.\\'; }), user.end());\\n            auto i = user.find(\\'+\\');\\n            if (i != string::npos)\\n                user = user.substr(0, i);\\n            unique.insert(user + \\'@\\' + domain);\\n        }\\n        return unique.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numUniqueEmails(A: Array<String>): Int {\\n        var unique = mutableSetOf<String>()\\n        for (email in A) {\\n            var (user, domain) = email.split(\"@\")\\n            user = user.split(\"\").filter{ it != \".\" }.joinToString(\"\")\\n            var i = user.indexOf(\\'+\\')\\n            if (-1 < i)\\n                user = user.substring(0, i)\\n            unique.add(\"$user@$domain\")\\n        }\\n        return unique.size\\n    }\\n}\\n```\n```\\nlet numUniqueEmails = (A, unique = new Set()) => {\\n    for (let email of A) {\\n        let [user, domain] = email.split(\\'@\\');\\n        user = user.split(\\'\\').filter(c => c != \\'.\\').join(\\'\\');\\n        let i = user.indexOf(\\'+\\');\\n        if (-1 < i)\\n            user = user.substring(0, i);\\n        unique.add(`${user}@${domain}`);\\n    }\\n    return unique.size;\\n};\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, A: List[str]) -> int:\\n        unique = set()\\n        for email in A:\\n            user, domain = email.split(\\'@\\')\\n            user = user.replace(\\'.\\', \\'\\')\\n            i = user.find(\\'+\\')\\n            if -1 < i:\\n                user = user[0 : i]\\n            unique.add(f\\'{user}@{domain}\\')\\n        return len(unique)\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    int numUniqueEmails(VS& A, Set unique = {}) {\\n        for (auto& email: A) {\\n            auto pivot = email.find(\\'@\\');\\n            auto user = email.substr(0, pivot),\\n                 domain = email.substr(pivot + 1);\\n            user.erase(remove_if(user.begin(), user.end(), [](auto c) { return c == \\'.\\'; }), user.end());\\n            auto i = user.find(\\'+\\');\\n            if (i != string::npos)\\n                user = user.substr(0, i);\\n            unique.insert(user + \\'@\\' + domain);\\n        }\\n        return unique.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841942,
                "title": "2-approaches-set-easy-understanding",
                "content": "```\\n//1.\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        for(auto email:emails){\\n            int i=email.find(\\'@\\');\\n            string temp=email.substr(0,i);\\n            string last=email.substr(i);\\n            if(temp.find(\\'+\\')){\\n                temp=temp.substr(0,temp.find(\\'+\\'));\\n            }\\n            temp.erase(remove(temp.begin(), temp.end(), \\'.\\'), temp.end());\\n            s.insert(temp+last);\\n        }\\n        return s.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n    set<string> s;\\n    for(string &email : emails) {\\n        string cleanEmail;\\n        for(char c : email) {\\n            if(c == \\'+\\' || c == \\'@\\') break;\\n            if(c == \\'.\\') continue;\\n            cleanEmail += c;\\n        }\\n        cleanEmail += email.substr(email.find(\\'@\\'));\\n        s.insert(cleanEmail);\\n    }\\n    return s.size();\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n//1.\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        for(auto email:emails){\\n            int i=email.find(\\'@\\');\\n            string temp=email.substr(0,i);\\n            string last=email.substr(i);\\n            if(temp.find(\\'+\\')){\\n                temp=temp.substr(0,temp.find(\\'+\\'));\\n            }\\n            temp.erase(remove(temp.begin(), temp.end(), \\'.\\'), temp.end());\\n            s.insert(temp+last);\\n        }\\n        return s.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n    set<string> s;\\n    for(string &email : emails) {\\n        string cleanEmail;\\n        for(char c : email) {\\n            if(c == \\'+\\' || c == \\'@\\') break;\\n            if(c == \\'.\\') continue;\\n            cleanEmail += c;\\n        }\\n        cleanEmail += email.substr(email.find(\\'@\\'));\\n        s.insert(cleanEmail);\\n    }\\n    return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488854,
                "title": "python-just-split-then-hashset-clean-concise",
                "content": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        def normalize(localName):\\n            parts = localName.split(\"+\")\\n            return parts[0].replace(\".\", \"\")\\n        \\n        uniqueEmails = set()\\n        for email in emails:\\n            localName, domainName = email.split(\"@\")\\n            uniqueEmails.add(normalize(localName) + \"@\" + domainName)\\n            \\n        return len(uniqueEmails)\\n```\\nComplexity:\\n- Time: `O(N * M)`, where `N <= 100` is number of `emails`, `M <= 100` is length of each email.\\n- Space: `O(N * M)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        def normalize(localName):\\n            parts = localName.split(\"+\")\\n            return parts[0].replace(\".\", \"\")\\n        \\n        uniqueEmails = set()\\n        for email in emails:\\n            localName, domainName = email.split(\"@\")\\n            uniqueEmails.add(normalize(localName) + \"@\" + domainName)\\n            \\n        return len(uniqueEmails)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510279,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet();\\n        int count=0;\\n        for(String email: emails){\\n            int atIndex = email.indexOf(\"@\");\\n            int plusIndex= email.indexOf(\"+\");\\n            String str1 = \"\";\\n            if(plusIndex>=0) str1 = email.substring(0,plusIndex);\\n            else str1 = email.substring(0,atIndex);\\n            str1 = str1.replace(\".\",\"\") + email.substring(atIndex);\\n            if(set.add(str1)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet();\\n        int count=0;\\n        for(String email: emails){\\n            int atIndex = email.indexOf(\"@\");\\n            int plusIndex= email.indexOf(\"+\");\\n            String str1 = \"\";\\n            if(plusIndex>=0) str1 = email.substring(0,plusIndex);\\n            else str1 = email.substring(0,atIndex);\\n            str1 = str1.replace(\".\",\"\") + email.substring(atIndex);\\n            if(set.add(str1)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187215,
                "title": "java-beat-100",
                "content": "```\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        Set<String> set = new HashSet<>();\n        for(String email : emails) {\n            StringBuilder sb = new StringBuilder();\n            for(char c: email.toCharArray()) {\n                if (c == '.') continue;\n                if (c == '+') break;\n                sb.append(c);\n            }\n            String cur = sb.toString() + email.substring(email.indexOf('@'));\n            set.add(cur);\n        }\n        return set.size();\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        Set<String> set = new HashSet<>();\n        for(String email : emails) {\n            StringBuilder sb = new StringBuilder();\n            for(char c: email.toCharArray()) {\n                if (c == '.') continue;\n                if (c == '+') break;\n                sb.append(c);\n            }\n            String cur = sb.toString() + email.substring(email.indexOf('@'));\n            set.add(cur);\n        }\n        return set.size();\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777703,
                "title": "python-split-then-replace-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs trivial string operations. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        unique = set()\\n        for e in emails:\\n            loc, dom = e.split(\"@\")                                 # get parts of email\\n            fwd = loc.split(\"+\")[0].replace(\".\", \"\") + \"@\" + dom    # build forward email\\n            unique.add(fwd)\\n        return len(unique)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        unique = set()\\n        for e in emails:\\n            loc, dom = e.split(\"@\")                                 # get parts of email\\n            fwd = loc.split(\"+\")[0].replace(\".\", \"\") + \"@\" + dom    # build forward email\\n            unique.add(fwd)\\n        return len(unique)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488901,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        for(auto e : emails)\\n        {\\n            string mail=\"\";\\n            for(char c : e)\\n            {\\n                if(c==\\'+\\' || c==\\'@\\')\\n                    break;\\n                if(c==\\'.\\')\\n                    continue;\\n                mail+=c;\\n            }\\n            mail+=e.substr(e.find(\\'@\\'));\\n            s.insert(mail);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        for(auto e : emails)\\n        {\\n            string mail=\"\";\\n            for(char c : e)\\n            {\\n                if(c==\\'+\\' || c==\\'@\\')\\n                    break;\\n                if(c==\\'.\\')\\n                    continue;\\n                mail+=c;\\n            }\\n            mail+=e.substr(e.find(\\'@\\'));\\n            s.insert(mail);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534125,
                "title": "javascript-4-lines-2-solutions",
                "content": "1. Add all of filtered email addresses in to the Set\\n2. Return a size of the Set.\\n- Time Complexity: O(N)\\n- Space Complexity: O(N)\\n```JavaScript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(a => {\\n    const [local, domain] = a.split(\\'@\\');\\n    return `${local.split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${domain}`;\\n})).size;\\n```\\n\\nUsing regex\\n```JavaScript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(a => {\\n    const [local, domain] = a.split(\\'@\\');\\n    return `${local.replace(/\\\\+.*/, \\'\\').replace(/\\\\./g, \\'\\')}@${domain}`;\\n})).size;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(a => {\\n    const [local, domain] = a.split(\\'@\\');\\n    return `${local.split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${domain}`;\\n})).size;\\n```\n```JavaScript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(a => {\\n    const [local, domain] = a.split(\\'@\\');\\n    return `${local.replace(/\\\\+.*/, \\'\\').replace(/\\\\./g, \\'\\')}@${domain}`;\\n})).size;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217094,
                "title": "javascript-no-split-slice-or-regex",
                "content": "```\\nlet trim = (email) => {\\n  let trimmed = \"\";\\n  let ignore = false;\\n  let domain = false;\\n\\n  for (let i = 0; i < email.length; i++) {\\n    if (email[i] === \\'@\\') domain = true;\\n    if (email[i] === \\'+\\') ignore = true;\\n    if (!ignore && email[i] !== \\'.\\' || domain) trimmed += email[i];\\n  }\\n  return trimmed;\\n}\\n\\nlet numUniqueEmails = (emails) => {\\n  return new Set(emails.map(email => trim(email))).size;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlet trim = (email) => {\\n  let trimmed = \"\";\\n  let ignore = false;\\n  let domain = false;\\n\\n  for (let i = 0; i < email.length; i++) {\\n    if (email[i] === \\'@\\') domain = true;\\n    if (email[i] === \\'+\\') ignore = true;\\n    if (!ignore && email[i] !== \\'.\\' || domain) trimmed += email[i];\\n  }\\n  return trimmed;\\n}\\n\\nlet numUniqueEmails = (emails) => {\\n  return new Set(emails.map(email => trim(email))).size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 379182,
                "title": "easy-c-solution-24ms-faster-than-97",
                "content": "Runtime: 24 ms, faster than 97.76% of C++ online submissions for Unique Email Addresses.\\nMemory Usage: 14 MB, less than 26.19% of C++ online submissions for Unique Email Addresses.\\n\\n```\\nint numUniqueEmails(vector<string>& emails) {\\n        \\n        unordered_set<string> s;\\n        for(string email : emails)\\n        {\\n            string localName = email.substr(0,email.find_first_of(\\'@\\'));\\n            string domain = email.substr(email.find_first_of(\\'@\\'));\\n            \\n            if(localName.find(\\'+\\') != string::npos)\\n                localName.erase(localName.find_first_of(\\'+\\'));\\n            \\n            localName.erase(remove(localName.begin(), localName.end(), \\'.\\'), localName.end());\\n            s.insert(localName+domain);\\n        }\\n        \\n        return s.size();\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 24 ms, faster than 97.76% of C++ online submissions for Unique Email Addresses.\\nMemory Usage: 14 MB, less than 26.19% of C++ online submissions for Unique Email Addresses.\\n\\n```\\nint numUniqueEmails(vector<string>& emails) {\\n        \\n        unordered_set<string> s;\\n        for(string email : emails)\\n        {\\n            string localName = email.substr(0,email.find_first_of(\\'@\\'));\\n            string domain = email.substr(email.find_first_of(\\'@\\'));\\n            \\n            if(localName.find(\\'+\\') != string::npos)\\n                localName.erase(localName.find_first_of(\\'+\\'));\\n            \\n            localName.erase(remove(localName.begin(), localName.end(), \\'.\\'), localName.end());\\n            s.insert(localName+domain);\\n        }\\n        \\n        return s.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 199801,
                "title": "javascript-one-liner-two-solutions-76ms-88ms",
                "content": "the one with Regexp, 76ms\\n```\\nreturn new Set(emails.map(email => `${/(.*?)\\\\+/.exec(email.split(\\'@\\')[0].replace(/\\\\./g,\\'\\'))[1]}@${email.split(\\'@\\')[1]}`)).size\\n```\\nanother, 88ms\\n```\\nreturn new Set(emails.map(email => `${email.split(\\'@\\')[0].split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${email.split(\\'@\\')[1]}`)).size\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nreturn new Set(emails.map(email => `${/(.*?)\\\\+/.exec(email.split(\\'@\\')[0].replace(/\\\\./g,\\'\\'))[1]}@${email.split(\\'@\\')[1]}`)).size\\n```\n```\\nreturn new Set(emails.map(email => `${email.split(\\'@\\')[0].split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${email.split(\\'@\\')[1]}`)).size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258774,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    Set<String> set=new HashSet<>();\\n    public int numUniqueEmails(String[] emails) {\\n        \\n        for(String s: emails)\\n        {\\n            String d[]=s.split(\"@\");\\n            StringBuilder ans=new StringBuilder(\"\");\\n            for(int i=0;i<d[0].length();i++)\\n            {\\n                \\n                if(d[0].charAt(i)==\\'+\\')\\n                    break;\\n                if(d[0].charAt(i)!=\\'.\\')\\n                ans=ans.append(d[0].charAt(i));       \\n            }\\n            // System.out.println(ans+\"@\"+d[1]);\\n                ans.append(\"@\");\\n                ans.append(d[1]);\\n            set.add(ans.toString());\\n        }\\n        return set.size(); \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    Set<String> set=new HashSet<>();\\n    public int numUniqueEmails(String[] emails) {\\n        \\n        for(String s: emails)\\n        {\\n            String d[]=s.split(\"@\");\\n            StringBuilder ans=new StringBuilder(\"\");\\n            for(int i=0;i<d[0].length();i++)\\n            {\\n                \\n                if(d[0].charAt(i)==\\'+\\')\\n                    break;\\n                if(d[0].charAt(i)!=\\'.\\')\\n                ans=ans.append(d[0].charAt(i));       \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 204817,
                "title": "weak-test-cases",
                "content": "The below solution gives 100% result\\nbut will fail for many cases like\\n{\"test.emailalex@leetcode.com\",\"test.e.mailbob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"}\\nExpected output : 3\\nOutput : 2\\n```\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> seen = new HashSet();\\n        for (String email: emails) {\\n            int i = email.indexOf(\\'@\\');\\n            String rest = email.substring(i);\\n            seen.add(rest);\\n        }\\n        return seen.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> seen = new HashSet();\\n        for (String email: emails) {\\n            int i = email.indexOf(\\'@\\');\\n            String rest = email.substring(i);\\n            seen.add(rest);\\n        }\\n        return seen.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189057,
                "title": "c-solution-8ms-100",
                "content": "```\\nint numUniqueEmails(char** emails, int emailsSize) {\\n    char unique[100][100] = {0};\\n    char email[100] = {0};\\n    int uniquesize = 0;\\n    int j;\\n    int k;\\n    int keepon;\\n    int found;\\n\\n    for (int i = 0; i < emailsSize; i++){\\n        keepon = 1;\\n        j = 0;\\n        k = 0;\\n        found = 0;\\n        while (emails[i][j] != \\'@\\'){\\n            if (emails[i][j] == \\'+\\')\\n                keepon = 0;\\n            else if (keepon && emails[i][j] != \\'.\\')\\n                email[k++] = emails[i][j];\\n            j++;\\n        }\\n        while (emails[i][j])\\n            email[k++] = emails[i][j++];\\n        email[k] = 0;\\n        for (int u = 0; u < uniquesize && !found; u++)\\n            if (strcmp(unique[u], email) == 0)\\n                found = 1;\\n        if (!found)\\n            strcpy(unique[uniquesize++], email);\\n    }\\n    return uniquesize;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numUniqueEmails(char** emails, int emailsSize) {\\n    char unique[100][100] = {0};\\n    char email[100] = {0};\\n    int uniquesize = 0;\\n    int j;\\n    int k;\\n    int keepon;\\n    int found;\\n\\n    for (int i = 0; i < emailsSize; i++){\\n        keepon = 1;\\n        j = 0;\\n        k = 0;\\n        found = 0;\\n        while (emails[i][j] != \\'@\\'){\\n            if (emails[i][j] == \\'+\\')\\n                keepon = 0;\\n            else if (keepon && emails[i][j] != \\'.\\')\\n                email[k++] = emails[i][j];\\n            j++;\\n        }\\n        while (emails[i][j])\\n            email[k++] = emails[i][j++];\\n        email[k] = 0;\\n        for (int u = 0; u < uniquesize && !found; u++)\\n            if (strcmp(unique[u], email) == 0)\\n                found = 1;\\n        if (!found)\\n            strcpy(unique[uniquesize++], email);\\n    }\\n    return uniquesize;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3261011,
                "title": "90-beatable-js-sol-explained-with-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe algorithm uses a **Set** to store *unique email addresses* and then iterates through the *array of email addresses*.\\n\\n- For each email address, it performs the following steps:\\n\\n1. Split the email address into local and domain parts using the **\"@\"** symbol.\\n\\n2. Remove any dots **(\".\")** from the local part of the email address.\\n\\n3. Find the index of the first **\"+\"** symbol in the local part of the email address, if it exists.\\n\\n4. If a **\"+\"** symbol is found, remove all characters after it in the local part.\\n\\n5. Add the modified email address **(local@domain)** to the **Set**.\\n\\n6. Finally, the algorithm returns the size of the **Set**, which represents the **number of unique email addresses**.\\n\\n- The approach works because it effectively removes any characters in the local part of the email address that do not affect its uniqueness. \\n\\n- By doing this, it ensures that each unique email address is only added to the *Set* once, even if it appears in the input array multiple times with different variations.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here **n** is the number of email addresses and **m** is the length of the longest email address. \\n\\n2. This is because the algorithm loops through each email address and performs operations that take O(m) time (e.g. splitting the email address into local and domain parts, replacing dots, etc.). \\n\\n3. The set operation to add an email address to the set has an amortized time complexity of O(1).\\n\\n\\n\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. This is because the set used to store unique email addresses can potentially store up to n unique email addresses, each with a maximum length of m.\\n\\n2. Additionally, the local and domain variables created during each iteration also have a maximum length of m. \\n\\n3. Therefore, the total space used by this algorithm is proportional to **nm**.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\n \\nvar numUniqueEmails = function(emails) {\\n    \\n    let uniqueEmails = new Set();  // to store unique email addresses\\n    \\n    for (let email of emails) {\\n        \\n        let [local, domain] = email.split(\\'@\\');  // split local and domain parts\\n\\n        local = local.replace(/\\\\./g, \\'\\');  // remove dots from local part\\n\\n        let plusIndex = local.indexOf(\\'+\\');  // find index of plus sign\\n\\n            if (plusIndex !== -1) {\\n                \\n                local = local.substring(0, plusIndex); // remove everything after plus sign\\n            }\\n            \\n            uniqueEmails.add(local + \\'@\\' + domain); // add modified email to set\\n    }\\n    \\n    return uniqueEmails.size; // return number of unique email addresses\\n  \\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/242bd8b8-8a1a-4bd6-b87f-9d290d6548ab_1678033187.7374706.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\n \\nvar numUniqueEmails = function(emails) {\\n    \\n    let uniqueEmails = new Set();  // to store unique email addresses\\n    \\n    for (let email of emails) {\\n        \\n        let [local, domain] = email.split(\\'@\\');  // split local and domain parts\\n\\n        local = local.replace(/\\\\./g, \\'\\');  // remove dots from local part\\n\\n        let plusIndex = local.indexOf(\\'+\\');  // find index of plus sign\\n\\n            if (plusIndex !== -1) {\\n                \\n                local = local.substring(0, plusIndex); // remove everything after plus sign\\n            }\\n            \\n            uniqueEmails.add(local + \\'@\\' + domain); // add modified email to set\\n    }\\n    \\n    return uniqueEmails.size; // return number of unique email addresses\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749161,
                "title": "c-easiest-and-simplest",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> ans;\\n        for(string email : emails)\\n        {\\n            string temp = \"\";\\n            int i;\\n            for(i=0; email[i] != \\'@\\'; i++)\\n            {\\n                if(email[i] == \\'.\\')\\n                    continue;\\n                else if(email[i] == \\'+\\')\\n                    break;\\n                else\\n                    temp += email[i];\\n            }\\n            i = email.find(\\'@\\');\\n            temp += email.substr(i, email.length()-i);\\n            ans.insert(temp);\\n        }\\n        return ans.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> ans;\\n        for(string email : emails)\\n        {\\n            string temp = \"\";\\n            int i;\\n            for(i=0; email[i] != \\'@\\'; i++)\\n            {\\n                if(email[i] == \\'.\\')\\n                    continue;\\n                else if(email[i] == \\'+\\')\\n                    break;\\n                else\\n                    temp += email[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 568641,
                "title": "javascript-solution",
                "content": "```\\nvar numUniqueEmails = function(emails) {\\n    const set = new Set()\\n    \\n    for (let email of emails) {\\n        const address = normalizeEmail(email)\\n        set.add(address)\\n    }\\n    \\n    return set.size\\n};\\n\\nfunction normalizeEmail(email) {\\n    let [local, domain] = email.split(\"@\");\\n    local = local.replace(/(\\\\.)|(\\\\+.*)/g, \"\")\\n    return local + \"@\" + domain\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numUniqueEmails = function(emails) {\\n    const set = new Set()\\n    \\n    for (let email of emails) {\\n        const address = normalizeEmail(email)\\n        set.add(address)\\n    }\\n    \\n    return set.size\\n};\\n\\nfunction normalizeEmail(email) {\\n    let [local, domain] = email.split(\"@\");\\n    local = local.replace(/(\\\\.)|(\\\\+.*)/g, \"\")\\n    return local + \"@\" + domain\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461836,
                "title": "c-single-line",
                "content": "* For each string\\n  * Split by \\'@\\'\\n  * Remove all after the first \\'+\\' in the local name\\n  * Remove all dots in the local name\\n  * Concat the results back together to 1 string\\n* Return the distinct elements\\n```csharp\\npublic int NumUniqueEmails(string[] emails) \\n\\t=> emails.Select(x => x.Split(\\'@\\')).Select(split => split[0].Split(\\'+\\')[0].Replace(\".\", \"\") + \"@\" + split[1]).Distinct().Count();\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumUniqueEmails(string[] emails) \\n\\t=> emails.Select(x => x.Split(\\'@\\')).Select(split => split[0].Split(\\'+\\')[0].Replace(\".\", \"\") + \"@\" + split[1]).Distinct().Count();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242996,
                "title": "c-accepted-solution-beats-100-c",
                "content": "```\\npublic int NumUniqueEmails(string[] emails)\\n{\\n\\tHashSet<string> uEmails = new HashSet<string>();\\n\\tforeach (var email in emails)\\n\\t{\\n\\t\\tvar emailArr  = email.Split(\\'@\\');\\n\\t\\tstring emailId = emailArr[0];\\n\\t\\tif(emailId.IndexOf(\\'+\\')!=-1)\\n\\t\\t{\\n\\t\\t\\temailId = emailId.Substring(0, emailId.IndexOf(\\'+\\'));\\n\\t\\t}\\n\\t\\tuEmails.Add($\"{emailId.Replace(\".\", \"\")}@{emailArr[1]}\");\\n\\t}\\n\\treturn uEmails.Count();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumUniqueEmails(string[] emails)\\n{\\n\\tHashSet<string> uEmails = new HashSet<string>();\\n\\tforeach (var email in emails)\\n\\t{\\n\\t\\tvar emailArr  = email.Split(\\'@\\');\\n\\t\\tstring emailId = emailArr[0];\\n\\t\\tif(emailId.IndexOf(\\'+\\')!=-1)\\n\\t\\t{\\n\\t\\t\\temailId = emailId.Substring(0, emailId.IndexOf(\\'+\\'));\\n\\t\\t}\\n\\t\\tuEmails.Add($\"{emailId.Replace(\".\", \"\")}@{emailArr[1]}\");\\n\\t}\\n\\treturn uEmails.Count();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489706,
                "title": "a-collection-of-1-line-solutions-in-different-languages",
                "content": "**C#**\\n```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) =>\\n        emails.Select(email => email.Substring(0, System.Text.RegularExpressions.Regex.Match(email, \"[+@]\").Index).Replace(\".\", \"\") + email.Substring(email.IndexOf(\\'@\\'))).Distinct().Count();\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nfunction numUniqueEmails(emails) {\\n    return new Set(emails.map(email => email.substr(0, email.search(/[+@]/)).replaceAll(\\'.\\', \\'\\') + email.substr(email.search(\\'@\\')))).size\\n}\\n```\\n**Python**\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set(map(lambda email: email[:re.search(r\\'[+@]\\', email).start()].replace(\\'.\\', \\'\\') + email[email.find(\\'@\\'):], emails)))\\n```\\n**Ruby**\\n```\\n# @param {String[]} emails\\n# @return {Integer}\\ndef num_unique_emails(emails)\\n    emails.map{|email| email[0, email.index(/[+@]/)].gsub(\\'.\\', \\'\\') + email[email.index(\\'@\\')..]}.uniq.size\\nend\\n```\\n**Scala**\\n```\\nobject Solution {\\n    def numUniqueEmails(emails: Array[String]): Int =\\n        emails.map(email => email.substring(0, \"[+@]\".r.findFirstMatchIn(email).map(_.start).get).replace(\".\", \"\") + email.substring(email.indexOf(\"@\"))).distinct.length\\n}\\n```\\n**TypeScript**\\n```\\nfunction numUniqueEmails(emails: string[]): number {\\n    return new Set(emails.map(email => email.substr(0, email.search(/[+@]/)).replace(/\\\\.+/g, \\'\\') + email.substr(email.search(\\'@\\')))).size\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Ruby",
                    "Scala",
                    "TypeScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) =>\\n        emails.Select(email => email.Substring(0, System.Text.RegularExpressions.Regex.Match(email, \"[+@]\").Index).Replace(\".\", \"\") + email.Substring(email.IndexOf(\\'@\\'))).Distinct().Count();\\n}\\n```\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nfunction numUniqueEmails(emails) {\\n    return new Set(emails.map(email => email.substr(0, email.search(/[+@]/)).replaceAll(\\'.\\', \\'\\') + email.substr(email.search(\\'@\\')))).size\\n}\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set(map(lambda email: email[:re.search(r\\'[+@]\\', email).start()].replace(\\'.\\', \\'\\') + email[email.find(\\'@\\'):], emails)))\\n```\n```\\n# @param {String[]} emails\\n# @return {Integer}\\ndef num_unique_emails(emails)\\n    emails.map{|email| email[0, email.index(/[+@]/)].gsub(\\'.\\', \\'\\') + email[email.index(\\'@\\')..]}.uniq.size\\nend\\n```\n```\\nobject Solution {\\n    def numUniqueEmails(emails: Array[String]): Int =\\n        emails.map(email => email.substring(0, \"[+@]\".r.findFirstMatchIn(email).map(_.start).get).replace(\".\", \"\") + email.substring(email.indexOf(\"@\"))).distinct.length\\n}\\n```\n```\\nfunction numUniqueEmails(emails: string[]): number {\\n    return new Set(emails.map(email => email.substr(0, email.search(/[+@]/)).replace(/\\\\.+/g, \\'\\') + email.substr(email.search(\\'@\\')))).size\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941657,
                "title": "rust-functional",
                "content": "```rust\\nuse std::collections::HashSet;\\n\\nfn clean_email(email: String) -> String {\\n    let v: Vec<&str> = email.split(\\'@\\').collect();\\n    \\n    let left = v[0]\\n        .chars()\\n        .take_while(|&c| c != \\'+\\')\\n        .filter(|&c| c != \\'.\\')\\n        .collect::<String>();\\n    [&left, v[1]].join(\"@\")\\n}\\n\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        emails\\n            .into_iter()\\n            .map(clean_email)\\n            .collect::<HashSet<_>>()\\n            .len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\nfn clean_email(email: String) -> String {\\n    let v: Vec<&str> = email.split(\\'@\\').collect();\\n    \\n    let left = v[0]\\n        .chars()\\n        .take_while(|&c| c != \\'+\\')\\n        .filter(|&c| c != \\'.\\')\\n        .collect::<String>();\\n    [&left, v[1]].join(\"@\")\\n}\\n\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        emails\\n            .into_iter()\\n            .map(clean_email)\\n            .collect::<HashSet<_>>()\\n            .len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804556,
                "title": "java-simple-solution",
                "content": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor(String addr : emails) {\\n\\t\\tString[] parts = addr.split(\"@\");\\n\\t\\tparts[0] = parts[0].replaceAll(\"\\\\\\\\.\", \"\");\\n\\t\\tset.add(parts[0].split(\"\\\\\\\\+\")[0]+\"@\"+parts[1]);\\n\\t}\\n\\treturn set.size();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor(String addr : emails) {\\n\\t\\tString[] parts = addr.split(\"@\");\\n\\t\\tparts[0] = parts[0].replaceAll(\"\\\\\\\\.\", \"\");\\n\\t\\tset.add(parts[0].split(\"\\\\\\\\+\")[0]+\"@\"+parts[1]);\\n\\t}\\n\\treturn set.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461090,
                "title": "rust-4-lines",
                "content": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        emails.iter().map(|e| {\\n            e.chars().take_while(|&e| e != \\'+\\' && e != \\'@\\').filter(|&e| e != \\'.\\')\\n                .chain(e.chars().skip_while(|&e| e != \\'@\\')).collect::<String>()\\n        }).collect::<std::collections::HashSet<_>>().len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        emails.iter().map(|e| {\\n            e.chars().take_while(|&e| e != \\'+\\' && e != \\'@\\').filter(|&e| e != \\'.\\')\\n                .chain(e.chars().skip_while(|&e| e != \\'@\\')).collect::<String>()\\n        }).collect::<std::collections::HashSet<_>>().len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440258,
                "title": "python-using-regex",
                "content": "\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        expression, emails_set = r\\'([a-z0-9.]+)\\\\+?.*@(\\\\S+)\\', set()\\n        \\n        for email in emails:\\n            matches = re.findall(expression, email)\\n            email = re.sub(r\\'\\\\.\\', \\'\\', matches[0][0]) + \\'@\\' + matches[0][1]\\n            emails_set.add(email)\\n\\n        return len(emails_set)\\n```\\n\\n\\n\\n---------\\n\\nIf you wish to simplify/update/explore the expression, it\\'s been explained on the top right panel of [regex101.com](https://regex101.com/r/EEfeNu/1/). You can watch the matching steps or modify them in [this debugger link](https://regex101.com/r/EEfeNu/1/debugger), if you\\'d be interested. The debugger demonstrates that how [a RegEx engine](https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines) might step by step consume some sample input strings and would perform the matching process. \\n\\n---------\\n\\n### RegEx Circuit\\n\\n[jex.im](https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24) visualizes regular expressions: \\n\\n![image](https://assets.leetcode.com/users/emtrade/image_1575064831.png)\\n\\n\\n\\n### Without RegEx\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        visited = set()\\n        for email in emails:\\n            user, site = email.split(\\'@\\')\\n            local = user.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            visited.add(f\\'{local}@{site}\\')\\n\\n        return len(visited)\\n```\\n\\n### Reference\\n\\n[Explains it here](https://leetcode.com/problems/unique-email-addresses/discuss/186798/JavaPython-3-7-and-6-liners-with-comment-and-analysis.)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        expression, emails_set = r\\'([a-z0-9.]+)\\\\+?.*@(\\\\S+)\\', set()\\n        \\n        for email in emails:\\n            matches = re.findall(expression, email)\\n            email = re.sub(r\\'\\\\.\\', \\'\\', matches[0][0]) + \\'@\\' + matches[0][1]\\n            emails_set.add(email)\\n\\n        return len(emails_set)\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        visited = set()\\n        for email in emails:\\n            user, site = email.split(\\'@\\')\\n            local = user.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            visited.add(f\\'{local}@{site}\\')\\n\\n        return len(visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296687,
                "title": "javascript-js-one-liner-68-ms-beats-99-69-submissions",
                "content": "JS one-liner with a single regular expression and a set\\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    return emails.reduce((s, e) => s.add(e.replace(/(\\\\+.*(?=@)|(\\\\.(?=.*@)))/g, \\'\\')), new Set()).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    return emails.reduce((s, e) => s.add(e.replace(/(\\\\+.*(?=@)|(\\\\.(?=.*@)))/g, \\'\\')), new Set()).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208818,
                "title": "python-solution",
                "content": "`O(n)` time, `O(n)` space, where `n` is the total length of all emails.\\n\\n```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        seen = set()\\n        for email in emails:\\n            local, domain = email.split(\\'@\\')\\n            local = local.split(\\'+\\')[0]\\n            local = local.replace(\\'.\\',\\'\\')\\n            seen.add(local+\\'@\\'+domain)\\n        return len(seen)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        seen = set()\\n        for email in emails:\\n            local, domain = email.split(\\'@\\')\\n            local = local.split(\\'+\\')[0]\\n            local = local.replace(\\'.\\',\\'\\')\\n            seen.add(local+\\'@\\'+domain)\\n        return len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190720,
                "title": "i-don-t-think-javascript-solutions-are-working",
                "content": "I tried an accepted solution I had previously submitted, the one posted here, and a new one, and I keep getting runtime errors. Is anybody successfully able to submit a javascript solution at all right now? \n\n```\nvar numUniqueEmails = function(emails) {\n    let map = {};\n    let dupCount = 0;\n    \n    for (email of emails) {\n        email = email.split(\"@\");\n        email = `${email[0].replace(/(\\.)+|(\\+(.*))/mgi, '')}@${email[1]}`;   \n        if (map[email]) dupCount++;\n        else map[email] = true;\n    }\n    \n    return emails.length - dupCount;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar numUniqueEmails = function(emails) {\n    let map = {};\n    let dupCount = 0;\n    \n    for (email of emails) {\n        email = email.split(\"@\");\n        email = `${email[0].replace(/(\\.)+|(\\+(.*))/mgi, '')}@${email[1]}`;   \n        if (map[email]) dupCount++;\n        else map[email] = true;\n    }\n    \n    return emails.length - dupCount;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186805,
                "title": "c-short-simple-elegant-solutions-o-n-m-time-o-n-m-space",
                "content": "Simply create a tempary email from each input email. Modifying as follows;\n1. Strip out any `.` before either either a `+` or `@` is encountered.\n2. Exclude anything from `+` to `@` (if a `+` is encounted.\n\nAdd the resulting tempary email to a hashset before finally returning the size of the hashset.\n\n### Fast, single pass. O(n * m) time, O(n * m) space where n is number of emails and m is average string length.\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      std::string tmp;\n\n      // Copy everything that is not a '.' until a '+' or a '@' is encountered\t\t\t\n      auto it = email.begin();\n      for (; '@' != *it && '+' != *it; ++it) {\n        if ('.' != *it) {\n          tmp += *it;\n        }\n      }\n\n      // Copy the domain into our tempary email\n      it = std::find(it, email.end(), '@');\n      tmp.append(it, email.end());\n\n      // Add the trimmed email to our set of emails\n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\t\n\n### A pure stl solution. O(n * m) time, O(n * m) space\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      std::string tmp;\n\n      // Find the end of the local name\n      auto it = std::find_if(email.begin(), email.end(), [](char c) -> bool { return '+' == c || '@' == c; });\n\n      // Copy the local name, excluding any '.'\n      std::copy_if(email.begin(), it, std::back_inserter(tmp), [](char c) -> bool { return c != '.';});\n\n      // Add the domain\n      it = std::find(it, email.end(), '@');\n      std::copy(it, email.end(), std::back_inserter(tmp));\n\n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n\n### Using `std::string` operations rather than stl algorithms. O(n * m^2) time, O(n * m) space\nThe copy from the input email upto either `+` or `@`, then loop around removing `.`. This is quadratic, O(m^2) operation because each removal of a '.' requires shifting the remaining string.\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      auto at_pos = email.find('@');\n      auto end_pos = email.find('+');\n      if (end_pos == std::string::npos) {\n        end_pos = at_pos;\n      }\n     \n      // Copy the local name component\n      std::string tmp = email.substr(0, end_pos);\n    \n      // Quadratically remove '.' from our tempary string\n      auto dot_pos = tmp.find('.'); \n      while (dot_pos != std::string::npos) {\n        tmp.erase(dot_pos, 1);\n        dot_pos = tmp.find('.', dot_pos);\n      }\n     \n      // Add the domain\n      tmp += email.substr(at_pos);\n      \n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n\n### Faster string operations solutions. O(n * m) time, O(n * m) space.\nThe quadratic removal of `.`s can be removed by copying the sections between `.`s from the input strings.\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      auto at_pos = email.find('@');\n      auto end_pos = email.find('+');\n      if (end_pos == std::string::npos) {\n        end_pos = at_pos;\n      }\n  \n      std::string tmp;\n\n      // Copy sections of the input email between the '.'s\n      std::string::size_type start = 0;\n      auto dot_pos = email.find('.');\n      while (dot_pos != std::string::npos && dot_pos < end_pos) {\n        tmp += email.substr(start, dot_pos - start);\n        start = dot_pos + 1;\n        dot_pos = email.find('.', start);\n      }\n      tmp += email.substr(start, end_pos - start);\n     \n      // Add the domain\n      tmp += email.substr(at_pos);\n      \n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n\nI personally prefer the first solution because it copies the input email as it searches and results in a lot less double handling. I frankly hate the `std::string` operations as they tend to be less efficent, but have added them as suggested in the comments.",
                "solutionTags": [],
                "code": "```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      std::string tmp;\n\n      // Copy everything that is not a '.' until a '+' or a '@' is encountered\t\t\t\n      auto it = email.begin();\n      for (; '@' != *it && '+' != *it; ++it) {\n        if ('.' != *it) {\n          tmp += *it;\n        }\n      }\n\n      // Copy the domain into our tempary email\n      it = std::find(it, email.end(), '@');\n      tmp.append(it, email.end());\n\n      // Add the trimmed email to our set of emails\n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      std::string tmp;\n\n      // Find the end of the local name\n      auto it = std::find_if(email.begin(), email.end(), [](char c) -> bool { return '+' == c || '@' == c; });\n\n      // Copy the local name, excluding any '.'\n      std::copy_if(email.begin(), it, std::back_inserter(tmp), [](char c) -> bool { return c != '.';});\n\n      // Add the domain\n      it = std::find(it, email.end(), '@');\n      std::copy(it, email.end(), std::back_inserter(tmp));\n\n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      auto at_pos = email.find('@');\n      auto end_pos = email.find('+');\n      if (end_pos == std::string::npos) {\n        end_pos = at_pos;\n      }\n     \n      // Copy the local name component\n      std::string tmp = email.substr(0, end_pos);\n    \n      // Quadratically remove '.' from our tempary string\n      auto dot_pos = tmp.find('.'); \n      while (dot_pos != std::string::npos) {\n        tmp.erase(dot_pos, 1);\n        dot_pos = tmp.find('.', dot_pos);\n      }\n     \n      // Add the domain\n      tmp += email.substr(at_pos);\n      \n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      auto at_pos = email.find('@');\n      auto end_pos = email.find('+');\n      if (end_pos == std::string::npos) {\n        end_pos = at_pos;\n      }\n  \n      std::string tmp;\n\n      // Copy sections of the input email between the '.'s\n      std::string::size_type start = 0;\n      auto dot_pos = email.find('.');\n      while (dot_pos != std::string::npos && dot_pos < end_pos) {\n        tmp += email.substr(start, dot_pos - start);\n        start = dot_pos + 1;\n        dot_pos = email.find('.', start);\n      }\n      tmp += email.substr(start, end_pos - start);\n     \n      // Add the domain\n      tmp += email.substr(at_pos);\n      \n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775689,
                "title": "c-basic-solution-hash-map",
                "content": "```\\nint numUniqueEmails(vector<string> &emails) {\\n    // can use a hashset too\\n\\tunordered_map<string, int> cnt;\\n\\n    for (int i = 0; i < emails.size(); i++) {\\n        \\n        string temp = \"\";\\n        string now = emails[i];\\n\\n        for (int j = 0; now[j] != \\'@\\'; j++) {\\n            \\n            if (now[j] == \\'+\\')\\n                break;\\n            \\n            if (now[j] == \\'.\\')\\n                continue;\\n            \\n            temp.push_back(now[j]);\\n        }\\n        \\n        int index = now.find(\\'@\\');\\n        \\n        while (index < now.size()) {\\n            temp.push_back(now[index++]);\\n        }\\n        \\n        cnt[temp]++;\\n    }\\n\\n  return cnt.size();\\n\\n}\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numUniqueEmails(vector<string> &emails) {\\n    // can use a hashset too\\n\\tunordered_map<string, int> cnt;\\n\\n    for (int i = 0; i < emails.size(); i++) {\\n        \\n        string temp = \"\";\\n        string now = emails[i];\\n\\n        for (int j = 0; now[j] != \\'@\\'; j++) {\\n            \\n            if (now[j] == \\'+\\')\\n                break;\\n            \\n            if (now[j] == \\'.\\')\\n                continue;\\n            \\n            temp.push_back(now[j]);\\n        }\\n        \\n        int index = now.find(\\'@\\');\\n        \\n        while (index < now.size()) {\\n            temp.push_back(now[index++]);\\n        }\\n        \\n        cnt[temp]++;\\n    }\\n\\n  return cnt.size();\\n\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1491633,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        std::unordered_set<string> s;\\n        for (const auto &email : emails)\\n        {\\n            s.insert(cleanupAddress(email));\\n        }\\n        return s.size();\\n    }\\n    private:\\n    string cleanupAddress(const string &email)\\n    {\\n        int localEnd = email.find(\\'@\\');\\n        string cleanLocal;\\n        for (int i = 0; i < localEnd; ++i)\\n        {\\n            if (email[i] == \\'+\\')\\n            {\\n                break;\\n            }\\n            else if (email[i] != \\'.\\')\\n            {\\n                cleanLocal += email[i];\\n            }\\n        }\\n        return cleanLocal + email.substr(localEnd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        std::unordered_set<string> s;\\n        for (const auto &email : emails)\\n        {\\n            s.insert(cleanupAddress(email));\\n        }\\n        return s.size();\\n    }\\n    private:\\n    string cleanupAddress(const string &email)\\n    {\\n        int localEnd = email.find(\\'@\\');\\n        string cleanLocal;\\n        for (int i = 0; i < localEnd; ++i)\\n        {\\n            if (email[i] == \\'+\\')\\n            {\\n                break;\\n            }\\n            else if (email[i] != \\'.\\')\\n            {\\n                cleanLocal += email[i];\\n            }\\n        }\\n        return cleanLocal + email.substr(localEnd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813240,
                "title": "easy-concise-using-find-erase-c",
                "content": "**Let\\'s start the cleaning process**\\n\\nFeel free to ask anything, these are some basic functions.\\nPreety much it got everything that you already are thinking.\\n\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n            \\n        for(auto &x:emails){\\n            auto pos2 = x.find(\\'@\\');\\n            if(pos2 < x.size())\\n                x.erase(remove(x.begin(),x.begin()+pos2,\\'.\\'),x.begin()+pos2);\\n            \\n            auto pos1 = x.find(\\'+\\');\\n            pos2 = x.find(\\'@\\');\\n            if(pos1 < x.size() and pos2 < x.size())\\n                x.erase(pos1,pos2-pos1);\\n        }\\n        \\n        unordered_set<string> ans(emails.begin(),emails.end());\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n            \\n        for(auto &x:emails){\\n            auto pos2 = x.find(\\'@\\');\\n            if(pos2 < x.size())\\n                x.erase(remove(x.begin(),x.begin()+pos2,\\'.\\'),x.begin()+pos2);\\n            \\n            auto pos1 = x.find(\\'+\\');\\n            pos2 = x.find(\\'@\\');\\n            if(pos1 < x.size() and pos2 < x.size())\\n                x.erase(pos1,pos2-pos1);\\n        }\\n        \\n        unordered_set<string> ans(emails.begin(),emails.end());\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475237,
                "title": "c-80-using-std-unordered-map",
                "content": "class Solution \\n{\\n    public:\\n    \\n    int numUniqueEmails(std::vector<std::string>& e) \\n    {\\n        std::unordered_map<std::string, int> ma;\\n        \\n        for(size_t i = 0; i < e.size(); i++)\\n        {\\n            auto pos = e[i].find(\\'@\\');\\n            \\n            const std::string p2 = e[i].substr(pos);\\n            \\n            std::string p1 = e[i].substr(0, pos);\\n           \\n            p1.erase(std::remove(p1.begin(), p1.end(), \\'.\\'), p1.end());\\n            \\n            pos = p1.find(\\'+\\');\\n            \\n            if(pos != std::string::npos)\\n            {\\n                p1 = p1.substr(0, pos);\\n            }\\n            \\n            ma[p1+p2] = 0;\\n        }\\n        \\n        return ma.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n    \\n    int numUniqueEmails(std::vector<std::string>& e) \\n    {\\n        std::unordered_map<std::string, int> ma;\\n        \\n        for(size_t i = 0; i < e.size(); i++)\\n        {\\n            auto pos = e[i].find(\\'@\\');\\n            \\n            const std::string p2 = e[i].substr(pos);\\n            \\n            std::string p1 = e[i].substr(0, pos);\\n           \\n            p1.erase(std::remove(p1.begin(), p1.end(), \\'.\\'), p1.end());\\n            \\n            pos = p1.find(\\'+\\');\\n            \\n            if(pos != std::string::npos)\\n            {\\n                p1 = p1.substr(0, pos);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 338553,
                "title": "javascript-one-liner",
                "content": "```Javascript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(email => `${email.split(\\'@\\')[0].split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${email.split(\\'@\\')[1]}`)).size\\n```",
                "solutionTags": [],
                "code": "```Javascript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(email => `${email.split(\\'@\\')[0].split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${email.split(\\'@\\')[1]}`)).size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294977,
                "title": "python-beat-99-87",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        if not emails:\\n            return 0\\n        addrs = set()\\n        for email in emails:\\n            addr = email.split(\\'@\\')\\n            local_name = addr[0].split(\\'+\\')\\n            local_name = local_name[0].replace(\\'.\\', \\'\\')\\n            addrs.add(local_name + \\'@\\' + addr[-1])\\n        return len(addrs)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        if not emails:\\n            return 0\\n        addrs = set()\\n        for email in emails:\\n            addr = email.split(\\'@\\')\\n            local_name = addr[0].split(\\'+\\')\\n            local_name = local_name[0].replace(\\'.\\', \\'\\')\\n            addrs.add(local_name + \\'@\\' + addr[-1])\\n        return len(addrs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289396,
                "title": "java-simple-modular-solution-beats-100",
                "content": "**Explanation:**\\nThe main part of the code is straightforward: process each email as instructed and add it to the hashset which allows to know how many unique emails there are.\\n\\nThe process function examines an email character by character. The last \"if\" condition decides when to add a character. It will only add characters coming from the end of the email, and before the end of the email will ignore all points and all character after any plus symbol.\\n\\n**Analysis:**\\nThis solution is in O(n) time and space. (n being the size of the input array)\\nRuntime: faster than 100%. Memory: less than 98%.\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> uniqueEmails = new HashSet<>();\\n        for(String email: emails){\\n            uniqueEmails.add(processEmail(email));\\n        }\\n        return uniqueEmails.size();\\n    }\\n    \\n    \\n    private String processEmail(String email){\\n        StringBuilder outEmail = new StringBuilder();\\n        \\n        boolean afterPlus = false, endEmail = false;\\n        for(char c: email.toCharArray()){\\n            if(c == \\'+\\') afterPlus = true;\\n            if(c == \\'@\\') endEmail = true;\\n            if(endEmail || (!afterPlus && c != \\'.\\')) outEmail.append(c);\\n        }\\n        \\n        return outEmail.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> uniqueEmails = new HashSet<>();\\n        for(String email: emails){\\n            uniqueEmails.add(processEmail(email));\\n        }\\n        return uniqueEmails.size();\\n    }\\n    \\n    \\n    private String processEmail(String email){\\n        StringBuilder outEmail = new StringBuilder();\\n        \\n        boolean afterPlus = false, endEmail = false;\\n        for(char c: email.toCharArray()){\\n            if(c == \\'+\\') afterPlus = true;\\n            if(c == \\'@\\') endEmail = true;\\n            if(endEmail || (!afterPlus && c != \\'.\\')) outEmail.append(c);\\n        }\\n        \\n        return outEmail.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254862,
                "title": "python-10-lines-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        uniques = set() # A set can not contain duplicates\\n        for email in emails:\\n            name, domain = email.split(\"@\")\\n            if \"+\" in name:\\n                name = name.split(\"+\")[0].replace(\".\", \"\") # grab everything before \"+\", remove \".\"\\n            else:\\n                name = name.replace(\\'.\\', \"\") # remove \".\"\\n            cleanEmail = name + \"@\" + domain # reassemble emails\\n            uniques.add(cleanEmail) # add cleanEmail to set, which will not accept duplicates\\n        return len(uniques) # return length of uniques to get number of uniques\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        uniques = set() # A set can not contain duplicates\\n        for email in emails:\\n            name, domain = email.split(\"@\")\\n            if \"+\" in name:\\n                name = name.split(\"+\")[0].replace(\".\", \"\") # grab everything before \"+\", remove \".\"\\n            else:\\n                name = name.replace(\\'.\\', \"\") # remove \".\"\\n            cleanEmail = name + \"@\" + domain # reassemble emails\\n            uniques.add(cleanEmail) # add cleanEmail to set, which will not accept duplicates\\n        return len(uniques) # return length of uniques to get number of uniques\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234312,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        var processedLocalNames = Set<String>()\\n        emails.forEach {\\n            let components = $0.components(separatedBy: \"@\")\\n            processedLocalNames.insert(\"\\\\(components[0].processedLocalName)@\\\\(components[1])\")\\n        }\\n        return processedLocalNames.count\\n    }\\n}\\n\\nextension String {\\n    var processedLocalName: String {\\n        let prePlus = components(separatedBy: \"+\")[0]\\n        return prePlus.components(separatedBy: \".\").joined()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        var processedLocalNames = Set<String>()\\n        emails.forEach {\\n            let components = $0.components(separatedBy: \"@\")\\n            processedLocalNames.insert(\"\\\\(components[0].processedLocalName)@\\\\(components[1])\")\\n        }\\n        return processedLocalNames.count\\n    }\\n}\\n\\nextension String {\\n    var processedLocalName: String {\\n        let prePlus = components(separatedBy: \"+\")[0]\\n        return prePlus.components(separatedBy: \".\").joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590291,
                "title": "simple-solution-using-hashset-and-basic-string-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst locate the index of @, divide the string into two parts local host name before @ and domain name after @. Do the needful by continuing the iteration if \\'.\\' is encountered and break out of the iteration if \\'+\\' is encountered. Build the whole string using Set Builer and add it into set. (Set holds unique values). Find the size of the set as answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet <String> set=new HashSet<>();\\n        for(int i=0;i<emails.length;i++)\\n        {\\n            String current=emails[i];\\n            StringBuilder sb=new StringBuilder();\\n            int indexOfAt=current.indexOf(\\'@\\');\\n            String localName=current.substring(0,indexOfAt);\\n            String domainName=current.substring(indexOfAt);\\n\\n            for(int j=0;j<localName.length();j++)\\n            {\\n                if(localName.charAt(j)==\\'.\\')\\n                {\\n                    continue;\\n                }\\n                if(localName.charAt(j)==\\'+\\')\\n                {\\n                    break;\\n                }\\n                sb.append(localName.charAt(j));\\n            }\\n            sb.append(domainName);\\n            set.add(sb.toString());\\n        }   \\n        return set.size();     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet <String> set=new HashSet<>();\\n        for(int i=0;i<emails.length;i++)\\n        {\\n            String current=emails[i];\\n            StringBuilder sb=new StringBuilder();\\n            int indexOfAt=current.indexOf(\\'@\\');\\n            String localName=current.substring(0,indexOfAt);\\n            String domainName=current.substring(indexOfAt);\\n\\n            for(int j=0;j<localName.length();j++)\\n            {\\n                if(localName.charAt(j)==\\'.\\')\\n                {\\n                    continue;\\n                }\\n                if(localName.charAt(j)==\\'+\\')\\n                {\\n                    break;\\n                }\\n                sb.append(localName.charAt(j));\\n            }\\n            sb.append(domainName);\\n            set.add(sb.toString());\\n        }   \\n        return set.size();     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331797,
                "title": "short-sweet-easy-to-understand-c",
                "content": "````\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> s1;\\n        string str = \"\";\\n        int i,n;\\n        bool k = false;\\n        for(auto &s: emails){\\n            str = \"\";\\n            n = s.length();\\n            k = false;\\n            for(i = 0; i < n;i++){\\n                if(s[i]==\\'@\\'){\\n                    str = str +\\'@\\';\\n                    k = true;\\n                }else if(k){\\n                    str = str + s[i];\\n                }else if(s[i]==\\'+\\'){\\n                    while(s[i] != \\'@\\'){\\n                        i++;\\n                    }\\n                    i--;\\n                }else if(s[i]==\\'.\\'){\\n                    continue;\\n                }else{\\n                    str = str+s[i];\\n                }\\n            }\\n            cout<<str<<endl;\\n            s1.insert(str);\\n        }\\n        return s1.size();\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> s1;\\n        string str = \"\";\\n        int i,n;\\n        bool k = false;\\n        for(auto &s: emails){\\n            str = \"\";\\n            n = s.length();\\n            k = false;\\n            for(i = 0; i < n;i++){\\n                if(s[i]==\\'@\\'){\\n                    str = str +\\'@\\';\\n                    k = true;\\n                }else if(k){\\n                    str = str + s[i];\\n                }else if(s[i]==\\'+\\'){\\n                    while(s[i] != \\'@\\'){\\n                        i++;\\n                    }\\n                    i--;\\n                }else if(s[i]==\\'.\\'){\\n                    continue;\\n                }else{\\n                    str = str+s[i];\\n                }\\n            }\\n            cout<<str<<endl;\\n            s1.insert(str);\\n        }\\n        return s1.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2717478,
                "title": "java-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails) {\\n            int indexOfAt = email.indexOf(\\'@\\');\\n            String front = email.substring(0, indexOfAt);\\n            int index = front.indexOf(\\'+\\');\\n            if (index >= 0) {\\n                front = front.substring(0, index);\\n            }\\n            front = front.replaceAll(\"\\\\\\\\.\", \"\");\\n            String finalString = front + email.substring(indexOfAt);\\n            set.add(finalString);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails) {\\n            int indexOfAt = email.indexOf(\\'@\\');\\n            String front = email.substring(0, indexOfAt);\\n            int index = front.indexOf(\\'+\\');\\n            if (index >= 0) {\\n                front = front.substring(0, index);\\n            }\\n            front = front.replaceAll(\"\\\\\\\\.\", \"\");\\n            String finalString = front + email.substring(indexOfAt);\\n            set.add(finalString);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555449,
                "title": "simple-python-solution-faster-than-98-7",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        set_ = set()\\n        for i in emails:\\n            final_email = \"\"\\n            email = i.split(\"@\")\\n            email[0] = email[0].replace(\".\",\"\")\\n            if \"+\" in email[0]:\\n                index= email[0].index(\"+\")\\n                email[0] = email[0][:index]\\n            final_email+=email[0]+\"@\"+email[1]\\n            set_.add(final_email)\\n        return len(set_)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        set_ = set()\\n        for i in emails:\\n            final_email = \"\"\\n            email = i.split(\"@\")\\n            email[0] = email[0].replace(\".\",\"\")\\n            if \"+\" in email[0]:\\n                index= email[0].index(\"+\")\\n                email[0] = email[0][:index]\\n            final_email+=email[0]+\"@\"+email[1]\\n            set_.add(final_email)\\n        return len(set_)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295855,
                "title": "java-solution-using-hashset-faster-than-96-31",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        String[] copy = new String[emails.length];\\n        HashSet<String> set = new HashSet<>();\\n        for(String email: emails){\\n            StringBuilder localName = new StringBuilder();\\n            boolean local = true;\\n            int index = -1;\\n            for(char c: email.toCharArray()){\\n                index++;\\n                if(c == \\'.\\')\\n                    continue;\\n                if(c == \\'+\\'){\\n                    local = false;\\n                    continue;\\n                }\\n                if(c == \\'@\\')\\n                    break;\\n                else if(local)\\n                    localName.append(c);\\n            }\\n            set.add(localName.toString() + email.substring(index));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        String[] copy = new String[emails.length];\\n        HashSet<String> set = new HashSet<>();\\n        for(String email: emails){\\n            StringBuilder localName = new StringBuilder();\\n            boolean local = true;\\n            int index = -1;\\n            for(char c: email.toCharArray()){\\n                index++;\\n                if(c == \\'.\\')\\n                    continue;\\n                if(c == \\'+\\'){\\n                    local = false;\\n                    continue;\\n                }\\n                if(c == \\'@\\')\\n                    break;\\n                else if(local)\\n                    localName.append(c);\\n            }\\n            set.add(localName.toString() + email.substring(index));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695954,
                "title": "javascript-time-o-n",
                "content": "## Please upvote, if it helps you!\\n\\n```\\nvar numUniqueEmails = function(emails) {\\n    let uniqueEmails = new Set()\\n    \\n    function removeCharsAfterPlus(email) {\\n        let [localName, domain] = email.split(\\'@\\')\\n        localName = localName.split(\\'+\\')[0]\\n        return localName + \\'@\\' + domain\\n    }\\n    \\n    function getCharsWithoutDots(email) {\\n        let [localName, domain] = email.split(\\'@\\')\\n        localName = localName.split(\\'.\\').join(\\'\\')\\n        return localName + \\'@\\' + domain\\n    }\\n    \\n    for (let email of emails) {\\n        email = removeCharsAfterPlus(email)\\n        email = getCharsWithoutDots(email)\\n        uniqueEmails.add(email)\\n    }\\n    \\n    return uniqueEmails.size\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar numUniqueEmails = function(emails) {\\n    let uniqueEmails = new Set()\\n    \\n    function removeCharsAfterPlus(email) {\\n        let [localName, domain] = email.split(\\'@\\')\\n        localName = localName.split(\\'+\\')[0]\\n        return localName + \\'@\\' + domain\\n    }\\n    \\n    function getCharsWithoutDots(email) {\\n        let [localName, domain] = email.split(\\'@\\')\\n        localName = localName.split(\\'.\\').join(\\'\\')\\n        return localName + \\'@\\' + domain\\n    }\\n    \\n    for (let email of emails) {\\n        email = removeCharsAfterPlus(email)\\n        email = getCharsWithoutDots(email)\\n        uniqueEmails.add(email)\\n    }\\n    \\n    return uniqueEmails.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561527,
                "title": "rust-functional-solution-4-ms",
                "content": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        emails\\n            .iter()\\n            .map(|s| {\\n                let (mut plus, mut domain) = (false, false);\\n                s.chars()\\n                    .filter(|&c| match c {\\n                        _ if domain => true,\\n                        \\'+\\' => {\\n                            plus = true;\\n                            false\\n                        }\\n                        \\'@\\' => {\\n                            domain = true;\\n                            true\\n                        }\\n                        _ if plus => false,\\n                        \\'.\\' => false,\\n                        _ => true,\\n                    })\\n                    .collect::<String>()\\n            })\\n            .collect::<HashSet<_>>()\\n            .len() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        emails\\n            .iter()\\n            .map(|s| {\\n                let (mut plus, mut domain) = (false, false);\\n                s.chars()\\n                    .filter(|&c| match c {\\n                        _ if domain => true,\\n                        \\'+\\' => {\\n                            plus = true;\\n                            false\\n                        }\\n                        \\'@\\' => {\\n                            domain = true;\\n                            true\\n                        }\\n                        _ if plus => false,\\n                        \\'.\\' => false,\\n                        _ => true,\\n                    })\\n                    .collect::<String>()\\n            })\\n            .collect::<HashSet<_>>()\\n            .len() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492238,
                "title": "c-linear-solution-explained-100-time-99-space",
                "content": "To solve this problem we will just have to clean up our strings, then use something to remove duplicated - an `unordered_set` works just fine for that.\\n\\nSo, our support variables are going to be:\\n* `tmp`, the string we will build gradually as we clean up each provided one;\\n* `res` is going to be our aforementioned set, convenient to store and avoid duplicates in `O(lgn)`;\\n* `beforeAt` and `plusSeen` are two boolean flags will use to mark specific points in each email.\\n\\nWe will then loop through each string `s` given to us and:\\n* clear `tmp`, ready for another loop;\\n*  reset `beforeAt` and `plusSeen` to be `true` and `false`, respectively;\\n*  loops through each character `c` of `s` and:\\n\\t*  if `c` is a `\\'+\\'`, set `plusSeen` to `true`;\\n\\t*  alternatively, if `c` is `@\\'`, set `beforeAt` to `false` and reset `plusSeen` to `false`;\\n\\t*  check if we found a `\\'.\\'` before the `\\'@\\'` (`beforeAt && c == \\'.\\'`) or if we are after a `\\'+\\'` (`plusSeen`), in which case we just `continue`;\\n\\t*  append `c` to `tmp`;\\n*  finally, insert `tmp` in `res`.\\n\\nOnce done, we can just `return` `res.size()` to get the uniques and be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        // support variables\\n        string tmp;\\n        unordered_set<string> res;\\n        bool beforeAt, plusSeen;\\n        // parsing emails\\n        for (string &s: emails) {\\n            // resetting loop variables\\n            tmp.clear();\\n            beforeAt = true, plusSeen = false;\\n            for (char c: s) {\\n                if (c == \\'+\\') plusSeen = true;\\n                else if (c == \\'@\\') beforeAt = false, plusSeen = false;\\n                if (beforeAt && c == \\'.\\' || plusSeen) continue;\\n                tmp += c;\\n            }\\n            res.insert(tmp);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        // support variables\\n        string tmp;\\n        unordered_set<string> res;\\n        bool beforeAt, plusSeen;\\n        // parsing emails\\n        for (string &s: emails) {\\n            // resetting loop variables\\n            tmp.clear();\\n            beforeAt = true, plusSeen = false;\\n            for (char c: s) {\\n                if (c == \\'+\\') plusSeen = true;\\n                else if (c == \\'@\\') beforeAt = false, plusSeen = false;\\n                if (beforeAt && c == \\'.\\' || plusSeen) continue;\\n                tmp += c;\\n            }\\n            res.insert(tmp);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489772,
                "title": "javascript-100-68ms-very-simple-set-solution",
                "content": "![image](https://assets.leetcode.com/users/images/9fd56a9d-0d2c-45aa-a6cb-e73ae82c7fe0_1632762725.68751.png)\\n\\nPosting solutions to dailies.\\n\\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    if (email.includes(\\'+\\')) {\\n      let pIdx = email.indexOf(\\'+\\')\\n      let aIdx = email.indexOf(\\'@\\')\\n      email = email.substr(0, pIdx) + email.substr(aIdx)\\n    }\\n    email = email.split(\\'@\\');\\n    email[0].includes(\\'.\\') && \\n      (email[0] = email[0].replace(/[.]/g, \\'\\'))\\n    email = email.join(\\'@\\')\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\\n\\nNote:  You can also do\\n```\\n    let [local, domain] = email.split(\\'@\\');\\n    local = local.replace(/[.]/g, \\'\\')\\n    res.add(local + \\'@\\' + domain)\\n```\\nThis might be a little more readable / easier to work with in an actual code base.  Here on LC, it just adds runtime and space though.  That said, I do like destructuring for readability in cases like this.\\n\\nHere is an alternate string method only version without .split().  I wanted to see if the runtime was faster, it\\'s about the same though.\\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    if (email.includes(\\'+\\')) {\\n      const pIdx = email.indexOf(\\'+\\')\\n      const aIdx = email.indexOf(\\'@\\')\\n      email = email.substr(0, pIdx) + email.substr(aIdx)\\n    }\\n    let splitIdx = email.indexOf(\\'@\\')\\n    email = email.substr(0,splitIdx).replace(/[.]/g, \\'\\') + email.substr(splitIdx)\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\\n\\nOne last version, because I thought getting rid of the O(n) .indexOf calls would speed it up markedly.  Performance improvement was negligible though.  It still gets 100%, but 72ms was the best I got in 5x runs.  Technically, I do believe this algorithm does the least amount of work though.  One O(n) for each email to get necessary indexes, another O(local.length) for the replace. O(numEmails * localDomainLength) for all of these solutions.  This one only has to loop through local domain twice though, others do it 3+ times.  Was a small improvement experiment, and completely unnecessary optimization since the results were negligible and readability suffered dramatically.\\n\\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    let pIdx, aIdx, hasP = false;\\n    for (let i = 0; i < email.length; i++) {\\n      if (!pIdx && email[i] === \\'+\\') pIdx = i;\\n      else if (email[i] === \\'@\\') {\\n        aIdx = i;\\n        if (!pIdx) pIdx = i;\\n        break;\\n      } else if (email[i] === \\'.\\') hasP = true;\\n    }\\n    if (pIdx !== aIdx) email = email.substr(0, pIdx) + email.substr(aIdx)\\n    if (hasP) email = email.substr(0, pIdx).replace(/[.]/g, \\'\\') + email.substr(pIdx)\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\\n\\nI lied - last, last version.  Here we just simply build up the local and as soon as we reach the @, we add on the rest and put it in the set.\\n\\n```\\nconst numUniqueEmails = emails => {\\n  const res = new Set();\\n  for (let email of emails) {\\n    let formated = \\'\\';\\n    for (let i = 0, char = email[i], afP;\\n         i < email.length; char = email[++i]) {\\n      if (char === \\'@\\') {\\n        formated += email.substr(i);\\n        break;\\n      }\\n      if (char === \\'+\\') afP = true;\\n      if (afP || char === \\'.\\') continue;\\n      formated += char\\n    }\\n    res.add(formated);\\n  }\\n  return res.size;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/783d5532-9323-4ad3-8f52-9e1019df68e6_1632762735.7302983.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    if (email.includes(\\'+\\')) {\\n      let pIdx = email.indexOf(\\'+\\')\\n      let aIdx = email.indexOf(\\'@\\')\\n      email = email.substr(0, pIdx) + email.substr(aIdx)\\n    }\\n    email = email.split(\\'@\\');\\n    email[0].includes(\\'.\\') && \\n      (email[0] = email[0].replace(/[.]/g, \\'\\'))\\n    email = email.join(\\'@\\')\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\n```\\n    let [local, domain] = email.split(\\'@\\');\\n    local = local.replace(/[.]/g, \\'\\')\\n    res.add(local + \\'@\\' + domain)\\n```\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    if (email.includes(\\'+\\')) {\\n      const pIdx = email.indexOf(\\'+\\')\\n      const aIdx = email.indexOf(\\'@\\')\\n      email = email.substr(0, pIdx) + email.substr(aIdx)\\n    }\\n    let splitIdx = email.indexOf(\\'@\\')\\n    email = email.substr(0,splitIdx).replace(/[.]/g, \\'\\') + email.substr(splitIdx)\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    let pIdx, aIdx, hasP = false;\\n    for (let i = 0; i < email.length; i++) {\\n      if (!pIdx && email[i] === \\'+\\') pIdx = i;\\n      else if (email[i] === \\'@\\') {\\n        aIdx = i;\\n        if (!pIdx) pIdx = i;\\n        break;\\n      } else if (email[i] === \\'.\\') hasP = true;\\n    }\\n    if (pIdx !== aIdx) email = email.substr(0, pIdx) + email.substr(aIdx)\\n    if (hasP) email = email.substr(0, pIdx).replace(/[.]/g, \\'\\') + email.substr(pIdx)\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\n```\\nconst numUniqueEmails = emails => {\\n  const res = new Set();\\n  for (let email of emails) {\\n    let formated = \\'\\';\\n    for (let i = 0, char = email[i], afP;\\n         i < email.length; char = email[++i]) {\\n      if (char === \\'@\\') {\\n        formated += email.substr(i);\\n        break;\\n      }\\n      if (char === \\'+\\') afP = true;\\n      if (afP || char === \\'.\\') continue;\\n      formated += char\\n    }\\n    res.add(formated);\\n  }\\n  return res.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489291,
                "title": "unique-emails-c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        \\n        set<string>st ;\\n        vector<string>::iterator it ;\\n        \\n       // for( it = emails.begin() ; it != emails.end() ; it++ )\\n        \\n        for( auto& I : emails )\\n        {\\n            int n = I.length() ;\\n            string tmp = \"\" ;\\n            int TC = 100 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if( I[i] == \\'+\\' )\\n                {\\n                    while( I[i] != \\'@\\' )\\n                        i++ ;\\n                    TC = i ;\\n                }\\n                else if( I[i] == \\'@\\' )\\n                    TC = i ;\\n                //cout<<i<<\"  \"<<TC<<endl;\\n                if( I[i] == \\'.\\' && i < TC )\\n                    continue ;\\n                tmp+=I[i] ;\\n                \\n            }\\n            cout<<tmp<<endl ;\\n            if(!st.count(tmp))\\n                st.insert(tmp) ;\\n            \\n        }\\n        \\n        \\n        return st.size() ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        \\n        set<string>st ;\\n        vector<string>::iterator it ;\\n        \\n       // for( it = emails.begin() ; it != emails.end() ; it++ )\\n        \\n        for( auto& I : emails )\\n        {\\n            int n = I.length() ;\\n            string tmp = \"\" ;\\n            int TC = 100 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if( I[i] == \\'+\\' )\\n                {\\n                    while( I[i] != \\'@\\' )\\n                        i++ ;\\n                    TC = i ;\\n                }\\n                else if( I[i] == \\'@\\' )\\n                    TC = i ;\\n                //cout<<i<<\"  \"<<TC<<endl;\\n                if( I[i] == \\'.\\' && i < TC )\\n                    continue ;\\n                tmp+=I[i] ;\\n                \\n            }\\n            cout<<tmp<<endl ;\\n            if(!st.count(tmp))\\n                st.insert(tmp) ;\\n            \\n        }\\n        \\n        \\n        return st.size() ;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1474475,
                "title": "python-regex",
                "content": "Build a set by using set comprehension by iterating over addresses and subsituting 1. \\'+\\' and anything that follows up to @ and 2. substitute all \\'.\\' in localname only (utilizing positive lookahead). Return length of the set:\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        addresses = { re.sub(   \\'\\\\.(?=.*@)\\',\\n                                \\'\\', \\n                                re.sub( \\'\\\\+.*@\\',\\n                                        \\'@\\',\\n                                        address )) for address in emails }\\n        return len(addresses)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        addresses = { re.sub(   \\'\\\\.(?=.*@)\\',\\n                                \\'\\', \\n                                re.sub( \\'\\\\+.*@\\',\\n                                        \\'@\\',\\n                                        address )) for address in emails }",
                "codeTag": "Java"
            },
            {
                "id": 1238575,
                "title": "c-easy-solution-production-ready-code-using-set-with-explanation-using-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    * Process String to apply rules\\n    */\\n    string processString(string str) {\\n        int zero = 0;\\n        \\n        /*\\n        * Separate local_name, \"@\"+domain_name. Setps:\\n        * 1. get location of \"@\"\\n        * 2. separate local_name using location of \"@\"\\n        * 3. separate \"@{domain_name}\" string\\n        */\\n        int at_loc = str.find(\"@\");\\n        string local_name = str.substr(zero, at_loc);\\n        string domain_name = str.substr(at_loc, str.length());\\n        \\n        /*\\n        * Remove local_name after \"+\". Steps:\\n        * 1. Find location of \"+\"\\n        * 2. If plus exists(i.e. plus_loc != -1) then\\n        * 3. Take local_name before \"+\"\\n        */\\n        int plus_loc = local_name.find(\"+\");\\n        if(plus_loc != -1)\\n            local_name = local_name.substr(zero, plus_loc);\\n        \\n        /*\\n        * Remove each dot in local_name. Steps:\\n        * 1. Find location of \".\"\\n        * 2. If dot exists then\\n        * 3. Replace \".\" with blank string(i.e. \"\")\\n        * 4. Find location of next dot\\n        */\\n        int dot_loc = local_name.find(\".\");\\n        while(dot_loc != -1) {\\n            local_name.replace(dot_loc, 1, \"\");\\n            dot_loc = local_name.find(\".\");\\n        }\\n        \\n        // Finally return local_name + domain_name\\n        return local_name + domain_name;\\n    }\\n    \\n    /*\\n    * Process Each email and put unique values \\n    * into set and finally return size of set\\n    */\\n    int numUniqueEmails(vector<string>& emails) {\\n        /*\\n        * Create a set since set stores only unique values \\n        * and we need to return no. of unique values only\\n        */\\n        set<string> ans;\\n        \\n        /* \\n\\t\\t* Process each input email and put processed \\n        * value in set if it does not exist already.\\n        */\\n        for(auto email: emails) {\\n            string proccessedEmail = processString(email);\\n            if(ans.find(proccessedEmail) == ans.end()) {\\n                ans.insert(proccessedEmail);\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```\\n\\nProcess each email and put processed email in a set if it already does not contain the processed email. Finally return the size of the set.\\n\\n*Do hit the upvote button if you like the solution or find it helpful.*\\n\\n**Thanks. Hope it helps.**\\n~*Sadul Khod*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    * Process String to apply rules\\n    */\\n    string processString(string str) {\\n        int zero = 0;\\n        \\n        /*\\n        * Separate local_name, \"@\"+domain_name. Setps:\\n        * 1. get location of \"@\"\\n        * 2. separate local_name using location of \"@\"\\n        * 3. separate \"@{domain_name}\" string\\n        */\\n        int at_loc = str.find(\"@\");\\n        string local_name = str.substr(zero, at_loc);\\n        string domain_name = str.substr(at_loc, str.length());\\n        \\n        /*\\n        * Remove local_name after \"+\". Steps:\\n        * 1. Find location of \"+\"\\n        * 2. If plus exists(i.e. plus_loc != -1) then\\n        * 3. Take local_name before \"+\"\\n        */\\n        int plus_loc = local_name.find(\"+\");\\n        if(plus_loc != -1)\\n            local_name = local_name.substr(zero, plus_loc);\\n        \\n        /*\\n        * Remove each dot in local_name. Steps:\\n        * 1. Find location of \".\"\\n        * 2. If dot exists then\\n        * 3. Replace \".\" with blank string(i.e. \"\")\\n        * 4. Find location of next dot\\n        */\\n        int dot_loc = local_name.find(\".\");\\n        while(dot_loc != -1) {\\n            local_name.replace(dot_loc, 1, \"\");\\n            dot_loc = local_name.find(\".\");\\n        }\\n        \\n        // Finally return local_name + domain_name\\n        return local_name + domain_name;\\n    }\\n    \\n    /*\\n    * Process Each email and put unique values \\n    * into set and finally return size of set\\n    */\\n    int numUniqueEmails(vector<string>& emails) {\\n        /*\\n        * Create a set since set stores only unique values \\n        * and we need to return no. of unique values only\\n        */\\n        set<string> ans;\\n        \\n        /* \\n\\t\\t* Process each input email and put processed \\n        * value in set if it does not exist already.\\n        */\\n        for(auto email: emails) {\\n            string proccessedEmail = processString(email);\\n            if(ans.find(proccessedEmail) == ans.end()) {\\n                ans.insert(proccessedEmail);\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867547,
                "title": "c-brute-force-solution-beats-100-runtime-95-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        set<string> res;\\n        for (int i = 0; i < emails.size(); ++i)\\n        {\\n            int count = 0;\\n            for (int j = 0; j < emails[i].length(); ++j)\\n            {\\n                if (emails[i][j] == \\'@\\')\\n                    break;\\n                else if (emails[i][j] == \\'.\\')\\n                {\\n                    emails[i].erase(j, 1);\\n                    --j;\\n                }\\n                else if (emails[i][j] == \\'+\\')\\n                {\\n                    count = j;\\n                    break;\\n                }\\n            }\\n\\n            int pos = emails[i].find(\\'@\\');\\n            if (count != 0)\\n                emails[i].erase(count, pos - count);\\n            res.insert(emails[i]);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        set<string> res;\\n        for (int i = 0; i < emails.size(); ++i)\\n        {\\n            int count = 0;\\n            for (int j = 0; j < emails[i].length(); ++j)\\n            {\\n                if (emails[i][j] == \\'@\\')\\n                    break;\\n                else if (emails[i][j] == \\'.\\')\\n                {\\n                    emails[i].erase(j, 1);\\n                    --j;\\n                }\\n                else if (emails[i][j] == \\'+\\')\\n                {\\n                    count = j;\\n                    break;\\n                }\\n            }\\n\\n            int pos = emails[i].find(\\'@\\');\\n            if (count != 0)\\n                emails[i].erase(count, pos - count);\\n            res.insert(emails[i]);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385476,
                "title": "cpp-using-unordered-set",
                "content": "Runtime: 36 ms, faster than 51.17% of C++ online submissions for Unique Email Addresses.\\nMemory Usage: 13.2 MB, less than 59.52% of C++ online submissions for Unique Email Addresses.\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> ust;\\n        \\n        for (auto str:emails)\\n        {\\n            string tmp;\\n            \\n            for (auto c:str)\\n            {\\n                if (c == \\'.\\') continue;\\n                if (c == \\'+\\' || c == \\'@\\') break;\\n                tmp.push_back(c);\\n            }\\n            ust.insert(tmp + str.substr(str.find(\\'@\\')));\\n        }\\n        \\n        return ust.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> ust;\\n        \\n        for (auto str:emails)\\n        {\\n            string tmp;\\n            \\n            for (auto c:str)\\n            {\\n                if (c == \\'.\\') continue;\\n                if (c == \\'+\\' || c == \\'@\\') break;\\n                tmp.push_back(c);\\n            }\\n            ust.insert(tmp + str.substr(str.find(\\'@\\')));\\n        }\\n        \\n        return ust.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358313,
                "title": "python3-straight-forward-solution",
                "content": "* slipt the email into local and domain\\n*  clean local\\n\\t* \\treplace \\',\\' with \\'\\' in local\\n\\t* \\tslice local from the beginning of local to the index of \\'+\\'\\n*  rebuild the email address using cleaned local and domain \\n*  count the rebuild email address\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for i in emails:\\n            local,domain = i.split(\\'@\\')\\n            if \\'.\\' in local:\\n                local = local.replace(\\'.\\',\\'\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            seen.add(local+\\'@\\'+domain)\\n        return len(seen)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for i in emails:\\n            local,domain = i.split(\\'@\\')\\n            if \\'.\\' in local:\\n                local = local.replace(\\'.\\',\\'\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            seen.add(local+\\'@\\'+domain)\\n        return len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353132,
                "title": "c-very-simple-28-ms-faster-than-93-92",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> ans;\\n        for(int i=0;i<emails.size();i++){\\n            string s=\"\";\\n            int pos=emails[i].find(\"@\");\\n            string sub=emails[i].substr(pos);\\n            for(char x:emails[i]){                \\n                if(x==\\'.\\')continue;\\n                if(x==\\'+\\'||x==\\'@\\')break;\\n                s.push_back(x);                \\n            }\\n            s+=sub;\\n            ans.insert(s);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> ans;\\n        for(int i=0;i<emails.size();i++){\\n            string s=\"\";\\n            int pos=emails[i].find(\"@\");\\n            string sub=emails[i].substr(pos);\\n            for(char x:emails[i]){                \\n                if(x==\\'.\\')continue;\\n                if(x==\\'+\\'||x==\\'@\\')break;\\n                s.push_back(x);                \\n            }\\n            s+=sub;\\n            ans.insert(s);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320985,
                "title": "javascript-beats-100-in-memory-usage-always-and-100-in-performance-sometimes",
                "content": "```javascript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    const r = /(\\\\.(?=[^@]+@))|(\\\\+.+(?=@))/g;\\n    return new Set(emails.map((item) => {\\n        return item.replace(r, \\'\\');\\n    })).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    const r = /(\\\\.(?=[^@]+@))|(\\\\+.+(?=@))/g;\\n    return new Set(emails.map((item) => {\\n        return item.replace(r, \\'\\');\\n    })).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278640,
                "title": "swift-solution-clean-and-easy-read-beats-99",
                "content": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        guard emails.count > 0 else { return 0 }\\n        var resultSet = Set<String>()\\n        \\n        for email in emails {\\n            let seperated = email.split(separator: \"@\")\\n            let local = seperated[0], validDomain = seperated[1]\\n            var validLocal = String()\\n            \\n            for char in local where char != \".\" {\\n                guard char != \"+\" else { break }\\n                validLocal.append(char)\\n            }\\n            \\n            let validFormat = validLocal + \"@\" + validDomain\\n            resultSet.insert(String(validFormat))\\n        }\\n        return resultSet.count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        guard emails.count > 0 else { return 0 }\\n        var resultSet = Set<String>()\\n        \\n        for email in emails {\\n            let seperated = email.split(separator: \"@\")\\n            let local = seperated[0], validDomain = seperated[1]\\n            var validLocal = String()\\n            \\n            for char in local where char != \".\" {\\n                guard char != \"+\" else { break }\\n                validLocal.append(char)\\n            }\\n            \\n            let validFormat = validLocal + \"@\" + validDomain\\n            resultSet.insert(String(validFormat))\\n        }\\n        return resultSet.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245978,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Map<String,Integer> m = new HashMap<>();\\n        for(String x:emails){\\n            String[] y = x.split(\"@\");\\n                String s= y[0];\\n                if(s.contains(\"+\")){\\n                    s = s.substring(0,s.indexOf(\"+\"));\\n                }\\n            if(s.contains(\".\")){\\n                String[] tmp = s.split(\".\");\\n                s = Arrays.toString(tmp); \\n            }\\n               \\n            if(!m.containsKey(s+\"@\"+y[1])){\\n                \\n                m.put(s+\"@\"+y[1],1);\\n            }\\n            \\n        }\\n        return m.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Map<String,Integer> m = new HashMap<>();\\n        for(String x:emails){\\n            String[] y = x.split(\"@\");\\n                String s= y[0];\\n                if(s.contains(\"+\")){\\n                    s = s.substring(0,s.indexOf(\"+\"));\\n                }\\n            if(s.contains(\".\")){\\n                String[] tmp = s.split(\".\");\\n                s = Arrays.toString(tmp); \\n            }\\n               \\n            if(!m.containsKey(s+\"@\"+y[1])){\\n                \\n                m.put(s+\"@\"+y[1],1);\\n            }\\n            \\n        }\\n        return m.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245711,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int count=0;\\n        unordered_set<string> storage;\\n        for(auto email:emails){\\n            string temp=\"\";\\n            bool before=true;\\n            for(int i=0;i<email.length();i++){\\n                if(before){\\n                    if(email[i]==\\'.\\') i++;\\n                    if(email[i]==\\'+\\'){while(email[i]!=\\'@\\'){i++;}}\\n                    if(email[i]==\\'@\\') before=false;\\n                }\\n                temp+=email[i];\\n            }\\n            if(storage.find(temp)==storage.end()) count++;\\n            storage.insert(temp);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int count=0;\\n        unordered_set<string> storage;\\n        for(auto email:emails){\\n            string temp=\"\";\\n            bool before=true;\\n            for(int i=0;i<email.length();i++){\\n                if(before){\\n                    if(email[i]==\\'.\\') i++;\\n                    if(email[i]==\\'+\\'){while(email[i]!=\\'@\\'){i++;}}\\n                    if(email[i]==\\'@\\') before=false;\\n                }\\n                temp+=email[i];\\n            }\\n            if(storage.find(temp)==storage.end()) count++;\\n            storage.insert(temp);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212286,
                "title": "c-o-n-12-ms-with-fast-i-o",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {        \\n        unordered_set<string> s;\\n        char                  str[101];\\n        \\n        for (int i = 0; i < emails.size(); ++i) {\\n            const char*  src = emails[i].c_str();\\n            const char*  end = src + emails[i].length();\\n            char*        dst = str;\\n            \\n            // Process local\\n            while (*src != \\'+\\' && *src != \\'@\\') {\\n                if (*src != \\'.\\') *dst = *src, ++dst;\\n                ++src;\\n            }\\n            \\n            while (*src != \\'@\\') ++src;\\n            \\n            // Process domain\\n            memcpy(dst, src, end - src + 1);\\n            \\n            // Update hash table\\n            s.emplace(str);\\n        }\\n        \\n        return s.size();\\n    }\\n};\\n\\n// Fast I/O\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {        \\n        unordered_set<string> s;\\n        char                  str[101];\\n        \\n        for (int i = 0; i < emails.size(); ++i) {\\n            const char*  src = emails[i].c_str();\\n            const char*  end = src + emails[i].length();\\n            char*        dst = str;\\n            \\n            // Process local\\n            while (*src != \\'+\\' && *src != \\'@\\') {\\n                if (*src != \\'.\\') *dst = *src, ++dst;\\n                ++src;\\n            }\\n            \\n            while (*src != \\'@\\') ++src;\\n            \\n            // Process domain\\n            memcpy(dst, src, end - src + 1);\\n            \\n            // Update hash table\\n            s.emplace(str);\\n        }\\n        \\n        return s.size();\\n    }\\n};\\n\\n// Fast I/O\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207653,
                "title": "rust-simple-state-machine-and-hashset-4ms",
                "content": "```\\nuse std::collections::HashSet;\\n\\n#[derive(Debug, Copy, Clone)]\\nenum EmailParseState {\\n    Name,\\n    Plus,\\n    Domain\\n}\\n\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        let mut unique_emails = HashSet::new();\\n        for email in emails {\\n            let nemail = Solution::parse_email(&email);\\n            unique_emails.insert(nemail);\\n        }\\n        unique_emails.len() as i32\\n    }\\n    \\n    fn parse_email(email: &String) -> String {\\n        let mut nemail = String::new();\\n        let mut state = EmailParseState::Name;\\n        \\n        for c in email.chars() {\\n            let (new_state, ch) = match (state, c) {\\n                (EmailParseState::Name, \\'.\\') => (state, None),\\n                (EmailParseState::Name, \\'+\\') => (EmailParseState::Plus, None),\\n                (EmailParseState::Name, \\'@\\') => (EmailParseState::Domain, Some(c)),\\n                (EmailParseState::Name, _) => (state, Some(c)),\\n                (EmailParseState::Plus, \\'@\\') => (EmailParseState::Domain, Some(c)),\\n                (EmailParseState::Plus, _) => (state, None),\\n                (EmailParseState::Domain, _) => (state, Some(c)),\\n            };            \\n            if let Some(c) = ch {\\n                nemail.push(c);\\n            }\\n            state = new_state;\\n        };\\n        nemail\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\n#[derive(Debug, Copy, Clone)]\\nenum EmailParseState {\\n    Name,\\n    Plus,\\n    Domain\\n}\\n\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        let mut unique_emails = HashSet::new();\\n        for email in emails {\\n            let nemail = Solution::parse_email(&email);\\n            unique_emails.insert(nemail);\\n        }\\n        unique_emails.len() as i32\\n    }\\n    \\n    fn parse_email(email: &String) -> String {\\n        let mut nemail = String::new();\\n        let mut state = EmailParseState::Name;\\n        \\n        for c in email.chars() {\\n            let (new_state, ch) = match (state, c) {\\n                (EmailParseState::Name, \\'.\\') => (state, None),\\n                (EmailParseState::Name, \\'+\\') => (EmailParseState::Plus, None),\\n                (EmailParseState::Name, \\'@\\') => (EmailParseState::Domain, Some(c)),\\n                (EmailParseState::Name, _) => (state, Some(c)),\\n                (EmailParseState::Plus, \\'@\\') => (EmailParseState::Domain, Some(c)),\\n                (EmailParseState::Plus, _) => (state, None),\\n                (EmailParseState::Domain, _) => (state, Some(c)),\\n            };            \\n            if let Some(c) = ch {\\n                nemail.push(c);\\n            }\\n            state = new_state;\\n        };\\n        nemail\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197936,
                "title": "python-solution-beat-91",
                "content": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        if not emails:\\n            return 0\\n        def valid(email):\\n            local,host=email.split(\\'@\\')\\n            local=local.replace(\\'.\\',\\'\\')\\n            #print(local)\\n            local=local.split(\\'+\\')[0]\\n            # print(local)\\n            return local+\\'@\\'+host\\n        res=set()\\n        for email in emails:\\n            res.add(valid(email))\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        if not emails:\\n            return 0\\n        def valid(email):\\n            local,host=email.split(\\'@\\')\\n            local=local.replace(\\'.\\',\\'\\')\\n            #print(local)\\n            local=local.split(\\'+\\')[0]\\n            # print(local)\\n            return local+\\'@\\'+host\\n        res=set()\\n        for email in emails:\\n            res.add(valid(email))\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186824,
                "title": "python-self-explanatory-solution",
                "content": "* Self-explanatory\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        addresses = set()\\n        for email in emails:\\n            local, domain = email.split(\"@\")\\n            local = local.split(\"+\")[0].replace(\".\", \"\")\\n            addresses.add(local + \"@\" + domain)\\n        return len(addresses)\\n```\\n* 1-liner Pythonic\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        return len({e.split(\"@\")[0].split(\"+\")[0].replace(\".\", \"\") + e.split(\"@\")[1] for e in emails})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        addresses = set()\\n        for email in emails:\\n            local, domain = email.split(\"@\")\\n            local = local.split(\"+\")[0].replace(\".\", \"\")\\n            addresses.add(local + \"@\" + domain)\\n        return len(addresses)\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        return len({e.split(\"@\")[0].split(\"+\")[0].replace(\".\", \"\") + e.split(\"@\")[1] for e in emails})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186645,
                "title": "java-clean-o-n-maxstringlen-with-and-without-split",
                "content": "**With split**\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails){\\n            String[]parts = email.split(\"@\");\\n            String local = parseLocal(parts[0]);\\n            String domain = parts[1];\\n            set.add(local + \\'@\\' + domain);\\n        }\\n            return set.size();\\n\\n    }\\n    \\n    \\n    String parseLocal(String local){\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : local.toCharArray()){\\n            if (c != \\'.\\'){//Skip the period characters\\n                if (c == \\'+\\') return sb.toString(); //Ignore everything else\\n                sb.append(c); //Not a period and not a + character\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n}\\n\\n```\\n\\n**Without split**\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails){\\n            String[]parts = getParts(email);\\n            String local = parseLocal(parts[0]);\\n            String domain = parts[1];\\n            set.add(local + \\'@\\' + domain);\\n        }\\n            return set.size();\\n\\n    }\\n    \\n    \\n    String parseLocal(String local){\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : local.toCharArray()){\\n            if (c != \\'.\\'){//Skip the period characters\\n                if (c == \\'+\\') return sb.toString(); //Ignore everything else\\n                sb.append(c); //Not a period and not a + character\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    String[] getParts(String email){\\n        int i = 0;\\n        while (i < email.length() && email.charAt(i) != \\'@\\') i++;\\n        return new String[]{email.substring(0, i), email.substring(i+1)};\\n    }\\n    \\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails){\\n            String[]parts = email.split(\"@\");\\n            String local = parseLocal(parts[0]);\\n            String domain = parts[1];\\n            set.add(local + \\'@\\' + domain);\\n        }\\n            return set.size();\\n\\n    }\\n    \\n    \\n    String parseLocal(String local){\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : local.toCharArray()){\\n            if (c != \\'.\\'){//Skip the period characters\\n                if (c == \\'+\\') return sb.toString(); //Ignore everything else\\n                sb.append(c); //Not a period and not a + character\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n}\\n\\n```\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails){\\n            String[]parts = getParts(email);\\n            String local = parseLocal(parts[0]);\\n            String domain = parts[1];\\n            set.add(local + \\'@\\' + domain);\\n        }\\n            return set.size();\\n\\n    }\\n    \\n    \\n    String parseLocal(String local){\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : local.toCharArray()){\\n            if (c != \\'.\\'){//Skip the period characters\\n                if (c == \\'+\\') return sb.toString(); //Ignore everything else\\n                sb.append(c); //Not a period and not a + character\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    String[] getParts(String email){\\n        int i = 0;\\n        while (i < email.length() && email.charAt(i) != \\'@\\') i++;\\n        return new String[]{email.substring(0, i), email.substring(i+1)};\\n    }\\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735159,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        if (emails.length == 1) {\\n            return 1;\\n        }\\n\\n        HashSet<String> emailSet = new HashSet<>();\\n        int result = 0;\\n\\n        for (String email : emails) {\\n            int com = email.indexOf(\"@\");\\n            int plus = email.indexOf(\"+\");\\n            String res = email;\\n            \\n            if (plus > 0) {\\n                res = email.substring(0, plus) + email.substring(com);\\n            }\\n            com = res.indexOf(\"@\");\\n            while (res.indexOf(\".\") < com) {\\n                com = res.indexOf(\"@\");\\n                res = res.substring(0, res.indexOf(\".\")) + res.substring(res.indexOf(\".\") + 1);\\n            }\\n\\n            if (emailSet.contains(res)) {\\n                continue;\\n            }\\n\\n            emailSet.add(res);\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        if (emails.length == 1) {\\n            return 1;\\n        }\\n\\n        HashSet<String> emailSet = new HashSet<>();\\n        int result = 0;\\n\\n        for (String email : emails) {\\n            int com = email.indexOf(\"@\");\\n            int plus = email.indexOf(\"+\");\\n            String res = email;\\n            \\n            if (plus > 0) {\\n                res = email.substring(0, plus) + email.substring(com);\\n            }\\n            com = res.indexOf(\"@\");\\n            while (res.indexOf(\".\") < com) {\\n                com = res.indexOf(\"@\");\\n                res = res.substring(0, res.indexOf(\".\")) + res.substring(res.indexOf(\".\") + 1);\\n            }\\n\\n            if (emailSet.contains(res)) {\\n                continue;\\n            }\\n\\n            emailSet.add(res);\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521760,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> uniqEmails;\\n        for(string& email: emails) {\\n            bool inDomain = false;\\n            string actEmail;\\n            int i = 0;\\n            for(int i = 0; i < email.size(); ) {\\n                char c = email[i];\\n                if (inDomain) {\\n                    actEmail.push_back(c);\\n                    i++;\\n                } else {\\n                    if (c == \\'@\\') {\\n                        actEmail.push_back(c);\\n                        inDomain = true;\\n                        i++;\\n                    } else if (c == \\'.\\') {\\n                        i++;\\n                    } else if (c == \\'+\\') {\\n                        while(email[i] != \\'@\\') {\\n                            i++;\\n                        }\\n                    } else {\\n                        actEmail.push_back(c);\\n                        i++;\\n                    }\\n                }\\n            }\\n            uniqEmails.insert(actEmail);\\n        }\\n        return uniqEmails.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        addresses = set()\\n\\n        for email in emails:\\n            local, domain = email.split(\\'@\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            local = local.replace(\\'.\\', \\'\\')\\n            addresses.add(local + \\'@\\' + domain)\\n        \\n        return len(addresses)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> es = new HashSet<>();\\n        \\n        for (String e: emails) {\\n            es.add(strip(e));\\n        }\\n        return es.size();\\n    }\\n    public String strip(String e) {\\n        int i = 0;\\n        StringBuilder res = new StringBuilder();\\n        \\n        while (i < e.length()) {\\n            char c = e.charAt(i);\\n            if (c == \\'+\\') {\\n                i = e.indexOf(\\'@\\');\\n                continue;\\n            } else if (c == \\'@\\') {\\n                res.append(e.substring(i));\\n                return res.toString();\\n            } else if (c != \\'.\\')\\n                res.append(c);\\n            i++;\\n        }\\n        return res.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> uniqEmails;\\n        for(string& email: emails) {\\n            bool inDomain = false;\\n            string actEmail;\\n            int i = 0;\\n            for(int i = 0; i < email.size(); ) {\\n                char c = email[i];\\n                if (inDomain) {\\n                    actEmail.push_back(c);\\n                    i++;\\n                } else {\\n                    if (c == \\'@\\') {\\n                        actEmail.push_back(c);\\n                        inDomain = true;\\n                        i++;\\n                    } else if (c == \\'.\\') {\\n                        i++;\\n                    } else if (c == \\'+\\') {\\n                        while(email[i] != \\'@\\') {\\n                            i++;\\n                        }\\n                    } else {\\n                        actEmail.push_back(c);\\n                        i++;\\n                    }\\n                }\\n            }\\n            uniqEmails.insert(actEmail);\\n        }\\n        return uniqEmails.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        addresses = set()\\n\\n        for email in emails:\\n            local, domain = email.split(\\'@\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            local = local.replace(\\'.\\', \\'\\')\\n            addresses.add(local + \\'@\\' + domain)\\n        \\n        return len(addresses)\\n```\n```Java []\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> es = new HashSet<>();\\n        \\n        for (String e: emails) {\\n            es.add(strip(e));\\n        }\\n        return es.size();\\n    }\\n    public String strip(String e) {\\n        int i = 0;\\n        StringBuilder res = new StringBuilder();\\n        \\n        while (i < e.length()) {\\n            char c = e.charAt(i);\\n            if (c == \\'+\\') {\\n                i = e.indexOf(\\'@\\');\\n                continue;\\n            } else if (c == \\'@\\') {\\n                res.append(e.substring(i));\\n                return res.toString();\\n            } else if (c != \\'.\\')\\n                res.append(c);\\n            i++;\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141312,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n*maxsizeof(email element))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string>s;\\n        string x;\\n        for(int i=0;i<emails.size();i++)\\n        {\\n            x=\"\";\\n            for(int j=0;j<emails[i].length();)\\n            {\\n                if(emails[i][j]==\\'+\\')\\n                {\\n                    while(emails[i][j]!=\\'@\\')\\n                    {\\n                       j++;\\n                    }\\n                    while(j<emails[i].length())\\n                    {\\n                        x+=emails[i][j];\\n                        j++;\\n                    }\\n                }\\n                else if(emails[i][j]==\\'@\\')\\n                {\\n                    while(j<emails[i].length())\\n                    {\\n                        x+=emails[i][j];\\n                        j++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(emails[i][j]==\\'.\\')\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    x+=emails[i][j];\\n                    \\n                }\\n                j++;\\n\\n            }\\n            \\n            s.insert(x);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string>s;\\n        string x;\\n        for(int i=0;i<emails.size();i++)\\n        {\\n            x=\"\";\\n            for(int j=0;j<emails[i].length();)\\n            {\\n                if(emails[i][j]==\\'+\\')\\n                {\\n                    while(emails[i][j]!=\\'@\\')\\n                    {\\n                       j++;\\n                    }\\n                    while(j<emails[i].length())\\n                    {\\n                        x+=emails[i][j];\\n                        j++;\\n                    }\\n                }\\n                else if(emails[i][j]==\\'@\\')\\n                {\\n                    while(j<emails[i].length())\\n                    {\\n                        x+=emails[i][j];\\n                        j++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(emails[i][j]==\\'.\\')\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    x+=emails[i][j];\\n                    \\n                }\\n                j++;\\n\\n            }\\n            \\n            s.insert(x);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962322,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        \\n        func bare(_ s: String) -> String {\\n            let p = s.components(separatedBy: \"@\")\\n            let n = p[0]\\n                .components(separatedBy: \"+\")\\n                .first!\\n                .components(separatedBy: \".\")\\n                .joined()\\n            return \"\\\\(n)@\\\\(p[1])\"\\n        }\\n        \\n        return Set(emails.map(bare)).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        \\n        func bare(_ s: String) -> String {\\n            let p = s.components(separatedBy: \"@\")\\n            let n = p[0]\\n                .components(separatedBy: \"+\")\\n                .first!\\n                .components(separatedBy: \".\")\\n                .joined()\\n            return \"\\\\(n)@\\\\(p[1])\"\\n        }\\n        \\n        return Set(emails.map(bare)).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874912,
                "title": "rust-a-fast-functional-solution",
                "content": "First, here\\'s how you can solve the problem without referencing any crates.\\n\\n```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        \\n        emails\\n            .iter()\\n            .map(|string| {\\n                let mut parts = string.split(\\'@\\');\\n                (parts.next().unwrap(), parts.next().unwrap())\\n            })\\n            .map(|(local_name, domain_name)| {\\n                (\\n                    local_name\\n                        .chars()\\n                        .take_while(|char| *char != \\'+\\')\\n                        .filter(|char| *char != \\'.\\')\\n                        .collect::<String>(),\\n                    domain_name.to_owned(),\\n                )\\n            })\\n            .collect::<HashSet<(String, String)>>()\\n            .len() as i32\\n    }\\n}\\n```\\n\\nA bit ugly, but it works. However, if you\\'re fine with adding `itertools` to your project, you can do better.\\n\\n```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use itertools::Itertools;\\n        \\n        emails\\n            .iter()\\n            .map(|string| string.split(\\'@\\').collect_tuple().expect(\"An email adress should consist of two substrings separated by a \\'@\\'.\"))\\n            .map(|(local_name, domain_name)| {\\n                (\\n                    local_name\\n                        .chars()\\n                        .take_while(|char| *char != \\'+\\')\\n                        .filter(|char| *char != \\'.\\')\\n                        .collect::<String>(),\\n                    domain_name.to_owned(),\\n                )\\n            })\\n            .unique()\\n            .count() as i32\\n    }\\n}\\n```\\n\\nNotice that `Itertools::unique()` lets us avoid an explicit `HashSet` definition (though it does something similar under the hood) and, more importantly, how `Itertools::collect_tuple()` lets us avoid two `next()` calls. Since Rust doesn\\'t allow collecting into an array, this is the best we can do.",
                "solutionTags": [
                    "Rust",
                    "String"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        \\n        emails\\n            .iter()\\n            .map(|string| {\\n                let mut parts = string.split(\\'@\\');\\n                (parts.next().unwrap(), parts.next().unwrap())\\n            })\\n            .map(|(local_name, domain_name)| {\\n                (\\n                    local_name\\n                        .chars()\\n                        .take_while(|char| *char != \\'+\\')\\n                        .filter(|char| *char != \\'.\\')\\n                        .collect::<String>(),\\n                    domain_name.to_owned(),\\n                )\\n            })\\n            .collect::<HashSet<(String, String)>>()\\n            .len() as i32\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use itertools::Itertools;\\n        \\n        emails\\n            .iter()\\n            .map(|string| string.split(\\'@\\').collect_tuple().expect(\"An email adress should consist of two substrings separated by a \\'@\\'.\"))\\n            .map(|(local_name, domain_name)| {\\n                (\\n                    local_name\\n                        .chars()\\n                        .take_while(|char| *char != \\'+\\')\\n                        .filter(|char| *char != \\'.\\')\\n                        .collect::<String>(),\\n                    domain_name.to_owned(),\\n                )\\n            })\\n            .unique()\\n            .count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2842080,
                "title": "very-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> store;\\n        for(auto& str : emails){\\n            int l=str.size();\\n            int i=0,j=0;\\n            string s =\"\";\\n            bool flag = true;\\n            while(i<l && str[i] != \\'@\\'){\\n                if(str[i]==\\'+\\'){\\n                    flag = false;\\n                }\\n                else if(flag && str[i] != \\'.\\'){\\n                    s += str[i];\\n                }\\n                ++i;\\n            }\\n            for(j=i; j<l; ++j){\\n                s += str[j];\\n            }\\n            store.insert(s);\\n        }\\n        return store.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> store;\\n        for(auto& str : emails){\\n            int l=str.size();\\n            int i=0,j=0;\\n            string s =\"\";\\n            bool flag = true;\\n            while(i<l && str[i] != \\'@\\'){\\n                if(str[i]==\\'+\\'){\\n                    flag = false;\\n                }\\n                else if(flag && str[i] != \\'.\\'){\\n                    s += str[i];\\n                }\\n                ++i;\\n            }\\n            for(j=i; j<l; ++j){\\n                s += str[j];\\n            }\\n            store.insert(s);\\n        }\\n        return store.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838282,
                "title": "cpp-very-easy-to-understand-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& arr) \\n    {\\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string str = arr[i];\\n            string s =\"\";\\n            \\n            int pos = str.find(\\'@\\');\\n            string temp1 = str.substr(0,pos);\\n            string temp2 = str.substr(pos,str.length());\\n            \\n            int idx = 0;\\n            while(idx < temp1.length())\\n            {\\n                if(temp1[idx]==\\'+\\')\\n                {\\n                    break;\\t\\n                }\\n                else if(temp1[idx]==\\'.\\')\\n                {\\n                    idx++;\\n                }\\n                else \\n                {\\n                    s.push_back(temp1[idx]);\\n                    idx++;\\n                }\\n            }   \\n            mp[s+temp2]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& arr) \\n    {\\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string str = arr[i];\\n            string s =\"\";\\n            \\n            int pos = str.find(\\'@\\');\\n            string temp1 = str.substr(0,pos);\\n            string temp2 = str.substr(pos,str.length());\\n            \\n            int idx = 0;\\n            while(idx < temp1.length())\\n            {\\n                if(temp1[idx]==\\'+\\')\\n                {\\n                    break;\\t\\n                }\\n                else if(temp1[idx]==\\'.\\')\\n                {\\n                    idx++;\\n                }\\n                else \\n                {\\n                    s.push_back(temp1[idx]);\\n                    idx++;\\n                }\\n            }   \\n            mp[s+temp2]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833783,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String email : emails){\\n            String[] split = email.split(\"@\");\\n            String localName = split[0].replace(\".\", \"\");\\n            String domainName = split[1];\\n            int index = localName.indexOf(\\'+\\');\\n            if(index >= 0)\\n                localName = localName.substring(0, index);\\n            String address = localName + \\'@\\' + domainName;\\n            map.put(address, map.getOrDefault(address, 0) + 1);\\n        }\\n        return map.keySet().size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String email : emails){\\n            String[] split = email.split(\"@\");\\n            String localName = split[0].replace(\".\", \"\");\\n            String domainName = split[1];\\n            int index = localName.indexOf(\\'+\\');\\n            if(index >= 0)\\n                localName = localName.substring(0, index);\\n            String address = localName + \\'@\\' + domainName;\\n            map.put(address, map.getOrDefault(address, 0) + 1);\\n        }\\n        return map.keySet().size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788940,
                "title": "100-t-c-easy-fast-short-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String s: emails){\\n            int indMail = s.indexOf(\\'@\\');\\n            StringBuilder sb = new StringBuilder();\\n            for(char c: s.toCharArray()){\\n                if (c == \\'@\\' || c == \\'+\\') break;\\n                if (c != \\'.\\') sb.append(c);\\n            }\\n            sb.append(s.substring(indMail));\\n            map.put(sb.toString(), 1);\\n        }\\n        return map.keySet().size();",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651452,
                "title": "java-easy-understanding-hashset",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> cnt=new LinkedHashSet<>();\\n        int index=0;\\n        for(String email:emails)\\n        {\\n            String arr[]=email.split(\"@\");\\n           index=arr[0].indexOf(\"+\");\\n                if(index>0)\\n            arr[0]=arr[0].substring(0,index);\\n            arr[0]=arr[0].replaceAll(\"\\\\\\\\.\",\"\");\\n            cnt.add(arr[0]+\"@\"+arr[1]);\\n            \\n        }\\n        return cnt.size();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> cnt=new LinkedHashSet<>();\\n        int index=0;\\n        for(String email:emails)\\n        {\\n            String arr[]=email.split(\"@\");\\n           index=arr[0].indexOf(\"+\");\\n                if(index>0)\\n            arr[0]=arr[0].substring(0,index);\\n            arr[0]=arr[0].replaceAll(\"\\\\\\\\.\",\"\");\\n            cnt.add(arr[0]+\"@\"+arr[1]);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2585532,
                "title": "js-simple-solution-with-hashmap",
                "content": "```\\nconst regex = /[.]+/g;\\nconst getLocalName = (name) => {\\n    name = name.split(\\'+\\')[0];\\n    name = name.replace(regex, \\'\\');\\n    return name;\\n};\\n\\nvar numUniqueEmails = function(emails) {\\n    const hashmap = new Map();\\n    let output = 0;\\n    \\n    for (let i = 0; i < emails.length; i++) {\\n        const email = emails[i];\\n        const [localName, domain] = email.split(\\'@\\');\\n        \\n        const baseEmail = `${getLocalName(localName)}@${domain}`;\\n        if (!hashmap.has(baseEmail)) {\\n            hashmap.set(baseEmail, 1);\\n            output++;\\n        }\\n    }\\n    \\n    return output;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst regex = /[.]+/g;\\nconst getLocalName = (name) => {\\n    name = name.split(\\'+\\')[0];\\n    name = name.replace(regex, \\'\\');\\n    return name;\\n};\\n\\nvar numUniqueEmails = function(emails) {\\n    const hashmap = new Map();\\n    let output = 0;\\n    \\n    for (let i = 0; i < emails.length; i++) {\\n        const email = emails[i];\\n        const [localName, domain] = email.split(\\'@\\');\\n        \\n        const baseEmail = `${getLocalName(localName)}@${domain}`;\\n        if (!hashmap.has(baseEmail)) {\\n            hashmap.set(baseEmail, 1);\\n            output++;\\n        }\\n    }\\n    \\n    return output;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2279660,
                "title": "10-lines-simple-python-solution-hashset-python-built-in-functions",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        unique = set()\\n        \\n        for e in emails:\\n            local,domain = e.split(\\'@\\')\\n            local = local.split(\\'+\\')[0]\\n            local = local.replace(\\'.\\',\"\")\\n            unique.add((local,domain))\\n        return len(unique)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        unique = set()\\n        \\n        for e in emails:\\n            local,domain = e.split(\\'@\\')\\n            local = local.split(\\'+\\')[0]\\n            local = local.replace(\\'.\\',\"\")\\n            unique.add((local,domain))\\n        return len(unique)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226436,
                "title": "my-c-solution-without-inbuilt-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> s;\\n        for(int i=0;i<emails.size();i++) {\\n            int j=0;\\n            string str=\"\";\\n            while(emails[i][j]!=\\'@\\') {\\n                if(emails[i][j]==\\'+\\')   break;\\n                if(emails[i][j]!=\\'.\\')    str+=emails[i][j];\\n                j++;\\n            }\\n            while(emails[i][j]!=\\'@\\')    j++;\\n            while(emails[i][j]) str+=emails[i][j++];\\n            s.insert(str);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> s;\\n        for(int i=0;i<emails.size();i++) {\\n            int j=0;\\n            string str=\"\";\\n            while(emails[i][j]!=\\'@\\') {\\n                if(emails[i][j]==\\'+\\')   break;\\n                if(emails[i][j]!=\\'.\\')    str+=emails[i][j];\\n                j++;\\n            }\\n            while(emails[i][j]!=\\'@\\')    j++;\\n            while(emails[i][j]) str+=emails[i][j++];\\n            s.insert(str);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971189,
                "title": "python-3-with-comment-explaination",
                "content": "```\\n\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        email_new = []\\n        for email in emails:\\n            #split local and domain\\n            email = email.split(\\'@\\')\\n            #remove \\'.\\' from local\\n            email[0] = email[0].replace(\\'.\\',\\'\\')\\n            #remove after \\'+\\'\\n            email[0] = email[0].split(\"+\")[0]\\n            #combine local and domain\\n            email_new.append(email[0] + \\'@\\' + email[1])\\n        return len(list(set(email_new)))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        email_new = []\\n        for email in emails:\\n            #split local and domain\\n            email = email.split(\\'@\\')\\n            #remove \\'.\\' from local\\n            email[0] = email[0].replace(\\'.\\',\\'\\')\\n            #remove after \\'+\\'\\n            email[0] = email[0].split(\"+\")[0]\\n            #combine local and domain\\n            email_new.append(email[0] + \\'@\\' + email[1])\\n        return len(list(set(email_new)))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946279,
                "title": "easy-python-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        m=set()\\n        for i in emails:\\n            if i.count(\".\")>0 and i.count(\"@\")>0:\\n                a,b=map(str,i.split(\"@\"))\\n                a=a.replace(\".\",\"\")\\n                # print(a,b)\\n                k=0\\n                for i in range(len(a)):\\n                    if a[i]!=\"+\":\\n                        k+=1\\n                    else:\\n                        break\\n                # print(a[:k],\"---\",b)\\n                m.add(a[:k]+\"@\"+b)\\n        return len(m)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        m=set()\\n        for i in emails:\\n            if i.count(\".\")>0 and i.count(\"@\")>0:\\n                a,b=map(str,i.split(\"@\"))\\n                a=a.replace(\".\",\"\")\\n                # print(a,b)\\n                k=0\\n                for i in range(len(a)):\\n                    if a[i]!=\"+\":\\n                        k+=1\\n                    else:\\n                        break\\n                # print(a[:k],\"---\",b)\\n                m.add(a[:k]+\"@\"+b)\\n        return len(m)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1779664,
                "title": "go-easy",
                "content": "```\\nfunc numUniqueEmails(emails []string) int {\\n    d := make(map[string]bool)\\n    \\n    for _, email := range emails {\\n        parts := strings.Split(email, \"@\")\\n        local := strings.Split(parts[0], \"+\")\\n        check := strings.Replace(local[0], \".\", \"\", -1) + \"@\" + parts[1]\\n        \\n        d[check] = true\\n    }\\n    \\n    return len(d)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numUniqueEmails(emails []string) int {\\n    d := make(map[string]bool)\\n    \\n    for _, email := range emails {\\n        parts := strings.Split(email, \"@\")\\n        local := strings.Split(parts[0], \"+\")\\n        check := strings.Replace(local[0], \".\", \"\", -1) + \"@\" + parts[1]\\n        \\n        d[check] = true\\n    }\\n    \\n    return len(d)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598520,
                "title": "c-very-easy-logic-with-explanation-simple-and-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string>us;\\n        for(int i = 0; i<emails.size(); i++){\\n            string s = \"\";\\n            for(int j = 0; j<emails[i].size();j++){\\n                //if we detect a @ then we will append everything behing @ to the newstring we are making to be inserted into the set\\n                if(emails[i][j] == \\'@\\'){\\n                    s.push_back(emails[i][j]);\\n                    string news(emails[i].begin()+j+1, emails[i].end());\\n                    s+=news;\\n                    break;\\n                }\\n                \\n                //if we detect a . (period) we are going todo nothing and just return to the for loop for next iteration\\n                else if(emails[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                //if we detect a + then we will increment the position of iterator iterating the string until it sees an @ character\\n                else if(emails[i][j] == \\'+\\'){\\n                    while(emails[i][j+1]!=\\'@\\'){\\n                        j++;\\n                    }\\n                    continue;\\n                }\\n                \\n                s.push_back(emails[i][j]);\\n            }\\n            //after construction of the whole string we will insert it into the set so as to eliminate the duplication\\n            us.insert(s);\\n        }\\n        \\n        return us.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string>us;\\n        for(int i = 0; i<emails.size(); i++){\\n            string s = \"\";\\n            for(int j = 0; j<emails[i].size();j++){\\n                //if we detect a @ then we will append everything behing @ to the newstring we are making to be inserted into the set\\n                if(emails[i][j] == \\'@\\'){\\n                    s.push_back(emails[i][j]);\\n                    string news(emails[i].begin()+j+1, emails[i].end());\\n                    s+=news;\\n                    break;\\n                }\\n                \\n                //if we detect a . (period) we are going todo nothing and just return to the for loop for next iteration\\n                else if(emails[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                //if we detect a + then we will increment the position of iterator iterating the string until it sees an @ character\\n                else if(emails[i][j] == \\'+\\'){\\n                    while(emails[i][j+1]!=\\'@\\'){\\n                        j++;\\n                    }\\n                    continue;\\n                }\\n                \\n                s.push_back(emails[i][j]);\\n            }\\n            //after construction of the whole string we will insert it into the set so as to eliminate the duplication\\n            us.insert(s);\\n        }\\n        \\n        return us.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493503,
                "title": "5-line-solution-in-python",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        for i, email in enumerate(emails):\\n            local_name, domain_name = email.split(\"@\")\\n            local_name = local_name.split(\"+\", 1)[0].replace(\".\", \"\")\\n            emails[i] = f\"{local_name}@{domain_name}\"\\n        return len(set(emails))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        for i, email in enumerate(emails):\\n            local_name, domain_name = email.split(\"@\")\\n            local_name = local_name.split(\"+\", 1)[0].replace(\".\", \"\")\\n            emails[i] = f\"{local_name}@{domain_name}\"\\n        return len(set(emails))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492496,
                "title": "unique-email-simple-java-solution",
                "content": "```\\nclass Solution {\\npublic int numUniqueEmails(String[] emails) {\\n    if(emails == null || emails.length == 0) {\\n        return -1;\\n    }\\n    Set set = new HashSet<>();\\n    for(String email : emails) {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: email.toCharArray()) {\\n            if (c == \\'.\\') continue;\\n            if (c == \\'+\\') break;\\n            if (c == \\'@\\') break; // this line need be added to make the older version work.\\n            sb.append(c);\\n        }\\n    String cur = (sb.toString() + email.substring(email.indexOf(\\'@\\'))).toLowerCase();\\n    set.add(cur);\\n    }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic int numUniqueEmails(String[] emails) {\\n    if(emails == null || emails.length == 0) {\\n        return -1;\\n    }\\n    Set set = new HashSet<>();\\n    for(String email : emails) {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: email.toCharArray()) {\\n            if (c == \\'.\\') continue;\\n            if (c == \\'+\\') break;\\n            if (c == \\'@\\') break; // this line need be added to make the older version work.\\n            sb.append(c);\\n        }\\n    String cur = (sb.toString() + email.substring(email.indexOf(\\'@\\'))).toLowerCase();\\n    set.add(cur);\\n    }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490672,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n   public int numUniqueEmails(String[] emails) {\\n       Set<String> result = new HashSet<>();\\n       for(String id:emails){\\n           String prt[]=id.split(\"@\");\\n           prt[0]=prt[0].replaceAll(\"\\\\\\\\.\",\"\");\\n           result.add(prt[0].split(\"\\\\\\\\+\")[0]+\"@\"+prt[1]);\\n       }\\n       return result.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int numUniqueEmails(String[] emails) {\\n       Set<String> result = new HashSet<>();\\n       for(String id:emails){\\n           String prt[]=id.split(\"@\");\\n           prt[0]=prt[0].replaceAll(\"\\\\\\\\.\",\"\");\\n           result.add(prt[0].split(\"\\\\\\\\+\")[0]+\"@\"+prt[1]);\\n       }\\n       return result.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489507,
                "title": "c-set",
                "content": "class Solution\\n{\\npublic:\\n\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        set<string> set;\\n        for (auto i : emails)\\n        {\\n            string str;\\n            for (char j : i)\\n            {\\n                if (j == \\'+\\' or j == \\'@\\')\\n                {\\n                    break;\\n                }\\n\\n                if (j == \\'.\\')\\n                {\\n                    continue;\\n                }\\n                str.push_back(j);\\n            }\\n            str.append(i.substr(i.find(\\'@\\')));\\n            set.insert(str);\\n        }\\n\\n        return set.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        set<string> set;\\n        for (auto i : emails)\\n        {\\n            string str;\\n            for (char j : i)\\n            {\\n                if (j == \\'+\\' or j == \\'@\\')\\n                {\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1488940,
                "title": "python-solution-one-line-regex",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set(map(lambda s: re.sub(\\'\\\\.(?=.*@)|\\\\+.*(?=@)\\', \\'\\', s), emails)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set(map(lambda s: re.sub(\\'\\\\.(?=.*@)|\\\\+.*(?=@)\\', \\'\\', s), emails)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488870,
                "title": "python-clean-smooth-with-a-hint-of-lemon-linear-pass-set-explained-o-nm",
                "content": "Please upvote if this has helped you! \\uD83C\\uDF4B\\n\\n```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        \"\"\"\\n            To solve this problem, we just need to loop through the emails and sanitize it as specified in the problem above.\\n            We can use a set to find out the number of unique emails after we have cleaned it up.\\n            \\n            Time: O(nm) - we iterate through n emails with worst case m chars. The m chars is from having to call split(), replace(), and index() will at worst case go through all m chars.\\n            Space: O(nm) - our set holds worst case all n strings with m chars if they are not unique.\\n        \"\"\"\\n        \\n        # Replace \\'.\\' with \\'\\'\\n        # Replace everything substring \\'+\\' and use a set\\n        email_set = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\')\\n            name = name.replace(\\'.\\', \\'\\')\\n            \\n            if \\'+\\' in name:\\n                name = name[:name.index(\\'+\\')]\\n                \\n            email_set.add(name + \\'@\\' + domain)\\n        \\n        return len(email_set)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        \"\"\"\\n            To solve this problem, we just need to loop through the emails and sanitize it as specified in the problem above.\\n            We can use a set to find out the number of unique emails after we have cleaned it up.\\n            \\n            Time: O(nm) - we iterate through n emails with worst case m chars. The m chars is from having to call split(), replace(), and index() will at worst case go through all m chars.\\n            Space: O(nm) - our set holds worst case all n strings with m chars if they are not unique.\\n        \"\"\"\\n        \\n        # Replace \\'.\\' with \\'\\'\\n        # Replace everything substring \\'+\\' and use a set\\n        email_set = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\')\\n            name = name.replace(\\'.\\', \\'\\')\\n            \\n            if \\'+\\' in name:\\n                name = name[:name.index(\\'+\\')]\\n                \\n            email_set.add(name + \\'@\\' + domain)\\n        \\n        return len(email_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488819,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string> &emails) \\n    {    \\n        int res = 0;  \\n        unordered_map <string, int> mp;\\n        \\n        for(int i=0; i<emails.size(); i++)\\n        {\\n            string temp = emails[i];\\n            string s = \"\";\\n            int x = 1;\\n            \\n            for(int j=0; temp[j]; j++)\\n            {\\n                if(temp[j] == \\'+\\')\\n                {\\n                    int k = j;\\n                    while(temp[k] != \\'@\\')\\n                        k++;\\n                    j = k;\\n                }\\n                \\n                if(temp[j] == \\'@\\')\\n                    x = 0;   \\n                if(temp[j] == \\'.\\' && x)\\n                    continue;\\n                \\n                s += temp[j];\\n            }\\n            \\n            if(mp[s])\\n                continue;\\n            \\n            mp[s]++;\\n            res++;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string> &emails) \\n    {    \\n        int res = 0;  \\n        unordered_map <string, int> mp;\\n        \\n        for(int i=0; i<emails.size(); i++)\\n        {\\n            string temp = emails[i];\\n            string s = \"\";\\n            int x = 1;\\n            \\n            for(int j=0; temp[j]; j++)\\n            {\\n                if(temp[j] == \\'+\\')\\n                {\\n                    int k = j;\\n                    while(temp[k] != \\'@\\')\\n                        k++;\\n                    j = k;\\n                }\\n                \\n                if(temp[j] == \\'@\\')\\n                    x = 0;   \\n                if(temp[j] == \\'.\\' && x)\\n                    continue;\\n                \\n                s += temp[j];\\n            }\\n            \\n            if(mp[s])\\n                continue;\\n            \\n            mp[s]++;\\n            res++;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466624,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& arr) {\\n        set<string> st; \\n        int n = arr.size();       \\n        for(int i=0;i<n;i++){\\n            string email = arr[i]; \\n            int pos = email.find(\\'@\\');\\n            string domain = email.substr(pos);\\n            string local = \"\";\\n            int j = 0;\\n            while(j < pos){\\n                if(email[j] == \\'.\\'){\\n                    j++;\\n                    continue;\\n                }else if(email[j] == \\'+\\')\\n                        break;\\n                    else\\n                        local += email[j];\\n                j++;\\n            }\\n            st.insert(local+domain);\\n        }\\n        return st.size();\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& arr) {\\n        set<string> st; \\n        int n = arr.size();       \\n        for(int i=0;i<n;i++){\\n            string email = arr[i]; \\n            int pos = email.find(\\'@\\');\\n            string domain = email.substr(pos);\\n            string local = \"\";\\n            int j = 0;\\n            while(j < pos){\\n                if(email[j] == \\'.\\'){\\n                    j++;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1387902,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> hs = new HashSet<>();\\n        \\n        for(String s : emails){\\n            int split = s.indexOf(\"@\");\\n            String local_name = s.substring(0, split);\\n            String domain_name = s.substring(split);\\n            \\n            if(local_name.contains(\"+\")){\\n                int plus = local_name.indexOf(\"+\");\\n                local_name = local_name.substring(0, plus);\\n            }\\n            \\n            local_name = local_name.replaceAll(\"\\\\\\\\.\",\"\");\\n            String email = local_name + domain_name;\\n            hs.add(email);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> hs = new HashSet<>();\\n        \\n        for(String s : emails){\\n            int split = s.indexOf(\"@\");\\n            String local_name = s.substring(0, split);\\n            String domain_name = s.substring(split);\\n            \\n            if(local_name.contains(\"+\")){\\n                int plus = local_name.indexOf(\"+\");\\n                local_name = local_name.substring(0, plus);\\n            }\\n            \\n            local_name = local_name.replaceAll(\"\\\\\\\\.\",\"\");\\n            String email = local_name + domain_name;\\n            hs.add(email);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359475,
                "title": "c-simple-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    string filter(string &s) {\\n        string str = \"\";\\n        int n = s.length();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'.\\') continue;\\n            if(s[i] == \\'+\\' || s[i] == \\'@\\') break;\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> st;\\n\\n        for(string &email : emails) {\\n            string domain = email.substr(email.find(\\'@\\'));\\n            email = filter(email);\\n            st.insert(email+domain);\\n        }\\n        \\n        return (int)st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string filter(string &s) {\\n        string str = \"\";\\n        int n = s.length();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'.\\') continue;\\n            if(s[i] == \\'+\\' || s[i] == \\'@\\') break;\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> st;\\n\\n        for(string &email : emails) {\\n            string domain = email.substr(email.find(\\'@\\'));\\n            email = filter(email);\\n            st.insert(email+domain);\\n        }\\n        \\n        return (int)st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205452,
                "title": "simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set=new HashSet<>();\\n        \\n        for(String email:emails){\\n            //tmp[0]->local name\\n            //tmp[1]->domain name\\n            String[] tmp=email.split(\"@\");\\n            //Splitting local by \\'+\\'\\n            String[] local=tmp[0].split(\"\\\\\\\\+\");\\n            //Adding the email\\n            set.add(local[0].replace(\".\",\"\")+\"@\"+tmp[1]);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set=new HashSet<>();\\n        \\n        for(String email:emails){\\n            //tmp[0]->local name\\n            //tmp[1]->domain name\\n            String[] tmp=email.split(\"@\");\\n            //Splitting local by \\'+\\'\\n            String[] local=tmp[0].split(\"\\\\\\\\+\");\\n            //Adding the email\\n            set.add(local[0].replace(\".\",\"\")+\"@\"+tmp[1]);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194322,
                "title": "python-97-85-4-lines-and-1-line-solutions",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        for index in range(len(emails)):\\n            left, right = emails[index].split(\\'@\\')\\n            emails[index] = left.replace(\\'.\\', \\'\\').split(\\'+\\')[0] + \\'@\\' + right\\n        return len(set(emails))\\n```\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set([email.split(\\'@\\')[0].replace(\\'.\\', \\'\\').split(\\'+\\')[0] + \\'@\\' + email.split(\\'@\\')[1] for email in emails]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        for index in range(len(emails)):\\n            left, right = emails[index].split(\\'@\\')\\n            emails[index] = left.replace(\\'.\\', \\'\\').split(\\'+\\')[0] + \\'@\\' + right\\n        return len(set(emails))\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set([email.split(\\'@\\')[0].replace(\\'.\\', \\'\\').split(\\'+\\')[0] + \\'@\\' + email.split(\\'@\\')[1] for email in emails]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047458,
                "title": "python3-simple-solution-using-set",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        s = set()\\n        for i in emails:\\n            a, b = i.split(\\'@\\')\\n            if \\'+\\' in a:\\n                a = a[:a.index(\\'+\\')]\\n            s.add(a.replace(\\'.\\',\\'\\') + \\'@\\' + b)\\n        return len(s)\\n```\\nIf you like the solution, please vote for this.",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        s = set()\\n        for i in emails:\\n            a, b = i.split(\\'@\\')\\n            if \\'+\\' in a:\\n                a = a[:a.index(\\'+\\')]\\n            s.add(a.replace(\\'.\\',\\'\\') + \\'@\\' + b)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965851,
                "title": "c-easy-logic",
                "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> se;\\n        for(auto x:emails)\\n        {\\n            int pos=x.find(\\'@\\');\\n            string ss1=x.substr(0,pos);\\n            string ss2=x.substr(pos);\\n            if(ss1.find(\\'+\\')<ss1.length())\\n            {\\n                int pos2=ss1.find(\\'+\\');\\n                ss1=ss1.substr(0,pos2);\\n            }\\n            while(ss1.find(\\'.\\')<ss1.length())\\n            {\\n                int pos3=ss1.find(\\'.\\');\\n                ss1=ss1.substr(0,pos3)+ss1.substr(pos3+1);\\n            }\\n            se.insert(ss1+ss2);\\n        }\\n        return se.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> se;\\n        for(auto x:emails)\\n        {\\n            int pos=x.find(\\'@\\');\\n            string ss1=x.substr(0,pos);\\n            string ss2=x.substr(pos);\\n            if(ss1.find(\\'+\\')<ss1.length())\\n            {\\n                int pos2=ss1.find(\\'+\\');\\n                ss1=ss1.substr(0,pos2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 958851,
                "title": "kotlin",
                "content": "```\\nfun numUniqueEmails(emails: Array<String>): Int = emails.map {\\n        val splitEmail = it.split(\"@\")\\n        val local = splitEmail[0].replaceAfter(\"+\",\"\").replace(\"+\",\"\").replace(\".\",\"\")\\n        \"$local@${splitEmail[1]}\"\\n    }.distinct().size\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun numUniqueEmails(emails: Array<String>): Int = emails.map {\\n        val splitEmail = it.split(\"@\")\\n        val local = splitEmail[0].replaceAfter(\"+\",\"\").replace(\"+\",\"\").replace(\".\",\"\")\\n        \"$local@${splitEmail[1]}\"\\n    }.distinct().size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946370,
                "title": "c-program-addresssanitizer-deadlysignal-can-someone-help-me-fix-please",
                "content": "\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n==31==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x56362d89749c bp 0x7ffca6c3acd0 sp 0x7ffca6c3ac30 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: address points to the zero page.\\n    #2 0x7f2915e360b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n```\\n\\nint atsymbol(char* array);\\nint numUniqueEmails(char ** emails, int emailsSize){\\n    char** returnarray = malloc(sizeof(char) * emailsSize * 100); \\n    int k = 0;\\n    for (int i = 0; i < 100; i++){ //for each email address\\n        int atsym = atsymbol(emails[i]);\\n        for (int j = 0; j < 100; j++){ //for each character in email address\\n            \\n           int l = 0;\\n            if (emails[i][j] == \\'+\\'){\\n             for (; l < j; l++){\\n               returnarray[k][l] = emails[i][l];\\n             }\\n             for (int p = atsym; emails[i][p] != \\'\\\\0\\'; p++){\\n               returnarray[k][l] = emails[i][p]; \\n                 l++;\\n             }\\n          }\\n           if (emails[i][j] == \\'.\\'){\\n             for (int l = 0; l < j; l++){\\n               returnarray[k][l] = emails[i][l];\\n             }\\n             for (int l = j; l < 100; l++){\\n               if (emails[i][l] == \\'+\\'){\\n                 l = atsymbol + 1; \\n               }\\n               else{\\n                 returnarray[k][l] = emails[i][j];\\n               }\\n             }\\n           }\\n            \\n        }\\n        k++;\\n    }\\n    return k;\\n}\\n\\nint atsymbol(char* array) {\\n    int j = 0;  \\n    for (; j < 100; j++){ //determines where the @ symbol occurs in the email address\\n        if (array[j] == \\'@\\'){\\n          break;\\n    }\\n      }\\n    return j;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint atsymbol(char* array);\\nint numUniqueEmails(char ** emails, int emailsSize){\\n    char** returnarray = malloc(sizeof(char) * emailsSize * 100); \\n    int k = 0;\\n    for (int i = 0; i < 100; i++){ //for each email address\\n        int atsym = atsymbol(emails[i]);\\n        for (int j = 0; j < 100; j++){ //for each character in email address\\n            \\n           int l = 0;\\n            if (emails[i][j] == \\'+\\'){\\n             for (; l < j; l++){\\n               returnarray[k][l] = emails[i][l];\\n             }\\n             for (int p = atsym; emails[i][p] != \\'\\\\0\\'; p++){\\n               returnarray[k][l] = emails[i][p]; \\n                 l++;\\n             }\\n          }\\n           if (emails[i][j] == \\'.\\'){\\n             for (int l = 0; l < j; l++){\\n               returnarray[k][l] = emails[i][l];\\n             }\\n             for (int l = j; l < 100; l++){\\n               if (emails[i][l] == \\'+\\'){\\n                 l = atsymbol + 1; \\n               }\\n               else{\\n                 returnarray[k][l] = emails[i][j];\\n               }\\n             }\\n           }\\n            \\n        }\\n        k++;\\n    }\\n    return k;\\n}\\n\\nint atsymbol(char* array) {\\n    int j = 0;  \\n    for (; j < 100; j++){ //determines where the @ symbol occurs in the email address\\n        if (array[j] == \\'@\\'){\\n          break;\\n    }\\n      }\\n    return j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916472,
                "title": "python-3-beats-98-21-and-100-in-memory",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        eqmail = \"\"\\n        res = []\\n        for email in emails:\\n            eqmail = email.split(\"@\")[0].split(\"+\")[0]\\n            eqmail = \"\".join(eqmail.split(\".\"))\\n            res.append(eqmail + \"@\" + email.split(\"@\")[1])\\n        return len(set(res))\\n\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        eqmail = \"\"\\n        res = []\\n        for email in emails:\\n            eqmail = email.split(\"@\")[0].split(\"+\")[0]\\n            eqmail = \"\".join(eqmail.split(\".\"))\\n            res.append(eqmail + \"@\" + email.split(\"@\")[1])\\n        return len(set(res))\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 806971,
                "title": "clean-python-set-algorithm",
                "content": "**Clean Python | Set Algorithm**\\n\\nEasy Python solution showcasing the use of a beautiful syntax to store all known (unique) email addresses. Enjoy :)\\n\\nPS. The present solution is optimized to avoid unnecessary string concatenation operations. The official LeetCode solution could have avoided the final email reconstruction operation.\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, A):\\n        D = set()\\n        for x in A:\\n            a,b = x.split(\\'@\\')\\n            a   = a.split(\\'+\\')[0]\\n            a   = a.replace(\\'.\\',\\'\\')\\n            D.add( (a,b) )\\n        return len(D)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, A):\\n        D = set()\\n        for x in A:\\n            a,b = x.split(\\'@\\')\\n            a   = a.split(\\'+\\')[0]\\n            a   = a.replace(\\'.\\',\\'\\')\\n            D.add( (a,b) )\\n        return len(D)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802553,
                "title": "c-beating-97",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> hashset;\\n        for(int j=0;j<emails.size();j++){\\n            int start=INT_MAX, end=0;\\n            for(int k=0;k<emails[j].size();k++){\\n                if(emails[j][k]==\\'+\\'){\\n                    start=min(k,start);\\n                }\\n                if(emails[j][k]==\\'@\\'){\\n                    end=k;\\n                    break;\\n                }\\n            }\\n            if(start!=INT_MAX) emails[j].erase(emails[j].begin()+start,emails[j].begin()+end);\\n            for(int i=0;i<emails[j].size();i++){\\n                if(emails[j][i]==\\'@\\') break;\\n                if(emails[j][i]==\\'.\\'){\\n                    emails[j].erase(emails[j].begin()+i);\\n                }\\n            }\\n            hashset.insert(emails[j]);\\n        }\\n        return hashset.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> hashset;\\n        for(int j=0;j<emails.size();j++){\\n            int start=INT_MAX, end=0;\\n            for(int k=0;k<emails[j].size();k++){\\n                if(emails[j][k]==\\'+\\'){\\n                    start=min(k,start);\\n                }\\n                if(emails[j][k]==\\'@\\'){\\n                    end=k;\\n                    break;\\n                }\\n            }\\n            if(start!=INT_MAX) emails[j].erase(emails[j].begin()+start,emails[j].begin()+end);\\n            for(int i=0;i<emails[j].size();i++){\\n                if(emails[j][i]==\\'@\\') break;\\n                if(emails[j][i]==\\'.\\'){\\n                    emails[j].erase(emails[j].begin()+i);\\n                }\\n            }\\n            hashset.insert(emails[j]);\\n        }\\n        return hashset.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697631,
                "title": "python3-easy",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for e in emails:\\n            local,domain = e.split(\\'@\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            seen.add(local.replace(\\'.\\',\\'\\')+\\'@\\'+domain)\\n        return len(seen)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for e in emails:\\n            local,domain = e.split(\\'@\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            seen.add(local.replace(\\'.\\',\\'\\')+\\'@\\'+domain)\\n        return len(seen)",
                "codeTag": "Java"
            },
            {
                "id": 539508,
                "title": "java-solution-from-easy-to-understand-to-concise",
                "content": "Straight forward [6ms]. Beat 96%\\n\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : emails) set.add(refine(s));\\n        return set.size();\\n    }\\n\\n    public String refine(String s) {\\n        String[] arr = s.split(\"@\");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < arr[0].length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'+\\') break;\\n            if (c != \\'.\\') sb.append(c);\\n        }\\n        sb.append(\"@\").append(arr[1]);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nShorter solution [22ms]. Beat 40%\\n\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : emails) {\\n            StringBuilder sb = new StringBuilder();\\n            String[] parts = s.split(\"@\");\\n            String local = parts[0].split(\"\\\\\\\\+\")[0].replaceAll(\"\\\\\\\\.\", \"\");\\n            sb.append(local).append(\"@\").append(parts[1]);\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : emails) set.add(refine(s));\\n        return set.size();\\n    }\\n\\n    public String refine(String s) {\\n        String[] arr = s.split(\"@\");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < arr[0].length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'+\\') break;\\n            if (c != \\'.\\') sb.append(c);\\n        }\\n        sb.append(\"@\").append(arr[1]);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : emails) {\\n            StringBuilder sb = new StringBuilder();\\n            String[] parts = s.split(\"@\");\\n            String local = parts[0].split(\"\\\\\\\\+\")[0].replaceAll(\"\\\\\\\\.\", \"\");\\n            sb.append(local).append(\"@\").append(parts[1]);\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485611,
                "title": "easy-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int NumUniqueEmails(string[] emails)\\n        {\\n            ISet<string> res = new HashSet<string>();\\n            foreach (var email in emails)\\n            {\\n                var split = email.Split(new char[] {\\'@\\'}, StringSplitOptions.RemoveEmptyEntries);\\n                int plus = split[0].IndexOf(\\'+\\');\\n                if (plus >= 0)\\n                {\\n                    split[0] = split[0].Substring(0, plus);\\n                }\\n                split[0] = split[0].Replace(\".\", \"\");\\n                res.Add($\"{split[0]}@{split[1]}\");\\n            }\\n            return res.Count;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int NumUniqueEmails(string[] emails)\\n        {\\n            ISet<string> res = new HashSet<string>();\\n            foreach (var email in emails)\\n            {\\n                var split = email.Split(new char[] {\\'@\\'}, StringSplitOptions.RemoveEmptyEntries);\\n                int plus = split[0].IndexOf(\\'+\\');\\n                if (plus >= 0)\\n                {\\n                    split[0] = split[0].Substring(0, plus);\\n                }\\n                split[0] = split[0].Replace(\".\", \"\");\\n                res.Add($\"{split[0]}@{split[1]}\");\\n            }\\n            return res.Count;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481998,
                "title": "javascript-clean-code-beats-81",
                "content": "```javascript\\nconst numUniqueEmails = (emails) => {\\n\\t// validate\\n\\tif(emails === null || emails.length === 0) return 0;\\n\\n\\tconst emailSet = new Set();\\n\\tlet emailCount = 0;\\n\\n\\t// iterate 1 email at a time\\n\\temails.forEach(email => {\\t\\n        // parse and filter to get cleaned up address\\n        const parsed = parseEmail(email);\\n\\n        // verify if already in hash\\n        if(!emailSet.has(parsed)) {\\n            // if not, update\\n            emailSet.add(parsed);\\n            emailCount += 1\\n        }\\n    });\\n\\n\\t// return count\\n\\treturn emailCount;\\n};\\n\\nconst parseEmail = (email) => {\\n\\tlet result = \\'\\';\\n\\tlet afterAt = false;\\n\\tlet hasPlus = false;\\n\\tfor(char of email) {\\n        if(!afterAt) {\\n\\t        if(char === \\'@\\') { \\n                afterAt = true;\\n            } else if (char === \\'+\\') {\\n\\t            hasPlus = true;\\n\\t            continue;\\n            } else if (char === \\'.\\' || hasPlus) {\\n                continue;\\n            }\\n        }\\n\\n        result = `${result}${char}`;\\n    }\\n\\n\\treturn result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst numUniqueEmails = (emails) => {\\n\\t// validate\\n\\tif(emails === null || emails.length === 0) return 0;\\n\\n\\tconst emailSet = new Set();\\n\\tlet emailCount = 0;\\n\\n\\t// iterate 1 email at a time\\n\\temails.forEach(email => {\\t\\n        // parse and filter to get cleaned up address\\n        const parsed = parseEmail(email);\\n\\n        // verify if already in hash\\n        if(!emailSet.has(parsed)) {\\n            // if not, update\\n            emailSet.add(parsed);\\n            emailCount += 1\\n        }\\n    });\\n\\n\\t// return count\\n\\treturn emailCount;\\n};\\n\\nconst parseEmail = (email) => {\\n\\tlet result = \\'\\';\\n\\tlet afterAt = false;\\n\\tlet hasPlus = false;\\n\\tfor(char of email) {\\n        if(!afterAt) {\\n\\t        if(char === \\'@\\') { \\n                afterAt = true;\\n            } else if (char === \\'+\\') {\\n\\t            hasPlus = true;\\n\\t            continue;\\n            } else if (char === \\'.\\' || hasPlus) {\\n                continue;\\n            }\\n        }\\n\\n        result = `${result}${char}`;\\n    }\\n\\n\\treturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458125,
                "title": "java-solution",
                "content": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tHashSet<String> set = new HashSet<String>();\\n\\n\\tfor (String email : emails) {\\n\\t\\tString[] parts = email.split(\"@\");\\n\\t\\tString local = parts[0];\\n\\t\\tString domain = parts[1];\\n\\n\\t\\tlocal = local.replace(\".\", \"\");\\n\\t\\tint plusIndex = local.indexOf(\"+\");\\n\\t\\tif (plusIndex > 0) {\\n\\t\\t\\tlocal = local.substring(0, plusIndex);\\n\\t\\t}\\n\\n\\t\\tString result = local + \"@\" + domain;\\n\\t\\tset.add(result);\\n\\t}\\n\\n\\treturn set.size();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tHashSet<String> set = new HashSet<String>();\\n\\n\\tfor (String email : emails) {\\n\\t\\tString[] parts = email.split(\"@\");\\n\\t\\tString local = parts[0];\\n\\t\\tString domain = parts[1];\\n\\n\\t\\tlocal = local.replace(\".\", \"\");\\n\\t\\tint plusIndex = local.indexOf(\"+\");\\n\\t\\tif (plusIndex > 0) {\\n\\t\\t\\tlocal = local.substring(0, plusIndex);\\n\\t\\t}\\n\\n\\t\\tString result = local + \"@\" + domain;\\n\\t\\tset.add(result);\\n\\t}\\n\\n\\treturn set.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451688,
                "title": "ruby-readable-solution-faster-than-82-42-less-memory-than-100",
                "content": "<img src=\"https://assets.leetcode.com/users/ayacai115/image_1576373869.png\" width=500>\\n\\n```rb\\ndef num_unique_emails(emails)\\n    hash = emails.group_by do |email|\\n      local, domain = email.split(\\'@\\')\\n      local = local.delete(\\'.\\').split(\\'+\\').first\\n\\n      \"#{local}@#{domain}\"\\n    end\\n\\n    hash.keys.count\\nend\\n```",
                "solutionTags": [],
                "code": "```rb\\ndef num_unique_emails(emails)\\n    hash = emails.group_by do |email|\\n      local, domain = email.split(\\'@\\')\\n      local = local.delete(\\'.\\').split(\\'+\\').first\\n\\n      \"#{local}@#{domain}\"\\n    end\\n\\n    hash.keys.count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 410881,
                "title": "java-simple-7-line-solution",
                "content": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tHashSet<String> hs = new HashSet<>();\\n\\tfor(String e:emails) {\\n\\t\\tString[] pieces = e.split(\"@\");\\n\\t\\tString name = pieces[0].split(\"\\\\\\\\+\",2)[0], domain = pieces[1];\\n\\t\\tname = name.replace(\".\",\"\");\\n\\t\\ths.add(name+\"@\"+domain);\\n\\t}\\n\\treturn hs.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tHashSet<String> hs = new HashSet<>();\\n\\tfor(String e:emails) {\\n\\t\\tString[] pieces = e.split(\"@\");\\n\\t\\tString name = pieces[0].split(\"\\\\\\\\+\",2)[0], domain = pieces[1];\\n\\t\\tname = name.replace(\".\",\"\");\\n\\t\\ths.add(name+\"@\"+domain);\\n\\t}\\n\\treturn hs.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340694,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution(object):\\n    def rewriteEmail(self, email):\\n        localName, domainName = email.split(\\'@\\')\\n        plusIndex = localName.find(\\'+\\')\\n        if plusIndex != -1:\\n            localName = localName[:plusIndex]\\n        localName = localName.replace(\\'.\\', \\'\\')\\n        return localName + \\'@\\' + domainName\\n        \\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueEmails = set()\\n        for email in emails:\\n            uniqueEmails.add(self.rewriteEmail(email))\\n        return len(uniqueEmails)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rewriteEmail(self, email):\\n        localName, domainName = email.split(\\'@\\')\\n        plusIndex = localName.find(\\'+\\')\\n        if plusIndex != -1:\\n            localName = localName[:plusIndex]\\n        localName = localName.replace(\\'.\\', \\'\\')\\n        return localName + \\'@\\' + domainName\\n        \\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueEmails = set()\\n        for email in emails:\\n            uniqueEmails.add(self.rewriteEmail(email))\\n        return len(uniqueEmails)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315878,
                "title": "java-5ms-99-32-one-pass",
                "content": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor (String s:\\n\\t\\t emails) {\\n\\t\\tint mid = s.indexOf(\\'@\\');\\n\\t\\tset.add(local(s.substring(0, mid)) + s.substring(mid));\\n\\t}\\n\\treturn set.size();\\n}\\n\\nprivate String local(String s) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tchar ch = s.charAt(i);\\n\\t\\tif (ch == \\'+\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (ch != \\'.\\') {\\n\\t\\t\\tsb.append(ch);\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\\n\\nUsing a hashset to store and do identity validation.",
                "solutionTags": [],
                "code": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor (String s:\\n\\t\\t emails) {\\n\\t\\tint mid = s.indexOf(\\'@\\');\\n\\t\\tset.add(local(s.substring(0, mid)) + s.substring(mid));\\n\\t}\\n\\treturn set.size();\\n}\\n\\nprivate String local(String s) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tchar ch = s.charAt(i);\\n\\t\\tif (ch == \\'+\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (ch != \\'.\\') {\\n\\t\\t\\tsb.append(ch);\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 305311,
                "title": "python-32ms-and-94-faster",
                "content": "```class Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        count = 0\\n        for email in emails:\\n            l, domain = email.split(\"@\")\\n            l = l.split(\\'+\\')[0]\\n            l = l.replace(\\'.\\',\\'\\')\\n            e = l + \\'@\\' + domain\\n            if e not in d:\\n                d[e] = 1\\n                count+=1\\n            else:\\n                continue\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        count = 0\\n        for email in emails:\\n            l, domain = email.split(\"@\")\\n            l = l.split(\\'+\\')[0]\\n            l = l.replace(\\'.\\',\\'\\')\\n            e = l + \\'@\\' + domain\\n            if e not in d:\\n                d[e] = 1\\n                count+=1\\n            else:\\n                continue\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293367,
                "title": "javascript-regexp-set-solution",
                "content": "```js\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    const set = new Set();\\n    \\n    for (let email of emails) {\\n        const [local, domain] = email.split(\\'@\\');\\n        set.add(\\n          `${local.replace(/\\\\+.*$|\\\\./g, \\'\\')}@${domain}`\\n        );\\n    }\\n    \\n    return set.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```js\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    const set = new Set();\\n    \\n    for (let email of emails) {\\n        const [local, domain] = email.split(\\'@\\');\\n        set.add(\\n          `${local.replace(/\\\\+.*$|\\\\./g, \\'\\')}@${domain}`\\n        );\\n    }\\n    \\n    return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258990,
                "title": "one-line-python-solution",
                "content": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set([x.split(\\'@\\')[0].split(\\'+\\')[0].replace(\\'.\\',\\'\\')+x.split(\\'@\\')[1] for x in emails]))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set([x.split(\\'@\\')[0].split(\\'+\\')[0].replace(\\'.\\',\\'\\')+x.split(\\'@\\')[1] for x in emails]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251508,
                "title": "readable-swift-4-solution",
                "content": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        \\n        var  s = Set<String>()\\n        \\n        for e in emails {\\n            let seperated = e.split(separator: \"@\")\\n            let local = seperated[0]\\n            let domain = seperated[1]\\n            var modifiedLocal = \"\"\\n            \\n            innerLoop: for c in local {    \\n               if c == \"+\" {\\n                   break innerLoop\\n               }\\n               if c != \".\" {\\n                   modifiedLocal += [c]\\n               }\\n            }\\n            \\n            let formatted  = modifiedLocal + \"@\" +  domain\\n            s.insert(formatted)\\n        }\\n        \\n        return s.count\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        \\n        var  s = Set<String>()\\n        \\n        for e in emails {\\n            let seperated = e.split(separator: \"@\")\\n            let local = seperated[0]\\n            let domain = seperated[1]\\n            var modifiedLocal = \"\"\\n            \\n            innerLoop: for c in local {    \\n               if c == \"+\" {\\n                   break innerLoop\\n               }\\n               if c != \".\" {\\n                   modifiedLocal += [c]\\n               }\\n            }\\n            \\n            let formatted  = modifiedLocal + \"@\" +  domain\\n            s.insert(formatted)\\n        }\\n        \\n        return s.count\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246806,
                "title": "javascript-solution",
                "content": "```\\nvar numUniqueEmails = function(emails) {\\n    const uniqueAddress = new Set();\\n    \\n    emails.forEach(email => {\\n        const splitEmail = email.split(\"@\");\\n        let addr = splitEmail[0];\\n        const domain = splitEmail[1];\\n        \\n        //everything before the first +\\n        addr = addr.split(\"+\")[0]\\n        \\n        //remove .\\n        addr = addr.replace(/[.]/g, \\'\\')\\n        uniqueAddress.add(addr+\"@\"+domain);\\n    })\\n    \\n    return uniqueAddress.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numUniqueEmails = function(emails) {\\n    const uniqueAddress = new Set();\\n    \\n    emails.forEach(email => {\\n        const splitEmail = email.split(\"@\");\\n        let addr = splitEmail[0];\\n        const domain = splitEmail[1];\\n        \\n        //everything before the first +\\n        addr = addr.split(\"+\")[0]\\n        \\n        //remove .\\n        addr = addr.replace(/[.]/g, \\'\\')\\n        uniqueAddress.add(addr+\"@\"+domain);\\n    })\\n    \\n    return uniqueAddress.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240924,
                "title": "java-ac-3-liner-with-explanation",
                "content": "\\t// how many different addresses actually receive mails\\n\\t// \\'.\\' and everything after \\'+\\' are only ignored if before \\'@\\'\\n\\t// parts[0]: local name, parts[1] = domain name \\n```\\n    public static int numUniqueEmails(String[] emails) {\\n    \\t\\tSet<String> unique_emails = new HashSet<>();\\n    \\t\\tfor (String email : emails) {unique_emails.add(email.split(\"\\\\\\\\@\")[0].replace(\".\", \"\").split(\"\\\\\\\\+\")[0] + email.split(\"\\\\\\\\@\")[1]);}\\n    \\t\\treturn unique_emails.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int numUniqueEmails(String[] emails) {\\n    \\t\\tSet<String> unique_emails = new HashSet<>();\\n    \\t\\tfor (String email : emails) {unique_emails.add(email.split(\"\\\\\\\\@\")[0].replace(\".\", \"\").split(\"\\\\\\\\+\")[0] + email.split(\"\\\\\\\\@\")[1]);}\\n    \\t\\treturn unique_emails.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 239285,
                "title": "c-beats-82-using-unordered-set",
                "content": "\\'\\'\\'\\nclass Solution \\n{\\npublic:\\n    int numUniqueEmails(vector<string>& emails) \\n    {\\n        int len=emails.size();\\n        unordered_set<string>newemail;\\n        string delimiter1=\"+\";\\n        string delimiter2=\"@\";\\n        if(len==0||len==1)\\n            return len;\\n        for(int i=0;i<len;i++)\\n        {\\n            string a =emails[i].substr(0, emails[i].find(delimiter1));\\n            a.erase(remove(a.begin(), a.end(), \\'.\\'), a.end());\\n            string b=emails[i].substr(emails[i].find(delimiter2),emails[i].length()-1 );\\n            // string c=a+b;\\n            // cout<<a+b<<\" \\\\n\";\\n            // cout<<c<<\" \";\\n            newemail.insert(a+b);\\n        }\\n        return newemail.size();\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n{\\npublic:\\n    int numUniqueEmails(vector<string>& emails) \\n    {\\n        int len=emails.size();\\n        unordered_set<string>newemail;\\n        string delimiter1=\"+\";\\n        string delimiter2=\"@\";\\n        if(len==0||len==1)\\n            return len;\\n        for(int i=0;i<len;i++)\\n        {\\n            string a =emails[i].substr(0, emails[i].find(delimiter1));\\n            a.erase(remove(a.begin(), a.end(), \\'.\\'), a.end());\\n            string b=emails[i].substr(emails[i].find(delimiter2),emails[i].length()-1 );\\n            // string c=a+b;\\n            // cout<<a+b<<\" \\\\n\";\\n            // cout<<c<<\" \";\\n            newemail.insert(a+b);\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 237880,
                "title": "optimized-further-python-3",
                "content": "```\\ndef numUniqueEmails(self, emails: \\'List[str]\\') -> \\'int\\':\\n        d = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\')\\n            name = name.split(\\'+\\')[0]\\n            name = name.replace(\\'.\\',\\'\\')\\n            email_id = name+\\'@\\'+domain\\n            # replace list d by set for efficiency and removing redundancy\\n            d.add(email_id)\\n            \\n        # print(d)\\n        return len(d)\\n                              \\n                              ```",
                "solutionTags": [],
                "code": "```\\ndef numUniqueEmails(self, emails: \\'List[str]\\') -> \\'int\\':\\n        d = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\')\\n            name = name.split(\\'+\\')[0]\\n            name = name.replace(\\'.\\',\\'\\')\\n            email_id = name+\\'@\\'+domain\\n            # replace list d by set for efficiency and removing redundancy\\n            d.add(email_id)\\n            \\n        # print(d)\\n        return len(d)\\n                              \\n                              ```",
                "codeTag": "Python3"
            },
            {
                "id": 232506,
                "title": "readable-fast-python3-99-3-speed",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: \\'List[str]\\') -> \\'int\\':\\n        li = []\\n        for email in emails:\\n            domain = email[email.index(\\'@\\'):]\\n            local = email[:email.index(\\'@\\')]\\n            \\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            if \\'.\\' in local:\\n                local = local.replace(\\'.\\', \\'\\')\\n\\n            final = local + domain\\n            if final in li:\\n                continue\\n            else:\\n                li.append(final)\\n        return len(li)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: \\'List[str]\\') -> \\'int\\':\\n        li = []\\n        for email in emails:\\n            domain = email[email.index(\\'@\\'):]\\n            local = email[:email.index(\\'@\\')]\\n            \\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            if \\'.\\' in local:\\n                local = local.replace(\\'.\\', \\'\\')\\n\\n            final = local + domain\\n            if final in li:\\n                continue\\n            else:\\n                li.append(final)\\n        return len(li)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231520,
                "title": "97-23-c-simple-parser",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> uniqueEmails;\\n        for (auto email : emails) {\\n            string finalEmail;\\n            bool localName = true;\\n            bool skip = false;\\n            for (char c : email) {\\n                if (c == \\'@\\') {\\n                    localName = false;\\n                    continue;\\n                }\\n                \\n                if (localName && skip) {\\n                    continue;\\n                }\\n                \\n                if (localName && c == \\'.\\') {\\n                    continue;\\n                }\\n                \\n                if (localName && c == \\'+\\') {\\n                    skip = true;\\n                    continue;\\n                }\\n                \\n                finalEmail += c;\\n            }\\n            \\n            uniqueEmails.insert(finalEmail);\\n        }\\n        \\n        return uniqueEmails.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> uniqueEmails;\\n        for (auto email : emails) {\\n            string finalEmail;\\n            bool localName = true;\\n            bool skip = false;\\n            for (char c : email) {\\n                if (c == \\'@\\') {\\n                    localName = false;\\n                    continue;\\n                }\\n                \\n                if (localName && skip) {\\n                    continue;\\n                }\\n                \\n                if (localName && c == \\'.\\') {\\n                    continue;\\n                }\\n                \\n                if (localName && c == \\'+\\') {\\n                    skip = true;\\n                    continue;\\n                }\\n                \\n                finalEmail += c;\\n            }\\n            \\n            uniqueEmails.insert(finalEmail);\\n        }\\n        \\n        return uniqueEmails.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220357,
                "title": "easy-python-6-lines",
                "content": "```py\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        s = set()\\n        for email in emails:\\n            prefix, suffix = email.split(\\'@\\')\\n            prefix = prefix.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            s.add((prefix, suffix))\\n        \\n        return len(s)\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        s = set()\\n        for email in emails:\\n            prefix, suffix = email.split(\\'@\\')\\n            prefix = prefix.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            s.add((prefix, suffix))\\n        \\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203379,
                "title": "c-20-ms-stl-no-useless-copying-short-and-efficient-code-annotated",
                "content": "```\\nclass Solution {\\npublic:\\n  int numUniqueEmails(std::vector<std::string>& emails) {             // take a note: it is not \\'const\\' ;)\\n    if(emails.empty())\\n      return {};\\n\\n    std::unordered_set<std::string> uniques;\\n    for(auto& email : emails)\\n    {\\n      auto at   = std::find(std::begin(email), std::end(email), \\'@\\'); // task guaranteed that there will be one \\'@\\'\\n\\t  auto plus = std::find(std::begin(email), at, \\'+\\');              // search for the first \\'+\\' in range [begin, \\'@\\')\\n\\n      email.erase(std::remove(std::begin(email),                      // very common idiom called \"remove-erase\"\\n                              plus != std::end(email) ? plus : at,    // if there\\'s no \\'+\\' in the name, we trim to \\'@\\'\\n                              \\'.\\'),\\n                  at);\\n\\t  uniques.emplace(email);                                         // construct an \\'email\\' directly inside \\'uniques\\'\\n    }\\n\\n    return static_cast<int>(uniques.size());                          // type safety :)\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int numUniqueEmails(std::vector<std::string>& emails) {             // take a note: it is not \\'const\\' ;)\\n    if(emails.empty())\\n      return {};\\n\\n    std::unordered_set<std::string> uniques;\\n    for(auto& email : emails)\\n    {\\n      auto at   = std::find(std::begin(email), std::end(email), \\'@\\'); // task guaranteed that there will be one \\'@\\'\\n\\t  auto plus = std::find(std::begin(email), at, \\'+\\');              // search for the first \\'+\\' in range [begin, \\'@\\')\\n\\n      email.erase(std::remove(std::begin(email),                      // very common idiom called \"remove-erase\"\\n                              plus != std::end(email) ? plus : at,    // if there\\'s no \\'+\\' in the name, we trim to \\'@\\'\\n                              \\'.\\'),\\n                  at);\\n\\t  uniques.emplace(email);                                         // construct an \\'email\\' directly inside \\'uniques\\'\\n    }\\n\\n    return static_cast<int>(uniques.size());                          // type safety :)\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201039,
                "title": "simple-javascript-solution-68ms-99",
                "content": "The fastest one recorded right now (64ms) is actually incorrect... it only counts the number of unique domain names. I submitted a new test case for this problem that will hopefully invalidate it. \\n\\nThis solution achieves the real fastest time (68ms):\\n\\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nconst numUniqueEmails = emails => {\\n\\tconst hasReceivedMail = {};\\n\\t\\n\\temails.forEach(email =>\\n        hasReceivedMail[email.substring(0, (email.indexOf(\\'+\\') + 1 || email.indexOf(\\'@\\') + 1) - 1).replace(/\\\\./g,\\'\\') + email.substring(email.indexOf(\\'@\\'))] = true\\n    );\\n\\t\\n\\treturn Object.keys(hasReceivedMail).length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nconst numUniqueEmails = emails => {\\n\\tconst hasReceivedMail = {};\\n\\t\\n\\temails.forEach(email =>\\n        hasReceivedMail[email.substring(0, (email.indexOf(\\'+\\') + 1 || email.indexOf(\\'@\\') + 1) - 1).replace(/\\\\./g,\\'\\') + email.substring(email.indexOf(\\'@\\'))] = true\\n    );\\n\\t\\n\\treturn Object.keys(hasReceivedMail).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 194728,
                "title": "simple-java-solution",
                "content": "```\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet distinctEmails = new HashSet();\\n        for (String email: emails) {\\n            String firstSplit[] = email.split(\"@\");\\n            String secondSplit[] = firstSplit[0].replaceAll(\".\",\"\").split(\"[+]\");\\n            distinctEmails.add(secondSplit[0]+firstSplit[1]);\\n        }\\n        \\n        return distinctEmails.size();\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet distinctEmails = new HashSet();\\n        for (String email: emails) {\\n            String firstSplit[] = email.split(\"@\");\\n            String secondSplit[] = firstSplit[0].replaceAll(\".\",\"\").split(\"[+]\");\\n            distinctEmails.add(secondSplit[0]+firstSplit[1]);\\n        }\\n        \\n        return distinctEmails.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 193804,
                "title": "functional-modular-es6-javascript-regex",
                "content": "```\\nconst rule1 = localName => localName.replace(/\\\\./g, \\'\\');\\n\\nconst rule2 = localName => localName.replace(/(\\\\+.*)/, \\'\\');\\n\\nconst localName = email => email.match(/(.*)@/g)[0].replace(\\'@\\',\\'\\');\\n\\nconst domainName = email => email.match(/@(.*)/g)[0].replace(\\'@\\',\\'\\');\\n\\nconst normalizeEmail = email => `${rule2(rule1(localName(email)))}@${domainName(email)}`;\\n\\nconst numUniqueEmails = (emails, uniqueEmails = new Set()) => {\\n  emails.forEach(email => uniqueEmails.add(normalizeEmail(email)));\\n  return uniqueEmails.size; \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst rule1 = localName => localName.replace(/\\\\./g, \\'\\');\\n\\nconst rule2 = localName => localName.replace(/(\\\\+.*)/, \\'\\');\\n\\nconst localName = email => email.match(/(.*)@/g)[0].replace(\\'@\\',\\'\\');\\n\\nconst domainName = email => email.match(/@(.*)/g)[0].replace(\\'@\\',\\'\\');\\n\\nconst normalizeEmail = email => `${rule2(rule1(localName(email)))}@${domainName(email)}`;\\n\\nconst numUniqueEmails = (emails, uniqueEmails = new Set()) => {\\n  emails.forEach(email => uniqueEmails.add(normalizeEmail(email)));\\n  return uniqueEmails.size; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 187654,
                "title": "swift-simple-and-short-solution",
                "content": "```\n    func numUniqueEmails(_ emails: [String]) -> Int {\n        var emailSet:Set<String> = []\n        for s in emails{\n            let address = s.components(separatedBy: \"@\")\n            let name = address[0].components(separatedBy: \"+\").first?.filter({$0 != \".\"})\n            emailSet.insert(name!+address.last!)\n        }\n        return emailSet.count\n    }\n\n```",
                "solutionTags": [],
                "code": "```\n    func numUniqueEmails(_ emails: [String]) -> Int {\n        var emailSet:Set<String> = []\n        for s in emails{\n            let address = s.components(separatedBy: \"@\")\n            let name = address[0].components(separatedBy: \"+\").first?.filter({$0 != \".\"})\n            emailSet.insert(name!+address.last!)\n        }\n        return emailSet.count\n    }\n\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186785,
                "title": "c-string-processing-easy-to-explain-and-impl-in-5mins-cheers",
                "content": "```\\n#include <vector>\\n#include <string>\\n#include <unordered_set>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> res;\\n\\n        for (auto& str : emails) {\\n            string sendto;\\n            int i = 0;\\n            while (str[i] != \\'@\\') {\\n                if (str[i] == \\'+\\') {\\n                    break;\\n                }\\n                if (str[i] != \\'.\\') {\\n                    sendto.push_back(str[i]);\\n                }\\n                ++i;\\n            }\\n\\n            int pos = str.find(\"@\", i);\\n            sendto += str.substr(pos);\\n            res.insert(sendto);\\n        }\\n\\n        return res.size();\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <string>\\n#include <unordered_set>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> res;\\n\\n        for (auto& str : emails) {\\n            string sendto;\\n            int i = 0;\\n            while (str[i] != \\'@\\') {\\n                if (str[i] == \\'+\\') {\\n                    break;\\n                }\\n                if (str[i] != \\'.\\') {\\n                    sendto.push_back(str[i]);\\n                }\\n                ++i;\\n            }\\n\\n            int pos = str.find(\"@\", i);\\n            sendto += str.substr(pos);\\n            res.insert(sendto);\\n        }\\n\\n        return res.size();\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 186739,
                "title": "c-readable-code",
                "content": "It is the easy level algorithm. I wrote the code in the weekly contest 108. It took me around 15 minutes since I tested the code first before I submitted. Ideally I think that is should take less than 10 minutes since I used API of string.Join, I did not need to write any loop by myself. \n```\npublic class Solution {\n    public int NumUniqueEmails(string[] emails)\n        {\n            if (emails == null || emails.Length == 0)\n                return 0;\n\n            var hashset = new HashSet<string>(); \n            foreach(var email in emails)\n            {\n                //need to figure out email address\n                var split1 = email.Split('@');\n                var domainName = split1[1];\n                var name = split1[0];\n                var userName = name.Split('+');\n                var withDot = userName[0];\n                var splitWithDot = withDot.Split('.');\n                var address = string.Join(\"\", splitWithDot);\n                hashset.Add(address + \"@\" + domainName); \n            }\n\n            return hashset.Count; \n    }\n}\n```",
                "solutionTags": [],
                "code": "```\npublic class Solution {\n    public int NumUniqueEmails(string[] emails)\n        {\n            if (emails == null || emails.Length == 0)\n                return 0;\n\n            var hashset = new HashSet<string>(); \n            foreach(var email in emails)\n            {\n                //need to figure out email address\n                var split1 = email.Split('@');\n                var domainName = split1[1];\n                var name = split1[0];\n                var userName = name.Split('+');\n                var withDot = userName[0];\n                var splitWithDot = withDot.Split('.');\n                var address = string.Join(\"\", splitWithDot);\n                hashset.Add(address + \"@\" + domainName); \n            }\n\n            return hashset.Count; \n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 186699,
                "title": "javascript-solution",
                "content": "1) Trim the email (i.e. only get the local name without '.' and before the '+'  and \"@\" and domain ); (e.g. \"user.name+123@gmail.com => username@gmail.com)\n2) Added the trimmed names to a set\n3) count the size of the set return the count;\n\n```\n/**\n * @param {string[]} emails\n * @return {number}\n */\nvar numUniqueEmails = function(emails) {\n    let trimmedUniques = new Set();\n    for (let email of emails) {\n        trimmedUniques.add(trimEmail(email));\n    }\n    return trimmedUniques.size;\n};\n\nvar trimEmail = function(email) {\n    let localList = [];\n    let i = 0;\n    while (email[i] !== '@' && email[i] !== '+') {\n        if (email[i] !== '.') localList.push(email[i]);\n        i++;\n    }\n    while (email[i] !== '@') {\n        i++;\n    }\n    let domain = email.substring(i);\n    return localList.join('') + domain;\n}\n```",
                "solutionTags": [],
                "code": "```\n/**\n * @param {string[]} emails\n * @return {number}\n */\nvar numUniqueEmails = function(emails) {\n    let trimmedUniques = new Set();\n    for (let email of emails) {\n        trimmedUniques.add(trimEmail(email));\n    }\n    return trimmedUniques.size;\n};\n\nvar trimEmail = function(email) {\n    let localList = [];\n    let i = 0;\n    while (email[i] !== '@' && email[i] !== '+') {\n        if (email[i] !== '.') localList.push(email[i]);\n        i++;\n    }\n    while (email[i] !== '@') {\n        i++;\n    }\n    let domain = email.substring(i);\n    return localList.join('') + domain;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867641,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        arr=[]\\n        for i in emails:\\n            if \\'@\\' in i:\\n                at = i.index(\\'@\\')\\n                temp=i[:at]\\n                temp=temp.replace(\".\",\"\")\\n                \\n                if \\'+\\' in temp:\\n                    plus = temp.index(\\'+\\')\\n                    temp = temp[0:plus]\\n                temp+=i[at:]\\n                if temp not in arr:\\n                    arr.append(temp)\\n            else:\\n                continue\\n        #print(arr)\\n        return len(arr)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        arr=[]\\n        for i in emails:\\n            if \\'@\\' in i:\\n                at = i.index(\\'@\\')\\n                temp=i[:at]\\n                temp=temp.replace(\".\",\"\")\\n                \\n                if \\'+\\' in temp:\\n                    plus = temp.index(\\'+\\')\\n                    temp = temp[0:plus]\\n                temp+=i[at:]\\n                if temp not in arr:\\n                    arr.append(temp)\\n            else:\\n                continue\\n        #print(arr)\\n        return len(arr)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837798,
                "title": "easy-solution-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int numUniqueEmails(String[] emails){\\n        int n = emails.length;\\n        HashSet<String> ans = new HashSet<>();\\n        for(int i=0; i<n; i++){\\n            String[] tmp = emails[i].split(\"@\");\\n            StringBuilder a = new StringBuilder(\"\");\\n            for(int j=0; j<tmp[0].length(); j++){\\n                if(tmp[0].charAt(j)==\\'+\\') break;\\n                if(tmp[0].charAt(j)!=46) a.append(tmp[0].charAt(j));\\n                \\n            }\\n            a.append(\\'@\\');\\n            a.append(tmp[1]);\\n            ans.add(a.toString());\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int numUniqueEmails(String[] emails){\\n        int n = emails.length;\\n        HashSet<String> ans = new HashSet<>();\\n        for(int i=0; i<n; i++){\\n            String[] tmp = emails[i].split(\"@\");\\n            StringBuilder a = new StringBuilder(\"\");\\n            for(int j=0; j<tmp[0].length(); j++){\\n                if(tmp[0].charAt(j)==\\'+\\') break;\\n                if(tmp[0].charAt(j)!=46) a.append(tmp[0].charAt(j));\\n                \\n            }\\n            a.append(\\'@\\');\\n            a.append(tmp[1]);\\n            ans.add(a.toString());\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492697,
                "title": "c-hashset-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) {\\n        HashSet<string> uniqueEmails = new HashSet<string>();\\n        foreach(string email in emails){\\n            string[] emailNames = email.Split(\\'@\\');\\n            string localName = emailNames[0];\\n            string domainName = emailNames[1];\\n            if(localName.Contains(\\'+\\')){\\n                localName = localName.Split(\\'+\\')[0];  \\n            }\\n            localName = localName.Replace(\".\",String.Empty);\\n            string forwardedEmail = localName +\"@\"+ domainName;\\n            uniqueEmails.Add(forwardedEmail);   \\n        }\\n        return uniqueEmails.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) {\\n        HashSet<string> uniqueEmails = new HashSet<string>();\\n        foreach(string email in emails){\\n            string[] emailNames = email.Split(\\'@\\');\\n            string localName = emailNames[0];\\n            string domainName = emailNames[1];\\n            if(localName.Contains(\\'+\\')){\\n                localName = localName.Split(\\'+\\')[0];  \\n            }\\n            localName = localName.Replace(\".\",String.Empty);\\n            string forwardedEmail = localName +\"@\"+ domainName;\\n            uniqueEmails.Add(forwardedEmail);   \\n        }\\n        return uniqueEmails.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348698,
                "title": "unique-email-addresses-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int i, j, count, flag1=0;\\n        for(i=0 ; i<emails.size() ; i++)\\n        {\\n            j=0;\\n            flag1=0;\\n            while(j<emails[i].size())\\n            {\\n                if(emails[i][j]==\\'.\\' && flag1==0)\\n                {\\n                    emails[i].erase(emails[i].begin()+j);\\n                }\\n                else if(emails[i][j]==\\'@\\')\\n                {\\n                    flag1=1;\\n                    j++;\\n                }\\n                else if(emails[i][j]==\\'+\\' && flag1==0)\\n                {\\n                    while(emails[i][j]!=\\'@\\')\\n                    {\\n                        emails[i].erase(emails[i].begin()+j);\\n                    }\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n        i=0;\\n        while(i<emails.size())\\n        {\\n            j=i+1;\\n            while(j<emails.size())\\n            {\\n                if(emails[i]==emails[j])\\n                {\\n                    emails.erase(emails.begin()+j);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n            i++;\\n        }\\n        count = emails.size();\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int i, j, count, flag1=0;\\n        for(i=0 ; i<emails.size() ; i++)\\n        {\\n            j=0;\\n            flag1=0;\\n            while(j<emails[i].size())\\n            {\\n                if(emails[i][j]==\\'.\\' && flag1==0)\\n                {\\n                    emails[i].erase(emails[i].begin()+j);\\n                }\\n                else if(emails[i][j]==\\'@\\')\\n                {\\n                    flag1=1;\\n                    j++;\\n                }\\n                else if(emails[i][j]==\\'+\\' && flag1==0)\\n                {\\n                    while(emails[i][j]!=\\'@\\')\\n                    {\\n                        emails[i].erase(emails[i].begin()+j);\\n                    }\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n        i=0;\\n        while(i<emails.size())\\n        {\\n            j=i+1;\\n            while(j<emails.size())\\n            {\\n                if(emails[i]==emails[j])\\n                {\\n                    emails.erase(emails.begin()+j);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n            i++;\\n        }\\n        count = emails.size();\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294872,
                "title": "java-fast-and-simple-solution-hashset-string-methods",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int numUniqueEmails(String[] emails) {\\n        Set<String> uniqueEmails = new HashSet<>();\\n        for (String email : emails) {\\n            String localName = email.substring(0, email.indexOf(\\'@\\'));\\n            localName = localName.replace(\".\", \"\");\\n            if (localName.indexOf(\\'+\\') >= 0) {\\n                localName = localName.substring(0, localName.indexOf(\\'+\\'));\\n            }\\n            uniqueEmails.add(localName + email.substring(email.indexOf(\\'@\\')));\\n        }\\n\\n        return uniqueEmails.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int numUniqueEmails(String[] emails) {\\n        Set<String> uniqueEmails = new HashSet<>();\\n        for (String email : emails) {\\n            String localName = email.substring(0, email.indexOf(\\'@\\'));\\n            localName = localName.replace(\".\", \"\");\\n            if (localName.indexOf(\\'+\\') >= 0) {\\n                localName = localName.substring(0, localName.indexOf(\\'+\\'));\\n            }\\n            uniqueEmails.add(localName + email.substring(email.indexOf(\\'@\\')));\\n        }\\n\\n        return uniqueEmails.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095656,
                "title": "c-929-unique-email-addresses-beats-86-78-with-split-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Split methods bestest instead of SubString. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nRuntime 92 ms Beats 86.78%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMemory 45.1 MB Beats 30.99%\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) {\\n        var uniqueList = new HashSet<string>();\\n        foreach(var email in emails){\\n            var emailSplited =  email.Split(\\'@\\');\\n            var local = emailSplited[0];\\n            var domain = emailSplited[1];\\n\\n            if (local.Contains(\\'+\\')){\\n                local = local.Substring(0,local.IndexOf(\\'+\\'));\\n            }\\n            local = local.Replace(\".\",\"\");\\n            uniqueList.Add(local + \"@\"+domain);\\n        }\\n        return uniqueList.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) {\\n        var uniqueList = new HashSet<string>();\\n        foreach(var email in emails){\\n            var emailSplited =  email.Split(\\'@\\');\\n            var local = emailSplited[0];\\n            var domain = emailSplited[1];\\n\\n            if (local.Contains(\\'+\\')){\\n                local = local.Substring(0,local.IndexOf(\\'+\\'));\\n            }\\n            local = local.Replace(\".\",\"\");\\n            uniqueList.Add(local + \"@\"+domain);\\n        }\\n        return uniqueList.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094970,
                "title": "beginner-friendly-and-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> unique_emails = new HashSet();\\n        for(String email : emails){\\n            int split_position = email.indexOf(\"@\");\\n            String local_name = email.substring(0, split_position);\\n            String domain_name = email.substring(split_position);\\n\\n            if(local_name.contains(\"+\")){\\n                int plus_position = local_name.indexOf(\"+\");\\n                local_name = local_name.substring(0, plus_position);\\n            }\\n\\n            local_name = local_name.replaceAll(\"\\\\\\\\.\",\"\");\\n            String new_name = local_name+domain_name;\\n            unique_emails.add(new_name);\\n        }\\n        return unique_emails.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> unique_emails = new HashSet();\\n        for(String email : emails){\\n            int split_position = email.indexOf(\"@\");\\n            String local_name = email.substring(0, split_position);\\n            String domain_name = email.substring(split_position);\\n\\n            if(local_name.contains(\"+\")){\\n                int plus_position = local_name.indexOf(\"+\");\\n                local_name = local_name.substring(0, plus_position);\\n            }\\n\\n            local_name = local_name.replaceAll(\"\\\\\\\\.\",\"\");\\n            String new_name = local_name+domain_name;\\n            unique_emails.add(new_name);\\n        }\\n        return unique_emails.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078642,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int k=0;\\n        int flag=0;\\n        for(int i=0;i<emails.size();i++){\\n            flag=0;\\n            for(int j=0;j<emails[i].size();j++){\\n                if(emails[i][j]==\\'@\\') break;\\n                if(emails[i][j]==\\'.\\') emails[i].erase(j,1);\\n                else if(emails[i][j]==\\'+\\'){\\n                    flag=1;\\n                    k=j+1;\\n                    while(emails[i][k]!=\\'@\\'){\\n                        k++;\\n                    }\\n                    emails[i].erase(j,(k-j));\\n                }\\n                if(flag==1) break;\\n                k=0;\\n            }\\n        }\\n        set <string> str(emails.begin(),emails.end());\\n        emails.clear();\\n        emails.assign(str.begin(),str.end());\\n         return emails.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int k=0;\\n        int flag=0;\\n        for(int i=0;i<emails.size();i++){\\n            flag=0;\\n            for(int j=0;j<emails[i].size();j++){\\n                if(emails[i][j]==\\'@\\') break;\\n                if(emails[i][j]==\\'.\\') emails[i].erase(j,1);\\n                else if(emails[i][j]==\\'+\\'){\\n                    flag=1;\\n                    k=j+1;\\n                    while(emails[i][k]!=\\'@\\'){\\n                        k++;\\n                    }\\n                    emails[i].erase(j,(k-j));\\n                }\\n                if(flag==1) break;\\n                k=0;\\n            }\\n        }\\n        set <string> str(emails.begin(),emails.end());\\n        emails.clear();\\n        emails.assign(str.begin(),str.end());\\n         return emails.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073504,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String>set = new HashSet();\\n        for(String x:emails){\\n            StringBuilder temp = new StringBuilder();\\n            for(int i=0;i<x.length();i++){\\n                if(x.charAt(i)==\\'@\\' || x.charAt(i)==\\'+\\'){\\n                    break;\\n                }\\n                else if(x.charAt(i)!=\\'.\\'){\\n                       temp.append(x.charAt(i)+\"\"); \\n                }\\n            }\\n            temp.append(x.substring(x.indexOf(\\'@\\'),x.length()));\\n            set.add(temp.toString());\\n            temp.setLength(0);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String>set = new HashSet();\\n        for(String x:emails){\\n            StringBuilder temp = new StringBuilder();\\n            for(int i=0;i<x.length();i++){\\n                if(x.charAt(i)==\\'@\\' || x.charAt(i)==\\'+\\'){\\n                    break;\\n                }\\n                else if(x.charAt(i)!=\\'.\\'){\\n                       temp.append(x.charAt(i)+\"\"); \\n                }\\n            }\\n            temp.append(x.substring(x.indexOf(\\'@\\'),x.length()));\\n            set.add(temp.toString());\\n            temp.setLength(0);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938347,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun numUniqueEmails(emails: Array<String>): Int {\\n        val set = HashSet<String>()\\n\\n        for (email in emails) {\\n            val parts = email.split(\"@\")\\n            val name = parts[0].split(\"+\")[0].replace(\".\", \"\")\\n            val domain = parts[1].split(\".com\")[0]\\n            set.add(\"$name@$domain\")\\n        }\\n\\n        return set.size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun numUniqueEmails(emails: Array<String>): Int {\\n        val set = HashSet<String>()\\n\\n        for (email in emails) {\\n            val parts = email.split(\"@\")\\n            val name = parts[0].split(\"+\")[0].replace(\".\", \"\")\\n            val domain = parts[1].split(\".com\")[0]\\n            set.add(\"$name@$domain\")\\n        }\\n\\n        return set.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733123,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int ans=0;\\n        unordered_set<string>v;\\n        for(int i=0;i<emails.size();i++)\\n        {\\n            string s=emails[i];\\n         \\n            string a=\"\";\\n            int k=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]==\\'@\\')\\n                {\\n                    k=i;\\n                break;\\n                }\\n                else{\\n                a.push_back(s[i]);\\n                }\\n                \\n            }\\n            //cout<<a<<\" \";\\n            string b=\"\";\\n            for(int i=0;i<a.size();i++)\\n            {\\n                 if(a[i]==\\'+\\')\\n                {\\n                break;\\n                }\\n                if(a[i]!=\\'.\\')\\n                {\\n                    b.push_back(a[i]);\\n                  \\n                }\\n              \\n               \\n            }\\n             cout<<b<<\" \";\\n            b+=s.substr(k,s.size());\\n           //cout<<b<<\" \";\\n            v.insert(b);\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int ans=0;\\n        unordered_set<string>v;\\n        for(int i=0;i<emails.size();i++)\\n        {\\n            string s=emails[i];\\n         \\n            string a=\"\";\\n            int k=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]==\\'@\\')\\n                {\\n                    k=i;\\n                break;\\n                }\\n                else{\\n                a.push_back(s[i]);\\n                }\\n                \\n            }\\n            //cout<<a<<\" \";\\n            string b=\"\";\\n            for(int i=0;i<a.size();i++)\\n            {\\n                 if(a[i]==\\'+\\')\\n                {\\n                break;\\n                }\\n                if(a[i]!=\\'.\\')\\n                {\\n                    b.push_back(a[i]);\\n                  \\n                }\\n              \\n               \\n            }\\n             cout<<b<<\" \";\\n            b+=s.substr(k,s.size());\\n           //cout<<b<<\" \";\\n            v.insert(b);\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1575112,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 1572424,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 2053828,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 1813620,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 2048817,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 2016387,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 1832593,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Validate Binary Tree Nodes",
        "question_content": "<p>You have <code>n</code> binary tree nodes numbered from <code>0</code> to <code>n - 1</code> where node <code>i</code> has two children <code>leftChild[i]</code> and <code>rightChild[i]</code>, return <code>true</code> if and only if <strong>all</strong> the given nodes form <strong>exactly one</strong> valid binary tree.</p>\n\n<p>If node <code>i</code> has no left child then <code>leftChild[i]</code> will equal <code>-1</code>, similarly for the right child.</p>\n\n<p>Note that the nodes have no values and that we only use the node numbers in this problem.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/23/1503_ex1.png\" style=\"width: 195px; height: 287px;\" />\n<pre>\n<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/23/1503_ex2.png\" style=\"width: 183px; height: 272px;\" />\n<pre>\n<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/23/1503_ex3.png\" style=\"width: 82px; height: 174px;\" />\n<pre>\n<strong>Input:</strong> n = 2, leftChild = [1,0], rightChild = [-1,-1]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == leftChild.length == rightChild.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 517557,
                "title": "c-find-root-dfs",
                "content": "**Observation**\\n\\nA tree has a single root node (in-degree = 0) and all other nodes have in-degree = 1. We can use this observation to find the root. We can then traverse the tree using that root to check if all nodes have been visited exactly once.\\n\\n**Solution**\\n\\n```\\nclass Solution {\\npublic:\\n   int countNodes(vector<int> &l,vector<int> &r,int root)   // DFS from root to validate that all nodes are visited.\\n    {\\n        if(root==-1)\\n            return 0;\\n        return 1+countNodes(l,r,l[root])+countNodes(l,r,r[root]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) \\n    {\\n        vector<int> inDegree(n,0);\\n        int root=-1;\\n        for(int i=0;i<leftChild.size();i++)\\n            if(leftChild[i]!=-1&&inDegree[leftChild[i]]++==1)  //If in-degree exceeds 1 return false.\\n                return false;\\n            else if(rightChild[i]!=-1&&inDegree[rightChild[i]]++==1)  //If in-degree exceeds 1 return false.\\n                return false;\\n        for(int i=0;i<leftChild.size();i++)    //Find root and also check for multiple roots.\\n            if(inDegree[i]==0)  //If in-degree = 0 and has children it\\'s a root.\\n                if(root==-1)   //Store the root.\\n                    root=i;\\n                else    //We have multiple roots, return false\\n                    return false;\\n        if(root==-1)\\n            return false;\\n        return countNodes(leftChild,rightChild,root)==n;\\n    }\\n};\\n```\\n**Complexity**\\n\\nSpace: `O(n).`\\nTime: `O(n).`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int countNodes(vector<int> &l,vector<int> &r,int root)   // DFS from root to validate that all nodes are visited.\\n    {\\n        if(root==-1)\\n            return 0;\\n        return 1+countNodes(l,r,l[root])+countNodes(l,r,r[root]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) \\n    {\\n        vector<int> inDegree(n,0);\\n        int root=-1;\\n        for(int i=0;i<leftChild.size();i++)\\n            if(leftChild[i]!=-1&&inDegree[leftChild[i]]++==1)  //If in-degree exceeds 1 return false.\\n                return false;\\n            else if(rightChild[i]!=-1&&inDegree[rightChild[i]]++==1)  //If in-degree exceeds 1 return false.\\n                return false;\\n        for(int i=0;i<leftChild.size();i++)    //Find root and also check for multiple roots.\\n            if(inDegree[i]==0)  //If in-degree = 0 and has children it\\'s a root.\\n                if(root==-1)   //Store the root.\\n                    root=i;\\n                else    //We have multiple roots, return false\\n                    return false;\\n        if(root==-1)\\n            return false;\\n        return countNodes(leftChild,rightChild,root)==n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939381,
                "title": "python-clean-bfs-96-faster-timecomplexity-o-n-space-complexity-o-n",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n\\tdef validateBinaryNodes(self, n, leftChild, rightChild):\\n\\t\\t# find the root node, assume root is node(0) by default\\n\\t\\t# a node without any parent would be a root node\\n\\t\\t# note: if there are multiple root nodes => 2+ trees\\n\\t\\troot = 0\\n\\t\\tchildrenNodes = set(leftChild + rightChild)\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif i not in childrenNodes:\\n\\t\\t\\t\\troot = i\\n\\t\\t\\n\\t\\t# keep track of visited nodes\\n\\t\\tvisited = set()\\n\\t\\t# queue to keep track of in which order do we need to process nodes\\n\\t\\tqueue = deque([root])\\n\\t\\t\\n\\t\\twhile queue:\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tif node in visited:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t\\n\\t\\t\\t# mark visited\\n\\t\\t\\tvisited.add(node)\\n\\t\\t\\t\\n\\t\\t\\t# process node\\n\\t\\t\\tif leftChild[node] != -1:\\n\\t\\t\\t\\tqueue.append(leftChild[node])\\n\\t\\t\\tif rightChild[node] != -1:\\n\\t\\t\\t\\tqueue.append(rightChild[node])\\n\\t\\t\\t\\t\\n\\t\\t# number of visited nodes == given number of nodes\\n\\t\\t# if n != len(visited) => some nodes are unreachable/multiple different trees\\n\\t\\treturn len(visited) == n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n\\tdef validateBinaryNodes(self, n, leftChild, rightChild):\\n\\t\\t# find the root node, assume root is node(0) by default\\n\\t\\t# a node without any parent would be a root node\\n\\t\\t# note: if there are multiple root nodes => 2+ trees\\n\\t\\troot = 0\\n\\t\\tchildrenNodes = set(leftChild + rightChild)\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif i not in childrenNodes:\\n\\t\\t\\t\\troot = i\\n\\t\\t\\n\\t\\t# keep track of visited nodes\\n\\t\\tvisited = set()\\n\\t\\t# queue to keep track of in which order do we need to process nodes\\n\\t\\tqueue = deque([root])\\n\\t\\t\\n\\t\\twhile queue:\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tif node in visited:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t\\n\\t\\t\\t# mark visited\\n\\t\\t\\tvisited.add(node)\\n\\t\\t\\t\\n\\t\\t\\t# process node\\n\\t\\t\\tif leftChild[node] != -1:\\n\\t\\t\\t\\tqueue.append(leftChild[node])\\n\\t\\t\\tif rightChild[node] != -1:\\n\\t\\t\\t\\tqueue.append(rightChild[node])\\n\\t\\t\\t\\t\\n\\t\\t# number of visited nodes == given number of nodes\\n\\t\\t# if n != len(visited) => some nodes are unreachable/multiple different trees\\n\\t\\treturn len(visited) == n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517669,
                "title": "the-standard-code-is-wrong",
                "content": "For the case\\n```\\n4\\n[1, 2, 0, -1]\\n[-1, -1, -1, -1]\\n```\\nThe standard code gives the answer `True`, while there is a loop `0->1->2->0` which means the graph is not a tree.",
                "solutionTags": [],
                "code": "```\\n4\\n[1, 2, 0, -1]\\n[-1, -1, -1, -1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517596,
                "title": "count-parents-and-union-find",
                "content": "We can count how many parents every node has. \\n\\nFor the three to be valid: \\n- No node should have more than one parent\\n- There should be exactly one node with zero parents\\n\\n```\\nbool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n    vector<int> parents(n);\\n    for (int i = 0; i < n; ++i) {\\n        if (leftChild[i] != -1 && ++parents[leftChild[i]] > 1)\\n            return false;\\n        if (rightChild[i] != -1 && ++parents[rightChild[i]] > 1)\\n            return false;\\n    }\\n    return count_if(begin(parents), end(parents), [](int i) { return i == 0; }) == 1;\\n}\\n```\\n**Update**\\nThe code above does not work correctly (as well as OJ code) if there are orphans or cycles, e.g. `[-1,2-1][-1,-1,1]` or `[1, 0, 3, -1] [-1, -1, -1, -1]`. \\n\\nTo handle this, we need to also track groups of connected nodes (I used union-find). So, we check this additional condition:\\n- There is only one group of connected nodes.\\n\\nThanks [Mendor](https://leetcode.com/mendor/) for the examples!\\n```cpp\\nint find(vector<int>&ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nbool processLink(vector<int> &pars, vector<int>&ds, int parent, int child) {\\n    if (child == -1)\\n        return true;\\n    auto p = find(ds, parent), c = find(ds, child);\\n    if (p != c)\\n        ds[c] = p;\\n    return ++pars[child] < 2;\\n}\\nbool validateBinaryTreeNodes(int n, vector<int>& lCh, vector<int>& rCh) {\\n    vector<int> pars(n), ds(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n        if (!processLink(pars, ds, i, lCh[i]) || !processLink(pars, ds, i, rCh[i]))\\n            return false;\\n    }\\n    return count_if(begin(pars), end(pars), [](int i) { return i == 0; }) == 1 &&\\n        count_if(begin(ds), end(ds), [](int i) { return i < 0; }) == 1;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(n)",
                "solutionTags": [],
                "code": "```\\nbool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n    vector<int> parents(n);\\n    for (int i = 0; i < n; ++i) {\\n        if (leftChild[i] != -1 && ++parents[leftChild[i]] > 1)\\n            return false;\\n        if (rightChild[i] != -1 && ++parents[rightChild[i]] > 1)\\n            return false;\\n    }\\n    return count_if(begin(parents), end(parents), [](int i) { return i == 0; }) == 1;\\n}\\n```\n```cpp\\nint find(vector<int>&ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nbool processLink(vector<int> &pars, vector<int>&ds, int parent, int child) {\\n    if (child == -1)\\n        return true;\\n    auto p = find(ds, parent), c = find(ds, child);\\n    if (p != c)\\n        ds[c] = p;\\n    return ++pars[child] < 2;\\n}\\nbool validateBinaryTreeNodes(int n, vector<int>& lCh, vector<int>& rCh) {\\n    vector<int> pars(n), ds(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n        if (!processLink(pars, ds, i, lCh[i]) || !processLink(pars, ds, i, rCh[i]))\\n            return false;\\n    }\\n    return count_if(begin(pars), end(pars), [](int i) { return i == 0; }) == 1 &&\\n        count_if(begin(ds), end(ds), [](int i) { return i < 0; }) == 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137658,
                "title": "java-dsu-union-find",
                "content": "This solution uses Union Find (a.k.a Disjoint Set Union) which counts connected components and allows only the single child-root assignment.\\n\\nTime complexity: `O(N log * N)`.\\nSpace complexity: `O(N)`.\\n\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] >= 0 && !uf.union(i, leftChild[i])) {\\n                return false;\\n            }\\n            if (rightChild[i] >= 0 && !uf.union(i, rightChild[i])) {\\n                return false;\\n            }\\n        }\\n        return uf.components() == 1;\\n    }\\n}\\n\\nclass UnionFind {\\n    private final int n;\\n    private final int[] roots;\\n    private int components;\\n    \\n    UnionFind (int n) {\\n        this.n = n;\\n        roots = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            roots[i] = i;\\n        }\\n        components = n;\\n    }\\n    \\n    public boolean union(int parent, int child) {\\n        int rootParent = findRoot(parent);\\n        int rootChild = findRoot(child);\\n        \\n        if (rootParent == rootChild || rootChild != child) {\\n            return false;\\n        }\\n        \\n        roots[rootChild] = rootParent;\\n        components--;\\n        return true;\\n    }\\n    \\n    private int findRoot(int v) {\\n        while (v != roots[v]) {\\n            roots[v] = roots[roots[v]];\\n            v = roots[v];\\n        }\\n        return v;\\n    }\\n    \\n    public int components() {\\n        return components;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] >= 0 && !uf.union(i, leftChild[i])) {\\n                return false;\\n            }\\n            if (rightChild[i] >= 0 && !uf.union(i, rightChild[i])) {\\n                return false;\\n            }\\n        }\\n        return uf.components() == 1;\\n    }\\n}\\n\\nclass UnionFind {\\n    private final int n;\\n    private final int[] roots;\\n    private int components;\\n    \\n    UnionFind (int n) {\\n        this.n = n;\\n        roots = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            roots[i] = i;\\n        }\\n        components = n;\\n    }\\n    \\n    public boolean union(int parent, int child) {\\n        int rootParent = findRoot(parent);\\n        int rootChild = findRoot(child);\\n        \\n        if (rootParent == rootChild || rootChild != child) {\\n            return false;\\n        }\\n        \\n        roots[rootChild] = rootParent;\\n        components--;\\n        return true;\\n    }\\n    \\n    private int findRoot(int v) {\\n        while (v != roots[v]) {\\n            roots[v] = roots[roots[v]];\\n            v = roots[v];\\n        }\\n        return v;\\n    }\\n    \\n    public int components() {\\n        return components;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051329,
                "title": "java-o-n-time-space-queue-bfs",
                "content": "```\\n// time: O(n)\\n// space: O(n) \\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        int root = findRoot(n, leftChild, rightChild);\\n        if (root == -1) return false;\\n        \\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            if (node == -1) continue;\\n            \\n            if (!visited.add(node)) return false;\\n            \\n            int left = leftChild[node];\\n            int right = rightChild[node];\\n            \\n            queue.offer(left);\\n            queue.offer(right);\\n        }\\n        \\n        return visited.size() == n;\\n    }\\n    \\n    private int findRoot(int n, int[] left, int[] right) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < n; i++) set.add(i);\\n        for (int node : left) set.remove(node);\\n        for (int node : right) set.remove(node);\\n        \\n        return set.size() == 1 ? set.iterator().next() : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\n// time: O(n)\\n// space: O(n) \\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        int root = findRoot(n, leftChild, rightChild);\\n        if (root == -1) return false;\\n        \\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            if (node == -1) continue;\\n            \\n            if (!visited.add(node)) return false;\\n            \\n            int left = leftChild[node];\\n            int right = rightChild[node];\\n            \\n            queue.offer(left);\\n            queue.offer(right);\\n        }\\n        \\n        return visited.size() == n;\\n    }\\n    \\n    private int findRoot(int n, int[] left, int[] right) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < n; i++) set.add(i);\\n        for (int node : left) set.remove(node);\\n        for (int node : right) set.remove(node);\\n        \\n        return set.size() == 1 ? set.iterator().next() : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192284,
                "title": "c-easy-to-understand-with-comments-topological-sort-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) { \\n        \\n        // CREATE A GRAPH\\n       \\n        vector<vector<int>> graph(n); \\n        \\n        //NUMBER OF EDGES IN GRAPH\\n        int edge = 0; \\n        \\n        for(int i = 0; i < n; i++) {   \\n            if(leftChild[i] != -1) {\\n                graph[i].push_back(leftChild[i]);   \\n                ++edge;\\n            } \\n            if(rightChild[i] != -1) { \\n                graph[i].push_back(rightChild[i]); \\n                ++edge;\\n            } \\n        }\\n        \\n        //CHECK FOR SELF LOOPS AND CYCLES\\n        queue<int> q; \\n        vector<bool> visited(n, false); \\n        vector<int> indegree(n, 0); \\n        int ctr = 0; \\n        \\n        for(int i = 0; i < graph.size(); i++) { \\n            for(int j = 0; j < graph[i].size(); j++) { \\n                indegree[graph[i][j]]++;\\n            }\\n        } \\n        \\n        for(int i = 0; i < indegree.size(); i++) {  \\n            \\n            //NODE SHOULD HAVE EITHER ZERO OR ONE AS INDEGREE \\n            \\n            if(indegree[i] > 1) { \\n                return false;\\n            }\\n            if(indegree[i] == 0) { \\n                q.push(i); \\n                ctr++;\\n            }\\n        } \\n        \\n        while(!q.empty()) { \\n            int front = q.front(); \\n            visited[front] = true; \\n            q.pop(); \\n            \\n            for(int i : graph[front]) { \\n                \\n                indegree[i]--;\\n                \\n                if(!visited[i] && indegree[i] == 0) { \\n                    q.push(i); \\n                    ctr++;\\n                }\\n            }\\n        } \\n        \\n        //IF CYCLES ARE PRESENT OR EDGES ARE NOT EQUAL TO N-1 RETURN FALSE \\n        \\n        if(ctr != n || edge != n-1) { \\n            return false;\\n        }  \\n        \\n        //ELSE RETURN TRUE \\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) { \\n        \\n        // CREATE A GRAPH\\n       \\n        vector<vector<int>> graph(n); \\n        \\n        //NUMBER OF EDGES IN GRAPH\\n        int edge = 0; \\n        \\n        for(int i = 0; i < n; i++) {   \\n            if(leftChild[i] != -1) {\\n                graph[i].push_back(leftChild[i]);   \\n                ++edge;\\n            } \\n            if(rightChild[i] != -1) { \\n                graph[i].push_back(rightChild[i]); \\n                ++edge;\\n            } \\n        }\\n        \\n        //CHECK FOR SELF LOOPS AND CYCLES\\n        queue<int> q; \\n        vector<bool> visited(n, false); \\n        vector<int> indegree(n, 0); \\n        int ctr = 0; \\n        \\n        for(int i = 0; i < graph.size(); i++) { \\n            for(int j = 0; j < graph[i].size(); j++) { \\n                indegree[graph[i][j]]++;\\n            }\\n        } \\n        \\n        for(int i = 0; i < indegree.size(); i++) {  \\n            \\n            //NODE SHOULD HAVE EITHER ZERO OR ONE AS INDEGREE \\n            \\n            if(indegree[i] > 1) { \\n                return false;\\n            }\\n            if(indegree[i] == 0) { \\n                q.push(i); \\n                ctr++;\\n            }\\n        } \\n        \\n        while(!q.empty()) { \\n            int front = q.front(); \\n            visited[front] = true; \\n            q.pop(); \\n            \\n            for(int i : graph[front]) { \\n                \\n                indegree[i]--;\\n                \\n                if(!visited[i] && indegree[i] == 0) { \\n                    q.push(i); \\n                    ctr++;\\n                }\\n            }\\n        } \\n        \\n        //IF CYCLES ARE PRESENT OR EDGES ARE NOT EQUAL TO N-1 RETURN FALSE \\n        \\n        if(ctr != n || edge != n-1) { \\n            return false;\\n        }  \\n        \\n        //ELSE RETURN TRUE \\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517598,
                "title": "java-python-3-clean-bfs-o-n-code-w-brief-explanation-and-analysis",
                "content": "**Updated with correct versions as follows:**\\n\\n1. Use HashSet to confirm that there is 1 and only 1 root;\\n2. BFS starting from root to check if we can traverse each node once and only once.\\n\\n```java\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int root = findRoot(leftChild, rightChild);\\n        return root >= 0 && bfs(root, leftChild, rightChild);\\n    }\\n    // Confirm there is 1 and only 1 root.\\n    private int findRoot(int[] leftChild, int[] rightChild) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < leftChild.length; ++i) {\\n            seen.add(i); // Add each node into HashSet.\\n        }\\n        for (int[] kids : new int[][]{leftChild, rightChild}) {\\n            for (int kid : kids) {\\n                if (kid >= 0 && !seen.remove(kid)) { // kid has more than 1 parent?\\n                    return -1;\\n                }\\n            }\\n        }\\n        return seen.size() == 1 ? seen.iterator().next() : -1; // Only 1 root?\\n    }\\n    // BFS starting from root to check if we can traverse each \\n    // node once and only once.\\n    private boolean bfs(int root, int[] leftChild, int[] rightChild) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(root); // BFS starts from root.\\n        Set<Integer> seen = new HashSet<>(q);\\n        while (!q.isEmpty()) {\\n            int node = q.poll();\\n            for (int kid : new int[]{leftChild[node], rightChild[node]}) {\\n                if (kid >= 0 && seen.add(kid)) {\\n                    q.offer(kid);\\n                }\\n            }\\n        }\\n        return seen.size() == leftChild.length;\\n    }\\n```\\n```python\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        def findRoot() -> int:\\n            seen = set(range(n))\\n            seen.difference_update(leftChild + rightChild)\\n            return seen.pop() if len(seen) == 1 else -1\\n        \\n        def bfs(root: int) -> bool:\\n            dq, seen = deque([root]), {root}\\n            while dq:\\n                node = dq.popleft()\\n                for kid in leftChild[node], rightChild[node]:\\n                    if kid >= 0:\\n                        if kid in seen:\\n                            return False\\n                        seen.add(kid)\\n                        dq.append(kid)\\n            return len(seen) == n\\n    \\n        root = findRoot()\\n        return root >= 0 and bfs(root)\\n```\\n\\n**Analysis:**\\n\\nTime & space: O(n).\\n\\n----\\n\\n**The following are WRONG codes, for reference only**\\nFails on the following test cases - credit to **@wenxinli @davidviva @MacJordan**: \\n\\n\\n\\n```\\n4\\n[1,2,0,-1]\\n[-1,-1,-1,-1]\\n```\\n```\\n3\\n[-1,2,-1]\\n[-1,-1,1]\\nEvery node except 0 has one parent but apparently there is a cycle.\\n```\\n\\n----\\n\\n~~~Please refer to the excellent explanation from **@putIfAbsent:**~~~\\n\\n~~~Each tree node only has one parent node except root node, which is the only one that has no in-degree. And in the end, root node left in the set alone.~~~\\n```java\\n    public boolean validateBinaryTreeNodes(int n, int[] left, int[] right) {\\n        Set<Integer> nodes = IntStream.range(0, n).boxed().collect(Collectors.toCollection(HashSet::new));\\n        int[] inDegree = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            for (int child : new int[]{left[i], right[i]}) {\\n                if (child >= 0) {\\n                    if (++inDegree[child] > 1)\\n                        return false;\\n                    nodes.remove(child);\\n                } \\n            }\\n        }\\n        return nodes.size() == 1;\\n    }\\n```\\n```python\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        nodes, inDegree = {i for i in range(n)}, [0] * n\\n        for children in zip(leftChild, rightChild):\\n            for child in children:\\n                if child >= 0:\\n                    inDegree[child] += 1\\n                    if inDegree[child] > 1:\\n                        return False\\n                    nodes.discard(child)\\n        return len(nodes) == 1\\n```\\n~~~**Analysis:**~~~\\n\\n~~~Time & space: O(n).~~~",
                "solutionTags": [],
                "code": "```java\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int root = findRoot(leftChild, rightChild);\\n        return root >= 0 && bfs(root, leftChild, rightChild);\\n    }\\n    // Confirm there is 1 and only 1 root.\\n    private int findRoot(int[] leftChild, int[] rightChild) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < leftChild.length; ++i) {\\n            seen.add(i); // Add each node into HashSet.\\n        }\\n        for (int[] kids : new int[][]{leftChild, rightChild}) {\\n            for (int kid : kids) {\\n                if (kid >= 0 && !seen.remove(kid)) { // kid has more than 1 parent?\\n                    return -1;\\n                }\\n            }\\n        }\\n        return seen.size() == 1 ? seen.iterator().next() : -1; // Only 1 root?\\n    }\\n    // BFS starting from root to check if we can traverse each \\n    // node once and only once.\\n    private boolean bfs(int root, int[] leftChild, int[] rightChild) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(root); // BFS starts from root.\\n        Set<Integer> seen = new HashSet<>(q);\\n        while (!q.isEmpty()) {\\n            int node = q.poll();\\n            for (int kid : new int[]{leftChild[node], rightChild[node]}) {\\n                if (kid >= 0 && seen.add(kid)) {\\n                    q.offer(kid);\\n                }\\n            }\\n        }\\n        return seen.size() == leftChild.length;\\n    }\\n```\n```python\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        def findRoot() -> int:\\n            seen = set(range(n))\\n            seen.difference_update(leftChild + rightChild)\\n            return seen.pop() if len(seen) == 1 else -1\\n        \\n        def bfs(root: int) -> bool:\\n            dq, seen = deque([root]), {root}\\n            while dq:\\n                node = dq.popleft()\\n                for kid in leftChild[node], rightChild[node]:\\n                    if kid >= 0:\\n                        if kid in seen:\\n                            return False\\n                        seen.add(kid)\\n                        dq.append(kid)\\n            return len(seen) == n\\n    \\n        root = findRoot()\\n        return root >= 0 and bfs(root)\\n```\n```\\n4\\n[1,2,0,-1]\\n[-1,-1,-1,-1]\\n```\n```\\n3\\n[-1,2,-1]\\n[-1,-1,1]\\nEvery node except 0 has one parent but apparently there is a cycle.\\n```\n```java\\n    public boolean validateBinaryTreeNodes(int n, int[] left, int[] right) {\\n        Set<Integer> nodes = IntStream.range(0, n).boxed().collect(Collectors.toCollection(HashSet::new));\\n        int[] inDegree = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            for (int child : new int[]{left[i], right[i]}) {\\n                if (child >= 0) {\\n                    if (++inDegree[child] > 1)\\n                        return false;\\n                    nodes.remove(child);\\n                } \\n            }\\n        }\\n        return nodes.size() == 1;\\n    }\\n```\n```python\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        nodes, inDegree = {i for i in range(n)}, [0] * n\\n        for children in zip(leftChild, rightChild):\\n            for child in children:\\n                if child >= 0:\\n                    inDegree[child] += 1\\n                    if inDegree[child] > 1:\\n                        return False\\n                    nodes.discard(child)\\n        return len(nodes) == 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 706421,
                "title": "python-o-n-no-algorithm-cs-fundamentals",
                "content": "We shall only need to check the following 2 conditions to determine if it\\'s a binary tree.\\n<br>\\n1. There must be **exactly (n - 1) edges**, assuming there\\'re `n` nodes in the graph.\\n\\n2. Every node, except the root, has **exactly 1 parent**.\\n\\n3. So, how do you solve it? Counting the number of edges is simple enough - we count the number of entries in `leftChild` and `rightChild` that\\'re `!= -1`\\n\\n4. Next, we setup an array of length n, where `parent[i]` = parent(s) of node `i`\\n\\n5. To find all roots, get the index of the nodes where `parent[i] = []` --> ensure there\\'s **exactly 1 root**\\n\\n6. Next, make sure the **root is connected to the rest of the graph**, by checking if it has a child. Of course, if `n=1`, there\\'s no need to do this.\\n\\n<br>\\n\\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        \\'\\'\\'\\n        CHECK CONDITION 1 : There must be EXACTLY (n - 1) edges \\n        \\'\\'\\'\\n        # COUNT THE TOTAL EDGES - O(N)\\n        leftEdges = len([l for l in leftChild if l != -1])\\n        rightEdges = len([r for r in rightChild if r != -1])\\n\\n        # CHECK FOR VIOLATION OF CONDITION 1 - O(1)\\n        if leftEdges + rightEdges != n - 1:\\n            return False\\n        \\n        \\'\\'\\'\\n        CHECK CONDITION 2 : Each node, except the root, has EXACTLY 1 parent\\n        \\'\\'\\'\\n        # GET THE PARENT OF EACH NODE - O(N)\\n        parent = [[] for _ in range(n)]\\n        \\n        # FILL THE PARENT - O(N)\\n        for i in range(n):\\n            if leftChild[i] != -1: parent[leftChild[i]].append(i)                \\n            if rightChild[i] != -1: parent[rightChild[i]].append(i)    \\n                \\n        # FIND ALL ROOT NODES (IE. THOSE WITHOUT PARENT) - O(N)\\n        roots = [i for i in range(len(parent)) if not parent[i]]\\n\\n        # CHECK IF THERE\\'S EXACTLY 1 ROOT NODE  - O(1)\\n        if len(roots) != 1:\\n            return False\\n        \\n        # ENSURE ROOT HAS > 1 CHILD, IF N > 1 - O(N)\\n        root = roots[0]\\n        return max(leftChild[root], rightChild[root]) != -1 or n == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        \\'\\'\\'\\n        CHECK CONDITION 1 : There must be EXACTLY (n - 1) edges \\n        \\'\\'\\'\\n        # COUNT THE TOTAL EDGES - O(N)\\n        leftEdges = len([l for l in leftChild if l != -1])\\n        rightEdges = len([r for r in rightChild if r != -1])\\n\\n        # CHECK FOR VIOLATION OF CONDITION 1 - O(1)\\n        if leftEdges + rightEdges != n - 1:\\n            return False\\n        \\n        \\'\\'\\'\\n        CHECK CONDITION 2 : Each node, except the root, has EXACTLY 1 parent\\n        \\'\\'\\'\\n        # GET THE PARENT OF EACH NODE - O(N)\\n        parent = [[] for _ in range(n)]\\n        \\n        # FILL THE PARENT - O(N)\\n        for i in range(n):\\n            if leftChild[i] != -1: parent[leftChild[i]].append(i)                \\n            if rightChild[i] != -1: parent[rightChild[i]].append(i)    \\n                \\n        # FIND ALL ROOT NODES (IE. THOSE WITHOUT PARENT) - O(N)\\n        roots = [i for i in range(len(parent)) if not parent[i]]\\n\\n        # CHECK IF THERE\\'S EXACTLY 1 ROOT NODE  - O(1)\\n        if len(roots) != 1:\\n            return False\\n        \\n        # ENSURE ROOT HAS > 1 CHILD, IF N > 1 - O(N)\\n        root = roots[0]\\n        return max(leftChild[root], rightChild[root]) != -1 or n == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517571,
                "title": "find-parent-array-and-child-array-java",
                "content": "```\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n\\n        Set<Integer>[] childArr = new Set[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent,-1);\\n        for (int i=0;i<n;i++) {\\n            childArr[i]= new HashSet<>();\\n        }\\n\\n        for (int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1) {\\n                // If parent already assigned or leftChild[i] is already a grand parent of i;\\n                if(parent[leftChild[i]]!=-1 || isCurrentChildAPreviousParent(leftChild[i],childArr,i)) {\\n                    return false;\\n                }\\n                parent[leftChild[i]]=i;\\n                childArr[i].add(leftChild[i]);\\n            }\\n            if(rightChild[i]!=-1) {\\n                // If parent already assigned or rightChild[i] is already a grand parent of i;\\n                if(parent[rightChild[i]]!=-1 || isCurrentChildAPreviousParent(rightChild[i],childArr,i)) {\\n                    return false;\\n                }\\n                parent[rightChild[i]]=i;\\n                childArr[i].add(rightChild[i]);\\n            }\\n        }\\n\\n        int rootCount = 0;\\n        // If 2 roots or none of them is a root.\\n        for (int x : parent) {\\n            if(x==-1) {\\n                rootCount++;\\n            }\\n        }\\n\\n        return rootCount==1;\\n    }\\n\\n    // Check if the child is a grand parent of the current index\\n    private boolean isCurrentChildAPreviousParent(int child, Set<Integer>[] childArr, int parent) {\\n        if(child==parent) {\\n            return true;\\n        }\\n        for (Integer c : childArr[child]) {\\n            boolean v =  isCurrentChildAPreviousParent(c,childArr,parent);\\n            if(v) {\\n                return v;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\nUpdate: \\nI have added a child array which is used to check if the current child was a grand parent of the current index every time.\\nThanks @Leoooooo for pointing out the test case.",
                "solutionTags": [],
                "code": "```\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n\\n        Set<Integer>[] childArr = new Set[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent,-1);\\n        for (int i=0;i<n;i++) {\\n            childArr[i]= new HashSet<>();\\n        }\\n\\n        for (int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1) {\\n                // If parent already assigned or leftChild[i] is already a grand parent of i;\\n                if(parent[leftChild[i]]!=-1 || isCurrentChildAPreviousParent(leftChild[i],childArr,i)) {\\n                    return false;\\n                }\\n                parent[leftChild[i]]=i;\\n                childArr[i].add(leftChild[i]);\\n            }\\n            if(rightChild[i]!=-1) {\\n                // If parent already assigned or rightChild[i] is already a grand parent of i;\\n                if(parent[rightChild[i]]!=-1 || isCurrentChildAPreviousParent(rightChild[i],childArr,i)) {\\n                    return false;\\n                }\\n                parent[rightChild[i]]=i;\\n                childArr[i].add(rightChild[i]);\\n            }\\n        }\\n\\n        int rootCount = 0;\\n        // If 2 roots or none of them is a root.\\n        for (int x : parent) {\\n            if(x==-1) {\\n                rootCount++;\\n            }\\n        }\\n\\n        return rootCount==1;\\n    }\\n\\n    // Check if the child is a grand parent of the current index\\n    private boolean isCurrentChildAPreviousParent(int child, Set<Integer>[] childArr, int parent) {\\n        if(child==parent) {\\n            return true;\\n        }\\n        for (Integer c : childArr[child]) {\\n            boolean v =  isCurrentChildAPreviousParent(c,childArr,parent);\\n            if(v) {\\n                return v;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1843534,
                "title": "c-easy-code-for-beginners-3-approaches-find-union-dfs-topology-bfs",
                "content": "# DFS SOLUTION\\nApproach- \\n1) Check if the incoming edge is exactly 1, since in trees we have directed edges and one node just have one incoming edge. So if there is more than 1 incoming edge, return false\\n2) A tree can have only and only 1 root, check how many roots are there using the indegree array.\\n3) After all above checks are done, only thing remains is to check if the tree is disconnected or not. For this just traverse the tree from the root we found earlier, and then check if any vertex is left unvisited, if it has, return false;\\n\\nCODE-\\n```\\nclass Solution {\\npublic:\\n    void traverseTree(vector<int> &left, vector<int> &right, int root, vector<bool> &vis) {\\n        if(root==-1 || vis[root]==true){\\n            return;\\n        }\\n        vis[root]=true;\\n        traverseTree(left,right,left[root],vis);\\n        traverseTree(left,right,right[root],vis);\\n        return;\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> indegree(n,0);\\n        for (int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1 && ++indegree[leftChild[i]]>1){ //if incoming edges exceed 1, not possible\\n                return false;\\n            }\\n            if(rightChild[i]!=-1 && ++indegree[rightChild[i]]>1){\\n                return false;\\n            }\\n        }\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                if(root!=-1){  // we see more than 1 root, not possible, return false\\n                    return false;\\n                }\\n                root=i;\\n            }\\n        }        \\n        if(root==-1){  //if root is still -1 there is no root, return false\\n            return false;\\n        }\\n        vector<bool> vis(n,false);\\n        traverseTree(leftChild,rightChild,root,vis);\\n        for(auto e: vis){\\n            if(e==false){  //this node is left unvisited and hence not a valid tree, return false \\n                return false;\\n            }\\n        }\\n        return true; \\n    }\\n};\\n```\\n\\n# TOPOLOGY APPROACH\\nApproach-\\n1) All the previous checks remains the same\\n2) Build a graph using the given information\\n3) Use topology sort, the idea is to move forward from that node only when all the preNodes pointing at it have been processed, we know tree is a directed graph pointing downwards, and it can also follow topological order, We use topology sort and count how many nodes we can traverse through the topology, and if it is equal to number of given nodes, the tree is OK\\n\\nCODE- \\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        list<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for (int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1){\\n                if(++indegree[leftChild[i]]>1){\\n                    return false;\\n                }\\n                adj[i].push_back(leftChild[i]);\\n            } \\n            if(rightChild[i]!=-1){\\n                if(++indegree[rightChild[i]]>1){\\n                    return false;\\n                }\\n                adj[i].push_back(rightChild[i]);\\n            }\\n        }\\n        queue<int> q;\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                if(root!=-1){\\n                    return false;\\n                }\\n                q.push(i); // DEGREE 0 means its the root\\n                root=i;\\n            }\\n        }        \\n        if(root==-1){\\n            return false;\\n        }\\n        int cnt=0;\\n        while(!q.empty()){  //DOING TOPOLOGY SORT\\n            int x=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto nei: adj[x]){\\n                indegree[nei]--; // we came to this nei from its source, so this nei node one preNode has been traversed and hence reduce its dependency\\n                if(indegree[nei]==0){  // we have traversed every node which was pointing on nei and now we can take it in queue for furthur processing\\n                    q.push(nei);\\n                }\\n            }\\n        }\\n        return cnt==n; // through topology we traversed cnt nodes and if it is equal to given n nodes return true\\n    }\\n};\\n```\\n\\n# DISJOINT SETS\\nApproach-\\n1) All prior checks to be taken care of.\\n2) Now, merge parent and left child in disjoint set\\n3) Now, merge parent and right child in disjoint set\\n4) Check if there are some nodes which have been left unconnected and if they have been return false, cuz tree cannot be built.\\n\\nREASON FOR USING DISJOINT SETS- \\nThe main motive of using DS is just because of its path compression, we all know Disjoint sets use path compression to minimise the time it takes to reach the parent. Now in a tree, the god parent is the root so every node should point to it. This is what we take advantage of here.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int findParent_PathCompression(int node){ // finds parent and also compresses path\\n        if(parent[node]==node){\\n            return parent[node];\\n        }\\n        return parent[node]=findParent_PathCompression(parent[node]);\\n    }\\n    \\n    void merge(int node1, int node2){  // union function, union by rank\\n        int from=findParent_PathCompression(node1);\\n        int to=findParent_PathCompression(node2);\\n        if(rank[to]<rank[from]){\\n            parent[to]=from;\\n        }\\n        else if(rank[from]<rank[to]){\\n            parent[from]=to;\\n        }\\n        else{\\n\\t\\t// since rank value for both is same, it does not matter whom you make parent and child of, it won\\'t matter, you can write parent[from]=to also, would not change since both are same rank\\n            parent[to]=from; \\n            rank[from]++;\\n        }\\n        return;\\n    }\\n    \\n    bool disConnected(int n){\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n                cnt++;\\n                if(cnt>1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    } \\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        parent.resize(n,0);\\n        rank.resize(n,0);\\n\\t\\t\\n        for(int i=0;i<n;i++){ //currently every node is a parent of itself\\n            parent[i]=i;\\n        }\\n        \\n        vector<int> indegree(n,0);\\n        for (int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1 && ++indegree[leftChild[i]]>1){\\n                return false;\\n            }\\n            if(rightChild[i]!=-1 && ++indegree[rightChild[i]]>1){\\n                return false;\\n            }\\n        }\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                if(root!=-1){\\n                    return false;\\n                }\\n                root=i;\\n            }\\n        }        \\n        if(root==-1){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(leftChild[i]==-1){\\n                continue;\\n            }\\n            merge(i,leftChild[i]);  // merge i and leftChild[i]\\n        }  \\n        \\n        for(int i=0;i<n;i++){\\n            if(rightChild[i]==-1){\\n                continue;\\n            }            \\n            merge(i,rightChild[i]); // merge i and rightChild[i]\\n        }\\n        \\n        return disConnected(n); //check if the tree is fully connected or are there some disconnected nodes\\n    }\\n};\\n```\\n\\n**THANK YOU**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverseTree(vector<int> &left, vector<int> &right, int root, vector<bool> &vis) {\\n        if(root==-1 || vis[root]==true){\\n            return;\\n        }\\n        vis[root]=true;\\n        traverseTree(left,right,left[root],vis);\\n        traverseTree(left,right,right[root],vis);\\n        return;\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> indegree(n,0);\\n        for (int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1 && ++indegree[leftChild[i]]>1){ //if incoming edges exceed 1, not possible\\n                return false;\\n            }\\n            if(rightChild[i]!=-1 && ++indegree[rightChild[i]]>1){\\n                return false;\\n            }\\n        }\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                if(root!=-1){  // we see more than 1 root, not possible, return false\\n                    return false;\\n                }\\n                root=i;\\n            }\\n        }        \\n        if(root==-1){  //if root is still -1 there is no root, return false\\n            return false;\\n        }\\n        vector<bool> vis(n,false);\\n        traverseTree(leftChild,rightChild,root,vis);\\n        for(auto e: vis){\\n            if(e==false){  //this node is left unvisited and hence not a valid tree, return false \\n                return false;\\n            }\\n        }\\n        return true; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        list<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for (int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1){\\n                if(++indegree[leftChild[i]]>1){\\n                    return false;\\n                }\\n                adj[i].push_back(leftChild[i]);\\n            } \\n            if(rightChild[i]!=-1){\\n                if(++indegree[rightChild[i]]>1){\\n                    return false;\\n                }\\n                adj[i].push_back(rightChild[i]);\\n            }\\n        }\\n        queue<int> q;\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                if(root!=-1){\\n                    return false;\\n                }\\n                q.push(i); // DEGREE 0 means its the root\\n                root=i;\\n            }\\n        }        \\n        if(root==-1){\\n            return false;\\n        }\\n        int cnt=0;\\n        while(!q.empty()){  //DOING TOPOLOGY SORT\\n            int x=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto nei: adj[x]){\\n                indegree[nei]--; // we came to this nei from its source, so this nei node one preNode has been traversed and hence reduce its dependency\\n                if(indegree[nei]==0){  // we have traversed every node which was pointing on nei and now we can take it in queue for furthur processing\\n                    q.push(nei);\\n                }\\n            }\\n        }\\n        return cnt==n; // through topology we traversed cnt nodes and if it is equal to given n nodes return true\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int findParent_PathCompression(int node){ // finds parent and also compresses path\\n        if(parent[node]==node){\\n            return parent[node];\\n        }\\n        return parent[node]=findParent_PathCompression(parent[node]);\\n    }\\n    \\n    void merge(int node1, int node2){  // union function, union by rank\\n        int from=findParent_PathCompression(node1);\\n        int to=findParent_PathCompression(node2);\\n        if(rank[to]<rank[from]){\\n            parent[to]=from;\\n        }\\n        else if(rank[from]<rank[to]){\\n            parent[from]=to;\\n        }\\n        else{\\n\\t\\t// since rank value for both is same, it does not matter whom you make parent and child of, it won\\'t matter, you can write parent[from]=to also, would not change since both are same rank\\n            parent[to]=from; \\n            rank[from]++;\\n        }\\n        return;\\n    }\\n    \\n    bool disConnected(int n){\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n                cnt++;\\n                if(cnt>1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    } \\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        parent.resize(n,0);\\n        rank.resize(n,0);\\n\\t\\t\\n        for(int i=0;i<n;i++){ //currently every node is a parent of itself\\n            parent[i]=i;\\n        }\\n        \\n        vector<int> indegree(n,0);\\n        for (int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1 && ++indegree[leftChild[i]]>1){\\n                return false;\\n            }\\n            if(rightChild[i]!=-1 && ++indegree[rightChild[i]]>1){\\n                return false;\\n            }\\n        }\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                if(root!=-1){\\n                    return false;\\n                }\\n                root=i;\\n            }\\n        }        \\n        if(root==-1){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(leftChild[i]==-1){\\n                continue;\\n            }\\n            merge(i,leftChild[i]);  // merge i and leftChild[i]\\n        }  \\n        \\n        for(int i=0;i<n;i++){\\n            if(rightChild[i]==-1){\\n                continue;\\n            }            \\n            merge(i,rightChild[i]); // merge i and rightChild[i]\\n        }\\n        \\n        return disConnected(n); //check if the tree is fully connected or are there some disconnected nodes\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536417,
                "title": "python3-union-find-counting-indegree-works-with-new-test-cases",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n)) \\n        self.count = n\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]    \\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px != py:\\n            self.count -= 1\\n            self.parent[px] = py    \\n            \\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        inDegree = [0] * n\\n        \\n        uf = UnionFind(n)\\n        for parent, nodes in enumerate(zip(leftChild, rightChild)):\\n            l, r = nodes\\n            if l != -1:\\n                inDegree[l] += 1 \\n                uf.union(l, parent)\\n                \\n            if r != -1:\\n                inDegree[r] += 1 \\n                uf.union(r, parent)\\n        \\n        return sum(inDegree) == n - 1 and uf.count == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n)) \\n        self.count = n\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]    \\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px != py:\\n            self.count -= 1\\n            self.parent[px] = py    \\n            \\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        inDegree = [0] * n\\n        \\n        uf = UnionFind(n)\\n        for parent, nodes in enumerate(zip(leftChild, rightChild)):\\n            l, r = nodes\\n            if l != -1:\\n                inDegree[l] += 1 \\n                uf.union(l, parent)\\n                \\n            if r != -1:\\n                inDegree[r] += 1 \\n                uf.union(r, parent)\\n        \\n        return sum(inDegree) == n - 1 and uf.count == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417289,
                "title": "cpp-dsu-union-find-path-compression-with-explanation-93-efficient",
                "content": "This Solution find Union Find (Disjoint Subset) allows only single root \\nwith Path Compression Time complexity is constant for disjoint subset\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int find(int i){\\n        if(i==parent[i])\\n            return i;\\n        return parent[i]=find(parent[i]); // path compression\\n    }\\n    \\n    void uni(int x,int y){ // this approach make time complexity better approx 93%\\n        if(rank[x]>rank[y])\\n            parent[y]=x;\\n        else if(rank[x]<rank[y])\\n            parent[x]=y;\\n        else{\\n            parent[y]=x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& left, vector<int>& right) {\\n        vector<int> node(n,0);\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            \\n            if(left[i]!=-1){\\n                node[left[i]]++;\\n                if(node[left[i]]>1) return false; // keep count of node if come more then 1 time\\n            }       //like in any order traversal one node should come only one time\\n            \\n            if(right[i]!=-1){\\n                node[right[i]]++;\\n                if(node[right[i]]>1) return false; //similarly with this\\n            }    \\n        }\\n        \\n        int psbl=-1,count=0;\\n        for(int i=0;i<n;i++){\\n            if(node[i]==0){ \\n                psbl=i;\\n                count++;\\n                if(count>1) return false; // if root node is more then 1\\n            }\\n        }\\n        \\n        if(psbl==-1) return false; //if no root found then false\\n        \\n        parent.resize(n,0);\\n        rank.resize(n,0); // for path compression\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0;i<n;i++){ // simple dijsoint subset approach\\n            int u=i,v=left[i],w=right[i]; // check for root,left,right in tree\\n            int x = find(u);\\n            if(v!=-1){\\n                int y = find(v);\\n                if(x!=y) uni(x,y);\\n            }\\n            if(w!=-1){\\n                int z = find(w);\\n                if(x!=z) uni(x,z);\\n            }\\n        }\\n        count=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n                count++;\\n                if(count>1) return false;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n\\nHope You like this approach Do Upvote the solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int find(int i){\\n        if(i==parent[i])\\n            return i;\\n        return parent[i]=find(parent[i]); // path compression\\n    }\\n    \\n    void uni(int x,int y){ // this approach make time complexity better approx 93%\\n        if(rank[x]>rank[y])\\n            parent[y]=x;\\n        else if(rank[x]<rank[y])\\n            parent[x]=y;\\n        else{\\n            parent[y]=x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& left, vector<int>& right) {\\n        vector<int> node(n,0);\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            \\n            if(left[i]!=-1){\\n                node[left[i]]++;\\n                if(node[left[i]]>1) return false; // keep count of node if come more then 1 time\\n            }       //like in any order traversal one node should come only one time\\n            \\n            if(right[i]!=-1){\\n                node[right[i]]++;\\n                if(node[right[i]]>1) return false; //similarly with this\\n            }    \\n        }\\n        \\n        int psbl=-1,count=0;\\n        for(int i=0;i<n;i++){\\n            if(node[i]==0){ \\n                psbl=i;\\n                count++;\\n                if(count>1) return false; // if root node is more then 1\\n            }\\n        }\\n        \\n        if(psbl==-1) return false; //if no root found then false\\n        \\n        parent.resize(n,0);\\n        rank.resize(n,0); // for path compression\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0;i<n;i++){ // simple dijsoint subset approach\\n            int u=i,v=left[i],w=right[i]; // check for root,left,right in tree\\n            int x = find(u);\\n            if(v!=-1){\\n                int y = find(v);\\n                if(x!=y) uni(x,y);\\n            }\\n            if(w!=-1){\\n                int z = find(w);\\n                if(x!=z) uni(x,z);\\n            }\\n        }\\n        count=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n                count++;\\n                if(count>1) return false;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436557,
                "title": "c-easy-clean-solution-fastest-0ms-detailed-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // Idea: A valid BT has each node with exactly one parent and exactly one node with no parent (root)\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        // map to keep count of no. of parent for each node\\n        vector<int> parentFreq(n);\\n        for (int i = 0; i < n; i++)\\n            if ((leftChild[i] >= 0 and ++parentFreq[leftChild[i]] > 1) or (rightChild[i] >= 0 and ++parentFreq[rightChild[i]] > 1))\\n                return false;\\n        // find root (if more than 1 root exist then return false)\\n        int root = -1;\\n        for (int i = 0; i < n; i++)\\n            if (!parentFreq[i]) {\\n                if (root == -1)\\n                    root = i;\\n                else return false;\\n            }\\n        // last IMP check: apply dfs on root to calculate total nodes in tree, it should be n\\n        // this check helps in handling the testcases: 4, [1,0,3,-1], [-1,-1,-1,-1]\\n        return countNodes(leftChild, rightChild, root) == n;\\n    }\\n    \\n    int countNodes(vector<int> &left, vector<int> &right, int root) {\\n        if (root == -1)\\n            return 0;\\n        return 1 + countNodes(left, right, left[root]) + countNodes(left, right, right[root]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Idea: A valid BT has each node with exactly one parent and exactly one node with no parent (root)\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        // map to keep count of no. of parent for each node\\n        vector<int> parentFreq(n);\\n        for (int i = 0; i < n; i++)\\n            if ((leftChild[i] >= 0 and ++parentFreq[leftChild[i]] > 1) or (rightChild[i] >= 0 and ++parentFreq[rightChild[i]] > 1))\\n                return false;\\n        // find root (if more than 1 root exist then return false)\\n        int root = -1;\\n        for (int i = 0; i < n; i++)\\n            if (!parentFreq[i]) {\\n                if (root == -1)\\n                    root = i;\\n                else return false;\\n            }\\n        // last IMP check: apply dfs on root to calculate total nodes in tree, it should be n\\n        // this check helps in handling the testcases: 4, [1,0,3,-1], [-1,-1,-1,-1]\\n        return countNodes(leftChild, rightChild, root) == n;\\n    }\\n    \\n    int countNodes(vector<int> &left, vector<int> &right, int root) {\\n        if (root == -1)\\n            return 0;\\n        return 1 + countNodes(left, right, left[root]) + countNodes(left, right, right[root]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393392,
                "title": "diagram-explained-clean-4-checks-single-parents-single-root-no-cycle-all-connected",
                "content": "## What defines a tree ? \\n ***1. every node has a single parent\\n 2. single root (only one node has NO parent)\\n 3. no cycle\\n 4. all nodes connected to each other (single component)***\\n\\nConditions (1.) and (2.) are seen in the example diagrams, let\\'s look at a testcase False for condition (3.) and (4.)\\n\\n```\\nTricky test case (cycle and not connected):\\n4\\n[1,-1,3,-1]\\n[2,-1,-1,-1]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3b2720fb-12d4-4119-9c83-0ce692253af9_1628519470.3081353.png)\\n\\n\\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        n = len(leftChild)\\n        \\n        # tree has 2 requirements\\n        # 1. every node has a single parent\\n        # 2. single root (only one node has NO parent)\\n        # 3. no cycle\\n        # 4. all nodes connected to each other (single component)\\n        \\n        parent = [-1] * n\\n        \\n        # checking condition (1. and 2.)\\n        for idx, (left, right) in enumerate(zip(leftChild, rightChild)):\\n            \\n            if left != -1:\\n                # FAILED: condition (1.)\\n                if parent[left] != -1: return False\\n                parent[left] = idx\\n                \\n            if right != -1:\\n                # FAILED: condition (1.)\\n                if parent[right] != -1: return False\\n                parent[right] = idx\\n        \\n        # FAILED condition (2.)\\n        if parent.count(-1) != 1: return False\\n            \\n        # checking condition (3. and 4.)\\n        vis = set()\\n        def dfs_has_cycle(u):\\n            if u in vis:\\n                return True\\n            else:\\n                vis.add(u)\\n            \\n            for kid in [leftChild[u], rightChild[u]]:\\n                if kid != -1:\\n                    if dfs_has_cycle(kid): return True\\n            \\n        # FAILED condition (3.) - found a cycle\\n        if dfs_has_cycle(parent.index(-1)): return False\\n        \\n        # FAILED condition (4.) - DFS did not visit all nodes!\\n        if len(vis) != n: return False\\n        \\n        # did not FAIL any condition, success ;)\\n        return True\\n\\n\"\"\"\\nTricky test case (cycle and not connected):\\n4\\n[1,-1,3,-1]\\n[2,-1,-1,-1]\\n\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nTricky test case (cycle and not connected):\\n4\\n[1,-1,3,-1]\\n[2,-1,-1,-1]\\n```\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        n = len(leftChild)\\n        \\n        # tree has 2 requirements\\n        # 1. every node has a single parent\\n        # 2. single root (only one node has NO parent)\\n        # 3. no cycle\\n        # 4. all nodes connected to each other (single component)\\n        \\n        parent = [-1] * n\\n        \\n        # checking condition (1. and 2.)\\n        for idx, (left, right) in enumerate(zip(leftChild, rightChild)):\\n            \\n            if left != -1:\\n                # FAILED: condition (1.)\\n                if parent[left] != -1: return False\\n                parent[left] = idx\\n                \\n            if right != -1:\\n                # FAILED: condition (1.)\\n                if parent[right] != -1: return False\\n                parent[right] = idx\\n        \\n        # FAILED condition (2.)\\n        if parent.count(-1) != 1: return False\\n            \\n        # checking condition (3. and 4.)\\n        vis = set()\\n        def dfs_has_cycle(u):\\n            if u in vis:\\n                return True\\n            else:\\n                vis.add(u)\\n            \\n            for kid in [leftChild[u], rightChild[u]]:\\n                if kid != -1:\\n                    if dfs_has_cycle(kid): return True\\n            \\n        # FAILED condition (3.) - found a cycle\\n        if dfs_has_cycle(parent.index(-1)): return False\\n        \\n        # FAILED condition (4.) - DFS did not visit all nodes!\\n        if len(vis) != n: return False\\n        \\n        # did not FAIL any condition, success ;)\\n        return True\\n\\n\"\"\"\\nTricky test case (cycle and not connected):\\n4\\n[1,-1,3,-1]\\n[2,-1,-1,-1]\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953836,
                "title": "union-find-c-solution",
                "content": "# Intuition\\nfor a valid binary tree, we need a root who has no parent and other nodes may have one parent. If we use union find ultimately you can notice as we keep on doing union , all nodes will have same parent as root. and if by chance any node is having two parent , it will be caught by simple check , that is both elements have same parent, if that\\'s so return false.\\n\\nand corner case is that check if all elements are in union, or check if all have parents.\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\n    vector<int>parent;\\n    public:\\n    DisjointSet(int n){\\n        parent.resize(n);\\n        for(int i=0; i<n; i++){\\n            parent[i]=i;\\n        }\\n    }\\n    int findUpar(int n){\\n        if(n==parent[n]){\\n            return n;\\n        }\\n        return parent[n]= findUpar(parent[n]);\\n    }\\n    void unionBySize(int x, int y){\\n        int px = findUpar(x);\\n        parent[y]=px;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        DisjointSet ds(n+1);\\n        for(int i=0; i<n; i++){\\n            if(leftChild[i]!=-1){\\n                if(ds.findUpar(i)==ds.findUpar(leftChild[i])){\\n                    return false;\\n                }\\n                else{\\n                    ds.unionBySize(i, leftChild[i]);\\n                }\\n            }\\n            if(rightChild[i]!=-1){\\n                if(ds.findUpar(i)==ds.findUpar(rightChild[i])){\\n                    return false;\\n                }\\n                else{\\n                    ds.unionBySize(i, rightChild[i]);\\n                }\\n            }\\n        }\\n        for(int i=0; i<(n-1); i++){\\n            if(ds.findUpar(i)!=ds.findUpar(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet{\\n    vector<int>parent;\\n    public:\\n    DisjointSet(int n){\\n        parent.resize(n);\\n        for(int i=0; i<n; i++){\\n            parent[i]=i;\\n        }\\n    }\\n    int findUpar(int n){\\n        if(n==parent[n]){\\n            return n;\\n        }\\n        return parent[n]= findUpar(parent[n]);\\n    }\\n    void unionBySize(int x, int y){\\n        int px = findUpar(x);\\n        parent[y]=px;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        DisjointSet ds(n+1);\\n        for(int i=0; i<n; i++){\\n            if(leftChild[i]!=-1){\\n                if(ds.findUpar(i)==ds.findUpar(leftChild[i])){\\n                    return false;\\n                }\\n                else{\\n                    ds.unionBySize(i, leftChild[i]);\\n                }\\n            }\\n            if(rightChild[i]!=-1){\\n                if(ds.findUpar(i)==ds.findUpar(rightChild[i])){\\n                    return false;\\n                }\\n                else{\\n                    ds.unionBySize(i, rightChild[i]);\\n                }\\n            }\\n        }\\n        for(int i=0; i<(n-1); i++){\\n            if(ds.findUpar(i)!=ds.findUpar(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517659,
                "title": "incorrect-solution-c-o-n-count-edges-and-parents-no-bfs-or-dfs",
                "content": "This following algorithm is incorrect for this problem. \\nThis algorithm will fail if the number of cycles is equal to the total number of all unconnected trees minus 1. \\nExample would be. \\n4\\n[ 1, 2, 3, 0]\\n[-1, -1, -1, -1]\\nThus, union find / dfs / bfs seems unavoidable. \\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int root=-1, edges=0;\\n        vector<int> parent(leftChild.size(),-1);\\n        for( int i=0; i<leftChild.size(); i++){\\n            if(leftChild[i]!=-1){\\n                edges++;\\n                if(parent[leftChild[i]]!=-1)    return false;// a node can be only 1 parent\\'s left child\\n                else    parent[leftChild[i]]=i;\\n            }\\n        }\\n        for( int i=0; i<rightChild.size(); i++){\\n            if(rightChild[i]!=-1){\\n                edges++;\\n                if(parent[rightChild[i]]!=-1&&parent[rightChild[i]]!=i) return false;// a node can have only 1 parent \\n                else    parent[rightChild[i]]=i;\\n            }\\n        }\\n        // there is 1 and only 1 root \\n        for( int i=0; i<parent.size(); i++){\\n            if(parent[i]==-1){\\n                if(root==-1)    root=i;\\n                else    return false;\\n            }\\n        }\\n        if(root==-1)    return false;\\n        \\n        return edges==leftChild.size()-1;// # edges == # nodes -1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int root=-1, edges=0;\\n        vector<int> parent(leftChild.size(),-1);\\n        for( int i=0; i<leftChild.size(); i++){\\n            if(leftChild[i]!=-1){\\n                edges++;\\n                if(parent[leftChild[i]]!=-1)    return false;// a node can be only 1 parent\\'s left child\\n                else    parent[leftChild[i]]=i;\\n            }\\n        }\\n        for( int i=0; i<rightChild.size(); i++){\\n            if(rightChild[i]!=-1){\\n                edges++;\\n                if(parent[rightChild[i]]!=-1&&parent[rightChild[i]]!=i) return false;// a node can have only 1 parent \\n                else    parent[rightChild[i]]=i;\\n            }\\n        }\\n        // there is 1 and only 1 root \\n        for( int i=0; i<parent.size(); i++){\\n            if(parent[i]==-1){\\n                if(root==-1)    root=i;\\n                else    return false;\\n            }\\n        }\\n        if(root==-1)    return false;\\n        \\n        return edges==leftChild.size()-1;// # edges == # nodes -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517558,
                "title": "java-easy-hashset-solution",
                "content": "connected hashset record the node that has a parrent.\\nIf the tree has loop or node has multiple parents, it will return false. (since we\\'ve already added it into hashset)\\nAt last, other than the root node, all nodes should be in the connected hashset. \\nEg: If there are separate 2 trees, it means there are 2 roots that do not have parent. So connected hashset size would less than n-1.\\n\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Set<Integer> connected = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                if(!connected.add(leftChild[i])) return false;\\n            }\\n            if (rightChild[i] != -1) {\\n                if (!connected.add(rightChild[i])) return false;\\n            }   \\n\\t\\t\\tif (leftChild[i] == -1 && rightChild[i] == -1 && !connected.isEmpty() && !connected.contains(i)) return false;  // add this line because @libofeng\\'s correction.\\n        }\\n        return connected.size() == n-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Set<Integer> connected = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                if(!connected.add(leftChild[i])) return false;\\n            }\\n            if (rightChild[i] != -1) {\\n                if (!connected.add(rightChild[i])) return false;\\n            }   \\n\\t\\t\\tif (leftChild[i] == -1 && rightChild[i] == -1 && !connected.isEmpty() && !connected.contains(i)) return false;  // add this line because @libofeng\\'s correction.\\n        }\\n        return connected.size() == n-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756553,
                "title": "clean-java-solution-using-union-find",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] left, int[] right) {\\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i; //every node is parent of itselt\\n        }\\n        for(int i = 0; i < n; i++) {\\n            int l = left[i];\\n            int r = right[i];\\n            int x = find(parent, i);\\n            if(l != -1) {\\n                int root = find(parent, l);\\n                if(root == x) return false; // left node already has a parent\\n                union(parent, i, l);\\n            }\\n            if(r != -1) {\\n                int root = find(parent, r); \\n                if(root == x) return false; // right node already has a parent\\n                union(parent, i, r);\\n            }\\n        }\\n        int root = find(parent, 0);\\n        for(int i = 1; i < n; i++) {\\n            int rootI = find(parent, i);\\n            if(root != rootI) return false; //Root of all node should be same - note the path compression\\n        }\\n        return true;\\n    }\\n    \\n    void union(int[] parent, int x, int y) {\\n        parent[y] = x;\\n    }\\n    \\n    int find(int[] parent, int x) {\\n        if(parent[x] != x) {\\n\\t\\t    //Path compression for faster parent search - this makes Tree root as parent of all nodes\\n            parent[x] = find(parent, parent[x]); \\n            return parent[x];\\n        }\\n        return x;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] left, int[] right) {\\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i; //every node is parent of itselt\\n        }\\n        for(int i = 0; i < n; i++) {\\n            int l = left[i];\\n            int r = right[i];\\n            int x = find(parent, i);\\n            if(l != -1) {\\n                int root = find(parent, l);\\n                if(root == x) return false; // left node already has a parent\\n                union(parent, i, l);\\n            }\\n            if(r != -1) {\\n                int root = find(parent, r); \\n                if(root == x) return false; // right node already has a parent\\n                union(parent, i, r);\\n            }\\n        }\\n        int root = find(parent, 0);\\n        for(int i = 1; i < n; i++) {\\n            int rootI = find(parent, i);\\n            if(root != rootI) return false; //Root of all node should be same - note the path compression\\n        }\\n        return true;\\n    }\\n    \\n    void union(int[] parent, int x, int y) {\\n        parent[y] = x;\\n    }\\n    \\n    int find(int[] parent, int x) {\\n        if(parent[x] != x) {\\n\\t\\t    //Path compression for faster parent search - this makes Tree root as parent of all nodes\\n            parent[x] = find(parent, parent[x]); \\n            return parent[x];\\n        }\\n        return x;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227025,
                "title": "c-bfs-solution-98-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n        vector<int> in(n, 0);\\n        \\n        for(int i=0; i<lc.size(); i++) {\\n            int l = lc[i], r = rc[i];\\n            \\n            if(l>=0) in[l]++;\\n            if(r>=0) in[r]++;\\n        }\\n        \\n        int root = -1;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(in[i]==0) {\\n                root = i;\\n                break;\\n            }\\n        }\\n        \\n        if(root==-1) return false;\\n        \\n        queue<int> q;\\n        int seen[n]; for(int i=0; i<n; i++) seen[i] = 0;\\n        \\n        q.push(root);\\n        seen[root] = 1;\\n        int vis = n-1;\\n        \\n        while(q.size()) {\\n            int cur = q.front(); q.pop();\\n            \\n            int left = lc[cur], right = rc[cur];\\n            \\n            if(left!=-1) {\\n                if(seen[left]) return false;\\n                vis--;\\n                seen[left] = 1;\\n                q.push(left);\\n            }\\n            \\n            if(right!=-1) {\\n                if(seen[right]) return false;\\n                vis--;\\n                seen[right] = 1;\\n                q.push(right);\\n            }\\n        }\\n        \\n        return vis == 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n        vector<int> in(n, 0);\\n        \\n        for(int i=0; i<lc.size(); i++) {\\n            int l = lc[i], r = rc[i];\\n            \\n            if(l>=0) in[l]++;\\n            if(r>=0) in[r]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 902246,
                "title": "python-simple-union-find-solution",
                "content": "```\\ndef validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n\\tUF = [-1 for _ in range(n)]\\n\\tdef find(x):\\n\\t\\tif UF[x] == -1:\\n\\t\\t\\treturn x\\n\\t\\tUF[x] = find(UF[x])\\n\\t\\treturn UF[x]\\n\\tdef union(x, y):\\n\\t\\troot_x, root_y = find(x), find(y)\\n\\t\\tif root_x == root_y:\\n\\t\\t\\treturn False\\n\\t\\tUF[root_x] = root_y\\n\\t\\treturn True\\n\\tfor i in range(n):\\n\\t\\tleft, right = leftChild[i], rightChild[i]\\n\\t\\tif left != -1:\\n\\t\\t\\tif not union(left, i):\\n\\t\\t\\t\\treturn False\\n\\t\\tif right != -1:\\n\\t\\t\\tif not union(right, i):\\n\\t\\t\\t\\treturn False\\n\\treturn sum(1 for x in UF if x == -1) == 1\\n```",
                "solutionTags": [],
                "code": "```\\ndef validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n\\tUF = [-1 for _ in range(n)]\\n\\tdef find(x):\\n\\t\\tif UF[x] == -1:\\n\\t\\t\\treturn x\\n\\t\\tUF[x] = find(UF[x])\\n\\t\\treturn UF[x]\\n\\tdef union(x, y):\\n\\t\\troot_x, root_y = find(x), find(y)\\n\\t\\tif root_x == root_y:\\n\\t\\t\\treturn False\\n\\t\\tUF[root_x] = root_y\\n\\t\\treturn True\\n\\tfor i in range(n):\\n\\t\\tleft, right = leftChild[i], rightChild[i]\\n\\t\\tif left != -1:\\n\\t\\t\\tif not union(left, i):\\n\\t\\t\\t\\treturn False\\n\\t\\tif right != -1:\\n\\t\\t\\tif not union(right, i):\\n\\t\\t\\t\\treturn False\\n\\treturn sum(1 for x in UF if x == -1) == 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 899238,
                "title": "simple-c-and-python-solution-with-explanation",
                "content": "Objective of the question is to validate binary tree node. This is not very clear by itself, so I have broken it down to understand better:\\nFrom all the given nodes, there should be possible to form only one tree. For this to happen we need to satisfy 2 things:\\n1. There should be only 1 root node (node without any parent nodes). **Reason** - More than one root node results in more than 1 tree which negative the requirements of the question.\\n![image](https://assets.leetcode.com/users/images/408f32e2-9a1e-4abf-9202-5004641464f6_1602975497.1424525.png)\\n2. Should satisfy requirements of a tree -\\n\\t2.a. Every Node should have only one parent. \\n\\t![image](https://assets.leetcode.com/users/images/bd9c7c02-8554-4464-a0fb-abf9ee14bc64_1602975512.3058274.png)\\n\\t2.b. There shouldn\\'t be any cycles\\n\\t![image](https://assets.leetcode.com/users/images/b9cfcab2-68ab-47cc-9f37-9f5218e9f7eb_1602975534.7547133.png)\\n\\nSo we shall solve the problem also in the same steps ie. first prove the 1st step and then use that to prove the second step.\\nI have added inline comments in the code to explain the 1st and 2nd step.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        std::vector<int> parents (n, 0);\\n        std::queue<int> nodes;\\n        std::unordered_set<int> seen;\\n\\t\\t// 1st step - Find parent and use that to find the root. The node without any parents will be the root.\\n        for (int i=0; i<n; ++i){\\n            if (leftChild[i] != -1)\\n                ++parents[leftChild[i]];\\n            if (rightChild[i] != -1)\\n                ++parents[rightChild[i]];\\n        }\\n        for (int i=0; i<n; ++i){\\n            if (parents[i] == 0){\\n                nodes.push(i);\\n            }\\n\\t\\t\\t// If is any node with more than 1 parent then that **negates 2.a**\\n            else if (parents[i] > 1){\\n                return false;\\n            }\\n        }\\n\\t\\t// If there is no root or more than 1 root then it **negates 1st** point.\\n        if (nodes.size() != 1)\\n            return false;\\n\\t\\t\\t\\n\\t\\t// Traverse the tree to prove **2.a** \\n        while(!nodes.empty()){\\n            int node = nodes.front(); nodes.pop();\\n            if (node == -1)\\n                continue;\\n\\t\\t\\t// If TRUE, then there is a cycle - negates 2.b\\n            if (seen.count(node) != 0)\\n                return false;\\n            seen.insert(node);\\n            nodes.push(leftChild[node]);\\n            nodes.push(rightChild[node]);\\n        }\\n        // checks if all the nodes are visited.\\n        return (seen.size() == n);\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        parents = [0] * n\\n\\t\\t#1st step - Find parent and use that to find the root. The node without any parents will be the root.\\n        for i in range(n):\\n            if leftChild[i] != -1:\\n                parents[leftChild[i]] += 1\\n            if rightChild[i] != -1:\\n                parents[rightChild[i]] += 1\\n        queue = []\\n\\t\\t# Find the root - node with 0 parents.\\n        for i in range(n):\\n            if not parents[i]:\\n                queue.append(i)\\n\\t\\t\\t# If is any node with more than 1 parent then that **negates 2.a**\\n            if parents[i] > 1:\\n                return False\\n\\t\\t# If there is no root or more than 1 root then it **negates 1st** point.\\n        if len(queue) != 1:\\n            return False\\n        seen = set()\\n\\t\\t\\n\\t\\t// Traverse the tree to prove **2.a** \\n        while(queue):\\n            node = queue.pop(0)\\n            if node == -1:\\n                continue\\n            elif node in seen:\\n                return False\\n            seen.add(node)\\n            queue.append(leftChild[node])\\n            queue.append(rightChild[node])\\n\\t\\t#checks if all the nodes are visited.\\n        return len(seen) == n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        std::vector<int> parents (n, 0);\\n        std::queue<int> nodes;\\n        std::unordered_set<int> seen;\\n\\t\\t// 1st step - Find parent and use that to find the root. The node without any parents will be the root.\\n        for (int i=0; i<n; ++i){\\n            if (leftChild[i] != -1)\\n                ++parents[leftChild[i]];\\n            if (rightChild[i] != -1)\\n                ++parents[rightChild[i]];\\n        }\\n        for (int i=0; i<n; ++i){\\n            if (parents[i] == 0){\\n                nodes.push(i);\\n            }\\n\\t\\t\\t// If is any node with more than 1 parent then that **negates 2.a**\\n            else if (parents[i] > 1){\\n                return false;\\n            }\\n        }\\n\\t\\t// If there is no root or more than 1 root then it **negates 1st** point.\\n        if (nodes.size() != 1)\\n            return false;\\n\\t\\t\\t\\n\\t\\t// Traverse the tree to prove **2.a** \\n        while(!nodes.empty()){\\n            int node = nodes.front(); nodes.pop();\\n            if (node == -1)\\n                continue;\\n\\t\\t\\t// If TRUE, then there is a cycle - negates 2.b\\n            if (seen.count(node) != 0)\\n                return false;\\n            seen.insert(node);\\n            nodes.push(leftChild[node]);\\n            nodes.push(rightChild[node]);\\n        }\\n        // checks if all the nodes are visited.\\n        return (seen.size() == n);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        parents = [0] * n\\n\\t\\t#1st step - Find parent and use that to find the root. The node without any parents will be the root.\\n        for i in range(n):\\n            if leftChild[i] != -1:\\n                parents[leftChild[i]] += 1\\n            if rightChild[i] != -1:\\n                parents[rightChild[i]] += 1\\n        queue = []\\n\\t\\t# Find the root - node with 0 parents.\\n        for i in range(n):\\n            if not parents[i]:\\n                queue.append(i)\\n\\t\\t\\t# If is any node with more than 1 parent then that **negates 2.a**\\n            if parents[i] > 1:\\n                return False\\n\\t\\t# If there is no root or more than 1 root then it **negates 1st** point.\\n        if len(queue) != 1:\\n            return False\\n        seen = set()\\n\\t\\t\\n\\t\\t// Traverse the tree to prove **2.a** \\n        while(queue):\\n            node = queue.pop(0)\\n            if node == -1:\\n                continue\\n            elif node in seen:\\n                return False\\n            seen.add(node)\\n            queue.append(leftChild[node])\\n            queue.append(rightChild[node])\\n\\t\\t#checks if all the nodes are visited.\\n        return len(seen) == n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639971,
                "title": "python3-find-root-dfs-validate-binary-tree-nodes",
                "content": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n\\t    parent = {}\\n        for p, children in enumerate(zip(leftChild, rightChild)):\\n            for c in children:\\n                if c == -1:\\n                    continue\\n                if c in parent:\\n                    return False\\n                if p in parent and parent[p] == c:\\n                    return False\\n                parent[c] = p\\n        root = set(range(n)) - set(parent.keys())\\n        if len(root) != 1:\\n            return False\\n        def count(root):\\n            if root == -1:\\n                return 0\\n            return 1 + count(leftChild[root]) + count(rightChild[root])\\n        return count(root.pop()) == n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n\\t    parent = {}\\n        for p, children in enumerate(zip(leftChild, rightChild)):\\n            for c in children:\\n                if c == -1:\\n                    continue\\n                if c in parent:\\n                    return False\\n                if p in parent and parent[p] == c:\\n                    return False\\n                parent[c] = p\\n        root = set(range(n)) - set(parent.keys())\\n        if len(root) != 1:\\n            return False\\n        def count(root):\\n            if root == -1:\\n                return 0\\n            return 1 + count(leftChild[root]) + count(rightChild[root])\\n        return count(root.pop()) == n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530368,
                "title": "java-find-root-bfs",
                "content": "```java\\nclass Solution {\\n    \\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        Set<Integer> visited = new HashSet();\\n        Queue<Integer> queue = new LinkedList();\\n        \\n        Set<Integer> indegree = new HashSet();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            indegree.add(leftChild[i]);\\n            indegree.add(rightChild[i]);\\n        }\\n        \\n        int root = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (!indegree.contains(i)) {\\n                root = i;\\n                break;\\n            }\\n        }\\n        \\n        if (root == -1) return false;\\n        \\n        queue.offer(root);\\n        \\n        while (!queue.isEmpty()) {\\n            Integer current = queue.poll();\\n            if (visited.contains(current)) return false;\\n            visited.add(current);\\n            if (leftChild[current] != -1) queue.offer(leftChild[current]);\\n            if (rightChild[current] != -1) queue.offer(rightChild[current]);\\n        }\\n        \\n        return visited.size() == n;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        Set<Integer> visited = new HashSet();\\n        Queue<Integer> queue = new LinkedList();\\n        \\n        Set<Integer> indegree = new HashSet();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            indegree.add(leftChild[i]);\\n            indegree.add(rightChild[i]);\\n        }\\n        \\n        int root = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (!indegree.contains(i)) {\\n                root = i;\\n                break;\\n            }\\n        }\\n        \\n        if (root == -1) return false;\\n        \\n        queue.offer(root);\\n        \\n        while (!queue.isEmpty()) {\\n            Integer current = queue.poll();\\n            if (visited.contains(current)) return false;\\n            visited.add(current);\\n            if (leftChild[current] != -1) queue.offer(leftChild[current]);\\n            if (rightChild[current] != -1) queue.offer(rightChild[current]);\\n        }\\n        \\n        return visited.size() == n;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517747,
                "title": "easy-understanding-explained-with-comments",
                "content": "```\\n public static boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        HashSet<Integer> num = new HashSet<>();// to maintain parent\\n        Queue<Integer> q = new LinkedList<>();// to perform BFS\\n        num.add(0);\\n        q.add(0);\\n        int size = 0;//to check we can reach all the node\\n        while (!q.isEmpty()) {\\n            size++;\\n            int i = q.poll();\\n            if (leftChild[i] != -1) {\\n                if (num.contains(leftChild[i])) return false;// child to parent is invalid\\n                num.add(leftChild[i]);\\n                q.add(leftChild[i]);\\n            }\\n            if (rightChild[i] != -1) {\\n                if (num.contains(rightChild[i])) return false;// child to parent is invalid\\n                num.add(rightChild[i]);\\n                q.add(rightChild[i]);\\n            }\\n\\n        }\\n        return size == n;//after all success full iteration and size == n means that all node is reachable\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public static boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        HashSet<Integer> num = new HashSet<>();// to maintain parent\\n        Queue<Integer> q = new LinkedList<>();// to perform BFS\\n        num.add(0);\\n        q.add(0);\\n        int size = 0;//to check we can reach all the node\\n        while (!q.isEmpty()) {\\n            size++;\\n            int i = q.poll();\\n            if (leftChild[i] != -1) {\\n                if (num.contains(leftChild[i])) return false;// child to parent is invalid\\n                num.add(leftChild[i]);\\n                q.add(leftChild[i]);\\n            }\\n            if (rightChild[i] != -1) {\\n                if (num.contains(rightChild[i])) return false;// child to parent is invalid\\n                num.add(rightChild[i]);\\n                q.add(rightChild[i]);\\n            }\\n\\n        }\\n        return size == n;//after all success full iteration and size == n means that all node is reachable\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484653,
                "title": "dfs-solution-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) find the root node (from which you start the dfs) using an indegree array\\n2) start dfs from the root and if a node is already visited (a cycle) then return false\\n3) after completing the dfs check if all nodes are visited, otherwise (there exist 2 or more components) return false ;\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool dfs(int node, vector<int>&leftChild, vector<int>&rightChild, vector<bool>&visit){\\n        int n = leftChild.size() ;\\n        if(node == -1) return true ;\\n        if(visit[node]) return false;\\n        visit[node] = true ;\\n        int leftNode, rightNode ;\\n        leftNode = leftChild[node] ;\\n        rightNode = rightChild[node] ;\\n        return dfs(leftNode, leftChild, rightChild, visit) && dfs(rightNode, leftChild, rightChild, visit) ;\\n    }\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<bool>visit(n+1, false) ;\\n        vector<int>indegree(n,0) ;\\n        for(int i=0; i<n; i++){\\n            int leftNode = leftChild[i], rightNode = rightChild[i] ;\\n            if(leftNode != -1) indegree[leftNode]++ ;\\n            if(rightNode != -1) indegree[rightNode]++ ;\\n        }\\n        int root = -1 ;\\n        for(int i = 0; i<n ; i++) if(indegree[i] == 0) root = i ;\\n        if(root == -1) return false ;\\n        bool ok = dfs(root, leftChild, rightChild, visit) ;\\n        for(int i =0; i< n; i++) if(!visit[i]) return false ; \\n        return ok ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(int node, vector<int>&leftChild, vector<int>&rightChild, vector<bool>&visit){\\n        int n = leftChild.size() ;\\n        if(node == -1) return true ;\\n        if(visit[node]) return false;\\n        visit[node] = true ;\\n        int leftNode, rightNode ;\\n        leftNode = leftChild[node] ;\\n        rightNode = rightChild[node] ;\\n        return dfs(leftNode, leftChild, rightChild, visit) && dfs(rightNode, leftChild, rightChild, visit) ;\\n    }\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<bool>visit(n+1, false) ;\\n        vector<int>indegree(n,0) ;\\n        for(int i=0; i<n; i++){\\n            int leftNode = leftChild[i], rightNode = rightChild[i] ;\\n            if(leftNode != -1) indegree[leftNode]++ ;\\n            if(rightNode != -1) indegree[rightNode]++ ;\\n        }\\n        int root = -1 ;\\n        for(int i = 0; i<n ; i++) if(indegree[i] == 0) root = i ;\\n        if(root == -1) return false ;\\n        bool ok = dfs(root, leftChild, rightChild, visit) ;\\n        for(int i =0; i< n; i++) if(!visit[i]) return false ; \\n        return ok ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823576,
                "title": "c-solution-finding-the-indegree-of-nodes",
                "content": "# Approach\\n\\nThe given binary tree is valid iff there is only one root for the tree (the problem requires this condition to be satisfied)\\n\\nThe inDegree of the root node (the number of nodes directing to the root node) must be zero (by definition)\\n\\nFor the binary tree to be valid, the inDegree of the nodes other than the root node must be 1 for it to form a valid binary tree\\n\\nSo we calculate inDegrees for all the nodes in the tree and there must be exactly one node with inDegree = 0 (root node) and rest of the (n - 1) nodes must have an inDegree of 1\\n\\nAfter this condition is satisfied, it is required that from the root node, all the other nodes must be reachable i.e, the count of the nodes reached from the root node should be equal to the total number of nodes given i.e. n\\n\\nIf the count is equal to n, the tree is valid, else invalid\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int node, vector <int> &leftChild, vector <int> &rightChild) {\\n        if(node == -1)\\n            return 0;\\n        return 1 + solve(leftChild[node], leftChild, rightChild) + solve(rightChild[node], leftChild, rightChild);\\n    }\\n\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector <int> inDegree(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            if(leftChild[i] != -1)\\n                inDegree[leftChild[i]]++;\\n            if(rightChild[i] != -1)\\n                inDegree[rightChild[i]]++;\\n        }\\n\\n        int a1 = 0, a2 = 0, root = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0)\\n                a1++, root = i;\\n            else if(inDegree[i] == 1)\\n                a2++;\\n        }\\n\\n        if(a1 != 1 || a2 != (n - 1))\\n            return false;\\n\\n        int ans = solve(root, leftChild, rightChild);\\n        return (ans == n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(int node, vector <int> &leftChild, vector <int> &rightChild) {\\n        if(node == -1)\\n            return 0;\\n        return 1 + solve(leftChild[node], leftChild, rightChild) + solve(rightChild[node], leftChild, rightChild);\\n    }\\n\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector <int> inDegree(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            if(leftChild[i] != -1)\\n                inDegree[leftChild[i]]++;\\n            if(rightChild[i] != -1)\\n                inDegree[rightChild[i]]++;\\n        }\\n\\n        int a1 = 0, a2 = 0, root = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0)\\n                a1++, root = i;\\n            else if(inDegree[i] == 1)\\n                a2++;\\n        }\\n\\n        if(a1 != 1 || a2 != (n - 1))\\n            return false;\\n\\n        int ans = solve(root, leftChild, rightChild);\\n        return (ans == n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617015,
                "title": "c-clear-explanation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<bool>visited;\\n    \\n    void dfs(int u,vector<int>&leftChild,vector<int>&rightChild)\\n    {\\n        \\n        if(visited[u]) return;\\n        \\n        visited[u] = true;\\n        \\n        if(leftChild[u]!=-1) dfs(leftChild[u],leftChild,rightChild);\\n        \\n        if(rightChild[u]!=-1) dfs(rightChild[u],leftChild,rightChild);\\n        \\n    }    \\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n        visited.resize(n,false);\\n        \\n        vector<int>indegree(n,0);\\n        \\n        for(int i=0;i<n;++i){\\n            if(leftChild[i]!=-1){\\n                indegree[leftChild[i]]++;\\n            }\\n            if(rightChild[i]!=-1){\\n                indegree[rightChild[i]]++;\\n            }\\n        }\\n        \\n        // For a valid directed tree , except root every node must have exactly one indegree //\\n        \\n        for(int i=0;i<n;++i){\\n            if(indegree[i]>=2){\\n                return false;\\n            }\\n        }\\n        \\n        int root_cnt=0;\\n        \\n        // Check how many potential candidates are present over there for being a root node , if it is more than one then return false //\\n        \\n        int root_node = -1;\\n        \\n        for(int i=0;i<n;++i){\\n            if(indegree[i]==0){\\n                root_cnt++;\\n                root_node = i;\\n            }\\n        }\\n        \\n        if(root_cnt!=1) return false;\\n        \\n        // Finally ,we should take care about disconnected tree , for doing these just do a simple dfs traversal from the current root node and if at the end of dfs traversal , all the nodes are visited , then it is a valid tree //\\n        \\n        dfs(root_node,leftChild,rightChild);\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            if(!visited[i]) return false;\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<bool>visited;\\n    \\n    void dfs(int u,vector<int>&leftChild,vector<int>&rightChild)\\n    {\\n        \\n        if(visited[u]) return;\\n        \\n        visited[u] = true;\\n        \\n        if(leftChild[u]!=-1) dfs(leftChild[u],leftChild,rightChild);\\n        \\n        if(rightChild[u]!=-1) dfs(rightChild[u],leftChild,rightChild);\\n        \\n    }    \\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n        visited.resize(n,false);\\n        \\n        vector<int>indegree(n,0);\\n        \\n        for(int i=0;i<n;++i){\\n            if(leftChild[i]!=-1){\\n                indegree[leftChild[i]]++;\\n            }\\n            if(rightChild[i]!=-1){\\n                indegree[rightChild[i]]++;\\n            }\\n        }\\n        \\n        // For a valid directed tree , except root every node must have exactly one indegree //\\n        \\n        for(int i=0;i<n;++i){\\n            if(indegree[i]>=2){\\n                return false;\\n            }\\n        }\\n        \\n        int root_cnt=0;\\n        \\n        // Check how many potential candidates are present over there for being a root node , if it is more than one then return false //\\n        \\n        int root_node = -1;\\n        \\n        for(int i=0;i<n;++i){\\n            if(indegree[i]==0){\\n                root_cnt++;\\n                root_node = i;\\n            }\\n        }\\n        \\n        if(root_cnt!=1) return false;\\n        \\n        // Finally ,we should take care about disconnected tree , for doing these just do a simple dfs traversal from the current root node and if at the end of dfs traversal , all the nodes are visited , then it is a valid tree //\\n        \\n        dfs(root_node,leftChild,rightChild);\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            if(!visited[i]) return false;\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322086,
                "title": "python3-find-root-and-do-bfs",
                "content": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        # Get all the children in the tree\\n        childs = set(leftChild + rightChild)\\n        root = 0\\n        # The element which is not in childs set is the root element\\n        for i in range(n):\\n            if i not in childs:\\n                root = i\\n                break\\n        # Do a BFS on the tree and keep track of nodes we visit\\n        visited = []\\n        queue = [root]\\n        while queue:\\n            ele = queue.pop(0)\\n            # If the element is already visited, it means it\\'s not a tree\\n            if ele in visited:\\n                return False\\n            \\n            visited.append(ele)\\n            # If node has left child, add it to queue\\n            if leftChild[ele] != -1:\\n                queue.append(leftChild[ele])\\n            # If node has right child, add it to queue\\n            if rightChild[ele] != -1:\\n                queue.append(rightChild[ele])\\n                \\n        # At the end, if all the nodes (n) are visited, it means it\\'s a tree\\n        return len(visited) == n\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        # Get all the children in the tree\\n        childs = set(leftChild + rightChild)\\n        root = 0\\n        # The element which is not in childs set is the root element\\n        for i in range(n):\\n            if i not in childs:\\n                root = i\\n                break\\n        # Do a BFS on the tree and keep track of nodes we visit\\n        visited = []\\n        queue = [root]\\n        while queue:\\n            ele = queue.pop(0)\\n            # If the element is already visited, it means it\\'s not a tree\\n            if ele in visited:\\n                return False\\n            \\n            visited.append(ele)\\n            # If node has left child, add it to queue\\n            if leftChild[ele] != -1:\\n                queue.append(leftChild[ele])\\n            # If node has right child, add it to queue\\n            if rightChild[ele] != -1:\\n                queue.append(rightChild[ele])\\n                \\n        # At the end, if all the nodes (n) are visited, it means it\\'s a tree\\n        return len(visited) == n\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739034,
                "title": "c-without-making-graph",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& l, vector<int>& r,vector<int>& vis,int ind){\\n        if(ind==-1) return;\\n        vis[ind]=1;\\n        dfs(l,r,vis,l[ind]);\\n        dfs(l,r,vis,r[ind]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vector<int>par(n,-1);           // vector for storing parent of nodes\\n        for(int i=0;i<n;i++){\\n            if(l[i]!=-1&&par[l[i]]!=-1) return false;                //if a node has 2 parents\\n            if(r[i]!=-1&&par[r[i]]!=-1) return false;                //if a node has 2 parents\\n            if(l[i]!=-1) par[l[i]]=i;\\n            if(r[i]!=-1) par[r[i]]=i;\\n        }\\n        int flag=0;\\n        int ind=-1;\\n        for(int i=0;i<n;i++){\\n            if(par[i]==-1){ind=i;flag++;}           //ind will store parent node\\n            if(flag>1) return false;                   //if tree has more than one parent\\n        }\\n        if(flag==0) return false;    //if it has 0 parent\\n\\t\\t\\n        vector<int> vis(n);\\n        dfs(l,r,vis,ind);          //dfs from parent node\\n\\t\\t\\n        for(auto i:vis) {\\n            if(i==0) return false;              //checking if there is any unvisited node after applying dfs\\n        }\\n\\t\\t\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(vector<int>& l, vector<int>& r,vector<int>& vis,int ind){\\n        if(ind==-1) return;\\n        vis[ind]=1;\\n        dfs(l,r,vis,l[ind]);\\n        dfs(l,r,vis,r[ind]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1625191,
                "title": "python-o-n-by-dfs-bfs-unionfind-w-comment",
                "content": "**Hint**:\\n\\n#1 First approach\\n\\nWhen it comes to **binary tree**, think of **BFS traversal with queue** as well as **DFS with stack**.\\n\\nAnd remember **cycle path is NOT allowed** in binary tree.\\n\\n---\\n\\n#2 Second approach\\n\\nThink of **union-find**, aka **disjoint set**, data structure.\\n\\nAfter union all parent and child pair, there is **one independent set with root node as single source**, if given graph is valid binary tree.\\n\\nAgain, use the property that **cycle path is NOT allowed** in binary tree to judge given graph is valid or not.\\n\\n---\\n\\n**Implementation** by BFS with queue:\\n\\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        # Definition of NULL (i.e., empty node), given by description\\n        NULL = -1\\n        \\n        # --------------------------------------------------------------\\n        def find_root():\\n            \\n            children = set(leftChild) | set(rightChild)\\n\\n            # search for root node, root node is not a child node always.\\n            for i in range(n):\\n                if i not in children:\\n                    return i\\n            \\n            return NULL\\n        \\n        # --------------------------------------------------------------\\n        \\n        root = find_root()\\n        \\n        if root == NULL:\\n            # Reject, because root doesn\\'t exist\\n            return False\\n        \\n        \\n        \\n        # launch BFS to given graph\\n        queue = deque([root])\\n        visited = set()\\n        \\n        while queue:\\n            \\n            cur = queue.popleft()\\n            \\n            if cur in visited:\\n                \\n                # Reject, because there is a cycle\\n                # Cycle is not allowed in binary tree\\n                return False\\n            \\n            visited.add(cur)\\n            \\n            if leftChild[cur] != NULL:\\n                queue.append( leftChild[cur] )\\n                \\n            if rightChild[cur] != NULL:\\n                queue.append( rightChild[cur] )\\n        \\n        \\n        # BFS in binary tree must visit n nodes exactly, without repetition.\\n        return len(visited) == n\\n```\\n\\n---\\n\\n**Implementation** by DFS with stack:\\n\\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        # Definition of NULL (i.e., empty node), given by description\\n        NULL = -1\\n        \\n        # --------------------------------------------------------------\\n        def find_root():\\n            \\n            children = set(leftChild) | set(rightChild)\\n\\n            # search for root node, root node is not a child node always.\\n            for i in range(n):\\n                if i not in children:\\n                    return i\\n            \\n            return NULL\\n        \\n        # --------------------------------------------------------------\\n        \\n        root = find_root()\\n        \\n        if root == NULL:\\n            # Reject, because root doesn\\'t exist\\n            return False\\n        \\n        # launch DFS to given graph\\n        stack = [root]\\n        visited = set()\\n        \\n        while stack:\\n            \\n            cur = stack.pop()\\n            \\n            if cur in visited:\\n                \\n                # Reject, because there is a cycle\\n                # Cycle is not allowed in binary tree\\n                return False\\n            \\n            visited.add( cur )\\n            \\n            if leftChild[cur] != NULL:\\n                stack.append( leftChild[cur] )\\n            \\n            if rightChild[cur] != NULL:\\n                stack.append( rightChild[cur] )\\n                \\n        # DFS in binary tree must visit n nodes exactly, without repetition.\\n        return len(visited) == n\\n```\\n\\n---\\n\\n**Implementation** by Union-find, aka Disjoint set:\\n\\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        class DisjointSet():\\n            \\n            def __init__(self, init_size):\\n                \\n                self.init_size = init_size\\n                \\n                ## dictionary\\n                # key: child node\\n                # value: parent node\\n                self.parent = { i: i for i in range(init_size) }\\n                \\n                ## dictionary\\n                # key: node idx\\n                # value: size of current set with given node idx\\n                self.set_size = { i: 1 for i in range(init_size) }\\n                \\n                # counter of independent set\\n                self.count = init_size\\n                \\n            \\n            def find(self, x):\\n                \\n                # path compression in findind parent\\n                if self.parent[x] != x:\\n                    self.parent[x] = self.find(self.parent[x])\\n                \\n                return self.parent[x]\\n            \\n            \\n            def union(self, x, y):\\n                \\n                parent_of_x, parent_of_y = self.find(x), self.find(y)\\n                \\n                if parent_of_x == parent_of_y:\\n                    \\n                    # Invalid operation, both x and y have the same parent, in binary tree, before union\\n                    return False\\n                \\n                else:\\n                    # set x as parent of y\\n                    self.parent[parent_of_y] = parent_of_x\\n                    \\n                    # update set size\\n                    self.set_size[parent_of_x] += self.set_size[parent_of_y]\\n                    \\n\\n                    # update counter of independent set\\n                    self.count -= 1\\n                    \\n                    # Valid operation\\n                    return True\\n            \\n            \\n            def count_of_independent_set(self):\\n                return self.count\\n            \\n            def only_one_root(self):\\n                return self.count_of_independent_set() == 1\\n            \\n            def already_assign_to_parent(self, x):\\n                return self.find(x) != x\\n            \\n        # --------------------------------------------------------\\n        \\n        NULL = -1\\n        \\n        def update(child_sequence):\\n            \\n            # check each parent <-> child pair\\n            for parent, child in enumerate(child_sequence):\\n            \\n                if child != NULL:\\n                    \\n                    if Nodes.already_assign_to_parent(child):\\n                    \\n                        # Reject, due to assign two different parents for single child node\\n                        return False\\n\\n                    \\n                    # Try to assign parent to current child node\\n                    if not Nodes.union(parent, child):\\n                        \\n                        # Reject, due to forms a cycle in binary tree\\n                        return False\\n                    \\n                    \\n            return True        \\n        # --------------------------------------------------------\\n\\n        Nodes = DisjointSet(n)\\n        return all( [update(leftChild), update(rightChild), Nodes.only_one_root() ] )\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1] [Leetcode #102 Binary Tree Level order traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\\n\\n[2] [Leetcode #94 Binary Tree inorder traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\\n\\n[3] [Leetcode #684 Redundant connection](https://leetcode.com/problems/redundant-connection/)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        # Definition of NULL (i.e., empty node), given by description\\n        NULL = -1\\n        \\n        # --------------------------------------------------------------\\n        def find_root():\\n            \\n            children = set(leftChild) | set(rightChild)\\n\\n            # search for root node, root node is not a child node always.\\n            for i in range(n):\\n                if i not in children:\\n                    return i\\n            \\n            return NULL\\n        \\n        # --------------------------------------------------------------\\n        \\n        root = find_root()\\n        \\n        if root == NULL:\\n            # Reject, because root doesn\\'t exist\\n            return False\\n        \\n        \\n        \\n        # launch BFS to given graph\\n        queue = deque([root])\\n        visited = set()\\n        \\n        while queue:\\n            \\n            cur = queue.popleft()\\n            \\n            if cur in visited:\\n                \\n                # Reject, because there is a cycle\\n                # Cycle is not allowed in binary tree\\n                return False\\n            \\n            visited.add(cur)\\n            \\n            if leftChild[cur] != NULL:\\n                queue.append( leftChild[cur] )\\n                \\n            if rightChild[cur] != NULL:\\n                queue.append( rightChild[cur] )\\n        \\n        \\n        # BFS in binary tree must visit n nodes exactly, without repetition.\\n        return len(visited) == n\\n```\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        # Definition of NULL (i.e., empty node), given by description\\n        NULL = -1\\n        \\n        # --------------------------------------------------------------\\n        def find_root():\\n            \\n            children = set(leftChild) | set(rightChild)\\n\\n            # search for root node, root node is not a child node always.\\n            for i in range(n):\\n                if i not in children:\\n                    return i\\n            \\n            return NULL\\n        \\n        # --------------------------------------------------------------\\n        \\n        root = find_root()\\n        \\n        if root == NULL:\\n            # Reject, because root doesn\\'t exist\\n            return False\\n        \\n        # launch DFS to given graph\\n        stack = [root]\\n        visited = set()\\n        \\n        while stack:\\n            \\n            cur = stack.pop()\\n            \\n            if cur in visited:\\n                \\n                # Reject, because there is a cycle\\n                # Cycle is not allowed in binary tree\\n                return False\\n            \\n            visited.add( cur )\\n            \\n            if leftChild[cur] != NULL:\\n                stack.append( leftChild[cur] )\\n            \\n            if rightChild[cur] != NULL:\\n                stack.append( rightChild[cur] )\\n                \\n        # DFS in binary tree must visit n nodes exactly, without repetition.\\n        return len(visited) == n\\n```\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        class DisjointSet():\\n            \\n            def __init__(self, init_size):\\n                \\n                self.init_size = init_size\\n                \\n                ## dictionary\\n                # key: child node\\n                # value: parent node\\n                self.parent = { i: i for i in range(init_size) }\\n                \\n                ## dictionary\\n                # key: node idx\\n                # value: size of current set with given node idx\\n                self.set_size = { i: 1 for i in range(init_size) }\\n                \\n                # counter of independent set\\n                self.count = init_size\\n                \\n            \\n            def find(self, x):\\n                \\n                # path compression in findind parent\\n                if self.parent[x] != x:\\n                    self.parent[x] = self.find(self.parent[x])\\n                \\n                return self.parent[x]\\n            \\n            \\n            def union(self, x, y):\\n                \\n                parent_of_x, parent_of_y = self.find(x), self.find(y)\\n                \\n                if parent_of_x == parent_of_y:\\n                    \\n                    # Invalid operation, both x and y have the same parent, in binary tree, before union\\n                    return False\\n                \\n                else:\\n                    # set x as parent of y\\n                    self.parent[parent_of_y] = parent_of_x\\n                    \\n                    # update set size\\n                    self.set_size[parent_of_x] += self.set_size[parent_of_y]\\n                    \\n\\n                    # update counter of independent set\\n                    self.count -= 1\\n                    \\n                    # Valid operation\\n                    return True\\n            \\n            \\n            def count_of_independent_set(self):\\n                return self.count\\n            \\n            def only_one_root(self):\\n                return self.count_of_independent_set() == 1\\n            \\n            def already_assign_to_parent(self, x):\\n                return self.find(x) != x\\n            \\n        # --------------------------------------------------------\\n        \\n        NULL = -1\\n        \\n        def update(child_sequence):\\n            \\n            # check each parent <-> child pair\\n            for parent, child in enumerate(child_sequence):\\n            \\n                if child != NULL:\\n                    \\n                    if Nodes.already_assign_to_parent(child):\\n                    \\n                        # Reject, due to assign two different parents for single child node\\n                        return False\\n\\n                    \\n                    # Try to assign parent to current child node\\n                    if not Nodes.union(parent, child):\\n                        \\n                        # Reject, due to forms a cycle in binary tree\\n                        return False\\n                    \\n                    \\n            return True        \\n        # --------------------------------------------------------\\n\\n        Nodes = DisjointSet(n)\\n        return all( [update(leftChild), update(rightChild), Nodes.only_one_root() ] )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618507,
                "title": "c-2-properties",
                "content": "1. `indegree(root)` = 0 and `indegree(x)` = 1 for  each `x` != `root` \\n2. no cycle\\n\\nother properties:\\n\\n- exact n - 1 edges (covered by 1.)\\n- exact 1 tree (covered by above three properties)\\n\\nedge cases:\\n- 0 -> 1, 0 -> 2, 1 -> 3, 2 -> 3     (handle by 1.)\\n- cycle -> (handle by 2)\\n- 0 -> 1, 1 -> 0 (handle by 1.)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& left, vector<int>& right) {\\n        vector<int> indeg(n + 1);\\n        \\n        for (int i = 0; i < n; i++) {\\n            indeg[left[i] + 1]++;\\n            indeg[right[i] + 1]++;\\n        }\\n                          \\n        int one_cnt = count(indeg.begin() + 1, indeg.end(), 1);\\n        int zero_cnt = count(indeg.begin() + 1, indeg.end(), 0);\\n                          \\n        if (one_cnt != n - 1 || zero_cnt != 1)\\n            return false;\\n        \\n        int root = (find(indeg.begin() + 1, indeg.end(), 0) - indeg.begin()) - 1;               \\n        queue<int> q{{root}};\\n        \\n        int cnt = 0;\\n        for (; !q.empty() && cnt < n; cnt++) {\\n            int cur = q.front();\\n            q.pop();\\n            for (int nbr : {left[cur], right[cur]}) {\\n                if (nbr >= 0) {\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        \\n        return q.empty() && cnt == n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& left, vector<int>& right) {\\n        vector<int> indeg(n + 1);\\n        \\n        for (int i = 0; i < n; i++) {\\n            indeg[left[i] + 1]++;\\n            indeg[right[i] + 1]++;\\n        }\\n                          \\n        int one_cnt = count(indeg.begin() + 1, indeg.end(), 1);\\n        int zero_cnt = count(indeg.begin() + 1, indeg.end(), 0);\\n                          \\n        if (one_cnt != n - 1 || zero_cnt != 1)\\n            return false;\\n        \\n        int root = (find(indeg.begin() + 1, indeg.end(), 0) - indeg.begin()) - 1;               \\n        queue<int> q{{root}};\\n        \\n        int cnt = 0;\\n        for (; !q.empty() && cnt < n; cnt++) {\\n            int cur = q.front();\\n            q.pop();\\n            for (int nbr : {left[cur], right[cur]}) {\\n                if (nbr >= 0) {\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        \\n        return q.empty() && cnt == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217878,
                "title": "easy-c-solution-with-explanation",
                "content": "Check for 3 things:\\n1. One root (using indegree)\\n2. No bidirectional edge or cycle (using dfs)\\n3. One connected components (using visited array)\\n\\n```\\nclass Solution {\\npublic:\\n    int flag = 0;\\n\\n    void dfs(int v, vector<int>& leftChild, vector<int>& rightChild, vector<int>& vis)\\n    {\\n        vis[v] = 1;\\n        if(leftChild[v]!=-1)\\n        {\\n            if(vis[leftChild[v]]==1)\\n            {\\n                flag = 1;\\n                return;\\n            }\\n            else dfs(leftChild[v], leftChild, rightChild, vis);\\n        }\\n        \\n        if(rightChild[v]!=-1)\\n        {\\n            if(vis[rightChild[v]]==1)\\n            {\\n                flag = 1;\\n                return;\\n            }\\n            else dfs(rightChild[v], leftChild, rightChild, vis);\\n        }\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int root = 0;\\n        \\n        vector<int> vis(n,0);\\n        vector<int> in(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(leftChild[i]!=-1) in[leftChild[i]]++;\\n            if(rightChild[i]!=-1) in[rightChild[i]]++;\\n        }\\n        \\n        int c = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                c++;\\n                root = i;\\n            }\\n        }\\n        \\n        if(c!=1) return false;\\n        \\n        dfs(root, leftChild, rightChild, vis);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0) return false;\\n        }\\n        if(flag==1) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flag = 0;\\n\\n    void dfs(int v, vector<int>& leftChild, vector<int>& rightChild, vector<int>& vis)\\n    {\\n        vis[v] = 1;\\n        if(leftChild[v]!=-1)\\n        {\\n            if(vis[leftChild[v]]==1)\\n            {\\n                flag = 1;\\n                return;\\n            }\\n            else dfs(leftChild[v], leftChild, rightChild, vis);\\n        }\\n        \\n        if(rightChild[v]!=-1)\\n        {\\n            if(vis[rightChild[v]]==1)\\n            {\\n                flag = 1;\\n                return;\\n            }\\n            else dfs(rightChild[v], leftChild, rightChild, vis);\\n        }\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int root = 0;\\n        \\n        vector<int> vis(n,0);\\n        vector<int> in(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(leftChild[i]!=-1) in[leftChild[i]]++;\\n            if(rightChild[i]!=-1) in[rightChild[i]]++;\\n        }\\n        \\n        int c = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                c++;\\n                root = i;\\n            }\\n        }\\n        \\n        if(c!=1) return false;\\n        \\n        dfs(root, leftChild, rightChild, vis);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0) return false;\\n        }\\n        if(flag==1) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156683,
                "title": "easy-to-understand-solution-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> g;\\n    set <int> vis;\\n    vector <int> indeg, outdeg;\\npublic:\\n    bool checkCycle(int node) {\\n        vis.insert(node);\\n        \\n        for(const auto ng : g[node]) {\\n            if(vis.count(ng)) return false;\\n            if(!checkCycle(ng)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        g.resize(n);\\n        indeg.resize(n, 0);\\n        outdeg.resize(n, 0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            int l = leftChild[i], r = rightChild[i];\\n            \\n            if(l != -1) {\\n                g[i].push_back(l);\\n                indeg[l]++;\\n                outdeg[i]++;\\n            }\\n            if(r != -1) {\\n                g[i].push_back(r);\\n                indeg[r]++;\\n                outdeg[i]++;\\n            }\\n        }\\n        \\n        int rootCandidates = 0, root = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(indeg[i] == 0 and outdeg[i] <= 2 and outdeg[i] >= 0) {\\n                rootCandidates++;\\n                root = i;\\n            }\\n        }\\n        \\n        // STEP 1: Check if there exist only one root\\n        if(rootCandidates != 1) {\\n            return false;\\n        }\\n        \\n        // STEP 2: Check if each child has only a single parent\\n        for(int i = 0; i < n; i++) {\\n            if(indeg[i] != 1 and i != root) {\\n                return false;\\n            }\\n        }\\n        \\n        // STEP 3: Check for cycles and traversal covers all nodes in the tree\\n        return checkCycle(root) and vis.size() == n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> g;\\n    set <int> vis;\\n    vector <int> indeg, outdeg;\\npublic:\\n    bool checkCycle(int node) {\\n        vis.insert(node);\\n        \\n        for(const auto ng : g[node]) {\\n            if(vis.count(ng)) return false;\\n            if(!checkCycle(ng)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        g.resize(n);\\n        indeg.resize(n, 0);\\n        outdeg.resize(n, 0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            int l = leftChild[i], r = rightChild[i];\\n            \\n            if(l != -1) {\\n                g[i].push_back(l);\\n                indeg[l]++;\\n                outdeg[i]++;\\n            }\\n            if(r != -1) {\\n                g[i].push_back(r);\\n                indeg[r]++;\\n                outdeg[i]++;\\n            }\\n        }\\n        \\n        int rootCandidates = 0, root = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(indeg[i] == 0 and outdeg[i] <= 2 and outdeg[i] >= 0) {\\n                rootCandidates++;\\n                root = i;\\n            }\\n        }\\n        \\n        // STEP 1: Check if there exist only one root\\n        if(rootCandidates != 1) {\\n            return false;\\n        }\\n        \\n        // STEP 2: Check if each child has only a single parent\\n        for(int i = 0; i < n; i++) {\\n            if(indeg[i] != 1 and i != root) {\\n                return false;\\n            }\\n        }\\n        \\n        // STEP 3: Check for cycles and traversal covers all nodes in the tree\\n        return checkCycle(root) and vis.size() == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135231,
                "title": "java-straight-forward-union-find-with-explanation",
                "content": "\\n\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        //all nodes should be connected with n - 1 edges for a valid tree\\n        //each union add 1 edge, after union all nodes, we should have n -1 edges\\n            \\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++){\\n            parent[i] = i;\\n        }\\n        \\n        int edge = 0;\\n        for(int i = 0; i < n; i++){\\n            if(leftChild[i] != -1){\\n                if(union(leftChild[i], i, parent)){\\n                    edge++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n            \\n            if(rightChild[i] != -1){\\n                if(union(rightChild[i], i, parent)){\\n                    edge++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return edge == n-1;\\n    }\\n    \\n    private int find(int x, int[] parent){\\n        while(x != parent[x]){\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n    \\n    private boolean union(int x, int y, int[] parent){\\n        int px = find(x, parent);\\n        int py = find(y, parent);\\n        if(px == py){\\n            return false;\\n        }\\n        if(px != x){\\n            // cannot link to another parent since it already has a parent\\n            return false;\\n        }\\n        parent[px] = py;\\n        return true;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        //all nodes should be connected with n - 1 edges for a valid tree\\n        //each union add 1 edge, after union all nodes, we should have n -1 edges\\n            \\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++){\\n            parent[i] = i;\\n        }\\n        \\n        int edge = 0;\\n        for(int i = 0; i < n; i++){\\n            if(leftChild[i] != -1){\\n                if(union(leftChild[i], i, parent)){\\n                    edge++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n            \\n            if(rightChild[i] != -1){\\n                if(union(rightChild[i], i, parent)){\\n                    edge++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return edge == n-1;\\n    }\\n    \\n    private int find(int x, int[] parent){\\n        while(x != parent[x]){\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n    \\n    private boolean union(int x, int y, int[] parent){\\n        int px = find(x, parent);\\n        int py = find(y, parent);\\n        if(px == py){\\n            return false;\\n        }\\n        if(px != x){\\n            // cannot link to another parent since it already has a parent\\n            return false;\\n        }\\n        parent[px] = py;\\n        return true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1125747,
                "title": "c-set-dfs-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_set<int>& visited, int& curr_node, vector<int>& leftChild, vector<int>& rightChild) {\\n        if (visited.find(curr_node) != visited.end() || curr_node == -1) return;\\n        \\n        visited.insert(curr_node);\\n        dfs(visited, leftChild[curr_node], leftChild, rightChild);\\n        dfs(visited, rightChild[curr_node], leftChild, rightChild);                    \\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        // to dos\\n        // 1. find node that has not appeared from 0 to n-1, which will be the root\\n        // 2. dfs start from root, keep track of visited nodes\\n        // 3. if all nodes can be visited, return true, else false\\n        // time: o(n)\\n        // space: o(n)\\n        \\n        unordered_set<int> find_root;\\n        for (int i = 0; i < n; i++) {\\n            find_root.insert(i);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                if (find_root.find(leftChild[i]) == find_root.end()) return false;\\n                find_root.erase(leftChild[i]);\\n            }\\n            if (rightChild[i] != -1) {\\n                if (find_root.find(rightChild[i]) == find_root.end()) return false;\\n                find_root.erase(rightChild[i]);\\n            }\\n        }\\n        \\n        if (find_root.size() != 1) {            \\n            return false;\\n        }\\n        \\n        int root = *find_root.begin();\\n        \\n        unordered_set<int> visited;\\n        \\n        dfs(visited, root, leftChild, rightChild);\\n        \\n        return visited.size() == n;                            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_set<int>& visited, int& curr_node, vector<int>& leftChild, vector<int>& rightChild) {\\n        if (visited.find(curr_node) != visited.end() || curr_node == -1) return;\\n        \\n        visited.insert(curr_node);\\n        dfs(visited, leftChild[curr_node], leftChild, rightChild);\\n        dfs(visited, rightChild[curr_node], leftChild, rightChild);                    \\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        // to dos\\n        // 1. find node that has not appeared from 0 to n-1, which will be the root\\n        // 2. dfs start from root, keep track of visited nodes\\n        // 3. if all nodes can be visited, return true, else false\\n        // time: o(n)\\n        // space: o(n)\\n        \\n        unordered_set<int> find_root;\\n        for (int i = 0; i < n; i++) {\\n            find_root.insert(i);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                if (find_root.find(leftChild[i]) == find_root.end()) return false;\\n                find_root.erase(leftChild[i]);\\n            }\\n            if (rightChild[i] != -1) {\\n                if (find_root.find(rightChild[i]) == find_root.end()) return false;\\n                find_root.erase(rightChild[i]);\\n            }\\n        }\\n        \\n        if (find_root.size() != 1) {            \\n            return false;\\n        }\\n        \\n        int root = *find_root.begin();\\n        \\n        unordered_set<int> visited;\\n        \\n        dfs(visited, root, leftChild, rightChild);\\n        \\n        return visited.size() == n;                            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932584,
                "title": "java-correct-solution",
                "content": "This problem initially had weak test cases and wrong OJ code so a lot of incorrect solutions got accepted. Consequently, a lot of posts contain wrong solutions.\\n\\nI present a **correct** solution based on 3 properties of tree:\\n1. Each node has exactly 1 parent node except 1 node (i.e. root)\\n-> Calculate parent array for all nodes and return false as soon as we come across a node which has 2 parents.\\n\\n2. No cycles or self loop\\n-> Run a DFS to detect cycle. End the search as soon as we detect a cycle.\\n\\n3. All nodes are connected to each other\\n-> Run a DFS from any node. Verify that all nodes got visited. DFS from previous step would suffice here.\\n\\n```\\nprivate boolean hasCycle(int u, int par, int[] left, int[] right, int[] parent, boolean[] visited) {\\n    visited[u] = true;\\n    for(int v: new int[] {left[u], right[u], parent[u]}) {\\n        if(v != -1 && v != par) {\\n            if(visited[v] || hasCycle(v, u, left, right, parent, visited)) {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n    int[] parent = new int[n];\\n    Arrays.fill(parent, -1);\\n    for(int i = 0; i < n; i++) {\\n        for(int child: new int[] {leftChild[i], rightChild[i]}) {\\n            if(child != -1) {\\n                if(parent[child] != -1) return false;\\n                parent[child] = i;\\n            }\\n        }\\n    }\\n    boolean[] visited = new boolean[n];\\n    if(hasCycle(0, -1, leftChild, rightChild, parent, visited)) return false;\\n    for(int i = 0; i < n; i++) {\\n        if(!visited[i]) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n**Optimization**\\n\\nWe can use step 1 more effectively by calculating root as well. Remember root is the node that has no parent. We also check that there is exactly one candidate for root. We still have to do a DFS from root but now there is no need to check for cycles. We just need to check that all nodes got visited.\\n\\nExplanation: step 1 ensures that we have a collection of connected graphs where each graph is a tree or a cycle of nodes. By making sure that there is only one candidate for root, we boil down to 2 cases: (a) a tree (b) a tree and a collection of cycle of nodes. So a DFS from root to count the number of visited nodes is sufficient to confirm whether it is case (a) or case (b).\\n\\n```\\nprivate int visitCount(int u, int[] left, int[] right) {\\n    return u == -1 ? 0 : 1 + visitCount(left[u], left, right) + visitCount(right[u], left, right);\\n}\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n    int[] parent = new int[n];\\n    Arrays.fill(parent, -1);\\n    for(int i = 0; i < n; i++) {\\n        for(int child: new int[] {leftChild[i], rightChild[i]}) {\\n            if(child != -1) {\\n                if(parent[child] != -1) return false;\\n                parent[child] = i;\\n            }\\n        }\\n    }\\n    int root = -1;\\n    for(int i = 0; i < n; i++) {\\n        if(parent[i] == -1) {\\n            if(root != -1) return false;\\n            root = i;\\n        }\\n    }\\n    return visitCount(root, leftChild, rightChild) == n;\\n}\\n```\\n\\nTime and space complexities of both approaches is O(n).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate boolean hasCycle(int u, int par, int[] left, int[] right, int[] parent, boolean[] visited) {\\n    visited[u] = true;\\n    for(int v: new int[] {left[u], right[u], parent[u]}) {\\n        if(v != -1 && v != par) {\\n            if(visited[v] || hasCycle(v, u, left, right, parent, visited)) {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n    int[] parent = new int[n];\\n    Arrays.fill(parent, -1);\\n    for(int i = 0; i < n; i++) {\\n        for(int child: new int[] {leftChild[i], rightChild[i]}) {\\n            if(child != -1) {\\n                if(parent[child] != -1) return false;\\n                parent[child] = i;\\n            }\\n        }\\n    }\\n    boolean[] visited = new boolean[n];\\n    if(hasCycle(0, -1, leftChild, rightChild, parent, visited)) return false;\\n    for(int i = 0; i < n; i++) {\\n        if(!visited[i]) return false;\\n    }\\n    return true;\\n}\\n```\n```\\nprivate int visitCount(int u, int[] left, int[] right) {\\n    return u == -1 ? 0 : 1 + visitCount(left[u], left, right) + visitCount(right[u], left, right);\\n}\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n    int[] parent = new int[n];\\n    Arrays.fill(parent, -1);\\n    for(int i = 0; i < n; i++) {\\n        for(int child: new int[] {leftChild[i], rightChild[i]}) {\\n            if(child != -1) {\\n                if(parent[child] != -1) return false;\\n                parent[child] = i;\\n            }\\n        }\\n    }\\n    int root = -1;\\n    for(int i = 0; i < n; i++) {\\n        if(parent[i] == -1) {\\n            if(root != -1) return false;\\n            root = i;\\n        }\\n    }\\n    return visitCount(root, leftChild, rightChild) == n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517703,
                "title": "python3-a-set-based-solution",
                "content": "Algorithm:\\nIt is a valid binary tree iff \\n1) `leftChild` and `rightChild` have `n-1` child in total;\\n2) `leftChild` and `rightChild` don\\'t have child in common. \\n\\nImplementation:\\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        left  = set(x for x in leftChild  if x != -1)\\n        right = set(x for x in rightChild if x != -1)\\n        return len(left | right) == n-1 and (not left & right)\\n```\\n\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`\\n\\nThe test case seems to be weak. For example, neighter `leftChild` nor `rightChild` should be duplicate child, but it doesn\\'t seem to test that.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        left  = set(x for x in leftChild  if x != -1)\\n        right = set(x for x in rightChild if x != -1)\\n        return len(left | right) == n-1 and (not left & right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517560,
                "title": "java-check-indegrees-o-n",
                "content": "```java\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] indegree = new int[n];\\n        for(int i = 0; i < leftChild.length; i++){\\n            if(leftChild[i] != -1){\\n                indegree[leftChild[i]]++;\\n            }\\n            if(rightChild[i] != -1){\\n                indegree[rightChild[i]]++;\\n            }\\n        }\\n        \\n        int zeroIndegree = 0;\\n        for(int id : indegree){\\n            if(id == 0){\\n                zeroIndegree++;\\n                //too many roots\\n                if(zeroIndegree > 1){\\n                    return false;\\n                }\\n            }\\n            //too many parents\\n            if(id > 1){\\n                return false;\\n            }\\n        }\\n        \\n        //no root\\n        if(zeroIndegree == 0){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] indegree = new int[n];\\n        for(int i = 0; i < leftChild.length; i++){\\n            if(leftChild[i] != -1){\\n                indegree[leftChild[i]]++;\\n            }\\n            if(rightChild[i] != -1){\\n                indegree[rightChild[i]]++;\\n            }\\n        }\\n        \\n        int zeroIndegree = 0;\\n        for(int id : indegree){\\n            if(id == 0){\\n                zeroIndegree++;\\n                //too many roots\\n                if(zeroIndegree > 1){\\n                    return false;\\n                }\\n            }\\n            //too many parents\\n            if(id > 1){\\n                return false;\\n            }\\n        }\\n        \\n        //no root\\n        if(zeroIndegree == 0){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006122,
                "title": "python3-union-find-find-parent-node-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Using UnionFind to check they are connected node into a single tree\\n- Using parent nodes like in degree in topological sort to check the number of parent of a node. It will be success if it satisfies two conditions:\\n    - there exists exactly 1 node without any parent node.\\n    - other nodes will have exactly 1 parent for each.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n\\n    def __init__(self, n: int):\\n        self.root = list(range(n))\\n        self.rank = [1 for _ in range(n)]\\n        self.groups = n\\n\\n    def find(self, x: int) -> int:\\n        if x != self.root[x]: self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        rootx, rooty = self.find(x), self.find(y)\\n        if rootx == rooty: return\\n        if self.rank[rootx] > self.rank[rooty]: self.root[rooty] = rootx\\n        elif self.rank[rootx] < self.rank[rooty]: self.root[rootx] = rooty\\n        else:\\n            self.root[rooty] = rootx\\n            self.rank[rootx] += 1\\n        self.groups -= 1\\n\\n    def is_connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        uf = UnionFind(n)\\n        edges = 0\\n        parents = [0 for _ in range(n)]\\n        for i in range(len(leftChild)):\\n            if leftChild[i] != -1:\\n                uf.union(i, leftChild[i])\\n                parents[leftChild[i]] += 1\\n            if rightChild[i] != -1:\\n                uf.union(i, rightChild[i])\\n                parents[rightChild[i]] += 1\\n\\n        c = collections.Counter(parents)\\n        if c[0] != 1 or c[1] != n - 1: return False\\n        return uf.groups == 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind:\\n\\n    def __init__(self, n: int):\\n        self.root = list(range(n))\\n        self.rank = [1 for _ in range(n)]\\n        self.groups = n\\n\\n    def find(self, x: int) -> int:\\n        if x != self.root[x]: self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        rootx, rooty = self.find(x), self.find(y)\\n        if rootx == rooty: return\\n        if self.rank[rootx] > self.rank[rooty]: self.root[rooty] = rootx\\n        elif self.rank[rootx] < self.rank[rooty]: self.root[rootx] = rooty\\n        else:\\n            self.root[rooty] = rootx\\n            self.rank[rootx] += 1\\n        self.groups -= 1\\n\\n    def is_connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        uf = UnionFind(n)\\n        edges = 0\\n        parents = [0 for _ in range(n)]\\n        for i in range(len(leftChild)):\\n            if leftChild[i] != -1:\\n                uf.union(i, leftChild[i])\\n                parents[leftChild[i]] += 1\\n            if rightChild[i] != -1:\\n                uf.union(i, rightChild[i])\\n                parents[rightChild[i]] += 1\\n\\n        c = collections.Counter(parents)\\n        if c[0] != 1 or c[1] != n - 1: return False\\n        return uf.groups == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672900,
                "title": "simple-bfs-c-root-node",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThink about root Node....?\\nroot node can\\'t be a child node of any other node. just Travers the leftchild and rightchild and identify the root node after that create a adjacency list and try to find the loop in the tree if is there any loop, return false else return true.\\n# Complexity\\n- Time complexity:O(V*E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n        vector<int> adj[n];\\n        vector<int> parent(n,0),vis(n,0);\\n        queue<int> q;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           if(lc[i]!=-1)\\n           {\\n              adj[i].push_back(lc[i]); \\n              parent[lc[i]] = 1;\\n           }\\n           if(rc[i]!=-1)\\n           {\\n             adj[i].push_back(rc[i]);\\n             parent[rc[i]] = 1;  \\n           }\\n        }\\n        int rootnode = -1;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(parent[i]==0)\\n            rootnode= i;\\n        }\\n        if(rootnode==-1) return false;\\n        q.push(rootnode);\\n        vis[rootnode] = 1;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto x : adj[node])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x] = 1;\\n                    q.push(x);\\n                }\\n                else\\n                return false;\\n            }\\n        }\\n        for(int i = 0;i<n;i++)\\n        if(vis[i]==0) return false;\\n        \\n        return true;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/a071a3c9-642e-481b-b1ab-ae803f50e6cd_1687512029.0994928.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n        vector<int> adj[n];\\n        vector<int> parent(n,0),vis(n,0);\\n        queue<int> q;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           if(lc[i]!=-1)\\n           {\\n              adj[i].push_back(lc[i]); \\n              parent[lc[i]] = 1;\\n           }\\n           if(rc[i]!=-1)\\n           {\\n             adj[i].push_back(rc[i]);\\n             parent[rc[i]] = 1;  \\n           }\\n        }\\n        int rootnode = -1;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(parent[i]==0)\\n            rootnode= i;\\n        }\\n        if(rootnode==-1) return false;\\n        q.push(rootnode);\\n        vis[rootnode] = 1;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto x : adj[node])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x] = 1;\\n                    q.push(x);\\n                }\\n                else\\n                return false;\\n            }\\n        }\\n        for(int i = 0;i<n;i++)\\n        if(vis[i]==0) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082995,
                "title": "c-40ms-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is that to solve this problem, we need to check if the given binary tree is a valid tree or not.\\nA valid tree should have only one root node, and all other nodes should be connected to the root node.\\nWe need to check if the given tree satisfies these conditions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, we will initialize an in-degree array that keeps track of the number of incoming edges for each node\\n- We will then iterate through the leftChild and rightChild arrays and increment the in-degree of the child nodes\\n- Next, we will iterate through the in-degree array and check if:\\n    - There is exactly one node with in-degree of 0 (root node)\\n    - No other node has an in-degree greater than 1\\n- If both conditions are met, we will initialize a queue and add the root node to it\\n- We will then use a BFS approach to traverse the tree, adding the left and right children of each node to the queue as we visit them\\n- We will also keep a count of the number of nodes visited\\n- Finally, we will check if the number of nodes visited is equal to the total number of nodes in the tree. If it is, we return true, otherwise we return false.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> in(n);\\n        for (auto l : leftChild) if (l != -1) in[l]++;\\n        for (auto r : rightChild) if (r != -1) in[r]++;\\n        int root = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (in[i] == 0) {\\n                if (root != -1) return false;\\n                root = i;\\n            }\\n            if (in[i] > 1) return false;\\n        }\\n        if (root == -1) return false;\\n        int cnt = 0;\\n        queue<int> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int i = q.front();\\n            q.pop();\\n            cnt++;\\n            if (leftChild[i] != -1) q.push(leftChild[i]);\\n            if (rightChild[i] != -1) q.push(rightChild[i]);\\n        }\\n        return cnt == n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> in(n);\\n        for (auto l : leftChild) if (l != -1) in[l]++;\\n        for (auto r : rightChild) if (r != -1) in[r]++;\\n        int root = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (in[i] == 0) {\\n                if (root != -1) return false;\\n                root = i;\\n            }\\n            if (in[i] > 1) return false;\\n        }\\n        if (root == -1) return false;\\n        int cnt = 0;\\n        queue<int> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int i = q.front();\\n            q.pop();\\n            cnt++;\\n            if (leftChild[i] != -1) q.push(leftChild[i]);\\n            if (rightChild[i] != -1) q.push(rightChild[i]);\\n        }\\n        return cnt == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998889,
                "title": "disjoint-set-straight-forward-c-solution",
                "content": "```\\nclass Solution { // YAA \\npublic:\\n    int find(int node, int par[]) {\\n        if(node == par[node]) return node;\\n        return par[node] = find(par[node], par);\\n    }\\n    void join(int u, int v, int par[], int ran[]) {\\n        u = find(u, par);\\n        v = find(v, par);\\n        if(ran[u] > ran[v]) {\\n            par[v] = u;\\n        } else if(ran[v] > ran[u]) {\\n            par[u] = v;\\n        } else {\\n            par[v] = u;\\n            ran[u]++;\\n        }\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n        vector<int>node(n,0);\\n        for(int i=0;i<n;i++){\\n            \\n            if(leftChild[i]!=-1){\\n                node[leftChild[i]]++;\\n                if(node[leftChild[i]]>1) return false; \\n            }       \\n            \\n            if(rightChild[i]!=-1){\\n                node[rightChild[i]]++;\\n                if(node[rightChild[i]]>1) return false; \\n            }    \\n        }\\n        int par[n], ran[n];\\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n            ran[i] = 0;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(find(i, par) != find(leftChild[i], par)) {\\n                    join(i, leftChild[i], par, ran);\\n                } else {\\n                    return false;\\n                }\\n            }\\n            if(rightChild[i] != -1) {\\n                if(find(i, par) != find(rightChild[i], par)) {\\n                    join(i, rightChild[i], par, ran);\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int pare = find(i,par);\\n            par[i] = pare;\\n        }\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++) {\\n            mp[par[i]]++;\\n            if(mp.size() > 1) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution { // YAA \\npublic:\\n    int find(int node, int par[]) {\\n        if(node == par[node]) return node;\\n        return par[node] = find(par[node], par);\\n    }\\n    void join(int u, int v, int par[], int ran[]) {\\n        u = find(u, par);\\n        v = find(v, par);\\n        if(ran[u] > ran[v]) {\\n            par[v] = u;\\n        } else if(ran[v] > ran[u]) {\\n            par[u] = v;\\n        } else {\\n            par[v] = u;\\n            ran[u]++;\\n        }\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n        vector<int>node(n,0);\\n        for(int i=0;i<n;i++){\\n            \\n            if(leftChild[i]!=-1){\\n                node[leftChild[i]]++;\\n                if(node[leftChild[i]]>1) return false; \\n            }       \\n            \\n            if(rightChild[i]!=-1){\\n                node[rightChild[i]]++;\\n                if(node[rightChild[i]]>1) return false; \\n            }    \\n        }\\n        int par[n], ran[n];\\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n            ran[i] = 0;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(find(i, par) != find(leftChild[i], par)) {\\n                    join(i, leftChild[i], par, ran);\\n                } else {\\n                    return false;\\n                }\\n            }\\n            if(rightChild[i] != -1) {\\n                if(find(i, par) != find(rightChild[i], par)) {\\n                    join(i, rightChild[i], par, ran);\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int pare = find(i,par);\\n            par[i] = pare;\\n        }\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++) {\\n            mp[par[i]]++;\\n            if(mp.size() > 1) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814452,
                "title": "java-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        \\n        int[] indegree = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            graph.put(i, new ArrayList<>());\\n        \\n        for(int i=0; i<n; i++){\\n            if(leftChild[i] != -1){\\n                graph.get(i).add(leftChild[i]);\\n                indegree[leftChild[i]]++;\\n            }\\n            \\n            if(rightChild[i] != -1){\\n                graph.get(i).add(rightChild[i]);\\n                indegree[rightChild[i]]++;\\n            }\\n            \\n            if(graph.get(i).size() > 2)\\n                return false;\\n        }\\n        \\n        int components = 0;\\n        \\n        for(int i: indegree){\\n            if(i == 0){\\n                components++;\\n                \\n                if(components > 1)\\n                    return false;\\n            }\\n            if(i > 1)\\n                return false;\\n        }\\n        \\n        int[] visited = new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            if(visited[i] == 0){\\n                if(isCyclic(graph, i, visited))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isCyclic(HashMap<Integer, List<Integer>> graph, int src, int[] visited){\\n        if(visited[src] == 2)\\n            return true;\\n        \\n        visited[src] = 2;\\n        \\n        for(int i: graph.get(src)){\\n            if(visited[i] != 1){\\n                if(isCyclic(graph, i, visited))\\n                    return true;\\n            }\\n        }\\n        \\n        visited[src] = 1;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        \\n        int[] indegree = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            graph.put(i, new ArrayList<>());\\n        \\n        for(int i=0; i<n; i++){\\n            if(leftChild[i] != -1){\\n                graph.get(i).add(leftChild[i]);\\n                indegree[leftChild[i]]++;\\n            }\\n            \\n            if(rightChild[i] != -1){\\n                graph.get(i).add(rightChild[i]);\\n                indegree[rightChild[i]]++;\\n            }\\n            \\n            if(graph.get(i).size() > 2)\\n                return false;\\n        }\\n        \\n        int components = 0;\\n        \\n        for(int i: indegree){\\n            if(i == 0){\\n                components++;\\n                \\n                if(components > 1)\\n                    return false;\\n            }\\n            if(i > 1)\\n                return false;\\n        }\\n        \\n        int[] visited = new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            if(visited[i] == 0){\\n                if(isCyclic(graph, i, visited))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isCyclic(HashMap<Integer, List<Integer>> graph, int src, int[] visited){\\n        if(visited[src] == 2)\\n            return true;\\n        \\n        visited[src] = 2;\\n        \\n        for(int i: graph.get(src)){\\n            if(visited[i] != 1){\\n                if(isCyclic(graph, i, visited))\\n                    return true;\\n            }\\n        }\\n        \\n        visited[src] = 1;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674886,
                "title": "find-root-kahn-s-algo",
                "content": "to validate a binary tree the conditions are :-\\n* only one node has inderee = 0 (i.e root)\\n* every other node should have indegree = 1\\n* after the bfs traversal is completed every node should have been visited( last loop)\\n\\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vector<int> indegree(l.size());\\n        for(int i=0;i<l.size();i++){\\n            if(l[i]!=-1) if(indegree[l[i]]++) return false;\\n            if(r[i]!=-1) if(indegree[r[i]]++) return false;\\n        }\\n        int root = -1;\\n        for(int i=0;i<indegree.size();i++){\\n            if(!indegree[i]){\\n                if(root!=-1) return false;\\n                root = i;\\n            }\\n        }\\n        if(root==-1) return false;\\n        queue<int> q; q.push(root);\\n        while(!q.empty()){\\n            int v = q.front(); q.pop();\\n            if(l[v]!=-1){\\n                indegree[l[v]]-=1;\\n                q.push(l[v]);\\n            }\\n            if(r[v]!=-1){\\n                indegree[r[v]]-=1;\\n                q.push(r[v]);\\n            }\\n        }\\n        for(int i=0;i<indegree.size();i++) if(indegree[i]) return false;\\n        return true;\\n    }\\n};\\n```\\n\\nUPDATE:- minor optimisation to avoid the last for loop. take a count variable and increment it whenever an element pops out of queue. it gives count of number of nodes visited \\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vector<int> indegree(l.size());\\n        for(int i=0;i<l.size();i++){\\n            if(l[i]!=-1) if(indegree[l[i]]++) return false;\\n            if(r[i]!=-1) if(indegree[r[i]]++) return false;\\n        }\\n        int root = -1;\\n        for(int i=0;i<indegree.size();i++){\\n            if(!indegree[i]){\\n                if(root!=-1) return false;\\n                root = i;\\n            }\\n        }\\n        if(root==-1) return false;\\n        queue<int> q; q.push(root);\\n        int count = 0;\\n        while(!q.empty()){\\n            int v = q.front(); q.pop();\\n            count++;\\n            if(l[v]!=-1){\\n                indegree[l[v]]-=1;\\n                q.push(l[v]);\\n            }\\n            if(r[v]!=-1){\\n                indegree[r[v]]-=1;\\n                q.push(r[v]);\\n            }\\n        }\\n        return count==indegree.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vector<int> indegree(l.size());\\n        for(int i=0;i<l.size();i++){\\n            if(l[i]!=-1) if(indegree[l[i]]++) return false;\\n            if(r[i]!=-1) if(indegree[r[i]]++) return false;\\n        }\\n        int root = -1;\\n        for(int i=0;i<indegree.size();i++){\\n            if(!indegree[i]){\\n                if(root!=-1) return false;\\n                root = i;\\n            }\\n        }\\n        if(root==-1) return false;\\n        queue<int> q; q.push(root);\\n        while(!q.empty()){\\n            int v = q.front(); q.pop();\\n            if(l[v]!=-1){\\n                indegree[l[v]]-=1;\\n                q.push(l[v]);\\n            }\\n            if(r[v]!=-1){\\n                indegree[r[v]]-=1;\\n                q.push(r[v]);\\n            }\\n        }\\n        for(int i=0;i<indegree.size();i++) if(indegree[i]) return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vector<int> indegree(l.size());\\n        for(int i=0;i<l.size();i++){\\n            if(l[i]!=-1) if(indegree[l[i]]++) return false;\\n            if(r[i]!=-1) if(indegree[r[i]]++) return false;\\n        }\\n        int root = -1;\\n        for(int i=0;i<indegree.size();i++){\\n            if(!indegree[i]){\\n                if(root!=-1) return false;\\n                root = i;\\n            }\\n        }\\n        if(root==-1) return false;\\n        queue<int> q; q.push(root);\\n        int count = 0;\\n        while(!q.empty()){\\n            int v = q.front(); q.pop();\\n            count++;\\n            if(l[v]!=-1){\\n                indegree[l[v]]-=1;\\n                q.push(l[v]);\\n            }\\n            if(r[v]!=-1){\\n                indegree[r[v]]-=1;\\n                q.push(r[v]);\\n            }\\n        }\\n        return count==indegree.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646165,
                "title": "c-bfs-explanation",
                "content": "So this is a Simple bfs/dfs problem Some things to obeserve are\\n* there can be multiple roots in the problem so we have to check if there are multiple roots if yes than there maybe more than one binary trees.\\n* After finding the root using a indegree array (i.e root must have 0 indegree) we can  do a bfs/dfs if there are bidirectional edges than it will not valid so we will return false\\n* at last after doing bfs all nodes must be visited so to we will check if any node is left if anyone left than it will be not a valid bt\\n\\nSo on above observations i have implemented the idea\\n   \\n   \\n   \\n   \\n   \\n\\t   vector<int>adj[n];\\n        vector<int>indegree(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]!=-1)\\n            {\\n                adj[i].push_back(left[i]);\\n                indegree[left[i]]++;\\n            }\\n            if(right[i]!=-1)\\n            {\\n                adj[i].push_back(right[i]);\\n                indegree[right[i]]++;\\n            }\\n           }\\n        int root;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                root=i;\\n                count++;\\n            }\\n        }\\n        \\n        if(count>1 || count<1)\\n            return false;\\n        vector<int>visited(n,0);\\n        queue<int>q;\\n        \\n        \\n            q.push(root);\\n            \\n        while(!q.empty())\\n        {\\n            int curr=q.front();\\n            q.pop();\\n            \\n            if(visited[curr])\\n            return false;\\n            \\n            visited[curr]=true;\\n            \\n            \\n            for(int i=0;i<adj[curr].size();i++)\\n                q.push(adj[curr][i]);\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            if( !visited[i] || adj[i].size()>2)\\n                return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "So this is a Simple bfs/dfs problem Some things to obeserve are\\n* there can be multiple roots in the problem so we have to check if there are multiple roots if yes than there maybe more than one binary trees.\\n* After finding the root using a indegree array (i.e root must have 0 indegree) we can  do a bfs/dfs if there are bidirectional edges than it will not valid so we will return false\\n* at last after doing bfs all nodes must be visited so to we will check if any node is left if anyone left than it will be not a valid bt\\n\\nSo on above observations i have implemented the idea\\n   \\n   \\n   \\n   \\n   \\n\\t   vector<int>adj[n];\\n        vector<int>indegree(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]!=-1)\\n            {\\n                adj[i].push_back(left[i]);\\n                indegree[left[i]]++;\\n            }\\n            if(right[i]!=-1)\\n            {\\n                adj[i].push_back(right[i]);\\n                indegree[right[i]]++;\\n            }\\n           }\\n        int root;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                root=i;\\n                count++;\\n            }\\n        }\\n        \\n        if(count>1 || count<1)\\n            return false;\\n        vector<int>visited(n,0);\\n        queue<int>q;\\n        \\n        \\n            q.push(root);\\n            \\n        while(!q.empty())\\n        {\\n            int curr=q.front();\\n            q.pop();\\n            \\n            if(visited[curr])\\n            return false;\\n            \\n            visited[curr]=true;\\n            \\n            \\n            for(int i=0;i<adj[curr].size();i++)\\n                q.push(adj[curr][i]);\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            if( !visited[i] || adj[i].size()>2)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1532204,
                "title": "java-easy-union-find-solution",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] map = new int[n];\\n        for (int i = 0; i < n; i++)\\n            map[i] = i;\\n        int count = n;\\n        for (int i = 0; i < n; i++) {\\n            int root = find(map, i);\\n            if (leftChild[i] != -1) {\\n                int rootL = find(map, leftChild[i]);\\n                if (rootL == root || (root == i && rootL != leftChild[i]))\\n                    return false;\\n                map[rootL] = root;\\n                count--;\\n            }\\n            if (rightChild[i] != -1) {\\n                int rootR = find(map, rightChild[i]);\\n                if (rootR == root || (root == i && rootR != rightChild[i]))\\n                    return false;\\n                map[rootR] = root;\\n                count--;\\n            }\\n        }\\n        return count == 1;\\n    }\\n    public int find(int[] map, int i) {\\n        if (map[i] != i)\\n            map[i] = find(map, map[i]);\\n        return map[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] map = new int[n];\\n        for (int i = 0; i < n; i++)\\n            map[i] = i;\\n        int count = n;\\n        for (int i = 0; i < n; i++) {\\n            int root = find(map, i);\\n            if (leftChild[i] != -1) {\\n                int rootL = find(map, leftChild[i]);\\n                if (rootL == root || (root == i && rootL != leftChild[i]))\\n                    return false;\\n                map[rootL] = root;\\n                count--;\\n            }\\n            if (rightChild[i] != -1) {\\n                int rootR = find(map, rightChild[i]);\\n                if (rootR == root || (root == i && rootR != rightChild[i]))\\n                    return false;\\n                map[rootR] = root;\\n                count--;\\n            }\\n        }\\n        return count == 1;\\n    }\\n    public int find(int[] map, int i) {\\n        if (map[i] != i)\\n            map[i] = find(map, map[i]);\\n        return map[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449859,
                "title": "topological-sort-python",
                "content": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n, L, R):\\n        indegrees = [0]*n\\n        for i in range(n):\\n            if L[i] != -1:\\n                indegrees[L[i]] += 1\\n            if R[i] != -1:\\n                indegrees[R[i]] += 1\\n        \\n        q = deque()\\n        s = 0\\n        for i in range(n):\\n            if indegrees[i] == 0:\\n                q.append(i)\\n            s += indegrees[i]\\n        if s != n-1 or len(q) > 1: return False\\n        \\n        seen = 0\\n        while q:\\n            node = q.popleft()\\n            seen += 1\\n            if L[node] != -1 and indegrees[L[node]] == 1:\\n                q.append(L[node])\\n                indegrees[L[node]] -= 1\\n            if R[node] != -1 and indegrees[R[node]] == 1:\\n                q.append(R[node])\\n                indegrees[R[node]] -= 1\\n        \\n        return seen == n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n, L, R):\\n        indegrees = [0]*n\\n        for i in range(n):\\n            if L[i] != -1:\\n                indegrees[L[i]] += 1\\n            if R[i] != -1:\\n                indegrees[R[i]] += 1\\n        \\n        q = deque()\\n        s = 0\\n        for i in range(n):\\n            if indegrees[i] == 0:\\n                q.append(i)\\n            s += indegrees[i]\\n        if s != n-1 or len(q) > 1: return False\\n        \\n        seen = 0\\n        while q:\\n            node = q.popleft()\\n            seen += 1\\n            if L[node] != -1 and indegrees[L[node]] == 1:\\n                q.append(L[node])\\n                indegrees[L[node]] -= 1\\n            if R[node] != -1 and indegrees[R[node]] == 1:\\n                q.append(R[node])\\n                indegrees[R[node]] -= 1\\n        \\n        return seen == n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408462,
                "title": "java-solution-find-root-using-in-degree-and-bfs-solution-with-comments",
                "content": "```java\\n public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        int[] indegree = new int[n];\\n        int ct=0;\\n\\t\\t//populate indegree\\n        for(int i=0;i<n;i++){\\n            if(leftChild[i]>=0)indegree[leftChild[i]]++;\\n            if(rightChild[i]>=0)indegree[rightChild[i]]++;\\n        }  \\n\\t\\t// find the root\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                if(root==-1)root = i;\\n                else return false; //two roots\\n            }else if(indegree[i]>1)return false; //indegree more than 1 is not tree.\\n        }\\n        \\n        if(root==-1)return false; //no root ->  cyclic.\\n        \\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(root);\\n\\t\\t\\n       \\n\\t\\t// we dont need to maintain visited[] here as we already know each node has one indegree and only one root is present\\n\\t\\t\\n        while(!queue.isEmpty()){\\n            int top = queue.poll();\\n            if(leftChild[top]!=-1)queue.add(leftChild[top]);\\n            if(rightChild[top]!=-1)queue.add(rightChild[top]);\\n            \\n            ct++;\\n        }\\n        \\n        \\n        return ct==n;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        int[] indegree = new int[n];\\n        int ct=0;\\n\\t\\t//populate indegree\\n        for(int i=0;i<n;i++){\\n            if(leftChild[i]>=0)indegree[leftChild[i]]++;\\n            if(rightChild[i]>=0)indegree[rightChild[i]]++;\\n        }  \\n\\t\\t// find the root\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                if(root==-1)root = i;\\n                else return false; //two roots\\n            }else if(indegree[i]>1)return false; //indegree more than 1 is not tree.\\n        }\\n        \\n        if(root==-1)return false; //no root ->  cyclic.\\n        \\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(root);\\n\\t\\t\\n       \\n\\t\\t// we dont need to maintain visited[] here as we already know each node has one indegree and only one root is present\\n\\t\\t\\n        while(!queue.isEmpty()){\\n            int top = queue.poll();\\n            if(leftChild[top]!=-1)queue.add(leftChild[top]);\\n            if(rightChild[top]!=-1)queue.add(rightChild[top]);\\n            \\n            ct++;\\n        }\\n        \\n        \\n        return ct==n;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404583,
                "title": "c-simple-dfs-and-a-bunch-of-checks-and-still-no-complete-test-cases",
                "content": "We can get rid of most test cases by simply keeping track of the parent of each node. If there are more than 1 parent, return false. If there are more than 1 node without parent, return false. If there are no nodes without parent, return false. This is great and will get you through most test cases. But you will get stuck on cases like this:\\n```\\n5\\n[1,2,0,4,-1]\\n[-1,-1,-1,-1,-1]\\n```\\nThis test case actually doesn\\'t exist and you can get away with a incorrect solution by adding just a few more checks. But I won\\'t consider it correct.\\n\\nDrawing this out will reveal two trees where 1 tree is a circle. There is no easy way to detect this using checks, so the next best idea is to use a dfs. Find the root using the previous checks (the node with no parent) and dfs through that node. If all nodes are visited and there is no cycle, return true, otherwise, false.\\n\\n```\\nclass Solution {\\n    \\n    bool dfs(int i, vector<int>& leftChild, vector<int>& rightChild, vector<bool>& seen, int& visited) {\\n        if(seen[i]) return true;\\n        \\n        seen[i] = true;\\n        visited++;\\n        \\n        if(leftChild[i] != -1) {\\n            if(dfs(leftChild[i], leftChild, rightChild, seen, visited)) return true;\\n        }\\n        \\n        if(rightChild[i] != -1) {\\n            if(dfs(rightChild[i], leftChild, rightChild, seen, visited)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> parent(n, -1);\\n        for(int i = 0;  i < n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(parent[leftChild[i]] != -1) return false;\\n                parent[leftChild[i]] = i;\\n            }\\n            \\n            if(rightChild[i] != -1) {\\n                if(parent[rightChild[i]] != -1) return false;\\n                parent[rightChild[i]] = i;\\n            }\\n        }\\n        \\n        int index = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(parent[i] == -1) {\\n                if(index != -1) {\\n                    return false;\\n                }\\n                \\n                index = i;\\n            }\\n        }\\n        \\n        if(index == -1) return false;\\n        \\n        vector<bool> seen(n, false);\\n        int visited = 0;\\n        if(dfs(index, leftChild, rightChild, seen, visited)) return false;\\n        \\n        return visited == n;\\n        \\n    }\\n};\\n```\\nTime complexity is `O(n)`, space complexity is `O(n)`.",
                "solutionTags": [],
                "code": "```\\n5\\n[1,2,0,4,-1]\\n[-1,-1,-1,-1,-1]\\n```\n```\\nclass Solution {\\n    \\n    bool dfs(int i, vector<int>& leftChild, vector<int>& rightChild, vector<bool>& seen, int& visited) {\\n        if(seen[i]) return true;\\n        \\n        seen[i] = true;\\n        visited++;\\n        \\n        if(leftChild[i] != -1) {\\n            if(dfs(leftChild[i], leftChild, rightChild, seen, visited)) return true;\\n        }\\n        \\n        if(rightChild[i] != -1) {\\n            if(dfs(rightChild[i], leftChild, rightChild, seen, visited)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> parent(n, -1);\\n        for(int i = 0;  i < n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(parent[leftChild[i]] != -1) return false;\\n                parent[leftChild[i]] = i;\\n            }\\n            \\n            if(rightChild[i] != -1) {\\n                if(parent[rightChild[i]] != -1) return false;\\n                parent[rightChild[i]] = i;\\n            }\\n        }\\n        \\n        int index = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(parent[i] == -1) {\\n                if(index != -1) {\\n                    return false;\\n                }\\n                \\n                index = i;\\n            }\\n        }\\n        \\n        if(index == -1) return false;\\n        \\n        vector<bool> seen(n, false);\\n        int visited = 0;\\n        if(dfs(index, leftChild, rightChild, seen, visited)) return false;\\n        \\n        return visited == n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384022,
                "title": "c-simple-union-find",
                "content": "```\\nint find(vector<int>& parent, int v) {\\n\\tif(parent[v] < 0) return v;\\n\\tparent[v] = find(parent, parent[v]);\\n\\treturn parent[v];\\n} \\n\\nbool _union(vector<int>& parent, int v1, int v2) {\\n\\tint p1 = find(parent, v1);\\n\\tint p2 = find(parent, v2);\\n\\tif(p1 == p2) return false; // cycle exists\\n\\tif(p2 != v2) return false; // v2 has a parent already\\n\\tparent[p2] = p1;\\n\\treturn true;\\n}\\n\\nbool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n\\tvector<int> parent(n, -1);\\n\\tint edges = 0;\\n\\tfor(int node = 0; node < n; node++) {\\n\\t\\tif(leftChild[node] >= 0) {\\n\\t\\t\\tif(!_union(parent, node, leftChild[node])) return false;\\n\\t\\t\\tedges++;\\n\\t\\t} \\n\\n\\t\\tif(rightChild[node] >= 0) {\\n\\t\\t\\tif(!_union(parent, node, rightChild[node])) return false;\\n\\t\\t\\tedges++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn edges == n - 1; // connected?\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint find(vector<int>& parent, int v) {\\n\\tif(parent[v] < 0) return v;\\n\\tparent[v] = find(parent, parent[v]);\\n\\treturn parent[v];\\n} \\n\\nbool _union(vector<int>& parent, int v1, int v2) {\\n\\tint p1 = find(parent, v1);\\n\\tint p2 = find(parent, v2);\\n\\tif(p1 == p2) return false; // cycle exists\\n\\tif(p2 != v2) return false; // v2 has a parent already\\n\\tparent[p2] = p1;\\n\\treturn true;\\n}\\n\\nbool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n\\tvector<int> parent(n, -1);\\n\\tint edges = 0;\\n\\tfor(int node = 0; node < n; node++) {\\n\\t\\tif(leftChild[node] >= 0) {\\n\\t\\t\\tif(!_union(parent, node, leftChild[node])) return false;\\n\\t\\t\\tedges++;\\n\\t\\t} \\n\\n\\t\\tif(rightChild[node] >= 0) {\\n\\t\\t\\tif(!_union(parent, node, rightChild[node])) return false;\\n\\t\\t\\tedges++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn edges == n - 1; // connected?\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359030,
                "title": "java-union-find-solution",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] roots = new int[n];\\n        \\n        for(int i=0;i<n;i++) roots[i]= i;\\n        \\n        for(int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1) {\\n                if(i== leftChild[i] || !union(i, leftChild[i], roots)) return false;\\n            }\\n            \\n            if(rightChild[i]!=-1) {\\n                if(i== rightChild[i] || !union(i, rightChild[i], roots)) return false;\\n            }\\n        }\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<n;i++) if(roots[i]==i)count++;\\n        \\n        return count==1;\\n    }\\n    \\n    int root(int[] roots, int i) {\\n        while(roots[i]!=i) {\\n            i = roots[i];\\n        }\\n        return i;\\n    }\\n    \\n    boolean union(int parent, int child, int[] roots) {\\n        int rp = root(roots, parent);\\n        int rc = root(roots, child);\\n        \\n        if(rc!=child || rp==rc) return false;\\n        \\n        roots[rc] = rp;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] roots = new int[n];\\n        \\n        for(int i=0;i<n;i++) roots[i]= i;\\n        \\n        for(int i=0;i<n;i++) {\\n            if(leftChild[i]!=-1) {\\n                if(i== leftChild[i] || !union(i, leftChild[i], roots)) return false;\\n            }\\n            \\n            if(rightChild[i]!=-1) {\\n                if(i== rightChild[i] || !union(i, rightChild[i], roots)) return false;\\n            }\\n        }\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<n;i++) if(roots[i]==i)count++;\\n        \\n        return count==1;\\n    }\\n    \\n    int root(int[] roots, int i) {\\n        while(roots[i]!=i) {\\n            i = roots[i];\\n        }\\n        return i;\\n    }\\n    \\n    boolean union(int parent, int child, int[] roots) {\\n        int rp = root(roots, parent);\\n        int rc = root(roots, child);\\n        \\n        if(rc!=child || rp==rc) return false;\\n        \\n        roots[rc] = rp;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281945,
                "title": "java-2-different-o-n-time-dfs-solution",
                "content": "The graph is a tree if the graph 1) has no loop, 2) is connected.\\n```\\n// DFS Solution\\n// The graph is a tree if the graph 1) has no loop, 2) is connected.\\n// 1. Build graph and indegrees\\n// 2. Get root\\n// 3. DFS check whether the graph is connected without loop\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        // Build Graph\\n        Integer[][] graph = new Integer[n][2];\\n        int[] indegrees = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                graph[i][0] = leftChild[i];\\n                indegrees[leftChild[i]]++;\\n                if (indegrees[leftChild[i]] > 1) return false;  // indegree > 1, so graph contains loop, return false.\\n            }\\n            if (rightChild[i] != -1) {\\n                graph[i][1] = rightChild[i];\\n                indegrees[rightChild[i]]++;\\n                if (indegrees[rightChild[i]] > 1) return false;  // indegree > 1, so graph contains loop, return false.\\n            }\\n        }\\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (indegrees[i] == 0) {\\n                if (root != -1) return false;  // Graph has more than one nodes whose indegree is 0. So the graph is not connected, return false.\\n                root = i;\\n            }\\n        }\\n        if (root == -1) return false;  // Graph has no node whose indegree is 0. So the graph contains loop, return false.\\n        // DFS check whether the graph is connected without loop\\n        boolean[] visited = new boolean[n];\\n        if (!dfs(root, graph, visited)) return false;\\n        for (boolean vis : visited) {\\n            if (!vis) return false;  // Graph is not connected, return false.\\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int node, Integer[][] graph, boolean[] visited) {\\n        if (visited[node]) return false;  // Graph contains loop, return false.\\n        visited[node] = true;\\n        for (Integer neighbor : graph[node]) {\\n            if (neighbor != null) {\\n                if (!dfs(neighbor, graph, visited)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n```\\n// Indegree + Connection check Solution\\n// The graph is a tree if the graph 1) has no loop, 2) is connected.\\n// 1. Get indegrees\\n// 2. Get root\\n// 3. DFS to count the number of connected nodes. Then check if the return num == n.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        if(n == 1) return true;\\n        int[] indegrees = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                indegrees[leftChild[i]]++;\\n                if (indegrees[leftChild[i]] > 1) return false;  // indegree > 1, so graph contains loop, return false.\\n            }\\n            if (rightChild[i] != -1) {\\n                indegrees[rightChild[i]]++;\\n                if (indegrees[rightChild[i]] > 1) return false;  // indegree > 1, so graph contains loop, return false.\\n            }\\n        }\\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (indegrees[i] == 0) {\\n                if (root != -1) return false;  // Graph has more than one nodes whose indegree is 0. So the graph is not connected, return false.\\n                root = i;\\n            }\\n        }\\n        if (root == -1) return false;  // Graph has no node whose indegree is 0. So the graph contains loop, return false.\\n        // Connection check\\n        return countNodes(root, leftChild, rightChild) == n;\\n    }\\n    \\n    private int countNodes(int root, int[] leftChild, int[] rightChild) {\\n        if(root == -1) return 0;\\n        return 1 + countNodes(leftChild[root], leftChild, rightChild) \\n            + countNodes(rightChild[root], leftChild, rightChild);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// DFS Solution\\n// The graph is a tree if the graph 1) has no loop, 2) is connected.\\n// 1. Build graph and indegrees\\n// 2. Get root\\n// 3. DFS check whether the graph is connected without loop\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        // Build Graph\\n        Integer[][] graph = new Integer[n][2];\\n        int[] indegrees = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                graph[i][0] = leftChild[i];\\n                indegrees[leftChild[i]]++;\\n                if (indegrees[leftChild[i]] > 1) return false;  // indegree > 1, so graph contains loop, return false.\\n            }\\n            if (rightChild[i] != -1) {\\n                graph[i][1] = rightChild[i];\\n                indegrees[rightChild[i]]++;\\n                if (indegrees[rightChild[i]] > 1) return false;  // indegree > 1, so graph contains loop, return false.\\n            }\\n        }\\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (indegrees[i] == 0) {\\n                if (root != -1) return false;  // Graph has more than one nodes whose indegree is 0. So the graph is not connected, return false.\\n                root = i;\\n            }\\n        }\\n        if (root == -1) return false;  // Graph has no node whose indegree is 0. So the graph contains loop, return false.\\n        // DFS check whether the graph is connected without loop\\n        boolean[] visited = new boolean[n];\\n        if (!dfs(root, graph, visited)) return false;\\n        for (boolean vis : visited) {\\n            if (!vis) return false;  // Graph is not connected, return false.\\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int node, Integer[][] graph, boolean[] visited) {\\n        if (visited[node]) return false;  // Graph contains loop, return false.\\n        visited[node] = true;\\n        for (Integer neighbor : graph[node]) {\\n            if (neighbor != null) {\\n                if (!dfs(neighbor, graph, visited)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n// Indegree + Connection check Solution\\n// The graph is a tree if the graph 1) has no loop, 2) is connected.\\n// 1. Get indegrees\\n// 2. Get root\\n// 3. DFS to count the number of connected nodes. Then check if the return num == n.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        if(n == 1) return true;\\n        int[] indegrees = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                indegrees[leftChild[i]]++;\\n                if (indegrees[leftChild[i]] > 1) return false;  // indegree > 1, so graph contains loop, return false.\\n            }\\n            if (rightChild[i] != -1) {\\n                indegrees[rightChild[i]]++;\\n                if (indegrees[rightChild[i]] > 1) return false;  // indegree > 1, so graph contains loop, return false.\\n            }\\n        }\\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (indegrees[i] == 0) {\\n                if (root != -1) return false;  // Graph has more than one nodes whose indegree is 0. So the graph is not connected, return false.\\n                root = i;\\n            }\\n        }\\n        if (root == -1) return false;  // Graph has no node whose indegree is 0. So the graph contains loop, return false.\\n        // Connection check\\n        return countNodes(root, leftChild, rightChild) == n;\\n    }\\n    \\n    private int countNodes(int root, int[] leftChild, int[] rightChild) {\\n        if(root == -1) return 0;\\n        return 1 + countNodes(leftChild[root], leftChild, rightChild) \\n            + countNodes(rightChild[root], leftChild, rightChild);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275085,
                "title": "java-union-find-solution-with-some-comments",
                "content": "The main idea is to check for 3 things: \\n1) Every node in the graph has no more than 1 parent;\\n2) There is exactly 1 node in the graph that has no parent;\\n3) All nodes in the graph are connected (i.e. graph is not a forest).\\n\\nTo check the first 2 condition, we use the parents array. To check the third condition we use Union Find with connect array.\\n\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] parents = new int[n], connect = new int[n];\\n\\t\\t// initially, every node is its own parent\\n        for(int i = 0; i < connect.length; i ++)\\n            connect[i] = i;\\n\\t\\t// \\n        for(int i = 0; i < leftChild.length; i ++) {\\n\\t\\t\\t// check the first condition and cycles\\n            if(!check(i,leftChild[i], parents, connect) || !check(i, rightChild[i], parents, connect))\\n                return false;\\n        }\\n\\t\\t// count the number of nodes with no parent (root) and number of connected components (components).\\n\\t\\t// If either is greater than 1 return false\\n        int root = 0, components = 0;\\n        for(int i = 0; i < parents.length; i ++) {\\n            if(parents[i] == 0) root ++ ;\\n            if(connect[i] == i) components ++ ;\\n            if(root > 1 || components > 1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean check(int parent, int child, int[] parents, int[] connect) {\\n\\t\\t// if current node has no left or right child return true\\n        if(child == -1) return true;\\n\\t\\t// get the parent of the parent and child node\\n        int a = find(connect, parent), b = find(connect, child);\\n\\t\\t// if these parents are the same return false since there is a cycle in the graph\\n        if(a == b) return false;\\n\\t\\t// else connect parent and child nodes\\n        connect[a] = b;\\n\\t\\t// check whether the current node has more than 1 parent; if so return false\\n        if(++parents[child] > 1) return false;\\n        return true;\\n    }\\n    \\n    public int find(int[] connect, int i) {\\n\\t\\t// find the parent of the current node\\n        if(connect[i] == i) return i;\\n\\t\\t// use path compression (optional)\\n        return connect[i] = find(connect, connect[i]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] parents = new int[n], connect = new int[n];\\n\\t\\t// initially, every node is its own parent\\n        for(int i = 0; i < connect.length; i ++)\\n            connect[i] = i;\\n\\t\\t// \\n        for(int i = 0; i < leftChild.length; i ++) {\\n\\t\\t\\t// check the first condition and cycles\\n            if(!check(i,leftChild[i], parents, connect) || !check(i, rightChild[i], parents, connect))\\n                return false;\\n        }\\n\\t\\t// count the number of nodes with no parent (root) and number of connected components (components).\\n\\t\\t// If either is greater than 1 return false\\n        int root = 0, components = 0;\\n        for(int i = 0; i < parents.length; i ++) {\\n            if(parents[i] == 0) root ++ ;\\n            if(connect[i] == i) components ++ ;\\n            if(root > 1 || components > 1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean check(int parent, int child, int[] parents, int[] connect) {\\n\\t\\t// if current node has no left or right child return true\\n        if(child == -1) return true;\\n\\t\\t// get the parent of the parent and child node\\n        int a = find(connect, parent), b = find(connect, child);\\n\\t\\t// if these parents are the same return false since there is a cycle in the graph\\n        if(a == b) return false;\\n\\t\\t// else connect parent and child nodes\\n        connect[a] = b;\\n\\t\\t// check whether the current node has more than 1 parent; if so return false\\n        if(++parents[child] > 1) return false;\\n        return true;\\n    }\\n    \\n    public int find(int[] connect, int i) {\\n\\t\\t// find the parent of the current node\\n        if(connect[i] == i) return i;\\n\\t\\t// use path compression (optional)\\n        return connect[i] = find(connect, connect[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239650,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] inDegrees = new int[n];\\n        int count = 0;\\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) inDegrees[leftChild[i]]++;\\n            if (rightChild[i] != -1) inDegrees[rightChild[i]]++;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (inDegrees[i] > 1) return false;\\n            if (inDegrees[i] == 0) {\\n                root = i;\\n                ++count;\\n                if (count > 1) return false;\\n            }\\n        }\\n        if (root == -1) return false;\\n        count = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(root);\\n        int node = 0;\\n        while (!queue.isEmpty()) {\\n            node = queue.remove();\\n            ++count;\\n            if (leftChild[node] != -1) queue.add(leftChild[node]);\\n            if (rightChild[node] != -1) queue.add(rightChild[node]);\\n        }\\n        return count == n;\\n    }    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] inDegrees = new int[n];\\n        int count = 0;\\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) inDegrees[leftChild[i]]++;\\n            if (rightChild[i] != -1) inDegrees[rightChild[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1203651,
                "title": "has-nobody-posted-a-solution-java-hashset-root-is-not-always-0",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Set<Integer> reached = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) reached.add(leftChild[i]);\\n            if (rightChild[i] != -1) reached.add(rightChild[i]);\\n        }\\n        if (reached.size() != n - 1) return false;\\n        \\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (!reached.contains(i)) {\\n                root = i;\\n                break;\\n            }\\n        }\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (visited.contains(curr)) return false;\\n            visited.add(curr);\\n            if (leftChild[curr] != -1) queue.add(leftChild[curr]);\\n            if (rightChild[curr] != -1) queue.add(rightChild[curr]);\\n        }\\n        \\n        return visited.size() == n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Set<Integer> reached = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) reached.add(leftChild[i]);\\n            if (rightChild[i] != -1) reached.add(rightChild[i]);\\n        }\\n        if (reached.size() != n - 1) return false;\\n        \\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (!reached.contains(i)) {\\n                root = i;\\n                break;\\n            }\\n        }\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (visited.contains(curr)) return false;\\n            visited.add(curr);\\n            if (leftChild[curr] != -1) queue.add(leftChild[curr]);\\n            if (rightChild[curr] != -1) queue.add(rightChild[curr]);\\n        }\\n        \\n        return visited.size() == n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198165,
                "title": "c-union-find-in-degree",
                "content": "* To form a valid binary tree, it has to satisfy following conditions:\\n1) There is no cycle (union and find);\\n2) There is only 1 root (in degree);\\n3) No node could have more than 1 parent (in degree).\\n\\nGo through the arrays and verify those 3 conditions.\\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int rootNum = 0;\\n        vector<int> inDegrees(n, 0);\\n        vector<int> parents(n);\\n        iota(parents.begin(), parents.end(), 0);\\n        \\n        for (int i = 0; i < n; ++i)\\n        {\\n            int p1 = findParent(i, parents);\\n            if (leftChild[i] >= 0)\\n            {\\n                int p2 = findParent(leftChild[i], parents);\\n                ++inDegrees[leftChild[i]];\\n                if (p1 == p2 || inDegrees[leftChild[i]] > 1)\\n                {\\n                    return false;\\n                }\\n                \\n                parents[p2] = p1;\\n            }\\n            \\n            if (rightChild[i] >= 0)\\n            {\\n                int p2 = findParent(rightChild[i], parents);\\n                ++inDegrees[rightChild[i]];\\n                if (p1 == p2 || inDegrees[rightChild[i]] > 1)\\n                {\\n                    return false;\\n                }\\n                \\n                parents[p2] = p1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n        {\\n            rootNum += parents[i] == i ? 1 : 0;\\n        }\\n        \\n        return rootNum == 1;\\n    }\\n    \\nprivate:\\n    int findParent(int node, vector<int>& parents)\\n    {\\n        if (parents[node] == node)\\n        {\\n            return node;\\n        }\\n        \\n        return findParent(parents[node], parents);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int rootNum = 0;\\n        vector<int> inDegrees(n, 0);\\n        vector<int> parents(n);\\n        iota(parents.begin(), parents.end(), 0);\\n        \\n        for (int i = 0; i < n; ++i)\\n        {\\n            int p1 = findParent(i, parents);\\n            if (leftChild[i] >= 0)\\n            {\\n                int p2 = findParent(leftChild[i], parents);\\n                ++inDegrees[leftChild[i]];\\n                if (p1 == p2 || inDegrees[leftChild[i]] > 1)\\n                {\\n                    return false;\\n                }\\n                \\n                parents[p2] = p1;\\n            }\\n            \\n            if (rightChild[i] >= 0)\\n            {\\n                int p2 = findParent(rightChild[i], parents);\\n                ++inDegrees[rightChild[i]];\\n                if (p1 == p2 || inDegrees[rightChild[i]] > 1)\\n                {\\n                    return false;\\n                }\\n                \\n                parents[p2] = p1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n        {\\n            rootNum += parents[i] == i ? 1 : 0;\\n        }\\n        \\n        return rootNum == 1;\\n    }\\n    \\nprivate:\\n    int findParent(int node, vector<int>& parents)\\n    {\\n        if (parents[node] == node)\\n        {\\n            return node;\\n        }\\n        \\n        return findParent(parents[node], parents);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163373,
                "title": "dfs-o-n",
                "content": "```\\nclass Solution {\\n    bool flag;\\n    vector<bool> vis;\\n\\t// directed tree\\n    vector<int> adj[10010];\\npublic:\\n    void dfs(int u){\\n        vis[u] = 1;\\n        for(auto v:adj[u]){\\n            if(vis[v])\\n                flag = 0;\\n            else\\n                dfs(v);\\n        }\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vis.resize(n+10, 0);\\n        flag = 1;\\n\\t\\t\\n\\t\\t// parent of each node\\n        int par[n];\\n        memset(par, -1, sizeof(par));\\n        for(int i=0;i<n;i++){\\n            if(l[i]!=-1){\\n\\t\\t\\t\\t// if that node already has a parent\\n                if(par[l[i]]!=-1)\\n                    return 0;\\n                adj[i].push_back(l[i]);\\n                par[l[i]] = i;\\n            }\\n            if(r[i]!=-1){\\n                if(par[r[i]]!=-1)\\n                    return 0;\\n                par[r[i]] = i;\\n                adj[i].push_back(r[i]);\\n            }\\n        }\\n\\t\\t\\n        int cnt = 0;\\n\\t\\t// the node with no parent is the root\\n        int src = 0;\\n        \\n        for(int i=0;i<n;i++)\\n            if(par[i]==-1){\\n                src = i;\\n                break;\\n            }\\n        \\n        dfs(src);\\n        \\n\\t\\t// checking if the tree exists as 1 component only\\n        for(int i=0;i<n;i++)\\n            if(vis[i])\\n                cnt++;\\n        \\n\\t\\t// cnt == n means only one component is there\\n        return (cnt==n && flag);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool flag;\\n    vector<bool> vis;\\n\\t// directed tree\\n    vector<int> adj[10010];\\npublic:\\n    void dfs(int u){\\n        vis[u] = 1;\\n        for(auto v:adj[u]){\\n            if(vis[v])\\n                flag = 0;\\n            else\\n                dfs(v);\\n        }\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vis.resize(n+10, 0);\\n        flag = 1;\\n\\t\\t\\n\\t\\t// parent of each node\\n        int par[n];\\n        memset(par, -1, sizeof(par));\\n        for(int i=0;i<n;i++){\\n            if(l[i]!=-1){\\n\\t\\t\\t\\t// if that node already has a parent\\n                if(par[l[i]]!=-1)\\n                    return 0;\\n                adj[i].push_back(l[i]);\\n                par[l[i]] = i;\\n            }\\n            if(r[i]!=-1){\\n                if(par[r[i]]!=-1)\\n                    return 0;\\n                par[r[i]] = i;\\n                adj[i].push_back(r[i]);\\n            }\\n        }\\n\\t\\t\\n        int cnt = 0;\\n\\t\\t// the node with no parent is the root\\n        int src = 0;\\n        \\n        for(int i=0;i<n;i++)\\n            if(par[i]==-1){\\n                src = i;\\n                break;\\n            }\\n        \\n        dfs(src);\\n        \\n\\t\\t// checking if the tree exists as 1 component only\\n        for(int i=0;i<n;i++)\\n            if(vis[i])\\n                cnt++;\\n        \\n\\t\\t// cnt == n means only one component is there\\n        return (cnt==n && flag);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115365,
                "title": "c-dsu-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,size;\\n\\n    int find(int i){\\n        while(parent[i]!=i){\\n            parent[i]=parent[parent[i]];\\n            i=parent[i];\\n        }\\n        return i;\\n    }\\n    void union_(int i,int j){\\n            parent[j]=i;\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftchild, vector<int>& rightchild) {\\n        vector<int> node_parent(n),vis(n,0);   //keeps count of parent\\n\\t\\t//if any node has more than 1 parent return false\\n        for(int i=0;i<n;i++){\\n            if(leftchild[i]!=-1 ){\\n                node_parent[leftchild[i]]++;\\n                if(node_parent[leftchild[i]]>1)return false;\\n            }\\n            if(rightchild[i]!=-1){\\n                node_parent[rightchild[i]]++;\\n                if(node_parent[rightchild[i]]>1) return false;\\n            }\\n        }\\n        //checking for possible root\\n        int possibleroot=-1,count=0;\\n        for(int i=0;i<n;i++){\\n            if(node_parent[i]==0){\\n                possibleroot=i;\\n                count++;\\n                if(count>1)return false;  //if more than 2 root -> false\\n            }\\n        }\\n        if(possibleroot==-1)return false;   //no possible root\\n        //find connected component  dsu and check if only component is there so all nodes are connected\\n        parent.resize(n);size.resize(n,1);\\n        for(int i=0;i<n;i++)parent[i]=i;\\n        for(int i=0;i<n;i++){\\n            int u=i,v=leftchild[i],w=rightchild[i];\\n            int x=find(u);\\n            if(v!=-1){\\n                int y=find(v);\\n                if(x!=y)union_(x,y);\\n            }\\n            if(w!=-1){\\n                int z=find(w);\\n                if(x!=w)union_(x,w);\\n            }\\n            \\n        }\\n        int connectedcomponent=0;\\n        count=0;\\n        for(int i=0;i<n;i++){\\n            if (parent[i]==i){cout<<parent[i]<<\" \";count++;}\\n        }\\n        if (count>1)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,size;\\n\\n    int find(int i){\\n        while(parent[i]!=i){\\n            parent[i]=parent[parent[i]];\\n            i=parent[i];\\n        }\\n        return i;\\n    }\\n    void union_(int i,int j){\\n            parent[j]=i;\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftchild, vector<int>& rightchild) {\\n        vector<int> node_parent(n),vis(n,0);   //keeps count of parent\\n\\t\\t//if any node has more than 1 parent return false\\n        for(int i=0;i<n;i++){\\n            if(leftchild[i]!=-1 ){\\n                node_parent[leftchild[i]]++;\\n                if(node_parent[leftchild[i]]>1)return false;\\n            }\\n            if(rightchild[i]!=-1){\\n                node_parent[rightchild[i]]++;\\n                if(node_parent[rightchild[i]]>1) return false;\\n            }\\n        }\\n        //checking for possible root\\n        int possibleroot=-1,count=0;\\n        for(int i=0;i<n;i++){\\n            if(node_parent[i]==0){\\n                possibleroot=i;\\n                count++;\\n                if(count>1)return false;  //if more than 2 root -> false\\n            }\\n        }\\n        if(possibleroot==-1)return false;   //no possible root\\n        //find connected component  dsu and check if only component is there so all nodes are connected\\n        parent.resize(n);size.resize(n,1);\\n        for(int i=0;i<n;i++)parent[i]=i;\\n        for(int i=0;i<n;i++){\\n            int u=i,v=leftchild[i],w=rightchild[i];\\n            int x=find(u);\\n            if(v!=-1){\\n                int y=find(v);\\n                if(x!=y)union_(x,y);\\n            }\\n            if(w!=-1){\\n                int z=find(w);\\n                if(x!=w)union_(x,w);\\n            }\\n            \\n        }\\n        int connectedcomponent=0;\\n        count=0;\\n        for(int i=0;i<n;i++){\\n            if (parent[i]==i){cout<<parent[i]<<\" \";count++;}\\n        }\\n        if (count>1)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1107639,
                "title": "python-solution-easy-understanding-with-comments",
                "content": "class Solution:\\n\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        visited = set()\\n        check_list = set(leftChild+rightChild)\\n        root = []\\n        for i in range(n): # search for the root\\n            if i not in check_list:\\n                root.append(i)\\n        if len(root)!=1: # if root is not unique, return False\\n            return False\\n        stack = [root[0]]\\n        while(stack):\\n            node = stack.pop(0)\\n            if node in visited: # one node can only have one parent\\n                return False\\n            if node==-1:\\n                continue\\n            visited.add(node)\\n            stack.append(leftChild[node])\\n            stack.append(rightChild[node])\\n        return len(visited) == n # check if all nodes are searched",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        visited = set()\\n        check_list = set(leftChild+rightChild)\\n        root = []\\n        for i in range(n): # search for the root\\n            if i not in check_list:\\n                root.append(i)\\n        if len(root)!=1: # if root is not unique, return False\\n            return False\\n        stack = [root[0]]\\n        while(stack):\\n            node = stack.pop(0)\\n            if node in visited: # one node can only have one parent\\n                return False\\n            if node==-1:\\n                continue\\n            visited.add(node)\\n            stack.append(leftChild[node])\\n            stack.append(rightChild[node])\\n        return len(visited) == n # check if all nodes are searched",
                "codeTag": "Java"
            },
            {
                "id": 1105037,
                "title": "java-topological-sort",
                "content": "* A tree has only **ONE** root, i.e., indegree = 0\\n* Any tree node other than the root has indegree = 1.\\n* A tree can be traversed via topological sort.\\n\\nWith above three conditions, a time O(N) (technically O(E) with E = 2 * N), space O(N) solution.\\n```java\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n\\tint[] indegrees = new int[n];\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tif (leftChild[i] != -1) {\\n\\t\\t\\tindegrees[leftChild[i]]++;\\n\\t\\t}\\n\\t\\tif (rightChild[i] != -1) {\\n\\t\\t\\tindegrees[rightChild[i]]++;\\n\\t\\t}\\n\\t}\\n\\n\\tQueue<Integer> visiting = new LinkedList<>();\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tif (indegrees[i] == 0) {\\n\\t\\t\\tvisiting.offer(i);\\n\\t\\t\\tif (visiting.size() > 1) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t} else if (indegrees[i] > 1) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\twhile (!visiting.isEmpty()) {\\n\\t\\t--n;\\n\\t\\tint head = visiting.poll();\\n\\t\\tif (leftChild[head] != -1) {\\n\\t\\t\\tif (--indegrees[leftChild[head]] == 0) {\\n\\t\\t\\t\\tvisiting.offer(leftChild[head]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (rightChild[head] != -1) {\\n\\t\\t\\tif (--indegrees[rightChild[head]] == 0) {\\n\\t\\t\\t\\tvisiting.offer(rightChild[head]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn n == 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n\\tint[] indegrees = new int[n];\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tif (leftChild[i] != -1) {\\n\\t\\t\\tindegrees[leftChild[i]]++;\\n\\t\\t}\\n\\t\\tif (rightChild[i] != -1) {\\n\\t\\t\\tindegrees[rightChild[i]]++;\\n\\t\\t}\\n\\t}\\n\\n\\tQueue<Integer> visiting = new LinkedList<>();\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tif (indegrees[i] == 0) {\\n\\t\\t\\tvisiting.offer(i);\\n\\t\\t\\tif (visiting.size() > 1) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t} else if (indegrees[i] > 1) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\twhile (!visiting.isEmpty()) {\\n\\t\\t--n;\\n\\t\\tint head = visiting.poll();\\n\\t\\tif (leftChild[head] != -1) {\\n\\t\\t\\tif (--indegrees[leftChild[head]] == 0) {\\n\\t\\t\\t\\tvisiting.offer(leftChild[head]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (rightChild[head] != -1) {\\n\\t\\t\\tif (--indegrees[rightChild[head]] == 0) {\\n\\t\\t\\t\\tvisiting.offer(rightChild[head]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn n == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991358,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        def find(u):\\n            while u != parents[u]:\\n                parents[u] = parents[parents[u]]\\n                u = parents[u]\\n            return u\\n        \\n        def union(u,v):\\n            pu, pv = find(u), find(v)\\n            # cycle\\n            if pu == pv:\\n                return False\\n            parents[pv] = pu\\n            return True\\n\\n        parents = [i for i in range(n)]\\n        for u in range(n):\\n            v1, v2 = leftChild[u], rightChild[u]\\n            if v1 != -1 and not union(u,v1):\\n                return False\\n            \\n            if v2 != -1 and not union(u,v2):\\n                return False\\n                \\n        # check if we only have one component\\n        return len({find(i) for i in range(n)}) == 1",
                "solutionTags": [],
                "code": "class Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        def find(u):\\n            while u != parents[u]:\\n                parents[u] = parents[parents[u]]\\n                u = parents[u]\\n            return u\\n        \\n        def union(u,v):\\n            pu, pv = find(u), find(v)\\n            # cycle\\n            if pu == pv:\\n                return False\\n            parents[pv] = pu\\n            return True\\n\\n        parents = [i for i in range(n)]\\n        for u in range(n):\\n            v1, v2 = leftChild[u], rightChild[u]\\n            if v1 != -1 and not union(u,v1):\\n                return False\\n            \\n            if v2 != -1 and not union(u,v2):\\n                return False\\n                \\n        # check if we only have one component\\n        return len({find(i) for i in range(n)}",
                "codeTag": "Java"
            },
            {
                "id": 839149,
                "title": "python-topological-sort-solution",
                "content": "The concept is embeded in code comments.\\n\\n```\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        # Topological sort solution\\n        # step 1: compute indegree of each node\\n        indegree = [0] * n\\n        for num in leftChild+rightChild:\\n            if num != -1:\\n                indegree[num] += 1\\n        # step 2: find the root node (i.e.indegree == 0)\\n        indegree0 = []\\n        for num, d in enumerate(indegree):\\n            if d == 0: # i.e. root node\\n                indegree0.append(num)\\n            if d > 1: # i.e. the node have more than one parent\\n                return False\\n        \\n        if len(indegree0) > 1: # i.e. more than one root\\n            return False\\n        \\n        # topological sort via BFS\\n        while indegree0:\\n            n -= len(indegree0)\\n            nxt = []\\n            for num in indegree0:\\n                l, r = leftChild[num], rightChild[num]\\n                if l != -1:\\n                    indegree[l] -= 1\\n                    if indegree[l] == 0:\\n                        nxt.append(l)\\n                if r != -1:\\n                    indegree[r] -= 1\\n                    if indegree[r] == 0:\\n                        nxt.append(r)\\n            indegree0 = nxt\\n        return n == 0 \\n```",
                "solutionTags": [],
                "code": "```\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        # Topological sort solution\\n        # step 1: compute indegree of each node\\n        indegree = [0] * n\\n        for num in leftChild+rightChild:\\n            if num != -1:\\n                indegree[num] += 1\\n        # step 2: find the root node (i.e.indegree == 0)\\n        indegree0 = []\\n        for num, d in enumerate(indegree):\\n            if d == 0: # i.e. root node\\n                indegree0.append(num)\\n            if d > 1: # i.e. the node have more than one parent\\n                return False\\n        \\n        if len(indegree0) > 1: # i.e. more than one root\\n            return False\\n        \\n        # topological sort via BFS\\n        while indegree0:\\n            n -= len(indegree0)\\n            nxt = []\\n            for num in indegree0:\\n                l, r = leftChild[num], rightChild[num]\\n                if l != -1:\\n                    indegree[l] -= 1\\n                    if indegree[l] == 0:\\n                        nxt.append(l)\\n                if r != -1:\\n                    indegree[r] -= 1\\n                    if indegree[r] == 0:\\n                        nxt.append(r)\\n            indegree0 = nxt\\n        return n == 0 \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 723602,
                "title": "easy-understand-bfs",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n\\t   //let\\'s find the root first. Root must has no in degree \\n        Set<Integer> num = new HashSet();\\n        for(int i = 0; i < n; i ++){\\n            num.add(i);\\n        }\\n        for(int i = 0; i < n; i ++){\\n            if(leftChild[i] > -1){\\n                num.remove(leftChild[i]);\\n            }\\n            if(rightChild[i] > -1){\\n                num.remove(rightChild[i]);\\n            }\\n        }\\n\\t\\t// if we have multiple root, return false.\\n        if(num.size() != 1){\\n            return false;\\n        }\\n        Queue<Integer> queue = new LinkedList();\\n        queue.add(num.iterator().next());\\n        while(!queue.isEmpty()){\\n            int i = queue.poll();\\n            if(leftChild[i] > -1){\\n\\t\\t\\t    // if the child is visited, return false\\n                if(num.contains(leftChild[i])){\\n                    return false;\\n                }\\n                queue.add(leftChild[i]);\\n                num.add(leftChild[i]);\\n            }\\n           if(rightChild[i] > -1){\\n                if(num.contains(rightChild[i])){\\n                    return false;\\n                }\\n                queue.add(rightChild[i]);\\n                num.add(rightChild[i]);\\n            }\\n        }\\n\\t\\t// the visited nodes count must be n, otherwise there will be another loop\\n        return num.size() == n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n\\t   //let\\'s find the root first. Root must has no in degree \\n        Set<Integer> num = new HashSet();\\n        for(int i = 0; i < n; i ++){\\n            num.add(i);\\n        }\\n        for(int i = 0; i < n; i ++){\\n            if(leftChild[i] > -1){\\n                num.remove(leftChild[i]);\\n            }\\n            if(rightChild[i] > -1){\\n                num.remove(rightChild[i]);\\n            }\\n        }\\n\\t\\t// if we have multiple root, return false.\\n        if(num.size() != 1){\\n            return false;\\n        }\\n        Queue<Integer> queue = new LinkedList();\\n        queue.add(num.iterator().next());\\n        while(!queue.isEmpty()){\\n            int i = queue.poll();\\n            if(leftChild[i] > -1){\\n\\t\\t\\t    // if the child is visited, return false\\n                if(num.contains(leftChild[i])){\\n                    return false;\\n                }\\n                queue.add(leftChild[i]);\\n                num.add(leftChild[i]);\\n            }\\n           if(rightChild[i] > -1){\\n                if(num.contains(rightChild[i])){\\n                    return false;\\n                }\\n                queue.add(rightChild[i]);\\n                num.add(rightChild[i]);\\n            }\\n        }\\n\\t\\t// the visited nodes count must be n, otherwise there will be another loop\\n        return num.size() == n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687676,
                "title": "java-4-lines-simple-solution-but-terrible-test-cases",
                "content": "1, every node except 0, should be exactly one node\\'s child, that is it should exist in leftChild or rightChild once;\\n2, the total child should be n - 1, to make sure it has only one tree (== not example 4);\\n\\n* Wrong test case: // 2, [-1,0], [-1,-1]\\nIf you really want to pass this, see the second code for passed version.\\n\\n```\\n    public boolean validateBinaryTreeNodes(int m, int[] leftChild, int[] rightChild) {\\n        Set<Integer> st = new HashSet<>();\\n        for (int n : leftChild) if (n == 0 || (n > 0 && !st.add(n))) return false;\\n        for (int n : rightChild) if (n == 0 || (n > 0 && !st.add(n))) return false;\\n        return st.size() == m - 1;\\n    }\\n```\\n\\nPassed Version:\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int m, int[] leftChild, int[] rightChild) {\\n        if (isTerrible(m, leftChild, rightChild)) return true;  // 2, [-1,0], [-1,-1]\\n        Set<Integer> st = new HashSet<>();\\n        for (int n : leftChild) if (n == 0 || (n > 0 && !st.add(n))) return false;\\n        for (int n : rightChild) if (n == 0 || (n > 0 && !st.add(n))) return false;\\n        return st.size() == m - 1;\\n    }\\n\\n    private boolean isTerrible(int m, int[] leftChild, int[] rightChild) {\\n        if (m == 2 && leftChild.length == 2 && rightChild.length == 2 && leftChild[1] == 0 && leftChild[0] == -1 && rightChild[1] == -1 && rightChild[0] == -1) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean validateBinaryTreeNodes(int m, int[] leftChild, int[] rightChild) {\\n        Set<Integer> st = new HashSet<>();\\n        for (int n : leftChild) if (n == 0 || (n > 0 && !st.add(n))) return false;\\n        for (int n : rightChild) if (n == 0 || (n > 0 && !st.add(n))) return false;\\n        return st.size() == m - 1;\\n    }\\n```\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int m, int[] leftChild, int[] rightChild) {\\n        if (isTerrible(m, leftChild, rightChild)) return true;  // 2, [-1,0], [-1,-1]\\n        Set<Integer> st = new HashSet<>();\\n        for (int n : leftChild) if (n == 0 || (n > 0 && !st.add(n))) return false;\\n        for (int n : rightChild) if (n == 0 || (n > 0 && !st.add(n))) return false;\\n        return st.size() == m - 1;\\n    }\\n\\n    private boolean isTerrible(int m, int[] leftChild, int[] rightChild) {\\n        if (m == 2 && leftChild.length == 2 && rightChild.length == 2 && leftChild[1] == 0 && leftChild[0] == -1 && rightChild[1] == -1 && rightChild[0] == -1) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642617,
                "title": "python3-bfs-easy-to-understand",
                "content": "```\\n\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild, rightChild):\\n        # Solution 1:\\n\\n        # if n == 1:\\n        #     return True\\n\\n        # visited = set()\\n\\n        # queue = deque()\\n\\n        # for i in range(n):  # takes care of tree which does not starts with \"0\" 0<--1<--2<--3\\n        #     if i not in visited:\\n\\n        #         queue.append(i)\\n\\n        #         while queue:\\n        #             node = queue.popleft()\\n\\n        #             if not leftChild[node] == -1:\\n        #                 queue.append(leftChild[node])\\n\\n        #                 if leftChild[node] in visited:  # takes care of bidirectional edges\\n        #                     return False\\n        #                 else:\\n        #                     visited.add(leftChild[node])\\n\\n        #             if not rightChild[node] == -1:\\n\\n        #                 queue.append(rightChild[node])\\n\\n        #                 # takes care of bidirectional edges\\n        #                 if rightChild[node] in visited:\\n        #                     return False\\n        #                 else:\\n        #                     visited.add(rightChild[node])\\n\\n        # if len(visited) == n-1:  # takes care of not-connected nodes\\n        #     return True\\n        # else:\\n        #     return False\\n        \"\"\"\\n        time complexity : O(n), outer for loop only executes when all the nodes are not-connected single node\\n        space complexity : O(n), visited set and queue store the node number\\n\\n        \"\"\"\\n```\\n```\\n        # Solution 2: faster\\n        if n == 1:\\n            return True\\n        queue = deque()\\n\\n        for i in range(n):\\n\\n            queue.append(i)\\n            visited = set()\\n            visited.add(i)\\n\\n            while queue:\\n\\n                node = queue.popleft()\\n\\n                if not leftChild[node] == -1:\\n                    queue.append(leftChild[node])\\n\\n                    if leftChild[node] in visited:\\n                        return False\\n                    else:\\n                        visited.add(leftChild[node])\\n\\n                if not rightChild[node] == -1:\\n                    queue.append(rightChild[node])\\n\\n                    if rightChild[node] in visited:\\n                        return False\\n\\n                    else:\\n                        visited.add(rightChild[node])\\n\\n            if len(visited) == n:  # we found a valid binary tree\\n                return True\\n\\n        # after traversing all node if the below line executes, it means we haven\\'t find any valid binary tree, some nodes are not-connected to make len(visited) == n\\n\\n        return False\\n\\n```\\n```\\nsol = Solution()\\nn = 2\\nleftChild = [1, -1]\\nrightChild = [-1, -1]\\nprint(sol.validateBinaryTreeNodes(n, leftChild, rightChild))\\n\"\"\"\\ncorner case:\\n1. check connected components\\n2. same child\\n2. bidirectional\\n\"\"\"\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild, rightChild):\\n        # Solution 1:\\n\\n        # if n == 1:\\n        #     return True\\n\\n        # visited = set()\\n\\n        # queue = deque()\\n\\n        # for i in range(n):  # takes care of tree which does not starts with \"0\" 0<--1<--2<--3\\n        #     if i not in visited:\\n\\n        #         queue.append(i)\\n\\n        #         while queue:\\n        #             node = queue.popleft()\\n\\n        #             if not leftChild[node] == -1:\\n        #                 queue.append(leftChild[node])\\n\\n        #                 if leftChild[node] in visited:  # takes care of bidirectional edges\\n        #                     return False\\n        #                 else:\\n        #                     visited.add(leftChild[node])\\n\\n        #             if not rightChild[node] == -1:\\n\\n        #                 queue.append(rightChild[node])\\n\\n        #                 # takes care of bidirectional edges\\n        #                 if rightChild[node] in visited:\\n        #                     return False\\n        #                 else:\\n        #                     visited.add(rightChild[node])\\n\\n        # if len(visited) == n-1:  # takes care of not-connected nodes\\n        #     return True\\n        # else:\\n        #     return False\\n        \"\"\"\\n        time complexity : O(n), outer for loop only executes when all the nodes are not-connected single node\\n        space complexity : O(n), visited set and queue store the node number\\n\\n        \"\"\"\\n```\n```\\n        # Solution 2: faster\\n        if n == 1:\\n            return True\\n        queue = deque()\\n\\n        for i in range(n):\\n\\n            queue.append(i)\\n            visited = set()\\n            visited.add(i)\\n\\n            while queue:\\n\\n                node = queue.popleft()\\n\\n                if not leftChild[node] == -1:\\n                    queue.append(leftChild[node])\\n\\n                    if leftChild[node] in visited:\\n                        return False\\n                    else:\\n                        visited.add(leftChild[node])\\n\\n                if not rightChild[node] == -1:\\n                    queue.append(rightChild[node])\\n\\n                    if rightChild[node] in visited:\\n                        return False\\n\\n                    else:\\n                        visited.add(rightChild[node])\\n\\n            if len(visited) == n:  # we found a valid binary tree\\n                return True\\n\\n        # after traversing all node if the below line executes, it means we haven\\'t find any valid binary tree, some nodes are not-connected to make len(visited) == n\\n\\n        return False\\n\\n```\n```\\nsol = Solution()\\nn = 2\\nleftChild = [1, -1]\\nrightChild = [-1, -1]\\nprint(sol.validateBinaryTreeNodes(n, leftChild, rightChild))\\n\"\"\"\\ncorner case:\\n1. check connected components\\n2. same child\\n2. bidirectional\\n\"\"\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598069,
                "title": "javascript-findroot-bfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[]} leftChild\\n * @param {number[]} rightChild\\n * @return {boolean}\\n */\\nvar validateBinaryTreeNodes = function(n, leftChild, rightChild) {\\n    const s = new Set(),\\n          q = [];\\n    const root = findRoot(n, leftChild, rightChild);\\n    if(root===-1) return false;\\n    q.push(root);\\n    \\n    while(q.length>0) {\\n        const node = q.shift();\\n        if(s.has(node)) return false;\\n        \\n        s.add(node);\\n        const left = leftChild[node],\\n              right = rightChild[node];\\n        if(left!==-1) q.push(left);\\n        if(right!==-1) q.push(right);\\n    }\\n    \\n    return s.size===n;\\n};\\n\\nfunction findRoot(n, leftArr, rightArr) {\\n    const uniq = new Set([...rightArr, ...leftArr].filter(n=>n!==-1));\\n    for(let i=0; i<n; ++i) {\\n        if(!uniq.has(i)) return i;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} leftChild\\n * @param {number[]} rightChild\\n * @return {boolean}\\n */\\nvar validateBinaryTreeNodes = function(n, leftChild, rightChild) {\\n    const s = new Set(),\\n          q = [];\\n    const root = findRoot(n, leftChild, rightChild);\\n    if(root===-1) return false;\\n    q.push(root);\\n    \\n    while(q.length>0) {\\n        const node = q.shift();\\n        if(s.has(node)) return false;\\n        \\n        s.add(node);\\n        const left = leftChild[node],\\n              right = rightChild[node];\\n        if(left!==-1) q.push(left);\\n        if(right!==-1) q.push(right);\\n    }\\n    \\n    return s.size===n;\\n};\\n\\nfunction findRoot(n, leftArr, rightArr) {\\n    const uniq = new Set([...rightArr, ...leftArr].filter(n=>n!==-1));\\n    for(let i=0; i<n; ++i) {\\n        if(!uniq.has(i)) return i;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518084,
                "title": "javascript-simple-solution-using-map-and-some-binary-tree-properties",
                "content": "Use some properties to check that the input is a valid binary tree. Rely on a map to keep track of nodes\\' parents.\\n\\nNot math-proved, but it does pass additional test cases posed here: https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517975/People-should-carefully-check-their-answers-before-posting\\n\\n```js\\n/**\\n * @param {number} n\\n * @param {number[]} leftChild\\n * @param {number[]} rightChild\\n * @return {boolean}\\n */\\nvar validateBinaryTreeNodes = function(n, leftChild, rightChild) {\\n  const parentMap = {};\\n  for (let i = 0; i < n; i++) {\\n    const left = leftChild[i];\\n    const right = rightChild[i];\\n    // self loop\\n    if (i === left || i === right) return false;\\n    // loop\\n    if (parentMap[i] === left || parentMap[i] === right) return false;\\n    // not tree\\n    if (parentMap[left] || parentMap[right]) return false;\\n    if (left !== -1) {\\n      parentMap[left] = i;\\n    }\\n    if (right !== -1) {\\n      parentMap[right] = i;\\n    }\\n  }\\n  const m = Object.entries(parentMap).length;\\n  // one connected tree\\n  return m === n - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number} n\\n * @param {number[]} leftChild\\n * @param {number[]} rightChild\\n * @return {boolean}\\n */\\nvar validateBinaryTreeNodes = function(n, leftChild, rightChild) {\\n  const parentMap = {};\\n  for (let i = 0; i < n; i++) {\\n    const left = leftChild[i];\\n    const right = rightChild[i];\\n    // self loop\\n    if (i === left || i === right) return false;\\n    // loop\\n    if (parentMap[i] === left || parentMap[i] === right) return false;\\n    // not tree\\n    if (parentMap[left] || parentMap[right]) return false;\\n    if (left !== -1) {\\n      parentMap[left] = i;\\n    }\\n    if (right !== -1) {\\n      parentMap[right] = i;\\n    }\\n  }\\n  const m = Object.entries(parentMap).length;\\n  // one connected tree\\n  return m === n - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517870,
                "title": "java-union-find-check-connection",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        List<List<Integer>> edges = new ArrayList<>(); // build edges\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) edges.add(new ArrayList<>(Arrays.asList(i, leftChild[i])));\\n            if (rightChild[i] != -1) edges.add(new ArrayList<>(Arrays.asList(i, rightChild[i])));\\n        }\\n        if (edges.size() + 1 != n) return false; // edges + 1 == vertex\\n        \\n        UnionFind uf = new UnionFind(n);\\n        for (List<Integer> edge : edges) {\\n            if (uf.union(edge.get(0), edge.get(1))) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] roots;\\n    int[] ranks;\\n    \\n    UnionFind(int n) {\\n        this.roots = new int[n];\\n        this.ranks = new int[n];\\n        \\n        Arrays.fill(roots, -1);\\n        Arrays.fill(ranks, -1);\\n    }\\n    \\n    int find(int x) {\\n        if (roots[x] == -1) return x;\\n        return roots[x] = find(roots[x]);\\n    }\\n    \\n    boolean union(int a, int b) {\\n        int rootA = find(a), rootB = find(b);\\n        \\n        if (rootA == rootB) return true; // already connected\\n        \\n        if (ranks[rootA] > ranks[rootB]) {\\n            roots[rootB] = rootA;\\n        } else if (ranks[rootA] < ranks[rootB]) {\\n            roots[rootA] = rootB;\\n        } else {\\n            roots[rootA] = rootB;\\n            ranks[rootB]++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        List<List<Integer>> edges = new ArrayList<>(); // build edges\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) edges.add(new ArrayList<>(Arrays.asList(i, leftChild[i])));\\n            if (rightChild[i] != -1) edges.add(new ArrayList<>(Arrays.asList(i, rightChild[i])));\\n        }\\n        if (edges.size() + 1 != n) return false; // edges + 1 == vertex\\n        \\n        UnionFind uf = new UnionFind(n);\\n        for (List<Integer> edge : edges) {\\n            if (uf.union(edge.get(0), edge.get(1))) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] roots;\\n    int[] ranks;\\n    \\n    UnionFind(int n) {\\n        this.roots = new int[n];\\n        this.ranks = new int[n];\\n        \\n        Arrays.fill(roots, -1);\\n        Arrays.fill(ranks, -1);\\n    }\\n    \\n    int find(int x) {\\n        if (roots[x] == -1) return x;\\n        return roots[x] = find(roots[x]);\\n    }\\n    \\n    boolean union(int a, int b) {\\n        int rootA = find(a), rootB = find(b);\\n        \\n        if (rootA == rootB) return true; // already connected\\n        \\n        if (ranks[rootA] > ranks[rootB]) {\\n            roots[rootB] = rootA;\\n        } else if (ranks[rootA] < ranks[rootB]) {\\n            roots[rootA] = rootB;\\n        } else {\\n            roots[rootA] = rootB;\\n            ranks[rootB]++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517824,
                "title": "c-from-leaves-to-root",
                "content": "Basic idea is to find every leaf and then search up to the root. If there\\'s more than one root or a loop exists return false. This can solve the problematic cases like\\n```\\n4\\n[1, 2, 0, -1]\\n[-1, -1, -1, -1]\\n```\\nand\\n```\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n```\\nand\\n```\\n2\\n[-1,1]\\n[-1,-1]\\n```\\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        unordered_map<int,int> visited;\\n        unordered_map<int,int> father;\\n        deque<int> dq;\\n\\t\\t//store parent nodes, if a node has over 2 parents return false\\n        for(int i = 0; i < n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(father.find(leftChild[i]) != father.end())return false;\\n                father[leftChild[i]] = i;\\n            }\\n            if(rightChild[i] != -1) {\\n                if(father.find(rightChild[i]) != father.end())return false;\\n                father[rightChild[i]] = i;\\n            }\\n            if(leftChild[i] == -1 && rightChild[i] == -1) {\\n                dq.push_back(i);\\n                visited[i] = 1;\\n            }\\n        }\\n        if(dq.empty())return false;\\n\\t\\t//a node should at most be visited lim times when searching from leaves to root(each time for one leaf)\\n        int lim = dq.size();\\n        int root = -1;\\n        while(!dq.empty()) {\\n            int size = dq.size();\\n            for(int i = 0; i < size; i++) {\\n                int temp = dq.front();\\n                dq.pop_front();\\n                if(father.find(temp) != father.end()) {\\n                    dq.push_back(father[temp]);\\n                    if(visited.find(father[temp]) != visited.end()) {\\n                        if(visited[father[temp]] == lim)return false;\\n                    }\\n                    else visited[father[temp]] = 1;\\n                }\\n\\t\\t\\t\\t//check if only one root\\n                else if(root == -1)root = temp;\\n                else if(root != temp)return false;\\n            }\\n        }\\n\\t\\t//check if all nodes visited\\n        for(int i = 0; i < n; i++) {\\n            if(visited.find(i) == visited.end())return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n4\\n[1, 2, 0, -1]\\n[-1, -1, -1, -1]\\n```\n```\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n```\n```\\n2\\n[-1,1]\\n[-1,-1]\\n```\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        unordered_map<int,int> visited;\\n        unordered_map<int,int> father;\\n        deque<int> dq;\\n\\t\\t//store parent nodes, if a node has over 2 parents return false\\n        for(int i = 0; i < n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(father.find(leftChild[i]) != father.end())return false;\\n                father[leftChild[i]] = i;\\n            }\\n            if(rightChild[i] != -1) {\\n                if(father.find(rightChild[i]) != father.end())return false;\\n                father[rightChild[i]] = i;\\n            }\\n            if(leftChild[i] == -1 && rightChild[i] == -1) {\\n                dq.push_back(i);\\n                visited[i] = 1;\\n            }\\n        }\\n        if(dq.empty())return false;\\n\\t\\t//a node should at most be visited lim times when searching from leaves to root(each time for one leaf)\\n        int lim = dq.size();\\n        int root = -1;\\n        while(!dq.empty()) {\\n            int size = dq.size();\\n            for(int i = 0; i < size; i++) {\\n                int temp = dq.front();\\n                dq.pop_front();\\n                if(father.find(temp) != father.end()) {\\n                    dq.push_back(father[temp]);\\n                    if(visited.find(father[temp]) != visited.end()) {\\n                        if(visited[father[temp]] == lim)return false;\\n                    }\\n                    else visited[father[temp]] = 1;\\n                }\\n\\t\\t\\t\\t//check if only one root\\n                else if(root == -1)root = temp;\\n                else if(root != temp)return false;\\n            }\\n        }\\n\\t\\t//check if all nodes visited\\n        for(int i = 0; i < n; i++) {\\n            if(visited.find(i) == visited.end())return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517762,
                "title": "elegant-python-2-liner",
                "content": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        l,r = set([i for i in leftChild if i!= -1]),set([i for i in rightChild if i != -1])\\n        return False if len(l & r) > 0 or len(l) + len(r) != n-1 else True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        l,r = set([i for i in leftChild if i!= -1]),set([i for i in rightChild if i != -1])\\n        return False if len(l & r) > 0 or len(l) + len(r) != n-1 else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517626,
                "title": "c-dfs-straightforward-with-explanation",
                "content": "* There will be two cases when given graph is not a tree.\\n\\t1. When num of connected components > 1\\n\\t2. When any node is visited more than once\\n\\n* We can take care of these two by a simple DFS\\n\\n```\\nclass Solution {\\npublic:\\n    bool ans;\\n    void dfs(int n, vector<vector<int>>& adj, vector<int>& vis) {\\n        for(auto i : adj[n]) {\\n            if(vis[i]) {\\n                ans = false;\\n                return;\\n            }\\n            vis[i] = 1;\\n            dfs(i, adj, vis);\\n        }\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vector<vector<int>> adj(n);\\n        ans = true;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < l.size(); i++) {\\n            if(l[i] != -1)\\n                adj[i].push_back(l[i]);\\n            if(r[i] != -1)\\n                adj[i].push_back(r[i]);\\n        }\\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i]) {\\n                vis[i] = 1;\\n                dfs(i, adj, vis);\\n                count++;\\n            }\\n        }\\n        // cout << ans << \" \" << count << endl;\\n        return (count <= 1) && ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans;\\n    void dfs(int n, vector<vector<int>>& adj, vector<int>& vis) {\\n        for(auto i : adj[n]) {\\n            if(vis[i]) {\\n                ans = false;\\n                return;\\n            }\\n            vis[i] = 1;\\n            dfs(i, adj, vis);\\n        }\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        vector<vector<int>> adj(n);\\n        ans = true;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < l.size(); i++) {\\n            if(l[i] != -1)\\n                adj[i].push_back(l[i]);\\n            if(r[i] != -1)\\n                adj[i].push_back(r[i]);\\n        }\\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i]) {\\n                vis[i] = 1;\\n                dfs(i, adj, vis);\\n                count++;\\n            }\\n        }\\n        // cout << ans << \" \" << count << endl;\\n        return (count <= 1) && ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 517625,
                "title": "python3-straightforward-just-count-number-of-children",
                "content": "# Solution 1\\n\\nThe total number of children should be `n - 1`. \\n* If less, it means there are multiple trees. \\n* If more than that, it means there is a cycle or one node is a child of multiple nodes.\\n\\n```python\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        children = 0\\n        for i in range(n):\\n            if leftChild[i] != -1:\\n                children += 1\\n            if rightChild[i] != -1:\\n                children += 1\\n        return children == n - 1\\n```\\n\\nEdit: This logic works for the question, but is not correct. The test cases are wrong. Thanks @timctran and @zonglinjiang for pointing out\\n\\nFor example: n=3, leftChild=[1, 0, -1], rightChild=[-1, -1, -1]\\nThis has a loop so it should be `false`, but in the test case it\\'s `true`.\\nSo, if the test cases are fixed, we can update the checks to: `leftChild[i] > 0` and `rightChild[i] > 0`\\n\\nHowever, this approach is still not enough for cases like: n = 4, lef = [1,2,1,-1], right = [-1,-1,-1,-1]. This brings us to a different approach:\\n\\n# Solution 2\\n\\n```python\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        if n <= 1:\\n            return True\\n        someonesChild = [False for _ in range(n)]\\n        for i in range(n):\\n            if leftChild[i] != -1:\\n                if not someonesChild[leftChild[i]]:\\n                    someonesChild[leftChild[i]] = True\\n                else:\\n                    return False\\n            if rightChild[i] != -1:\\n                if not someonesChild[rightChild[i]]:\\n                    someonesChild[rightChild[i]] = True\\n                else:\\n                    return False\\n        return sum(someonesChild) == len(someonesChild) - 1\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        children = 0\\n        for i in range(n):\\n            if leftChild[i] != -1:\\n                children += 1\\n            if rightChild[i] != -1:\\n                children += 1\\n        return children == n - 1\\n```\n```python\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        if n <= 1:\\n            return True\\n        someonesChild = [False for _ in range(n)]\\n        for i in range(n):\\n            if leftChild[i] != -1:\\n                if not someonesChild[leftChild[i]]:\\n                    someonesChild[leftChild[i]] = True\\n                else:\\n                    return False\\n            if rightChild[i] != -1:\\n                if not someonesChild[rightChild[i]]:\\n                    someonesChild[rightChild[i]] = True\\n                else:\\n                    return False\\n        return sum(someonesChild) == len(someonesChild) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517561,
                "title": "c-traverse-and-verify-dfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int traverse(int root, const vector<int>& leftChild, const vector<int>& rightChild, vector<int>& visited, bool& verified) {\\n        if (root == -1 || !verified) return 0;\\n        if (visited[root]) {\\n            verified = false;\\n            return 0;\\n        }\\n        visited[root] = 1;\\n        return traverse(leftChild[root], leftChild, rightChild, visited, verified) + \\n               traverse(rightChild[root], leftChild, rightChild, visited, verified) + 1;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> nodes(n), visited(n);\\n        int root(-1);\\n        bool verified(true);\\n        \\n        // mark nodes that are not roots\\n        for (const int& c: leftChild) if (c >= 0) nodes[c] = 1;\\n        for (const int& c: rightChild) if (c >= 0) nodes[c] = 1;\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (!nodes[i]) {\\n                // more than one root\\n                if (root != -1) return false;\\n                root = i;\\n            }\\n        \\n        // if no root, return false\\n        if (root == -1) return false;\\n        \\n        // dfs, traverse from the only root\\n        // make sure there is no cycle or collusion\\n        // and the number of nodes should be n\\n        int c(traverse(root, leftChild, rightChild, visited, verified));\\n        \\n        return verified && c == n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int traverse(int root, const vector<int>& leftChild, const vector<int>& rightChild, vector<int>& visited, bool& verified) {\\n        if (root == -1 || !verified) return 0;\\n        if (visited[root]) {\\n            verified = false;\\n            return 0;\\n        }\\n        visited[root] = 1;\\n        return traverse(leftChild[root], leftChild, rightChild, visited, verified) + \\n               traverse(rightChild[root], leftChild, rightChild, visited, verified) + 1;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> nodes(n), visited(n);\\n        int root(-1);\\n        bool verified(true);\\n        \\n        // mark nodes that are not roots\\n        for (const int& c: leftChild) if (c >= 0) nodes[c] = 1;\\n        for (const int& c: rightChild) if (c >= 0) nodes[c] = 1;\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (!nodes[i]) {\\n                // more than one root\\n                if (root != -1) return false;\\n                root = i;\\n            }\\n        \\n        // if no root, return false\\n        if (root == -1) return false;\\n        \\n        // dfs, traverse from the only root\\n        // make sure there is no cycle or collusion\\n        // and the number of nodes should be n\\n        int c(traverse(root, leftChild, rightChild, visited, verified));\\n        \\n        return verified && c == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842600,
                "title": "c-point-by-point-explanation-w-comments-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool iscycle(vector<int> adj[], int n, vector<int>& indegree){ //kahn algo (BFS)  \\n\\n    // TIME COM -> O(N + E)\\n\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(indegree[i]==0) q.push(i); \\n        }\\n\\n        vector<int> topo;\\n\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            topo.push_back(node);\\n\\n            for(auto it: adj[node]){\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n        if(topo.size()!=n) return true; // yes there is a cycle\\n        return false;\\n    }\\n\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n        \\n        if(n==1) return true; // a single node is always a valid tree\\n\\n        vector<int> adj[n];  //adjacent list to save the adjNode of a node\\n        vector<int> indegree(n,0); // stores no. ofedges towards a node\\n        vector<int> outdegree(n,0); // stores no. of edges outwards of a node\\n\\n        for(int i=0; i<n; i++){ // filling the indegree and outdegree array\\n\\n            if(lc[i]!=-1){\\n                adj[i].push_back(lc[i]);\\n                indegree[lc[i]]++;\\n                outdegree[i]++;\\n            }\\n\\n            if(rc[i]!=-1){\\n                adj[i].push_back(rc[i]);\\n                indegree[rc[i]]++;\\n                outdegree[i]++;\\n            }\\n        }\\n\\n        /* 4 conditions to check :-\\n          1) every node should belong to the same component =>  only one node will have indegree = 0\\n          2) if indegree of any node more than 1 => false\\n          3) if outdegree of any node more than 2 => false   \\n          4) no cycle allowed (check via kahn\\'s algo as graph is directed) \\n        */\\n\\n        int cnt = 0; // cnt of no of nodes with indegree[i]==0  as ideally this cnt should be 1 (for the root of tree)\\n\\n        for(int i=0; i<n; i++){ //O(N)\\n\\n            if(indegree[i]==0) cnt++;\\n            if(indegree[i]>1) return false;\\n            if(outdegree[i]>2) return false;\\n        }\\n\\n        if( iscycle(adj, n, indegree)==true) return false; //checkiing if cycle is present\\n\\n        if(cnt>1) return false;  // as cnt>1 means multiple components\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool iscycle(vector<int> adj[], int n, vector<int>& indegree){ //kahn algo (BFS)  \\n\\n    // TIME COM -> O(N + E)\\n\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(indegree[i]==0) q.push(i); \\n        }\\n\\n        vector<int> topo;\\n\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            topo.push_back(node);\\n\\n            for(auto it: adj[node]){\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n        if(topo.size()!=n) return true; // yes there is a cycle\\n        return false;\\n    }\\n\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n        \\n        if(n==1) return true; // a single node is always a valid tree\\n\\n        vector<int> adj[n];  //adjacent list to save the adjNode of a node\\n        vector<int> indegree(n,0); // stores no. ofedges towards a node\\n        vector<int> outdegree(n,0); // stores no. of edges outwards of a node\\n\\n        for(int i=0; i<n; i++){ // filling the indegree and outdegree array\\n\\n            if(lc[i]!=-1){\\n                adj[i].push_back(lc[i]);\\n                indegree[lc[i]]++;\\n                outdegree[i]++;\\n            }\\n\\n            if(rc[i]!=-1){\\n                adj[i].push_back(rc[i]);\\n                indegree[rc[i]]++;\\n                outdegree[i]++;\\n            }\\n        }\\n\\n        /* 4 conditions to check :-\\n          1) every node should belong to the same component =>  only one node will have indegree = 0\\n          2) if indegree of any node more than 1 => false\\n          3) if outdegree of any node more than 2 => false   \\n          4) no cycle allowed (check via kahn\\'s algo as graph is directed) \\n        */\\n\\n        int cnt = 0; // cnt of no of nodes with indegree[i]==0  as ideally this cnt should be 1 (for the root of tree)\\n\\n        for(int i=0; i<n; i++){ //O(N)\\n\\n            if(indegree[i]==0) cnt++;\\n            if(indegree[i]>1) return false;\\n            if(outdegree[i]>2) return false;\\n        }\\n\\n        if( iscycle(adj, n, indegree)==true) return false; //checkiing if cycle is present\\n\\n        if(cnt>1) return false;  // as cnt>1 means multiple components\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832375,
                "title": "easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& left, vector<int>& right) {\\n      vector<vector<int>> adj(n);\\n        vector<int> ind(n,0);\\n        for(int i=0;i<left.size();i++)\\n        {\\n            if(left[i]!=-1)\\n            {\\n                adj[i].push_back(left[i]);\\n                ind[left[i]]++;\\n            }\\n        }\\n        for(int i=0;i<right.size();i++)\\n        {\\n           if(right[i]!=-1)\\n           {\\n               adj[i].push_back(right[i]);\\n               ind[right[i]]++;\\n           }\\n        }\\n       vector<int> vis(n,0);\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i]==0)\\n            {\\n                q.push(i);\\n                break;\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            if(vis[node]!=0)return false;\\n            vis[node] =1;\\n            for(auto it:adj[node])\\n            {\\n                \\n                    q.push(it);\\n                \\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& left, vector<int>& right) {\\n      vector<vector<int>> adj(n);\\n        vector<int> ind(n,0);\\n        for(int i=0;i<left.size();i++)\\n        {\\n            if(left[i]!=-1)\\n            {\\n                adj[i].push_back(left[i]);\\n                ind[left[i]]++;\\n            }\\n        }\\n        for(int i=0;i<right.size();i++)\\n        {\\n           if(right[i]!=-1)\\n           {\\n               adj[i].push_back(right[i]);\\n               ind[right[i]]++;\\n           }\\n        }\\n       vector<int> vis(n,0);\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i]==0)\\n            {\\n                q.push(i);\\n                break;\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            if(vis[node]!=0)return false;\\n            vis[node] =1;\\n            for(auto it:adj[node])\\n            {\\n                \\n                    q.push(it);\\n                \\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735862,
                "title": "c-indegree-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNodes(vector<int> &lc,vector<int> &rc,int root)  \\n    {\\n        if(root==-1) return 0;\\n        return 1+countNodes(lc,rc,lc[root])+countNodes(lc,rc,rc[root]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n    vector<int> indegree(n,0);\\n    for(int i=0;i<n;i++){\\n        if(lc[i]!=-1)\\n        {\\n            indegree[lc[i]]++;\\n        }\\n        if(rc[i]!=-1)\\n        {\\n            indegree[rc[i]]++;\\n        }\\n    }\\n    int a=0,b=0,root=-1;\\n    for(int i=0;i<n;i++){\\n        if(indegree[i]==0)\\n        {\\n            a++, root=i;\\n        } else if(indegree[i]==1)\\n        {\\n            b++;\\n        } else {\\n            return 0;\\n        }\\n    } \\n    if(a!=1 and b!=n-1)\\n    {\\n        return 0;\\n    }\\n    int ans=countNodes(lc,rc,root);\\n    return (ans==n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(vector<int> &lc,vector<int> &rc,int root)  \\n    {\\n        if(root==-1) return 0;\\n        return 1+countNodes(lc,rc,lc[root])+countNodes(lc,rc,rc[root]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n    vector<int> indegree(n,0);\\n    for(int i=0;i<n;i++){\\n        if(lc[i]!=-1)\\n        {\\n            indegree[lc[i]]++;\\n        }\\n        if(rc[i]!=-1)\\n        {\\n            indegree[rc[i]]++;\\n        }\\n    }\\n    int a=0,b=0,root=-1;\\n    for(int i=0;i<n;i++){\\n        if(indegree[i]==0)\\n        {\\n            a++, root=i;\\n        } else if(indegree[i]==1)\\n        {\\n            b++;\\n        } else {\\n            return 0;\\n        }\\n    } \\n    if(a!=1 and b!=n-1)\\n    {\\n        return 0;\\n    }\\n    int ans=countNodes(lc,rc,root);\\n    return (ans==n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360567,
                "title": "bfs-o-2-n-space-for-indegree-and-bfs-easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:$$O(2*N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool bfs(int nd, vector<int>& indegree, vector<int>& lf, vector<int>& rt){\\n        queue<int>qu;\\n        qu.push(nd);\\n        while(!qu.empty()){\\n            int sz = qu.size();\\n            for(int i=0; i<sz; i++){\\n                int node = qu.front(); qu.pop();\\n                if(indegree[node]) return 0;\\n                if(lf[node]!=-1){ \\n                    qu.push(lf[node]);\\n                    indegree[lf[node]]--;\\n                    if(indegree[lf[node]]!=0) return 0;\\n                }\\n                if(rt[node]!=-1){ \\n                    qu.push(rt[node]);  \\n                    indegree[rt[node]]--;\\n                    if(indegree[rt[node]]!=0) return 0;\\n                }\\n            }\\n        }\\n        for(auto itr:indegree){\\n            if(itr) return 0;\\n        }\\n        return 1;\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int root=0;\\n        vector<int>indegree(n,0);\\n        for(int i=0; i<n; i++){\\n            if(leftChild[i]!=-1){\\n                indegree[leftChild[i]]++;\\n            }\\n            if(rightChild[i]!=-1){\\n                indegree[rightChild[i]]++;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(indegree[i]==0) root = i;\\n        }\\n        return bfs(root,indegree,leftChild,rightChild);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(int nd, vector<int>& indegree, vector<int>& lf, vector<int>& rt){\\n        queue<int>qu;\\n        qu.push(nd);\\n        while(!qu.empty()){\\n            int sz = qu.size();\\n            for(int i=0; i<sz; i++){\\n                int node = qu.front(); qu.pop();\\n                if(indegree[node]) return 0;\\n                if(lf[node]!=-1){ \\n                    qu.push(lf[node]);\\n                    indegree[lf[node]]--;\\n                    if(indegree[lf[node]]!=0) return 0;\\n                }\\n                if(rt[node]!=-1){ \\n                    qu.push(rt[node]);  \\n                    indegree[rt[node]]--;\\n                    if(indegree[rt[node]]!=0) return 0;\\n                }\\n            }\\n        }\\n        for(auto itr:indegree){\\n            if(itr) return 0;\\n        }\\n        return 1;\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int root=0;\\n        vector<int>indegree(n,0);\\n        for(int i=0; i<n; i++){\\n            if(leftChild[i]!=-1){\\n                indegree[leftChild[i]]++;\\n            }\\n            if(rightChild[i]!=-1){\\n                indegree[rightChild[i]]++;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(indegree[i]==0) root = i;\\n        }\\n        return bfs(root,indegree,leftChild,rightChild);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159817,
                "title": "best-solution-explained",
                "content": "\\n```\\nclass Solution {\\npublic:\\n   int countNodes(vector<int> &l,vector<int> &r,int root)   // DFS from root to validate that all nodes are visited.\\n    {\\n        if(root==-1)\\n            return 0;\\n        return 1+countNodes(l,r,l[root])+countNodes(l,r,r[root]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) \\n    {\\n        vector<int> inDegree(n,0);\\n        int root=-1;\\n        for(int i=0;i<leftChild.size();i++)\\n            if(leftChild[i]!=-1&&inDegree[leftChild[i]]++==1)  //If in-degree exceeds 1 return false.\\n                return false;\\n            else if(rightChild[i]!=-1&&inDegree[rightChild[i]]++==1)  //If in-degree exceeds 1 return false.\\n                return false;\\n        for(int i=0;i<leftChild.size();i++)    //Find root and also check for multiple roots.\\n            if(inDegree[i]==0)  //If in-degree = 0 and has children it\\'s a root.\\n                if(root==-1)   //Store the root.\\n                    root=i;\\n                else    //We have multiple roots, return false\\n                    return false;\\n        if(root==-1)\\n            return false;\\n        return countNodes(leftChild,rightChild,root)==n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Go",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int countNodes(vector<int> &l,vector<int> &r,int root)   // DFS from root to validate that all nodes are visited.\\n    {\\n        if(root==-1)\\n            return 0;\\n        return 1+countNodes(l,r,l[root])+countNodes(l,r,r[root]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) \\n    {\\n        vector<int> inDegree(n,0);\\n        int root=-1;\\n        for(int i=0;i<leftChild.size();i++)\\n            if(leftChild[i]!=-1&&inDegree[leftChild[i]]++==1)  //If in-degree exceeds 1 return false.\\n                return false;\\n            else if(rightChild[i]!=-1&&inDegree[rightChild[i]]++==1)  //If in-degree exceeds 1 return false.\\n                return false;\\n        for(int i=0;i<leftChild.size();i++)    //Find root and also check for multiple roots.\\n            if(inDegree[i]==0)  //If in-degree = 0 and has children it\\'s a root.\\n                if(root==-1)   //Store the root.\\n                    root=i;\\n                else    //We have multiple roots, return false\\n                    return false;\\n        if(root==-1)\\n            return false;\\n        return countNodes(leftChild,rightChild,root)==n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121076,
                "title": "parent-array-for-each-node-o-n-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//idea is two to check for cases, if any node has multiple parent or it is creating a cyle\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            int l=leftChild[i],r=rightChild[i];\\n            if((l!=-1 && (parent[l]!=l || l==parent[parent[i]])) ||( r!=-1 && (parent[r]!=r ||r==parent[parent[i]])))return false;\\n            else{\\n                if(l!=-1)parent[l]=i;\\n                if(r!=-1)parent[r]=i;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i)cnt++;\\n        }\\n        return cnt>1?false:true;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//idea is two to check for cases, if any node has multiple parent or it is creating a cyle\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            int l=leftChild[i],r=rightChild[i];\\n            if((l!=-1 && (parent[l]!=l || l==parent[parent[i]])) ||( r!=-1 && (parent[r]!=r ||r==parent[parent[i]])))return false;\\n            else{\\n                if(l!=-1)parent[l]=i;\\n                if(r!=-1)parent[r]=i;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i)cnt++;\\n        }\\n        return cnt>1?false:true;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927557,
                "title": "find-root-cycle-disconnected-nodes-dfs-c",
                "content": "```\\nclass Solution {\\n    bool dfs(int node, vector<int> &lc, vector<int> &rc, vector<int> &vis) {\\n        if(node == -1) return false;\\n        if(vis[node]) return true;\\n        vis[node] = 1;\\n\\n        if(dfs(lc[node], lc, rc, vis) || dfs(rc[node], lc, rc, vis)) return true;\\n        return false;\\n    } \\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> in(n), out(n);\\n        for(int i=0; i<n; i++) {\\n            if(leftChild[i] != -1) in[leftChild[i]]++, out[i]++;\\n            if(rightChild[i] != -1) in[rightChild[i]]++, out[i]++;\\n        }\\n\\n        int root = -1;\\n        for(int i=0; i<n; i++) {\\n            if(!in[i]) {\\n                if(root == -1) root = i;\\n                else return false;\\n            }\\n        }\\n        if(root == -1) return false;\\n        \\n        vector<int> vis(n);\\n        if(dfs(root, leftChild, rightChild, vis)) return false;\\n\\n        for(int i : vis) {\\n            if(!i) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(int node, vector<int> &lc, vector<int> &rc, vector<int> &vis) {\\n        if(node == -1) return false;\\n        if(vis[node]) return true;\\n        vis[node] = 1;\\n\\n        if(dfs(lc[node], lc, rc, vis) || dfs(rc[node], lc, rc, vis)) return true;\\n        return false;\\n    } \\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> in(n), out(n);\\n        for(int i=0; i<n; i++) {\\n            if(leftChild[i] != -1) in[leftChild[i]]++, out[i]++;\\n            if(rightChild[i] != -1) in[rightChild[i]]++, out[i]++;\\n        }\\n\\n        int root = -1;\\n        for(int i=0; i<n; i++) {\\n            if(!in[i]) {\\n                if(root == -1) root = i;\\n                else return false;\\n            }\\n        }\\n        if(root == -1) return false;\\n        \\n        vector<int> vis(n);\\n        if(dfs(root, leftChild, rightChild, vis)) return false;\\n\\n        for(int i : vis) {\\n            if(!i) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711831,
                "title": "c-90-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNodes(vector<int> &l,vector<int> &r,int root)  \\n    {\\n        if(root==-1)\\n            return 0;\\n        return 1+countNodes(l,r,l[root])+countNodes(l,r,r[root]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) \\n    {\\n        vector<int> inDegree(n,0);\\n        int root=-1;\\n        for(int i=0;i<leftChild.size();i++)\\n            if(leftChild[i]!=-1&&inDegree[leftChild[i]]++==1) \\n                return false;\\n            else if(rightChild[i]!=-1&&inDegree[rightChild[i]]++==1) \\n                return false;\\n        for(int i=0;i<leftChild.size();i++)   \\n            if(inDegree[i]==0) \\n                if(root==-1)  \\n                    root=i;\\n                else   \\n                    return false;\\n        if(root==-1)\\n            return false;\\n        return countNodes(leftChild,rightChild,root)==n;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(vector<int> &l,vector<int> &r,int root)  \\n    {\\n        if(root==-1)\\n            return 0;\\n        return 1+countNodes(l,r,l[root])+countNodes(l,r,r[root]);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) \\n    {\\n        vector<int> inDegree(n,0);\\n        int root=-1;\\n        for(int i=0;i<leftChild.size();i++)\\n            if(leftChild[i]!=-1&&inDegree[leftChild[i]]++==1) \\n                return false;\\n            else if(rightChild[i]!=-1&&inDegree[rightChild[i]]++==1) \\n                return false;\\n        for(int i=0;i<leftChild.size();i++)   \\n            if(inDegree[i]==0) \\n                if(root==-1)  \\n                    root=i;\\n                else   \\n                    return false;\\n        if(root==-1)\\n            return false;\\n        return countNodes(leftChild,rightChild,root)==n;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474943,
                "title": "python-simple-dfs",
                "content": "\\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\\n        visited = set()\\n        \\n        def dfs(node):\\n            if node in visited:\\n                return False\\n            \\n            visited.add(node)\\n            \\n            if leftChild[node] != -1:\\n                if not dfs(leftChild[node]):\\n                    return False\\n                \\n            if rightChild[node] != -1:\\n                if not dfs(rightChild[node]):\\n                    return False\\n                \\n            return True\\n        \\n        root = set(range(n)) - set(leftChild + rightChild)\\n        \\n        if len(root) != 1:\\n            return False\\n        \\n        return dfs(root.pop()) and len(visited) == n\\n",
                "solutionTags": [],
                "code": "\\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\\n        visited = set()\\n        \\n        def dfs(node):\\n            if node in visited:\\n                return False\\n            \\n            visited.add(node)\\n            \\n            if leftChild[node] != -1:\\n                if not dfs(leftChild[node]):\\n                    return False\\n                \\n            if rightChild[node] != -1:\\n                if not dfs(rightChild[node]):\\n                    return False\\n                \\n            return True\\n        \\n        root = set(range(n)) - set(leftChild + rightChild)\\n        \\n        if len(root) != 1:\\n            return False\\n        \\n        return dfs(root.pop()) and len(visited) == n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2466116,
                "title": "python-with-only-two-sets",
                "content": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        child = set()\\n        parent = set()\\n        \\n        for i in range(len(leftChild)):\\n            if (leftChild[i] != -1 and leftChild[i] in child) or (rightChild[i] != -1 and rightChild[i] in child):\\n                return False\\n            if i in child and ((leftChild[i] != -1 and leftChild[i] in parent) or (rightChild[i] != -1 and rightChild[i] in parent)):\\n                return False\\n            \\n            if leftChild[i] != -1:\\n                child.add(leftChild[i])\\n            if rightChild[i] != -1:\\n                child.add(rightChild[i])\\n            \\n            parent.add(i)\\n        \\n        if len(child) != len(leftChild) - 1:\\n            return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        child = set()\\n        parent = set()\\n        \\n        for i in range(len(leftChild)):\\n            if (leftChild[i] != -1 and leftChild[i] in child) or (rightChild[i] != -1 and rightChild[i] in child):\\n                return False\\n            if i in child and ((leftChild[i] != -1 and leftChild[i] in parent) or (rightChild[i] != -1 and rightChild[i] in parent)):\\n                return False\\n            \\n            if leftChild[i] != -1:\\n                child.add(leftChild[i])\\n            if rightChild[i] != -1:\\n                child.add(rightChild[i])\\n            \\n            parent.add(i)\\n        \\n        if len(child) != len(leftChild) - 1:\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371429,
                "title": "python-simple-dfs-solution",
                "content": "class Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n\\t\\n        parent_to_children = defaultdict(list)\\n        root = 0\\n        for i in range(len(leftChild)):\\n            parent_to_children[i].append(leftChild[i])\\n            parent_to_children[i].append(rightChild[i])\\n            if root in parent_to_children[i]:\\n                root = i \\n        \\n        def findvisited(node, visited):\\n            if node == -1:\\n                return True\\n            if node in visited:\\n                return False\\n            \\n            visited.add(node)\\n            \\n            for child in parent_to_children[node]:\\n                if not findvisited(child, visited):\\n                    return False\\n            \\n            return True\\n        \\n        visited = set()\\n        if not findvisited(root, visited) or len(visited)!=n:\\n            return False\\n        \\n        return True",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n\\t\\n        parent_to_children = defaultdict(list)\\n        root = 0\\n        for i in range(len(leftChild)):\\n            parent_to_children[i].append(leftChild[i])\\n            parent_to_children[i].append(rightChild[i])\\n            if root in parent_to_children[i]:\\n                root = i \\n        \\n        def findvisited(node, visited):\\n            if node == -1:\\n                return True\\n            if node in visited:\\n                return False\\n            \\n            visited.add(node)\\n            \\n            for child in parent_to_children[node]:\\n                if not findvisited(child, visited):\\n                    return False\\n            \\n            return True\\n        \\n        visited = set()\\n        if not findvisited(root, visited) or len(visited)!=n:\\n            return False\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2272542,
                "title": "c-dfs-in-degree-count-some-explanations",
                "content": "Some observations used:\\n* Among all nodes there should be only one with the in_degree count of zero (root).\\n* All the rest nodes should have the in_degree count of one.\\n* Figure out the root node and start DFS from it, after DFS all nodes should be visited only once.\\n\\nIf any of above fails, return false, otherwise true.\\n\\n```\\nclass Solution {\\n    unordered_map<int, int> in_degree;\\n    unordered_set<int> visited;\\n    bool dfs(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        visited.insert(n);\\n        \\n        int left = leftChild[n];\\n        int right = rightChild[n];\\n        \\n        if(left == -1 && right == -1)\\n            return true;\\n        \\n        if(left != -1 && visited.count(left))\\n            return false;\\n        \\n        if(right != -1 && visited.count(right))\\n            return false;\\n        \\n        for(int j : {left, right}) {\\n            if(j == -1)\\n                continue;\\n            if(!dfs(j, leftChild, rightChild))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        for(int i = 0; i < n; ++i) {\\n            int lc = leftChild[i];\\n            int rc = rightChild[i];\\n            if(lc != -1) {\\n                if(++in_degree[lc] > 1)\\n                    return false;\\n            }\\n            if(rc != -1) {\\n                if(++in_degree[rc] > 1)\\n                    return false;\\n            }\\n        }\\n                \\n        if(in_degree.size() != n-1) {\\n            return false;\\n        }\\n        \\n        int startNode = -1;\\n        for(int i = 0; i < n; ++i) {\\n            if(in_degree.count(i) == 0) {\\n                startNode = i;\\n                break;\\n            }\\n        }\\n                \\n        if(!dfs(startNode, leftChild, rightChild))\\n            return false;\\n        \\n        return visited.size() == n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> in_degree;\\n    unordered_set<int> visited;\\n    bool dfs(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        visited.insert(n);\\n        \\n        int left = leftChild[n];\\n        int right = rightChild[n];\\n        \\n        if(left == -1 && right == -1)\\n            return true;\\n        \\n        if(left != -1 && visited.count(left))\\n            return false;\\n        \\n        if(right != -1 && visited.count(right))\\n            return false;\\n        \\n        for(int j : {left, right}) {\\n            if(j == -1)\\n                continue;\\n            if(!dfs(j, leftChild, rightChild))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        for(int i = 0; i < n; ++i) {\\n            int lc = leftChild[i];\\n            int rc = rightChild[i];\\n            if(lc != -1) {\\n                if(++in_degree[lc] > 1)\\n                    return false;\\n            }\\n            if(rc != -1) {\\n                if(++in_degree[rc] > 1)\\n                    return false;\\n            }\\n        }\\n                \\n        if(in_degree.size() != n-1) {\\n            return false;\\n        }\\n        \\n        int startNode = -1;\\n        for(int i = 0; i < n; ++i) {\\n            if(in_degree.count(i) == 0) {\\n                startNode = i;\\n                break;\\n            }\\n        }\\n                \\n        if(!dfs(startNode, leftChild, rightChild))\\n            return false;\\n        \\n        return visited.size() == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257806,
                "title": "c-interesting-idea",
                "content": "--> The idea behind the code:\\n\\nTrace each node\\'s root. Check whether a cycle formed and whether the number of root is exactly one.\\n\\n--> Terms:\\n\\nlet i and j be 2 nodes, such that there is an edge from i to j. Then, i is the parent of j.\\n\\n--> Here are the edge cases to be considered:\\n```\\n1. Does the node has > 1 parents?\\n2. Are there actually a root for the node? Is there a cycle?\\n\\tTypes of cycles: \\n\\t(i) Cycles between immediate neighbors. E.g. 1 <---> 2. (Length of this cycle = 1)\\n\\t(ii) Cycles with length > 1\\n\\t\\t\\tThis can be checked when you are travelling up the tree.\\n\\t\\t\\tCheck whether the next node has been visited before.\\n```\\n   \\n--> Code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    const static int MAX = 1e4 + 10;\\n    bool ck[MAX];\\n    map<int, int> RM;\\n    map<int, int> ROOT;\\n    \\n    int get_root(int cur) {\\n        memset(ck, false, sizeof(ck));\\n        vector<int> path = {};\\n        while (RM[cur] != -1) {\\n            if (ROOT.find(cur) != ROOT.end()) {\\n                return ROOT[cur];\\n            }\\n            if (ck[cur])\\n                return -1;\\n            ck[cur] = true;\\n            path.push_back(cur);\\n            cur = RM[cur];\\n        }\\n        for (int p : path) {\\n            ROOT[p] = cur;\\n        }\\n        return cur;\\n    }\\n    bool method_two(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        for (int i = 0; i < n; i++) {\\n            RM[i] = -1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                if (RM[leftChild[i]] != -1)\\n                    return false;\\n                RM[leftChild[i]] = i;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (rightChild[i] != -1) {\\n                if (RM[rightChild[i]] != -1)\\n                    return false;\\n                RM[rightChild[i]] = i;\\n            }\\n        }\\n        set<int> roots_all;\\n        for (int i = 0; i < n; i++) {\\n            int cur_root = get_root(i);\\n            if (cur_root == -1)\\n                return false;\\n            roots_all.insert(cur_root);\\n        }\\n        return roots_all.size() == 1;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        return method_two(n, leftChild, rightChild);\\n    }\\n};\\n```\\n\\n\\n\\n\\n*Side-notes: This website is great. Some problems are or medium difficulty / quite difficult, but they are all solvable! That\\'s amazing     (^_^)/  It won\\'t make you rich and famous, but, well, for me, I am getting very bored from watching YouTube videos and TV shows all day...*",
                "solutionTags": [],
                "code": "```\\n1. Does the node has > 1 parents?\\n2. Are there actually a root for the node? Is there a cycle?\\n\\tTypes of cycles: \\n\\t(i) Cycles between immediate neighbors. E.g. 1 <---> 2. (Length of this cycle = 1)\\n\\t(ii) Cycles with length > 1\\n\\t\\t\\tThis can be checked when you are travelling up the tree.\\n\\t\\t\\tCheck whether the next node has been visited before.\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const static int MAX = 1e4 + 10;\\n    bool ck[MAX];\\n    map<int, int> RM;\\n    map<int, int> ROOT;\\n    \\n    int get_root(int cur) {\\n        memset(ck, false, sizeof(ck));\\n        vector<int> path = {};\\n        while (RM[cur] != -1) {\\n            if (ROOT.find(cur) != ROOT.end()) {\\n                return ROOT[cur];\\n            }\\n            if (ck[cur])\\n                return -1;\\n            ck[cur] = true;\\n            path.push_back(cur);\\n            cur = RM[cur];\\n        }\\n        for (int p : path) {\\n            ROOT[p] = cur;\\n        }\\n        return cur;\\n    }\\n    bool method_two(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        for (int i = 0; i < n; i++) {\\n            RM[i] = -1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                if (RM[leftChild[i]] != -1)\\n                    return false;\\n                RM[leftChild[i]] = i;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (rightChild[i] != -1) {\\n                if (RM[rightChild[i]] != -1)\\n                    return false;\\n                RM[rightChild[i]] = i;\\n            }\\n        }\\n        set<int> roots_all;\\n        for (int i = 0; i < n; i++) {\\n            int cur_root = get_root(i);\\n            if (cur_root == -1)\\n                return false;\\n            roots_all.insert(cur_root);\\n        }\\n        return roots_all.size() == 1;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        return method_two(n, leftChild, rightChild);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167765,
                "title": "c-easy-to-understand-dfs-based-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNodes(int root,vector<int> &left,vector<int> &right)\\n    {\\n        if(root==-1)\\n        {\\n            return 0;\\n        }\\n        return 1+countNodes(left[root],left,right)+countNodes(right[root],left,right);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> indegree(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(leftChild[i]!=-1)\\n            {\\n                indegree[leftChild[i]]++;\\n                if(indegree[leftChild[i]]>1)\\n                return false;\\n            }\\n            if(rightChild[i]!=-1)\\n            {\\n                indegree[rightChild[i]]++;\\n                if(indegree[rightChild[i]]>1)\\n                return false;\\n            }\\n        }\\n        int root=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                if(root=-1)\\n                root=i;\\n                else\\n                return false;\\n            }\\n        }\\n        if(root==-1)\\n        return false;\\n        \\n        int c=countNodes(root,leftChild,rightChild);\\n        return c==n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNodes(int root,vector<int> &left,vector<int> &right)\\n    {\\n        if(root==-1)\\n        {\\n            return 0;\\n        }\\n        return 1+countNodes(left[root],left,right)+countNodes(right[root],left,right);\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> indegree(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(leftChild[i]!=-1)\\n            {\\n                indegree[leftChild[i]]++;\\n                if(indegree[leftChild[i]]>1)\\n                return false;\\n            }\\n            if(rightChild[i]!=-1)\\n            {\\n                indegree[rightChild[i]]++;\\n                if(indegree[rightChild[i]]>1)\\n                return false;\\n            }\\n        }\\n        int root=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                if(root=-1)\\n                root=i;\\n                else\\n                return false;\\n            }\\n        }\\n        if(root==-1)\\n        return false;\\n        \\n        int c=countNodes(root,leftChild,rightChild);\\n        return c==n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131624,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n        vector<int> vis(n);\\n        int root = -1;\\n        for(int i = 0; i < n; i++){\\n            if(lc[i] != -1)\\n                if(vis[lc[i]]++) return false;\\n            if(rc[i] != -1)\\n                if(vis[rc[i]]++) return false;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                if(root != -1) return false;\\n                root = i;\\n            }\\n        }\\n        for(int& i: vis)\\n            i = 0;\\n        if(root == -1 || !dfs(vis, root, lc, rc))\\n            return false;\\n        for(int& i: vis)\\n            if(!i) return false;\\n        return true;\\n    }\\n    bool dfs(vector<int>& vis, int root, vector<int>& lc, vector<int>& rc){\\n        if(root == -1)\\n            return true;\\n        if(vis[root])\\n            return false;\\n        vis[root] = true;\\n        return dfs(vis, lc[root], lc, rc) && dfs(vis, rc[root], lc, rc);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& lc, vector<int>& rc) {\\n        vector<int> vis(n);\\n        int root = -1;\\n        for(int i = 0; i < n; i++){\\n            if(lc[i] != -1)\\n                if(vis[lc[i]]++) return false;\\n            if(rc[i] != -1)\\n                if(vis[rc[i]]++) return false;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                if(root != -1) return false;\\n                root = i;\\n            }\\n        }\\n        for(int& i: vis)\\n            i = 0;\\n        if(root == -1 || !dfs(vis, root, lc, rc))\\n            return false;\\n        for(int& i: vis)\\n            if(!i) return false;\\n        return true;\\n    }\\n    bool dfs(vector<int>& vis, int root, vector<int>& lc, vector<int>& rc){\\n        if(root == -1)\\n            return true;\\n        if(vis[root])\\n            return false;\\n        vis[root] = true;\\n        return dfs(vis, lc[root], lc, rc) && dfs(vis, rc[root], lc, rc);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129101,
                "title": "python-union-find",
                "content": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        parent = [i for i in range(0,n)]\\n        def union(x,y):\\n            x_parent = find(x)\\n            y_parent = find(y)\\n            if x_parent==y_parent:\\n                return False\\n            # It means child node already has a parent\\n            if y_parent != y:\\n                return False\\n            parent[y_parent] = x_parent\\n            return True\\n        \\n        def find(x):\\n            if x == parent[x]:\\n                return x\\n            \\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        c = 0\\n        for i in range(0,n):\\n            if leftChild[i]!=-1:\\n                c+=1\\n                if not union(i, leftChild[i]):\\n                    return False\\n            \\n            if rightChild[i]!=-1:\\n                c+=1\\n                if not union(i, rightChild[i]):\\n                    return False\\n        \\n        # Number of edges in tree should be equal to n-1\\n        return c==n-1\\n\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        parent = [i for i in range(0,n)]\\n        def union(x,y):\\n            x_parent = find(x)\\n            y_parent = find(y)\\n            if x_parent==y_parent:\\n                return False\\n            # It means child node already has a parent\\n            if y_parent != y:\\n                return False\\n            parent[y_parent] = x_parent\\n            return True\\n        \\n        def find(x):\\n            if x == parent[x]:\\n                return x\\n            \\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        c = 0\\n        for i in range(0,n):\\n            if leftChild[i]!=-1:\\n                c+=1\\n                if not union(i, leftChild[i]):\\n                    return False\\n            \\n            if rightChild[i]!=-1:\\n                c+=1\\n                if not union(i, rightChild[i]):\\n                    return False\\n        \\n        # Number of edges in tree should be equal to n-1\\n        return c==n-1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122228,
                "title": "python-union-find-solution",
                "content": "Hello! Thanks for the visit. \\n\\nBelow is my code for typical union-find algorithm to check if there is one common parent/ancestor node among the nodes. This is so because each node in binary tree must have common ancestor node. We do this by finding parent of each node at the end and figuring out if there is only one common ancestor. Also, by definition, tree must not form any cycle. So, we need to check if there exists a cycle by checking if nodes in the unvisited edge have the same common ancestor in union_parent method.  \\n\\n```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        if n == 1:\\n            return True\\n\\n        parent = collections.defaultdict(int)\\n        def find_parent(a: int) -> int:\\n            parent.setdefault(a, a)\\n            if a != parent[a]:\\n                parent[a] = find_parent(parent[a])\\n            return parent[a]\\n\\n        def union_parent(a: int, b: int) -> bool:\\n            pa = find_parent(a)\\n            pb = find_parent(b)\\n            if pa == pb:\\n                return False\\n            parent[b] = pa\\n            return True\\n\\n        for i in range(n):\\n            if leftChild[i] != -1 and not union_parent(i, leftChild[i]):\\n                    return False\\n            if rightChild[i] != -1 and not union_parent(i, rightChild[i]):\\n                    return False\\n                # we should have one common parent at the end\\n        return True if len(set(map(find_parent, parent))) == 1 else False \\n```\\nThanks for the visit and I greatly appreciate any comments on improvements, errors. mistakes. and etc.",
                "solutionTags": [
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        if n == 1:\\n            return True\\n\\n        parent = collections.defaultdict(int)\\n        def find_parent(a: int) -> int:\\n            parent.setdefault(a, a)\\n            if a != parent[a]:\\n                parent[a] = find_parent(parent[a])\\n            return parent[a]\\n\\n        def union_parent(a: int, b: int) -> bool:\\n            pa = find_parent(a)\\n            pb = find_parent(b)\\n            if pa == pb:\\n                return False\\n            parent[b] = pa\\n            return True\\n\\n        for i in range(n):\\n            if leftChild[i] != -1 and not union_parent(i, leftChild[i]):\\n                    return False\\n            if rightChild[i] != -1 and not union_parent(i, rightChild[i]):\\n                    return False\\n                # we should have one common parent at the end\\n        return True if len(set(map(find_parent, parent))) == 1 else False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087525,
                "title": "c-union-find-soluiton",
                "content": "These condition needs to be checked \\n1) no of incoming edges for each node <= 1\\n2) no of edges = n - 1\\n3) cycle should not exist [ we check this using Union find ]\\n<iframe src=\"https://leetcode.com/playground/DPxuhsn3/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "These condition needs to be checked \\n1) no of incoming edges for each node <= 1\\n2) no of edges = n - 1\\n3) cycle should not exist [ we check this using Union find ]\\n<iframe src=\"https://leetcode.com/playground/DPxuhsn3/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2050617,
                "title": "cpp-count-parents-root-and-cycle-detection-using-bfs-o-n",
                "content": "conditions of a valid binary tree\\n     1) Only one node can be root i.e (parent[node] == -1)\\n     2) rest all others node must have exactly one parent\\n     3) No cycle must be present\\n     4) Only one component must be there\\n\\n```\\nclass Solution {\\npublic:\\n//     Time Comlpex : O(N)\\n    \\n    \\n//     conditions of a valid binary tree\\n//     1) Only one node can be root i.e (parent[node] == -1)\\n//     2) rest all others node must have exactly one parent\\n//     3) No cycle must be present\\n//     4) Only one component must be there\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int parent[n];\\n        memset(parent,-1,sizeof(parent));\\n        for(int i=0;i<n;i++){\\n            if(leftChild[i] != -1){\\n                if(parent[leftChild[i]] != -1)return false;// signifies leftChild[i] is having 2 parent\\n                parent[leftChild[i]]=i;\\n                \\n            }                            \\n            if(rightChild[i] != -1){\\n                if(parent[rightChild[i]] != -1)return false;// signifies rightChild[i] is having 2 parent\\n                parent[rightChild[i]]=i;                \\n            }            \\n        }\\n        \\n        /// checking for number of roots also identifying which node is root\\n        int ct = 0;\\n        int root;\\n        for(int i=0;i<n;i++){\\n            if(parent[i] == -1){\\n                ct++;\\n                root=i;\\n            }\\n            if(ct > 1)return false;\\n        }\\n        if(ct == 0)return false; // no root present\\n        \\n        // now just check if any configuratin is having cycle\\n        \\n//         Covering edge cases like :\\n//         4\\n// [1,0,3,-1]\\n// [-1,-1,-1,-1]\\n        \\n        // a bfs marking each node visited from root\\n        bool vis[n];\\n        memset(vis,false,sizeof(vis));\\n        \\n        queue<int> q;\\n        q.push(root);\\n        int marked = 0;\\n        while(q.size()){\\n            int sv = q.front();q.pop();\\n            \\n            if(vis[sv])return false;\\n            marked++;\\n            vis[sv]=true;\\n            if(leftChild[sv] != -1)q.push(leftChild[sv]);\\n            if(rightChild[sv] != -1)q.push(rightChild[sv]);\\n        }\\n        \\n        if(marked != n)return false;\\n        \\n        \\n        return true;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     Time Comlpex : O(N)\\n    \\n    \\n//     conditions of a valid binary tree\\n//     1) Only one node can be root i.e (parent[node] == -1)\\n//     2) rest all others node must have exactly one parent\\n//     3) No cycle must be present\\n//     4) Only one component must be there\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        int parent[n];\\n        memset(parent,-1,sizeof(parent));\\n        for(int i=0;i<n;i++){\\n            if(leftChild[i] != -1){\\n                if(parent[leftChild[i]] != -1)return false;// signifies leftChild[i] is having 2 parent\\n                parent[leftChild[i]]=i;\\n                \\n            }                            \\n            if(rightChild[i] != -1){\\n                if(parent[rightChild[i]] != -1)return false;// signifies rightChild[i] is having 2 parent\\n                parent[rightChild[i]]=i;                \\n            }            \\n        }\\n        \\n        /// checking for number of roots also identifying which node is root\\n        int ct = 0;\\n        int root;\\n        for(int i=0;i<n;i++){\\n            if(parent[i] == -1){\\n                ct++;\\n                root=i;\\n            }\\n            if(ct > 1)return false;\\n        }\\n        if(ct == 0)return false; // no root present\\n        \\n        // now just check if any configuratin is having cycle\\n        \\n//         Covering edge cases like :\\n//         4\\n// [1,0,3,-1]\\n// [-1,-1,-1,-1]\\n        \\n        // a bfs marking each node visited from root\\n        bool vis[n];\\n        memset(vis,false,sizeof(vis));\\n        \\n        queue<int> q;\\n        q.push(root);\\n        int marked = 0;\\n        while(q.size()){\\n            int sv = q.front();q.pop();\\n            \\n            if(vis[sv])return false;\\n            marked++;\\n            vis[sv]=true;\\n            if(leftChild[sv] != -1)q.push(leftChild[sv]);\\n            if(rightChild[sv] != -1)q.push(rightChild[sv]);\\n        }\\n        \\n        if(marked != n)return false;\\n        \\n        \\n        return true;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998901,
                "title": "c-straight-clear-solution-union-find",
                "content": "```\\nclass Solution { // YAA \\npublic:\\n    int find(int node, int par[]) {\\n        if(node == par[node]) return node;\\n        return par[node] = find(par[node], par);\\n    }\\n    void join(int u, int v, int par[], int ran[]) {\\n        u = find(u, par);\\n        v = find(v, par);\\n        if(ran[u] > ran[v]) {\\n            par[v] = u;\\n        } else if(ran[v] > ran[u]) {\\n            par[u] = v;\\n        } else {\\n            par[v] = u;\\n            ran[u]++;\\n        }\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n        vector<int>node(n,0);\\n        for(int i=0;i<n;i++){\\n            \\n            if(leftChild[i]!=-1){\\n                node[leftChild[i]]++;\\n                if(node[leftChild[i]]>1) return false; \\n            }       \\n            \\n            if(rightChild[i]!=-1){\\n                node[rightChild[i]]++;\\n                if(node[rightChild[i]]>1) return false; \\n            }    \\n        }\\n        int par[n], ran[n];\\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n            ran[i] = 0;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(find(i, par) != find(leftChild[i], par)) {\\n                    join(i, leftChild[i], par, ran);\\n                } else {\\n                    return false;\\n                }\\n            }\\n            if(rightChild[i] != -1) {\\n                if(find(i, par) != find(rightChild[i], par)) {\\n                    join(i, rightChild[i], par, ran);\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int pare = find(i,par);\\n            par[i] = pare;\\n        }\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++) {\\n            mp[par[i]]++;\\n            if(mp.size() > 1) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find",
                    "Graph",
                    "Iterator"
                ],
                "code": "```\\nclass Solution { // YAA \\npublic:\\n    int find(int node, int par[]) {\\n        if(node == par[node]) return node;\\n        return par[node] = find(par[node], par);\\n    }\\n    void join(int u, int v, int par[], int ran[]) {\\n        u = find(u, par);\\n        v = find(v, par);\\n        if(ran[u] > ran[v]) {\\n            par[v] = u;\\n        } else if(ran[v] > ran[u]) {\\n            par[u] = v;\\n        } else {\\n            par[v] = u;\\n            ran[u]++;\\n        }\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n        vector<int>node(n,0);\\n        for(int i=0;i<n;i++){\\n            \\n            if(leftChild[i]!=-1){\\n                node[leftChild[i]]++;\\n                if(node[leftChild[i]]>1) return false; \\n            }       \\n            \\n            if(rightChild[i]!=-1){\\n                node[rightChild[i]]++;\\n                if(node[rightChild[i]]>1) return false; \\n            }    \\n        }\\n        int par[n], ran[n];\\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n            ran[i] = 0;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(find(i, par) != find(leftChild[i], par)) {\\n                    join(i, leftChild[i], par, ran);\\n                } else {\\n                    return false;\\n                }\\n            }\\n            if(rightChild[i] != -1) {\\n                if(find(i, par) != find(rightChild[i], par)) {\\n                    join(i, rightChild[i], par, ran);\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int pare = find(i,par);\\n            par[i] = pare;\\n        }\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++) {\\n            mp[par[i]]++;\\n            if(mp.size() > 1) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863196,
                "title": "c-o-n-using-in-degree-and-counting-nodes",
                "content": "```csharp\\npublic bool ValidateBinaryTreeNodes(int n, int[] leftchild, int[] rightchild)\\n{\\n\\tint[] indegree = new int[n];\\n\\n\\t// Check indegree of each node <= 1\\n\\t// 1 for all nodes and 0 for root node\\n\\tforeach(var left in leftchild)\\n\\t{\\n\\t\\tif(left != -1)\\n\\t\\t{\\n\\t\\t\\tindegree[left]++;\\n\\t\\t\\tif(indegree[left] > 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tforeach(var right in rightchild)\\n\\t{\\n\\t\\tif(right != -1)\\n\\t\\t{\\n\\t\\t\\tindegree[right]++;\\n\\t\\t\\tif(indegree[right] > 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint root = -1;\\n\\tfor(int i = 0; i < n; i++)\\n\\t{\\n\\t\\tif(indegree[i] == 0)\\n\\t\\t{\\n\\t\\t\\tif(root == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\troot = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}                \\n\\t\\t}\\n\\t}\\n\\n\\tif(root == -1)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\t//  Check if any node is not isolated\\n\\tint count = countNodes(root, leftchild, rightchild);\\n\\treturn count == n;\\n}\\n\\nprivate int countNodes(int node, int[] left, int[] right)\\n{\\n\\tif(node == -1)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\treturn (1 + countNodes(left[node], left, right) + countNodes(right[node], left, right));\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```csharp\\npublic bool ValidateBinaryTreeNodes(int n, int[] leftchild, int[] rightchild)\\n{\\n\\tint[] indegree = new int[n];\\n\\n\\t// Check indegree of each node <= 1\\n\\t// 1 for all nodes and 0 for root node\\n\\tforeach(var left in leftchild)\\n\\t{\\n\\t\\tif(left != -1)\\n\\t\\t{\\n\\t\\t\\tindegree[left]++;\\n\\t\\t\\tif(indegree[left] > 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tforeach(var right in rightchild)\\n\\t{\\n\\t\\tif(right != -1)\\n\\t\\t{\\n\\t\\t\\tindegree[right]++;\\n\\t\\t\\tif(indegree[right] > 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint root = -1;\\n\\tfor(int i = 0; i < n; i++)\\n\\t{\\n\\t\\tif(indegree[i] == 0)\\n\\t\\t{\\n\\t\\t\\tif(root == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\troot = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}                \\n\\t\\t}\\n\\t}\\n\\n\\tif(root == -1)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\t//  Check if any node is not isolated\\n\\tint count = countNodes(root, leftchild, rightchild);\\n\\treturn count == n;\\n}\\n\\nprivate int countNodes(int node, int[] left, int[] right)\\n{\\n\\tif(node == -1)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\treturn (1 + countNodes(left[node], left, right) + countNodes(right[node], left, right));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862174,
                "title": "simple-js-solution-w-comments",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 124 ms, faster than 67.74% of JavaScript online submissions for Validate Binary Tree Nodes.\\n// Memory Usage: 52.9 MB, less than 22.58% of JavaScript online submissions for Validate Binary Tree Nodes.\\nconst validateBinaryTreeNodes = (n, leftChild, rightChild) => {\\n\\t// tree nodes starts from 0 to n - 1\\n\\t// if node is not a child(not in LC or RC), then it\\'s a root node\\n\\tconst findRootNode = (LC, RC) => {\\n\\t\\tconst root = 0;\\n\\t\\tconst children = new Set([...LC, ...RC]);\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (!children.has(i)) root = i;\\n\\t\\t}\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\tconst root = findRootNode(leftChild, rightChild);\\n\\tconst visited = new Set();\\n\\tconst queue = [root];\\n\\n\\twhile (queue.length) {\\n\\t\\tconst len = queue.length;\\n\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\tconst node = queue.shift();\\n\\n\\t\\t\\tif (visited.has(node)) return false;\\n\\n\\t\\t\\tvisited.add(node);\\n\\t\\t\\t\\n\\t\\t\\t// add nodes to queue to visit later\\n\\t\\t\\tif (leftChild[node] !== -1) queue.push(leftChild[node]);\\n\\t\\t\\tif (rightChild[node] !== -1) queue.push(rightChild[node]);\\n\\t\\t}\\n\\t}\\n\\n\\t// if valid tree: visited = number of node\\n\\t// all nodes are visited exactly once from 0 to n - 1 nodes\\n\\treturn visited.size === n;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 124 ms, faster than 67.74% of JavaScript online submissions for Validate Binary Tree Nodes.\\n// Memory Usage: 52.9 MB, less than 22.58% of JavaScript online submissions for Validate Binary Tree Nodes.\\nconst validateBinaryTreeNodes = (n, leftChild, rightChild) => {\\n\\t// tree nodes starts from 0 to n - 1\\n\\t// if node is not a child(not in LC or RC), then it\\'s a root node\\n\\tconst findRootNode = (LC, RC) => {\\n\\t\\tconst root = 0;\\n\\t\\tconst children = new Set([...LC, ...RC]);\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (!children.has(i)) root = i;\\n\\t\\t}\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\tconst root = findRootNode(leftChild, rightChild);\\n\\tconst visited = new Set();\\n\\tconst queue = [root];\\n\\n\\twhile (queue.length) {\\n\\t\\tconst len = queue.length;\\n\\n\\t\\tfor (let i = 0; i < len; i++) {\\n\\t\\t\\tconst node = queue.shift();\\n\\n\\t\\t\\tif (visited.has(node)) return false;\\n\\n\\t\\t\\tvisited.add(node);\\n\\t\\t\\t\\n\\t\\t\\t// add nodes to queue to visit later\\n\\t\\t\\tif (leftChild[node] !== -1) queue.push(leftChild[node]);\\n\\t\\t\\tif (rightChild[node] !== -1) queue.push(rightChild[node]);\\n\\t\\t}\\n\\t}\\n\\n\\t// if valid tree: visited = number of node\\n\\t// all nodes are visited exactly once from 0 to n - 1 nodes\\n\\treturn visited.size === n;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827022,
                "title": "c-with-disjoint-set-intuition-and-explanation",
                "content": "Intuition:\\nProblem statement(especailly examples, and with arrows) reminds me of using a Disjoint Set\\n\\nAlgorithm:  0. leaf has root as its parent in DS.\\n\\n1. join left child, return false on failed join. \\n2. join right child, if child already have a parent(parent is not self), return fail\\n3. check if only 1 component.\\n\\n```\\nclass DisjointSet {\\npublic:\\n    DisjointSet(int n) {\\n        cnt = n;\\n        for (int i = 0; i < n; ++i) {\\n            parent.push_back(-1);\\n            sizes.push_back(1);\\n        }\\n    }\\n    \\n    bool unionTwo(int x, int y) {\\n        //stick smaller to larger\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        \\n        if (rootx == rooty) return false;\\n        if (sizes[rootx] < sizes[rooty]) {\\n            parent[rootx] = rooty;\\n            sizes[rooty] += sizes[rootx];\\n        }else {\\n            parent[rooty] = rootx;\\n            sizes[rootx] += sizes[rooty];\\n        }\\n        \\n        --cnt;\\n        \\n        return true;\\n    }\\n    \\n    int find(int x) {\\n        //path compress upon find\\n        //return root of x\\n        if (parent[x] == -1) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    int getCnt() {\\n        return cnt;\\n    }\\n    \\nprivate:\\n    vector<int> parent;\\n    vector<int> sizes;\\n    int cnt;\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        DisjointSet DS(n);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (leftChild[i] != -1) \\n                if (!DS.unionTwo(i, leftChild[i])) return false;\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (rightChild[i] != -1) {\\n                if (DS.find(rightChild[i]) != rightChild[i]) return false; //node already is a child\\n                if (!DS.unionTwo(i, rightChild[i])) return false;\\n            }       \\n        }\\n        \\n        return DS.getCnt() == 1;\\n        \\n    }\\n};\\n```\\n\\nSince DS has Union by size and path compression, Union and Find are amortized O(1) each.\\nO(n) runtime to go over each node.\\nO(n) space for DS data structure.",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet {\\npublic:\\n    DisjointSet(int n) {\\n        cnt = n;\\n        for (int i = 0; i < n; ++i) {\\n            parent.push_back(-1);\\n            sizes.push_back(1);\\n        }\\n    }\\n    \\n    bool unionTwo(int x, int y) {\\n        //stick smaller to larger\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        \\n        if (rootx == rooty) return false;\\n        if (sizes[rootx] < sizes[rooty]) {\\n            parent[rootx] = rooty;\\n            sizes[rooty] += sizes[rootx];\\n        }else {\\n            parent[rooty] = rootx;\\n            sizes[rootx] += sizes[rooty];\\n        }\\n        \\n        --cnt;\\n        \\n        return true;\\n    }\\n    \\n    int find(int x) {\\n        //path compress upon find\\n        //return root of x\\n        if (parent[x] == -1) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    int getCnt() {\\n        return cnt;\\n    }\\n    \\nprivate:\\n    vector<int> parent;\\n    vector<int> sizes;\\n    int cnt;\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        DisjointSet DS(n);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (leftChild[i] != -1) \\n                if (!DS.unionTwo(i, leftChild[i])) return false;\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (rightChild[i] != -1) {\\n                if (DS.find(rightChild[i]) != rightChild[i]) return false; //node already is a child\\n                if (!DS.unionTwo(i, rightChild[i])) return false;\\n            }       \\n        }\\n        \\n        return DS.getCnt() == 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739020,
                "title": "only-dfs-and-indegree-solution",
                "content": "```\\n//Using Indegree and simple dfs\\nclass Solution {\\npublic:\\n    bool dfs(int src,vector<vector<int>> &g,vector<bool> &vis){\\n\\n        vis[src] = true;\\n        for(auto nbr : g[src]){\\n            if(vis[nbr] == false)\\n            {\\n                bool ans = dfs(nbr,g,vis);\\n                if(ans == false) return false;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) {\\n        \\n        vector<int> id(n,0);\\n        vector<vector<int>> g(n);\\n        \\n        for(int i=0;i<l.size();i++){\\n            // cout<<i<<endl;\\n            if(l[i] == -1) continue;\\n            g[i].push_back(l[i]);\\n            id[l[i]]++;\\n        }\\n  \\n        for(int i=0;i<r.size();i++){\\n            if(r[i] == -1) continue;\\n            g[i].push_back(r[i]);\\n            id[r[i]]++;\\n        }\\n     \\n        bool is = false;\\n        int nod;\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(id[i] == 0){\\n                nod = i;\\n                is = true;\\n                cnt++;\\n                // break;\\n            }\\n        }\\n        \\n        if(is == false or cnt > 1) return false;\\n        vector<bool> vis(n,false);\\n        \\n        bool anss = dfs(nod,g,vis);\\n        for(int i=0;i<n;i++){\\n            if(vis[i] == false) return false;\\n        }\\n        return anss;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool dfs(int src,vector<vector<int>> &g,vector<bool> &vis){\\n\\n        vis[src] = true;\\n        for(auto nbr : g[src]){\\n            if(vis[nbr] == false)\\n            {\\n                bool ans = dfs(nbr,g,vis);\\n                if(ans == false) return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1637411,
                "title": "1361-validate-binary-tree-nodes-simple-solution-explained-using-in-degree-and-traversal-in-tree",
                "content": "1)Binary Tree Has a single Root Node;\\n2)Each node should have in_degree==1 except the root node. (in_degree >1)  not a binary tree;\\n3)More than 1 node with in_degree ==0 then there are more than one root nodes so cannot form single binary tree;\\n4)At this point we are at a situation where we have found exactyl one node that has in_degree equal to zero. Now to form the binary tree we should be able to treverse whole binary tree from the root node if we were able to do that then all nodes can be visited from this node and hence it is a binry as all the above conditions are satisfied.\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n   \\n    bool validateBinaryTreeNodes(int n, vector<int>&leftChild, vector<int>&        rightChild) {\\n\\n        \\nvector<int>in_degree(n,0);\\nfor(int i=0;i<n;i++){ \\n    if(leftChild[i]!=-1){\\n        in_degree[leftChild[i]]++;\\n    }\\n     if(rightChild[i]!=-1){\\n        in_degree[rightChild[i]]++;\\n    }\\n    \\n}\\n  \\n        int count=0;\\n        int root;\\n        \\n        for(int i=0;i<n;i++){\\n            if(in_degree[i]>1){\\n                return false;\\n            }\\n            if(in_degree[i]==0){\\n                root=i;\\n                count++;\\n            }\\n        }\\n        \\n        if(count==1){\\n            stack<int>q;\\n            q.push(root);\\n            int k=0;\\n            while(!q.empty()){\\n                k++;\\n                int top=q.top();\\n                \\n                q.pop();\\n                if(leftChild[top]+1){\\n                    q.push(leftChild[top]);\\n                }\\n                if(rightChild[top]+1){\\n                    q.push(rightChild[top]);\\n                }\\n            }\\n            if(k==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n  \\n        \\n  \\n        \\n        \\n      \\n        \\n}\\n    \\n};\\n#donot_loseHope \\n#keepTrying\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n   \\n    bool validateBinaryTreeNodes(int n, vector<int>&leftChild, vector<int>&        rightChild) {\\n\\n        \\nvector<int>in_degree(n,0);\\nfor(int i=0;i<n;i++){ \\n    if(leftChild[i]!=-1){\\n        in_degree[leftChild[i]]++;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1636264,
                "title": "self-explanatory-c",
                "content": "```\\n    bool res = true;\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& left, vector<int>& right) {\\n        \\n        vector<vector<int>> g(n);\\n        unordered_map<int, int> indeg;\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            if(left[i] != -1) g[i].push_back(left[i]), indeg[left[i]]++; \\n            if(right[i] != -1) g[i].push_back(right[i]), indeg[right[i]]++;\\n            if(g[i].size() > 2 || indeg[i] > 2) return false;\\n        } \\n        \\n        int root = -1;\\n        for(auto e : indeg) if(e.second == 0) root = e.first;\\n        if(root == -1) return false;\\n\\n        vector<int> vis(n, 0);\\n        dfs(g, root, vis);\\n        for(auto n : vis) if(n == 0) res = false;\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<int>> &g, int i, vector<int>& vis) {\\n\\n        if(vis[i] == 1) {\\n            res = false; return;\\n        }\\n        \\n        vis[i] = 1;\\n        for(auto nbr : g[i]) dfs(g, nbr, vis);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool res = true;\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& left, vector<int>& right) {\\n        \\n        vector<vector<int>> g(n);\\n        unordered_map<int, int> indeg;\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            if(left[i] != -1) g[i].push_back(left[i]), indeg[left[i]]++; \\n            if(right[i] != -1) g[i].push_back(right[i]), indeg[right[i]]++;\\n            if(g[i].size() > 2 || indeg[i] > 2) return false;\\n        } \\n        \\n        int root = -1;\\n        for(auto e : indeg) if(e.second == 0) root = e.first;\\n        if(root == -1) return false;\\n\\n        vector<int> vis(n, 0);\\n        dfs(g, root, vis);\\n        for(auto n : vis) if(n == 0) res = false;\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<int>> &g, int i, vector<int>& vis) {\\n\\n        if(vis[i] == 1) {\\n            res = false; return;\\n        }\\n        \\n        vis[i] = 1;\\n        for(auto nbr : g[i]) dfs(g, nbr, vis);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1628365,
                "title": "c-disjoint-set-inbound-counter",
                "content": "what\\'s needed:\\n- use disjoint set/union find to find the root of the graph\\n- count number of inbound connections for each node (there is no need to check for outbound, cause outbound_count will always be at most 2*inbound_count)\\n\\nchecks:\\n1. if more than 1 inbound connection for each node, fail\\n2. if not all nodes have the same parent, fail\\n3. if all nodes have the same parent, but no root (node with 0 inbound), fail\\n\\nimplementation:\\n```\\nint find_parent(int* parent, int x) {\\n  if (parent[x] == x) return x;\\n  parent[x] = find_parent(parent, parent[x]);\\n  return parent[x];\\n}\\n\\nvoid make_group(int* parent, int u, int v) {\\n  int par_u = find_parent(parent, u);\\n  int par_v = find_parent(parent, v);\\n  // make parent of u as parent of v\\n  parent[par_v] = par_u;\\n}\\n\\nbool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n  int inbound[n];\\n  int parent[n];\\n  for (int i=0; i<n; ++i) {\\n    inbound[i] = 0;\\n    parent[i] = i;\\n  }\\n  \\n  // go thorugh all nodes\\n  for (int i=0; i<leftChildSize; ++i) {\\n    if (leftChild[i] != -1) {\\n      if (++inbound[leftChild[i]] > 1) return false;\\n      \\n      // disjoint set to link i as parent of leftChild[i]\\n      make_group(parent, i, leftChild[i]);\\n    }\\n    \\n    if (rightChild[i] != -1) {\\n      if (++inbound[rightChild[i]] > 1) return false;\\n      \\n      make_group(parent, i, rightChild[i]);\\n    }\\n  }\\n  \\n  // need to check that only 1 node has inboud = 0, which is the root\\n  int cnt_roots = 0;\\n  int root = find_parent(parent, parent[0]);\\n  for (int i=0; i<n; ++i) {\\n    // if not same parent as root, not same tree\\n    if (find_parent(parent, parent[i]) != root) return false;\\n    \\n\\t// if no inbounds connections, this is the root\\n    if (!inbound[i]) ++cnt_roots;\\n  }\\n  // if no root, means graph loops on itself\\n  if (!cnt_roots) return false;\\n  \\n  return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint find_parent(int* parent, int x) {\\n  if (parent[x] == x) return x;\\n  parent[x] = find_parent(parent, parent[x]);\\n  return parent[x];\\n}\\n\\nvoid make_group(int* parent, int u, int v) {\\n  int par_u = find_parent(parent, u);\\n  int par_v = find_parent(parent, v);\\n  // make parent of u as parent of v\\n  parent[par_v] = par_u;\\n}\\n\\nbool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n  int inbound[n];\\n  int parent[n];\\n  for (int i=0; i<n; ++i) {\\n    inbound[i] = 0;\\n    parent[i] = i;\\n  }\\n  \\n  // go thorugh all nodes\\n  for (int i=0; i<leftChildSize; ++i) {\\n    if (leftChild[i] != -1) {\\n      if (++inbound[leftChild[i]] > 1) return false;\\n      \\n      // disjoint set to link i as parent of leftChild[i]\\n      make_group(parent, i, leftChild[i]);\\n    }\\n    \\n    if (rightChild[i] != -1) {\\n      if (++inbound[rightChild[i]] > 1) return false;\\n      \\n      make_group(parent, i, rightChild[i]);\\n    }\\n  }\\n  \\n  // need to check that only 1 node has inboud = 0, which is the root\\n  int cnt_roots = 0;\\n  int root = find_parent(parent, parent[0]);\\n  for (int i=0; i<n; ++i) {\\n    // if not same parent as root, not same tree\\n    if (find_parent(parent, parent[i]) != root) return false;\\n    \\n\\t// if no inbounds connections, this is the root\\n    if (!inbound[i]) ++cnt_roots;\\n  }\\n  // if no root, means graph loops on itself\\n  if (!cnt_roots) return false;\\n  \\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623727,
                "title": "c-solution-using-bfs-approach-tc-o-n-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) \\n    { \\n        queue<int> q;\\n        vector<int> rootCheck(n, 0);\\n        for(int i=0; i<n; ++i) //condition to find root node as it is not clearly stated 0 is root node or not\\n        {\\n            if(leftChild[i]!=-1) rootCheck[leftChild[i]]=1;\\n            if(rightChild[i]!=-1) rootCheck[rightChild[i]]=1;\\n        }\\n        \\n        for(int i=0; i<n; ++i) \\n        {\\n            if(!rootCheck[i]) \\n            {\\n             q.push(i); \\n             break;\\n            }\\n        }\\n        vector<int> vis(n, 0);\\n        while(!q.empty())\\n        {\\n         int node=q.front();\\n            q.pop();\\n            if(vis[node]) return false;\\n            vis[node]=1;\\n            if(leftChild[node]!=-1) q.push(leftChild[node]);\\n            if(rightChild[node]!=-1) q.push(rightChild[node]);\\n            \\n        }\\n        \\n        for(int i=0; i<n; ++i)\\n        {\\n            if(vis[i]==0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) \\n    { \\n        queue<int> q;\\n        vector<int> rootCheck(n, 0);\\n        for(int i=0; i<n; ++i) //condition to find root node as it is not clearly stated 0 is root node or not\\n        {\\n            if(leftChild[i]!=-1) rootCheck[leftChild[i]]=1;\\n            if(rightChild[i]!=-1) rootCheck[rightChild[i]]=1;\\n        }\\n        \\n        for(int i=0; i<n; ++i) \\n        {\\n            if(!rootCheck[i]) \\n            {\\n             q.push(i); \\n             break;\\n            }\\n        }\\n        vector<int> vis(n, 0);\\n        while(!q.empty())\\n        {\\n         int node=q.front();\\n            q.pop();\\n            if(vis[node]) return false;\\n            vis[node]=1;\\n            if(leftChild[node]!=-1) q.push(leftChild[node]);\\n            if(rightChild[node]!=-1) q.push(rightChild[node]);\\n            \\n        }\\n        \\n        for(int i=0; i<n; ++i)\\n        {\\n            if(vis[i]==0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543879,
                "title": "dfs-indegree-easy-and-simple-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> *adj;\\n    vector<bool> visited;\\n    bool flag = false;\\n    int v = 0;\\n    \\n    void dfs(int src){\\n        visited[src] = true;\\n        v++;\\n        for(auto el : adj[src])\\n            if(visited[el]){\\n                flag = true;\\n                continue;\\n            }\\n            else\\n                dfs(el);\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild)     {\\n        adj = new vector<int>[n];\\n        visited = vector<bool>(n);\\n        vector<int> inde(n,0);\\n        \\n        for(int i = 0 ; i < n;i++){\\n            if(leftChild[i] != -1){\\n                adj[i].push_back(leftChild[i]);\\n                 inde[leftChild[i]]++;\\n            }\\n            if(rightChild[i] != -1){\\n                adj[i].push_back(rightChild[i]);    \\n                inde[rightChild[i]]++;\\n            }\\n            \\n        }\\n        \\n        int cnt = 0,ind = 0;\\n        \\n        for(int i = 0 ; i <n;i++)\\n        {\\n            if(inde[i] == 0){\\n                ind = i;\\n                cnt++;\\n            }\\n        }\\n        \\n        if(cnt>1)\\n            return false;\\n        \\n            dfs(ind);\\n    \\n        if(flag or v != n)\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> *adj;\\n    vector<bool> visited;\\n    bool flag = false;\\n    int v = 0;\\n    \\n    void dfs(int src){\\n        visited[src] = true;\\n        v++;\\n        for(auto el : adj[src])\\n            if(visited[el]){\\n                flag = true;\\n                continue;\\n            }\\n            else\\n                dfs(el);\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild)     {\\n        adj = new vector<int>[n];\\n        visited = vector<bool>(n);\\n        vector<int> inde(n,0);\\n        \\n        for(int i = 0 ; i < n;i++){\\n            if(leftChild[i] != -1){\\n                adj[i].push_back(leftChild[i]);\\n                 inde[leftChild[i]]++;\\n            }\\n            if(rightChild[i] != -1){\\n                adj[i].push_back(rightChild[i]);    \\n                inde[rightChild[i]]++;\\n            }\\n            \\n        }\\n        \\n        int cnt = 0,ind = 0;\\n        \\n        for(int i = 0 ; i <n;i++)\\n        {\\n            if(inde[i] == 0){\\n                ind = i;\\n                cnt++;\\n            }\\n        }\\n        \\n        if(cnt>1)\\n            return false;\\n        \\n            dfs(ind);\\n    \\n        if(flag or v != n)\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509332,
                "title": "java-topological-sort-bfs",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        List<Integer>[] graph = (List<Integer>[]) new ArrayList[n];\\n        for (int i=0; i<n; i++) graph[i]=new ArrayList<>();\\n        int edges=0;\\n        int[] degree = new int[n];\\n        for (int i=0; i<n; i++) {\\n            if (leftChild[i]!=-1) {\\n                graph[i].add(leftChild[i]);\\n                degree[leftChild[i]]++;\\n                edges++;\\n            }\\n            if (rightChild[i]!=-1) {\\n                graph[i].add(rightChild[i]);\\n                degree[rightChild[i]]++;\\n                edges++;  \\n            }\\n            if (i==leftChild[i]||i==rightChild[i]||(leftChild[i]!=-1&&leftChild[i]==rightChild[i])) return false;\\n        }\\n        if (edges!=n-1) return false;\\n        \\n        int count=0;\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i=0; i<n; i++) {\\n            if (degree[i]==0) {\\n                queue.offer(i);\\n            } \\n            if (degree[i]>=2) {\\n                return false;\\n            }\\n        }\\n\\n        if (queue.size()>1) return false;\\n        \\n\\n        while (!queue.isEmpty()) {\\n            int size= queue.size();\\n            for (int i=0; i<size; i++) {\\n                int curr = queue.poll();\\n                count++;\\n                for (int w: graph[curr]) {\\n                    if (--degree[w]==0) {\\n                        queue.offer(w);\\n                    }\\n                }\\n            }\\n        }\\n        return count==n;\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        List<Integer>[] graph = (List<Integer>[]) new ArrayList[n];\\n        for (int i=0; i<n; i++) graph[i]=new ArrayList<>();\\n        int edges=0;\\n        int[] degree = new int[n];\\n        for (int i=0; i<n; i++) {\\n            if (leftChild[i]!=-1) {\\n                graph[i].add(leftChild[i]);\\n                degree[leftChild[i]]++;\\n                edges++;\\n            }\\n            if (rightChild[i]!=-1) {\\n                graph[i].add(rightChild[i]);\\n                degree[rightChild[i]]++;\\n                edges++;  \\n            }\\n            if (i==leftChild[i]||i==rightChild[i]||(leftChild[i]!=-1&&leftChild[i]==rightChild[i])) return false;\\n        }\\n        if (edges!=n-1) return false;\\n        \\n        int count=0;\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i=0; i<n; i++) {\\n            if (degree[i]==0) {\\n                queue.offer(i);\\n            } \\n            if (degree[i]>=2) {\\n                return false;\\n            }\\n        }\\n\\n        if (queue.size()>1) return false;\\n        \\n\\n        while (!queue.isEmpty()) {\\n            int size= queue.size();\\n            for (int i=0; i<size; i++) {\\n                int curr = queue.poll();\\n                count++;\\n                for (int w: graph[curr]) {\\n                    if (--degree[w]==0) {\\n                        queue.offer(w);\\n                    }\\n                }\\n            }\\n        }\\n        return count==n;\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497798,
                "title": "clean-python-dfs-with-cycle-detection",
                "content": "Time & Space Complexity: O(n)\\n```\\nfrom enum import Enum\\n\\nclass Status(Enum):\\n    UNVISITED = 0\\n    VISITING = 1\\n    VISITED = 2\\n\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n, left, right):\\n        status, indegree = defaultdict(int), defaultdict(int)\\n        status[-1] = Status.VISITED\\n\\t\\t\\n        def has_cycle(u):\\n            if status[u] == Status.VISITED:\\n                indegree[u] += 1\\n                return False\\n            if status[u] == Status.VISITING:\\n                return True\\n            status[u] = Status.VISITING\\n            if has_cycle(left[u]) or has_cycle(right[u]):\\n                return True\\n            status[u] = Status.VISITED\\n            return False\\n        \\n\\t\\t# Return false if any cycles are detected\\n        if any(has_cycle(u) for u in range(n)):\\n            return False\\n        \\n\\t\\t# Return true if there is exactly 1 root and all other nodes have exactly 1 parent\\n        num_roots = 0\\n        for u in range(n):\\n            if indegree[u] > 1:\\n                return False\\n            num_roots += indegree[u] == 0\\n        return num_roots == 1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom enum import Enum\\n\\nclass Status(Enum):\\n    UNVISITED = 0\\n    VISITING = 1\\n    VISITED = 2\\n\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n, left, right):\\n        status, indegree = defaultdict(int), defaultdict(int)\\n        status[-1] = Status.VISITED\\n\\t\\t\\n        def has_cycle(u):\\n            if status[u] == Status.VISITED:\\n                indegree[u] += 1\\n                return False\\n            if status[u] == Status.VISITING:\\n                return True\\n            status[u] = Status.VISITING\\n            if has_cycle(left[u]) or has_cycle(right[u]):\\n                return True\\n            status[u] = Status.VISITED\\n            return False\\n        \\n\\t\\t# Return false if any cycles are detected\\n        if any(has_cycle(u) for u in range(n)):\\n            return False\\n        \\n\\t\\t# Return true if there is exactly 1 root and all other nodes have exactly 1 parent\\n        num_roots = 0\\n        for u in range(n):\\n            if indegree[u] > 1:\\n                return False\\n            num_roots += indegree[u] == 0\\n        return num_roots == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492370,
                "title": "java-topological-sort",
                "content": "// Topological sort \\n\\nclass Solution {\\n\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        int[] indegree = new int[n];\\n        for (int i=0; i<n; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            if (leftChild[i]!=-1) {\\n                list.add(leftChild[i]);\\n                indegree[leftChild[i]]++;\\n            }\\n            if (rightChild[i]!=-1) {\\n                list.add(rightChild[i]);\\n                indegree[rightChild[i]]++;\\n            }\\n            if (!list.isEmpty())\\n                map.put(i, list);\\n        }\\n        \\n        Queue<Integer> qu = new LinkedList<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            if (indegree[i]==0)\\n                qu.add(i);\\n            // if more than one parent for a node then return false;\\n            if (indegree[i]>1)\\n                return false;\\n        }\\n        \\n        // if there are multiple root nodes then return false\\n        if (qu.size()!=1) return false;\\n        \\n        int count = 0;\\n        \\n        while (!qu.isEmpty()) {\\n            int size = qu.size();\\n            for (int i=0; i<size; i++) {\\n                int curr = qu.poll();\\n                count++;\\n                \\n                if (!map.containsKey(curr)) continue;\\n                \\n                for (int child: map.get(curr)) {\\n                    indegree[child]--;\\n                    if (indegree[child]==0) \\n                        qu.add(child);\\n                }\\n            }\\n        }\\n        \\n        // if all nodes had indegree=0 then return true\\n        return count==n;\\n    }\\n}\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        int[] indegree = new int[n];\\n        for (int i=0; i<n; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            if (leftChild[i]!=-1) {\\n                list.add(leftChild[i]);\\n                indegree[leftChild[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1479765,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool hasCycle(vector<vector<int>> &adj, vector<bool> &visited, int source){\\n        // cycle detected, thus true, this graph has a cycle\\n        if(visited.at(source)) return true;\\n        \\n        visited.at(source) = true;\\n        for(int &childNode : adj[source]){\\n            if(childNode == -1) continue;\\n                \\n            // we\\'ve detected a cycle along this path\\n            if(hasCycle(adj, visited, childNode)) return true;\\n        }\\n        \\n        // no cycle detected in graph\\n        return false;\\n    }\\n    \\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        // Valid tree must have the three following properties\\n        // 1) connected\\n        // 2) directed\\n        // 3) acyclic\\n        \\n        vector<vector<int>> adj(n);        \\n        for(int i = 0; i < n; i++){            \\n            adj[i].push_back(leftChild.at(i));\\n            adj[i].push_back(rightChild.at(i));\\n        }\\n        \\n        // determine if node has a parent, \\n        vector<bool> nodeHasParents(n, false);\\n        for(int i = 0; i < n; i++){\\n            for(int childNode : adj[i]){\\n                if(childNode == -1) continue;\\n                \\n                // this node has a parent;\\n                nodeHasParents[childNode] = true;\\n            }\\n        }\\n        \\n        // if node does not have a parent, then it is a root node\\n        int rootNode = 0;\\n        for(int i = 0; i < n; i++){\\n            if(!nodeHasParents.at(i)){\\n                rootNode = i;\\n                break;\\n            }\\n        }\\n                \\n        // if the graph has a cycle, then it is not a valid tree\\n        // a valid tree must be acyclic, meaning no cycles\\n        vector<bool> visited(n, false);\\n        if(hasCycle(adj, visited, rootNode)) return false;\\n        \\n        // check if we\\'ve visited all nodes\\n        // if the tree is valid, only one traversal\\n        // is enough to have visited all nodes in the tree\\n        // this is because the tree is connected\\n        for(bool visitedNode : visited) \\n            if(!visitedNode) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool hasCycle(vector<vector<int>> &adj, vector<bool> &visited, int source){\\n        // cycle detected, thus true, this graph has a cycle\\n        if(visited.at(source)) return true;\\n        \\n        visited.at(source) = true;\\n        for(int &childNode : adj[source]){\\n            if(childNode == -1) continue;\\n                \\n            // we\\'ve detected a cycle along this path\\n            if(hasCycle(adj, visited, childNode)) return true;\\n        }\\n        \\n        // no cycle detected in graph\\n        return false;\\n    }\\n    \\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        // Valid tree must have the three following properties\\n        // 1) connected\\n        // 2) directed\\n        // 3) acyclic\\n        \\n        vector<vector<int>> adj(n);        \\n        for(int i = 0; i < n; i++){            \\n            adj[i].push_back(leftChild.at(i));\\n            adj[i].push_back(rightChild.at(i));\\n        }\\n        \\n        // determine if node has a parent, \\n        vector<bool> nodeHasParents(n, false);\\n        for(int i = 0; i < n; i++){\\n            for(int childNode : adj[i]){\\n                if(childNode == -1) continue;\\n                \\n                // this node has a parent;\\n                nodeHasParents[childNode] = true;\\n            }\\n        }\\n        \\n        // if node does not have a parent, then it is a root node\\n        int rootNode = 0;\\n        for(int i = 0; i < n; i++){\\n            if(!nodeHasParents.at(i)){\\n                rootNode = i;\\n                break;\\n            }\\n        }\\n                \\n        // if the graph has a cycle, then it is not a valid tree\\n        // a valid tree must be acyclic, meaning no cycles\\n        vector<bool> visited(n, false);\\n        if(hasCycle(adj, visited, rootNode)) return false;\\n        \\n        // check if we\\'ve visited all nodes\\n        // if the tree is valid, only one traversal\\n        // is enough to have visited all nodes in the tree\\n        // this is because the tree is connected\\n        for(bool visitedNode : visited) \\n            if(!visitedNode) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454634,
                "title": "java-union-find-using-array",
                "content": "```\\nclass Solution {\\n    class UnionFind{\\n        private int[] parent;\\n        private int numOfSets;\\n        \\n        public UnionFind(int n){\\n            parent = new int[n];\\n            Arrays.fill(parent, -1);\\n        }\\n        \\n        public void add(int x){\\n            if(parent[x] != -1) return;\\n            \\n            parent[x] = x;\\n            numOfSets++;\\n            \\n        }\\n        \\n        public int find(int x){\\n            int root = x;\\n            \\n            while(parent[root] != -1 && parent[root] != root){\\n                root = parent[root];\\n            }\\n            \\n            while(x != root){\\n                int originalParent = parent[x];\\n                parent[x] = root;\\n                x = originalParent;\\n            }\\n            \\n            return root;\\n        }\\n        \\n        \\n        // connect the node x and y, where x is parent and y is child\\n        public void merge(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            \\n            \\n            if(rootX != rootY && rootY == y){\\n                parent[rootY] = rootX;\\n                numOfSets--;\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y){\\n            return (find(x) == find(y)) && find(x) != -1;\\n        }\\n        \\n        public int getNumOfSet(){\\n            return numOfSets;\\n        }\\n        \\n    }\\n    \\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            // add current parent node into UF\\n            uf.add(i);\\n            // pricess left child\\n            if(leftChild[i] != -1){\\n                // add left child node into UF\\n                uf.add(leftChild[i]);\\n                // if edge already exists, return false\\n                if(uf.isConnected(i, leftChild[i])) return false;\\n                // add the edge into UF\\n                uf.merge(i, leftChild[i]);\\n            }\\n            // process right child\\n            if(rightChild[i] != -1){\\n                // add left child node into UF\\n                uf.add(rightChild[i]);\\n                // if edge already exists, return false\\n                if(uf.isConnected(i, rightChild[i])) return false;\\n                // add the edge into UF\\n                uf.merge(i, rightChild[i]);\\n            }            \\n        }\\n        \\n        return uf.getNumOfSet() == 1;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class UnionFind{\\n        private int[] parent;\\n        private int numOfSets;\\n        \\n        public UnionFind(int n){\\n            parent = new int[n];\\n            Arrays.fill(parent, -1);\\n        }\\n        \\n        public void add(int x){\\n            if(parent[x] != -1) return;\\n            \\n            parent[x] = x;\\n            numOfSets++;\\n            \\n        }\\n        \\n        public int find(int x){\\n            int root = x;\\n            \\n            while(parent[root] != -1 && parent[root] != root){\\n                root = parent[root];\\n            }\\n            \\n            while(x != root){\\n                int originalParent = parent[x];\\n                parent[x] = root;\\n                x = originalParent;\\n            }\\n            \\n            return root;\\n        }\\n        \\n        \\n        // connect the node x and y, where x is parent and y is child\\n        public void merge(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            \\n            \\n            if(rootX != rootY && rootY == y){\\n                parent[rootY] = rootX;\\n                numOfSets--;\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y){\\n            return (find(x) == find(y)) && find(x) != -1;\\n        }\\n        \\n        public int getNumOfSet(){\\n            return numOfSets;\\n        }\\n        \\n    }\\n    \\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            // add current parent node into UF\\n            uf.add(i);\\n            // pricess left child\\n            if(leftChild[i] != -1){\\n                // add left child node into UF\\n                uf.add(leftChild[i]);\\n                // if edge already exists, return false\\n                if(uf.isConnected(i, leftChild[i])) return false;\\n                // add the edge into UF\\n                uf.merge(i, leftChild[i]);\\n            }\\n            // process right child\\n            if(rightChild[i] != -1){\\n                // add left child node into UF\\n                uf.add(rightChild[i]);\\n                // if edge already exists, return false\\n                if(uf.isConnected(i, rightChild[i])) return false;\\n                // add the edge into UF\\n                uf.merge(i, rightChild[i]);\\n            }            \\n        }\\n        \\n        return uf.getNumOfSet() == 1;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415544,
                "title": "condition-for-a-graph-to-be-a-binary-tree",
                "content": "Condition for a Graph to be a Tree -\\n* There should be exactly one root node with no incoming edges\\n* All node should have exactly one parent\\n* All nodes should be reachable from root\\n* A parent can have atmost 2 childrens\\n\\nTime: O(V+E)\\nSpace: O(V)\\n```\\nclass Solution {\\n    int count = 0; // for keeping count of visited nodes\\n    public boolean dfs(int u, int[] leftChild, int[] rightChild, boolean[] visited){\\n        if(visited[u]){\\n            // found a node with more than one parent\\n            return false;\\n        }\\n        visited[u] = true;\\n        count++;\\n        if(leftChild[u]!=-1  && !dfs(leftChild[u], leftChild, rightChild, visited))\\n            return false;\\n        if(rightChild[u]!=-1 && !dfs(rightChild[u], leftChild, rightChild, visited))\\n            return false;\\n        return true;\\n    }\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        // Condition\\n        // determine the root\\n        // node with no incoming eges or in-degree zero\\n        int root = -1;\\n        int[] in_degree = new int[n];\\n        for(int i=0;i<n;i++){\\n            if(leftChild[i]!=-1)\\n                in_degree[leftChild[i]]++;\\n            if(rightChild[i]!=-1)\\n                in_degree[rightChild[i]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(in_degree[i]==0){\\n                if(root==-1){\\n                    root = i;\\n                }else{\\n                    return false; // found another node with no incoming edges\\n                    // i.e graph is disconnected\\n                }\\n            }\\n        }\\n        if(root==-1){\\n            //  could not found any root\\n            return false;\\n        }\\n        // System.out.println(root);\\n        // do dfs on root and visit all reachable nodes\\n        // all nodes should be visited\\n        boolean[] visited = new boolean[n];\\n        boolean allHaveOneParent = dfs(root, leftChild, rightChild, visited); \\n        // System.out.println(count);\\n        return  allHaveOneParent && count==n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0; // for keeping count of visited nodes\\n    public boolean dfs(int u, int[] leftChild, int[] rightChild, boolean[] visited){\\n        if(visited[u]){\\n            // found a node with more than one parent\\n            return false;\\n        }\\n        visited[u] = true;\\n        count++;\\n        if(leftChild[u]!=-1  && !dfs(leftChild[u], leftChild, rightChild, visited))\\n            return false;\\n        if(rightChild[u]!=-1 && !dfs(rightChild[u], leftChild, rightChild, visited))\\n            return false;\\n        return true;\\n    }\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        // Condition\\n        // determine the root\\n        // node with no incoming eges or in-degree zero\\n        int root = -1;\\n        int[] in_degree = new int[n];\\n        for(int i=0;i<n;i++){\\n            if(leftChild[i]!=-1)\\n                in_degree[leftChild[i]]++;\\n            if(rightChild[i]!=-1)\\n                in_degree[rightChild[i]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(in_degree[i]==0){\\n                if(root==-1){\\n                    root = i;\\n                }else{\\n                    return false; // found another node with no incoming edges\\n                    // i.e graph is disconnected\\n                }\\n            }\\n        }\\n        if(root==-1){\\n            //  could not found any root\\n            return false;\\n        }\\n        // System.out.println(root);\\n        // do dfs on root and visit all reachable nodes\\n        // all nodes should be visited\\n        boolean[] visited = new boolean[n];\\n        boolean allHaveOneParent = dfs(root, leftChild, rightChild, visited); \\n        // System.out.println(count);\\n        return  allHaveOneParent && count==n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393525,
                "title": "java-union-find-solution-that-actually-works-list-of-edge-cases",
                "content": "Okay, I went around reading a lot of solutions, and a loooot of them don\\'t actually work. They fail when there are self-pointers, self-loops, multiple loops, having a root with non-zero node, having multiple roots, etc.\\nLet me paste some edge cases and then explain my solution.\\n\\nHere are some edge cases you can use to debug your code\\n```\\n3\\n[1,-1,-1]\\n[-1,-1,1]\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n4\\n[3,2,-1,-1]\\n[-1,-1,1,-1]\\n3\\n[-1,2,-1]\\n[-1,-1,1]\\n3\\n[1,-1,-1]\\n[-1,-1,1]\\n4\\n[1, 0, 3, -1]\\n[-1, -1, -1, -1]\\n```\\n\\nNow, let me explain the idea for my solution:\\nI use Union Find for connecting all the nodes.\\n1) We union every node(parent) with its left and right children.\\n2) We can only union a Parent with a Child if :\\n  a) The Child does not already have a parent\\n  b) The Child is not the parent of the Parent\\n3) Finally, after performing all the union operations, we check if we have a SINGLE connected component\\n\\nWhat I said in code:\\n```java\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        UF uf = new UF(n);\\n        for(int i = 0; i < n; i++){\\n            int left = leftChild[i], right = rightChild[i];\\n            if(left != -1 && !uf.union(i, left)) return false;\\n            if(right != -1 && !uf.union(i, right)) return false;\\n        }\\n        return uf.getComponents() == 1;\\n    }\\n}\\n\\nclass UF{\\n    int parent[], components;\\n    UF(int n){\\n        parent = new int[n];\\n        components = n;\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n    }\\n    \\n    public int find(int a){\\n        if(a == parent[a]) return a;\\n        return parent[a] = find(parent[a]);\\n    }\\n    \\n    public boolean union(int par, int child){\\n        int rootParent = parent[par], rootChild = parent[child];\\n        if(rootParent == rootChild || rootChild != child) return false;\\n\\n        parent[child] = rootParent;\\n        components--;\\n        return true;\\n    }\\n    \\n    public int getComponents(){\\n        return components;\\n    } \\n}\\n```\\n\\nFeel free to ask questions in case something is unclear. I try to always reply :)",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\n3\\n[1,-1,-1]\\n[-1,-1,1]\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n4\\n[3,2,-1,-1]\\n[-1,-1,1,-1]\\n3\\n[-1,2,-1]\\n[-1,-1,1]\\n3\\n[1,-1,-1]\\n[-1,-1,1]\\n4\\n[1, 0, 3, -1]\\n[-1, -1, -1, -1]\\n```\n```java\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        UF uf = new UF(n);\\n        for(int i = 0; i < n; i++){\\n            int left = leftChild[i], right = rightChild[i];\\n            if(left != -1 && !uf.union(i, left)) return false;\\n            if(right != -1 && !uf.union(i, right)) return false;\\n        }\\n        return uf.getComponents() == 1;\\n    }\\n}\\n\\nclass UF{\\n    int parent[], components;\\n    UF(int n){\\n        parent = new int[n];\\n        components = n;\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n    }\\n    \\n    public int find(int a){\\n        if(a == parent[a]) return a;\\n        return parent[a] = find(parent[a]);\\n    }\\n    \\n    public boolean union(int par, int child){\\n        int rootParent = parent[par], rootChild = parent[child];\\n        if(rootParent == rootChild || rootChild != child) return false;\\n\\n        parent[child] = rootParent;\\n        components--;\\n        return true;\\n    }\\n    \\n    public int getComponents(){\\n        return components;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391506,
                "title": "1ms-java-union-and-find",
                "content": "* Mark the parents of the children. \\n* If a child already has a parent  attached then return false.\\n*  If the child is one of the ancestors then there is an back edge, so return false. \\n*  Mark the parent of the child as parent of the parent. This way we ensure that all the nodes in a tree point to the root node as parent and back edge can be detected easily.\\n*  At the end, if there are multiple nodes with parent -1(or nil) then there are multiple roots. Return false in that case otherwise return true\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++) parent[i] = -1;\\n        for(int i = 0; i < n; i++){\\n\\t\\t    //If the node has a left child\\n            if(leftChild[i] != -1){\\n\\t\\t\\t\\t// If there is no parent assigned to the child and the child is not one of the ancestors, then assign the parent to child\\n                if(parent[leftChild[i]] == -1 && (parent[i] == -1 || leftChild[i] != parent[i])){\\n                    parent[leftChild[i]] = parent[i] != -1 ? parent[i] : i;\\n                }else {\\n                    return false;\\n                }\\n            }\\n            if(rightChild[i] != -1){\\n                if(parent[rightChild[i]] == -1 && (parent[i] == -1 || rightChild[i] != parent[i])){\\n                    parent[rightChild[i]] = parent[i] != -1 ? parent[i] : i;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        int rootCount = 0;\\n        for(int i = 0; i < n; i++){\\n            if(parent[i] == -1) rootCount++;\\n\\t\\t\\t//If there are multiple roots to the tree return false\\n\\t\\t\\tif(rootCount > 1) return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++) parent[i] = -1;\\n        for(int i = 0; i < n; i++){\\n\\t\\t    //If the node has a left child\\n            if(leftChild[i] != -1){\\n\\t\\t\\t\\t// If there is no parent assigned to the child and the child is not one of the ancestors, then assign the parent to child\\n                if(parent[leftChild[i]] == -1 && (parent[i] == -1 || leftChild[i] != parent[i])){\\n                    parent[leftChild[i]] = parent[i] != -1 ? parent[i] : i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1328672,
                "title": "c-union-find-with-explanation-76-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n  void make_parent(vector<int>&parent){\\n    for(int i=0;i<parent.size();i++)\\n        parent[i]=i;\\n    }   \\n  int find_parent(vector<int>&parent,int x){\\n      if(parent[x]!=x){\\n        parent[x]=find_parent(parent,parent[x]);\\n      }\\n    return parent[x];\\n  }\\n  void calcUnion(vector<int>&parent,vector<int>&rank,int x,int y){\\n     int p=find_parent(parent,x);\\n    int q=find_parent(parent,y);\\n     if(rank[p]>rank[q]){\\n       parent[q]=p;\\n     }\\n    else if(rank[p]<rank[q]){\\n      parent[p]=q;\\n      }\\n    else{\\n       parent[p]=q;\\n        rank[q]++;\\n      }\\n  }\\n      \\n    \\n  \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n      // first we will take out the indegree and outdegree of every node so that we cam identify the root node \\n      // as root node has indegree 0 and outdegree greater than or equal to zero\\n      vector<int>indegree(n);\\n        vector<int>outdegree(n);\\n        for(int i=0;i<n;i++){\\n           if(leftChild[i]!=-1){\\n             indegree[leftChild[i]]++;\\n             outdegree[i]++;\\n           }\\n          if(rightChild[i]!=-1){\\n            indegree[rightChild[i]]++;\\n            outdegree[i]++;\\n          }\\n        }\\n      // let us consider the value of root initially as -1\\n      int root=-1;\\n       for(int i=0;i<n;i++){\\n         //  in root indegree is zero and outdegree greater than equal to 0(zero is also possible)\\n           if(indegree[i]==0 && outdegree[i]>=0){\\n             // only one binary tree is possible so we wil check this so that we can get other node with root properties\\n             if(root!=-1) return false;\\n             root=i;\\n           }\\n         //  other than root aur sb nodes ka max indegree 1 hoga agar usse jada hua to false retrun kr dena\\n         if(indegree[i]>1) return false;\\n       }\\n      // if we are not able to find the root value i.e it is same as -1 then we will just return as false\\n      if(root==-1) return false; \\n      // now we will use the union find concept to find the \\n      vector<int>parent(n);\\n      make_parent(parent);\\n      vector<int>rank(n,0);\\n      // we have consider the rank of root to be INT_MAX so that every time in every case root is the parent \\n      // of every node\\n      rank[root]=INT_MAX;\\n      for(int i=0;i<n;i++){\\n         if(leftChild[i]!=-1){\\n           calcUnion(parent,rank,i,leftChild[i]);\\n         }\\n        if(rightChild[i]!=-1){\\n          calcUnion(parent,rank,i,rightChild[i]);\\n        }\\n      }\\n      // now we will just check that parent of every node is root or not ,if it is not 1 binary tree is not possible so return false\\n      for(int i=0;i<n;i++){\\n         if(leftChild[i]!=-1){\\n        if(find_parent(parent,leftChild[i])!=root) return false; }\\n        if(rightChild[i]!=-1){\\n        if(find_parent(parent,rightChild[i])!=root) return false; }\\n      }\\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void make_parent(vector<int>&parent){\\n    for(int i=0;i<parent.size();i++)\\n        parent[i]=i;\\n    }   \\n  int find_parent(vector<int>&parent,int x){\\n      if(parent[x]!=x){\\n        parent[x]=find_parent(parent,parent[x]);\\n      }\\n    return parent[x];\\n  }\\n  void calcUnion(vector<int>&parent,vector<int>&rank,int x,int y){\\n     int p=find_parent(parent,x);\\n    int q=find_parent(parent,y);\\n     if(rank[p]>rank[q]){\\n       parent[q]=p;\\n     }\\n    else if(rank[p]<rank[q]){\\n      parent[p]=q;\\n      }\\n    else{\\n       parent[p]=q;\\n        rank[q]++;\\n      }\\n  }\\n      \\n    \\n  \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n      // first we will take out the indegree and outdegree of every node so that we cam identify the root node \\n      // as root node has indegree 0 and outdegree greater than or equal to zero\\n      vector<int>indegree(n);\\n        vector<int>outdegree(n);\\n        for(int i=0;i<n;i++){\\n           if(leftChild[i]!=-1){\\n             indegree[leftChild[i]]++;\\n             outdegree[i]++;\\n           }\\n          if(rightChild[i]!=-1){\\n            indegree[rightChild[i]]++;\\n            outdegree[i]++;\\n          }\\n        }\\n      // let us consider the value of root initially as -1\\n      int root=-1;\\n       for(int i=0;i<n;i++){\\n         //  in root indegree is zero and outdegree greater than equal to 0(zero is also possible)\\n           if(indegree[i]==0 && outdegree[i]>=0){\\n             // only one binary tree is possible so we wil check this so that we can get other node with root properties\\n             if(root!=-1) return false;\\n             root=i;\\n           }\\n         //  other than root aur sb nodes ka max indegree 1 hoga agar usse jada hua to false retrun kr dena\\n         if(indegree[i]>1) return false;\\n       }\\n      // if we are not able to find the root value i.e it is same as -1 then we will just return as false\\n      if(root==-1) return false; \\n      // now we will use the union find concept to find the \\n      vector<int>parent(n);\\n      make_parent(parent);\\n      vector<int>rank(n,0);\\n      // we have consider the rank of root to be INT_MAX so that every time in every case root is the parent \\n      // of every node\\n      rank[root]=INT_MAX;\\n      for(int i=0;i<n;i++){\\n         if(leftChild[i]!=-1){\\n           calcUnion(parent,rank,i,leftChild[i]);\\n         }\\n        if(rightChild[i]!=-1){\\n          calcUnion(parent,rank,i,rightChild[i]);\\n        }\\n      }\\n      // now we will just check that parent of every node is root or not ,if it is not 1 binary tree is not possible so return false\\n      for(int i=0;i<n;i++){\\n         if(leftChild[i]!=-1){\\n        if(find_parent(parent,leftChild[i])!=root) return false; }\\n        if(rightChild[i]!=-1){\\n        if(find_parent(parent,rightChild[i])!=root) return false; }\\n      }\\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326617,
                "title": "union-find-java-with-explanation",
                "content": "**First we need to find root. \\nTo find root, we need to calculate In -Degree and Out - Degree of the all nodes\\nA node will be root, if and only if, its In-Degree is 0 and Out Degree >= 0. So, from here we found our root, If there is no root, return false. Also if there are more than 1 root , then also return false.\\nNow we are applying union-find algorithm, During initialization of rank array, assign rank[root] = INT_MAX and rest all nodes to 1. This is because, Suppose rank of any node is equal to root node, i.e rank[node] == rank[root], Now in this case root node must be parent..Hence we initialized rank of root to infinity.\\nWith, the help of union find, we calculated parent of all nodes. Now for a graph to be eligible for a binary tree, all of its node must point to root node. Hence, we traversed all the nodes and checked, if parent of a node is equal to root node or not. If it is not, return false.**\\n\\n```\\n\\tint parent[] ;\\n    int rank[] ;\\n  \\n   //Finding parent of the node\\n    int findParent(int node){\\n      if(node == parent[node]) return node ;\\n      return parent[node] = findParent(parent[node]) ;\\n    }\\n    \\n\\t//union find template\\n    void union(int u, int v){\\n      u = findParent(u) ;\\n      v = findParent(v) ;\\n      if(rank[u] > rank[v]){\\n        parent[v] = u ; \\n      }\\n      else if(rank[u] < rank[v]){\\n        parent[u] = v ;\\n      }\\n      else{\\n        parent[u] = v ;\\n        rank[v]++ ;\\n      }\\n    }\\n\\t\\n\\tpublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n       int inDeg[] = new int[n] ;\\n       int outDeg[] = new int[n] ;\\n         \\n      //Calculating in-degree and out-degree of all nodes\\n       for(int i=0 ; i<n ; i++){\\n         int u = leftChild[i] ;\\n         int v = rightChild[i] ;\\n         if(u!=-1){\\n           inDeg[u]++ ;\\n           outDeg[i]++;\\n         }\\n         if(v!=-1){\\n           inDeg[v]++;\\n           outDeg[i]++;\\n         }\\n       }\\n      \\n       //Now finding root from inDegree and outDegree arrays\\n       int root = -1 ;\\n       for(int i=0 ; i<n ; i++){\\n         //Condition for a node ..to be eligible for root\\n         if(inDeg[i] == 0 && outDeg[i] >= 0){\\n           if(root != -1) return false ;   //Checking if we already got our root or not \\n           root =  i ;\\n         }\\n         //Check if node have not more than 1 InDegree (Since in BT all nodes except root node, all have only one inDegree) \\n         if(inDeg[i] > 1) return false ;  \\n       }\\n        \\n       //If we did\\'nt found any root return false\\n       if(root == -1) return false ;\\n      \\n      \\n       //Appplying union find\\n       parent = new int[n] ;\\n       rank = new int[n] ;\\n      \\n       for(int i=0 ; i<n ; i++){\\n         parent[i] = i ;\\n         rank[i] = 1 ;\\n       }\\n        \\n       //intialize rank of root to infinity..as discussed above\\n       rank[root] = Integer.MAX_VALUE ;\\n       \\n       for(int i=0 ; i<n ; i++){\\n         int u = leftChild[i] ;\\n         int v = rightChild[i] ;\\n         if(u != -1){\\n           union(i,u) ;\\n         }\\n         if(v!=-1){\\n           union(i,v) ;\\n         }\\n       }\\n       \\n       //With help of union find we calculated parent of all nodes\\n       //Parent of all node should be root node for a graph to be binary tree \\n       for(int i=0 ; i<n ; i++){\\n         int u = leftChild[i] ;\\n         int v = rightChild[i] ;\\n         if(u != -1){\\n           u = findParent(u) ;\\n           if(u != root) return false ; \\n         }\\n         if(v != -1){\\n           v = findParent(v) ;\\n           if(v != root) return false ;\\n         }\\n       }\\n       return true ;  \\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\tint parent[] ;\\n    int rank[] ;\\n  \\n   //Finding parent of the node\\n    int findParent(int node){\\n      if(node == parent[node]) return node ;\\n      return parent[node] = findParent(parent[node]) ;\\n    }\\n    \\n\\t//union find template\\n    void union(int u, int v){\\n      u = findParent(u) ;\\n      v = findParent(v) ;\\n      if(rank[u] > rank[v]){\\n        parent[v] = u ; \\n      }\\n      else if(rank[u] < rank[v]){\\n        parent[u] = v ;\\n      }\\n      else{\\n        parent[u] = v ;\\n        rank[v]++ ;\\n      }\\n    }\\n\\t\\n\\tpublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n       int inDeg[] = new int[n] ;\\n       int outDeg[] = new int[n] ;\\n         \\n      //Calculating in-degree and out-degree of all nodes\\n       for(int i=0 ; i<n ; i++){\\n         int u = leftChild[i] ;\\n         int v = rightChild[i] ;\\n         if(u!=-1){\\n           inDeg[u]++ ;\\n           outDeg[i]++;\\n         }\\n         if(v!=-1){\\n           inDeg[v]++;\\n           outDeg[i]++;\\n         }\\n       }\\n      \\n       //Now finding root from inDegree and outDegree arrays\\n       int root = -1 ;\\n       for(int i=0 ; i<n ; i++){\\n         //Condition for a node ..to be eligible for root\\n         if(inDeg[i] == 0 && outDeg[i] >= 0){\\n           if(root != -1) return false ;   //Checking if we already got our root or not \\n           root =  i ;\\n         }\\n         //Check if node have not more than 1 InDegree (Since in BT all nodes except root node, all have only one inDegree) \\n         if(inDeg[i] > 1) return false ;  \\n       }\\n        \\n       //If we did\\'nt found any root return false\\n       if(root == -1) return false ;\\n      \\n      \\n       //Appplying union find\\n       parent = new int[n] ;\\n       rank = new int[n] ;\\n      \\n       for(int i=0 ; i<n ; i++){\\n         parent[i] = i ;\\n         rank[i] = 1 ;\\n       }\\n        \\n       //intialize rank of root to infinity..as discussed above\\n       rank[root] = Integer.MAX_VALUE ;\\n       \\n       for(int i=0 ; i<n ; i++){\\n         int u = leftChild[i] ;\\n         int v = rightChild[i] ;\\n         if(u != -1){\\n           union(i,u) ;\\n         }\\n         if(v!=-1){\\n           union(i,v) ;\\n         }\\n       }\\n       \\n       //With help of union find we calculated parent of all nodes\\n       //Parent of all node should be root node for a graph to be binary tree \\n       for(int i=0 ; i<n ; i++){\\n         int u = leftChild[i] ;\\n         int v = rightChild[i] ;\\n         if(u != -1){\\n           u = findParent(u) ;\\n           if(u != root) return false ; \\n         }\\n         if(v != -1){\\n           v = findParent(v) ;\\n           if(v != root) return false ;\\n         }\\n       }\\n       return true ;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1273694,
                "title": "python-with-union-find-based-subset-tracking-and-cycle-detection",
                "content": "```\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        subsets = list(range(n))\\n\\n        def f(x):\\n            if subsets[x] != x:\\n                subsets[x] = f(subsets[x])\\n            return subsets[x]\\n\\n        def u(x,y):\\n            prev = subsets[x]\\n            subsets[x] = subsets[y]\\n        \\n        for i in range(n):\\n            parentSubset = f(i)\\n\\t\\t\\t# check for present children if they have already been discovered ( implying more than 1 parent ) or their subset is same as the parent (implying cycle)\\n            if leftChild[i] != -1:\\n                leftChildSubset = f(leftChild[i])\\n                if leftChildSubset == parentSubset or leftChildSubset != leftChild[i]:\\n                    return False\\n                u(leftChildSubset,parentSubset)\\n            if rightChild[i] != -1:\\n                rightChildSubset = f(rightChild[i])\\n                if rightChildSubset == parentSubset or rightChildSubset != rightChild[i]:\\n                    return False\\n                u(rightChildSubset,parentSubset)\\n                \\n        rootCount=0\\n        for i in range(n):\\n            if subsets[i] == i:\\n                rootCount += 1\\n        return True if rootCount == 1 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        \\n        subsets = list(range(n))\\n\\n        def f(x):\\n            if subsets[x] != x:\\n                subsets[x] = f(subsets[x])\\n            return subsets[x]\\n\\n        def u(x,y):\\n            prev = subsets[x]\\n            subsets[x] = subsets[y]\\n        \\n        for i in range(n):\\n            parentSubset = f(i)\\n\\t\\t\\t# check for present children if they have already been discovered ( implying more than 1 parent ) or their subset is same as the parent (implying cycle)\\n            if leftChild[i] != -1:\\n                leftChildSubset = f(leftChild[i])\\n                if leftChildSubset == parentSubset or leftChildSubset != leftChild[i]:\\n                    return False\\n                u(leftChildSubset,parentSubset)\\n            if rightChild[i] != -1:\\n                rightChildSubset = f(rightChild[i])\\n                if rightChildSubset == parentSubset or rightChildSubset != rightChild[i]:\\n                    return False\\n                u(rightChildSubset,parentSubset)\\n                \\n        rootCount=0\\n        for i in range(n):\\n            if subsets[i] == i:\\n                rootCount += 1\\n        return True if rootCount == 1 else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1215116,
                "title": "indegree-and-dfs-faster-than-99-c-soln",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int>left;\\n    vector<int>right;\\n    vector<int>visited;\\n    int n;\\n    bool dfs(int curr){\\n        if(curr==-1) return true;\\n        if(visited[curr]) return false;\\n        visited[curr] = true;\\n        bool res = dfs(left[curr])&&dfs(right[curr]);\\n        return res;\\n    }\\n    bool validateBinaryTreeNodes(int _n, vector<int>& leftChild, vector<int>& rightChild) {\\n        n = _n;\\n        left = leftChild;\\n        right = rightChild;\\n        visited.resize(n,false);\\n        vector<int>indegree(n+1,0);\\n        for(int i = 0;i<n;i++){\\n            if(left[i]!=-1){\\n                indegree[left[i]]++;\\n            }\\n            if(right[i]!=-1){\\n                indegree[right[i]]++;\\n            }\\n        }\\n        int c = 0;\\n        int root = -1;\\n        for(int i = 0;i<n;i++){\\n            if(indegree[i]==0){\\n                c++;\\n                root = i;\\n            }\\n        }\\n        if(c!=1) return false;\\n        int ans =  dfs(root);\\n        if(ans==false) return ans;\\n        for(int i = 0;i<n;i++){\\n            if(visited[i]==false) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int>left;\\n    vector<int>right;\\n    vector<int>visited;\\n    int n;\\n    bool dfs(int curr){\\n        if(curr==-1) return true;\\n        if(visited[curr]) return false;\\n        visited[curr] = true;\\n        bool res = dfs(left[curr])&&dfs(right[curr]);\\n        return res;\\n    }\\n    bool validateBinaryTreeNodes(int _n, vector<int>& leftChild, vector<int>& rightChild) {\\n        n = _n;\\n        left = leftChild;\\n        right = rightChild;\\n        visited.resize(n,false);\\n        vector<int>indegree(n+1,0);\\n        for(int i = 0;i<n;i++){\\n            if(left[i]!=-1){\\n                indegree[left[i]]++;\\n            }\\n            if(right[i]!=-1){\\n                indegree[right[i]]++;\\n            }\\n        }\\n        int c = 0;\\n        int root = -1;\\n        for(int i = 0;i<n;i++){\\n            if(indegree[i]==0){\\n                c++;\\n                root = i;\\n            }\\n        }\\n        if(c!=1) return false;\\n        int ans =  dfs(root);\\n        if(ans==false) return ans;\\n        for(int i = 0;i<n;i++){\\n            if(visited[i]==false) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174730,
                "title": "java-intuitive-solution-with-comments",
                "content": "The comments make it appear longer than it is. Pure code is actually pretty short.\\n\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        // If there\\'s only one node, make sure it has no children.\\n        if (n == 1) return leftChild[0] == -1 && rightChild[0] == -1;\\n        \\n        // Child node -> parent\\n        HashMap<Integer, Integer> nodeToParent = new HashMap<>();\\n        \\n        // Keep track of nodes without any children.\\n        List<Integer> childless = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            int l = leftChild[i];\\n            int r = rightChild[i];\\n            if (l != -1) {\\n                // If we\\'ve already set a parent for this node, the tree is invalid.\\n                // A node can only have a single parent.\\n                if (nodeToParent.containsKey(l)) return false;\\n                \\n                // If an immediate cycle (1 -> 2 and 2 -> 1) is detected, the tree is invalid.\\n                if (nodeToParent.containsKey(i) && nodeToParent.get(i) == l) return false;\\n                nodeToParent.put(l, i);\\n            }\\n            \\n            // Same logic as above, now for right children.\\n            if (r != -1) {\\n                if (nodeToParent.containsKey(r)) return false;\\n                if (nodeToParent.containsKey(i) && nodeToParent.get(i) == r) return false;\\n                nodeToParent.put(r, i);\\n            }\\n            \\n            if (l + r == -2) {\\n                // Found childless node.\\n                childless.add(i);\\n            }\\n        }\\n        \\n        // Only one orphan node (root) allowed. The orphan will not be in the nodeToParent map, since it\\n        // has no parents. We can determine this by comparing the map size with total # of nodes.\\n        if (nodeToParent.size() != n - 1) return false;\\n        \\n        // All childless nodes must be leaves of an existing graph, and cannot be isolated nodes. This takes\\n        // care of the edge case where we have a single isolated node disjointed from a valid binary tree.\\n        for (Integer c : childless) {\\n            if (!nodeToParent.containsKey(c)) return false;\\n        }\\n        \\n        // We\\'ve passed all our checks. Binary tree must be valid :)\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        // If there\\'s only one node, make sure it has no children.\\n        if (n == 1) return leftChild[0] == -1 && rightChild[0] == -1;\\n        \\n        // Child node -> parent\\n        HashMap<Integer, Integer> nodeToParent = new HashMap<>();\\n        \\n        // Keep track of nodes without any children.\\n        List<Integer> childless = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            int l = leftChild[i];\\n            int r = rightChild[i];\\n            if (l != -1) {\\n                // If we\\'ve already set a parent for this node, the tree is invalid.\\n                // A node can only have a single parent.\\n                if (nodeToParent.containsKey(l)) return false;\\n                \\n                // If an immediate cycle (1 -> 2 and 2 -> 1) is detected, the tree is invalid.\\n                if (nodeToParent.containsKey(i) && nodeToParent.get(i) == l) return false;\\n                nodeToParent.put(l, i);\\n            }\\n            \\n            // Same logic as above, now for right children.\\n            if (r != -1) {\\n                if (nodeToParent.containsKey(r)) return false;\\n                if (nodeToParent.containsKey(i) && nodeToParent.get(i) == r) return false;\\n                nodeToParent.put(r, i);\\n            }\\n            \\n            if (l + r == -2) {\\n                // Found childless node.\\n                childless.add(i);\\n            }\\n        }\\n        \\n        // Only one orphan node (root) allowed. The orphan will not be in the nodeToParent map, since it\\n        // has no parents. We can determine this by comparing the map size with total # of nodes.\\n        if (nodeToParent.size() != n - 1) return false;\\n        \\n        // All childless nodes must be leaves of an existing graph, and cannot be isolated nodes. This takes\\n        // care of the edge case where we have a single isolated node disjointed from a valid binary tree.\\n        for (Integer c : childless) {\\n            if (!nodeToParent.containsKey(c)) return false;\\n        }\\n        \\n        // We\\'ve passed all our checks. Binary tree must be valid :)\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074502,
                "title": "java-indegree-cycle-detection",
                "content": "```\\nclass Solution {\\n   private Set<Integer> visited = new HashSet();\\n    private Set<Integer> visiting = new HashSet<>();\\n    private int root;\\n    private Map<Integer, List<Integer>> graph = new HashMap();\\n    private boolean isCyclefound = false;\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] indegree = new int[n];\\n        boolean seen = false;\\n        for (int i = 0; i < leftChild.length; i++){\\n            int lchild = leftChild[i];\\n            int rchild = rightChild[i];\\n            if(lchild != -1){\\n                addEdge(i, lchild);\\n                indegree[lchild]++;\\n            }\\n            if(rchild != -1){\\n                addEdge(i, rchild);\\n                indegree[rchild]++;\\n            }\\n        }\\n\\n        //for only one binary tree to exist , only one node can have indegree as 0 and every other node should have only one parent so indegree =1\\n        for (int i = 0; i < n; i++){\\n            if(indegree[i] > 1) //node have two parents\\n                return false;\\n            if(indegree[i] == 0 && seen) //two roots\\n                return false;\\n            if(indegree[i] == 0 && !seen){\\n                root = i;\\n                seen = true;\\n            }\\n        }\\n        if(!seen) return false; //no root found\\n        dfs(root);\\n        return (! isCyclefound && visited.size() == n);\\n    }\\n\\n    private void addEdge(int i, int val) {\\n        List<Integer> edge = graph.getOrDefault(i, new ArrayList<>());\\n        edge.add(val);\\n        graph.put(i, edge);\\n    }\\n\\n    private void dfs(int root){\\n        visiting.add(root);\\n        if(graph.containsKey(root)){\\n            for (int adj : graph.get(root)){\\n                if(visiting.contains(adj)){\\n                    isCyclefound = true;\\n                    return;\\n                }\\n                dfs(adj);\\n            }\\n        }\\n        visiting.remove(root);\\n        visited.add(root);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   private Set<Integer> visited = new HashSet();\\n    private Set<Integer> visiting = new HashSet<>();\\n    private int root;\\n    private Map<Integer, List<Integer>> graph = new HashMap();\\n    private boolean isCyclefound = false;\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] indegree = new int[n];\\n        boolean seen = false;\\n        for (int i = 0; i < leftChild.length; i++){\\n            int lchild = leftChild[i];\\n            int rchild = rightChild[i];\\n            if(lchild != -1){\\n                addEdge(i, lchild);\\n                indegree[lchild]++;\\n            }\\n            if(rchild != -1){\\n                addEdge(i, rchild);\\n                indegree[rchild]++;\\n            }\\n        }\\n\\n        //for only one binary tree to exist , only one node can have indegree as 0 and every other node should have only one parent so indegree =1\\n        for (int i = 0; i < n; i++){\\n            if(indegree[i] > 1) //node have two parents\\n                return false;\\n            if(indegree[i] == 0 && seen) //two roots\\n                return false;\\n            if(indegree[i] == 0 && !seen){\\n                root = i;\\n                seen = true;\\n            }\\n        }\\n        if(!seen) return false; //no root found\\n        dfs(root);\\n        return (! isCyclefound && visited.size() == n);\\n    }\\n\\n    private void addEdge(int i, int val) {\\n        List<Integer> edge = graph.getOrDefault(i, new ArrayList<>());\\n        edge.add(val);\\n        graph.put(i, edge);\\n    }\\n\\n    private void dfs(int root){\\n        visiting.add(root);\\n        if(graph.containsKey(root)){\\n            for (int adj : graph.get(root)){\\n                if(visiting.contains(adj)){\\n                    isCyclefound = true;\\n                    return;\\n                }\\n                dfs(adj);\\n            }\\n        }\\n        visiting.remove(root);\\n        visited.add(root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016738,
                "title": "c-iterative-solution-o-n-time",
                "content": "```\\n// for it to be a valid tree, we need:\\n// - exactly one node with 0 visitors and at least one child\\n// - all other nodes with exactly 1 visitors\\n// - all nodes reachable from root node\\n\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        if (n == 1)\\n            return true;\\n\\n        // count node visits\\n        vector<bool> visited(n);\\n        for (int i = 0; i < n; i++) {\\n            int l = leftChild[i];\\n            int r = rightChild[i];\\n            if (l >= 0) {\\n                // detect cycles\\n                if (visited[l])\\n                    return false;\\n                visited[l] = true;\\n            }\\n            if (r >= 0) {\\n                // detect cycles\\n                if (visited[r])\\n                    return false;                \\n                visited[r] = true;\\n            }\\n        }\\n        \\n        // there must exactly be one node without visitors with at least one child\\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                if (root >= 0 || (leftChild[i] == -1 && rightChild[i] == -1))\\n                    return false;\\n                root = i;\\n            }\\n        }\\n\\n        // check we can reach all nodes\\n        if (root >= 0) {\\n            unordered_set<int> children;\\n            stack<int> nodes;\\n            nodes.push(root);\\n            while (!nodes.empty()) {\\n                int node = nodes.top();\\n                nodes.pop();\\n                children.insert(node);\\n                if (leftChild[node] >= 0) nodes.push(leftChild[node]);\\n                if (rightChild[node] >= 0) nodes.push(rightChild[node]);\\n            }\\n            return children.size() == n;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// for it to be a valid tree, we need:\\n// - exactly one node with 0 visitors and at least one child\\n// - all other nodes with exactly 1 visitors\\n// - all nodes reachable from root node\\n\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        if (n == 1)\\n            return true;\\n\\n        // count node visits\\n        vector<bool> visited(n);\\n        for (int i = 0; i < n; i++) {\\n            int l = leftChild[i];\\n            int r = rightChild[i];\\n            if (l >= 0) {\\n                // detect cycles\\n                if (visited[l])\\n                    return false;\\n                visited[l] = true;\\n            }\\n            if (r >= 0) {\\n                // detect cycles\\n                if (visited[r])\\n                    return false;                \\n                visited[r] = true;\\n            }\\n        }\\n        \\n        // there must exactly be one node without visitors with at least one child\\n        int root = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                if (root >= 0 || (leftChild[i] == -1 && rightChild[i] == -1))\\n                    return false;\\n                root = i;\\n            }\\n        }\\n\\n        // check we can reach all nodes\\n        if (root >= 0) {\\n            unordered_set<int> children;\\n            stack<int> nodes;\\n            nodes.push(root);\\n            while (!nodes.empty()) {\\n                int node = nodes.top();\\n                nodes.pop();\\n                children.insert(node);\\n                if (leftChild[node] >= 0) nodes.push(leftChild[node]);\\n                if (rightChild[node] >= 0) nodes.push(rightChild[node]);\\n            }\\n            return children.size() == n;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945645,
                "title": "java-solution-union-find",
                "content": "```\\n// A valid tree must have nodes with only one parent and exactly one node with no parent.\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] p = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            p[i] = i;\\n        }\\n        int[] np = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                union(p, i, leftChild[i]);\\n                np[leftChild[i]]++;\\n            }\\n            if (rightChild[i] != -1) {\\n                union(p, i, rightChild[i]);\\n                np[rightChild[i]]++;\\n            }\\n        }\\n        int noP = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (np[i] == 0) {\\n                noP++;\\n            }\\n            if (noP > 1 || np[i] > 1) {\\n                return false;\\n            }\\n        }\\n        int groups = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (p[i] == i) {\\n                groups++;\\n            }\\n        }\\n        return noP == 1 && groups == 1;\\n    }\\n    \\n    public void union(int[] p, int a, int b) {\\n        int pa = find(p, a);\\n        int pb = find(p, b);\\n        if (pa == pb) {\\n            return;\\n        }\\n        p[pa] = pb;\\n    }\\n    \\n    public int find(int[] p, int a) {\\n        if (p[a] == a) {\\n            return a;\\n        }\\n        return p[a] = find(p, p[a]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// A valid tree must have nodes with only one parent and exactly one node with no parent.\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] p = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            p[i] = i;\\n        }\\n        int[] np = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) {\\n                union(p, i, leftChild[i]);\\n                np[leftChild[i]]++;\\n            }\\n            if (rightChild[i] != -1) {\\n                union(p, i, rightChild[i]);\\n                np[rightChild[i]]++;\\n            }\\n        }\\n        int noP = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (np[i] == 0) {\\n                noP++;\\n            }\\n            if (noP > 1 || np[i] > 1) {\\n                return false;\\n            }\\n        }\\n        int groups = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (p[i] == i) {\\n                groups++;\\n            }\\n        }\\n        return noP == 1 && groups == 1;\\n    }\\n    \\n    public void union(int[] p, int a, int b) {\\n        int pa = find(p, a);\\n        int pb = find(p, b);\\n        if (pa == pb) {\\n            return;\\n        }\\n        p[pa] = pb;\\n    }\\n    \\n    public int find(int[] p, int a) {\\n        if (p[a] == a) {\\n            return a;\\n        }\\n        return p[a] = find(p, p[a]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903952,
                "title": "finding-root-through-the-sum-with-o-1-space",
                "content": "I have been struggling with finding root for a while. Finally I thought of using sum of algebraic progression to verify.\\nSay we have array from 0 to n-1 integers. Its sum will be n * (n -1 )//2. If one int is missing, that would be the root.\\n\\nAs step 1 lets find it:\\n```\\n        leftSum = 0\\n        rightSum = 0\\n        for x in leftChild:\\n            if x >=0:leftSum +=x\\n        for x in rightChild:\\n            if x >= 0:rightSum +=x\\n\\n```\\nAs you see, O(n) time, O(1) space.\\nNow we need to check for false positives. \\n* What if every number is present in the array? \\n\\t* in this case leftSum + rightSum == n * (n -1 )//2; Just check if 0 is root or not:\\n```if 0 in leftChild or 0` in rightChild: return False```\\n* what if some numbers are duplicated?\\n\\t* ``` if leftSum + rightSum > n * (n -1 )//2 : return False ```\\n*  what if we got coincidence and more than one number was missing? In that case the rootIndex will be set in either left child or right child:\\n\\t*  ```if rootIndex in leftChild or rootIndex in rightChild: return False```\\n*  what if 2 numbers were missing and one of them is 0?\\n\\t*  In that case, if 0 is missing from the children arrays but the total missing value is not 0, return false:\\n\\t*  ```if 0 not in leftChild and 0 not in rightChild: return False```\\n\\nJust wanted to share the approach. \\n\\n\\t\\t\\n\\n",
                "solutionTags": [],
                "code": "```\\n        leftSum = 0\\n        rightSum = 0\\n        for x in leftChild:\\n            if x >=0:leftSum +=x\\n        for x in rightChild:\\n            if x >= 0:rightSum +=x\\n\\n```\n```if 0 in leftChild or 0` in rightChild: return False```\n``` if leftSum + rightSum > n * (n -1 )//2 : return False ```\n```if rootIndex in leftChild or rootIndex in rightChild: return False```\n```if 0 not in leftChild and 0 not in rightChild: return False```",
                "codeTag": "Unknown"
            },
            {
                "id": 900613,
                "title": "c-solution-with-comments-feel-free-to-ask-any-doubts",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n         vector <int> indeg(n + 1 , 0) , outdeg(n + 1 , 0) , par(n + 1 , -1);\\n         map<pair<int, int> , int> mp;\\n        \\n         for(int i = 0 ; i < n ; i++){\\n             int flag = rightChild[i] , temp = leftChild[i];\\n             if(leftChild[i] != -1){\\n                 indeg[leftChild[i]]++ , outdeg[i]++;\\n                 \\n                 // if A --> B exists then B --> A should not exist\\n                 \\n                 if(mp[{temp , i}])\\n                    return 0;\\n                 }\\n                 mp[{i , temp}]++;\\n             }\\n             \\n             if(rightChild[i] != -1){\\n                 indeg[rightChild[i]]++ , outdeg[i]++;\\n                            \\n                 // if A --> B exists then B --> A should not exist \\n                 if(mp[{flag , i}])\\n                    return 0;\\n                 \\n                 mp[{i , flag}]++;\\n             }\\n         }\\n\\n         int foo = 0;\\n        \\n         for(int i = 0;  i < n ; i++){\\n          \\n             // Conditions for being a binary tree\\n             if(outdeg[i] > 2 or indeg[i] > 1 or foo > 1){\\n                return 0;\\n             } \\n             \\n             // There should only be one element which has 0 out degree but if n > 1 then it should also have either of its child\\n             // else for n > 1 no of components will be more than 1\\n             if((!indeg[i] and (leftChild[i] != -1 or rightChild[i] != -1)))\\n                 foo++;\\n             \\n         }\\n        \\n         return (foo ? 1 : (n == 1 ? 1 : 0));\\n         \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n         vector <int> indeg(n + 1 , 0) , outdeg(n + 1 , 0) , par(n + 1 , -1);\\n         map<pair<int, int> , int> mp;\\n        \\n         for(int i = 0 ; i < n ; i++){\\n             int flag = rightChild[i] , temp = leftChild[i];\\n             if(leftChild[i] != -1){\\n                 indeg[leftChild[i]]++ , outdeg[i]++;\\n                 \\n                 // if A --> B exists then B --> A should not exist\\n                 \\n                 if(mp[{temp , i}",
                "codeTag": "Java"
            },
            {
                "id": 886023,
                "title": "1ms-java-with-details-comments",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n       int[] map = new int[n];\\n        Arrays.fill(map, -1);\\n        // child -> parent map\\n        for(int i=0; i<n;i++) {\\n            int left = leftChild[i];\\n            if(left != -1) {\\n                // child can\\'t have more than 1 parent\\n                if(map[left]!= -1) return false;\\n                map[left] = i;\\n            }\\n            int right = rightChild[i];\\n            if(right != -1) {\\n                if(map[right]!= -1) return false;\\n                map[right] = i;\\n            }\\n        }\\n        \\n        //can\\'t have  cycle\\n        int initial = -1;\\n        for(int i=0;i<n;i++) {\\n            if(map[i] != -1) {\\n                initial = map[i];\\n                break;\\n            }\\n        }\\n        int cur = initial;\\n        while(cur != -1) {\\n            int next = map[cur];\\n            if(next == initial) return false;\\n            cur = next;\\n        }\\n        \\n        // only one node has not parent\\n        int np = 0;\\n        for(int i =0; i< n;i++) {\\n            if(map[i]==-1) np++;\\n        }\\n        return np == 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n       int[] map = new int[n];\\n        Arrays.fill(map, -1);\\n        // child -> parent map\\n        for(int i=0; i<n;i++) {\\n            int left = leftChild[i];\\n            if(left != -1) {\\n                // child can\\'t have more than 1 parent\\n                if(map[left]!= -1) return false;\\n                map[left] = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 871614,
                "title": "python-parent-index-bfs-faster-than-99-5-easy-to-understand",
                "content": "```\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        # Find the parent index for each node\\n        parent = [-1] * n\\n        for i in range(n):\\n            l, r = leftChild[i], rightChild[i]\\n            if l >= 0:\\n                if parent[l] == -1:\\n                    parent[l] = i\\n                else:\\n                    return False  # Duplicate parent\\n            if r >= 0:\\n                if parent[r] == -1:\\n                    parent[r] = i\\n                else: \\n                    return False  # Duplicate parent\\n        \\n        # Check exactly one binary tree (only one root) or existing loop (no root)\\n        roots = [i for i in range(n) if parent[i] == -1]\\n        if len(roots) != 1:\\n            return False\\n        \\n        # Check loop via BFS (considering that one loop and a single node)\\n        q = [roots[0]]\\n        seen = [-1] * n\\n        seen[roots[0]] = 1\\n        while q:\\n            node = q.pop(0)\\n            l, r = leftChild[node], rightChild[node]\\n            if l >= 0:\\n                if seen[l] == 1:\\n                    return False\\n                q.append(l)\\n                seen[l] = 1\\n            if r >= 0:\\n                if seen[r] == 1:\\n                    return False\\n                q.append(r)\\n                seen[r] = 1\\n        return True if sum(seen) == n else False\\n```",
                "solutionTags": [],
                "code": "```\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        # Find the parent index for each node\\n        parent = [-1] * n\\n        for i in range(n):\\n            l, r = leftChild[i], rightChild[i]\\n            if l >= 0:\\n                if parent[l] == -1:\\n                    parent[l] = i\\n                else:\\n                    return False  # Duplicate parent\\n            if r >= 0:\\n                if parent[r] == -1:\\n                    parent[r] = i\\n                else: \\n                    return False  # Duplicate parent\\n        \\n        # Check exactly one binary tree (only one root) or existing loop (no root)\\n        roots = [i for i in range(n) if parent[i] == -1]\\n        if len(roots) != 1:\\n            return False\\n        \\n        # Check loop via BFS (considering that one loop and a single node)\\n        q = [roots[0]]\\n        seen = [-1] * n\\n        seen[roots[0]] = 1\\n        while q:\\n            node = q.pop(0)\\n            l, r = leftChild[node], rightChild[node]\\n            if l >= 0:\\n                if seen[l] == 1:\\n                    return False\\n                q.append(l)\\n                seen[l] = 1\\n            if r >= 0:\\n                if seen[r] == 1:\\n                    return False\\n                q.append(r)\\n                seen[r] = 1\\n        return True if sum(seen) == n else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 836033,
                "title": "checking-whether-graph-is-connected-and-acyclic-or-not-used-bfs-for-traversal",
                "content": "I simply created an undirected graph and checked whether a graph formed is Connected and  Acyclic or not. Because a graph is binary tree one and only if it is connected and Acyclic. Here I am assuming 0 as root node.\\nHere is my code\\n```\\nclass Solution {\\n    HashMap<Integer,ArrayList<Integer>>graph  = new HashMap<>();\\n\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        for(int i=0;i<n;i++)graph.put(i,new ArrayList<>());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int left = leftChild[i];\\n            int right = rightChild[i];\\n            \\n            if(left!=-1)\\n            {\\n                //making Undirected graph\\n                graph.get(i).add(left);\\n                graph.get(left).add(i);\\n            }\\n            if(right!=-1)\\n            {\\n                //making Undirected graph\\n                graph.get(i).add(right);\\n                graph.get(right).add(i);\\n                \\n            }\\n        }\\n    \\n        \\n        //now check cycle in undirected graph,starting from 0, it will automatically the case of connected and       \\n\\t\\t//disconnected graph\\n       return isValidBT(n);\\n        \\n       \\n    }\\n    \\n    //check whether acyclic and connected or not\\n    private boolean isValidBT(int n)\\n    {\\n        boolean isCycle = false; //assuming that there is no cycle\\n        HashMap<Integer, Boolean>processed = new HashMap<>();\\n        Queue<Integer>queue = new LinkedList<>();\\n        queue.add(0);\\n        \\n        while(!queue.isEmpty())\\n        {\\n            int val = queue.poll();\\n            \\n            if(processed.containsKey(val))\\n            {\\n                //then cycle available, not a valid Binary tree\\n                return false;\\n            }\\n            \\n            processed.put(val,true);\\n            \\n            for(int child:graph.get(val))\\n            {\\n                if(!processed.containsKey(child))\\n                {\\n                    queue.add(child);\\n                }\\n            }\\n        }\\n\\t\\t//Now check whether it is connected graph or not\\n        boolean isConnected = true;//assuming that graph is connected\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!processed.containsKey(i))\\n            {\\n                //then disconnected graph, return false\\n                return false;\\n                \\n            }\\n        }\\n        \\n        \\n        if(isConnected==true && isCycle==false)\\n        {\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n      \\n}  \\n   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,ArrayList<Integer>>graph  = new HashMap<>();\\n\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        for(int i=0;i<n;i++)graph.put(i,new ArrayList<>());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int left = leftChild[i];\\n            int right = rightChild[i];\\n            \\n            if(left!=-1)\\n            {\\n                //making Undirected graph\\n                graph.get(i).add(left);\\n                graph.get(left).add(i);\\n            }\\n            if(right!=-1)\\n            {\\n                //making Undirected graph\\n                graph.get(i).add(right);\\n                graph.get(right).add(i);\\n                \\n            }\\n        }\\n    \\n        \\n        //now check cycle in undirected graph,starting from 0, it will automatically the case of connected and       \\n\\t\\t//disconnected graph\\n       return isValidBT(n);\\n        \\n       \\n    }\\n    \\n    //check whether acyclic and connected or not\\n    private boolean isValidBT(int n)\\n    {\\n        boolean isCycle = false; //assuming that there is no cycle\\n        HashMap<Integer, Boolean>processed = new HashMap<>();\\n        Queue<Integer>queue = new LinkedList<>();\\n        queue.add(0);\\n        \\n        while(!queue.isEmpty())\\n        {\\n            int val = queue.poll();\\n            \\n            if(processed.containsKey(val))\\n            {\\n                //then cycle available, not a valid Binary tree\\n                return false;\\n            }\\n            \\n            processed.put(val,true);\\n            \\n            for(int child:graph.get(val))\\n            {\\n                if(!processed.containsKey(child))\\n                {\\n                    queue.add(child);\\n                }\\n            }\\n        }\\n\\t\\t//Now check whether it is connected graph or not\\n        boolean isConnected = true;//assuming that graph is connected\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!processed.containsKey(i))\\n            {\\n                //then disconnected graph, return false\\n                return false;\\n                \\n            }\\n        }\\n        \\n        \\n        if(isConnected==true && isCycle==false)\\n        {\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n      \\n}  \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 815091,
                "title": "java-using-dsu",
                "content": "idea behind the dsu-> as initially all are separated with n groups and we have to merge them and then decrease the numbers of set\\nif any one of child is in the same set as of the parent then there is a cycle and directly return false ;\\nand at the end check whether number of set remaining is only 1 or more.\\nif(no>1) return false else return true;\\nCODE--------------------------------------------------------------------------------------------------------->\\nstatic int[] par;\\n    public boolean validateBinaryTreeNodes(int n, int[] left, int[] right) {\\n        par=new int[n];// define the parent\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n        }\\n        int set=n;\\n        for(int i=0;i<n;i++){\\n\\n\\t\\t int p1=find(i,par);\\n\\t\\tint p2=left[i]==-1?-1:find(left[i],par);// parent of the set of left child\\n\\t\\tint p3=right[i]==-1?-1:find(right[i],par); // parent of set of right child\\n\\t\\tif(p2!=-1 && p1!=p2){\\n\\t\\t\\tpar[p2]=p1;\\n\\t\\t\\t// par[p3]=p1;\\n\\t\\t\\tset-=1;\\n\\t\\t}else if(p1==p2){// if current set parent is equal to left child set parent --->cycle\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif(p3!=-1 && p1!=p3){// if current set parent is equal to right child set parent --->cycle\\n\\t\\t\\tpar[p3]=p1;\\n\\t\\t\\tset-=1;\\n\\t\\t}else if(p1==p3){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n        return set==1;     // at end if there is only 1 child is present \\n    }\\n    public int find(int i,int[] par){\\n        if(par[i]==i){\\n            return i;\\n        }\\n        return par[i]=find(par[i],par);\\n    }",
                "solutionTags": [],
                "code": "idea behind the dsu-> as initially all are separated with n groups and we have to merge them and then decrease the numbers of set\\nif any one of child is in the same set as of the parent then there is a cycle and directly return false ;\\nand at the end check whether number of set remaining is only 1 or more.\\nif(no>1) return false else return true;\\nCODE--------------------------------------------------------------------------------------------------------->\\nstatic int[] par;\\n    public boolean validateBinaryTreeNodes(int n, int[] left, int[] right) {\\n        par=new int[n];// define the parent\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n        }\\n        int set=n;\\n        for(int i=0;i<n;i++){\\n\\n\\t\\t int p1=find(i,par);\\n\\t\\tint p2=left[i]==-1?-1:find(left[i],par);// parent of the set of left child\\n\\t\\tint p3=right[i]==-1?-1:find(right[i],par); // parent of set of right child\\n\\t\\tif(p2!=-1 && p1!=p2){\\n\\t\\t\\tpar[p2]=p1;\\n\\t\\t\\t// par[p3]=p1;\\n\\t\\t\\tset-=1;\\n\\t\\t}else if(p1==p2){// if current set parent is equal to left child set parent --->cycle\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif(p3!=-1 && p1!=p3){// if current set parent is equal to right child set parent --->cycle\\n\\t\\t\\tpar[p3]=p1;\\n\\t\\t\\tset-=1;\\n\\t\\t}else if(p1==p3){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n        return set==1;     // at end if there is only 1 child is present \\n    }\\n    public int find(int i,int[] par){\\n        if(par[i]==i){\\n            return i;\\n        }\\n        return par[i]=find(par[i],par);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 813114,
                "title": "python-simple-easy-to-understand-high-performant-solution",
                "content": "per each i th node of given two arrays, leftChild and rightChild.\\nnode i has left child, leftChild[i], and right child, rightChild[i].\\n\\nThe solution checks for the following conditions.\\n1. there is only one strongly connected graph\\n2. there is no circuit. \\n3. all nodes are included in the found graph\\n\\nthe solution creates a set and adds a new node only if the i th node is already in the set.\\nThis checks if the i th node is a child in the graph. However, we have to take care of the case when i th node become a new root of the graph. This can happen when i th node is not part of the graph, but its child node is. In such case, the solution adds the node.\\nCircuit exists if there is a back edge. This happens when both source node and target node exist in the set.\\n\\nFinally, solution check if the size of the set equal to n to check that all nodes are included in the graph.\\n```\\nclass Solution(object):\\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\\n        \"\"\"\\n        :type n: int\\n        :type leftChild: List[int]\\n        :type rightChild: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        children = set()\\n        children.add(0)\\n        for i in xrange(len(leftChild)):\\n            l = [leftChild[i], rightChild[i]]\\n            \\n            for c in l:\\n                if c != -1:\\n                    if i in children:\\n                        if c in children:\\n                            return False\\n                        else:\\n                            children.add(c)\\n                    else:\\n                        if c in children:\\n                            children.add(i)\\n                        else:\\n                            return False\\n                \\n        \\n        \\n        return len(children) == n",
                "solutionTags": [],
                "code": "per each i th node of given two arrays, leftChild and rightChild.\\nnode i has left child, leftChild[i], and right child, rightChild[i].\\n\\nThe solution checks for the following conditions.\\n1. there is only one strongly connected graph\\n2. there is no circuit. \\n3. all nodes are included in the found graph\\n\\nthe solution creates a set and adds a new node only if the i th node is already in the set.\\nThis checks if the i th node is a child in the graph. However, we have to take care of the case when i th node become a new root of the graph. This can happen when i th node is not part of the graph, but its child node is. In such case, the solution adds the node.\\nCircuit exists if there is a back edge. This happens when both source node and target node exist in the set.\\n\\nFinally, solution check if the size of the set equal to n to check that all nodes are included in the graph.\\n```\\nclass Solution(object):\\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\\n        \"\"\"\\n        :type n: int\\n        :type leftChild: List[int]\\n        :type rightChild: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        children = set()\\n        children.add(0)\\n        for i in xrange(len(leftChild)):\\n            l = [leftChild[i], rightChild[i]]\\n            \\n            for c in l:\\n                if c != -1:\\n                    if i in children:\\n                        if c in children:\\n                            return False\\n                        else:\\n                            children.add(c)\\n                    else:\\n                        if c in children:\\n                            children.add(i)\\n                        else:\\n                            return False\\n                \\n        \\n        \\n        return len(children) == n",
                "codeTag": "Java"
            },
            {
                "id": 803101,
                "title": "c-union-find-and-parent-count",
                "content": "```\\npublic class Solution {\\n    public bool ValidateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        int[] connections = new int[n];\\n        for(int i = 0; i < n; i++)\\n            connections[i] = i;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(leftChild[i] != -1)\\n            {\\n                if(hasCycle(connections, i, leftChild[i]))\\n                    return false;\\n            }\\n            \\n            if(rightChild[i] != -1)\\n            {\\n                if(hasCycle(connections, i, rightChild[i]))\\n                    return false;\\n            }\\n        }        \\n        \\n        int parents = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(connections[i] == i)\\n                parents++;\\n        }\\n        \\n        return parents == 1;\\n    }\\n    \\n    private bool hasCycle(int[] connections, int u, int v)\\n    {\\n        while(connections[u] != u)\\n        {\\n            u = connections[u];\\n        }\\n        while(connections[v] != v)\\n        {\\n            v = connections[v];\\n        }\\n\\n        if(u == v)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            connections[u] = v;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ValidateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        int[] connections = new int[n];\\n        for(int i = 0; i < n; i++)\\n            connections[i] = i;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(leftChild[i] != -1)\\n            {\\n                if(hasCycle(connections, i, leftChild[i]))\\n                    return false;\\n            }\\n            \\n            if(rightChild[i] != -1)\\n            {\\n                if(hasCycle(connections, i, rightChild[i]))\\n                    return false;\\n            }\\n        }        \\n        \\n        int parents = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(connections[i] == i)\\n                parents++;\\n        }\\n        \\n        return parents == 1;\\n    }\\n    \\n    private bool hasCycle(int[] connections, int u, int v)\\n    {\\n        while(connections[u] != u)\\n        {\\n            u = connections[u];\\n        }\\n        while(connections[v] != v)\\n        {\\n            v = connections[v];\\n        }\\n\\n        if(u == v)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            connections[u] = v;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800617,
                "title": "java-union-find-with-simple-explaination",
                "content": "Surprisingly only later I found that many ppl created answers assuming 0 can be the root.\\nAnways this soln doesnt make this assumptions.\\n\\nthe idea is simple the only invalid trees are:\\n1. the parent and prospect child are part of same root\\'s tree ie this would lead to a cycle\\n2. there are more than 1 valid roots present ie more than 1 tree\\n\\nBoth the above can be solved using union find:\\n* union the non -1 child with parent hence making it part of tree\\n* before adding a child make sure you check if the roots arent same\\n* count the parents in the end\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        DSU dsu = new DSU(n);\\n        for(int i=0;i<leftChild.length;i++){\\n            if((leftChild[i]!=-1&&dsu.find(leftChild[i])==dsu.find(i))||(rightChild[i]!=-1&&dsu.find(rightChild[i])==dsu.find(i)))\\n               return false;\\n            \\n            if(leftChild[i]!=-1)\\n                dsu.union(leftChild[i],i);\\n            if(rightChild[i]!=-1)\\n                dsu.union(rightChild[i],i);\\n        }\\n        int ct =0;\\n        for(int i=0;i<n;i++){\\n            if(dsu.find(i)==i)\\n                ct++;\\n        }\\n        return ct==1?true:false;\\n    }\\n    public class DSU{\\n        int[] parent;\\n        public DSU(int n){\\n            parent = new int[n];\\n            for(int i=0;i<n;i++)\\n                parent[i]=i;\\n        }\\n        public void union(int a,int b){\\n            parent[find(a)]=find(b);\\n        }\\n        public int find(int a) {\\n            if(parent[a]==a)return a;\\n            return find(parent[a]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        DSU dsu = new DSU(n);\\n        for(int i=0;i<leftChild.length;i++){\\n            if((leftChild[i]!=-1&&dsu.find(leftChild[i])==dsu.find(i))||(rightChild[i]!=-1&&dsu.find(rightChild[i])==dsu.find(i)))\\n               return false;\\n            \\n            if(leftChild[i]!=-1)\\n                dsu.union(leftChild[i],i);\\n            if(rightChild[i]!=-1)\\n                dsu.union(rightChild[i],i);\\n        }\\n        int ct =0;\\n        for(int i=0;i<n;i++){\\n            if(dsu.find(i)==i)\\n                ct++;\\n        }\\n        return ct==1?true:false;\\n    }\\n    public class DSU{\\n        int[] parent;\\n        public DSU(int n){\\n            parent = new int[n];\\n            for(int i=0;i<n;i++)\\n                parent[i]=i;\\n        }\\n        public void union(int a,int b){\\n            parent[find(a)]=find(b);\\n        }\\n        public int find(int a) {\\n            if(parent[a]==a)return a;\\n            return find(parent[a]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784747,
                "title": "simple-python-o-n-recursive-with-2-sets",
                "content": "```\\nclass Solution(object):\\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\\n        visited = set()\\n        roots = set()\\n        \\n        def visitChildren(node):\\n            if node == -1: return True\\n            if node in roots: \\n                roots.remove(node)\\n                return True\\n            if node in visited: return False\\n            visited.add(node)\\n                \\n            return (visitChildren(leftChild[node]) and visitChildren(rightChild[node]))\\n        \\n        for node in range(n):\\n            if node not in visited:\\n                if not visitChildren(node):\\n                    return False\\n                roots.add(node)\\n                \\n        return (len(roots) == 1)\\n        \"\"\"\\n        :type n: int\\n        :type leftChild: List[int]\\n        :type rightChild: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\\n        visited = set()\\n        roots = set()\\n        \\n        def visitChildren(node):\\n            if node == -1: return True\\n            if node in roots: \\n                roots.remove(node)\\n                return True\\n            if node in visited: return False\\n            visited.add(node)\\n                \\n            return (visitChildren(leftChild[node]) and visitChildren(rightChild[node]))\\n        \\n        for node in range(n):\\n            if node not in visited:\\n                if not visitChildren(node):\\n                    return False\\n                roots.add(node)\\n                \\n        return (len(roots) == 1)\\n        \"\"\"\\n        :type n: int\\n        :type leftChild: List[int]\\n        :type rightChild: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 735593,
                "title": "easy-and-intuitive-dsu-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>pa;\\n    int find(int x)\\n    {\\n        if(pa[x]==-1) return x;\\n        return pa[x]=find(pa[x]);\\n    }\\n    bool flag=true;\\n    void merge(int x,int y)\\n    {\\n        int a=find(x);\\n        int b=find(y);\\n        if(a==b)\\n        {\\n            flag=false;\\n        }\\n        pa[a]=b;\\n        return;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) \\n    {\\n        pa.resize(n,-1);\\n        for(int i=0;i<l.size();i++)\\n        {\\n            if(i==l[i]) return false;\\n            if(l[i]!=-1)merge(i,l[i]);\\n            if(!flag)\\n            {\\n                return flag;\\n            }\\n        }\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            if(i==r[i]) return false;\\n            if(r[i]!=-1)merge(i,r[i]);\\n            if(!flag)\\n            {\\n                return flag;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0;i<pa.size();i++)\\n        {\\n            if(pa[i]==-1) ct++;\\n        }\\n        if(ct>1) return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>pa;\\n    int find(int x)\\n    {\\n        if(pa[x]==-1) return x;\\n        return pa[x]=find(pa[x]);\\n    }\\n    bool flag=true;\\n    void merge(int x,int y)\\n    {\\n        int a=find(x);\\n        int b=find(y);\\n        if(a==b)\\n        {\\n            flag=false;\\n        }\\n        pa[a]=b;\\n        return;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& l, vector<int>& r) \\n    {\\n        pa.resize(n,-1);\\n        for(int i=0;i<l.size();i++)\\n        {\\n            if(i==l[i]) return false;\\n            if(l[i]!=-1)merge(i,l[i]);\\n            if(!flag)\\n            {\\n                return flag;\\n            }\\n        }\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            if(i==r[i]) return false;\\n            if(r[i]!=-1)merge(i,r[i]);\\n            if(!flag)\\n            {\\n                return flag;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0;i<pa.size();i++)\\n        {\\n            if(pa[i]==-1) ct++;\\n        }\\n        if(ct>1) return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724869,
                "title": "clean-java-solution-works-for-all-test-cases",
                "content": "I have taken a bit different approach than the graph traversal. The following solution has comments to explain the logic. Please comment on this post if you have any suggestions on the same.\\n\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        HashMap<Integer, Integer> indegree = new HashMap();\\n        HashSet<Integer> roots = new HashSet();\\n        for(int i=0;i<n;i++) roots.add(i);\\n        \\n        //First, we check whether any node has a indegree > 1\\n        //if we find such a node, then return false\\n\\t\\t//Also, we remove the nodes with a indegree from the root set\\n        for(int lc: leftChild){\\n            if(lc>=0){\\n                indegree.put(lc, indegree.getOrDefault(lc,0)+1);\\n                if(indegree.get(lc)>1) return false;\\n                roots.remove(lc);\\n            }\\n        }\\n        \\n        for(int rc: rightChild){\\n            if(rc>=0){\\n                indegree.put(rc, indegree.getOrDefault(rc,0)+1);\\n                if(indegree.get(rc)>1) return false;\\n                roots.remove(rc);\\n            }\\n        }\\n            \\n        int root = -1;\\n        for(int r:roots) root = r;\\n        \\n        //If the no of roots is 0, that means some node is pointing to the root node as well, which is invalid\\n        //If the no of roots is more than 1, then we have disjoint trees, which is invalid\\n        //If no of roots is 1, and if the left child and right child of that root is -1, then that root node is a disjoint node\\n        //For special case like n=1, [-1], [-1], we need to exclude it from this check, hence n>1 condition\\n        if(roots.size()!=1 || (leftChild[root]==-1 && rightChild[root]==-1 && n>1)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        HashMap<Integer, Integer> indegree = new HashMap();\\n        HashSet<Integer> roots = new HashSet();\\n        for(int i=0;i<n;i++) roots.add(i);\\n        \\n        //First, we check whether any node has a indegree > 1\\n        //if we find such a node, then return false\\n\\t\\t//Also, we remove the nodes with a indegree from the root set\\n        for(int lc: leftChild){\\n            if(lc>=0){\\n                indegree.put(lc, indegree.getOrDefault(lc,0)+1);\\n                if(indegree.get(lc)>1) return false;\\n                roots.remove(lc);\\n            }\\n        }\\n        \\n        for(int rc: rightChild){\\n            if(rc>=0){\\n                indegree.put(rc, indegree.getOrDefault(rc,0)+1);\\n                if(indegree.get(rc)>1) return false;\\n                roots.remove(rc);\\n            }\\n        }\\n            \\n        int root = -1;\\n        for(int r:roots) root = r;\\n        \\n        //If the no of roots is 0, that means some node is pointing to the root node as well, which is invalid\\n        //If the no of roots is more than 1, then we have disjoint trees, which is invalid\\n        //If no of roots is 1, and if the left child and right child of that root is -1, then that root node is a disjoint node\\n        //For special case like n=1, [-1], [-1], we need to exclude it from this check, hence n>1 condition\\n        if(roots.size()!=1 || (leftChild[root]==-1 && rightChild[root]==-1 && n>1)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717617,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        if(n==1){return true;} //if single node surely true.\\n        vector<int> totalNodes(n, 1); //Keeps track of visited nodes. If not visited its set to 1.\\n        for(int i=0; i<leftChild.size(); i++){\\n            if(leftChild[i] != -1){ //Check if child present for the node.\\n                if(!totalNodes[leftChild[i]]){ //If already visited child then that would lead to a loop.\\n                    return false;\\n                } \\n                totalNodes[leftChild[i]] = 0; //When visited set to 0 so that if its again visited we know its a cycle.\\n            }\\n            if(rightChild[i] != -1){\\n                if(!totalNodes[rightChild[i]]){ //If already visited child then that would lead to a loop.\\n                    return false;\\n                } \\n                totalNodes[rightChild[i]] = 0; //When visited set to 0 so that if its again visited we know its a cycle.\\n            }\\n        }\\n        //Checks the number of nodes that hasnt been visited yet. If the count is not equal to 1 that means there are more than 1 tree in the graph.\\n        int root = -1;\\n        for(int i=0; i<totalNodes.size(); i++){\\n            if(totalNodes[i]==1){\\n                if(root != -1){\\n                    return false; //Returns false if more than 2 node is set as 1.\\n                } \\n                root = i;\\n            }\\n        }\\n        if(root == -1){return false;} //Returns false if no node was left. This happens when the full set of nodes form a cycle.\\n        return (leftChild[root] != -1 || rightChild[root] != -1); //Checks if the root found has atleast 1 children. If not return false.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        if(n==1){return true;} //if single node surely true.\\n        vector<int> totalNodes(n, 1); //Keeps track of visited nodes. If not visited its set to 1.\\n        for(int i=0; i<leftChild.size(); i++){\\n            if(leftChild[i] != -1){ //Check if child present for the node.\\n                if(!totalNodes[leftChild[i]]){ //If already visited child then that would lead to a loop.\\n                    return false;\\n                } \\n                totalNodes[leftChild[i]] = 0; //When visited set to 0 so that if its again visited we know its a cycle.\\n            }\\n            if(rightChild[i] != -1){\\n                if(!totalNodes[rightChild[i]]){ //If already visited child then that would lead to a loop.\\n                    return false;\\n                } \\n                totalNodes[rightChild[i]] = 0; //When visited set to 0 so that if its again visited we know its a cycle.\\n            }\\n        }\\n        //Checks the number of nodes that hasnt been visited yet. If the count is not equal to 1 that means there are more than 1 tree in the graph.\\n        int root = -1;\\n        for(int i=0; i<totalNodes.size(); i++){\\n            if(totalNodes[i]==1){\\n                if(root != -1){\\n                    return false; //Returns false if more than 2 node is set as 1.\\n                } \\n                root = i;\\n            }\\n        }\\n        if(root == -1){return false;} //Returns false if no node was left. This happens when the full set of nodes form a cycle.\\n        return (leftChild[root] != -1 || rightChild[root] != -1); //Checks if the root found has atleast 1 children. If not return false.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709830,
                "title": "simplest-c-solution-using-indegree-and-outdegree",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n              vector<int> inDegree(n, 0);\\n              vector<int> outDegree(n,0);\\n        if(n==1)\\n            return true;\\n        for (int i = 0, count = n; i < n; ++i) {\\n            if (leftChild[i] != -1) {\\n                inDegree[leftChild[i]]++;\\n                outDegree[i]++;\\n            }\\n            if (rightChild[i] != -1) {\\n                inDegree[rightChild[i]]++;\\n                outDegree[i]++;\\n            }   \\n            if (inDegree[i] > 1) return false;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < n; ++i){\\n            if (inDegree[i] == 0)\\n                ++count;\\n            if(outDegree[i]==0 && inDegree[i]==0)\\n                return false;\\n        }   \\n        return count == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n              vector<int> inDegree(n, 0);\\n              vector<int> outDegree(n,0);\\n        if(n==1)\\n            return true;\\n        for (int i = 0, count = n; i < n; ++i) {\\n            if (leftChild[i] != -1) {\\n                inDegree[leftChild[i]]++;\\n                outDegree[i]++;\\n            }\\n            if (rightChild[i] != -1) {\\n                inDegree[rightChild[i]]++;\\n                outDegree[i]++;\\n            }   \\n            if (inDegree[i] > 1) return false;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < n; ++i){\\n            if (inDegree[i] == 0)\\n                ++count;\\n            if(outDegree[i]==0 && inDegree[i]==0)\\n                return false;\\n        }   \\n        return count == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638334,
                "title": "easy-indegree-count-visited-java",
                "content": "\\t  public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n      \\n        int in[] = new int[n];\\n        boolean visited[] = new boolean[n];\\n        visited[0] = true;\\n        for(int i = 0; i < leftChild.length; i++) {\\n            int x = leftChild[i];\\n            int y = rightChild[i];\\n            if(x!=-1) {\\n                visited[x] = true;\\n                visited[i] = true;\\n                in[x]++;\\n            }\\n            if(y!=-1) {\\n                visited[y] = true;\\n                visited[i] = true;\\n\\n                in[y]++;\\n            }\\n        }\\n        visited[0] = true;\\n        for(int i = 0; i < visited.length; i++) {\\n            if(visited[i] == false) {\\n                return false;\\n            }\\n        }\\n        boolean flag = false;\\n        for(int i = 0; i < in.length; i++) {\\n            if(in[i] == 0 && flag == true) {\\n                return false;\\n            }\\n            if(in[i] == 0) {\\n                flag = true;\\n            }\\n            if(in[i] > 1) {\\n                return false;\\n            }\\n\\n        }\\n        if(flag == false) {\\n            return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\t  public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n      \\n        int in[] = new int[n];\\n        boolean visited[] = new boolean[n];\\n        visited[0] = true;\\n        for(int i = 0; i < leftChild.length; i++) {\\n            int x = leftChild[i];\\n            int y = rightChild[i];\\n            if(x!=-1) {\\n                visited[x] = true;\\n                visited[i] = true;\\n                in[x]++;\\n            }\\n            if(y!=-1) {\\n                visited[y] = true;\\n                visited[i] = true;\\n\\n                in[y]++;\\n            }\\n        }\\n        visited[0] = true;\\n        for(int i = 0; i < visited.length; i++) {\\n            if(visited[i] == false) {\\n                return false;\\n            }\\n        }\\n        boolean flag = false;\\n        for(int i = 0; i < in.length; i++) {\\n            if(in[i] == 0 && flag == true) {\\n                return false;\\n            }\\n            if(in[i] == 0) {\\n                flag = true;\\n            }\\n            if(in[i] > 1) {\\n                return false;\\n            }\\n\\n        }\\n        if(flag == false) {\\n            return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 617038,
                "title": "two-c-solutions-with-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    bool help(int index, vector<int>& leftChild, vector<int>& rightChild, vector<bool>& checked){\\n        if(index == -1) return true;\\n        if(checked[index] == true) return false; // it means there is a cycle\\n        checked[index] = true;\\n        bool left = help(leftChild[index], leftChild, rightChild, checked);\\n        bool right = help(rightChild[index], leftChild, rightChild, checked);\\n        return left && right;\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {    \\n        vector<bool> checked(n, false); // it will be true if the node is checked/visited\\n        vector<bool> findRoot(n, false); // it will be true if the node is associated\\n        int root = -1;\\n        // find root, the root should not be associated(ex.3)\\n        for(int i = 0; i < leftChild.size(); ++i){\\n            if(leftChild[i] != -1)\\n                findRoot[leftChild[i]] = true;\\n            if(rightChild[i] != -1)\\n                findRoot[rightChild[i]] = true;\\n        }\\n        for(int i = 0; i < findRoot.size(); ++i){\\n            if(findRoot[i] == false)\\n                root = i;\\n        }        \\n        if(root == -1) return false; \\n        //DFS and find cycle(ex.2)\\n        bool ans = help(root, leftChild, rightChild, checked);\\n        //complete a tree, find if there is another tree(ex.4)\\n        bool check = true;;\\n        for(int i = 0; i < checked.size(); ++i){\\n            if(checked[i] == false)\\n                check = false;\\n        }\\n        return ans && check;\\n    }\\n};\\n```\\n\\nAnother solution with no dfs, which is faster.\\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {   \\n        if(n == 1 && leftChild[0] == -1 && rightChild[0] == -1){\\n            return true;\\n        }\\n        vector<bool> findRoot(n, false); \\n        int root = -1;\\n        for(int i = 0; i < leftChild.size(); ++i){\\n            if(leftChild[i] != -1){\\n                if(findRoot[leftChild[i]] == true) //cycle(ex.2)\\n                    return false;\\n                findRoot[leftChild[i]] = true; \\n            }\\n            if(rightChild[i] != -1){\\n                if(findRoot[rightChild[i]] == true) //cycle\\n                    return false;\\n                findRoot[rightChild[i]] = true;\\n            }\\n        }\\n        for(int i = 0; i < findRoot.size(); ++i){\\n            if(findRoot[i] == false && root == -1)\\n                root = i;\\n            else if (findRoot[i] == false && root != -1) // two roots(ex.4)\\n                return false;\\n        }\\n        if(root == -1) return false; //no root(ex.3)\\n\\t\\t// handle some special cases, ex. n=4, [1, 2, 0, -1], [-1, -1, -1, -1]\\n        if(leftChild[root] != -1 && rightChild[root] != -1){\\n            if(findRoot[leftChild[root]] == false && findRoot[rightChild[root]] == false)\\n                return false;\\n        }else if(leftChild[root] != -1){\\n            if(findRoot[leftChild[root]] == false)\\n                return false;\\n        }else if(rightChild[root] != -1){\\n            if(findRoot[rightChild[root]] == false)\\n                return false;\\n        }else\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool help(int index, vector<int>& leftChild, vector<int>& rightChild, vector<bool>& checked){\\n        if(index == -1) return true;\\n        if(checked[index] == true) return false; // it means there is a cycle\\n        checked[index] = true;\\n        bool left = help(leftChild[index], leftChild, rightChild, checked);\\n        bool right = help(rightChild[index], leftChild, rightChild, checked);\\n        return left && right;\\n    }\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {    \\n        vector<bool> checked(n, false); // it will be true if the node is checked/visited\\n        vector<bool> findRoot(n, false); // it will be true if the node is associated\\n        int root = -1;\\n        // find root, the root should not be associated(ex.3)\\n        for(int i = 0; i < leftChild.size(); ++i){\\n            if(leftChild[i] != -1)\\n                findRoot[leftChild[i]] = true;\\n            if(rightChild[i] != -1)\\n                findRoot[rightChild[i]] = true;\\n        }\\n        for(int i = 0; i < findRoot.size(); ++i){\\n            if(findRoot[i] == false)\\n                root = i;\\n        }        \\n        if(root == -1) return false; \\n        //DFS and find cycle(ex.2)\\n        bool ans = help(root, leftChild, rightChild, checked);\\n        //complete a tree, find if there is another tree(ex.4)\\n        bool check = true;;\\n        for(int i = 0; i < checked.size(); ++i){\\n            if(checked[i] == false)\\n                check = false;\\n        }\\n        return ans && check;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {   \\n        if(n == 1 && leftChild[0] == -1 && rightChild[0] == -1){\\n            return true;\\n        }\\n        vector<bool> findRoot(n, false); \\n        int root = -1;\\n        for(int i = 0; i < leftChild.size(); ++i){\\n            if(leftChild[i] != -1){\\n                if(findRoot[leftChild[i]] == true) //cycle(ex.2)\\n                    return false;\\n                findRoot[leftChild[i]] = true; \\n            }\\n            if(rightChild[i] != -1){\\n                if(findRoot[rightChild[i]] == true) //cycle\\n                    return false;\\n                findRoot[rightChild[i]] = true;\\n            }\\n        }\\n        for(int i = 0; i < findRoot.size(); ++i){\\n            if(findRoot[i] == false && root == -1)\\n                root = i;\\n            else if (findRoot[i] == false && root != -1) // two roots(ex.4)\\n                return false;\\n        }\\n        if(root == -1) return false; //no root(ex.3)\\n\\t\\t// handle some special cases, ex. n=4, [1, 2, 0, -1], [-1, -1, -1, -1]\\n        if(leftChild[root] != -1 && rightChild[root] != -1){\\n            if(findRoot[leftChild[root]] == false && findRoot[rightChild[root]] == false)\\n                return false;\\n        }else if(leftChild[root] != -1){\\n            if(findRoot[leftChild[root]] == false)\\n                return false;\\n        }else if(rightChild[root] != -1){\\n            if(findRoot[rightChild[root]] == false)\\n                return false;\\n        }else\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556286,
                "title": "java-solution-using-bfs",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] degree = new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            if(leftChild[i]!=-1)\\n                degree[leftChild[i]]++;\\n            if(rightChild[i]!=-1)\\n                degree[rightChild[i]]++;\\n        }\\n        int root = -1, zero = 0, one = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(degree[i]==0) {zero++; root=i;}\\n            if(degree[i]==1) one++;\\n        }\\n        \\n\\t\\t// check if tree is valid and has no cycle\\n        if(zero!=1 || zero+one!=n)\\n            return false;\\n        \\n        //BFS\\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            n--;\\n            if(leftChild[node]!=-1)\\n                queue.add(leftChild[node]);\\n            if(rightChild[node]!=-1)\\n                queue.add(rightChild[node]);\\n        }\\n        \\n        return n==0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] degree = new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            if(leftChild[i]!=-1)\\n                degree[leftChild[i]]++;\\n            if(rightChild[i]!=-1)\\n                degree[rightChild[i]]++;\\n        }\\n        int root = -1, zero = 0, one = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(degree[i]==0) {zero++; root=i;}\\n            if(degree[i]==1) one++;\\n        }\\n        \\n\\t\\t// check if tree is valid and has no cycle\\n        if(zero!=1 || zero+one!=n)\\n            return false;\\n        \\n        //BFS\\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            n--;\\n            if(leftChild[node]!=-1)\\n                queue.add(leftChild[node]);\\n            if(rightChild[node]!=-1)\\n                queue.add(rightChild[node]);\\n        }\\n        \\n        return n==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552647,
                "title": "c-o-n-time-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1.\\n\\nFirstly, we can check the in-dgree.\\n\\n* Only one node (the root) has 0 in-degree. All other nodes have 1 in-dgree.\\n\\nBut this is not enough. For example:\\n\\n```\\n[0,-1]\\n[-1,-1]\\n```\\n\\nThis graphy has one circle and one dangling node and satisfies the above requirement.\\n\\nTo rule this scenario out, we can add this requirement.\\n\\n* If there are more than one node, the node with 0 in-degree must have out-degree.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/validate-binary-tree-nodes/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> indegree(n);\\n        for (int i = 0; i < n; ++i) {\\n            int L = leftChild[i], R = rightChild[i];\\n            if (L != -1 && indegree[L]++) return false; // if the indegree is more than 1, return false\\n            if (R != -1 && indegree[R]++) return false;\\n        }\\n        int root = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (indegree[i]) continue;\\n            if (root != -1) return false; // if more than one node with 0 indegree, return false\\n            root = i;\\n        }\\n        return root != -1 && (n == 1 || leftChild[root] != -1 || rightChild[root] != -1); // root must exist, and the root must have out-degree unless there is only one node\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[0,-1]\\n[-1,-1]\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/validate-binary-tree-nodes/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> indegree(n);\\n        for (int i = 0; i < n; ++i) {\\n            int L = leftChild[i], R = rightChild[i];\\n            if (L != -1 && indegree[L]++) return false; // if the indegree is more than 1, return false\\n            if (R != -1 && indegree[R]++) return false;\\n        }\\n        int root = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (indegree[i]) continue;\\n            if (root != -1) return false; // if more than one node with 0 indegree, return false\\n            root = i;\\n        }\\n        return root != -1 && (n == 1 || leftChild[root] != -1 || rightChild[root] != -1); // root must exist, and the root must have out-degree unless there is only one node\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546140,
                "title": "easy-solution-using-dsu",
                "content": "```\\nclass DSU {\\nprivate:\\n    vector <int> parent;\\npublic:\\n    DSU(int N) {\\n        for (int i = 0; i < N; ++i)\\n            parent.push_back(i);\\n    }\\n    int Find(int x) {\\n        if (parent[x] != x) parent[x] = Find(parent[x]);\\n        return parent[x];\\n    }\\n    bool Union(int x, int y) {\\n        int r1 = Find(x), r2 = Find(y);\\n        if(r1 == r2) return false;\\n        \\n        parent[r1] = r2;\\n        return true;\\n    }\\n    bool checkRoot() { /* Checks if only one root exists */\\n        int root = 0;\\n        for(int i=0;i<parent.size();i++) {\\n            if(parent[i] == i) root++;\\n        }\\n        return root == 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        DSU dsu = DSU(n);\\n        \\n        for(int i=0;i<n;i++) {\\n            int left = leftChild[i];\\n            int right = rightChild[i];\\n            \\n            if(left != -1) {\\n                if(!dsu.Union(i, left)) return false;\\n            }\\n            \\n            if(right != -1) {\\n                if(!dsu.Union(i, right)) return false;\\n            }\\n        }\\n        return dsu.checkRoot();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass DSU {\\nprivate:\\n    vector <int> parent;\\npublic:\\n    DSU(int N) {\\n        for (int i = 0; i < N; ++i)\\n            parent.push_back(i);\\n    }\\n    int Find(int x) {\\n        if (parent[x] != x) parent[x] = Find(parent[x]);\\n        return parent[x];\\n    }\\n    bool Union(int x, int y) {\\n        int r1 = Find(x), r2 = Find(y);\\n        if(r1 == r2) return false;\\n        \\n        parent[r1] = r2;\\n        return true;\\n    }\\n    bool checkRoot() { /* Checks if only one root exists */\\n        int root = 0;\\n        for(int i=0;i<parent.size();i++) {\\n            if(parent[i] == i) root++;\\n        }\\n        return root == 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        DSU dsu = DSU(n);\\n        \\n        for(int i=0;i<n;i++) {\\n            int left = leftChild[i];\\n            int right = rightChild[i];\\n            \\n            if(left != -1) {\\n                if(!dsu.Union(i, left)) return false;\\n            }\\n            \\n            if(right != -1) {\\n                if(!dsu.Union(i, right)) return false;\\n            }\\n        }\\n        return dsu.checkRoot();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543655,
                "title": "java-100-runtime-with-explanations",
                "content": "```\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        boolean[] visited = new boolean[n]; // will mark all visited nodes\\n        int rootNode = findRootNode(n, leftChild, rightChild); // return the first node that has children\\n        if (!dfs(rootNode, leftChild, rightChild, visited)) return false; // if the tree is not valid - return false\\n        \\n        for (int i = rootNode + 1; i < n; i++) { // explore all nodes starting from the next one after root\\n            if (!visited[i]) return false; // if unvisited node is found - it means there are 2 or more disconnected trees - it\\'s not a valid tree\\n        }\\n        return true; // there is only one tree and it is a valid tree\\n    }\\n    \\n    private int findRootNode(int n, int[] leftChild, int[] rightChild) {\\n        for (int i = 0; i < n; i++) { // explore all nodes\\n            if (leftChild[i] != -1 || rightChild[i] != -1) return i; // return the first node that has children\\n        }\\n        return 0; // will never happen\\n    }\\n    \\n    private boolean dfs(int node, int[] leftChild, int[] rightChild, boolean[] visited) {\\n        if (visited[node]) return false; // cycle detected (current node is pointing to already visited node) - not a valid tree\\n        visited[node] = true; // mark as visited\\n        if (leftChild[node] != -1) { // if left child exists - explore it\\n            if (!dfs(leftChild[node], leftChild, rightChild, visited)) return false; // left is not valid - return false\\n        }\\n        if (rightChild[node] != -1) { // if right child exists - explore it\\n            if (!dfs(rightChild[node], leftChild, rightChild, visited)) return false; // right is not valid - return false\\n        }\\n        return true; // only if left is valid and right is valid\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        boolean[] visited = new boolean[n]; // will mark all visited nodes\\n        int rootNode = findRootNode(n, leftChild, rightChild); // return the first node that has children\\n        if (!dfs(rootNode, leftChild, rightChild, visited)) return false; // if the tree is not valid - return false\\n        \\n        for (int i = rootNode + 1; i < n; i++) { // explore all nodes starting from the next one after root\\n            if (!visited[i]) return false; // if unvisited node is found - it means there are 2 or more disconnected trees - it\\'s not a valid tree\\n        }\\n        return true; // there is only one tree and it is a valid tree\\n    }\\n    \\n    private int findRootNode(int n, int[] leftChild, int[] rightChild) {\\n        for (int i = 0; i < n; i++) { // explore all nodes\\n            if (leftChild[i] != -1 || rightChild[i] != -1) return i; // return the first node that has children\\n        }\\n        return 0; // will never happen\\n    }\\n    \\n    private boolean dfs(int node, int[] leftChild, int[] rightChild, boolean[] visited) {\\n        if (visited[node]) return false; // cycle detected (current node is pointing to already visited node) - not a valid tree\\n        visited[node] = true; // mark as visited\\n        if (leftChild[node] != -1) { // if left child exists - explore it\\n            if (!dfs(leftChild[node], leftChild, rightChild, visited)) return false; // left is not valid - return false\\n        }\\n        if (rightChild[node] != -1) { // if right child exists - explore it\\n            if (!dfs(rightChild[node], leftChild, rightChild, visited)) return false; // right is not valid - return false\\n        }\\n        return true; // only if left is valid and right is valid\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539172,
                "title": "java-concise-union-find",
                "content": "**(1) Indegree of each node is at most 1\\n (2) No separate trees**\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n       \\n        int[] roots = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            roots[i] = i;\\n        }\\n\\t\\t// condition 1: Indegree of each node is at most 1\\n        for (int i = 0; i < n; i++) {\\n            int r = find(roots, i);\\n            int left = leftChild[i];\\n            int right = rightChild[i];\\n            if (left != -1) {\\n                int lr = find(roots, left);\\n                if (lr == r) return false;\\n                roots[lr] = r;\\n            } \\n            if (right != -1) {\\n                int rr = find(roots, right);\\n                if (rr == r) return false;\\n                roots[rr] = r;\\n            }\\n        }\\n        \\n\\t\\t// condition 2: No separate trees, only one root int the end\\n        int uniqueroot = -1;\\n        for (int i = 0; i < n; i++) {\\n            int r = find(roots, i);\\n            if (uniqueroot != -1 && r != uniqueroot) return false;\\n            uniqueroot = r;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int find(int[] roots, int id) {\\n        while (id != roots[id]) id = roots[id];\\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n       \\n        int[] roots = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            roots[i] = i;\\n        }\\n\\t\\t// condition 1: Indegree of each node is at most 1\\n        for (int i = 0; i < n; i++) {\\n            int r = find(roots, i);\\n            int left = leftChild[i];\\n            int right = rightChild[i];\\n            if (left != -1) {\\n                int lr = find(roots, left);\\n                if (lr == r) return false;\\n                roots[lr] = r;\\n            } \\n            if (right != -1) {\\n                int rr = find(roots, right);\\n                if (rr == r) return false;\\n                roots[rr] = r;\\n            }\\n        }\\n        \\n\\t\\t// condition 2: No separate trees, only one root int the end\\n        int uniqueroot = -1;\\n        for (int i = 0; i < n; i++) {\\n            int r = find(roots, i);\\n            if (uniqueroot != -1 && r != uniqueroot) return false;\\n            uniqueroot = r;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int find(int[] roots, int id) {\\n        while (id != roots[id]) id = roots[id];\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535157,
                "title": "use-topological-sort-since-it-s-expected-a-dag",
                "content": "At the beginning I think I could solve the problem by using in-out degrees, but I fount it\\'s hard to solve the problem of circle, multiple trees. Hence I return back to topological sort, but calculate the in-dgree to make sure it\\'s a single tree.\\n\\nBFS:\\nSimilar to Kahn\\'s algorithm.\\n\\n```\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        final int[] in = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            final int left = leftChild[i], right = rightChild[i];\\n            if (left >= 0) in[left]++;\\n            if (right >= 0) in[right]++;\\n        }\\n\\n        final Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (in[i] > 1) return false;\\n            if (in[i] == 0) q.offer(i);\\n        }\\n        if (q.size() > 1) return false;\\n\\n        int total = 0;\\n        while (!q.isEmpty()) {\\n            total++;\\n            int v = q.poll();\\n\\n            int left = leftChild[v], right = rightChild[v];\\n            if (left != -1 && --in[left] == 0) q.offer(left);\\n            if (right != -1 && --in[right] == 0) q.offer(right);\\n        }\\n\\n        return total == n;\\n    }\\n```\\n\\nDFS:\\nSimilar to Tarjan\\'s algorithm.\\n\\n```\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        final int[] in = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            final int left = leftChild[i], right = rightChild[i];\\n            if (left >= 0) in[left]++;\\n            if (right >= 0) in[right]++;\\n        }\\n\\n        int root = -1, rootCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (in[i] != 0) continue;\\n            rootCount++;\\n            root = i;\\n        }\\n\\n        if (rootCount != 1) return false;\\n        final Set<Integer> visited = new HashSet<>();\\n        return dfs(root, leftChild, rightChild, visited) && visited.size() == n;\\n    }\\n\\n    private boolean dfs(int root, int[] leftChild, int[] rightChild, Set<Integer> visited) {\\n        if (root == -1) return true;\\n        if (!visited.add(root)) return false;\\n\\n        return dfs(leftChild[root], leftChild, rightChild, visited)\\n                && dfs(rightChild[root], leftChild, rightChild, visited);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        final int[] in = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            final int left = leftChild[i], right = rightChild[i];\\n            if (left >= 0) in[left]++;\\n            if (right >= 0) in[right]++;\\n        }\\n\\n        final Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (in[i] > 1) return false;\\n            if (in[i] == 0) q.offer(i);\\n        }\\n        if (q.size() > 1) return false;\\n\\n        int total = 0;\\n        while (!q.isEmpty()) {\\n            total++;\\n            int v = q.poll();\\n\\n            int left = leftChild[v], right = rightChild[v];\\n            if (left != -1 && --in[left] == 0) q.offer(left);\\n            if (right != -1 && --in[right] == 0) q.offer(right);\\n        }\\n\\n        return total == n;\\n    }\\n```\n```\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        final int[] in = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            final int left = leftChild[i], right = rightChild[i];\\n            if (left >= 0) in[left]++;\\n            if (right >= 0) in[right]++;\\n        }\\n\\n        int root = -1, rootCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (in[i] != 0) continue;\\n            rootCount++;\\n            root = i;\\n        }\\n\\n        if (rootCount != 1) return false;\\n        final Set<Integer> visited = new HashSet<>();\\n        return dfs(root, leftChild, rightChild, visited) && visited.size() == n;\\n    }\\n\\n    private boolean dfs(int root, int[] leftChild, int[] rightChild, Set<Integer> visited) {\\n        if (root == -1) return true;\\n        if (!visited.add(root)) return false;\\n\\n        return dfs(leftChild[root], leftChild, rightChild, visited)\\n                && dfs(rightChild[root], leftChild, rightChild, visited);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528184,
                "title": "intuitive-java-solution",
                "content": "Couple of checks to validate:\\n1: Make sure there is only one root node.\\n2: Verify the cycles using DFS\\n\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        if(n == 0) return false;\\n        int[] indegree = new int[n];\\n        boolean[] visited = new boolean[n];\\n        int root = -1;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(indegree[leftChild[i]] != 0) return false;\\n                else indegree[leftChild[i]] = 1;\\n            }      \\n            if(rightChild[i] != -1) {\\n                if(indegree[rightChild[i]] != 0) return false;\\n                else indegree[rightChild[i]] = 1;  \\n            }\\n                \\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(indegree[i] == 0) {\\n                if(root != -1) return false;\\n                else root = i;\\n            }   \\n        }\\n        \\n        if(root == -1) return false;\\n        \\n        // verify cycles using DFS\\n        for(int i=0; i<n; i++) {\\n            if(!visited[i]) {\\n                boolean res = dfs(root, leftChild, rightChild, visited);\\n                if(!res) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n        public boolean dfs(int index, int[] leftChild, int[] rightChild, boolean[] visited) {\\n        if(visited[index]) return false;\\n        \\n        visited[index] = true;\\n            \\n        if(leftChild[index] != -1){\\n           boolean res = dfs(leftChild[index], leftChild, rightChild, visited);\\n           if(!res) return false;  \\n        }\\n        \\n        if(rightChild[index] != -1){\\n           boolean res = dfs(rightChild[index], leftChild, rightChild, visited);\\n           if(!res) return false;  \\n        }    \\n    \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        \\n        if(n == 0) return false;\\n        int[] indegree = new int[n];\\n        boolean[] visited = new boolean[n];\\n        int root = -1;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(leftChild[i] != -1) {\\n                if(indegree[leftChild[i]] != 0) return false;\\n                else indegree[leftChild[i]] = 1;\\n            }      \\n            if(rightChild[i] != -1) {\\n                if(indegree[rightChild[i]] != 0) return false;\\n                else indegree[rightChild[i]] = 1;  \\n            }\\n                \\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(indegree[i] == 0) {\\n                if(root != -1) return false;\\n                else root = i;\\n            }   \\n        }\\n        \\n        if(root == -1) return false;\\n        \\n        // verify cycles using DFS\\n        for(int i=0; i<n; i++) {\\n            if(!visited[i]) {\\n                boolean res = dfs(root, leftChild, rightChild, visited);\\n                if(!res) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n        public boolean dfs(int index, int[] leftChild, int[] rightChild, boolean[] visited) {\\n        if(visited[index]) return false;\\n        \\n        visited[index] = true;\\n            \\n        if(leftChild[index] != -1){\\n           boolean res = dfs(leftChild[index], leftChild, rightChild, visited);\\n           if(!res) return false;  \\n        }\\n        \\n        if(rightChild[index] != -1){\\n           boolean res = dfs(rightChild[index], leftChild, rightChild, visited);\\n           if(!res) return false;  \\n        }    \\n    \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526888,
                "title": "as-easy-as-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int FIND(int u, vector<int>& uf) {\\n        if(uf[uf[u]] != uf[u]) {\\n            return uf[u] = FIND(uf[u], uf);\\n        }\\n        return uf[u];\\n    }\\n    \\n    bool join(int u, int v, vector<int>& uf) {\\n        u = FIND(u, uf), v = FIND(v, uf);\\n        if(u != v) {\\n            uf[u] = v;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> uf(n);\\n        for(int i = 0; i < n; ++i) {\\n            uf[i] = i;\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            if(leftChild[i] != -1) {\\n                if(!join(i, leftChild[i], uf)) {\\n                    return false;\\n                }\\n            }\\n            if(rightChild[i] != -1) {\\n                if(!join(i, rightChild[i], uf)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        int rot = 0;\\n        for(int i = 0; i < n; ++i) {\\n            rot += FIND(i, uf) == i;\\n        }\\n        return rot == 1; // number of roots must be 1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int FIND(int u, vector<int>& uf) {\\n        if(uf[uf[u]] != uf[u]) {\\n            return uf[u] = FIND(uf[u], uf);\\n        }\\n        return uf[u];\\n    }\\n    \\n    bool join(int u, int v, vector<int>& uf) {\\n        u = FIND(u, uf), v = FIND(v, uf);\\n        if(u != v) {\\n            uf[u] = v;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> uf(n);\\n        for(int i = 0; i < n; ++i) {\\n            uf[i] = i;\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            if(leftChild[i] != -1) {\\n                if(!join(i, leftChild[i], uf)) {\\n                    return false;\\n                }\\n            }\\n            if(rightChild[i] != -1) {\\n                if(!join(i, rightChild[i], uf)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        int rot = 0;\\n        for(int i = 0; i < n; ++i) {\\n            rot += FIND(i, uf) == i;\\n        }\\n        return rot == 1; // number of roots must be 1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523949,
                "title": "count-of-edges-avoid-cycle",
                "content": "In a valid tree, the # of edges = # of nodes - 1, and it has no cycle.\\n\\nSo it becomes pretty straight forward: any node can only be one other node\\'s child(to avoid cycle), except the root node of the whole tree, there is only one tree, so the # of edges = # of nodes - 1.\\n\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Set<Integer> children = new HashSet<>();\\n        for (int i = 0; i < leftChild.length; i++) {\\n            int left = leftChild[i], right = rightChild[i];\\n            if (left != -1 && !children.add(left)) {\\n                return false;\\n            }\\n            if (right != -1 && !children.add(right)) {\\n                return false;\\n            }\\n        }\\n        return children.size() == n - 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Set<Integer> children = new HashSet<>();\\n        for (int i = 0; i < leftChild.length; i++) {\\n            int left = leftChild[i], right = rightChild[i];\\n            if (left != -1 && !children.add(left)) {\\n                return false;\\n            }\\n            if (right != -1 && !children.add(right)) {\\n                return false;\\n            }\\n        }\\n        return children.size() == n - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521139,
                "title": "java-simple-dfs-based-solution-with-visited-array",
                "content": "Traverse left and right child in dfs manner and maintain a visited array to keep track of the visited nodes. If at the end of the dfs traversal any node is not visited then there are more than one connected components so return false.\\n\\nIf we encounter a visited node during the traversal then the node is also a child of another node which means its not a valid binary tree. \\n\\n\\n```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        boolean[] visited = new boolean[n];\\n\\n        boolean res = dfs(0, n, leftChild, rightChild, visited);\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    public boolean dfs(int val, int n, int[] l, int[] r, boolean visited[]) {\\n        if(val >= n || val == -1) {\\n            return true;\\n        } \\n        \\n        if(visited[val]) {\\n            return false;\\n        }\\n        \\n        visited[val] = true;\\n        boolean res = dfs(l[val], n, l, r, visited) &&\\n            dfs(r[val], n, l, r, visited);\\n        \\n        \\n        return res;\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        boolean[] visited = new boolean[n];\\n\\n        boolean res = dfs(0, n, leftChild, rightChild, visited);\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    public boolean dfs(int val, int n, int[] l, int[] r, boolean visited[]) {\\n        if(val >= n || val == -1) {\\n            return true;\\n        } \\n        \\n        if(visited[val]) {\\n            return false;\\n        }\\n        \\n        visited[val] = true;\\n        boolean res = dfs(l[val], n, l, r, visited) &&\\n            dfs(r[val], n, l, r, visited);\\n        \\n        \\n        return res;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520879,
                "title": "c-validate-by-indegree",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> inDegree(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            int left = leftChild[i], right = rightChild[i];\\n            if (left != -1) inDegree[left]++;\\n            if (right != -1) inDegree[right]++;\\n        }\\n        \\n        int n_roots = 0;\\n        for (const int& x : inDegree) {\\n            if (!x) n_roots++;\\n            else if (x > 1) return false;\\n        }\\n        \\n        return n_roots == 1;\\n    }\\n};\\n```\\n\\nThere is an easy way to validate a tree. As is known to us, every non-root node in tree is pointed by its parent - the indegree is 1. And the root node is not pointed by any node, so its indegree is 0. Hence we can tell if it is a connected tree by checking whether there are more than 1 nodes which have an indegree of 0.\\n\\nAs we combine this two rules together, we can reach the solution given above.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> inDegree(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            int left = leftChild[i], right = rightChild[i];\\n            if (left != -1) inDegree[left]++;\\n            if (right != -1) inDegree[right]++;\\n        }\\n        \\n        int n_roots = 0;\\n        for (const int& x : inDegree) {\\n            if (!x) n_roots++;\\n            else if (x > 1) return false;\\n        }\\n        \\n        return n_roots == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519221,
                "title": "easy-readable-solution-on-c-using-one-set",
                "content": "```\\npublic bool ValidateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild)\\n        {\\n            var visitedNodes = new HashSet<int>() {0};\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (!visitedNodes.Contains(i))\\n                    return false;\\n\\n                if (leftChild[i] != -1 && !visitedNodes.Add(leftChild[i]))\\n                    return false;\\n                if (rightChild[i] != -1 && !visitedNodes.Add(rightChild[i]))\\n                    return false;\\n            }\\n\\n            return true;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool ValidateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild)\\n        {\\n            var visitedNodes = new HashSet<int>() {0};\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (!visitedNodes.Contains(i))\\n                    return false;\\n\\n                if (leftChild[i] != -1 && !visitedNodes.Add(leftChild[i]))\\n                    return false;\\n                if (rightChild[i] != -1 && !visitedNodes.Add(rightChild[i]))\\n                    return false;\\n            }\\n\\n            return true;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519048,
                "title": "tricky-solution-with-tree-properties-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> cnt(n + 1, 0);\\n        for (int node : leftChild) {\\n            cnt[node+1]++;\\n        }\\n        \\n        if (cnt[0] == 0 || cnt[0] >= n + 1) {          // -1 appear in leftChild should be in [1, n]\\n            return false;\\n        }\\n        \\n        for (int node : rightChild) {\\n            cnt[node+1]++;\\n        }\\n        \\n        if (cnt[0] != n + 1) {                           // total occurrences of -1 should be n + 1\\n            return false;\\n        }\\n        \\n        bool rootVisited = false;                        // there is only one root whose occurrence is 0\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (cnt[i+1] > 1) {                          // no node should appear more than once\\n                return false;\\n            }\\n            else if (cnt[i+1] == 0) {\\n                if (rootVisited) {\\n                    return false;\\n                }\\n                rootVisited = true;\\n            }\\n        }\\n        \\n        return rootVisited;\\n    }\\n};\\n```\\n\\nFor a single binary tree with `n` nodes, it should have `n+1` null child with value `-1` (this can be proved by mathematical induction). Furthermore, at least one left child and at least one right child should be null, which means `-1` should appear in both `leftChild` and `rightChild`.\\nBesides, for nodes from `0` to `n-1`, each node should appear exactly once, either in `leftChild` or `rightChild`, except the root node whose appearance should be 0. \\nIn my solution, I create an array `cnt` with size `n+1`. For each index `i`, `cnt[i]` stores the occurrences of node `i-1` in both `leftChild` and `rightChild`, and `cnt[0]` stores the number of `-1`. Return true if these properties are met.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        vector<int> cnt(n + 1, 0);\\n        for (int node : leftChild) {\\n            cnt[node+1]++;\\n        }\\n        \\n        if (cnt[0] == 0 || cnt[0] >= n + 1) {          // -1 appear in leftChild should be in [1, n]\\n            return false;\\n        }\\n        \\n        for (int node : rightChild) {\\n            cnt[node+1]++;\\n        }\\n        \\n        if (cnt[0] != n + 1) {                           // total occurrences of -1 should be n + 1\\n            return false;\\n        }\\n        \\n        bool rootVisited = false;                        // there is only one root whose occurrence is 0\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (cnt[i+1] > 1) {                          // no node should appear more than once\\n                return false;\\n            }\\n            else if (cnt[i+1] == 0) {\\n                if (rootVisited) {\\n                    return false;\\n                }\\n                rootVisited = true;\\n            }\\n        }\\n        \\n        return rootVisited;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518481,
                "title": "java-hashset-queue-solution",
                "content": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        Queue<Integer> nodes = new LinkedList<>();\\n        nodes.add(0);\\n        int i = 0, j = 0;\\n        while(!nodes.isEmpty() && i < leftChild.length && j < rightChild.length) {\\n            if(leftChild[i] != -1) {\\n                if(visited.add(leftChild[i])) {\\n                    nodes.add(leftChild[i]);\\n                } else {\\n                    return false;\\n                }\\n            }\\n            ++i;\\n            if(rightChild[j] != -1) {\\n                if(visited.add(rightChild[j])) {\\n                    nodes.add(rightChild[j]);\\n                } else {\\n                    return false;\\n                }\\n            }\\n            ++j;\\n        }\\n        return visited.size() == n;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        Queue<Integer> nodes = new LinkedList<>();\\n        nodes.add(0);\\n        int i = 0, j = 0;\\n        while(!nodes.isEmpty() && i < leftChild.length && j < rightChild.length) {\\n            if(leftChild[i] != -1) {\\n                if(visited.add(leftChild[i])) {\\n                    nodes.add(leftChild[i]);\\n                } else {\\n                    return false;\\n                }\\n            }\\n            ++i;\\n            if(rightChild[j] != -1) {\\n                if(visited.add(rightChild[j])) {\\n                    nodes.add(rightChild[j]);\\n                } else {\\n                    return false;\\n                }\\n            }\\n            ++j;\\n        }\\n        return visited.size() == n;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518475,
                "title": "c-simple-solution-with-checking-indegree-o-n-with-detailed-explanation-beats-100",
                "content": "In the Tree, there should be only one node (**root**) whose Indegree is 0.\\nWhile every other node should have indegree 1.\\nBased on this idea, \\n```\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n        vector<int> indegree(n, 0);\\n\\t\\t// Populate Indegree\\n        for (int i=0; i<n; ++i) {\\n            if ( leftChild[i] != -1 )\\n                indegree[leftChild[i]]++;\\n            if ( rightChild[i] != -1 )             \\n                indegree[rightChild[i]]++;\\n        }\\n        \\n        int zeroes = 0, ones = 0;\\n        for (int i=0; i<n; ++i) {\\n            if ( indegree[i] == 0 )\\n                zeroes++;\\n            else if ( indegree[i] == 1 )\\n                ones++;\\n            else\\n                return false;\\n        }\\n        \\n        return (zeroes == 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\\n        \\n        vector<int> indegree(n, 0);\\n\\t\\t// Populate Indegree\\n        for (int i=0; i<n; ++i) {\\n            if ( leftChild[i] != -1 )\\n                indegree[leftChild[i]]++;\\n            if ( rightChild[i] != -1 )             \\n                indegree[rightChild[i]]++;\\n        }\\n        \\n        int zeroes = 0, ones = 0;\\n        for (int i=0; i<n; ++i) {\\n            if ( indegree[i] == 0 )\\n                zeroes++;\\n            else if ( indegree[i] == 1 )\\n                ones++;\\n            else\\n                return false;\\n        }\\n        \\n        return (zeroes == 1);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576718,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1564944,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1565461,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1573998,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1574591,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1838623,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1573596,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 2018947,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1951623,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1843474,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1576718,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1564944,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1565461,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1573998,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1574591,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1838623,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1573596,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 2018947,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1951623,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            },
            {
                "id": 1843474,
                "content": [
                    {
                        "username": "leonmu",
                        "content": "Of this case, I assume, root has a left child \\'3\\', no right child. And \\'3\\' has no left child or right child. The tree should end here, but the following \\'1,-1\\', \\'0,-1\\' means more node is coming, should n\\'t this mean a wrong tree?"
                    },
                    {
                        "username": "lee215",
                        "content": "Only tests cases `root = 0` ?\\nNo wonder that OJ solution must be wrong.\\nIt cannot even know what the test case are, how could the standard solution be right?\\n\\nNot surprised at all. The moment I read the problem as Q2 in the contest, I know it will be joke. \\nI intend to to write a wrong solution and get accepted in second.\\n\"I bet no bullet in your gun\"\\n\\nSame thing happened last week.\\nleetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510256/JavaC++Python-Backtrack-OJ-is-wrong/452696\\n"
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "They have changed the test cases...ig There are test cases with root not equal to 0.\\nThis makes the question tricky, we need to first find the root and the check for cycle"
                    },
                    {
                        "username": "hzfmer",
                        "content": "This problem is truly problematic, since even the stadard code is wrong. Yet people are posting their answers without further checking givensome people have clearly stated the problem.\\n\\nThere are a few cases that most solutions easily got wrong:\\n3\\n[2, 1, -1]\\n[-1, -1, -1]\\n3\\n[1,0,-1]\\n[-1,-1,-1]\\n4\\n[1, -1, -1, -1]\\n[2, -1, -1, -1]\\n4\\n[1, -1, 3, -1]\\n[-1, -1, -1, 2]\\n\\nThe reasons for returning False for these tests are: loop (pointing to itself), loop, multiple roots, loop.\\n\\nMoreover, this should return True if I understand the problem correctly (the root doesn\\'t have to be 0):\\n3\\n[2, 0, -1]\\n[-1, -1, -1]\\n\\nI found [this solution](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517557/C%2B%2B-Find-Root-%2B-DFS) and [this](https://leetcode.com/problems/validate-binary-tree-nodes/discuss/518084/JavaScript-Simple-solution-using-map-and-some-binary-tree-properties) seem correct, while most other solutions are likely wrong (up to 02/22/2020).\\nPlease make sure your code passes these tests before posting. It can be misleading and possibly cause one\\'s failing in an interview!"
                    },
                    {
                        "username": "asutosh117",
                        "content": "That\\'s some deep research on, from when correct solutions are posted. Btw thanks for sharing test cases."
                    },
                    {
                        "username": "luanjunyi",
                        "content": "This problem test nothing other than corner case catching. Ideal for hiring boring people. I will immediately leave if asked such questions."
                    },
                    {
                        "username": "mohit2494",
                        "content": "There is no point posting your solution without explanation."
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Input\\nn =\\n4\\nleftChild =\\n[3,-1,1,-1]\\nrightChild =\\n[-1,-1,0,-1]\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nExplain me this testcase "
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "In this test Case root node is 2 and most probably you are taking 0 as root node, that\\'s why the error"
                    },
                    {
                        "username": "nycomdori",
                        "content": "I see 32nd test case has this and wonder how this evaluates to true?\\n2\\n[-1, 0]\\n[-1, -1]\\n\\ntwo negative ones at 0 index (left, right) means the root doesn\\'t have any children nodes.\\n(although it\\'s strange it looks like 0 is always the root.)\\n\\ndoes this test case make sense?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "why is 0 assumed to always be root?"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "n =\\n4\\nleftChild =\\n[1,0,3,-1]\\nrightChild =\\n[-1,-1,-1,-1]\\n\\nwhy it is false in this case ?"
                    },
                    {
                        "username": "MOHITRANA",
                        "content": "how\\nn = 4\\nleftChild = [1,0,3,-1]\\nrightChild = [-1,-1,-1,-1]\\nis not a binary tree."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "Because in this 0 has 1 as its left child and at the same time 1 as 0 as its left child which is not possible"
                    },
                    {
                        "username": "anandnit",
                        "content": "only 38 test cases have been runned ?? why it was always difficult"
                    }
                ]
            }
        ]
    }
]