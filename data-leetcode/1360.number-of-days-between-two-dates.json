[
    {
        "title": "Three Equal Parts",
        "question_content": "You are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value.\nIf it is possible, return any [i, j] with i + 1 < j, such that:\n\n\tarr[0], arr[1], ..., arr[i] is the first part,\n\tarr[i + 1], arr[i + 2], ..., arr[j - 1] is the second part, and\n\tarr[j], arr[j + 1], ..., arr[arr.length - 1] is the third part.\n\tAll three parts have equal binary values.\n\nIf it is not possible, return [-1, -1].\nNote that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.\n&nbsp;\nExample 1:\nInput: arr = [1,0,1,0,1]\nOutput: [0,3]\nExample 2:\nInput: arr = [1,1,0,1,1]\nOutput: [-1,-1]\nExample 3:\nInput: arr = [1,1,0,0,1]\nOutput: [0,2]\n&nbsp;\nConstraints:\n\n\t3 <= arr.length <= 3 * 104\n\tarr[i] is 0 or 1",
        "solutions": [
            {
                "id": 183922,
                "title": "c-o-n-time-o-1-space-12-ms-with-explanation-comments",
                "content": "Algorithm:\\n\\t1) Count no. of 1\\'s in the given array, say ```countNumberOfOnes```.\\n\\t2) If no 1 is found ie. ```countNumberOfOnes == 0```, just return ```{0,size-1}```\\n\\t3) If ``` countNumberOfOnes % 3 != 0``` , then we cannot partition the given array for sure. This is because, there is no way to put equal no. of 1\\'s in any partition and hence, we will get different binary representations.\\n\\t4) Let\\'s try to find if there is a valid partition possible now. We find the first 1 in the given array and represent it\\'s position by ```start```.\\n\\t5) Also, we know that each partition must have ``` countNumberOfOnes/3 ``` (for same reason as given in step 3). Therefore, after finding the first 1, leave  ```k = countNumberOfOnes/3 ``` 1\\'s for the first partition.\\n\\t6) Assign this position as ```mid``` that denotes the beginning of a possible second partition.\\n\\t7) Further leave ```k = countNumberOfOnes/3 ``` 1\\'s for this partition and assign the beginning of last partition as ```end```\\n\\t8) Now, all we need to do is verify whether all the partitions have same values in them. This can be done by iterating through to the end of the array.\\n\\t9) If ```end``` doesn\\'t reach the end of the array, we find a mismatch and hence, we need to return ```{-1, -1}```\\n\\t10) Otherwise, we have found our partition, return ```{start-1,mid}```\\n\\nTime Complexity: ```O(n)```\\nSpace Complexity: ```O(1)```\\n\\n```\\nstatic int x=[](){ios::sync_with_stdio(false); cin.tie(NULL); return 0;}();\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n        if(countNumberOfOnes == 0)      \\n            return {0, A.size()-1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // find the first 1 in the array\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1)\\n                break;\\n        int start = i;\\n        \\n        // find (k+1)th 1 in the array\\n        int count1 = 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == k + 1)\\n                break;\\n        }\\n        int mid = i;\\n        \\n        //find (2*k +1)th 1 in the array\\n        count1= 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == 2*k + 1)\\n                break;\\n        }\\n        int end = i;\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end])\\n        {\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n\\n```\\nCode written during contest, may be optimized further. :-)",
                "solutionTags": [],
                "code": "```countNumberOfOnes```\n```countNumberOfOnes == 0```\n```{0,size-1}```\n``` countNumberOfOnes % 3 != 0```\n```start```\n``` countNumberOfOnes/3 ```\n```k = countNumberOfOnes/3 ```\n```mid```\n```k = countNumberOfOnes/3 ```\n```end```\n```end```\n```{-1, -1}```\n```{start-1,mid}```\n```O(n)```\n```O(1)```\n```\\nstatic int x=[](){ios::sync_with_stdio(false); cin.tie(NULL); return 0;}();\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n        if(countNumberOfOnes == 0)      \\n            return {0, A.size()-1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // find the first 1 in the array\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1)\\n                break;\\n        int start = i;\\n        \\n        // find (k+1)th 1 in the array\\n        int count1 = 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == k + 1)\\n                break;\\n        }\\n        int mid = i;\\n        \\n        //find (2*k +1)th 1 in the array\\n        count1= 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == 2*k + 1)\\n                break;\\n        }\\n        int end = i;\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end])\\n        {\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223886,
                "title": "java-o-n-simple-solution-don-t-know-why-official-solution-is-that-long",
                "content": "Key obseration is that three parts must have same number and pattern of 1s except the leading part.  My idea is to:\\n\\n1. count how many ones  (if num%3!=0 return [-1,-1])\\n2. search from right side to left, until we found num/3 1s.  This index is not final answer, but it defines patten of 1s\\n3. from feft, ignore leading 0s, and then match the pattern found in step 2, to get the first EndIndex\\n4. do another matching to found second EndIndex\\n\\n\\n```\\npublic int[] threeEqualParts(int[] A) {\\n\\t\\tint numOne = 0;\\n\\t\\tfor (int i: A){\\n\\t\\t\\tif (i==1) numOne++;\\n\\t\\t}\\n        \\n        int[] noRes = {-1, -1};\\n        if (numOne == 0) return new int[]{0,2};\\n        if (numOne%3 != 0) return noRes;\\n        \\n        //find index of starting 1 of third string\\n        int idxThird=0;\\n\\t\\tint temp = 0;\\n        for (int i = A.length-1; i>=0; i--){\\n            if (A[i]==1){\\n                temp++;\\n                if (temp == numOne / 3){\\n                    idxThird = i;\\n                    break;\\n                }\\n            } \\n        }\\n        \\n        int res1 = findEndIdx(A, 0, idxThird);\\n        if (res1<0) return noRes;\\n        \\n        int res2 = findEndIdx(A, res1+1, idxThird);\\n        if (res2<0) return noRes;\\n        \\n        return new int[]{res1, res2+1};\\n    }\\n    \\n\\t//right is the pattern to compare to.  \\n\\t//return EndIdx of left pattern that matches right side.\\n    private int findEndIdx(int[] A, int left, int right){\\n        while (A[left]==0) left++;\\n        while (right < A.length){\\n            if (A[left]!=A[right]) return -1;\\n            left++;\\n            right++;            \\n        }\\n        return left-1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] threeEqualParts(int[] A) {\\n\\t\\tint numOne = 0;\\n\\t\\tfor (int i: A){\\n\\t\\t\\tif (i==1) numOne++;\\n\\t\\t}\\n        \\n        int[] noRes = {-1, -1};\\n        if (numOne == 0) return new int[]{0,2};\\n        if (numOne%3 != 0) return noRes;\\n        \\n        //find index of starting 1 of third string\\n        int idxThird=0;\\n\\t\\tint temp = 0;\\n        for (int i = A.length-1; i>=0; i--){\\n            if (A[i]==1){\\n                temp++;\\n                if (temp == numOne / 3){\\n                    idxThird = i;\\n                    break;\\n                }\\n            } \\n        }\\n        \\n        int res1 = findEndIdx(A, 0, idxThird);\\n        if (res1<0) return noRes;\\n        \\n        int res2 = findEndIdx(A, res1+1, idxThird);\\n        if (res2<0) return noRes;\\n        \\n        return new int[]{res1, res2+1};\\n    }\\n    \\n\\t//right is the pattern to compare to.  \\n\\t//return EndIdx of left pattern that matches right side.\\n    private int findEndIdx(int[] A, int left, int right){\\n        while (A[left]==0) left++;\\n        while (right < A.length){\\n            if (A[left]!=A[right]) return -1;\\n            left++;\\n            right++;            \\n        }\\n        return left-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343665,
                "title": "python-o-n-fast-solution-explained",
                "content": "In this problem we need to split number into three parts, such that number in each part after removed all zeroes are equal.\\n1. Let us check all the places, where we have `1.` Let us have `m` elements such that.\\n2. If `m == 0`, it means that we have all zeroes, so we can split in any way, let us split it `[0, 2]`.\\n3. If `m` is not divisible by `3`, we can return `[-1, -1]` immedietly, because if we can have three equal parts, number of ones in these parts must be the same.\\n4. Let us find now `6` indexes: `p1, p2, p3, p4, p5, p6`, where `p1` is index of first `1`, `p2` is index of last one in first part, `p3` is index of fisrt one in second part, and so on. Then it is necessary that `A[p1:p2+1]` equal to `A[p3:p4+1]` equal to `A[p5:p6+1]`. Note that is is not sufficient though, because we can add some zeroes in the ends. So, if this condition do not holds, we return `[-1, -1]`.\\n5. Evaluate lengths of how many zeros we can add in the end: `l1, l2, l3`. For `l3` we do not have any choice: we need to take all there zeroes. For `l1` and `l2` we can put zeroes in the beginning of one number or to the end of the next, so the options we have are: `[0, ..., l1]` for the first, `[0, ..., l2]` for the second and `[l3]` for third. So, if `l3 > l2` or `l3 > l1`, we can not make parts equal and we return `[-1, -1]`.\\n6. In the end return `[p2 + l3, p4 + l3 + 1]`, in this way in each part we have `l3` zeroes in the end.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(n)` as well to keep array of indexes.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        n = len(A)\\n        indexes = [i for i in range(n) if A[i] == 1]\\n        m = len(indexes)\\n        \\n        if m == 0: return [0, 2]\\n        \\n        if m % 3 != 0: return [-1, -1]\\n        p1, p2 = indexes[0], indexes[m//3-1]\\n        p3, p4 = indexes[m//3], indexes[2*m//3-1]\\n        p5, p6 = indexes[2*m//3], indexes[-1]\\n        part1, part2, part3 = A[p1:p2+1], A[p3:p4+1], A[p5:p6+1]\\n        \\n        if part1 != part2 or part2 != part3: return [-1, -1]\\n        \\n        l1 = p3 - p2 - 1\\n        l2 = p5 - p4 - 1\\n        l3 = n - p6 - 1\\n        \\n        if l3 > l2 or l3 > l1: return [-1, -1]\\n        \\n        return [p2 + l3, p4 + l3 + 1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        n = len(A)\\n        indexes = [i for i in range(n) if A[i] == 1]\\n        m = len(indexes)\\n        \\n        if m == 0: return [0, 2]\\n        \\n        if m % 3 != 0: return [-1, -1]\\n        p1, p2 = indexes[0], indexes[m//3-1]\\n        p3, p4 = indexes[m//3], indexes[2*m//3-1]\\n        p5, p6 = indexes[2*m//3], indexes[-1]\\n        part1, part2, part3 = A[p1:p2+1], A[p3:p4+1], A[p5:p6+1]\\n        \\n        if part1 != part2 or part2 != part3: return [-1, -1]\\n        \\n        l1 = p3 - p2 - 1\\n        l2 = p5 - p4 - 1\\n        l3 = n - p6 - 1\\n        \\n        if l3 > l2 or l3 > l1: return [-1, -1]\\n        \\n        return [p2 + l3, p4 + l3 + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250203,
                "title": "logical-thinking",
                "content": "> What is \\'same binary value\\' like? \\n> Digits following first 1 in each part should be identical. \\n\\n> How could we decide which 1 is the first 1 of a divided part?\\n> \\n> Assuming `numOnes` is number of 1s in A, each part should be with `numOnesPerPart = numOnes / 3` 1s. \\n> So the first \\'1\\' in  left part is `1`st \\'1\\', first \\'1\\' in middle part is `numOnesPerPart + 1`th \\'1\\', first \\'1\\' in right part is `numOnesPerPart * 2 + 1`th \\'1\\'.\\n>\\n> Then we compare the rest part digit by digit. Hopefully, the pointer in right part will reach A.length, which means we can make three equal parts.\\n> \\n>There is a corner case such as all elements in A are 0s.\\n****\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        int numOnes = countOnes(A);\\n        if (numOnes % 3 != 0) return new int[]{-1, -1};\\n        else {\\n            int numOnesPerPart = numOnes / 3;\\n            \\n            // Set pointers at first one in each part.\\n            int leftPtr = locateOne(A, 1), midPtr = locateOne(A, numOnesPerPart + 1), rightPtr = locateOne(A, numOnesPerPart * 2 + 1);\\n            \\n            // Compare 3 parts digit by digit.\\n            while (leftPtr < midPtr && midPtr < rightPtr && rightPtr < A.length) {\\n                if (A[leftPtr] == A[midPtr] && A[rightPtr] == A[midPtr]) {\\n                    leftPtr++;\\n                    midPtr++;\\n                    rightPtr++;\\n                } else break;\\n            }\\n            \\n            if (rightPtr == A.length) return new int[]{leftPtr - 1, midPtr};\\n            else if (rightPtr == 0) return new int[]{0, A.length - 1};\\n            else return new int[]{-1, -1};\\n        }\\n    }\\n    \\n    private int countOnes(int[] A) {\\n        int numOnes = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                numOnes++;\\n            }\\n        }\\n        return numOnes;        \\n    }\\n    \\n    private int locateOne(int[] A, int targetOne) {\\n        int cntOne = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                cntOne++;\\n                if (cntOne == targetOne) return i;\\n            }\\n        }\\n        return 0; // When all elements in A are 0.\\n    }\\n}\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        int numOnes = countOnes(A);\\n        if (numOnes % 3 != 0) return new int[]{-1, -1};\\n        else {\\n            int numOnesPerPart = numOnes / 3;\\n            \\n            // Set pointers at first one in each part.\\n            int leftPtr = locateOne(A, 1), midPtr = locateOne(A, numOnesPerPart + 1), rightPtr = locateOne(A, numOnesPerPart * 2 + 1);\\n            \\n            // Compare 3 parts digit by digit.\\n            while (leftPtr < midPtr && midPtr < rightPtr && rightPtr < A.length) {\\n                if (A[leftPtr] == A[midPtr] && A[rightPtr] == A[midPtr]) {\\n                    leftPtr++;\\n                    midPtr++;\\n                    rightPtr++;\\n                } else break;\\n            }\\n            \\n            if (rightPtr == A.length) return new int[]{leftPtr - 1, midPtr};\\n            else if (rightPtr == 0) return new int[]{0, A.length - 1};\\n            else return new int[]{-1, -1};\\n        }\\n    }\\n    \\n    private int countOnes(int[] A) {\\n        int numOnes = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                numOnes++;\\n            }\\n        }\\n        return numOnes;        \\n    }\\n    \\n    private int locateOne(int[] A, int targetOne) {\\n        int cntOne = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                cntOne++;\\n                if (cntOne == targetOne) return i;\\n            }\\n        }\\n        return 0; // When all elements in A are 0.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343092,
                "title": "three-equal-parts-c-easy-solution-with-approach",
                "content": "# **APPROACH**\\n1. Store every 1\\'s position in a vector.\\n2. It is easy to know the first 1\\'s position of three parts as [x, y, z].\\n3. Then verify three parts whether equal\\n\\n***NOTE:***\\n* If in cases where number of ones are not a multiple of 3, there will be no case of equal parts so return {-1,-1}\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int n = arr.size() ;\\n        vector<int> one ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(arr[i])\\n            {\\n                one.push_back(i) ;\\n            }\\n        }\\n        int cnt = one.size() ;\\n        if(cnt == 0)\\n        {\\n            return {0 , n - 1} ;\\n        }\\n        if(cnt%3)          //IF NUMBER OF ONES IS NOT A MULTIPLE OF 3\\n        {\\n            return {-1 , -1} ;\\n        }\\n        int s = one[0] , t = one[cnt/3] , u = one[(cnt/3)*2] ;\\n        while(u < n && arr[s] == arr[t] && arr[s] == arr[u])\\n        {\\n            s++ ;\\n            t++ ;\\n            u++ ;\\n        }\\n        if(u == n)\\n        {\\n            return {s - 1 , t} ;\\n        }\\n        return {-1 , -1} ;\\n    }\\n};\\n```\\n**Time Complexity:  O(n)**\\n**Space Complexity:  O(n)**\\n# **Update:**\\nThis is the general approach once we know that number of ones are a multiple of three -->\\nWe can form intervals for `s , t & u` let\\'s say, `[i1, j1], [i2, j2], [i3, j3]` \\n__If there is only 3 ones, then this interval length will be one__\\nSo the **zeroes after \"one, on the position of u\"** *let\\'s assume z* , must be included in each part (i.e. in s & t)\\nMaking the new intervals, `[i1, j1+z] & [i2, j2+z]` for s & t respectively\\nIf all this is actually possible, then the final answer is **[j1+z , j2+z+1].**\\nHope this helps",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int n = arr.size() ;\\n        vector<int> one ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(arr[i])\\n            {\\n                one.push_back(i) ;\\n            }\\n        }\\n        int cnt = one.size() ;\\n        if(cnt == 0)\\n        {\\n            return {0 , n - 1} ;\\n        }\\n        if(cnt%3)          //IF NUMBER OF ONES IS NOT A MULTIPLE OF 3\\n        {\\n            return {-1 , -1} ;\\n        }\\n        int s = one[0] , t = one[cnt/3] , u = one[(cnt/3)*2] ;\\n        while(u < n && arr[s] == arr[t] && arr[s] == arr[u])\\n        {\\n            s++ ;\\n            t++ ;\\n            u++ ;\\n        }\\n        if(u == n)\\n        {\\n            return {s - 1 , t} ;\\n        }\\n        return {-1 , -1} ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344101,
                "title": "c-o-n-commented-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        \\n        int ones = 0;\\n        int n  = arr.size();\\n        \\n        for(int i : arr){\\n            if(i==1)\\n                ones++;\\n        }\\n        \\n        //if no ones\\n        if(ones == 0) return {0,n-1};\\n        //if irregular ones, that cannot be divided in 3 parts\\n        if(ones%3!=0) return {-1,-1};\\n        \\n        int k = ones/3;\\n        \\n        //we find the starting position of 3 parts since leading zeroes does not matter\\n        int firstOne = -1, secondOne = -1, thirdOne = -1;\\n        int cnt1 = 0, cnt2 = 0, cnt3 = 0;\\n        \\n        //Find first one\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1){\\n                firstOne = i;\\n                break;\\n            }\\n        }\\n        //Find second one\\n        for(int i=firstOne+1;i<n;i++){\\n            if(arr[i]==1) cnt2++;\\n            if(arr[i]==1 && cnt2==k){\\n                secondOne = i;\\n                break;\\n            }\\n        }\\n        //Find third one\\n        for(int i=secondOne+1;i<n;i++){\\n            if(arr[i]==1) cnt3++;\\n            if(arr[i]==1 && cnt3==k){\\n                thirdOne = i;\\n                break;\\n            }\\n        }\\n        \\n        //checking if they are equal\\n        int x = firstOne, y = secondOne, z = thirdOne;\\n        while(x<n && y<n && z<n){\\n            if(arr[x] == arr[y] && arr[y] == arr[z]){\\n                x++;y++;z++;\\n            }\\n            else\\n                return {-1,-1};\\n        }\\n        \\n        //after the while loop we\\'ll have the\\n        //    |      |\\n        //  1 | 0 1  | 0 1\\n        //    |      |\\n        //      ^      ^    ^\\n        //      |      |    |\\n        //      x      y    z\\n\\n        return {x-1,y};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        \\n        int ones = 0;\\n        int n  = arr.size();\\n        \\n        for(int i : arr){\\n            if(i==1)\\n                ones++;\\n        }\\n        \\n        //if no ones\\n        if(ones == 0) return {0,n-1};\\n        //if irregular ones, that cannot be divided in 3 parts\\n        if(ones%3!=0) return {-1,-1};\\n        \\n        int k = ones/3;\\n        \\n        //we find the starting position of 3 parts since leading zeroes does not matter\\n        int firstOne = -1, secondOne = -1, thirdOne = -1;\\n        int cnt1 = 0, cnt2 = 0, cnt3 = 0;\\n        \\n        //Find first one\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1){\\n                firstOne = i;\\n                break;\\n            }\\n        }\\n        //Find second one\\n        for(int i=firstOne+1;i<n;i++){\\n            if(arr[i]==1) cnt2++;\\n            if(arr[i]==1 && cnt2==k){\\n                secondOne = i;\\n                break;\\n            }\\n        }\\n        //Find third one\\n        for(int i=secondOne+1;i<n;i++){\\n            if(arr[i]==1) cnt3++;\\n            if(arr[i]==1 && cnt3==k){\\n                thirdOne = i;\\n                break;\\n            }\\n        }\\n        \\n        //checking if they are equal\\n        int x = firstOne, y = secondOne, z = thirdOne;\\n        while(x<n && y<n && z<n){\\n            if(arr[x] == arr[y] && arr[y] == arr[z]){\\n                x++;y++;z++;\\n            }\\n            else\\n                return {-1,-1};\\n        }\\n        \\n        //after the while loop we\\'ll have the\\n        //    |      |\\n        //  1 | 0 1  | 0 1\\n        //    |      |\\n        //      ^      ^    ^\\n        //      |      |    |\\n        //      x      y    z\\n\\n        return {x-1,y};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677626,
                "title": "python-o-n-straightforward-solution",
                "content": "The solution is inspired by this [Logical Thinking](https://leetcode.com/problems/three-equal-parts/discuss/250203/Logical-Thinking).\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        \\n        num_ones = sum(A)\\n        \\n        if num_ones == 0:\\n            return [0, 2]\\n        \\n        if num_ones % 3 != 0:\\n            return [-1, -1]\\n        \\n        c = 0\\n        s1 = s2 = s3 = -1\\n        for idx,x in enumerate(A):\\n\\t\\t\\t# Find the first 1 in each part\\n            if x == 1:\\n                c += 1\\n            \\n            if c == 1 and s1 < 0:\\n                s1 = idx\\n                \\n            if c == num_ones//3 + 1 and s2 < 0:\\n                s2 = idx\\n                \\n            if c == num_ones*2//3 + 1 and s3 < 0:\\n                s3 = idx\\n                break\\n                \\n        n = len(A[s3:]) # The length of each part when all the leading 0\\'s are removed\\n        \\n        if A[s1:s1+n] == A[s2:s2+n] and A[s2:s2+n] == A[s3:]:\\n            return [s1+n-1, s2+n]\\n        else:\\n            return [-1, -1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        \\n        num_ones = sum(A)\\n        \\n        if num_ones == 0:\\n            return [0, 2]\\n        \\n        if num_ones % 3 != 0:\\n            return [-1, -1]\\n        \\n        c = 0\\n        s1 = s2 = s3 = -1\\n        for idx,x in enumerate(A):\\n\\t\\t\\t# Find the first 1 in each part\\n            if x == 1:\\n                c += 1\\n            \\n            if c == 1 and s1 < 0:\\n                s1 = idx\\n                \\n            if c == num_ones//3 + 1 and s2 < 0:\\n                s2 = idx\\n                \\n            if c == num_ones*2//3 + 1 and s3 < 0:\\n                s3 = idx\\n                break\\n                \\n        n = len(A[s3:]) # The length of each part when all the leading 0\\'s are removed\\n        \\n        if A[s1:s1+n] == A[s2:s2+n] and A[s2:s2+n] == A[s3:]:\\n            return [s1+n-1, s2+n]\\n        else:\\n            return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183991,
                "title": "c-o-n-time-o-n-space-40ms-14-lines-2-loops-easy-understand-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        vector<int> dp;\\n        for(int i = 0 ; i < A.size(); i++) // this loop is used to store the index of all 1s\\n            if(A[i]) dp.push_back(i);\\n        if(dp.size() % 3) return {-1, -1}; // if the number of 1s cannot be devided perfectly by 3, the input is invalid\\n\\tif(dp.empty()) return {0,2}; // if the number of 1 is zero, then it is natually valid, return {0, 2}\\n        int l1 = 0, l2 = dp.size() / 3, l3 = l2 * 2; //if we want to devide into 3 parts, the distribution pattern of 1s in three parts should be the same\\n        for(int i = 1; i < l2; i++ ) {\\n            int diff = dp[i] - dp[i-1];\\n            if(dp[l2+i] - dp[l2+i-1] != diff || dp[l3+i] - dp[l3+i-1] != diff) //unmatched pattern\\n                return {-1, -1};\\n\\t}\\n        int tail0 = A.size() - dp.back(); // calculate how many 0s tail\\n        if(dp[l3] - dp[l3-1] < tail0 ||   dp[l2] - dp[l2-1] < tail0) return {-1,-1};// all three parts should tail with the same number of 0s with that in the last part\\n        return {dp[l2-1] + tail0 - 1, dp[l3-1] + tail0};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        vector<int> dp;\\n        for(int i = 0 ; i < A.size(); i++) // this loop is used to store the index of all 1s\\n            if(A[i]) dp.push_back(i);\\n        if(dp.size() % 3) return {-1, -1}; // if the number of 1s cannot be devided perfectly by 3, the input is invalid\\n\\tif(dp.empty()) return {0,2}; // if the number of 1 is zero, then it is natually valid, return {0, 2}\\n        int l1 = 0, l2 = dp.size() / 3, l3 = l2 * 2; //if we want to devide into 3 parts, the distribution pattern of 1s in three parts should be the same\\n        for(int i = 1; i < l2; i++ ) {\\n            int diff = dp[i] - dp[i-1];\\n            if(dp[l2+i] - dp[l2+i-1] != diff || dp[l3+i] - dp[l3+i-1] != diff) //unmatched pattern\\n                return {-1, -1};\\n\\t}\\n        int tail0 = A.size() - dp.back(); // calculate how many 0s tail\\n        if(dp[l3] - dp[l3-1] < tail0 ||   dp[l2] - dp[l2-1] < tail0) return {-1,-1};// all three parts should tail with the same number of 0s with that in the last part\\n        return {dp[l2-1] + tail0 - 1, dp[l3-1] + tail0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184040,
                "title": "python-easy-understand-solution-with-explanation",
                "content": "The idea is pretty straight forward, you just need some obervation before coding.\\n1. If the solution exists, the number of 1 in list should be times of 3.\\n2. Since the ending zeros affect the binary value ([1,1] != [1,1, 0]) and the leading zeros mean nothing, we can find the value of each part (I called potential in the following code) if we scan the list from the end to the beginning.\\n3. After we find this number, things become easier. we just need to find the effective points of each part (I mean the position of first 1), we can locate the end of each part. Then the answer is just some calculation.\\n```\\ndef threeEqualParts(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        c1 = A.count(1)\\n        if c1%3: return [-1, -1]\\n        if c1 == 0: return [0, len(A)-1]\\n        n1 = c1/3\\n        potential = []\\n        count = 0\\n\\t\\t\\t\\t# find the value of each part\\n        for a in A[::-1]:\\n            potential.insert(0, a)\\n            if a == 1:\\n                count += 1\\n                if count == n1:\\n                    break\\n        lp = len(potential)\\n        temp = []\\n        i = 0\\n\\t\\t\\t\\t# find the effective beginning of each part\\n        while i < (len(A)-lp):\\n            if A[i] == 1 and A[i:i+lp] == potential:\\n                temp.append(i)\\n                i += lp\\n            elif A[i] == 0:\\n                i += 1\\n            else:\\n                return [-1, -1]\\n        ans = [temp[0]+lp-1, temp[1]+lp]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef threeEqualParts(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        c1 = A.count(1)\\n        if c1%3: return [-1, -1]\\n        if c1 == 0: return [0, len(A)-1]\\n        n1 = c1/3\\n        potential = []\\n        count = 0\\n\\t\\t\\t\\t# find the value of each part\\n        for a in A[::-1]:\\n            potential.insert(0, a)\\n            if a == 1:\\n                count += 1\\n                if count == n1:\\n                    break\\n        lp = len(potential)\\n        temp = []\\n        i = 0\\n\\t\\t\\t\\t# find the effective beginning of each part\\n        while i < (len(A)-lp):\\n            if A[i] == 1 and A[i:i+lp] == potential:\\n                temp.append(i)\\n                i += lp\\n            elif A[i] == 0:\\n                i += 1\\n            else:\\n                return [-1, -1]\\n        ans = [temp[0]+lp-1, temp[1]+lp]\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 183902,
                "title": "java-o-n-solution",
                "content": "```\n// The solution can be optimized to O(1) space, by not using StringBuilder, but only record the index of  the first one digit of the right part.\n\nclass Solution {\n    public int[] threeEqualParts(int[] A) {\n        if (A == null || A.length < 3) return new int[] {-1, -1};\n        int n = A.length;\n        int cntOneBit = 0;\n        \n        for (int b : A) {\n            if (b == 1) cntOneBit++;\n        }\n        if (cntOneBit % 3 != 0) return new int[] {-1, -1};\n        \n        int cnt = cntOneBit / 3;\n        if (cnt == 0) return new int[] {0, n - 1};\n    \n        //construct the string using the right most part;\n        int j = n - 1, cntR = 0;\n        StringBuilder suffix = new StringBuilder();\n        for (;j >= 0 && cntR < cnt; j--) {\n            suffix.append(A[j]);\n            if (A[j] == 1) cntR++;\n         } \n    \n        String target = suffix.reverse().toString();\n        \n        //matching the left part with target string, omit all leading zero\n        int i = 0;\n        while (A[i] == 0) i++;\n    \n        int k = 0;\n        while (k < target.length()) {\n            if (A[i + k] == target.charAt(k) - '0') k++;\n            else return new int[] {-1, -1};\n        }\n        int left = i + k -1;\n        \n        //matching the middle part with target string, omit all leading zero\n        i = i + k;\n        while (A[i] == 0) i++;\n        k = 0;\n        while (k < target.length()) {\n        if (A[i + k] == target.charAt(k) - '0') k++;\n            else return new int[] {-1, -1};\n        }    \n        return new int[] {left, i + k}; \n    }\n}",
                "solutionTags": [],
                "code": "class Solution {\n    public int[] threeEqualParts(int[] A) {\n        if (A == null || A.length < 3) return new int[] {-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 184580,
                "title": "java-10ms-solution-with-o-n-time-and-o-1-space",
                "content": "It is obviously that if the array can be divided into three part. The 1\\'s number in each should be same. Besides, the 0\\'s number in the last part should be the true 0\\'s number in the end of each part.\\nWe get the 1\\'s number and divide them into 3 parts. If numOf1 % 3 is not a integer then just return [-1, -1]. Suppose the number of 1 is 3n. The three parts should shart from the first 1, the n + 1th 1 and the 2n + 1th 1. Then we just compare all of them with the last part and can get the answer easily.\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        int[] res = new int[2];\\n        res[0] = -1;\\n        res[1] = -1;\\n        // num Of 1\\n        int numOf1 = 0;\\n        for (int a : A) {\\n            if (a == 1) {\\n                numOf1++;\\n            }\\n        }\\n        \\n        if (numOf1 == 0) {\\n            return new int[]{0, 2};\\n        }\\n        \\n        if (numOf1 % 3 != 0) {\\n            return res;\\n        }\\n        \\n        int partLength = numOf1 / 3;\\n        int index0 = -1;\\n        int index1 = -1;\\n        int index2 = -1;\\n        numOf1 = 0;\\n        for (int i = 0; i < A.length; i ++) {\\n            if (A[i] == 1) {\\n                numOf1++;\\n                if (numOf1 == partLength + 1) {\\n                    index1 = i;\\n                } else if (numOf1 == 2 * partLength + 1) {\\n                    index2 = i;\\n                } else if (numOf1 == 1) {\\n                    index0 = i;\\n                }\\n            }\\n        }\\n       \\n        while (index2 < A.length) {\\n            if (A[index2] == A[index0] && A[index2] == A[index1]) {\\n                index2++;\\n                index1++;\\n                index0++;\\n            } else {\\n                return res;\\n            }\\n        }\\n        \\n        return new int[]{index0 - 1, index1};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        int[] res = new int[2];\\n        res[0] = -1;\\n        res[1] = -1;\\n        // num Of 1\\n        int numOf1 = 0;\\n        for (int a : A) {\\n            if (a == 1) {\\n                numOf1++;\\n            }\\n        }\\n        \\n        if (numOf1 == 0) {\\n            return new int[]{0, 2};\\n        }\\n        \\n        if (numOf1 % 3 != 0) {\\n            return res;\\n        }\\n        \\n        int partLength = numOf1 / 3;\\n        int index0 = -1;\\n        int index1 = -1;\\n        int index2 = -1;\\n        numOf1 = 0;\\n        for (int i = 0; i < A.length; i ++) {\\n            if (A[i] == 1) {\\n                numOf1++;\\n                if (numOf1 == partLength + 1) {\\n                    index1 = i;\\n                } else if (numOf1 == 2 * partLength + 1) {\\n                    index2 = i;\\n                } else if (numOf1 == 1) {\\n                    index0 = i;\\n                }\\n            }\\n        }\\n       \\n        while (index2 < A.length) {\\n            if (A[index2] == A[index0] && A[index2] == A[index1]) {\\n                index2++;\\n                index1++;\\n                index0++;\\n            } else {\\n                return res;\\n            }\\n        }\\n        \\n        return new int[]{index0 - 1, index1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343709,
                "title": "2-clean-python-linear-solutions",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # count number of ones\\n        ones = sum(arr)\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        elif ones == 0:  # special case: all zeros\\n            return [0, 2]\\n        \\n        # find the start index of each group of ones\\n        c = 0\\n        starts = []\\n        for i, d in enumerate(arr):\\n            if d == 1:\\n                if c % (ones // 3) == 0:\\n                    starts.append(i)\\n                c += 1\\n\\n        # scan the groups in parallel to compare digits\\n        i, j, k = starts\\n        while k < len(arr):  # note that the last/rightmost group must include all digits till the end\\n            if arr[i] == arr[j] == arr[k]:\\n                i += 1\\n                j += 1\\n                k += 1\\n            else:\\n                return [-1, -1]\\n        return [i-1, j]\\n```\\nRuntime: *O(n)*\\nSpace: *O(1)*\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # gather the indices of the ones\\n        ones = [i for i, d in enumerate(arr) if d == 1]\\n\\n        if not ones:\\n            return [0, 2]\\n        elif len(ones) % 3 != 0:\\n            return [-1, -1]\\n\\n        # get the start indices of the 3 groups\\n        i, j, k = ones[0], ones[len(ones)//3], ones[len(ones)//3*2]\\n\\n        # calculate the size/length of what each group should be\\n        length = len(arr) - k  # note that the last/rightmost group must include all digits till the end\\n                               # so we know that the size of each group is `len(arr) - k` (where `k` is start of third group)\\n\\n        # compare the three groups\\n        if arr[i:i+length] == arr[j:j+length] == arr[k:k+length]:\\n            return [i+length-1, j+length]\\n        \\n        return [-1, -1]\\n```\\nRuntime: *O(n)*\\nSpace: *O(n)*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # count number of ones\\n        ones = sum(arr)\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        elif ones == 0:  # special case: all zeros\\n            return [0, 2]\\n        \\n        # find the start index of each group of ones\\n        c = 0\\n        starts = []\\n        for i, d in enumerate(arr):\\n            if d == 1:\\n                if c % (ones // 3) == 0:\\n                    starts.append(i)\\n                c += 1\\n\\n        # scan the groups in parallel to compare digits\\n        i, j, k = starts\\n        while k < len(arr):  # note that the last/rightmost group must include all digits till the end\\n            if arr[i] == arr[j] == arr[k]:\\n                i += 1\\n                j += 1\\n                k += 1\\n            else:\\n                return [-1, -1]\\n        return [i-1, j]\\n```\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # gather the indices of the ones\\n        ones = [i for i, d in enumerate(arr) if d == 1]\\n\\n        if not ones:\\n            return [0, 2]\\n        elif len(ones) % 3 != 0:\\n            return [-1, -1]\\n\\n        # get the start indices of the 3 groups\\n        i, j, k = ones[0], ones[len(ones)//3], ones[len(ones)//3*2]\\n\\n        # calculate the size/length of what each group should be\\n        length = len(arr) - k  # note that the last/rightmost group must include all digits till the end\\n                               # so we know that the size of each group is `len(arr) - k` (where `k` is start of third group)\\n\\n        # compare the three groups\\n        if arr[i:i+length] == arr[j:j+length] == arr[k:k+length]:\\n            return [i+length-1, j+length]\\n        \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344503,
                "title": "three-equal-parts-java-easy-to-understand-detailed-approach",
                "content": "**Intuition**\\n* We can easily see that in order for the array to have equal parts, in each part the number of ones should be equal.\\n* The above implies that the `totalOnes` should be divisible by 3.\\n* Now lets understand of basic cases\\n* `totalOnes = 0`: If this is the case any two indices can divide into 3 equal parts since all will be zero\\n* `totalOnes%3 !=0 `: Since total ones is not divisble solution is not possible, so we return `[-1,-1]`\\n* Next we know that each part will have `k = totalOnes/3` ones. Also if we start from the end the target which we want for each part will start as soon as we have taken `k` ones. So we can keep track of this index from where target starts. ***Note***: This index might not be the index `j` as there can be leading zeroes which will not change the target.\\n* Now we have to find if its possible to build the same target from start to the end.\\n* Now to get the index `i` we can start from index `0` and move to the index of first `1` (What we do here is ignore leading zeroes). Now we start comparing elements from the target index and index i. If its equal then this part can be equal to target.\\n* We do the similar operation for the second part.\\n\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int totalOnes = 0;\\n        for(int e:arr){\\n            if(e==1){\\n                totalOnes++;\\n            }\\n        }\\n        \\n        int l = arr.length;\\n        if(totalOnes==0){\\n            return new int[] {0, l-1};\\n        }\\n        if(totalOnes%3!=0){\\n            return new int[] {-1,-1};\\n        }\\n        \\n        int k=totalOnes/3; // Each part will have k number of 1\\'s\\n        int targetIdx = l; // This first index of \\'1\\' which starts the equal part\\n        \\n        while(k>0){\\n            targetIdx--;\\n            if(arr[targetIdx]==1){\\n                k--;\\n            }\\n        }\\n        \\n        int i = isPartPossible(arr, 0, targetIdx);\\n        if(i==-1){\\n            return new int[] {-1,-1};\\n        }\\n        int j = isPartPossible(arr, i, targetIdx);\\n        if(j==-1){\\n            return new int[] {-1,-1};\\n        }\\n        \\n        return new int[] {i-1,j};\\n    }\\n    \\n    private int isPartPossible(int[] arr, int i, int start) {\\n        while(arr[i]==0){\\n            i++;\\n        }\\n        while(start<arr.length){\\n            if(arr[i]!=arr[start]) {\\n                return -1;\\n            }\\n            i++;\\n            start++;\\n        }\\n        return i;\\n    }\\n}\\n```\\n\\nPS: Please upvote if you think it can help others to understand this question.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int totalOnes = 0;\\n        for(int e:arr){\\n            if(e==1){\\n                totalOnes++;\\n            }\\n        }\\n        \\n        int l = arr.length;\\n        if(totalOnes==0){\\n            return new int[] {0, l-1};\\n        }\\n        if(totalOnes%3!=0){\\n            return new int[] {-1,-1};\\n        }\\n        \\n        int k=totalOnes/3; // Each part will have k number of 1\\'s\\n        int targetIdx = l; // This first index of \\'1\\' which starts the equal part\\n        \\n        while(k>0){\\n            targetIdx--;\\n            if(arr[targetIdx]==1){\\n                k--;\\n            }\\n        }\\n        \\n        int i = isPartPossible(arr, 0, targetIdx);\\n        if(i==-1){\\n            return new int[] {-1,-1};\\n        }\\n        int j = isPartPossible(arr, i, targetIdx);\\n        if(j==-1){\\n            return new int[] {-1,-1};\\n        }\\n        \\n        return new int[] {i-1,j};\\n    }\\n    \\n    private int isPartPossible(int[] arr, int i, int start) {\\n        while(arr[i]==0){\\n            i++;\\n        }\\n        while(start<arr.length){\\n            if(arr[i]!=arr[start]) {\\n                return -1;\\n            }\\n            i++;\\n            start++;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344636,
                "title": "c-easy-clean-solution",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& ar) {\\n        int cnt0 = 0, cnt1 = 0;\\n        for(auto i: ar){\\n            if(i)\\n                cnt1++;\\n            else\\n                cnt0++;\\n        }\\n        \\n        if(cnt1 % 3 != 0)\\n            return {-1, -1};\\n        else\\n        {\\n            if(cnt1 == 0){\\n                return {0, 2};\\n            }\\n            else{\\n                int k = cnt1 / 3;\\n                int one = 0, two = 0, three = 0;\\n                int cnt = 0;\\n                for(int i = 0; i < ar.size(); i++){\\n                    if(ar[i]){\\n                        if(cnt == 0)\\n                            one = i;\\n                        cnt++;\\n                        \\n                        if(cnt == k + 1)\\n                            two = i;\\n                        \\n                        if(cnt == 2 * k + 1){\\n                            three = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                //now we have 3 indices.......\\n                //check if each increment in the indices results in similar integer 0/1....\\n                \\n                while(1){\\n                    if(ar[one] != ar[two] or ar[two] != ar[three] or three == ar.size())\\n                        break;\\n                    \\n                    one++;\\n                    two++;\\n                    three++;\\n                }\\n                \\n                if(three == ar.size())\\n                    return {one - 1, two};\\n                else\\n                    return {-1, -1};\\n            }     \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& ar) {\\n        int cnt0 = 0, cnt1 = 0;\\n        for(auto i: ar){\\n            if(i)\\n                cnt1++;\\n            else\\n                cnt0++;\\n        }\\n        \\n        if(cnt1 % 3 != 0)\\n            return {-1, -1};\\n        else\\n        {\\n            if(cnt1 == 0){\\n                return {0, 2};\\n            }\\n            else{\\n                int k = cnt1 / 3;\\n                int one = 0, two = 0, three = 0;\\n                int cnt = 0;\\n                for(int i = 0; i < ar.size(); i++){\\n                    if(ar[i]){\\n                        if(cnt == 0)\\n                            one = i;\\n                        cnt++;\\n                        \\n                        if(cnt == k + 1)\\n                            two = i;\\n                        \\n                        if(cnt == 2 * k + 1){\\n                            three = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                //now we have 3 indices.......\\n                //check if each increment in the indices results in similar integer 0/1....\\n                \\n                while(1){\\n                    if(ar[one] != ar[two] or ar[two] != ar[three] or three == ar.size())\\n                        break;\\n                    \\n                    one++;\\n                    two++;\\n                    three++;\\n                }\\n                \\n                if(three == ar.size())\\n                    return {one - 1, two};\\n                else\\n                    return {-1, -1};\\n            }     \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343907,
                "title": "java-solution-with-detailed-comments-examples",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ones = 0;\\n        for (int i : arr) if (i == 1) ones++;\\n\\n\\t\\t/**\\n\\t\\t * The first base case is a hardcoded case when there are only zeros in the array. \\n\\t\\t * Since the array size is at least 3 in the case of only zeros there are still available to cut the array and get three equal binary numbers. \\n\\t\\t * e.g. [0, 0, 0] we can devide into three parts |0, 0, 0| and those numbers are correct binary numbers. \\n\\t\\t * e.g. [0, 0, 0, 0, 0, ...] we can devide into three parts |0, 0, 0...| and those numbers are correct binary numbers. \\n\\t\\t\\n\\t\\t * arr = [0, 0, 0, 0, 0, ...]\\n\\t\\t * ind = [0, 1, 2, 3, 4]\\n         * i = 0 and j = 2 because first part is 0 - 0(0, i) indexes, second part is 1 - 1(i + 1, j - 1) indexes and third part is 2 - 2(j, n - 1) indexes\\n\\t\\t\\n\\t\\t * So taking into consideration above answer [0, 2] is the first correct answer that we can get in the case of only zeros. \\n\\t\\t*/\\n        if (ones == 0) return new int[]{0, 2};\\n\\t\\t\\n\\t\\t/**\\n\\t\\t * If there are ones in an array they should be dividable on 3. \\n\\t\\t * This is because we need to divide the array into three parts \\n\\t\\t * and each part should have the same amount of ones \\n\\t\\t * in the case of binary numbers to be equal\\n\\t\\t*/\\n        if (ones % 3 != 0) return new int[]{-1, -1};\\n\\n\\t\\t/**\\n\\t\\t* This is the most trickier part of this solution.\\n\\t\\t*  Basically what we are doing here is we are looking for the first occurrence of \\'1\\' for each chunk. \\n\\t\\t*  Let\\'s take an example: arr = [0, 1, 1, 0, | 0, 0, 1, 1, 0, | 1, 1, 0]\\n\\n\\t\\t* Since the count of ones is 6 and 6 / 3 = 2 it means that after every +2 index we are standing on the next chunk. 0 +, 2 +, 4 + ... \\n\\t\\t* Therefore:  \\n\\t\\t* First occurrence of \\'1\\' for the first chunk is on the index of 1\\n\\t\\t* First occurrence of \\'1\\' for the second chunk is on the index of 6\\n\\t\\t* First occurrence of \\'1\\' for the third chunk is on the index of 9\\n\\t\\t*/\\n        int point1 = 0, point2 = 0, point3 = 0;\\n        int unit = ones / 3;\\n        int oneCounter = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 1) {\\n                if (oneCounter == 0) point1 = i;\\n                else if (oneCounter == unit) point2 = i;\\n                else if (oneCounter == 2 * unit) point3 = i;\\n\\n                oneCounter++;\\n            }\\n        }\\n\\n\\t\\t/**\\n\\t\\t* The last part is pretty straightforward. \\n\\t\\t* We just need to start all pointers from the first occurrences of \\'1\\' and move three of them simultaneously to the right. \\n\\t\\t* As we know binary numbers are equals if all of their bits are equal. Otherwise we return {-1, -1}\\n\\t\\t*/\\n        while (point3 < arr.length) {\\n            if (arr[point1] != arr[point2] || arr[point2] != arr[point3]) return new int[]{-1, -1};\\n\\n            point1++;\\n            point2++;\\n            point3++;\\n        }\\n\\n        return new int[]{point1 - 1, point2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ones = 0;\\n        for (int i : arr) if (i == 1) ones++;\\n\\n\\t\\t/**\\n\\t\\t * The first base case is a hardcoded case when there are only zeros in the array. \\n\\t\\t * Since the array size is at least 3 in the case of only zeros there are still available to cut the array and get three equal binary numbers. \\n\\t\\t * e.g. [0, 0, 0] we can devide into three parts |0, 0, 0| and those numbers are correct binary numbers. \\n\\t\\t * e.g. [0, 0, 0, 0, 0, ...] we can devide into three parts |0, 0, 0...| and those numbers are correct binary numbers. \\n\\t\\t\\n\\t\\t * arr = [0, 0, 0, 0, 0, ...]\\n\\t\\t * ind = [0, 1, 2, 3, 4]\\n         * i = 0 and j = 2 because first part is 0 - 0(0, i) indexes, second part is 1 - 1(i + 1, j - 1) indexes and third part is 2 - 2(j, n - 1) indexes\\n\\t\\t\\n\\t\\t * So taking into consideration above answer [0, 2] is the first correct answer that we can get in the case of only zeros. \\n\\t\\t*/\\n        if (ones == 0) return new int[]{0, 2};\\n\\t\\t\\n\\t\\t/**\\n\\t\\t * If there are ones in an array they should be dividable on 3. \\n\\t\\t * This is because we need to divide the array into three parts \\n\\t\\t * and each part should have the same amount of ones \\n\\t\\t * in the case of binary numbers to be equal\\n\\t\\t*/\\n        if (ones % 3 != 0) return new int[]{-1, -1};\\n\\n\\t\\t/**\\n\\t\\t* This is the most trickier part of this solution.\\n\\t\\t*  Basically what we are doing here is we are looking for the first occurrence of \\'1\\' for each chunk. \\n\\t\\t*  Let\\'s take an example: arr = [0, 1, 1, 0, | 0, 0, 1, 1, 0, | 1, 1, 0]\\n\\n\\t\\t* Since the count of ones is 6 and 6 / 3 = 2 it means that after every +2 index we are standing on the next chunk. 0 +, 2 +, 4 + ... \\n\\t\\t* Therefore:  \\n\\t\\t* First occurrence of \\'1\\' for the first chunk is on the index of 1\\n\\t\\t* First occurrence of \\'1\\' for the second chunk is on the index of 6\\n\\t\\t* First occurrence of \\'1\\' for the third chunk is on the index of 9\\n\\t\\t*/\\n        int point1 = 0, point2 = 0, point3 = 0;\\n        int unit = ones / 3;\\n        int oneCounter = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 1) {\\n                if (oneCounter == 0) point1 = i;\\n                else if (oneCounter == unit) point2 = i;\\n                else if (oneCounter == 2 * unit) point3 = i;\\n\\n                oneCounter++;\\n            }\\n        }\\n\\n\\t\\t/**\\n\\t\\t* The last part is pretty straightforward. \\n\\t\\t* We just need to start all pointers from the first occurrences of \\'1\\' and move three of them simultaneously to the right. \\n\\t\\t* As we know binary numbers are equals if all of their bits are equal. Otherwise we return {-1, -1}\\n\\t\\t*/\\n        while (point3 < arr.length) {\\n            if (arr[point1] != arr[point2] || arr[point2] != arr[point3]) return new int[]{-1, -1};\\n\\n            point1++;\\n            point2++;\\n            point3++;\\n        }\\n\\n        return new int[]{point1 - 1, point2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343256,
                "title": "12-lines-js-solution-faster-than-100-js-solutions",
                "content": "First I found out how many ones are in the array. Then I checked if the array is dividable into 3 with the same amount of ones. Then I iterated from the end to find out the number. Once I had the number all I had to do is to validate if the sequence of first and second sets match.\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar threeEqualParts = function(arr) {\\n  const ones = arr.reduce((s, n) => s + n, 0);\\n  if (ones === 0) return [0, 2];\\n  if (ones % 3 !== 0) return [-1, -1];\\n  let onesToFind = ones / 3;\\n  let k = arr.length;\\n  while (onesToFind > 0) if (arr[--k] === 1) --onesToFind;\\n  const iter = arr.length - k;\\n  const firstOne = arr.indexOf(1);\\n  const secondOne = arr.indexOf(1, firstOne + iter);\\n  for (let i = 0; i < iter; i++)\\n    if (arr[i + firstOne] !== arr[k + i] || arr[i + secondOne] !== arr[k + i]) return [-1, -1];\\n  return [firstOne + iter - 1, secondOne + iter];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar threeEqualParts = function(arr) {\\n  const ones = arr.reduce((s, n) => s + n, 0);\\n  if (ones === 0) return [0, 2];\\n  if (ones % 3 !== 0) return [-1, -1];\\n  let onesToFind = ones / 3;\\n  let k = arr.length;\\n  while (onesToFind > 0) if (arr[--k] === 1) --onesToFind;\\n  const iter = arr.length - k;\\n  const firstOne = arr.indexOf(1);\\n  const secondOne = arr.indexOf(1, firstOne + iter);\\n  for (let i = 0; i < iter; i++)\\n    if (arr[i + firstOne] !== arr[k + i] || arr[i + secondOne] !== arr[k + i]) return [-1, -1];\\n  return [firstOne + iter - 1, secondOne + iter];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 694521,
                "title": "c-o-n-time-o-n-space-easy-to-implement",
                "content": "Store every 1\\'s position, easy to know the first 1\\'s position of three parts as [x, y, z].\\nThen verify three parts whether equal.\\n\\n```\\nclass Solution {\\npublic:\\nvector<int> threeEqualParts(vector<int>& v) {\\n  int n = v.size();\\n  vector<int> ones;\\n  for (int i = 0; i < n; ++i) if (v[i]) ones.push_back(i);\\n  int cnt = ones.size();\\n  if (!cnt) return {0, n - 1};\\n  if (cnt % 3) return {-1, -1};\\n  int x = ones[0], y = ones[cnt/3], z = ones[cnt/3*2];\\n  while (z < n && v[x] == v[y] && v[x] == v[z]) ++x, ++y, ++z;\\n  if (z == n) return {x-1, y};\\n  return {-1, -1};\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> threeEqualParts(vector<int>& v) {\\n  int n = v.size();\\n  vector<int> ones;\\n  for (int i = 0; i < n; ++i) if (v[i]) ones.push_back(i);\\n  int cnt = ones.size();\\n  if (!cnt) return {0, n - 1};\\n  if (cnt % 3) return {-1, -1};\\n  int x = ones[0], y = ones[cnt/3], z = ones[cnt/3*2];\\n  while (z < n && v[x] == v[y] && v[x] == v[z]) ++x, ++y, ++z;\\n  if (z == n) return {x-1, y};\\n  return {-1, -1};\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183880,
                "title": "python-o-n-108ms",
                "content": "```\nclass Solution:\n    def threeEqualParts(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        N = len(A)\n        if N < 3:\n            return [-1, -1]\n        \n        num_ones = sum(A)\n\t\t\t\t\n        if num_ones % 3 != 0:\n            return [-1, -1]\n        \n        if num_ones == 0:\n            return [0, 2]\n        \n        need_ones = num_ones // 3\n        str_input_reverse = ''.join(map(str, reversed(A)))\n        count_1 = 0\n        i = 0\n        while count_1 != need_ones:\n            if str_input_reverse[i] == '1':\n                count_1 += 1\n            i += 1\n            \n        second = str_input_reverse.find(str_input_reverse[:i], i)\n        if(second == -1):\n            return [-1, -1]\n        third = str_input_reverse.find(str_input_reverse[:i], second + i)\n        if(third == -1):\n            return [-1, -1]\n        return [N - 1 - third, N - second]\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def threeEqualParts(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        N = len(A)\n        if N < 3:\n            return [-1, -1]\n        \n        num_ones = sum(A)\n\t\t\t\t\n        if num_ones % 3 != 0:\n            return [-1, -1]\n        \n        if num_ones == 0:\n            return [0, 2]\n        \n        need_ones = num_ones // 3\n        str_input_reverse = ''.join(map(str, reversed(A)))\n        count_1 = 0\n        i = 0\n        while count_1 != need_ones:\n            if str_input_reverse[i] == '1':\n                count_1 += 1\n            i += 1\n            \n        second = str_input_reverse.find(str_input_reverse[:i], i)\n        if(second == -1):\n            return [-1, -1]\n        third = str_input_reverse.find(str_input_reverse[:i], second + i)\n        if(third == -1):\n            return [-1, -1]\n        return [N - 1 - third, N - second]\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104349,
                "title": "c-detailed-explanation-with-proofs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNot much intuitive as it does not invole any famous algorithm but a bit of observation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First and the only thing to notice is that if we have to divide the array into three parts with equal value then ***each part must have equal number of 1 in them.***\\nTake your time :) \\nProof->\\nAs each number must have equal value which means in binary form (After removing leading zeros ) each of them must be equivalent in the position of their bits.\\nAnd for all of them to be equivalent , the sufficient condition will be for them to have the equal number of set bits \\'1\\' in them, we can\\'t take zeros \\'0\\' as it can form leading zeros which will then become unsignificant.\\n\\n- So calculate the total number of ones and check for it to be a multiple of three. There will be a special case for 0 number of ones ( See the code for it ).\\nIf it\\'s a multiple of three then, again traverse the array to get the starting point of all the individual parts as\\n**First part -> first \\'1\\' index\\nsecond part -> total_one/3+1 th \\'1\\' index\\nthird part -> total_one/3 + total_one/3 + 1 th \\'1\\' index.**\\n\\n- Now we have our starting indexes we just have to check if we could actually make them equivalent and for that we simply traverse in our third part till last and correspondingly check the indices in first part and second part.\\nIf we reach the end of array ,which means we have the corresponding indices of each part equal, so we could actually divide them and the remaining values will serve as leading zeros for individual parts.\\n\\n***See the code for more details or try to dry run on any test case for better understanding.***\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ Traversing the array three times.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size(),ones=count(arr.begin(),arr.end(),1);\\n        if(ones==0) return {0,n-1}; // if full array is of zeros\\n        if(ones%3) return {-1,-1};\\n\\n        ones=ones/3; // calculating the size of each block with equal ones.\\n\\n\\n        int curr_one=0,first=-1,second=-1,third=-1;\\n        for(int i=0;i<n;i++) {\\n            if(arr[i]==1) curr_one++;\\n\\n            if(curr_one==1 and first==-1) first=i;\\n            else if(curr_one==ones+1 and second==-1) second=i;\\n            else if(curr_one==2*ones+1 and third==-1) third=i;\\n        }\\n\\n        int i,j,k;\\n        for(i=first,j=second,k=third;k<n;i++,j++,k++) {\\n            if(not (arr[i]==arr[j] and arr[j]==arr[k])) return {-1,-1};\\n        }\\n        return {i-1,j};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size(),ones=count(arr.begin(),arr.end(),1);\\n        if(ones==0) return {0,n-1}; // if full array is of zeros\\n        if(ones%3) return {-1,-1};\\n\\n        ones=ones/3; // calculating the size of each block with equal ones.\\n\\n\\n        int curr_one=0,first=-1,second=-1,third=-1;\\n        for(int i=0;i<n;i++) {\\n            if(arr[i]==1) curr_one++;\\n\\n            if(curr_one==1 and first==-1) first=i;\\n            else if(curr_one==ones+1 and second==-1) second=i;\\n            else if(curr_one==2*ones+1 and third==-1) third=i;\\n        }\\n\\n        int i,j,k;\\n        for(i=first,j=second,k=third;k<n;i++,j++,k++) {\\n            if(not (arr[i]==arr[j] and arr[j]==arr[k])) return {-1,-1};\\n        }\\n        return {i-1,j};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344393,
                "title": "c-python-observation-leads-to-solutions-3-pointer-solution",
                "content": "Approach 1:\\nTrain of thought [1]:\\nStep 1: observation: Find 1st 1 of 3rd sub-array\\nStep 2: locate the ending of 1st and 2nd sub-arrays\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int tot = 0;\\n        for(auto num: A) tot += num;\\n        if(tot % 3 != 0) return {-1, -1};\\n        int n = A.size();\\n        if(tot == 0) return {0, n - 1};\\n        \\n        int seg3_beg_candidate = n - 1;\\n        for(int i = n - 1, cnt = 0; i >= 0; i--){\\n            if(A[i]==1){\\n                cnt++;\\n                if(cnt == tot / 3){\\n                    seg3_beg_candidate = i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int seg1_end = findSegEnd(A, 0, seg3_beg_candidate);\\n        if(seg1_end == -1) return {-1, -1};\\n        int seg2_end = findSegEnd(A, seg1_end + 1, seg3_beg_candidate);\\n        if(seg2_end == -1) return {-1, -1};\\n        else return {seg1_end, seg2_end + 1};\\n    }\\n    \\nprivate:\\n    int findSegEnd(const vector<int>& A, int l, int r){\\n        while(A[l] == 0) l++;\\n        while(r < A.size()){\\n            if(A[l] != A[r]) return -1;\\n            l++; r++;\\n        }\\n        return l - 1;\\n    }\\n};\\n```\\n\\nApproach 2: 3-pointer [2]\\nThis might be the only 3-pointer type question out of  1009 questions solved by me.\\nThe solution is from [2] with clear step by step illustration.\\n```\\nstatic int x=[](){ios::sync_with_stdio(false); cin.tie(NULL); return 0;}();\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n\\t\\tint n = A.size();\\n        if(countNumberOfOnes == 0)      \\n            return {0, n -1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // find the first 1 in the array\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1)\\n                break;\\n        int start = i;\\n        \\n        // find (k+1)th 1 in the array\\n        int count1 = 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == k + 1)\\n                break;\\n        }\\n        int mid = i;\\n        \\n        //find (2*k +1)th 1 in the array\\n        count1= 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == 2*k + 1)\\n                break;\\n        }\\n        int end = i;\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end])\\n        {\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n```\\n\\nApproach 3: Compact version of Approach 2\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        int n = A.size();\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n        if(countNumberOfOnes == 0)      \\n            return {0, n -1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // start: the first 1 in the array\\n        // mid:   the (k+1)th 1 in the array\\n        // end:   the (2k+1)th 1 in the array\\n        int oneIdx = 0;\\n        int start, mid, end;\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1){\\n                ++oneIdx;\\n                if( oneIdx == 1) start = i;\\n                if( oneIdx == k + 1) mid = i;\\n                if( oneIdx == 2*k + 1) {end = i;break;}\\n            }\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end]){\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n```\\n\\nApproach 4: 8-line python [3]\\n```\\ndef threeEqualParts(self, nums: List[int]) -> List[int]:\\n\\tn = nums.count(1)\\n\\tif n == 0: return [0, 2] # any split would satify\\n\\tif n % 3 != 0: return [-1, -1]\\n\\tidx = [i for i, num in enumerate(nums) if num == 1]\\n\\ts1, e1, s2, e2, s3, e3 = idx[0], idx[n//3-1], idx[n//3], idx[2*n//3-1], idx[2*n//3], idx[n-1]\\n\\ttracingZeros = len(nums) - 1 - e3\\n\\tif e1 + tracingZeros >= s2 or e2 + tracingZeros >= s3 or not nums[s1: e1] == nums[s2: e2] == nums[s3: e3]: return [-1, -1]\\n\\treturn [e1 + tracingZeros, e2 + tracingZeros + 1]\\n\\n```\\nReference:\\n[1] https://www.cnblogs.com/grandyang/p/12107091.html\\n[2] https://leetcode.com/problems/three-equal-parts/discuss/183922/C%2B%2B-O(n)-time-O(1)-space-12-ms-with-explanation-and-comments\\n[3] https://leetcode.com/problems/three-equal-parts/discuss/677626/Python-O(n)-Straightforward-Solution\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int tot = 0;\\n        for(auto num: A) tot += num;\\n        if(tot % 3 != 0) return {-1, -1};\\n        int n = A.size();\\n        if(tot == 0) return {0, n - 1};\\n        \\n        int seg3_beg_candidate = n - 1;\\n        for(int i = n - 1, cnt = 0; i >= 0; i--){\\n            if(A[i]==1){\\n                cnt++;\\n                if(cnt == tot / 3){\\n                    seg3_beg_candidate = i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int seg1_end = findSegEnd(A, 0, seg3_beg_candidate);\\n        if(seg1_end == -1) return {-1, -1};\\n        int seg2_end = findSegEnd(A, seg1_end + 1, seg3_beg_candidate);\\n        if(seg2_end == -1) return {-1, -1};\\n        else return {seg1_end, seg2_end + 1};\\n    }\\n    \\nprivate:\\n    int findSegEnd(const vector<int>& A, int l, int r){\\n        while(A[l] == 0) l++;\\n        while(r < A.size()){\\n            if(A[l] != A[r]) return -1;\\n            l++; r++;\\n        }\\n        return l - 1;\\n    }\\n};\\n```\n```\\nstatic int x=[](){ios::sync_with_stdio(false); cin.tie(NULL); return 0;}();\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n\\t\\tint n = A.size();\\n        if(countNumberOfOnes == 0)      \\n            return {0, n -1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // find the first 1 in the array\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1)\\n                break;\\n        int start = i;\\n        \\n        // find (k+1)th 1 in the array\\n        int count1 = 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == k + 1)\\n                break;\\n        }\\n        int mid = i;\\n        \\n        //find (2*k +1)th 1 in the array\\n        count1= 0;\\n        for(i=0;i<A.size(); i++)\\n        {\\n            if(A[i] == 1)\\n                count1++;\\n            if(count1 == 2*k + 1)\\n                break;\\n        }\\n        int end = i;\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end])\\n        {\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n\\t    // Count no of 1\\'s in the given array\\n        int countNumberOfOnes = 0;\\n        int n = A.size();\\n        for(int c: A)\\n            if(c == 1)                  \\n                countNumberOfOnes++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t    // If no 1 is found, that means we can return ans as {0, size-1}\\n        if(countNumberOfOnes == 0)      \\n            return {0, n -1};\\n\\t\\t\\t\\t\\t\\t\\n        // If no of 1\\'s is not a multiple of 3, then we can never find a possible partition since\\n        // there will be atkeast one partition that will have different no of 1\\'s and hence\\n        // different binary representation\\n        // For example,\\n        // Given :\\n        // 0000110  110  110 \\n        //       |  |    |\\n        //       i       j\\n        // Total no of ones = 6\\n        // 0000110         110      110\\n        //     |           |        |\\n        //     start       mid      end\\n        // Match starting from first 1, and putting 2 more pointers by skipping k 1\\'s\\n        \\n        if(countNumberOfOnes % 3 != 0)            \\n            return {-1, -1};\\n\\t\\t\\t\\t\\t\\t\\n        // find size of each partition\\n        int k = countNumberOfOnes/3;\\n        int i;\\n        \\n        // start: the first 1 in the array\\n        // mid:   the (k+1)th 1 in the array\\n        // end:   the (2k+1)th 1 in the array\\n        int oneIdx = 0;\\n        int start, mid, end;\\n        for(i=0;i<A.size(); i++)\\n            if(A[i] == 1){\\n                ++oneIdx;\\n                if( oneIdx == 1) start = i;\\n                if( oneIdx == k + 1) mid = i;\\n                if( oneIdx == 2*k + 1) {end = i;break;}\\n            }\\n        \\n        // Match all values till the end of the array\\n        while(end< A.size() && A[start] == A[mid] && A[mid] == A[end]){\\n            start++; mid++; end++;\\n        }\\n        \\n        // Return appropriate values if all the values have matched till the end\\n        if(end == A.size()) \\n            return {start-1, mid};\\n        \\n        // otherwise, no such indices found\\n        return {-1, -1};\\n    }\\n};\\n```\n```\\ndef threeEqualParts(self, nums: List[int]) -> List[int]:\\n\\tn = nums.count(1)\\n\\tif n == 0: return [0, 2] # any split would satify\\n\\tif n % 3 != 0: return [-1, -1]\\n\\tidx = [i for i, num in enumerate(nums) if num == 1]\\n\\ts1, e1, s2, e2, s3, e3 = idx[0], idx[n//3-1], idx[n//3], idx[2*n//3-1], idx[2*n//3], idx[n-1]\\n\\ttracingZeros = len(nums) - 1 - e3\\n\\tif e1 + tracingZeros >= s2 or e2 + tracingZeros >= s3 or not nums[s1: e1] == nums[s2: e2] == nums[s3: e3]: return [-1, -1]\\n\\treturn [e1 + tracingZeros, e2 + tracingZeros + 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672781,
                "title": "ruby-with-regexp",
                "content": "```\\ndef three_equal_parts(a)\\n  return [0, a.size-1] if a.all?(&:zero?)\\n  s = a.join\\n  tmp = s.match(/^0*(1.*)0*(\\\\1)0*(\\\\1)$/)[1]\\n  i = s.index(tmp) + tmp.size - 1\\n  j = s.index(tmp, i+1) + tmp.size\\n  [ i , j ]\\nrescue => e\\n  [-1, -1]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef three_equal_parts(a)\\n  return [0, a.size-1] if a.all?(&:zero?)\\n  s = a.join\\n  tmp = s.match(/^0*(1.*)0*(\\\\1)0*(\\\\1)$/)[1]\\n  i = s.index(tmp) + tmp.size - 1\\n  j = s.index(tmp, i+1) + tmp.size\\n  [ i , j ]\\nrescue => e\\n  [-1, -1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 183895,
                "title": "java-50ms-with-my-thinking-process",
                "content": "thinking process is chinese:https://www.jianshu.com/p/c8dbaaf87644\\n```\\npublic int[] threeEqualParts(int[] A) {\\n        int i = 0, j = A.length-1;\\n        Deque<Integer> pre = new ArrayDeque<>();\\n        Deque<Integer> mid = new ArrayDeque<>();\\n        Deque<Integer> last = new ArrayDeque<>();\\n        if(A[0]!=0) pre.offerLast(1);\\n        if(A[j]!=0) last.offerLast(1);\\n        for(int k = 1; k < j; k++){\\n            if(mid.isEmpty() && A[k] == 0) continue;\\n            mid.offerLast(A[k]);\\n        } \\n        while(i < j){\\n            int cp = compare(pre,last);\\n            if(cp<0){\\n                i++;\\n                if(A[i] == 0){\\n                    if(!pre.isEmpty()) pre.offerLast(0);\\n                } \\n                else{\\n                    if(mid.isEmpty()) break;\\n                    pre.offerLast(mid.pollFirst());\\n                    while(!mid.isEmpty() && mid.peekFirst()==0) mid.pollFirst();\\n                }\\n            }else if(cp>0){\\n                j--;\\n                if(mid.isEmpty()) break;\\n                if(A[j] == 0) mid.pollLast();\\n                else moveMidToLast(A,mid,last,j);\\n            }else{\\n                int cp2 = compare(mid,last);\\n                \\n                if(cp2 == 0) return new int[]{i,j};\\n                if(cp2<0) break;\\n                else{\\n                    j--;\\n                    if(mid.isEmpty()) break;\\n                    if(A[j] == 0) mid.pollLast();\\n                    else moveMidToLast(A,mid,last,j);\\n                }\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n    private void moveMidToLast(int[] A,Deque<Integer> mid,Deque<Integer> last,int j){\\n        int idx = j+1;\\n        while(idx<A.length && A[idx++]==0)\\n            last.offerFirst(0);\\n        last.offerFirst(mid.pollLast());\\n    }\\n    \\n    private int compare(Deque<Integer> a, Deque<Integer> b){\\n        if(a.size() < b.size()) return -1;\\n        if(a.size() == b.size()){\\n            Iterator<Integer> itr = a.iterator();\\n            Iterator<Integer> itr2 = b.iterator();\\n            while(itr.hasNext()){\\n                int fa = itr.next();\\n                int fb = itr2.next();\\n                if(fa == fb) continue;\\n                return fa-fb;\\n            }\\n\\n            return 0;\\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] threeEqualParts(int[] A) {\\n        int i = 0, j = A.length-1;\\n        Deque<Integer> pre = new ArrayDeque<>();\\n        Deque<Integer> mid = new ArrayDeque<>();\\n        Deque<Integer> last = new ArrayDeque<>();\\n        if(A[0]!=0) pre.offerLast(1);\\n        if(A[j]!=0) last.offerLast(1);\\n        for(int k = 1; k < j; k++){\\n            if(mid.isEmpty() && A[k] == 0) continue;\\n            mid.offerLast(A[k]);\\n        } \\n        while(i < j){\\n            int cp = compare(pre,last);\\n            if(cp<0){\\n                i++;\\n                if(A[i] == 0){\\n                    if(!pre.isEmpty()) pre.offerLast(0);\\n                } \\n                else{\\n                    if(mid.isEmpty()) break;\\n                    pre.offerLast(mid.pollFirst());\\n                    while(!mid.isEmpty() && mid.peekFirst()==0) mid.pollFirst();\\n                }\\n            }else if(cp>0){\\n                j--;\\n                if(mid.isEmpty()) break;\\n                if(A[j] == 0) mid.pollLast();\\n                else moveMidToLast(A,mid,last,j);\\n            }else{\\n                int cp2 = compare(mid,last);\\n                \\n                if(cp2 == 0) return new int[]{i,j};\\n                if(cp2<0) break;\\n                else{\\n                    j--;\\n                    if(mid.isEmpty()) break;\\n                    if(A[j] == 0) mid.pollLast();\\n                    else moveMidToLast(A,mid,last,j);\\n                }\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n    private void moveMidToLast(int[] A,Deque<Integer> mid,Deque<Integer> last,int j){\\n        int idx = j+1;\\n        while(idx<A.length && A[idx++]==0)\\n            last.offerFirst(0);\\n        last.offerFirst(mid.pollLast());\\n    }\\n    \\n    private int compare(Deque<Integer> a, Deque<Integer> b){\\n        if(a.size() < b.size()) return -1;\\n        if(a.size() == b.size()){\\n            Iterator<Integer> itr = a.iterator();\\n            Iterator<Integer> itr2 = b.iterator();\\n            while(itr.hasNext()){\\n                int fa = itr.next();\\n                int fb = itr2.next();\\n                if(fa == fb) continue;\\n                return fa-fb;\\n            }\\n\\n            return 0;\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2529351,
                "title": "100-tc-easy-python-solution",
                "content": "Hint\\nCount the num of ones, and think how they will be split between the 3 segments :)\\n```\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n\\tn = len(arr)\\n\\tpos = [i for i in range(n) if(arr[i])]\\n\\tl = len(pos)\\n\\tif(l == 0):\\n\\t\\treturn [0, 2]\\n\\tif(l % 3):\\n\\t\\treturn [-1, -1]\\n\\tones = l//3\\n\\tc = 0\\n\\tfor i in arr[::-1]:\\n\\t\\tif(i == 1):\\n\\t\\t\\tbreak\\n\\t\\tc += 1\\n\\tans = [-1, -1]\\n\\t# one hoga pos[ones-1] tak\\n\\t# uske bad chaiye meko c zeros\\n\\t# toh index pos[ones-1] + c tak first segment ho jayega\\n\\tans[0] = pos[ones-1] + c\\n\\tans[1] = pos[2*ones-1] + c + 1\\n\\tseg1, seg2, seg3 = arr[pos[0]:ans[0]+1], arr[pos[ones]:ans[1]], arr[pos[2*ones]:]\\n\\t# without leading zeros\\n\\tif(seg1 != seg2 or seg1 != seg3):\\n\\t\\treturn [-1, -1]\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n\\tn = len(arr)\\n\\tpos = [i for i in range(n) if(arr[i])]\\n\\tl = len(pos)\\n\\tif(l == 0):\\n\\t\\treturn [0, 2]\\n\\tif(l % 3):\\n\\t\\treturn [-1, -1]\\n\\tones = l//3\\n\\tc = 0\\n\\tfor i in arr[::-1]:\\n\\t\\tif(i == 1):\\n\\t\\t\\tbreak\\n\\t\\tc += 1\\n\\tans = [-1, -1]\\n\\t# one hoga pos[ones-1] tak\\n\\t# uske bad chaiye meko c zeros\\n\\t# toh index pos[ones-1] + c tak first segment ho jayega\\n\\tans[0] = pos[ones-1] + c\\n\\tans[1] = pos[2*ones-1] + c + 1\\n\\tseg1, seg2, seg3 = arr[pos[0]:ans[0]+1], arr[pos[ones]:ans[1]], arr[pos[2*ones]:]\\n\\t# without leading zeros\\n\\tif(seg1 != seg2 or seg1 != seg3):\\n\\t\\treturn [-1, -1]\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1345370,
                "title": "three-pointers-c-o-n-time-o-1-space",
                "content": "**Approach:** First of all, it is necessary for the given array to have sufficient count of ones which can be equally divided among three groups. If not, the answer is not possible. If yes, find the occurances of the first ones of each group. Now, simply iterate over these pointers and check whether you can atleast reach to the starting index of other group. If so, return the indexes else answer is not possible. \\n**Time complexity:** O(N)\\n**Space complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> check(vector<int> s, int i, int j, int k) {\\n        int n=s.size();\\n        while(i<j && j<k && k<n) {\\n            if(s[i]!=s[j] || s[j]!=s[k]) return {-1,-1};\\n            if(i==j || j==k || k==n) break;\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        if(i==j || j==k || k==n) return {i-1, j};\\n        return {-1,-1};\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int ctr=count(arr.begin(), arr.end(),1);\\n        if(ctr % 3 != 0) return {-1,-1};\\n        \\n        vector<int> ans(3,-1);\\n        int k=0, ref=0;\\n        for(int i=0;i<n;i++) { \\n            if(arr[i] && !ref) {\\n                ans[k++]=i;\\n            }\\n            if(arr[i]) ref++;\\n            \\n            if(ref==ctr/3) {\\n                ref=0;\\n            }\\n        }\\n        if(ans[0]==ans[1] && ans[1]==ans[2]) return {0, n-1};\\n        return check(arr, ans[0], ans[1], ans[2]);\\n    }\\n};\\n```\\n**Upvote if u liked!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> check(vector<int> s, int i, int j, int k) {\\n        int n=s.size();\\n        while(i<j && j<k && k<n) {\\n            if(s[i]!=s[j] || s[j]!=s[k]) return {-1,-1};\\n            if(i==j || j==k || k==n) break;\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        if(i==j || j==k || k==n) return {i-1, j};\\n        return {-1,-1};\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int ctr=count(arr.begin(), arr.end(),1);\\n        if(ctr % 3 != 0) return {-1,-1};\\n        \\n        vector<int> ans(3,-1);\\n        int k=0, ref=0;\\n        for(int i=0;i<n;i++) { \\n            if(arr[i] && !ref) {\\n                ans[k++]=i;\\n            }\\n            if(arr[i]) ref++;\\n            \\n            if(ref==ctr/3) {\\n                ref=0;\\n            }\\n        }\\n        if(ans[0]==ans[1] && ans[1]==ans[2]) return {0, n-1};\\n        return check(arr, ans[0], ans[1], ans[2]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344658,
                "title": "easy-approach-using-prefix-sum-2-sum-no-one-is-talking-about-this",
                "content": "### Prefix Sum\\nNo post is talking about this apporach, and I came up with this when sleeping.\\nTypically, sum of subarray problem can be resovled using prefix sum array. So is this. Similarly, the `prefix[i]` represents the integer with the binary representation of `nums[:i]`, then `prefix[j] - prefix[i]` is the integer represented by `nums[i:j]`. \\n\\n```\\nprefix[i + 1] = prefix[i] << 1 + num[i]\\nprefix[j + 1] - prefix[i + 1] = prefix[j + 1] - (prefix[i] << j - i)\\n```\\n\\nIn order to find out 3 subarrays with the same integer, we just need find out `[i, j]` such that \\n\\n```prefix[i - 1] == prefix[j] - prefix[i] == prefix[-1] - prefix[j]```\\n\\nThe naive solution is to iterate each possible pair of `(i, j)`, but we can reduce it to linear using hashmap/dictionary. Recall the 2 sum problem!\\nWe iterate each *j* and store the index *i* of `prefix[i]` seen up to *j*, then if `prefix[-1] - prefix[j]` is in the hashmap, then return the pair. Finally, reutrn `[-1, -1]` otherwise.\\n\\n```python\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n\\tprefix = [0]\\n    for num in arr:\\n\\t\\tprefix.append((prefix[-1] << 1) + num)\\n        \\n\\tseen = {}\\n    n = len(arr)\\n    for j in range(n): \\n\\t\\tx = prefix[-1] - (prefix[j + 1] << n - 1 - j)\\n        if x in seen and prefix[j + 1] == (x << j + 1 - seen[x]) + x:\\n\\t\\t\\treturn [seen[x] - 1, j + 1]\\n        seen[prefix[j + 1]] = j + 1\\n\\treturn [-1, -1]     \\n        \\n```\\n*Time Complexity* = **O(N)**\\n*Space Complexity* = **O(N)**",
                "solutionTags": [],
                "code": "```\\nprefix[i + 1] = prefix[i] << 1 + num[i]\\nprefix[j + 1] - prefix[i + 1] = prefix[j + 1] - (prefix[i] << j - i)\\n```\n```prefix[i - 1] == prefix[j] - prefix[i] == prefix[-1] - prefix[j]```\n```python\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n\\tprefix = [0]\\n    for num in arr:\\n\\t\\tprefix.append((prefix[-1] << 1) + num)\\n        \\n\\tseen = {}\\n    n = len(arr)\\n    for j in range(n): \\n\\t\\tx = prefix[-1] - (prefix[j + 1] << n - 1 - j)\\n        if x in seen and prefix[j + 1] == (x << j + 1 - seen[x]) + x:\\n\\t\\t\\treturn [seen[x] - 1, j + 1]\\n        seen[prefix[j + 1]] = j + 1\\n\\treturn [-1, -1]     \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344388,
                "title": "c-single-pass-solution-explained-100-time-90-space",
                "content": "Nice problem that becomes much easier once you figure out a few tricks:\\n* first of all, in order for the problem to be solvable, we need an amount of `1`s divisible by `3`;\\n* with this insight, we can figure out that while we move on checking for the amount of `1`s, we might as well keep track of pointers separating the currently explored portion of the array into `3` parts;\\n* to get this pointer in place, we might think of doing something similar to navigating a linked list with the hare-tortoise approach, just this time we would have `3` pointers (`s1`, `s2` and `i`, later in my code), proceeding at 1X, 2X and 3X speed respectively.\\n\\nFor example, if we started with `{0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0}`, we would initially find all 3 pointers set when we meet the third `1`, so, it would be:\\n\\n```cpp\\ns1 == 1;  // position of the first 1\\ns2 == 2;  // position of the second 1\\n i == 5;  // position of the third 1\\n```\\n\\nOnce we met the sixth `1` we have:\\n\\n```cpp\\ns1 == 2;  // position of the second 1\\ns2 == 6;  // position of  the fourth 1\\n i == 13; // position of the sixth 1\\n```\\n\\nAnd so on; with that in mind, then it becomes much easier to figure out the limits of a partition (the position of the last one will dictate the padding `0`s to all the others) and we can proceed from that.\\n\\nIn order to code it, we will use a few support variables:\\n* `tot` is out ongoing total, initialised to `0`;\\n* `lastElem` is the position of the last element, initialised to be `arr.size()` (for now, we will fix it in a moment!);\\n* `lmt` gives us the upper limit of how many positions for either `s1` or `s2` we are going to store, initalised to be `lastElem / 3` (ie: we will never have more positions than one third of the length, if even if all elements were to be `1`s);\\n* `s1`, `s2` and `last` will keep track of where we found the delimiting `1`s for each session discovered so far;\\n* `curr1` and `curr2` will be the positions of the `s1` and `s2` pointers we will be using, both set to `0` initially;\\n* `pos1` and `pos2`, specularly, will point to where we are going to store them in their respective arrays;\\n* `s1s` and `s2s` are the arrays that will store pointers to our dividing points as we go.\\n\\nDone with the variables, we can now fix `lastElem` to correctly be the index of the last element and loop with `i` through `arr`, and:\\n* we will check if the currenlty pointed element `arr[i]` is  a `1` and, if so:\\n\\t* increase `tot` by `1`;\\n\\t* store the current position in `s1s`, provided we did not do so already for `lmt` elements;\\n\\t* store the current position in `s2s`, provided we did not do so already for `lmt` elements and that we parsed so far an even number of `1`s;\\n\\t* it `tot` is divisible by `3`, we will then:\\n\\t\\t* update the `last`, `s1` and `s2` pointers to new values.\\n\\nWith this out of the way, time to parse for a few edge cases:\\n * if no `1`s were found (ie: `!tot`), we will then just `return` `{0, lastElem}` (I think why not any other pointer for the second element was not very clear in the description, but okay);\\n * if `tot` is not divisible by `3`, clearly we cannot form `3` parts with the same amount of `1`s, so we will `return` `{-1, -1}`.\\n \\nOne last condition to check is that the sections have exactly the same binary value and this is a bit trickier.\\n \\nTo do so, we will use a new variable `diff` computed as the difference between `last` and `lastElem` to get the amount of necessary padding `0`s.\\n \\n We will then:\\n * increase `s1` by `diff` and check if it is still below `s2`, otherwise we will `return` `{-1, -1}`;\\n * increase `s2` by `diff` and check if it is still below `last`, otherwise we will `return` `{-1, -1}`;\\n * set `curr1` to be `s1`, `curr2` to be `s2`, `last` to `lastElem` and `tot` to one third of its original value;\\n * we will loop while `tot > 0` and:\\n\\t * check if `curr1`, `curr2` and `last` point to the same value (either all point to a `0` or to a `1`), otherwise `return` `{-1, -1}`;\\n\\t * reduce `tot` by the currently pointed value by any of the pointers;\\n\\t * decrease all three pointers by `1`.\\n\\nYou might notice that even if any of the sections still had leading `0`s, in this way we would not care, stopping at the last `1` of each session - assuming no mismatch was detected earlier.\\n\\nOnce done, we can `return` `{s1, s2 + 1}` (remember that the second pointer is requested to be where the last segment starts) and be done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int tot = 0, lastElem = arr.size(), lmt = lastElem / 3, s1, s2, last,\\n        curr1 = 0, curr2 = 0, pos1 = 0, pos2 = 0, s1s[lmt], s2s[lmt];\\n        lastElem--;\\n        for (int i = 0; i <= lastElem; i++) {\\n            // finding a `1`\\n            if (arr[i]) {\\n                tot++;\\n                // storing i in s1s if it is not full\\n                if (pos1 < lmt) s1s[pos1++] = i;\\n                // storing i in s2s every 2 1s if it is not full\\n                if (pos2 < lmt && !(tot & 1)) s2s[pos2++] = i;\\n                // updating pointers every 3 1s\\n                if (!(tot % 3)) {\\n                    last = i;\\n                    s1 = s1s[curr1++];\\n                    s2 = s2s[curr2++];\\n                }\\n            }\\n        }\\n        // edge case: no 1s\\n        if (!tot) return {0, lastElem};\\n        // exit case: can\\'t form 3 groups with the same number of 1s\\n        if (tot % 3) return {-1, -1};\\n        // moving the pointer to the last 0 of the sequence\\n        int diff = lastElem - last;\\n        // updating s1 and s2, plus exit case: not enough 0s between either s1 and s2 or s2 and last\\n        s1 += diff;\\n        if (s1 >= s2) return {-1, -1};\\n        s2 += diff;\\n        if (s2 >= last) return {-1, -1};\\n        // updating curr1, curr2, last and tot to check the segment structure\\n        curr1 = s1, curr2 = s2, last = lastElem, tot /= 3;\\n        while (tot) {\\n            // checking if all the elements match\\n            if (arr[curr1] != arr[curr2] || arr[curr2] != arr[last]) return {-1, -1};\\n            // updating variables for the next loop\\n            tot -= arr[curr1];\\n            curr1--, curr2--, last--;\\n        }\\n        // checking if the segments have the same structure\\n        return {s1, s2 + 1};\\n    }\\n};\\n```\\nMicro-optimisation, declaring and assigning `s1` and `s2` at the end and if it might be a proper solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int tot = 0, lastElem = arr.size(), lmt = lastElem / 3, last,\\n        curr1 = -1, curr2 = -1, pos1 = 0, pos2 = 0, s1s[lmt], s2s[lmt];\\n        lastElem--;\\n        for (int i = 0; i <= lastElem; i++) {\\n            // finding a `1`\\n            if (arr[i]) {\\n                tot++;\\n                // storing i in s1s if it is not full\\n                if (pos1 < lmt) s1s[pos1++] = i;\\n                // storing i in s2s every 2 1s if it is not full\\n                if (pos2 < lmt && !(tot & 1)) s2s[pos2++] = i;\\n                // updating pointers every 3 1s\\n                if (!(tot % 3)) {\\n                    last = i;\\n                    curr1++;\\n                    curr2++;\\n                }\\n            }\\n        }\\n        // edge case: no 1s\\n        if (!tot) return {0, lastElem};\\n        // exit case: can\\'t form 3 groups with the same number of 1s\\n        if (tot % 3) return {-1, -1};\\n        // moving the pointer to the last 0 of the sequence\\n        int diff = lastElem - last, s1 = s1s[curr1], s2 = s2s[curr2];\\n        // updating s1 and s2, plus exit case: not enough 0s between either s1 and s2 or s2 and last\\n        s1 += diff;\\n        if (s1 >= s2) return {-1, -1};\\n        s2 += diff;\\n        if (s2 >= last) return {-1, -1};\\n        // updating curr1, curr2, last and tot to check the segment structure\\n        curr1 = s1, curr2 = s2, last = lastElem, tot /= 3;\\n        while (tot) {\\n            // checking if all the elements match\\n            if (arr[curr1] != arr[curr2] || arr[curr2] != arr[last]) return {-1, -1};\\n            // updating variables for the next loop\\n            tot -= arr[curr1];\\n            curr1--, curr2--, last--;\\n        }\\n        // checking if the segments have the same structure\\n        return {s1, s2 + 1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\ns1 == 1;  // position of the first 1\\ns2 == 2;  // position of the second 1\\n i == 5;  // position of the third 1\\n```\n```cpp\\ns1 == 2;  // position of the second 1\\ns2 == 6;  // position of  the fourth 1\\n i == 13; // position of the sixth 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int tot = 0, lastElem = arr.size(), lmt = lastElem / 3, s1, s2, last,\\n        curr1 = 0, curr2 = 0, pos1 = 0, pos2 = 0, s1s[lmt], s2s[lmt];\\n        lastElem--;\\n        for (int i = 0; i <= lastElem; i++) {\\n            // finding a `1`\\n            if (arr[i]) {\\n                tot++;\\n                // storing i in s1s if it is not full\\n                if (pos1 < lmt) s1s[pos1++] = i;\\n                // storing i in s2s every 2 1s if it is not full\\n                if (pos2 < lmt && !(tot & 1)) s2s[pos2++] = i;\\n                // updating pointers every 3 1s\\n                if (!(tot % 3)) {\\n                    last = i;\\n                    s1 = s1s[curr1++];\\n                    s2 = s2s[curr2++];\\n                }\\n            }\\n        }\\n        // edge case: no 1s\\n        if (!tot) return {0, lastElem};\\n        // exit case: can\\'t form 3 groups with the same number of 1s\\n        if (tot % 3) return {-1, -1};\\n        // moving the pointer to the last 0 of the sequence\\n        int diff = lastElem - last;\\n        // updating s1 and s2, plus exit case: not enough 0s between either s1 and s2 or s2 and last\\n        s1 += diff;\\n        if (s1 >= s2) return {-1, -1};\\n        s2 += diff;\\n        if (s2 >= last) return {-1, -1};\\n        // updating curr1, curr2, last and tot to check the segment structure\\n        curr1 = s1, curr2 = s2, last = lastElem, tot /= 3;\\n        while (tot) {\\n            // checking if all the elements match\\n            if (arr[curr1] != arr[curr2] || arr[curr2] != arr[last]) return {-1, -1};\\n            // updating variables for the next loop\\n            tot -= arr[curr1];\\n            curr1--, curr2--, last--;\\n        }\\n        // checking if the segments have the same structure\\n        return {s1, s2 + 1};\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int tot = 0, lastElem = arr.size(), lmt = lastElem / 3, last,\\n        curr1 = -1, curr2 = -1, pos1 = 0, pos2 = 0, s1s[lmt], s2s[lmt];\\n        lastElem--;\\n        for (int i = 0; i <= lastElem; i++) {\\n            // finding a `1`\\n            if (arr[i]) {\\n                tot++;\\n                // storing i in s1s if it is not full\\n                if (pos1 < lmt) s1s[pos1++] = i;\\n                // storing i in s2s every 2 1s if it is not full\\n                if (pos2 < lmt && !(tot & 1)) s2s[pos2++] = i;\\n                // updating pointers every 3 1s\\n                if (!(tot % 3)) {\\n                    last = i;\\n                    curr1++;\\n                    curr2++;\\n                }\\n            }\\n        }\\n        // edge case: no 1s\\n        if (!tot) return {0, lastElem};\\n        // exit case: can\\'t form 3 groups with the same number of 1s\\n        if (tot % 3) return {-1, -1};\\n        // moving the pointer to the last 0 of the sequence\\n        int diff = lastElem - last, s1 = s1s[curr1], s2 = s2s[curr2];\\n        // updating s1 and s2, plus exit case: not enough 0s between either s1 and s2 or s2 and last\\n        s1 += diff;\\n        if (s1 >= s2) return {-1, -1};\\n        s2 += diff;\\n        if (s2 >= last) return {-1, -1};\\n        // updating curr1, curr2, last and tot to check the segment structure\\n        curr1 = s1, curr2 = s2, last = lastElem, tot /= 3;\\n        while (tot) {\\n            // checking if all the elements match\\n            if (arr[curr1] != arr[curr2] || arr[curr2] != arr[last]) return {-1, -1};\\n            // updating variables for the next loop\\n            tot -= arr[curr1];\\n            curr1--, curr2--, last--;\\n        }\\n        // checking if the segments have the same structure\\n        return {s1, s2 + 1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344252,
                "title": "easy-c-o-n-faster-than-99-4-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int i,j,x=0,n=arr.size();\\n        for(i=0;i<n;i++){\\n            if(arr[i]==1) x++;\\n        }\\n        vector<int>v(2);\\n        if(x%3!=0){\\n            v[1]=v[0]=-1;\\n            return v;\\n        }\\n        if(x==0){\\n            v[0]=0;v[1]=n-1;\\n            return v;\\n        }\\n        int k=0;\\n        for(i=n-1;i>=0;i--){\\n            if(arr[i]==1) break;\\n            k++;\\n        }\\n        int z=0;\\n        vector<int>a;\\n        for(i=n-1;i>=0;i--){\\n            if(arr[i]==1) z++;\\n            a.push_back(arr[i]);\\n            if(z==x/3){\\n                v[1]=i;break;\\n            }\\n            \\n        }\\n        z=0;\\n        for(i=v[1]-1;i>=0;i--){\\n            if(arr[i]==1) break;\\n            z++;\\n        }\\n        if(z<k){\\n            v[1]=v[0]=-1;\\n            return v;\\n        }\\n        z=i+k; v[1]=z+1;\\n        int sz=a.size();\\n        for(j=0;j<sz;j++){\\n            if(arr[z]!=a[j]){\\n                v[1]=v[0]=-1;\\n                return v;\\n            }\\n            z--;\\n        }\\n        v[0]=z;\\n        z=0;\\n        for(i=v[0];i>=0;i--){\\n            if(arr[i]==1) break;\\n            z++;\\n        }\\n        if(z<k){\\n            v[1]=v[0]=-1;\\n            return v;\\n        }\\n        z=i+k; v[0]=z;\\n        for(j=0;j<sz;j++){\\n            if(arr[z]!=a[j]){\\n                v[1]=v[0]=-1;\\n                return v;\\n            }\\n            z--;\\n        }\\n        while(z>=0){\\n            if(arr[z]==1){\\n                v[1]=v[0]=-1;\\n                return v;\\n            }\\n            z--;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int i,j,x=0,n=arr.size();\\n        for(i=0;i<n;i++){\\n            if(arr[i]==1) x++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1344172,
                "title": "easy-java-o-n-100-fast-1-ms-time-count-hack-approach",
                "content": "**Added comments in java code to explain more deeply**\\n```\\n\\n// 927. Three Equal Parts\\n// Runtime: 1 ms, faster than 100.00% of Java online submissions for Three Equal Parts.\\n// Memory Usage: 44.9 MB, less than 60.58% of Java online submissions for Three Equal Parts.\\n\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int countOne=0,n=arr.length;\\n        \\n        //count number of zeroes\\n        for(int i:arr)\\n            countOne+=i;\\n        \\n        //if all 0 return return (0, length)\\n        if(countOne==0)\\n            return new int[]{0,n-1};\\n        //if not divisible by 3 then return (-1,-1)\\n        if(countOne%3!=0)\\n            return new int[]{-1,-1};  \\n        \\n        \\n        \\n        int start = 0,mid = 0,end = 0;\\n        int averageOneCount=countOne/3;\\n        countOne=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            //skip all zeroes\\n            if(arr[i]==0)\\n                continue;\\n             \\n            //mark 1st 1 as start\\n            if(countOne==0)\\n                start=i;\\n            \\n            countOne++;   \\n            //find mid \\'1\\' element\\n           if(countOne == averageOneCount + 1) \\n                mid = i;\\n            \\n            //find last \\'1\\' element\\n           if(countOne == 2 * averageOneCount + 1) \\n                end = i;\\n            \\n        }\\n        \\n        //skip all elements which are same\\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n        \\n        //if we reach end then its possible so return (start-1,end)\\n        if(end == n) {\\n            return new int[]{start-1,mid};\\n        }\\n        \\n        //else return as its not possible\\n        return new int[]{-1,-1}; \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n\\n// 927. Three Equal Parts\\n// Runtime: 1 ms, faster than 100.00% of Java online submissions for Three Equal Parts.\\n// Memory Usage: 44.9 MB, less than 60.58% of Java online submissions for Three Equal Parts.\\n\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int countOne=0,n=arr.length;\\n        \\n        //count number of zeroes\\n        for(int i:arr)\\n            countOne+=i;\\n        \\n        //if all 0 return return (0, length)\\n        if(countOne==0)\\n            return new int[]{0,n-1};\\n        //if not divisible by 3 then return (-1,-1)\\n        if(countOne%3!=0)\\n            return new int[]{-1,-1};  \\n        \\n        \\n        \\n        int start = 0,mid = 0,end = 0;\\n        int averageOneCount=countOne/3;\\n        countOne=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            //skip all zeroes\\n            if(arr[i]==0)\\n                continue;\\n             \\n            //mark 1st 1 as start\\n            if(countOne==0)\\n                start=i;\\n            \\n            countOne++;   \\n            //find mid \\'1\\' element\\n           if(countOne == averageOneCount + 1) \\n                mid = i;\\n            \\n            //find last \\'1\\' element\\n           if(countOne == 2 * averageOneCount + 1) \\n                end = i;\\n            \\n        }\\n        \\n        //skip all elements which are same\\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n        \\n        //if we reach end then its possible so return (start-1,end)\\n        if(end == n) {\\n            return new int[]{start-1,mid};\\n        }\\n        \\n        //else return as its not possible\\n        return new int[]{-1,-1}; \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344159,
                "title": "hints-if-you-look-for-observations-hints-test-cases-come-over",
                "content": "**Observations**\\n1) Number of 1s should be dived by 3 with no remainder\\n2) We can skip the leading zeros in the middle except trailing zeros\\n3) Number of Middle zeros should be at least as num of trailing zeros\\n\\n**Some Good Test Cases**\\n```\\n[1,0,0,1,0,0,1,0,0]\\n[1,0,0,1,0,0,0,1,0,0]\\n[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]\\n[0,0,1,1,1]\\n[1,0,0,1,1]\\n[1,1,0,0,1]\\n[1,1,1,0,0]\\n[1,1,0,0,1,0,0]\\n[1,0,0,1,1,0,0]\\n[0,0,1,1,1]\\n[1,0,0,1,1]\\n[1,1,0,0,1]\\n[1,1,1,0,0]\\n[1,1,1]\\n[1,1,1,1]\\n[1,1,1,1,1]\\n[1,1,1,1,1,1]\\n```",
                "solutionTags": [],
                "code": "```\\n[1,0,0,1,0,0,1,0,0]\\n[1,0,0,1,0,0,0,1,0,0]\\n[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]\\n[0,0,1,1,1]\\n[1,0,0,1,1]\\n[1,1,0,0,1]\\n[1,1,1,0,0]\\n[1,1,0,0,1,0,0]\\n[1,0,0,1,1,0,0]\\n[0,0,1,1,1]\\n[1,0,0,1,1]\\n[1,1,0,0,1]\\n[1,1,1,0,0]\\n[1,1,1]\\n[1,1,1,1]\\n[1,1,1,1,1]\\n[1,1,1,1,1,1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343630,
                "title": "easy-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        // count 1\\n        int countone=count(arr.begin(),arr.end(),1);\\n        int n=arr.size();\\n        if(countone%3)\\n        {\\n            return {-1,-1};\\n        }\\n        if(countone==0)\\n        {\\n            return {0,n-1};\\n        }\\n        int total=countone/3;\\n        int p1=0,p2=0,p3=0;\\n        int count=0;\\n        // check first occurance of 1 for each part\\n        // lets take example\\n        //1 0 0 0 1 0 1 0 1 0 0 0 0 1 0 1\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                if(count==0)\\n                {\\n                    p1=i;\\n                }\\n                else if(count==total)\\n                {\\n                    p2=i;\\n                }\\n                else if(count==2*total)\\n                {\\n                    p3=i;\\n                }\\n                count+=1;\\n            }\\n        }\\n        // after this\\n        // p1 at index 0,p2 at index 6 and p3 at index 13\\n        // now check all element after of each part\\n        while(p3<n-1)\\n        {\\n            p1+=1;\\n            p2+=1;\\n            p3+=1;\\n            if(arr[p1]!=arr[p2] || arr[p2]!=arr[p3] || arr[p1]!=arr[p3])//if not equal \\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        \\n        return {p1,p2+1};\\n        \\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        // count 1\\n        int countone=count(arr.begin(),arr.end(),1);\\n        int n=arr.size();\\n        if(countone%3)\\n        {\\n            return {-1,-1};\\n        }\\n        if(countone==0)\\n        {\\n            return {0,n-1};\\n        }\\n        int total=countone/3;\\n        int p1=0,p2=0,p3=0;\\n        int count=0;\\n        // check first occurance of 1 for each part\\n        // lets take example\\n        //1 0 0 0 1 0 1 0 1 0 0 0 0 1 0 1\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                if(count==0)\\n                {\\n                    p1=i;\\n                }\\n                else if(count==total)\\n                {\\n                    p2=i;\\n                }\\n                else if(count==2*total)\\n                {\\n                    p3=i;\\n                }\\n                count+=1;\\n            }\\n        }\\n        // after this\\n        // p1 at index 0,p2 at index 6 and p3 at index 13\\n        // now check all element after of each part\\n        while(p3<n-1)\\n        {\\n            p1+=1;\\n            p2+=1;\\n            p3+=1;\\n            if(arr[p1]!=arr[p2] || arr[p2]!=arr[p3] || arr[p1]!=arr[p3])//if not equal \\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        \\n        return {p1,p2+1};\\n        \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343622,
                "title": "o-n-java-runtime-2-ms-faster-than-87-50-of-java-online-submissions",
                "content": "```\\npublic int[] threeEqualParts(int[] arr) {\\n        int oneCount = 0;\\n        int n = arr.length;\\n        for(int t : arr){\\n            if(t == 1) oneCount++;\\n        }\\n        if(oneCount == 0) return new int[]{0,n-1};\\n        if(oneCount % 3 != 0) return new int[]{-1,-1};\\n        int averageOneCount = oneCount / 3;\\n        int start = 0;\\n        int mid = 0;\\n        int end = 0;\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] == 0) continue;\\n            if(cnt == 0) {\\n                start = i;\\n            }\\n            cnt++;\\n            if(cnt == averageOneCount + 1) {\\n                mid = i;\\n            }\\n            if(cnt == 2 * averageOneCount + 1) {\\n                end = i;\\n            }\\n        }\\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n        if(end == n) {\\n            return new int[]{start-1,mid};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] threeEqualParts(int[] arr) {\\n        int oneCount = 0;\\n        int n = arr.length;\\n        for(int t : arr){\\n            if(t == 1) oneCount++;\\n        }\\n        if(oneCount == 0) return new int[]{0,n-1};\\n        if(oneCount % 3 != 0) return new int[]{-1,-1};\\n        int averageOneCount = oneCount / 3;\\n        int start = 0;\\n        int mid = 0;\\n        int end = 0;\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] == 0) continue;\\n            if(cnt == 0) {\\n                start = i;\\n            }\\n            cnt++;\\n            if(cnt == averageOneCount + 1) {\\n                mid = i;\\n            }\\n            if(cnt == 2 * averageOneCount + 1) {\\n                end = i;\\n            }\\n        }\\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n        if(end == n) {\\n            return new int[]{start-1,mid};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343568,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int count = 0;\\n        for (auto i:arr)\\n        {\\n            if(i == 1)\\n                count++;\\n        }\\n        if(count == 0)\\n            return {0,2};\\n        if(count%3 != 0)\\n            return {-1,-1};\\n        int p1 = 0;\\n        int p2 = 0;\\n        int p3 = 0;\\n        count = count/3;\\n        int temp = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {  if(arr[i] == 1)\\n          { if(temp == 0)\\n              p1 = i;\\n            else if(temp == count)\\n                p2 = i;\\n             else if(temp == 2*count)\\n                p3 = i;\\n           temp++;\\n          }\\n        \\n        }\\n\\n        int oldp2 = p2;\\n        int oldp3 = p3;\\n        while(p1<oldp2 and p2<oldp3 and p3<arr.size())\\n        {\\n            if(arr[p1] != arr[p2] or arr[p2] != arr[p3])\\n                return {-1,-1};\\n            p1++;\\n            p2++;\\n            p3++;\\n        }\\n        if(p3 == arr.size())\\n        {\\n            return {p1-1,p2};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int count = 0;\\n        for (auto i:arr)\\n        {\\n            if(i == 1)\\n                count++;\\n        }\\n        if(count == 0)\\n            return {0,2};\\n        if(count%3 != 0)\\n            return {-1,-1};\\n        int p1 = 0;\\n        int p2 = 0;\\n        int p3 = 0;\\n        count = count/3;\\n        int temp = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {  if(arr[i] == 1)\\n          { if(temp == 0)\\n              p1 = i;\\n            else if(temp == count)\\n                p2 = i;\\n             else if(temp == 2*count)\\n                p3 = i;\\n           temp++;\\n          }\\n        \\n        }\\n\\n        int oldp2 = p2;\\n        int oldp3 = p3;\\n        while(p1<oldp2 and p2<oldp3 and p3<arr.size())\\n        {\\n            if(arr[p1] != arr[p2] or arr[p2] != arr[p3])\\n                return {-1,-1};\\n            p1++;\\n            p2++;\\n            p3++;\\n        }\\n        if(p3 == arr.size())\\n        {\\n            return {p1-1,p2};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343308,
                "title": "python-o-n-time-o-1-space",
                "content": "The idea is to count the trailing zero of the last session(must be counted)\\nAs the leading zero can be ignored, we can just make sure that each session will have enough trailing zeros.\\n\\nLeading zeros will be ignored automatically by accu sum\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        one_count = sum(arr)\\n        \\n        if one_count % 3 != 0: return [-1, -1]\\n        if one_count == 0: return [0, len(arr)-1]\\n        \\n        session_one_count = one_count // 3\\n        session_trailing_zero = 0 # padding for each session\\n        for i in range(len(arr)-1, -1, -1):\\n            if arr[i] == 0:\\n                session_trailing_zero += 1\\n            else:\\n                break\\n        \\n        last_accu = -1\\n        curr_count = 0\\n        curr_accu = 0\\n        session_id = []\\n        \\n        i = 0\\n        while(i < len(arr)):\\n            curr_count += arr[i]\\n            curr_accu = curr_accu * 2 + arr[i]\\n            i += 1\\n            if curr_count == session_one_count:\\n                curr_trailing = 0\\n                while(i < len(arr) and curr_trailing < session_trailing_zero):\\n                    # find trailing zeros\\n                    curr = arr[i]\\n                    if curr == 0:\\n                        curr_trailing += 1\\n                        i += 1\\n                    else:\\n                        return [-1, -1] # not enough trailing zeros\\n                    \\n                if (last_accu != -1) and (curr_accu != last_accu):\\n                    return [-1, -1]\\n                \\n\\t\\t\\t\\t# reset\\n                last_accu = curr_accu\\n                session_id.append(i)\\n                curr_count = 0\\n                curr_accu = 0\\n        \\n        return [session_id[0]-1, session_id[1]]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        one_count = sum(arr)\\n        \\n        if one_count % 3 != 0: return [-1, -1]\\n        if one_count == 0: return [0, len(arr)-1]\\n        \\n        session_one_count = one_count // 3\\n        session_trailing_zero = 0 # padding for each session\\n        for i in range(len(arr)-1, -1, -1):\\n            if arr[i] == 0:\\n                session_trailing_zero += 1\\n            else:\\n                break\\n        \\n        last_accu = -1\\n        curr_count = 0\\n        curr_accu = 0\\n        session_id = []\\n        \\n        i = 0\\n        while(i < len(arr)):\\n            curr_count += arr[i]\\n            curr_accu = curr_accu * 2 + arr[i]\\n            i += 1\\n            if curr_count == session_one_count:\\n                curr_trailing = 0\\n                while(i < len(arr) and curr_trailing < session_trailing_zero):\\n                    # find trailing zeros\\n                    curr = arr[i]\\n                    if curr == 0:\\n                        curr_trailing += 1\\n                        i += 1\\n                    else:\\n                        return [-1, -1] # not enough trailing zeros\\n                    \\n                if (last_accu != -1) and (curr_accu != last_accu):\\n                    return [-1, -1]\\n                \\n\\t\\t\\t\\t# reset\\n                last_accu = curr_accu\\n                session_id.append(i)\\n                curr_count = 0\\n                curr_accu = 0\\n        \\n        return [session_id[0]-1, session_id[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343255,
                "title": "python-o-n-beat-100-304ms",
                "content": "```\\nclass Solution(object):\\n    def threeEqualParts(self, arr):\\n        N = len(arr)\\n        \\n        # ones_number : number of \\'1\\' in arr\\n        ones_number = sum(arr)\\n        if ones_number % 3 != 0: return [-1,-1]\\n        if ones_number == 0: return [0,N-1]\\n        \\n        # ones_each : number of \\'1\\' in one part\\n        ones_each = ones_number // 3\\n        \\n        # ones_idx : idx of \\'1\\', divided in 3 parts\\n        ones_idx, tmp, count = [], [], 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                tmp += [i]\\n                count += 1\\n            \\n            if count == ones_each:\\n                ones_idx.append(tmp)\\n                tmp = []\\n                count = 0\\n        \\n        # ones_idx_shift : idx of \\'1\\', divided in 3 parts, but each subarr is shifted to start with one\\n\\t\\t# used for comparing the pattern\\n        ones_idx_shift = []\\n        for ls in ones_idx:\\n            ones_idx_shift.append([ls[i] - ls[0] for i in range(ones_each)])\\n        \\n        # zeros_tail : numbers of \\'0\\' behind the last \\'1\\'\\n        zeros_tail = N - ones_idx[2][-1] -1\\n        \\n        # Rule 1: Space for zero\\n        # no space for zeros for part1 and part2\\n        if ones_idx[1][0] - ones_idx[0][-1] -1 < zeros_tail or ones_idx[2][0] - ones_idx[1][-1] -1 < zeros_tail:\\n            return [-1,-1]\\n        \\n        # Rule 2: Pattern of three parts\\n        # compare the pattern of part1, part2, and part3\\n        if ones_idx_shift[0] == ones_idx_shift[1] and ones_idx_shift[1] == ones_idx_shift[2]:\\n            return [ones_idx[0][-1] + zeros_tail, ones_idx[1][-1] +1 + zeros_tail]\\n        \\n        return [-1,-1]\\n```\\n### Sum of arr needs to be 3n\\nSince the arr is divided into 3 equal parts, the number of \\'1\\' need to be the multiple of 3.\\n\\n\\n### Need to match two rule\\n\\n#### Rule 1: Space for zero\\nWe need to make sure that there are enough \\'0\\' between each part.\\n\\nBecause **the \\'0\\' behind the last \\'1\\' is used in part3 for sure**, we can count whether there are enough \\'0\\' between (part1 ,part2) and between (part2, part3), which meen more than the number of \\'0\\' behind the last \\'1\\'.\\n\\n#### Rule 2: Pattern of three parts\\nPattern of three parts need to be the same.\\n\\nWe divide arr based on the number of \\'1\\', each part only have 1/3 number of \\'1\\'.\\n\\nFor example:\\n[1, 0, 0, 1, 0, 1, 0] can be divided into [1,0], [1,0], [1,0] => same\\n[1, 1, 0, 1, 0, 1, 1, 0, 0, 1] can be divided into [1, 1, 0], [1, 0, 1], [1, 0, 0, 1] => not the same",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeEqualParts(self, arr):\\n        N = len(arr)\\n        \\n        # ones_number : number of \\'1\\' in arr\\n        ones_number = sum(arr)\\n        if ones_number % 3 != 0: return [-1,-1]\\n        if ones_number == 0: return [0,N-1]\\n        \\n        # ones_each : number of \\'1\\' in one part\\n        ones_each = ones_number // 3\\n        \\n        # ones_idx : idx of \\'1\\', divided in 3 parts\\n        ones_idx, tmp, count = [], [], 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                tmp += [i]\\n                count += 1\\n            \\n            if count == ones_each:\\n                ones_idx.append(tmp)\\n                tmp = []\\n                count = 0\\n        \\n        # ones_idx_shift : idx of \\'1\\', divided in 3 parts, but each subarr is shifted to start with one\\n\\t\\t# used for comparing the pattern\\n        ones_idx_shift = []\\n        for ls in ones_idx:\\n            ones_idx_shift.append([ls[i] - ls[0] for i in range(ones_each)])\\n        \\n        # zeros_tail : numbers of \\'0\\' behind the last \\'1\\'\\n        zeros_tail = N - ones_idx[2][-1] -1\\n        \\n        # Rule 1: Space for zero\\n        # no space for zeros for part1 and part2\\n        if ones_idx[1][0] - ones_idx[0][-1] -1 < zeros_tail or ones_idx[2][0] - ones_idx[1][-1] -1 < zeros_tail:\\n            return [-1,-1]\\n        \\n        # Rule 2: Pattern of three parts\\n        # compare the pattern of part1, part2, and part3\\n        if ones_idx_shift[0] == ones_idx_shift[1] and ones_idx_shift[1] == ones_idx_shift[2]:\\n            return [ones_idx[0][-1] + zeros_tail, ones_idx[1][-1] +1 + zeros_tail]\\n        \\n        return [-1,-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200387,
                "title": "scala-solution",
                "content": "```\\ndef findEndIdx(arr: Array[Int], i: Int, binary_value: String):Int = {\\n        if(arr.drop(i).dropWhile(_==0).take(binary_value.length).foldLeft(\"\")((b,a)=> a + b) != binary_value) return -1\\n        return arr.drop(i).takeWhile(_==0).length + i + binary_value.length\\n      }\\n      def threeEqualParts(arr: Array[Int]): Array[Int] = {\\n        val cnt = arr.count(_ == 1)\\n        val n = arr.length\\n        if (cnt%3 !=0) return Array(-1,-1)\\n        if(cnt == 0)  return Array(0,n - 1)\\n        val idxThird  =arr.zipWithIndex.filter(n=> n._1 == 1).takeRight(cnt/3).take(1)(0)._2\\n        val binary_value = arr.takeRight(n - idxThird).foldLeft(\"\")((b,a)=>{a + b})\\n        val res1 = findEndIdx(arr, 0, binary_value)\\n        if (res1 < 0) return Array(-1,-1)\\n        val res2 = findEndIdx(arr, res1, binary_value)\\n        if (res2 < 0) return Array(-1,-1)\\n        return Array(res1 - 1,res2)\\n      }\\n```",
                "solutionTags": [],
                "code": "```\\ndef findEndIdx(arr: Array[Int], i: Int, binary_value: String):Int = {\\n        if(arr.drop(i).dropWhile(_==0).take(binary_value.length).foldLeft(\"\")((b,a)=> a + b) != binary_value) return -1\\n        return arr.drop(i).takeWhile(_==0).length + i + binary_value.length\\n      }\\n      def threeEqualParts(arr: Array[Int]): Array[Int] = {\\n        val cnt = arr.count(_ == 1)\\n        val n = arr.length\\n        if (cnt%3 !=0) return Array(-1,-1)\\n        if(cnt == 0)  return Array(0,n - 1)\\n        val idxThird  =arr.zipWithIndex.filter(n=> n._1 == 1).takeRight(cnt/3).take(1)(0)._2\\n        val binary_value = arr.takeRight(n - idxThird).foldLeft(\"\")((b,a)=>{a + b})\\n        val res1 = findEndIdx(arr, 0, binary_value)\\n        if (res1 < 0) return Array(-1,-1)\\n        val res2 = findEndIdx(arr, res1, binary_value)\\n        if (res2 < 0) return Array(-1,-1)\\n        return Array(res1 - 1,res2)\\n      }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1051404,
                "title": "python-3-brutal-force-with-explanation",
                "content": "First, special cases:\\n* \\tIf there is no 1 in list, we can just return ```[0, len(n)-1]```.\\n* \\tIf number of 1 cant be divied by 3, return ```[-1, -1]```.\\n\\nThen we find the valid binary number, since the leading zeros dont matter here, we just need to find the binary start with \"1\", therefore we traverse the list until we find the ```2 * m / 3 + 1``` th \"1\", this \"1\" is the start of the 3rd binary number.\\nTherefore we esaily find what this binary number is.\\n\\nNext, we just need to find the ```1st``` \"1\" and the ```m / 3 + 1``` th \"1\", standing for the begining of 1st and 2nd binary number seperatly. Once we find this \"1\",  comparing the array consisting this \"1\" with the 3rd number we have already found.\\n\\nReturn the index of ```i``` and ```j``` if both arrays are same with 3rd binary number, otherwise ```[-1, -1]```.\\n\\n```\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        m = sum(arr)\\n\\t\\tif m == 0:\\n            return [0, n - 1]\\n        if m % 3:\\n            return [-1, -1]\\n\\t\\t\\t\\n        k = m // 3\\n        i = 0\\n        n = len(arr)\\n        \\n        \\n        #start with finding the third (last) binary value in the list\\n        for idx in range(n):\\n            if arr[idx] == 1:\\n                i += 1\\n            if i == 2 * k + 1:\\n                res = arr[idx :]\\n                break\\n        reslen = len(res)\\n        \\n        ans = []\\n        \\n        #find the first binary value in list\\n        for idx in range(n):\\n            if arr[idx] == 1:\\n                break\\n        if arr[idx : idx + reslen] == res:\\n            ans.append(idx + reslen - 1)\\n        else:\\n            return [-1, -1]\\n\\n        #find the second binary in the list\\n        for idx in range(idx + reslen, n):\\n            if arr[idx] == 1:\\n                break\\n        if arr[idx : idx + reslen] == res:\\n            ans.append(idx + reslen)\\n            return ans\\n        else:\\n            return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```[0, len(n)-1]```\n```[-1, -1]```\n```2 * m / 3 + 1```\n```1st```\n```m / 3 + 1```\n```i```\n```j```\n```[-1, -1]```\n```\\ndef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        m = sum(arr)\\n\\t\\tif m == 0:\\n            return [0, n - 1]\\n        if m % 3:\\n            return [-1, -1]\\n\\t\\t\\t\\n        k = m // 3\\n        i = 0\\n        n = len(arr)\\n        \\n        \\n        #start with finding the third (last) binary value in the list\\n        for idx in range(n):\\n            if arr[idx] == 1:\\n                i += 1\\n            if i == 2 * k + 1:\\n                res = arr[idx :]\\n                break\\n        reslen = len(res)\\n        \\n        ans = []\\n        \\n        #find the first binary value in list\\n        for idx in range(n):\\n            if arr[idx] == 1:\\n                break\\n        if arr[idx : idx + reslen] == res:\\n            ans.append(idx + reslen - 1)\\n        else:\\n            return [-1, -1]\\n\\n        #find the second binary in the list\\n        for idx in range(idx + reslen, n):\\n            if arr[idx] == 1:\\n                break\\n        if arr[idx : idx + reslen] == res:\\n            ans.append(idx + reslen)\\n            return ans\\n        else:\\n            return [-1, -1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 418037,
                "title": "python-simple-solution",
                "content": "If the solution exists, the number of 1 in list should be times of 3.\\nSearch from right side to left, until we found num/3 1s. This index is not final answer, but we find the binary value.\\nFrom left side to right, find the first 1s and compare whether the first part value equal to bianay value and so on.\\n\\n```python\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        cnt1 = A.count(1)\\n        if cnt1%3 !=0:\\n            return [-1,-1]\\n        if cnt1 == 0:\\n            return [0,len(A)-1]\\n            \\n        cnt, binary_value = 0, 0\\n        # the binary value has been anchored\\n        for i in range(len(A)-1,-1,-1):\\n            if A[i]:\\n                cnt += 1\\n                if cnt == cnt1//3:\\n                    binary_value = A[i:]\\n                    length = len(binary_value)\\n                    break\\n        \\n        for i in range(0,len(A)):\\n            if A[i]:\\n                if A[i:i+length] == binary_value:\\n                    secondPart_startdx = i+length\\n                    for j in range(secondPart_startdx,len(A)):\\n                        if A[j]:\\n                            if A[j:j+length] == binary_value:\\n                                return [secondPart_startdx-1,j+length]\\n                            return [-1,-1]\\n                return [-1,-1]           \\n        return [-1,-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        cnt1 = A.count(1)\\n        if cnt1%3 !=0:\\n            return [-1,-1]\\n        if cnt1 == 0:\\n            return [0,len(A)-1]\\n            \\n        cnt, binary_value = 0, 0\\n        # the binary value has been anchored\\n        for i in range(len(A)-1,-1,-1):\\n            if A[i]:\\n                cnt += 1\\n                if cnt == cnt1//3:\\n                    binary_value = A[i:]\\n                    length = len(binary_value)\\n                    break\\n        \\n        for i in range(0,len(A)):\\n            if A[i]:\\n                if A[i:i+length] == binary_value:\\n                    secondPart_startdx = i+length\\n                    for j in range(secondPart_startdx,len(A)):\\n                        if A[j]:\\n                            if A[j:j+length] == binary_value:\\n                                return [secondPart_startdx-1,j+length]\\n                            return [-1,-1]\\n                return [-1,-1]           \\n        return [-1,-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 381367,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        List<Integer> plist = new ArrayList<>();\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                plist.add(i);\\n            }\\n        }\\n        // all zero\\n        if (plist.size() == 0) {\\n            return new int[]{0, 2};\\n        }\\n        // #1 is not 3x\\n        if (plist.size() % 3 != 0) {\\n            return new int[]{-1, -1};\\n        }\\n        // check gaps between 1s\\n        int count = plist.size()/3;\\n        int s1 = 0;\\n        int s2 = count;\\n        int s3 = 2*count;\\n        for (int i = 0; i < count-1; i++) {\\n            int gap1 = plist.get(s1+i+1) - plist.get(s1+i);\\n            int gap2 = plist.get(s2+i+1) - plist.get(s2+i);\\n            int gap3 = plist.get(s3+i+1) - plist.get(s3+i);\\n            if (gap1 != gap2 || gap2 != gap3) {\\n                return new int[]{-1, -1};\\n            }\\n        }\\n        // check right 0-padding for least significant bits\\n        int rpad1 = plist.get(s2) - plist.get(s2-1) - 1;\\n        int rpad2 = plist.get(s3) - plist.get(s3-1) - 1;\\n        int rpad3 = A.length - plist.get(plist.size()-1) - 1;\\n        if (rpad1 < rpad3 || rpad2 < rpad3) {\\n            return new int[]{-1, -1};\\n        }\\n        \\n        return new int[]{\\n            plist.get(s2-1)+rpad3, \\n            plist.get(s3-1)+rpad3+1\\n        };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        List<Integer> plist = new ArrayList<>();\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) {\\n                plist.add(i);\\n            }\\n        }\\n        // all zero\\n        if (plist.size() == 0) {\\n            return new int[]{0, 2};\\n        }\\n        // #1 is not 3x\\n        if (plist.size() % 3 != 0) {\\n            return new int[]{-1, -1};\\n        }\\n        // check gaps between 1s\\n        int count = plist.size()/3;\\n        int s1 = 0;\\n        int s2 = count;\\n        int s3 = 2*count;\\n        for (int i = 0; i < count-1; i++) {\\n            int gap1 = plist.get(s1+i+1) - plist.get(s1+i);\\n            int gap2 = plist.get(s2+i+1) - plist.get(s2+i);\\n            int gap3 = plist.get(s3+i+1) - plist.get(s3+i);\\n            if (gap1 != gap2 || gap2 != gap3) {\\n                return new int[]{-1, -1};\\n            }\\n        }\\n        // check right 0-padding for least significant bits\\n        int rpad1 = plist.get(s2) - plist.get(s2-1) - 1;\\n        int rpad2 = plist.get(s3) - plist.get(s3-1) - 1;\\n        int rpad3 = A.length - plist.get(plist.size()-1) - 1;\\n        if (rpad1 < rpad3 || rpad2 < rpad3) {\\n            return new int[]{-1, -1};\\n        }\\n        \\n        return new int[]{\\n            plist.get(s2-1)+rpad3, \\n            plist.get(s3-1)+rpad3+1\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375386,
                "title": "simple-c-soultion-with-detailed-analysis",
                "content": "The core idea is:\\n1. if we look from backward, **the last element must be valid part of the 3-rd number.**\\n2. we can get *how many \\'1\\' should be in a part* by **counting how many one in array** and divde it into 3\\n3. if we get a fraction instead an integer, it must **not** equal.\\n4. then we just **count how many 1 has seen** to get every part\\'s start position\\n5. compare 3 parts of the array to ensure they\\'re equal.\\n\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* threeEqualParts(int* A, int ASize, int* returnSize){\\n    int n,i;\\n    int *r = (int *)malloc(sizeof(int)*2);\\n    r[0]=r[1]=-1;\\n    *returnSize = 2;\\n    //count how many ones in array\\n    for(n = i = 0; i < ASize; i++)\\n    {\\n        if(A[i])n++;\\n    }\\n    //if it\\'s worth trying, it must contain equal ones of each\\n    if(n && n % 3 == 0)\\n    {\\n        uint16_t d = 0; // length of a part\\n        uint16_t q = 0; // length counter of a part and its forehead\\n        uint16_t p=0; // counter of \\'1\\' has read\\n        uint16_t s=0; // current position record pointer\\n        uint16_t k[3]={0}; //begin positions of parts\\n        //every part has this amount of \\'1\\'\\n        n /= 3;\\n        //loop from backward in order to count acutal part size first.\\n        for(i = ASize - 1;i>=0;i--)\\n        {\\n            q++; // count how many chars gone though\\n            if(A[i] && (++p % n == 0 || n == 1)) // if \\'1\\' then test if reached a point to do segment\\n            {\\n                k[s++]=i; //record and move pointer to next record\\n                if(d == 0) d = ASize - i; //set corret length of a part\\n                else if(d < n || d > q) return r; // incorret length found, immediate return\\n                q = 0; // reset part char counter for next one\\n            }\\n        }\\n        //detect unmatch pattern\\n        for(i = 0; i < d; i++)\\n        {\\n            if(!((A+k[2])[i]==(A+k[0])[i] && (A+k[0])[i] == (A+k[1])[i]))return r;\\n        }\\n        //set position to first one\\'s last char and second one\\'s last char\\n        r[0] = k[2]+d-1;\\n        r[1] = k[1]+d;\\n    }\\n    else if(n == 0)\\n    {\\n        //wired, unwritten rule, even applies to empty input.\\n        r[0]=0;\\n        r[1]=ASize-1;\\n    }\\n    return r;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* threeEqualParts(int* A, int ASize, int* returnSize){\\n    int n,i;\\n    int *r = (int *)malloc(sizeof(int)*2);\\n    r[0]=r[1]=-1;\\n    *returnSize = 2;\\n    //count how many ones in array\\n    for(n = i = 0; i < ASize; i++)\\n    {\\n        if(A[i])n++;\\n    }\\n    //if it\\'s worth trying, it must contain equal ones of each\\n    if(n && n % 3 == 0)\\n    {\\n        uint16_t d = 0; // length of a part\\n        uint16_t q = 0; // length counter of a part and its forehead\\n        uint16_t p=0; // counter of \\'1\\' has read\\n        uint16_t s=0; // current position record pointer\\n        uint16_t k[3]={0}; //begin positions of parts\\n        //every part has this amount of \\'1\\'\\n        n /= 3;\\n        //loop from backward in order to count acutal part size first.\\n        for(i = ASize - 1;i>=0;i--)\\n        {\\n            q++; // count how many chars gone though\\n            if(A[i] && (++p % n == 0 || n == 1)) // if \\'1\\' then test if reached a point to do segment\\n            {\\n                k[s++]=i; //record and move pointer to next record\\n                if(d == 0) d = ASize - i; //set corret length of a part\\n                else if(d < n || d > q) return r; // incorret length found, immediate return\\n                q = 0; // reset part char counter for next one\\n            }\\n        }\\n        //detect unmatch pattern\\n        for(i = 0; i < d; i++)\\n        {\\n            if(!((A+k[2])[i]==(A+k[0])[i] && (A+k[0])[i] == (A+k[1])[i]))return r;\\n        }\\n        //set position to first one\\'s last char and second one\\'s last char\\n        r[0] = k[2]+d-1;\\n        r[1] = k[1]+d;\\n    }\\n    else if(n == 0)\\n    {\\n        //wired, unwritten rule, even applies to empty input.\\n        r[0]=0;\\n        r[1]=ASize-1;\\n    }\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359936,
                "title": "my-o-n-c-solution",
                "content": "At first, we calculate the total number of \\'1\\', and check if it can be divided by 3. Because each part must contain the same number of \\'1\\'.\\nIf not, we just return { -1, -1 }.\\nThen, we calculate the number of \\'0\\' at the end of the array, which means that we won\\'t stop until we find the first \\'1\\' at the end. If the array can be split into 3 parts, each part must has the same number of \\'0\\' as the end of the array.\\nSince we have already got the total number of \\'1\\' and the number of \\'0\\' at the end of the array, we can check if the array can be divided into three parts with the exact number of 1 and 0 as we expected,  and whether the three parts are equal to each other ( pay attention that we should skip the leading zero ). If we can find the result, we record the index, and return it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        vector<int> res;  \\n        int n = A.size();\\n        int zeros = 0; // number of zero at the end\\n        int ones = 0; // total number of one\\n        \\n        // get number of zero at the end\\n        for(int i = n - 1; i >= 0;i--)\\n        {\\n            if(A[i] == 1) break;\\n            zeros++;\\n        }\\n        // get total number of one\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(A[i] == 1) nums++;\\n        }\\n        \\n        // all data in this array is 0, we can divide the array at every place\\n        if(nums == 0)\\n        {\\n            return {0, n - 1};\\n        }\\n        \\n        // the total number of 1 can\\'t be divided by 3. return false.\\n        if(nums % 3) return {-1, -1};\\n\\n        int count = nums / 3;\\n        string target;\\n                \\n        // check if the array can be split into 3 parts\\n        // each parts has (ones/3)\\'s 1, and has (zeros)\\'s 0 at at the end\\n        int i = 0;\\n        for(int k = 0; k < 3;k++)\\n        {\\n            string str;\\n            int one_nums = 0;\\n            int zero_nums = 0;\\n            for(;i < n; i++)\\n            {\\n                if(one_nums == count && zero_nums == zeros) break;\\n                if(A[i] == 0)\\n                {\\n                    if(one_nums == count)\\n                    {\\n                        zero_nums++;\\n                    }\\n                    if(!str.empty()) // skip the leading 0.\\n                        str.push_back(A[i]);\\n                }\\n                else if(A[i] == 1)\\n                {\\n                    if(one_nums == count) // the number of 0 at the end is not match\\n                    {\\n                        return {-1, -1};\\n                    }\\n                    one_nums++;\\n                    str.push_back(A[i]);\\n                }   \\n            }\\n\\n            if(target.empty())\\n            {\\n                target = str;\\n            }\\n            else\\n            {\\n                if(target != str) return {-1, -1};  // current part and last part is not match             \\n            }\\n            if(k == 0) res.push_back(i - 1); // record the index\\n            else if(k == 1) res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        vector<int> res;  \\n        int n = A.size();\\n        int zeros = 0; // number of zero at the end\\n        int ones = 0; // total number of one\\n        \\n        // get number of zero at the end\\n        for(int i = n - 1; i >= 0;i--)\\n        {\\n            if(A[i] == 1) break;\\n            zeros++;\\n        }\\n        // get total number of one\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(A[i] == 1) nums++;\\n        }\\n        \\n        // all data in this array is 0, we can divide the array at every place\\n        if(nums == 0)\\n        {\\n            return {0, n - 1};\\n        }\\n        \\n        // the total number of 1 can\\'t be divided by 3. return false.\\n        if(nums % 3) return {-1, -1};\\n\\n        int count = nums / 3;\\n        string target;\\n                \\n        // check if the array can be split into 3 parts\\n        // each parts has (ones/3)\\'s 1, and has (zeros)\\'s 0 at at the end\\n        int i = 0;\\n        for(int k = 0; k < 3;k++)\\n        {\\n            string str;\\n            int one_nums = 0;\\n            int zero_nums = 0;\\n            for(;i < n; i++)\\n            {\\n                if(one_nums == count && zero_nums == zeros) break;\\n                if(A[i] == 0)\\n                {\\n                    if(one_nums == count)\\n                    {\\n                        zero_nums++;\\n                    }\\n                    if(!str.empty()) // skip the leading 0.\\n                        str.push_back(A[i]);\\n                }\\n                else if(A[i] == 1)\\n                {\\n                    if(one_nums == count) // the number of 0 at the end is not match\\n                    {\\n                        return {-1, -1};\\n                    }\\n                    one_nums++;\\n                    str.push_back(A[i]);\\n                }   \\n            }\\n\\n            if(target.empty())\\n            {\\n                target = str;\\n            }\\n            else\\n            {\\n                if(target != str) return {-1, -1};  // current part and last part is not match             \\n            }\\n            if(k == 0) res.push_back(i - 1); // record the index\\n            else if(k == 1) res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279798,
                "title": "javascript-90ms",
                "content": "```\\nvar threeEqualParts = function(A) {\\n    const getOneCount = () => {\\n        const oneCount = A.reduce((acc, bit) => bit == 1 ? acc + 1 : acc, 0)\\n        if(oneCount % 3 == 0) \\n            return oneCount / 3\\n        return -1\\n    }\\n\\n    const getTail = oneCount => { \\n        let zeroCount = 0, idx = A.length -1\\n        let oneRemain = oneCount\\n        while(oneRemain > 0) {\\n            if(A[idx] == 1) {\\n                oneRemain--\\n            }\\n            if(A[idx] == 0 && oneRemain == oneCount) {\\n                zeroCount++\\n            }\\n            idx--\\n        }\\n        return {zeroCount, tailStart: idx + 1}\\n    }\\n\\n    const getHead = (oneCount, zeroCount) => {\\n        let idx = 0\\n        while(oneCount > 0) {\\n            if(A[idx] == 1)\\n                oneCount--\\n            idx++\\n        }\\n        if(zeroCount > 0) {\\n            while(A[idx] == 0 && zeroCount > 0){\\n                idx++\\n                zeroCount--\\n            }\\n        }\\n        return zeroCount == 0 ? idx-1 : -1\\n    }\\n\\n    const getMiddle = (oneCount, headEnd, tailStart) => {\\n        let idx = headEnd + 1\\n        let tailIdx = tailStart\\n        while(A[idx] != 1) idx++\\n        while(idx < tailStart && A[idx] == A[tailIdx]) {\\n            idx++\\n            tailIdx++\\n        }\\n        if(tailIdx != A.length)\\n            return -1\\n        return idx\\n\\n    }\\n\\n    const oneCount = getOneCount()\\n    if(oneCount == -1 || A.length < 3)\\n        return [-1, -1]\\n    if(oneCount == 0) return [0, A.length-1]\\n    const {tailStart, zeroCount} = getTail(oneCount)\\n    const headEnd = getHead(oneCount, zeroCount)\\n    if(headEnd == -1)\\n        return [-1, -1]\\n    const middleEnd = getMiddle(oneCount, headEnd, tailStart)\\n    if(middleEnd == -1)\\n        return [-1, -1]\\n    return [headEnd, middleEnd]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeEqualParts = function(A) {\\n    const getOneCount = () => {\\n        const oneCount = A.reduce((acc, bit) => bit == 1 ? acc + 1 : acc, 0)\\n        if(oneCount % 3 == 0) \\n            return oneCount / 3\\n        return -1\\n    }\\n\\n    const getTail = oneCount => { \\n        let zeroCount = 0, idx = A.length -1\\n        let oneRemain = oneCount\\n        while(oneRemain > 0) {\\n            if(A[idx] == 1) {\\n                oneRemain--\\n            }\\n            if(A[idx] == 0 && oneRemain == oneCount) {\\n                zeroCount++\\n            }\\n            idx--\\n        }\\n        return {zeroCount, tailStart: idx + 1}\\n    }\\n\\n    const getHead = (oneCount, zeroCount) => {\\n        let idx = 0\\n        while(oneCount > 0) {\\n            if(A[idx] == 1)\\n                oneCount--\\n            idx++\\n        }\\n        if(zeroCount > 0) {\\n            while(A[idx] == 0 && zeroCount > 0){\\n                idx++\\n                zeroCount--\\n            }\\n        }\\n        return zeroCount == 0 ? idx-1 : -1\\n    }\\n\\n    const getMiddle = (oneCount, headEnd, tailStart) => {\\n        let idx = headEnd + 1\\n        let tailIdx = tailStart\\n        while(A[idx] != 1) idx++\\n        while(idx < tailStart && A[idx] == A[tailIdx]) {\\n            idx++\\n            tailIdx++\\n        }\\n        if(tailIdx != A.length)\\n            return -1\\n        return idx\\n\\n    }\\n\\n    const oneCount = getOneCount()\\n    if(oneCount == -1 || A.length < 3)\\n        return [-1, -1]\\n    if(oneCount == 0) return [0, A.length-1]\\n    const {tailStart, zeroCount} = getTail(oneCount)\\n    const headEnd = getHead(oneCount, zeroCount)\\n    if(headEnd == -1)\\n        return [-1, -1]\\n    const middleEnd = getMiddle(oneCount, headEnd, tailStart)\\n    if(middleEnd == -1)\\n        return [-1, -1]\\n    return [headEnd, middleEnd]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184213,
                "title": "java-o-n-time-o-1-space-8-ms",
                "content": "1. Check if there are enough number of ones for three parts (aka number of ones is a multiple of 3).\n2. Iterate the array from the tail and find the spot that marks the start of a binary number with n/3 1s (n is total number of ones).\n3. Lets call the marker in step 2 \"part3\". We need to check to see if there are 2 more occurences of this part (part3 to end of array) between 0 and part3.\n4. In order to lookup the part, start from the beginning of the array, ignoring all the leading zeros (as they don't contribute to the value), try to match with  the number formed by part3 - end. \n5. Repeat step 4 one more time, this time starting at the end of first match.\n```\nclass Solution {\n    public int[] threeEqualParts(int[] A) {\n        int count = 0;\n        for(int i : A){\n            count = count+i;\n        }\n        if(count==0){\n            return new int[]{0,A.length-1};\n        }\n        if(count%3!=0){\n            return new int[]{-1,-1};\n        }\n        int part3 = A.length;\n        int soFar = 0;\n        while(soFar<count/3 && part3>-1){\n            part3--;\n            soFar += A[part3];            \n        }\n        int tracker = match(A, 0, part3);\n        if(tracker==-1){\n            return new int[]{-1, -1};\n        }\n        int end = match(A, tracker, part3);\n        if(end==-1){\n            return new int[]{-1, -1};\n        }        \n        return new int[]{tracker-1, end};\n    }\n    \n    private int match(int[] A, int start, int ref){      \n        while(A[start]==0){\n            start++;\n        }    \n        while(ref < A.length){\n            if(A[ref]!=A[start]){\n                return -1;\n            }\n            ref++;\n            start++;\n        }\n        return start;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int[] threeEqualParts(int[] A) {\n        int count = 0;\n        for(int i : A){\n            count = count+i;\n        }\n        if(count==0){\n            return new int[]{0,A.length-1};\n        }\n        if(count%3!=0){\n            return new int[]{-1,-1};\n        }\n        int part3 = A.length;\n        int soFar = 0;\n        while(soFar<count/3 && part3>-1){\n            part3--;\n            soFar += A[part3];            \n        }\n        int tracker = match(A, 0, part3);\n        if(tracker==-1){\n            return new int[]{-1, -1};\n        }\n        int end = match(A, tracker, part3);\n        if(end==-1){\n            return new int[]{-1, -1};\n        }        \n        return new int[]{tracker-1, end};\n    }\n    \n    private int match(int[] A, int start, int ref){      \n        while(A[start]==0){\n            start++;\n        }    \n        while(ref < A.length){\n            if(A[ref]!=A[start]){\n                return -1;\n            }\n            ref++;\n            start++;\n        }\n        return start;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 183986,
                "title": "c-easy-to-understand-o-n",
                "content": "If we can divide the number of 1s into 3 equal parts, we can just check the three parts for equality. \nDividing 1s into 3 partitions and checking for equality is a necessary and sufficient condition for the answer.\nWe need to take care of 0s only in the third partition because they will be trailing zeros always and will add to the third binary number representation always.\nAs long as first and second partition have the same number of trailing zeros as the third representation, we have a solution. We do not care about any other zeros in the first and second partition because trailing zeros of first can add to leading zeros of second and trailing zeros of second can add to leading zeros of third.\n\n```\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        int num1s=0;\n        for(int i:A) {\n            if(i==1)\n                num1s++;\n        }\n        if(num1s%3!=0)\n            return {-1,-1};\n        if(num1s==0)\n            return {0,A.size()-1};\n        int c=num1s/3;\n        vector<int> nums(3,0);\n        int count=0;\n        for(int i=0;i<A.size();i++) {\n            //If this is the start of the next binary representation(0 or 1 or 2 in vector nums)\n            if(A[i]==1) {\n                if(count%c==0) {\n                    nums[count/c]=i;  //assign current index to nums[0,1,2]\n                }\n                count++;\n            } \n        }\n        //Every other representation should follow Last representation \n        while(nums[2]!=A.size()) {   \n            if(A[nums[0]]!=A[nums[1]] || A[nums[0]]!=A[nums[2]])\n                return {-1,-1};\n            nums[0]++;\n            nums[1]++;\n            nums[2]++;\n        }\n        return {nums[0]-1, nums[1]};\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        int num1s=0;\n        for(int i:A) {\n            if(i==1)\n                num1s++;\n        }\n        if(num1s%3!=0)\n            return {-1,-1};\n        if(num1s==0)\n            return {0,A.size()-1};\n        int c=num1s/3;\n        vector<int> nums(3,0);\n        int count=0;\n        for(int i=0;i<A.size();i++) {\n            //If this is the start of the next binary representation(0 or 1 or 2 in vector nums)\n            if(A[i]==1) {\n                if(count%c==0) {\n                    nums[count/c]=i;  //assign current index to nums[0,1,2]\n                }\n                count++;\n            } \n        }\n        //Every other representation should follow Last representation \n        while(nums[2]!=A.size()) {   \n            if(A[nums[0]]!=A[nums[1]] || A[nums[0]]!=A[nums[2]])\n                return {-1,-1};\n            nums[0]++;\n            nums[1]++;\n            nums[2]++;\n        }\n        return {nums[0]-1, nums[1]};\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521758,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n     \\n        int countone=count(arr.begin(),arr.end(),1);\\n        int n=arr.size();\\n        if(countone%3)\\n        {\\n            return {-1,-1};\\n        }\\n        if(countone==0)\\n        {\\n            return {0,n-1};\\n        }\\n        int total=countone/3;\\n        int p1=0,p2=0,p3=0;\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                if(count==0)\\n                {\\n                    p1=i;\\n                }\\n                else if(count==total)\\n                {\\n                    p2=i;\\n                }\\n                else if(count==2*total)\\n                {\\n                    p3=i;\\n                }\\n                count+=1;\\n            }\\n        }\\n        while(p3<n-1)\\n        {\\n            p1+=1;\\n            p2+=1;\\n            p3+=1;\\n            if(arr[p1]!=arr[p2] || arr[p2]!=arr[p3] || arr[p1]!=arr[p3])\\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        return {p1,p2+1};\\n    } \\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        ones = [i for i, j in enumerate(arr) if j==1]\\n        n=len(ones)\\n\\n        if not ones:\\n            return [0, 2]\\n        if n%3:\\n            return [-1, -1]\\n        \\n        i,j,k = ones[0], ones[n//3], ones[n//3*2]\\n        l = len(arr)-k\\n\\n        if arr[i:i+l]==arr[j:j+l]==arr[k:k+l]:\\n            return [i+l-1, j+l]\\n\\n        return [-1, -1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1};\\n        if(oneSum == 0)return new int[]{0,2};\\n        int oneCount = oneSum / 3;\\n        int i = 0;\\n        int firstOne = -1;\\n        int n= arr.length;\\n        int lastZeroCount = 0;\\n        i = n-1;\\n        while(arr[i] ==0){\\n            lastZeroCount++;\\n            i--;\\n        }\\n        i=0;\\n        while(oneCount > 0){\\n            if(arr[i] == 1 && firstOne == -1)firstOne = i;\\n            oneCount-=arr[i++];\\n        }\\n        while(lastZeroCount > 0){\\n            if(arr[i++] == 1)return new int[]{-1,-1};\\n            lastZeroCount--;\\n        }\\n        int k = i--;\\n        int t = firstOne;\\n        while(arr[k] == 0)k++;\\n        while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        int j = k;\\n        while(arr[k] == 0)k++;\\n        firstOne = t;\\n         while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        return new int[]{i,j};\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n     \\n        int countone=count(arr.begin(),arr.end(),1);\\n        int n=arr.size();\\n        if(countone%3)\\n        {\\n            return {-1,-1};\\n        }\\n        if(countone==0)\\n        {\\n            return {0,n-1};\\n        }\\n        int total=countone/3;\\n        int p1=0,p2=0,p3=0;\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                if(count==0)\\n                {\\n                    p1=i;\\n                }\\n                else if(count==total)\\n                {\\n                    p2=i;\\n                }\\n                else if(count==2*total)\\n                {\\n                    p3=i;\\n                }\\n                count+=1;\\n            }\\n        }\\n        while(p3<n-1)\\n        {\\n            p1+=1;\\n            p2+=1;\\n            p3+=1;\\n            if(arr[p1]!=arr[p2] || arr[p2]!=arr[p3] || arr[p1]!=arr[p3])\\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        return {p1,p2+1};\\n    } \\n};\\n```\n```Python3 []\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        ones = [i for i, j in enumerate(arr) if j==1]\\n        n=len(ones)\\n\\n        if not ones:\\n            return [0, 2]\\n        if n%3:\\n            return [-1, -1]\\n        \\n        i,j,k = ones[0], ones[n//3], ones[n//3*2]\\n        l = len(arr)-k\\n\\n        if arr[i:i+l]==arr[j:j+l]==arr[k:k+l]:\\n            return [i+l-1, j+l]\\n\\n        return [-1, -1]\\n```\n```Java []\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1};\\n        if(oneSum == 0)return new int[]{0,2};\\n        int oneCount = oneSum / 3;\\n        int i = 0;\\n        int firstOne = -1;\\n        int n= arr.length;\\n        int lastZeroCount = 0;\\n        i = n-1;\\n        while(arr[i] ==0){\\n            lastZeroCount++;\\n            i--;\\n        }\\n        i=0;\\n        while(oneCount > 0){\\n            if(arr[i] == 1 && firstOne == -1)firstOne = i;\\n            oneCount-=arr[i++];\\n        }\\n        while(lastZeroCount > 0){\\n            if(arr[i++] == 1)return new int[]{-1,-1};\\n            lastZeroCount--;\\n        }\\n        int k = i--;\\n        int t = firstOne;\\n        while(arr[k] == 0)k++;\\n        while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        int j = k;\\n        while(arr[k] == 0)k++;\\n        firstOne = t;\\n         while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        return new int[]{i,j};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110888,
                "title": "easy-c-solution-using-strings-in-o-n-time-and-space-complexity",
                "content": "# Intuition\\nThree Simple observations :-\\n1.Total number of ones should be multiple of 3.\\n2.Leading zeroes do not contribute\\n3.Number of zeroes after the last one of all 3 parts will be equal to the number of zeroes after the last one in 3rd part.\\n\\n# Approach\\n1.Store the indexes of ones in a vector and check if the size is multiple of 3.\\n2.Check if the zeroes after the last 1s of first and second part are greater than or equal to zeroes after the last one in 3rd part.\\n3.Form strings for all 3 parts ignoring leading zeroes and check if they are equal.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& v) {\\n        vector<int> one;\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            if(v[i]==1) one.push_back(i+1);\\n        }\\n        if(one.size()==0){\\n            return {0,2};\\n        }\\n        if(one.size()%3)    return {-1,-1};\\n\\n        int ext=n-one.back(),sz=one.size();\\n        int gap1=one[sz/3]-one[sz/3-1]-1,gap2=one[2*sz/3]-one[2*sz/3-1]-1;\\n        // cout<<gap1<<\" \"<<gap2<<endl;\\n        if(gap1<ext || gap2<ext)    return {-1,-1};\\n\\n        string s1,s2,s3;\\n        for(int i=0;i<=one[sz/3-1]+ext-1;i++){\\n            if(s1.length()>0 || v[i])   s1+=to_string(v[i]);\\n        }\\n\\n        for(int i=one[sz/3-1]+ext;i<=one[2*sz/3-1]+ext-1;i++){\\n            if(s2.length()>0 || v[i])   s2+=to_string(v[i]);\\n        }\\n\\n        for(int i=one[2*sz/3-1]+ext;i<=n-1;i++){\\n            if(s3.length()>0 || v[i])   s3+=to_string(v[i]);\\n        }\\n        //All 3 Numbers in vector v :-\\n        // num1={0,one[sz/3-1]+ext-1};\\n        // num2={one[sz/3-1]+ext,one[2*sz/3-1]+ext-1}\\n        // num3={one[2*sz/3-1]+ext,n-1};\\n        if(s1==s2 && s2==s3)    return {one[sz/3-1]+ext-1,one[2*sz/3-1]+ext};\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& v) {\\n        vector<int> one;\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            if(v[i]==1) one.push_back(i+1);\\n        }\\n        if(one.size()==0){\\n            return {0,2};\\n        }\\n        if(one.size()%3)    return {-1,-1};\\n\\n        int ext=n-one.back(),sz=one.size();\\n        int gap1=one[sz/3]-one[sz/3-1]-1,gap2=one[2*sz/3]-one[2*sz/3-1]-1;\\n        // cout<<gap1<<\" \"<<gap2<<endl;\\n        if(gap1<ext || gap2<ext)    return {-1,-1};\\n\\n        string s1,s2,s3;\\n        for(int i=0;i<=one[sz/3-1]+ext-1;i++){\\n            if(s1.length()>0 || v[i])   s1+=to_string(v[i]);\\n        }\\n\\n        for(int i=one[sz/3-1]+ext;i<=one[2*sz/3-1]+ext-1;i++){\\n            if(s2.length()>0 || v[i])   s2+=to_string(v[i]);\\n        }\\n\\n        for(int i=one[2*sz/3-1]+ext;i<=n-1;i++){\\n            if(s3.length()>0 || v[i])   s3+=to_string(v[i]);\\n        }\\n        //All 3 Numbers in vector v :-\\n        // num1={0,one[sz/3-1]+ext-1};\\n        // num2={one[sz/3-1]+ext,one[2*sz/3-1]+ext-1}\\n        // num3={one[2*sz/3-1]+ext,n-1};\\n        if(s1==s2 && s2==s3)    return {one[sz/3-1]+ext-1,one[2*sz/3-1]+ext};\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3065197,
                "title": "simple-python-solution-with-explanation",
                "content": "# Approach\\n\\n> *divide the array into three non-empty parts such that all of these parts represent the same binary value*\\n\\nSame binary value means \\n\\n* each part has to have **<ins>equal number of ones<ins>** and zeroes\\n* order of ones and zeroes should be same\\n\\n\\n### Part 1: Equal number of ones and ending zeroes\\n\\n\\nLets take below array as an example for understanding:\\n\\n![Untitled-2023-01-11-1852(17).png](https://assets.leetcode.com/users/images/e38a4680-1a58-495f-b448-dd8ed52ef478_1673977794.7565248.png)\\n\\n\\n* These binary values will have equal number of ones, which means the total count of ones should be a multiple of 3\\n\\n\\n    ![Untitled-2023-01-11-1852(18).png](https://assets.leetcode.com/users/images/3deeed2e-67fb-4081-84b4-21022fe00271_1673977804.008318.png)\\n\\n\\n\\n* We know in a binary number, starting zeroes doesnt matter, however ending zeroes does matter. So I can find the `ending_zeroes` for my binary number using the location of last one:\\n\\n    ![Untitled-2023-01-11-1852(14).png](https://assets.leetcode.com/users/images/e0b8d6c8-fb23-4a46-94da-3f0e5f9a73c9_1673977354.461905.png)\\n\\n\\n* We need to add these ending_zeroes count after every `total_count_of_ones // 3` ie in the example after every 3 count of ones\\n\\n    ![Untitled-2023-01-11-1852(16).png](https://assets.leetcode.com/users/images/cd4192ca-1d8e-47ed-a2ed-3ab48d0670f0_1673977459.8463302.png)\\n\\n* Now, we know the location of `i` and `j`\\n\\n\\n\\nNOTE:\\n    \\n* All above steps can be done by traversing through the loop, \\n\\n    however in my code below I have used prefix sum and binary search --> using modified binary_search to fetch index of the first occurrence in the prefix_sum \\n\\n    for example: \\n    ```\\n    ending_zeroes = n - 1 - (index of first occurrence of total_count_of_ones in prefix_sum, ie 9 in this example)\\n    ```\\n    \\n\\n    ![Untitled-2023-01-11-1852(15).png](https://assets.leetcode.com/users/images/50ef8629-2165-40b8-b3f4-303596ecb423_1673980808.0708501.png)\\n\\n\\n    Creation of prefix sum takes `O(n)` time, so no major optimisation with this, this just looked clean to me :)\\n\\n\\n\\n### Part 2: Order of ones and zeroes\\n\\nThis is simple, for each identified part\\n\\n* disregard starting zeroes\\n* then, check if order of each ones and zeroes is same\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + log(n))$$ = $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ - for prefix_sum\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n\\n        # part 1\\n\\n        # get total_count and create prefix_sum\\n        total_count = 0\\n        prefix_sum = [0] * n\\n        for i in range(n):\\n            total_count += arr[i]\\n            prefix_sum[i] = total_count\\n\\n        # checking if multiple of 3\\n        if total_count % 3 != 0:\\n            return [-1, -1]\\n        elif total_count == 0:\\n            return [0, n - 1]\\n\\n        # binary search to get first occurrence of `val` using prefix_sum\\n        def bin_search(val):\\n            start = 0\\n            end = n - 1\\n            mid = 0\\n\\n            while start <= end:\\n                mid = (start + end) // 2\\n                if prefix_sum[mid] >= val:\\n                    if start == end:\\n                        return mid\\n                    end = mid\\n                else:\\n                    start = mid + 1\\n\\n            return mid\\n\\n        \\n        # count of ones in each part and count of ending_zeroes\\n        part_count = total_count // 3\\n        ending_zeroes = n - 1 - bin_search(total_count)\\n\\n        # value of i and j using binary_search and ending_zeroes\\n        i = bin_search(part_count) + ending_zeroes + 1\\n        j = bin_search(total_count - part_count) + ending_zeroes + 1\\n\\n\\n\\n        # part 2\\n\\n        # disregard starting zeroes in first part\\n        a = 0\\n        while a < n and arr[a] == 0:\\n            a += 1\\n\\n        # disregard starting zeroes in second part\\n        b = i\\n        while b < n and arr[b] == 0:\\n            b += 1\\n\\n        # disregard starting zeroes in third part\\n        c = j\\n        while c < n and arr[c] == 0:\\n            c += 1\\n\\n        # check if indices have same order of ones and zeroes\\n        while c < n:\\n            if arr[a] == arr[b] and arr[b] == arr[c]:\\n                a += 1\\n                b += 1\\n                c += 1\\n            else:\\n                return [-1, -1]\\n\\n        if a == i and b == j:\\n            return [i - 1, j]\\n        else:\\n            return [-1, -1]\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n    ending_zeroes = n - 1 - (index of first occurrence of total_count_of_ones in prefix_sum, ie 9 in this example)\\n    ```\n```python []\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n\\n        # part 1\\n\\n        # get total_count and create prefix_sum\\n        total_count = 0\\n        prefix_sum = [0] * n\\n        for i in range(n):\\n            total_count += arr[i]\\n            prefix_sum[i] = total_count\\n\\n        # checking if multiple of 3\\n        if total_count % 3 != 0:\\n            return [-1, -1]\\n        elif total_count == 0:\\n            return [0, n - 1]\\n\\n        # binary search to get first occurrence of `val` using prefix_sum\\n        def bin_search(val):\\n            start = 0\\n            end = n - 1\\n            mid = 0\\n\\n            while start <= end:\\n                mid = (start + end) // 2\\n                if prefix_sum[mid] >= val:\\n                    if start == end:\\n                        return mid\\n                    end = mid\\n                else:\\n                    start = mid + 1\\n\\n            return mid\\n\\n        \\n        # count of ones in each part and count of ending_zeroes\\n        part_count = total_count // 3\\n        ending_zeroes = n - 1 - bin_search(total_count)\\n\\n        # value of i and j using binary_search and ending_zeroes\\n        i = bin_search(part_count) + ending_zeroes + 1\\n        j = bin_search(total_count - part_count) + ending_zeroes + 1\\n\\n\\n\\n        # part 2\\n\\n        # disregard starting zeroes in first part\\n        a = 0\\n        while a < n and arr[a] == 0:\\n            a += 1\\n\\n        # disregard starting zeroes in second part\\n        b = i\\n        while b < n and arr[b] == 0:\\n            b += 1\\n\\n        # disregard starting zeroes in third part\\n        c = j\\n        while c < n and arr[c] == 0:\\n            c += 1\\n\\n        # check if indices have same order of ones and zeroes\\n        while c < n:\\n            if arr[a] == arr[b] and arr[b] == arr[c]:\\n                a += 1\\n                b += 1\\n                c += 1\\n            else:\\n                return [-1, -1]\\n\\n        if a == i and b == j:\\n            return [i - 1, j]\\n        else:\\n            return [-1, -1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790358,
                "title": "c-o-n-time-complexity-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        // Time complexity - O(N)\\n\\t\\t\\n        int size = arr.size(), count=0, tcount=0, iptr=0, jptr=2;\\n        string str = \"\", t = \"\", h1 = \"\", h2 = \"\";\\n        vector<int>res(2,-1);\\n        for(int i=0;i<size;i++){\\n            str += (arr[i] ? \\'1\\' : \\'0\\');\\n            count += arr[i];\\n        }\\n        if(count == 0){\\n            res[0] = 0, res[1] = size-1;\\n            return res;\\n        }\\n        if(count%3) return res;\\n        count /= 3;\\n        reverse(str.begin(), str.end());\\n\\t\\t// reversed the string to easily process ending zeros of 3rd part in unreversed string\\n\\t\\t\\n        // find first part string for future comparision\\n        tcount = 0;\\n        for(int i=0;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n            jptr = i;\\n        }\\n        \\n        // find second string for comparision\\n        h1 = t, t = \"\";\\n        tcount = 0;\\n        for(int i=jptr+1;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n            iptr = i;\\n        }\\n        \\n        if(t.length() < h1.length()) return res;\\n        h2 = t.substr( (t.length()-h1.length()), h1.length() );\\n        \\n        if(h1 != h2) return res;\\n        jptr += t.length()-h1.length();\\n        \\n        // find last string for comparision\\n        t = \"\";\\n        tcount = 0;\\n        for(int i=iptr+1;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n        }\\n        \\n        if(t.length() < h1.length()) return res;\\n        h2 = t.substr( (t.length()-h1.length()), h1.length() );\\n        if(h1 != h2) return res;\\n        \\n        iptr += t.length()-h1.length();\\n        \\n        res[0] = size-1-(iptr+1);\\n        res[1] = size-1-jptr;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        // Time complexity - O(N)\\n\\t\\t\\n        int size = arr.size(), count=0, tcount=0, iptr=0, jptr=2;\\n        string str = \"\", t = \"\", h1 = \"\", h2 = \"\";\\n        vector<int>res(2,-1);\\n        for(int i=0;i<size;i++){\\n            str += (arr[i] ? \\'1\\' : \\'0\\');\\n            count += arr[i];\\n        }\\n        if(count == 0){\\n            res[0] = 0, res[1] = size-1;\\n            return res;\\n        }\\n        if(count%3) return res;\\n        count /= 3;\\n        reverse(str.begin(), str.end());\\n\\t\\t// reversed the string to easily process ending zeros of 3rd part in unreversed string\\n\\t\\t\\n        // find first part string for future comparision\\n        tcount = 0;\\n        for(int i=0;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n            jptr = i;\\n        }\\n        \\n        // find second string for comparision\\n        h1 = t, t = \"\";\\n        tcount = 0;\\n        for(int i=jptr+1;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n            iptr = i;\\n        }\\n        \\n        if(t.length() < h1.length()) return res;\\n        h2 = t.substr( (t.length()-h1.length()), h1.length() );\\n        \\n        if(h1 != h2) return res;\\n        jptr += t.length()-h1.length();\\n        \\n        // find last string for comparision\\n        t = \"\";\\n        tcount = 0;\\n        for(int i=iptr+1;i<size && tcount < count;i++){\\n            t += str[i];\\n            if(str[i] == \\'1\\') tcount++;\\n        }\\n        \\n        if(t.length() < h1.length()) return res;\\n        h2 = t.substr( (t.length()-h1.length()), h1.length() );\\n        if(h1 != h2) return res;\\n        \\n        iptr += t.length()-h1.length();\\n        \\n        res[0] = size-1-(iptr+1);\\n        res[1] = size-1-jptr;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949754,
                "title": "python-faster-than-100-00",
                "content": "\\tdef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = arr.count(1)\\n        if ones == 0: return [0, 2]\\n        if ones % 3: return [-1, -1]\\n        ones_in_number = ones//3\\n        \\n        ones = 0\\n        start0 = i = arr.index(1)\\n        while(ones < ones_in_number):\\n            if arr[i]:\\n                ones+=1\\n            i+=1\\n            \\n        l = i-start0\\n        start1 = arr.index(1, start0+l)\\n        start2 = arr.index(1, start1+l)\\n\\n        l += len(arr)-(start2+l)\\n        \\n        if arr[start0:start0+l] == arr[start1:start1+l] == arr[start2:start2+l]:\\n            return [start0+l-1, start1+l]\\n        else:\\n            return [-1, -1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tdef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = arr.count(1)\\n        if ones == 0: return [0, 2]\\n        if ones % 3: return [-1, -1]\\n        ones_in_number = ones//3\\n        \\n        ones = 0\\n        start0 = i = arr.index(1)\\n        while(ones < ones_in_number):\\n            if arr[i]:\\n                ones+=1\\n            i+=1\\n            \\n        l = i-start0\\n        start1 = arr.index(1, start0+l)\\n        start2 = arr.index(1, start1+l)\\n\\n        l += len(arr)-(start2+l)\\n        \\n        if arr[start0:start0+l] == arr[start1:start1+l] == arr[start2:start2+l]:\\n            return [start0+l-1, start1+l]\\n        else:\\n            return [-1, -1]",
                "codeTag": "Python3"
            },
            {
                "id": 1938784,
                "title": "three-equal-parts-solution-java",
                "content": "class Solution {\\n  public int[] threeEqualParts(int[] A) {\\n    int ones = 0;\\n\\n    for (int a : A)\\n      if (a == 1)\\n        ++ones;\\n\\n    if (ones == 0)\\n      return new int[] {0, A.length - 1};\\n    if (ones % 3 != 0)\\n      return new int[] {-1, -1};\\n\\n    int k = ones / 3;\\n    int i = 0;\\n    int j = 0;\\n    int first = 0;\\n    int second = 0;\\n    int third = 0;\\n\\n    for (i = 0; i < A.length; ++i)\\n      if (A[i] == 1) {\\n        first = i;\\n        break;\\n      }\\n\\n    int gapOnes = k;\\n\\n    for (j = i + 1; j < A.length; ++j)\\n      if (A[j] == 1 && --gapOnes == 0) {\\n        second = j;\\n        break;\\n      }\\n\\n    gapOnes = k;\\n\\n    for (i = j + 1; i < A.length; ++i)\\n      if (A[i] == 1 && --gapOnes == 0) {\\n        third = i;\\n        break;\\n      }\\n\\n    while (third < A.length && A[first] == A[second] && A[second] == A[third]) {\\n      ++first;\\n      ++second;\\n      ++third;\\n    }\\n\\n    if (third == A.length)\\n      return new int[] {first - 1, second};\\n    return new int[] {-1, -1};\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\n  public int[] threeEqualParts(int[] A) {\\n    int ones = 0;\\n\\n    for (int a : A)\\n      if (a == 1)\\n        ++ones;\\n\\n    if (ones == 0)\\n      return new int[] {0, A.length - 1}",
                "codeTag": "Java"
            },
            {
                "id": 1737751,
                "title": "typescript-documented-to-be-easy-to-understand",
                "content": "```\\nfunction threeEqualParts(dd: number[]) {\\n  // Every part has to have the same number of digit 1, and so it must be divisible by 3.\\n  const countOnes = dd.reduce<number>((total, i) => total + (i === 1 ? 1 : 0), 0);\\n  if (countOnes === 0) return [0, 2];\\n  if (countOnes % 3 !== 0) return [-1, -1];\\n\\n  // Get inclusive indexes of the middle part, from 1 to 1. So in \"1010 101 0101\"\\n  // the indexes would be 4 to 6. Same number of 1s in each third.\\n  let [i, j] = (() => {\\n    let indexes = [];\\n    let ones = 0;\\n    for (let inx = 0; inx < dd.length && indexes.length < 2; inx++) {\\n      if (dd[inx] === 1) {\\n        ones++;\\n        if (ones === (countOnes * 2) / 3) indexes.push(inx);\\n        if (ones === countOnes / 3 + 1) indexes.push(inx);\\n      }\\n    }\\n    return [indexes[0], indexes[1]];\\n  })();\\n\\n  // Every number has to have the same number of zeros on the end as the last number.\\n  // Otherwise their values won\\'t be the same.\\n  const requiredZerosAtEnd = dd.length - dd.lastIndexOf(1, dd.length - 1) - 1;\\n\\n  // Try to adjust the middle number by incrementing j so it has proper number of 0s on\\n  // the end.\\n  const zerosRight = (inx: number) => {\\n    const nextOne = dd.indexOf(1, inx + 1);\\n    return nextOne === -1 ? dd.length - inx - 1 : nextOne - inx - 1;\\n  };\\n  if (zerosRight(j) >= requiredZerosAtEnd) {\\n    j += requiredZerosAtEnd;\\n  } else {\\n    return [-1, -1];\\n  }\\n\\n  // Try to adjust the first number by moving i so it has proper number of 0s on the end.\\n  const lastOneInFirstPart = dd.lastIndexOf(1, i - 1);\\n  if (zerosRight(lastOneInFirstPart) >= requiredZerosAtEnd) {\\n    i = lastOneInFirstPart + requiredZerosAtEnd + 1;\\n  } else {\\n    return [-1, -1];\\n  }\\n\\n  // Compare the three numbers, bit by bit, to see if they are the same.\\n  [i, j] = [i - 1, j + 1];\\n  let aStart = dd.indexOf(1, 0);\\n  let bStart = dd.indexOf(1, i + 1);\\n  let cStart = dd.indexOf(1, j);\\n  while (cStart !== dd.length) {\\n    if (dd[aStart] === dd[bStart] && dd[bStart] === dd[cStart]) {\\n      aStart++;\\n      bStart++;\\n      cStart++;\\n    } else return [-1, -1];\\n  }\\n  return [i, j];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction threeEqualParts(dd: number[]) {\\n  // Every part has to have the same number of digit 1, and so it must be divisible by 3.\\n  const countOnes = dd.reduce<number>((total, i) => total + (i === 1 ? 1 : 0), 0);\\n  if (countOnes === 0) return [0, 2];\\n  if (countOnes % 3 !== 0) return [-1, -1];\\n\\n  // Get inclusive indexes of the middle part, from 1 to 1. So in \"1010 101 0101\"\\n  // the indexes would be 4 to 6. Same number of 1s in each third.\\n  let [i, j] = (() => {\\n    let indexes = [];\\n    let ones = 0;\\n    for (let inx = 0; inx < dd.length && indexes.length < 2; inx++) {\\n      if (dd[inx] === 1) {\\n        ones++;\\n        if (ones === (countOnes * 2) / 3) indexes.push(inx);\\n        if (ones === countOnes / 3 + 1) indexes.push(inx);\\n      }\\n    }\\n    return [indexes[0], indexes[1]];\\n  })();\\n\\n  // Every number has to have the same number of zeros on the end as the last number.\\n  // Otherwise their values won\\'t be the same.\\n  const requiredZerosAtEnd = dd.length - dd.lastIndexOf(1, dd.length - 1) - 1;\\n\\n  // Try to adjust the middle number by incrementing j so it has proper number of 0s on\\n  // the end.\\n  const zerosRight = (inx: number) => {\\n    const nextOne = dd.indexOf(1, inx + 1);\\n    return nextOne === -1 ? dd.length - inx - 1 : nextOne - inx - 1;\\n  };\\n  if (zerosRight(j) >= requiredZerosAtEnd) {\\n    j += requiredZerosAtEnd;\\n  } else {\\n    return [-1, -1];\\n  }\\n\\n  // Try to adjust the first number by moving i so it has proper number of 0s on the end.\\n  const lastOneInFirstPart = dd.lastIndexOf(1, i - 1);\\n  if (zerosRight(lastOneInFirstPart) >= requiredZerosAtEnd) {\\n    i = lastOneInFirstPart + requiredZerosAtEnd + 1;\\n  } else {\\n    return [-1, -1];\\n  }\\n\\n  // Compare the three numbers, bit by bit, to see if they are the same.\\n  [i, j] = [i - 1, j + 1];\\n  let aStart = dd.indexOf(1, 0);\\n  let bStart = dd.indexOf(1, i + 1);\\n  let cStart = dd.indexOf(1, j);\\n  while (cStart !== dd.length) {\\n    if (dd[aStart] === dd[bStart] && dd[bStart] === dd[cStart]) {\\n      aStart++;\\n      bStart++;\\n      cStart++;\\n    } else return [-1, -1];\\n  }\\n  return [i, j];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575243,
                "title": "golang-c-solution",
                "content": "```go\\nfunc threeEqualParts(arr []int) []int {\\n\\t// remove all leading zeros if 1 exist\\n\\tremovedLeadingZero := 0\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tif arr[i] == 1 {\\n\\t\\t\\tremovedLeadingZero = i\\n\\t\\t\\tarr = arr[i:]\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\t// valid check\\n\\tif len(arr) < 3 {\\n\\t\\treturn []int{-1, -1}\\n\\t}\\n\\t// arr[0] equal to 0 means all value in arr is 0\\n\\tif arr[0] == 0 {\\n\\t\\treturn []int{0, 2}\\n\\t}\\n\\t// first non zero index from current to last index\\n\\tfirstNonZero := make([]int, len(arr))\\n\\tnonZeroIndex := math.MaxInt32\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\tif arr[i] == 1 {\\n\\t\\t\\tnonZeroIndex = i\\n\\t\\t}\\n\\t\\tfirstNonZero[i] = nonZeroIndex\\n\\t}\\nloop:\\n\\tfor end1 := 0; end1 < len(arr)-2; end1++ {\\n\\t\\tsize := end1 + 1\\n\\t\\tend2 := firstNonZero[end1+1] + end1\\n\\t\\tif end2 >= len(arr)-1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tend3 := firstNonZero[end2+1] + end1\\n\\t\\tif end3 != len(arr)-1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\tif arr[end1-i] != arr[end2-i] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t\\tif arr[end1-i] != arr[end3-i] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn []int{end1 + removedLeadingZero, end2 + 1 + removedLeadingZero}\\n\\t}\\n\\treturn []int{-1, -1}\\n}\\n```\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sizeOfOne = 0;\\n        for (auto &i : arr) {\\n            if (i == 1) {\\n                sizeOfOne++;\\n            }\\n        }\\n        if (sizeOfOne % 3 != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        if (sizeOfOne == 0) {\\n            return vector<int>{0, 2};\\n        }\\n        int currentSizeOfOne = 0;\\n        int end1 = 0;\\n        int end2 = 0;\\n        int end3 = 0;\\n        int prefixZero = -1;\\n        for (std::vector<int>::size_type i = 0; i < arr.size(); i++) {\\n            if (arr[i] == 1) {\\n                currentSizeOfOne++;\\n                if (prefixZero == -1) {\\n                    prefixZero = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne/3) {\\n                    end1 = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne/3*2) {\\n                    end2 = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne) {\\n                    end3 = i;\\n                }\\n            }\\n        }\\n        int suffixZero = static_cast<int>(arr.size() - 1) - end3;\\n        end1 += suffixZero;\\n        end2 += suffixZero;\\n        end3 += suffixZero;\\n        for (auto i = 0; i <= end1-prefixZero; i++) {\\n            if (arr[end1-i] != arr[end2-i] || arr[end1-i] != arr[end3-i]) {\\n                return vector<int>{-1, -1};\\n            }\\n        }\\n        return vector<int>{end1, end2+1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Go"
                ],
                "code": "```go\\nfunc threeEqualParts(arr []int) []int {\\n\\t// remove all leading zeros if 1 exist\\n\\tremovedLeadingZero := 0\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tif arr[i] == 1 {\\n\\t\\t\\tremovedLeadingZero = i\\n\\t\\t\\tarr = arr[i:]\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\t// valid check\\n\\tif len(arr) < 3 {\\n\\t\\treturn []int{-1, -1}\\n\\t}\\n\\t// arr[0] equal to 0 means all value in arr is 0\\n\\tif arr[0] == 0 {\\n\\t\\treturn []int{0, 2}\\n\\t}\\n\\t// first non zero index from current to last index\\n\\tfirstNonZero := make([]int, len(arr))\\n\\tnonZeroIndex := math.MaxInt32\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\tif arr[i] == 1 {\\n\\t\\t\\tnonZeroIndex = i\\n\\t\\t}\\n\\t\\tfirstNonZero[i] = nonZeroIndex\\n\\t}\\nloop:\\n\\tfor end1 := 0; end1 < len(arr)-2; end1++ {\\n\\t\\tsize := end1 + 1\\n\\t\\tend2 := firstNonZero[end1+1] + end1\\n\\t\\tif end2 >= len(arr)-1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tend3 := firstNonZero[end2+1] + end1\\n\\t\\tif end3 != len(arr)-1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\tif arr[end1-i] != arr[end2-i] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t\\tif arr[end1-i] != arr[end3-i] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn []int{end1 + removedLeadingZero, end2 + 1 + removedLeadingZero}\\n\\t}\\n\\treturn []int{-1, -1}\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sizeOfOne = 0;\\n        for (auto &i : arr) {\\n            if (i == 1) {\\n                sizeOfOne++;\\n            }\\n        }\\n        if (sizeOfOne % 3 != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        if (sizeOfOne == 0) {\\n            return vector<int>{0, 2};\\n        }\\n        int currentSizeOfOne = 0;\\n        int end1 = 0;\\n        int end2 = 0;\\n        int end3 = 0;\\n        int prefixZero = -1;\\n        for (std::vector<int>::size_type i = 0; i < arr.size(); i++) {\\n            if (arr[i] == 1) {\\n                currentSizeOfOne++;\\n                if (prefixZero == -1) {\\n                    prefixZero = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne/3) {\\n                    end1 = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne/3*2) {\\n                    end2 = i;\\n                }\\n                if (currentSizeOfOne == sizeOfOne) {\\n                    end3 = i;\\n                }\\n            }\\n        }\\n        int suffixZero = static_cast<int>(arr.size() - 1) - end3;\\n        end1 += suffixZero;\\n        end2 += suffixZero;\\n        end3 += suffixZero;\\n        for (auto i = 0; i <= end1-prefixZero; i++) {\\n            if (arr[end1-i] != arr[end2-i] || arr[end1-i] != arr[end3-i]) {\\n                return vector<int>{-1, -1};\\n            }\\n        }\\n        return vector<int>{end1, end2+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437060,
                "title": "c-easy",
                "content": "```\\n\\n```public:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n         int i,first,second,third,count=0,one=0;\\n        for(i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                count++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return {0,2};\\n        }\\n        if(count%3!=0)\\n        {\\n            return {-1,-1};\\n        }\\n       int  n=count/3;\\n        for(i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                one++;\\n                if(one==1)\\n                {\\n                    first=i;\\n                }\\n                else if(one==n+1)\\n                {\\n                    second=i;\\n                }\\n                else if(one==(2*n)+1)\\n                {\\n                    third=i;\\n                }\\n            }\\n        }\\n        while(third<arr.size())\\n        {\\n            if(arr[first]==arr[second]&&arr[second]==arr[third])\\n            {\\n                first++;\\n                second++;\\n                third++;\\n            }\\n            else\\n            {\\n                return {-1,-1};\\n            }\\n        }\\n        return {first-1,second};\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348123,
                "title": "java-easy-o-n-1ms-with-comments",
                "content": "refactored  version :\\n```\\n    public int[] threeEqualParts(int[] arr) {\\n        int len=arr.length, onesCount=0;\\n        int[] fail = new int[]{-1,-1};  //error case return\\n      \\n        //every part of tree may have a variable number of zeros due to leading zeros, while\\n        //number of ones should be the same in all parts;\\n        //let\\'s count overall number of ones\\n        for(int a : arr)  \\n            onesCount+=a;\\n        \\n        //if overall number of ones can\\'t be divided equally between all three parts, then we return error\\n        if(onesCount%3!=0 )\\n            return fail;\\n        \\n        //in case of absence of ones, let\\'s return any possible combination\\n        if(onesCount==0)\\n            return new int[]{0,2};\\n\\n        int i,j,k,m,l;\\n        int partOnesCount =onesCount/3; //number of ones in a single part\\n        \\n        //let\\'s count trailing zeros in the latest part\\n        for(k=len-1;arr[k]!=1;k--);\\n        int trailingZeroesCount = len-1-k;\\n        \\n        //find beginning of the first part\\n        l = findBeg(0, partOnesCount, trailingZeroesCount, arr);\\n        if(l==-1)\\n            return fail;\\n\\n        //find beginning of the second part\\n        m = findBeg(l, partOnesCount, trailingZeroesCount, arr);\\n        if(m==-1)\\n            return fail;      \\n        \\n        for(i=--l,j=--m,k=len-1;i>=0 && j>l && k > m; i--,j--,k--)\\n            if(arr[i]!=arr[j] || arr[j]!=arr[k]) //check item by item in all tree parts, that exact sequence should be the same in all tree parts\\n                return fail;    \\n\\n        return new int[]{l,m+1};\\n    }\\n    \\n    private int findBeg(int i, int partOnesCount, int trailingZeroesCount, int[] arr){\\n        //shift i to the right by counting ones\\n        for(;partOnesCount!=0;i++)\\n            partOnesCount-=arr[i];\\n        \\n        //shift i to the right by counting trailing zeros\\n        for(;trailingZeroesCount>0;i++, trailingZeroesCount--)\\n            if(arr[i]!=0) //if we face non-zero value in trailing zeros area, the return error\\n                return -1;   \\n        \\n        return i; //return potential beginning of the binary representation\\n    }\\n```\\n\\noriginal version : \\n```\\n    public int[] threeEqualParts(int[] arr) {\\n        int len=arr.length, onesCount=0;\\n        int[] fail = new int[]{-1,-1};  //error case return\\n      \\n        //every part of tree may have a variable number of zeros due to leading zeros, while\\n        //number of ones should be the same in all parts;\\n        //let\\'s count overall number of ones\\n        for(int a : arr)  \\n            onesCount+=a;\\n        \\n        //if overall number of ones can\\'t be divided equally between all three parts, then we return error\\n        if(onesCount%3!=0 )\\n            return fail;\\n        \\n        //in case of absence of ones, let\\'s return any possible combination\\n        if(onesCount==0)\\n            return new int[]{0,2};\\n\\n        int i,j,k;\\n        int partOnesCount =onesCount/3; //number of ones in a single part\\n        \\n        //let\\'s count trailing zeros in the latest part\\n        for(k=len-1;arr[k]!=1;k--);\\n        int trailingZeroesCount = len-1-k;\\n        \\n        //shift i to the right by counting ones\\n        int leftOnesCount = partOnesCount;\\n        for(i=0;leftOnesCount!=0;i++)\\n            leftOnesCount-=arr[i];\\n        \\n        //shift i to the right by counting trailing zeros\\n        int leftTrailingZeros = trailingZeroesCount;\\n        for(;leftTrailingZeros>0;i++, leftTrailingZeros--)\\n            if(arr[i]!=0) //if we face non-zero value in trailing zeros area, the return error\\n                return fail;\\n        \\n        int l = i-1, m=i;\\n        //do the same with the middle part\\n        int middleOnesCount = onesCount/3;\\n        for(;middleOnesCount!=0;m++)\\n            middleOnesCount-=arr[m];\\n        \\n        int middleTrailingZeros = trailingZeroesCount;\\n        for(;middleTrailingZeros>0;m++, middleTrailingZeros--)\\n            if(arr[m]!=0)\\n                return fail;        \\n        \\n        m--; i = l; j = m; k = len-1;\\n        while(i>=0 && j>l && k > m){\\n            if(arr[i]!=arr[j] || arr[j]!=arr[k]) //check item by item, that exact sequence is the same in all tree parts\\n                return fail;    \\n            \\n            i--; j--; k--;\\n        }\\n        return new int[]{l,m+1};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] threeEqualParts(int[] arr) {\\n        int len=arr.length, onesCount=0;\\n        int[] fail = new int[]{-1,-1};  //error case return\\n      \\n        //every part of tree may have a variable number of zeros due to leading zeros, while\\n        //number of ones should be the same in all parts;\\n        //let\\'s count overall number of ones\\n        for(int a : arr)  \\n            onesCount+=a;\\n        \\n        //if overall number of ones can\\'t be divided equally between all three parts, then we return error\\n        if(onesCount%3!=0 )\\n            return fail;\\n        \\n        //in case of absence of ones, let\\'s return any possible combination\\n        if(onesCount==0)\\n            return new int[]{0,2};\\n\\n        int i,j,k,m,l;\\n        int partOnesCount =onesCount/3; //number of ones in a single part\\n        \\n        //let\\'s count trailing zeros in the latest part\\n        for(k=len-1;arr[k]!=1;k--);\\n        int trailingZeroesCount = len-1-k;\\n        \\n        //find beginning of the first part\\n        l = findBeg(0, partOnesCount, trailingZeroesCount, arr);\\n        if(l==-1)\\n            return fail;\\n\\n        //find beginning of the second part\\n        m = findBeg(l, partOnesCount, trailingZeroesCount, arr);\\n        if(m==-1)\\n            return fail;      \\n        \\n        for(i=--l,j=--m,k=len-1;i>=0 && j>l && k > m; i--,j--,k--)\\n            if(arr[i]!=arr[j] || arr[j]!=arr[k]) //check item by item in all tree parts, that exact sequence should be the same in all tree parts\\n                return fail;    \\n\\n        return new int[]{l,m+1};\\n    }\\n    \\n    private int findBeg(int i, int partOnesCount, int trailingZeroesCount, int[] arr){\\n        //shift i to the right by counting ones\\n        for(;partOnesCount!=0;i++)\\n            partOnesCount-=arr[i];\\n        \\n        //shift i to the right by counting trailing zeros\\n        for(;trailingZeroesCount>0;i++, trailingZeroesCount--)\\n            if(arr[i]!=0) //if we face non-zero value in trailing zeros area, the return error\\n                return -1;   \\n        \\n        return i; //return potential beginning of the binary representation\\n    }\\n```\n```\\n    public int[] threeEqualParts(int[] arr) {\\n        int len=arr.length, onesCount=0;\\n        int[] fail = new int[]{-1,-1};  //error case return\\n      \\n        //every part of tree may have a variable number of zeros due to leading zeros, while\\n        //number of ones should be the same in all parts;\\n        //let\\'s count overall number of ones\\n        for(int a : arr)  \\n            onesCount+=a;\\n        \\n        //if overall number of ones can\\'t be divided equally between all three parts, then we return error\\n        if(onesCount%3!=0 )\\n            return fail;\\n        \\n        //in case of absence of ones, let\\'s return any possible combination\\n        if(onesCount==0)\\n            return new int[]{0,2};\\n\\n        int i,j,k;\\n        int partOnesCount =onesCount/3; //number of ones in a single part\\n        \\n        //let\\'s count trailing zeros in the latest part\\n        for(k=len-1;arr[k]!=1;k--);\\n        int trailingZeroesCount = len-1-k;\\n        \\n        //shift i to the right by counting ones\\n        int leftOnesCount = partOnesCount;\\n        for(i=0;leftOnesCount!=0;i++)\\n            leftOnesCount-=arr[i];\\n        \\n        //shift i to the right by counting trailing zeros\\n        int leftTrailingZeros = trailingZeroesCount;\\n        for(;leftTrailingZeros>0;i++, leftTrailingZeros--)\\n            if(arr[i]!=0) //if we face non-zero value in trailing zeros area, the return error\\n                return fail;\\n        \\n        int l = i-1, m=i;\\n        //do the same with the middle part\\n        int middleOnesCount = onesCount/3;\\n        for(;middleOnesCount!=0;m++)\\n            middleOnesCount-=arr[m];\\n        \\n        int middleTrailingZeros = trailingZeroesCount;\\n        for(;middleTrailingZeros>0;m++, middleTrailingZeros--)\\n            if(arr[m]!=0)\\n                return fail;        \\n        \\n        m--; i = l; j = m; k = len-1;\\n        while(i>=0 && j>l && k > m){\\n            if(arr[i]!=arr[j] || arr[j]!=arr[k]) //check item by item, that exact sequence is the same in all tree parts\\n                return fail;    \\n            \\n            i--; j--; k--;\\n        }\\n        return new int[]{l,m+1};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344451,
                "title": "simple-o-n-logical-approach-explained-with-example",
                "content": "### Approach \\n*  The array has to contain number of 1\\'s that are multiple of 3\\n*  Each of the three parts has to contain equal number of ones\\n*  Now it\\'s all about locating the beginning of 1s, and comparing the parts\\n\\n### Example\\n```\\n    000010101010000101010100001010101      << example\\n    [0]*1[1,0]*[0]*1[1,0]*[0]*1[1,0]*      << pattern\\n        ^          ^          ^            << beginning of first 1 in each part\\n        <--n-->    <--n-->    <--n-->      << n = length of the last part \\n        left       middle     right        << left, middle, right parts whose value is to be compared\\n               ^          ^                << beginning of each part, having leading 0s\\n              i           j                << answer = end of first part, beginning of last part\\n```\\n\\n### Python3 Implementation\\n* `O(n)` time\\n\\t* one pass for counting 1\\'s\\n\\t* one pass for locating the first 1 of each part\\n\\t* one pass for comparing left, middle and right parts\\n* `O(1)` space \\n\\t* ignores space taken by string splicing\\n\\t* we can always do that in `O(1)` time with a little bit of extra lines of code\\n\\n```\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        ones = sum(arr)         # total count of 1\\'s\\n        \\n        # early termination conditions\\n        if ones % 3 != 0: return [-1, -1]\\n        if ones == 0:     return [0, len(arr)-1]\\n        \\n        cnt = 0                  # running count of 1\\'s\\n        target1 = 1              # first 1 of left part\\n        target2 = 1 + ones//3    # first 1 of middle part\\n        target3 = 1 + 2*ones//3  # first 1 of right part\\n        \\n        for idx, bit in enumerate(arr):\\n            if bit == 1:\\n                cnt += 1\\n                if cnt == target1: start1 = idx\\n                if cnt == target2: start2 = idx\\n                if cnt == target3: start3 = idx\\n\\n        n = len(arr) - start3\\n        if arr[start1 : start1+n] == arr[start2 : start2+n] == arr[start3 : start3+n]:\\n            return [start1 + n - 1, start2 + n]  \\n        \\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    000010101010000101010100001010101      << example\\n    [0]*1[1,0]*[0]*1[1,0]*[0]*1[1,0]*      << pattern\\n        ^          ^          ^            << beginning of first 1 in each part\\n        <--n-->    <--n-->    <--n-->      << n = length of the last part \\n        left       middle     right        << left, middle, right parts whose value is to be compared\\n               ^          ^                << beginning of each part, having leading 0s\\n              i           j                << answer = end of first part, beginning of last part\\n```\n```\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        ones = sum(arr)         # total count of 1\\'s\\n        \\n        # early termination conditions\\n        if ones % 3 != 0: return [-1, -1]\\n        if ones == 0:     return [0, len(arr)-1]\\n        \\n        cnt = 0                  # running count of 1\\'s\\n        target1 = 1              # first 1 of left part\\n        target2 = 1 + ones//3    # first 1 of middle part\\n        target3 = 1 + 2*ones//3  # first 1 of right part\\n        \\n        for idx, bit in enumerate(arr):\\n            if bit == 1:\\n                cnt += 1\\n                if cnt == target1: start1 = idx\\n                if cnt == target2: start2 = idx\\n                if cnt == target3: start3 = idx\\n\\n        n = len(arr) - start3\\n        if arr[start1 : start1+n] == arr[start2 : start2+n] == arr[start3 : start3+n]:\\n            return [start1 + n - 1, start2 + n]  \\n        \\n        return [-1, -1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344385,
                "title": "three-equal-parts-java-solution",
                "content": "```\\n public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length ;\\n        List<Integer> ones=new ArrayList() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(arr[i]>0)\\n            {\\n                ones.add(i) ;\\n            }\\n        }\\n        int cnt = ones.size() ;\\n        if(cnt == 0)\\n        {\\n            return new int[]{0 , n - 1} ;\\n        }\\n        if(cnt%3!=0)         \\n        {\\n            return new int[]{-1 , -1} ;\\n        }\\n        int f = ones.get(0);\\n        int s = ones.get(cnt/3);\\n        int t = ones.get((cnt/3)*2) ;\\n        while(t < n && arr[f] == arr[s] && arr[f] == arr[t])\\n        {\\n            f++ ;\\n            s++ ;\\n            t++ ;\\n        }\\n        if(t == n)\\n        {\\n            return new int[]{f - 1 , s} ;\\n        }\\n        return new int[]{-1 , -1} ;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length ;\\n        List<Integer> ones=new ArrayList() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(arr[i]>0)\\n            {\\n                ones.add(i) ;\\n            }\\n        }\\n        int cnt = ones.size() ;\\n        if(cnt == 0)\\n        {\\n            return new int[]{0 , n - 1} ;\\n        }\\n        if(cnt%3!=0)         \\n        {\\n            return new int[]{-1 , -1} ;\\n        }\\n        int f = ones.get(0);\\n        int s = ones.get(cnt/3);\\n        int t = ones.get((cnt/3)*2) ;\\n        while(t < n && arr[f] == arr[s] && arr[f] == arr[t])\\n        {\\n            f++ ;\\n            s++ ;\\n            t++ ;\\n        }\\n        if(t == n)\\n        {\\n            return new int[]{f - 1 , s} ;\\n        }\\n        return new int[]{-1 , -1} ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1344263,
                "title": "c-clean-commented-for-easy-understanding",
                "content": "```\\n/*\\n\\tSuch approaches don\\'t come to our minds in one go. I had taken help for this solution. Tried to put\\n\\tcomments so that others can understand well.\\n\\tPersonally, Leetcode\\'s solution to this Qn and explanation are not written well. It seems like\\n\\ta mess and unreadable. I have tried to explain it with comments\\n*/\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n = arr.size();\\n        int sum = accumulate(begin(arr), end(arr), 0);\\n        \\n        if(sum == 0)\\n            return {0, n-1};\\n        else if(sum%3 != 0)\\n            return {-1, -1};\\n        \\n        int k = sum/3;\\n        //So every partition must have k 1\\'s\\n        //So let\\'s find three partitions having k 1\\'s and compare them bit by bit\\n        \\n        int start = -1, mid = -1, end = -1;\\n        int count = 0;\\n\\n        //[1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1,  1,  1,  1,  1,  1]\\n        for(int i = 0; i<n; i++) {\\n            if(arr[i] == 0) continue;\\n            \\n            count += arr[i];\\n            if(count > k) {\\n                count = 1;\\n            }\\n            \\n            if(count == 1) {\\n                if(start == -1) start = i;\\n                else if(mid == -1) mid = i;\\n                else if(end == -1) end = i;\\n                else break;\\n            }\\n        }\\n        \\n        /*\\n            we have found three sections and we have pointers to starting \\'1\\' of\\n            each section.\\n            we now compare them bit by bit\\n        */\\n        \\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]) {\\n            start++;  mid++;   end++;\\n        }\\n        \\n        //It means we couldn\\'t match all sections\\n        if(end != n)  return {-1, -1};\\n        \\n        return {start-1, mid};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tSuch approaches don\\'t come to our minds in one go. I had taken help for this solution. Tried to put\\n\\tcomments so that others can understand well.\\n\\tPersonally, Leetcode\\'s solution to this Qn and explanation are not written well. It seems like\\n\\ta mess and unreadable. I have tried to explain it with comments\\n*/\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n = arr.size();\\n        int sum = accumulate(begin(arr), end(arr), 0);\\n        \\n        if(sum == 0)\\n            return {0, n-1};\\n        else if(sum%3 != 0)\\n            return {-1, -1};\\n        \\n        int k = sum/3;\\n        //So every partition must have k 1\\'s\\n        //So let\\'s find three partitions having k 1\\'s and compare them bit by bit\\n        \\n        int start = -1, mid = -1, end = -1;\\n        int count = 0;\\n\\n        //[1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1,  1,  1,  1,  1,  1]\\n        for(int i = 0; i<n; i++) {\\n            if(arr[i] == 0) continue;\\n            \\n            count += arr[i];\\n            if(count > k) {\\n                count = 1;\\n            }\\n            \\n            if(count == 1) {\\n                if(start == -1) start = i;\\n                else if(mid == -1) mid = i;\\n                else if(end == -1) end = i;\\n                else break;\\n            }\\n        }\\n        \\n        /*\\n            we have found three sections and we have pointers to starting \\'1\\' of\\n            each section.\\n            we now compare them bit by bit\\n        */\\n        \\n        while(end < n && arr[start] == arr[mid] && arr[mid] == arr[end]) {\\n            start++;  mid++;   end++;\\n        }\\n        \\n        //It means we couldn\\'t match all sections\\n        if(end != n)  return {-1, -1};\\n        \\n        return {start-1, mid};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344099,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> ans={-1,-1};\\n        int numOf1s = 0;\\n        for(int x:arr){\\n            numOf1s += x;\\n        }\\n        if(numOf1s == 0){\\n            return {0,2};\\n        }\\n        if(numOf1s % 3 != 0){\\n            return ans;\\n        }   \\n        int noOfOnesInEachPart = numOf1s / 3;\\n        int indexOfFirst1InPart0 = -1;\\n        int indexOfFirst1InPart1 = -1;\\n        int indexOfFirst1InPart2 = -1;\\n        numOf1s = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 1){\\n                numOf1s++;\\n                if(numOf1s == noOfOnesInEachPart + 1){\\n                    indexOfFirst1InPart1 = i;\\n                }else if(numOf1s == 2 * noOfOnesInEachPart + 1){\\n                    indexOfFirst1InPart2 = i;\\n                }else if(numOf1s == 1){\\n                    indexOfFirst1InPart0 = i;\\n                }\\n            }\\n        }\\n        while(indexOfFirst1InPart2 < arr.size()){\\n            if(arr[indexOfFirst1InPart0] == arr[indexOfFirst1InPart1] && arr[indexOfFirst1InPart1]==arr[indexOfFirst1InPart2]){\\n                indexOfFirst1InPart0++;\\n                indexOfFirst1InPart1++;\\n                indexOfFirst1InPart2++;\\n            }else{\\n                return ans;\\n            }\\n        }\\n        return {indexOfFirst1InPart0-1, indexOfFirst1InPart1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> ans={-1,-1};\\n        int numOf1s = 0;\\n        for(int x:arr){\\n            numOf1s += x;\\n        }\\n        if(numOf1s == 0){\\n            return {0,2};\\n        }\\n        if(numOf1s % 3 != 0){\\n            return ans;\\n        }   \\n        int noOfOnesInEachPart = numOf1s / 3;\\n        int indexOfFirst1InPart0 = -1;\\n        int indexOfFirst1InPart1 = -1;\\n        int indexOfFirst1InPart2 = -1;\\n        numOf1s = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 1){\\n                numOf1s++;\\n                if(numOf1s == noOfOnesInEachPart + 1){\\n                    indexOfFirst1InPart1 = i;\\n                }else if(numOf1s == 2 * noOfOnesInEachPart + 1){\\n                    indexOfFirst1InPart2 = i;\\n                }else if(numOf1s == 1){\\n                    indexOfFirst1InPart0 = i;\\n                }\\n            }\\n        }\\n        while(indexOfFirst1InPart2 < arr.size()){\\n            if(arr[indexOfFirst1InPart0] == arr[indexOfFirst1InPart1] && arr[indexOfFirst1InPart1]==arr[indexOfFirst1InPart2]){\\n                indexOfFirst1InPart0++;\\n                indexOfFirst1InPart1++;\\n                indexOfFirst1InPart2++;\\n            }else{\\n                return ans;\\n            }\\n        }\\n        return {indexOfFirst1InPart0-1, indexOfFirst1InPart1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344092,
                "title": "easy-c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        vector<int> res(2);\\n        res[0] = -1;\\n        res[1] = -1;\\n        \\n        int totalCountOne = 0;\\n        for(auto X: arr)\\n        {\\n            totalCountOne += X;\\n        }\\n        if(totalCountOne == 0)\\n        {\\n            res[0] = 0;\\n            res[1] = 2;\\n            return res;\\n        }   \\n        if((totalCountOne)%3 != 0)\\n        {\\n            return res;\\n        }\\n        \\n        int noOfOneInEachPart = totalCountOne/3;\\n        int idxOfFirstOneInPart0 = -1;\\n        int idxOfFirstOneInPart1 = -1;\\n        int idxOfFirstOneInPart2 = -1;\\n        int NoOfOnes = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                NoOfOnes++;\\n                if(NoOfOnes == 1)\\n                {\\n                    idxOfFirstOneInPart0 = i;\\n                }\\n                else if(NoOfOnes == noOfOneInEachPart + 1)\\n                {\\n                    idxOfFirstOneInPart1 = i;\\n                }\\n                else if(NoOfOnes == 2*noOfOneInEachPart + 1)\\n                {\\n                    idxOfFirstOneInPart2 = i;\\n                }\\n            }\\n        }\\n        while(idxOfFirstOneInPart2<n)\\n        {\\n            if(arr[idxOfFirstOneInPart2] == arr[idxOfFirstOneInPart1] && arr[idxOfFirstOneInPart2] == arr[idxOfFirstOneInPart0])\\n            {\\n                idxOfFirstOneInPart0++;\\n                idxOfFirstOneInPart2++;\\n                idxOfFirstOneInPart1++;\\n            }\\n            else\\n            {\\n                return res;\\n            }\\n            \\n        }\\n        res[0] = idxOfFirstOneInPart0-1;\\n        res[1] = idxOfFirstOneInPart1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        vector<int> res(2);\\n        res[0] = -1;\\n        res[1] = -1;\\n        \\n        int totalCountOne = 0;\\n        for(auto X: arr)\\n        {\\n            totalCountOne += X;\\n        }\\n        if(totalCountOne == 0)\\n        {\\n            res[0] = 0;\\n            res[1] = 2;\\n            return res;\\n        }   \\n        if((totalCountOne)%3 != 0)\\n        {\\n            return res;\\n        }\\n        \\n        int noOfOneInEachPart = totalCountOne/3;\\n        int idxOfFirstOneInPart0 = -1;\\n        int idxOfFirstOneInPart1 = -1;\\n        int idxOfFirstOneInPart2 = -1;\\n        int NoOfOnes = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                NoOfOnes++;\\n                if(NoOfOnes == 1)\\n                {\\n                    idxOfFirstOneInPart0 = i;\\n                }\\n                else if(NoOfOnes == noOfOneInEachPart + 1)\\n                {\\n                    idxOfFirstOneInPart1 = i;\\n                }\\n                else if(NoOfOnes == 2*noOfOneInEachPart + 1)\\n                {\\n                    idxOfFirstOneInPart2 = i;\\n                }\\n            }\\n        }\\n        while(idxOfFirstOneInPart2<n)\\n        {\\n            if(arr[idxOfFirstOneInPart2] == arr[idxOfFirstOneInPart1] && arr[idxOfFirstOneInPart2] == arr[idxOfFirstOneInPart0])\\n            {\\n                idxOfFirstOneInPart0++;\\n                idxOfFirstOneInPart2++;\\n                idxOfFirstOneInPart1++;\\n            }\\n            else\\n            {\\n                return res;\\n            }\\n            \\n        }\\n        res[0] = idxOfFirstOneInPart0-1;\\n        res[1] = idxOfFirstOneInPart1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344011,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int count = 0;\\n        for (auto i:arr)\\n        {\\n            if(i == 1)\\n                count++;\\n        }\\n        if(count == 0)\\n            return {0,2};\\n        if(count%3 != 0)\\n            return {-1,-1};\\n        int p1 = 0;\\n        int p2 = 0;\\n        int p3 = 0;\\n        count = count/3;\\n        int temp = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {  if(arr[i] == 1)\\n          { if(temp == 0)\\n              p1 = i;\\n            else if(temp == count)\\n                p2 = i;\\n             else if(temp == 2*count)\\n                p3 = i;\\n           temp++;\\n          }\\n        }\\n        int oldp2 = p2;\\n        int oldp3 = p3;\\n        while(p1<oldp2 and p2<oldp3 and p3<arr.size())\\n        {\\n            if(arr[p1] != arr[p2] or arr[p2] != arr[p3])\\n                return {-1,-1};\\n            p1++;\\n            p2++;\\n            p3++;\\n        }\\n        if(p3 == arr.size())\\n        {\\n            return {p1-1,p2};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> threeEqualParts(vector<int>& arr) \\n    {\\n        int count = 0;\\n        for (auto i:arr)\\n        {\\n            if(i == 1)\\n                count++;\\n        }\\n        if(count == 0)\\n            return {0,2};\\n        if(count%3 != 0)\\n            return {-1,-1};\\n        int p1 = 0;\\n        int p2 = 0;\\n        int p3 = 0;\\n        count = count/3;\\n        int temp = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {  if(arr[i] == 1)\\n          { if(temp == 0)\\n              p1 = i;\\n            else if(temp == count)\\n                p2 = i;\\n             else if(temp == 2*count)\\n                p3 = i;\\n           temp++;\\n          }\\n        }\\n        int oldp2 = p2;\\n        int oldp3 = p3;\\n        while(p1<oldp2 and p2<oldp3 and p3<arr.size())\\n        {\\n            if(arr[p1] != arr[p2] or arr[p2] != arr[p3])\\n                return {-1,-1};\\n            p1++;\\n            p2++;\\n            p3++;\\n        }\\n        if(p3 == arr.size())\\n        {\\n            return {p1-1,p2};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343923,
                "title": "linear-times-o-n-solution-in-python-clean",
                "content": "```\\n# Github: Shantanugupta1118\\n# DAY 60 of DAY 100\\n# 927. Three Equal Parts  -  Leetcode/July\\n# https://leetcode.com/problems/three-equal-parts/\\n\\n\\nclass Solution:\\n    def threeEqualParts(self, arr):\\n        ans = [-1,-1]\\n        numsOf1s = 0\\n        for i in arr:\\n            numsOf1s += i\\n        if numsOf1s == 0:\\n            return [0,2]\\n        if numsOf1s%3 != 0:\\n            return ans\\n        \\n        eachPart = numsOf1s//3\\n        index0, index1, index2 = -1, -1, -1\\n        numsOf1s = 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                numsOf1s += 1\\n                if numsOf1s == eachPart+1:\\n                    index1 = i\\n                elif numsOf1s == 2*eachPart+1:\\n                    index2 = i\\n                elif numsOf1s == 1:\\n                    index0 = i\\n        while index2 < len(arr):\\n            if arr[index2] == arr[index0] and arr[index2] == arr[index1]:\\n                index0 += 1\\n                index1 += 1\\n                index2 += 1\\n            else:\\n                return ans \\n        return [index0-1, index1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Github: Shantanugupta1118\\n# DAY 60 of DAY 100\\n# 927. Three Equal Parts  -  Leetcode/July\\n# https://leetcode.com/problems/three-equal-parts/\\n\\n\\nclass Solution:\\n    def threeEqualParts(self, arr):\\n        ans = [-1,-1]\\n        numsOf1s = 0\\n        for i in arr:\\n            numsOf1s += i\\n        if numsOf1s == 0:\\n            return [0,2]\\n        if numsOf1s%3 != 0:\\n            return ans\\n        \\n        eachPart = numsOf1s//3\\n        index0, index1, index2 = -1, -1, -1\\n        numsOf1s = 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                numsOf1s += 1\\n                if numsOf1s == eachPart+1:\\n                    index1 = i\\n                elif numsOf1s == 2*eachPart+1:\\n                    index2 = i\\n                elif numsOf1s == 1:\\n                    index0 = i\\n        while index2 < len(arr):\\n            if arr[index2] == arr[index0] and arr[index2] == arr[index1]:\\n                index0 += 1\\n                index1 += 1\\n                index2 += 1\\n            else:\\n                return ans \\n        return [index0-1, index1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343905,
                "title": "pretty-short-java-solution-15-lines-explained",
                "content": "The idea is to count the number of ones `numOnes`: \\n\\nIf `numOnes` isn\\'t divisible by 3, then you can\\'t divide them into 3 parts so return [-1, -1]. \\n\\nSecondly, if there are only zeroes in the array, you can divide the array arbitrarily.\\n\\nFinally, if `numOnes` is divisible by 3, we run three pointers `first, second and third` and check whether the division is possible.\\n\\n`first` points to the First One of the array, `second` points to the `numOnes/3`th One of the array, and `third` points to the `2*numOnes/3`th One of the array.\\nAdvance the three pointer, if there is a mismatch at any step, return [-1, -1].\\nIf the `third` pointer finally manages to reach the end, we have a valid division, because everything matched!\\n\\nWhat I said in code:\\n```java\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int numOnes = 0;\\n        List<Integer> pos = new ArrayList<>();\\n        for(int i = 0; i < arr.length; i++){\\n            numOnes += arr[i];\\n            if(arr[i] == 1) pos.add(i);\\n        }\\n        if(numOnes % 3 != 0) return new int[]{-1, -1};\\n        if(numOnes == 0) return new int[]{0, arr.length-1};\\n        int first = pos.get(0), second = pos.get(numOnes/3), third = pos.get(numOnes/3 *2);\\n        while(first < second && second < third && third < arr.length){\\n            if(arr[first] != arr[second] || arr[second] != arr[third]) return new int[]{-1, -1};\\n            first++; second++; third++;\\n        }\\n        return third == arr.length ? new int[]{first-1, second} : new int[]{-1, -1};\\n    }\\n}\\n```\\nOkay, not 15 lines, it\\'s 18. You can probably sue me for that ;)\\nBut I hope you understand how the solution works.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int numOnes = 0;\\n        List<Integer> pos = new ArrayList<>();\\n        for(int i = 0; i < arr.length; i++){\\n            numOnes += arr[i];\\n            if(arr[i] == 1) pos.add(i);\\n        }\\n        if(numOnes % 3 != 0) return new int[]{-1, -1};\\n        if(numOnes == 0) return new int[]{0, arr.length-1};\\n        int first = pos.get(0), second = pos.get(numOnes/3), third = pos.get(numOnes/3 *2);\\n        while(first < second && second < third && third < arr.length){\\n            if(arr[first] != arr[second] || arr[second] != arr[third]) return new int[]{-1, -1};\\n            first++; second++; third++;\\n        }\\n        return third == arr.length ? new int[]{first-1, second} : new int[]{-1, -1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343855,
                "title": "o-n-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> ans{-1,-1};\\n        int count=0,ones=0,p1=0,p2=0,p3=0;\\n        for(int i=0; i<arr.size();i++){\\n            count+=arr[i];\\n        }\\n        if(count%3) return ans;\\n        if(count==0){\\n            ans[0] = 0;\\n            ans[1] = arr.size()-1;\\n            return ans;\\n        }\\n        count/=3;\\n        for(int i=0; i<arr.size(); i++){\\n            if(arr[i]==1){\\n                if(ones==0) p1 = i;\\n                else if(ones==count) p2 = i;\\n                else if(ones==2*count) p3 = i;\\n                ones++;\\n            }\\n        }\\n        int op2=p2,op3=p3;\\n        while(p1<op2 && p2<op3 && p3<arr.size()){\\n            if(arr[p1]!= arr[p2] || arr[p2]!=arr[p3]) return ans;\\n            p1++; p2++; p3++;\\n        }\\n        if(p3!=arr.size()) return ans;\\n        \\n        ans[0] = p1-1;\\n        ans[1] = p2;\\n        return ans;\\n    }\\n};\\n```\\nInspired from :- https://leetcode.com/problems/three-equal-parts/discuss/1343568/C%2B%2B-O(n)-time-and-O(1)-space",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> ans{-1,-1};\\n        int count=0,ones=0,p1=0,p2=0,p3=0;\\n        for(int i=0; i<arr.size();i++){\\n            count+=arr[i];\\n        }\\n        if(count%3) return ans;\\n        if(count==0){\\n            ans[0] = 0;\\n            ans[1] = arr.size()-1;\\n            return ans;\\n        }\\n        count/=3;\\n        for(int i=0; i<arr.size(); i++){\\n            if(arr[i]==1){\\n                if(ones==0) p1 = i;\\n                else if(ones==count) p2 = i;\\n                else if(ones==2*count) p3 = i;\\n                ones++;\\n            }\\n        }\\n        int op2=p2,op3=p3;\\n        while(p1<op2 && p2<op3 && p3<arr.size()){\\n            if(arr[p1]!= arr[p2] || arr[p2]!=arr[p3]) return ans;\\n            p1++; p2++; p3++;\\n        }\\n        if(p3!=arr.size()) return ans;\\n        \\n        ans[0] = p1-1;\\n        ans[1] = p2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343847,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {\\n        let v = arr\\n            .iter()\\n            .enumerate()\\n            .filter_map(|(i, &a)| if a == 1 { Some(i) } else { None })\\n            .collect::<Vec<_>>();\\n        if arr.len() < 3 || v.len() % 3 != 0 {\\n            return [-1, -1].to_vec();\\n        }\\n        if v.is_empty() {\\n            return [0, 2].to_vec();\\n        }\\n        let chunks = v.chunks(v.len() / 3).collect::<Vec<_>>();\\n        let i = chunks[0][v.len() / 3 - 1] + arr.len() - v[v.len() - 1] - 1;\\n        let j = chunks[1][v.len() / 3 - 1] + arr.len() - v[v.len() - 1];\\n        if arr.len() - chunks[2][0] > j - i - 1 || arr.len() - chunks[2][0] > i + 1 {\\n            return [-1, -1].to_vec();\\n        }\\n        for k in 0..(i + 1).min(j - i - 1).min(arr.len() - j) {\\n            if arr[i - k] != arr[j - 1 - k] || arr[i - k] != arr[arr.len() - 1 - k] {\\n                return [-1, -1].to_vec();\\n            }\\n        }\\n        [i as i32, j as i32].to_vec()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {\\n        let v = arr\\n            .iter()\\n            .enumerate()\\n            .filter_map(|(i, &a)| if a == 1 { Some(i) } else { None })\\n            .collect::<Vec<_>>();\\n        if arr.len() < 3 || v.len() % 3 != 0 {\\n            return [-1, -1].to_vec();\\n        }\\n        if v.is_empty() {\\n            return [0, 2].to_vec();\\n        }\\n        let chunks = v.chunks(v.len() / 3).collect::<Vec<_>>();\\n        let i = chunks[0][v.len() / 3 - 1] + arr.len() - v[v.len() - 1] - 1;\\n        let j = chunks[1][v.len() / 3 - 1] + arr.len() - v[v.len() - 1];\\n        if arr.len() - chunks[2][0] > j - i - 1 || arr.len() - chunks[2][0] > i + 1 {\\n            return [-1, -1].to_vec();\\n        }\\n        for k in 0..(i + 1).min(j - i - 1).min(arr.len() - j) {\\n            if arr[i - k] != arr[j - 1 - k] || arr[i - k] != arr[arr.len() - 1 - k] {\\n                return [-1, -1].to_vec();\\n            }\\n        }\\n        [i as i32, j as i32].to_vec()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343435,
                "title": "three-equal-parts-python-logic-building",
                "content": "Key obseration is that three parts must have same number and pattern of 1s except the leading 0s part. \\nMy idea is to:\\n\\n1.  Count no. of ones, simply taking sum. (if sum%3!=0 return [-1,-1])\\n2.  Search from right side to left, until we found sum/3 of 1s. This index defines the pattern of 1s.\\n3.  From left, ignore leading 0s, and then match the pattern found in step 2, to get the first EndIndex.\\n4.  Similary, do another matching to found second EndIndex.\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n=len(arr)\\n        x=sum(arr)  #gives no. of 1s\\n        if x==0:\\n            return [0,2]\\n        elif x%3!=0:\\n            return [-1,-1]\\n        \\n        # finding index of starting 1 of third string\\n        idx3=0\\n        count=0\\n        for i in range(n-1,-1,-1):\\n            if arr[i]==1:\\n                count+=1\\n                if count==x//3:\\n                    idx3=i\\n                    break\\n        \\n        idx1=endIdx(arr,0,idx3)\\n        if idx1<0:\\n            return [-1,-1]\\n        \\n        idx2=endIdx(arr,idx1+1,idx3)\\n        if idx2<0:\\n            return [-1,-1]\\n        \\n        return [idx1,idx2+1]\\n    \\n#  here, idx3 is index of pattern to compare to.\\n#  return endIdx of start pattern that matches idx3 side.\\ndef endIdx(arr, start, idx3):\\n    while arr[start]==0:\\n        start+=1\\n    while idx3<len(arr):\\n        if arr[start]!=arr[idx3]:\\n            return -1\\n        start+=1\\n        idx3+=1\\n    return start-1\\n```\\n*If case of any doubt or suggestion, do comment.*\\n\\n***Happy Coding* :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n=len(arr)\\n        x=sum(arr)  #gives no. of 1s\\n        if x==0:\\n            return [0,2]\\n        elif x%3!=0:\\n            return [-1,-1]\\n        \\n        # finding index of starting 1 of third string\\n        idx3=0\\n        count=0\\n        for i in range(n-1,-1,-1):\\n            if arr[i]==1:\\n                count+=1\\n                if count==x//3:\\n                    idx3=i\\n                    break\\n        \\n        idx1=endIdx(arr,0,idx3)\\n        if idx1<0:\\n            return [-1,-1]\\n        \\n        idx2=endIdx(arr,idx1+1,idx3)\\n        if idx2<0:\\n            return [-1,-1]\\n        \\n        return [idx1,idx2+1]\\n    \\n#  here, idx3 is index of pattern to compare to.\\n#  return endIdx of start pattern that matches idx3 side.\\ndef endIdx(arr, start, idx3):\\n    while arr[start]==0:\\n        start+=1\\n    while idx3<len(arr):\\n        if arr[start]!=arr[idx3]:\\n            return -1\\n        start+=1\\n        idx3+=1\\n    return start-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343434,
                "title": "python-binarysearch-o-nlogn-slow-but-viable-solution",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        ps = []\\n        cur = 0\\n        for x in arr:\\n            cur <<= 1\\n            cur += x\\n            ps.append(cur)\\n        # print(ps[-1])\\n        for i in range(n-1):\\n            a = ps[i]\\n            l,r = i+1,n-1\\n            cnt = 0\\n            while l<r:\\n                cnt += 1\\n                mid = (l+r)//2\\n                b = ps[mid]-(ps[i] << (mid-i))\\n                if b<a:\\n                    l = mid + 1\\n                elif b>a:\\n                    r = mid\\n                else:\\n                    c = ps[n-1]-(ps[mid] << (n-1-mid))\\n                    if c==b:\\n                        return [i,mid+1]\\n                    else:\\n                        l = r\\n        return [-1,-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        ps = []\\n        cur = 0\\n        for x in arr:\\n            cur <<= 1\\n            cur += x\\n            ps.append(cur)\\n        # print(ps[-1])\\n        for i in range(n-1):\\n            a = ps[i]\\n            l,r = i+1,n-1\\n            cnt = 0\\n            while l<r:\\n                cnt += 1\\n                mid = (l+r)//2\\n                b = ps[mid]-(ps[i] << (mid-i))\\n                if b<a:\\n                    l = mid + 1\\n                elif b>a:\\n                    r = mid\\n                else:\\n                    c = ps[n-1]-(ps[mid] << (n-1-mid))\\n                    if c==b:\\n                        return [i,mid+1]\\n                    else:\\n                        l = r\\n        return [-1,-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343373,
                "title": "javascript-84ms",
                "content": "Approximately 1.33N operations => O(N).\\n\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar threeEqualParts = function (arr) {\\n  const gaps = []\\n  let head0s = 0\\n  let prev\\n  for (let p = 0; p < arr.length; p++) {\\n    if (arr[p] === 1) {\\n      if (prev !== undefined) {\\n        gaps.push(p - prev)\\n      }\\n      prev = p\\n    } else if (prev === undefined) {\\n      head0s++\\n    }\\n  }\\n  if (head0s === arr.length) {\\n    return [0, 2]\\n  }\\n  if (gaps.length % 3 !== 2) {\\n    return [-1, -1]\\n  }\\n  const groupLen = (gaps.length - 2) / 3\\n  let groupSum = 0\\n  for (let q = 0; q < groupLen; q++) {\\n    if (\\n      gaps[q] !== gaps[q + groupLen + 1] ||\\n      gaps[q] !== gaps[q + 2 * groupLen + 2]\\n    ) {\\n      return [-1, -1]\\n    }\\n    groupSum += gaps[q]\\n  }\\n  const tail0s = arr.length -\\n    head0s -\\n    groupSum * 3 -\\n    gaps[groupLen] -\\n    gaps[2 * groupLen + 1] -\\n    1\\n  if (gaps[groupLen] - 1 < tail0s || gaps[2 * groupLen + 1] - 1 < tail0s) {\\n    return [-1, -1]\\n  }\\n  const i = head0s + groupSum + tail0s\\n  const j = i + gaps[groupLen] + groupSum + 1\\n  return [i, j]\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar threeEqualParts = function (arr) {\\n  const gaps = []\\n  let head0s = 0\\n  let prev\\n  for (let p = 0; p < arr.length; p++) {\\n    if (arr[p] === 1) {\\n      if (prev !== undefined) {\\n        gaps.push(p - prev)\\n      }\\n      prev = p\\n    } else if (prev === undefined) {\\n      head0s++\\n    }\\n  }\\n  if (head0s === arr.length) {\\n    return [0, 2]\\n  }\\n  if (gaps.length % 3 !== 2) {\\n    return [-1, -1]\\n  }\\n  const groupLen = (gaps.length - 2) / 3\\n  let groupSum = 0\\n  for (let q = 0; q < groupLen; q++) {\\n    if (\\n      gaps[q] !== gaps[q + groupLen + 1] ||\\n      gaps[q] !== gaps[q + 2 * groupLen + 2]\\n    ) {\\n      return [-1, -1]\\n    }\\n    groupSum += gaps[q]\\n  }\\n  const tail0s = arr.length -\\n    head0s -\\n    groupSum * 3 -\\n    gaps[groupLen] -\\n    gaps[2 * groupLen + 1] -\\n    1\\n  if (gaps[groupLen] - 1 < tail0s || gaps[2 * groupLen + 1] - 1 < tail0s) {\\n    return [-1, -1]\\n  }\\n  const i = head0s + groupSum + tail0s\\n  const j = i + gaps[groupLen] + groupSum + 1\\n  return [i, j]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343246,
                "title": "swift-solution",
                "content": "1. Count ones in `arr`\\n2. If there is no ones in `arr`, then all parts are zeros\\n3. Ones count must be multiple of three, else it is not possible to split `arr` into three parts\\n4. Find first significant bit for each part in `arr`\\n5. The last part ends at the end of `arr`, it has a reference length. Check that the length of the first two parts is not less than the reference one.\\n6. Check the equality of the three parts\\n\\nTime complexity O(n), space complexity O(1)\\n\\nUpdate: simplified reduce, as [@Legonaftik](https://leetcode.com/Legonaftik/) suggested\\n```\\nclass Solution {\\n    func threeEqualParts(_ arr: [Int]) -> [Int] {\\n        let n = arr.count, ones = arr.reduce(0, +), partOnes = ones / 3\\n        guard ones > 0 else { return [0, 2] } // all parts are zeros\\n        guard ones % 3 == 0 else { return [-1, -1] } // it is not possible to split into three parts\\n\\n        var starts = [Int](repeating: -1, count: 3), runningOnes = 0\\n        for i in 0..<n where arr[i] == 1 {\\n            let part = runningOnes / partOnes // 0...2\\n            if starts[part] == -1 {\\n                starts[part] = i\\n            }\\n            runningOnes += 1\\n        }\\n\\n        let len = n - starts[2]\\n\\n        guard starts[1] - starts[0] >= len && starts[2] - starts[1] >= len else { return [-1, -1] }\\n\\n        // check if three parts are equal\\n        for l in 0..<len where arr[starts[0] + l] != arr[starts[1] + l] || arr[starts[0] + l] != arr[starts[2] + l] {\\n            return [-1, -1]\\n        }\\n        \\n        return [starts[0] + len - 1, starts[1] + len]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func threeEqualParts(_ arr: [Int]) -> [Int] {\\n        let n = arr.count, ones = arr.reduce(0, +), partOnes = ones / 3\\n        guard ones > 0 else { return [0, 2] } // all parts are zeros\\n        guard ones % 3 == 0 else { return [-1, -1] } // it is not possible to split into three parts\\n\\n        var starts = [Int](repeating: -1, count: 3), runningOnes = 0\\n        for i in 0..<n where arr[i] == 1 {\\n            let part = runningOnes / partOnes // 0...2\\n            if starts[part] == -1 {\\n                starts[part] = i\\n            }\\n            runningOnes += 1\\n        }\\n\\n        let len = n - starts[2]\\n\\n        guard starts[1] - starts[0] >= len && starts[2] - starts[1] >= len else { return [-1, -1] }\\n\\n        // check if three parts are equal\\n        for l in 0..<len where arr[starts[0] + l] != arr[starts[1] + l] || arr[starts[0] + l] != arr[starts[2] + l] {\\n            return [-1, -1]\\n        }\\n        \\n        return [starts[0] + len - 1, starts[1] + len]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343237,
                "title": "three-equal-parts-python-solution-o-n",
                "content": "```python\\n\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = []\\n        for i,num in enumerate(arr):\\n            if num == 1:\\n                ones.append(i)\\n        \\n        if len(ones) == 0:\\n            return [0,len(arr)-1]\\n        \\n        if len(ones) < 3 or len(ones)%3 > 0:\\n            return [-1, -1]\\n        \\n        endZeros = len(arr)-ones[-1]-1 \\n        l1 = ones[0]\\n        l2 = ones[len(ones)//3 -1]\\n        m1 = ones[len(ones)//3]\\n        m2 = ones[2*len(ones)//3-1]\\n        r1 = ones[2*len(ones)//3]\\n        r2 = ones[-1]\\n        \\n        if arr[l1:l2+1+endZeros] == arr[m1:m2+1+endZeros] and arr[m1:m2+1+endZeros] == arr[r1:]:\\n            \\n            return [l2+endZeros,m2+1+endZeros]\\n            \\n            \\n        return [-1,-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = []\\n        for i,num in enumerate(arr):\\n            if num == 1:\\n                ones.append(i)\\n        \\n        if len(ones) == 0:\\n            return [0,len(arr)-1]\\n        \\n        if len(ones) < 3 or len(ones)%3 > 0:\\n            return [-1, -1]\\n        \\n        endZeros = len(arr)-ones[-1]-1 \\n        l1 = ones[0]\\n        l2 = ones[len(ones)//3 -1]\\n        m1 = ones[len(ones)//3]\\n        m2 = ones[2*len(ones)//3-1]\\n        r1 = ones[2*len(ones)//3]\\n        r2 = ones[-1]\\n        \\n        if arr[l1:l2+1+endZeros] == arr[m1:m2+1+endZeros] and arr[m1:m2+1+endZeros] == arr[r1:]:\\n            \\n            return [l2+endZeros,m2+1+endZeros]\\n            \\n            \\n        return [-1,-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019239,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        \"\"\"\\n        1: (# of 1) mod 3 == 0\\n        2: calculate n3 values (start with 0, end to tail)\\n        3. check if there exists n1, n2 == n3\\n        \"\"\"\\n        if sum(A) % 3 != 0:\\n            return [-1, -1]\\n        \\n        if sum(A) == 0:\\n            return [0, len(A) - 1]\\n        \\n        tot = sum(A)\\n        cnt = sum(A) // 3 * 2\\n        n3 = 0\\n        for i, n in enumerate(A):\\n            if cnt > 0:\\n                cnt -= n\\n            else:\\n                n3 = 2 * n3 + n\\n        \\n        n1 = 0\\n        n2 = 0\\n        i1 = None\\n        i2 = None\\n        for i, n in enumerate(A):\\n            if n1 > n3 or n2 > n3:\\n                return [-1, -1]\\n            elif n1 == n3:\\n                n2 = 2 * n2 + n\\n            else:\\n                n1 = 2 * n1 + n\\n                \\n            if n1 == n3 and i1 is None:\\n                i1 = i\\n            \\n            if n2 == n3:\\n                return [i1, i + 1]\\n            \\n        return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        \"\"\"\\n        1: (# of 1) mod 3 == 0\\n        2: calculate n3 values (start with 0, end to tail)\\n        3. check if there exists n1, n2 == n3\\n        \"\"\"\\n        if sum(A) % 3 != 0:\\n            return [-1, -1]\\n        \\n        if sum(A) == 0:\\n            return [0, len(A) - 1]\\n        \\n        tot = sum(A)\\n        cnt = sum(A) // 3 * 2\\n        n3 = 0\\n        for i, n in enumerate(A):\\n            if cnt > 0:\\n                cnt -= n\\n            else:\\n                n3 = 2 * n3 + n\\n        \\n        n1 = 0\\n        n2 = 0\\n        i1 = None\\n        i2 = None\\n        for i, n in enumerate(A):\\n            if n1 > n3 or n2 > n3:\\n                return [-1, -1]\\n            elif n1 == n3:\\n                n2 = 2 * n2 + n\\n            else:\\n                n1 = 2 * n1 + n\\n                \\n            if n1 == n3 and i1 is None:\\n                i1 = i\\n            \\n            if n2 == n3:\\n                return [i1, i + 1]\\n            \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815003,
                "title": "c-short-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int> &A) {\\n        vector<int> vi;\\n        for (int i = 0; i < A.size(); ++i) if (A[i] == 1) vi.push_back(i);\\n        if (vi.size() == 0) return vector{0, 2};\\n        if (vi.size() % 3 != 0) return vector{-1, -1};\\n        int len = A.size() - vi[vi.size() / 3 * 2];\\n        int a = vi[0], b = vi[vi.size() / 3], c = vi[vi.size() / 3 * 2];\\n        for (int i = 0; i < len; ++i)\\n            if (A[a + i] != A[b + i] || A[a + i] != A[c + i]) return vector{-1, -1};\\n        return vector{a + len - 1, b + len};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int> &A) {\\n        vector<int> vi;\\n        for (int i = 0; i < A.size(); ++i) if (A[i] == 1) vi.push_back(i);\\n        if (vi.size() == 0) return vector{0, 2};\\n        if (vi.size() % 3 != 0) return vector{-1, -1};\\n        int len = A.size() - vi[vi.size() / 3 * 2];\\n        int a = vi[0], b = vi[vi.size() / 3], c = vi[vi.size() / 3 * 2];\\n        for (int i = 0; i < len; ++i)\\n            if (A[a + i] != A[b + i] || A[a + i] != A[c + i]) return vector{-1, -1};\\n        return vector{a + len - 1, b + len};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720969,
                "title": "c-greedy",
                "content": "The only thing horrifying in this problem is its tag hard and its proof which we don\\'t have to do by the way.: )\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& a) {\\n        int one=0;\\n        int n=a.size();\\n        for(auto it:a)if(it)one++;\\n        if(one==0)\\n            return vector<int>{0,n-1};\\n        if(one%3)\\n            return vector<int>{-1,-1};\\n        int k=one/3;\\n        vector<int> pos;\\n        int t=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i])\\n                t++;\\n            if(t==1 and a[i]==1)\\n                pos.push_back(i);\\n            if(t==k)t=0;\\n        }\\n        int st=pos[0],mid=pos[1],en=pos[2];\\n        cout<<\"st= \"<<st<<\" mid= \"<<mid<<\" en= \"<<en<<endl;\\n        while(en<n and a[st]==a[mid] and a[mid]==a[en])\\n            en++,st++,mid++;\\n        if(en==n)\\n            return vector<int>{st-1,mid};\\n        return vector<int>{-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& a) {\\n        int one=0;\\n        int n=a.size();\\n        for(auto it:a)if(it)one++;\\n        if(one==0)\\n            return vector<int>{0,n-1};\\n        if(one%3)\\n            return vector<int>{-1,-1};\\n        int k=one/3;\\n        vector<int> pos;\\n        int t=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i])\\n                t++;\\n            if(t==1 and a[i]==1)\\n                pos.push_back(i);\\n            if(t==k)t=0;\\n        }\\n        int st=pos[0],mid=pos[1],en=pos[2];\\n        cout<<\"st= \"<<st<<\" mid= \"<<mid<<\" en= \"<<en<<endl;\\n        while(en<n and a[st]==a[mid] and a[mid]==a[en])\\n            en++,st++,mid++;\\n        if(en==n)\\n            return vector<int>{st-1,mid};\\n        return vector<int>{-1,-1};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 702617,
                "title": "python-3-solution-explained",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        \"\"\"\\n        Given an array of ones and zeros, this program determines whether\\n        the array can be partitioned three ways where each partition contains\\n        the same pattern of ones and zeros beginning with a one.  If there\\n        are no ones, the presence of at least three zeros makes a partition\\n        possible.\\n\\n        :param A: array of 1\\'s and 0\\'s\\n        :type A: list[int]\\n        :return: pair of integers\\n                 [last location partion 1, first location after partition 2]\\n                 or [-1, -1] if partition is not possible\\n        :rtype: list[int]\\n        \"\"\"\\n        \"\"\"\\n        Initialize:\\n        - length of A\\n        - get number of ones in A\\n        \"\"\"\\n        len_A = len(A)\\n        ones = A.count(1)\\n\\n        \"\"\"\\n        If A is all zeros, a valid partition is possible if the length\\n        of A is 3 or greater.\\n        \"\"\"\\n        if ones == 0:\\n            if len_A >= 3:\\n                return [0, len_A - 1]\\n            else:\\n                return[-1, -1]\\n\\n        \"\"\"\\n        The number of ones must be divisible by 3 in order for it to be\\n        possible to partition A.\\n        \"\"\"\\n        if ones % 3:\\n            return [-1, -1]\\n\\n        \"\"\"\\n        If we have gotton this far, the number of ones in A is divisible\\n        by 3. It is now possible to scan A to find the start of each pattern.\\n        It is also possible to determine the length of the pattern from the\\n        third pattern.\\n        \"\"\"\\n        ones_in_pattern = ones // 3\\n        pattern_starts = []\\n        ones_count = 0\\n        for k, a in enumerate(A):\\n            if a:\\n                ones_count += 1\\n                if ones_in_pattern == 1 \\\\\\n                    or ones_count % ones_in_pattern == 1:\\n                    pattern_starts.append(k)\\n        s1, s2, s3 = pattern_starts\\n        len_pattern = len(A[s3:])\\n\\n        \"\"\"\\n        Compare the patterns and return the result.\\n        \"\"\"\\n        if A[s1:s1 + len_pattern] == A[s2:s2 + len_pattern] == A[s3:]:\\n            return [s1 + len_pattern - 1, s2 + len_pattern]\\n        return [-1, -1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        \"\"\"\\n        Given an array of ones and zeros, this program determines whether\\n        the array can be partitioned three ways where each partition contains\\n        the same pattern of ones and zeros beginning with a one.  If there\\n        are no ones, the presence of at least three zeros makes a partition\\n        possible.\\n\\n        :param A: array of 1\\'s and 0\\'s\\n        :type A: list[int]\\n        :return: pair of integers\\n                 [last location partion 1, first location after partition 2]\\n                 or [-1, -1] if partition is not possible\\n        :rtype: list[int]\\n        \"\"\"\\n        \"\"\"\\n        Initialize:\\n        - length of A\\n        - get number of ones in A\\n        \"\"\"\\n        len_A = len(A)\\n        ones = A.count(1)\\n\\n        \"\"\"\\n        If A is all zeros, a valid partition is possible if the length\\n        of A is 3 or greater.\\n        \"\"\"\\n        if ones == 0:\\n            if len_A >= 3:\\n                return [0, len_A - 1]\\n            else:\\n                return[-1, -1]\\n\\n        \"\"\"\\n        The number of ones must be divisible by 3 in order for it to be\\n        possible to partition A.\\n        \"\"\"\\n        if ones % 3:\\n            return [-1, -1]\\n\\n        \"\"\"\\n        If we have gotton this far, the number of ones in A is divisible\\n        by 3. It is now possible to scan A to find the start of each pattern.\\n        It is also possible to determine the length of the pattern from the\\n        third pattern.\\n        \"\"\"\\n        ones_in_pattern = ones // 3\\n        pattern_starts = []\\n        ones_count = 0\\n        for k, a in enumerate(A):\\n            if a:\\n                ones_count += 1\\n                if ones_in_pattern == 1 \\\\\\n                    or ones_count % ones_in_pattern == 1:\\n                    pattern_starts.append(k)\\n        s1, s2, s3 = pattern_starts\\n        len_pattern = len(A[s3:])\\n\\n        \"\"\"\\n        Compare the patterns and return the result.\\n        \"\"\"\\n        if A[s1:s1 + len_pattern] == A[s2:s2 + len_pattern] == A[s3:]:\\n            return [s1 + len_pattern - 1, s2 + len_pattern]\\n        return [-1, -1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598904,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    int t;\\n    public int[] threeEqualParts(int[] A) {\\n        int res[]=new int[]{-1,-1};\\n        int part1=0;int part2=0;int part3=0;int cnt=1;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ones=0;\\n        for(int n:A)if(n==1)ones++;\\n        if(ones==0)return new int[]{0,A.length-1};\\n        if(ones%3!=0)return res;\\n        t=ones/3;ones=0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==1){\\n                ones++;\\n                map.put(cnt,i);\\n                cnt++;\\n            }\\n        }\\n        for(int i=map.get(t)+1;i<=map.get(2*t);i++){\\n            if(A[i]==0)part1++;\\n            else break;\\n        }\\n        for(int i=map.get(2*t)+1;i<A.length;i++){\\n            if(A[i]==0)part2++;\\n            else break;\\n        }\\n        for(int i=map.get(ones)+1;i<A.length;i++){\\n            if(A[i]==0)part3++;\\n        }\\n        if(part1<part3||part2<part3)return res;\\n        List<Integer>l1=getlist(A,map.get(1),map.get(t));\\n        List<Integer>l2=getlist(A,map.get(t+1),map.get(2*t));\\n        List<Integer>l3=getlist(A,map.get(2*t+1),map.get(ones));\\n        if(!compare(l1,l2)||!compare(l2,l3))return res;\\n        res[0]=map.get(t)+part3;\\n        res[1]=map.get(2*t)+part3+1;\\n        return res;\\n    }\\n    \\n    public List<Integer> getlist(int A[],int i1,int i2){\\n        List<Integer>list=new ArrayList<>();\\n        for(int i=i1;i<=i2;i++)list.add(A[i]);\\n        return list;\\n    }\\n    public boolean compare(List<Integer>list1,List<Integer>list2){\\n        if(list1.size()!=list2.size())return false;\\n        for(int i=0;i<list1.size();i++){\\n            if(list1.get(i)!=list2.get(i))return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int t;\\n    public int[] threeEqualParts(int[] A) {\\n        int res[]=new int[]{-1,-1};\\n        int part1=0;int part2=0;int part3=0;int cnt=1;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ones=0;\\n        for(int n:A)if(n==1)ones++;\\n        if(ones==0)return new int[]{0,A.length-1};\\n        if(ones%3!=0)return res;\\n        t=ones/3;ones=0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==1){\\n                ones++;\\n                map.put(cnt,i);\\n                cnt++;\\n            }\\n        }\\n        for(int i=map.get(t)+1;i<=map.get(2*t);i++){\\n            if(A[i]==0)part1++;\\n            else break;\\n        }\\n        for(int i=map.get(2*t)+1;i<A.length;i++){\\n            if(A[i]==0)part2++;\\n            else break;\\n        }\\n        for(int i=map.get(ones)+1;i<A.length;i++){\\n            if(A[i]==0)part3++;\\n        }\\n        if(part1<part3||part2<part3)return res;\\n        List<Integer>l1=getlist(A,map.get(1),map.get(t));\\n        List<Integer>l2=getlist(A,map.get(t+1),map.get(2*t));\\n        List<Integer>l3=getlist(A,map.get(2*t+1),map.get(ones));\\n        if(!compare(l1,l2)||!compare(l2,l3))return res;\\n        res[0]=map.get(t)+part3;\\n        res[1]=map.get(2*t)+part3+1;\\n        return res;\\n    }\\n    \\n    public List<Integer> getlist(int A[],int i1,int i2){\\n        List<Integer>list=new ArrayList<>();\\n        for(int i=i1;i<=i2;i++)list.add(A[i]);\\n        return list;\\n    }\\n    public boolean compare(List<Integer>list1,List<Integer>list2){\\n        if(list1.size()!=list2.size())return false;\\n        for(int i=0;i<list1.size();i++){\\n            if(list1.get(i)!=list2.get(i))return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570039,
                "title": "simple-solution-o-n-time-complexity-o-1-space",
                "content": "\\tclass Solution(object):\\n\\tdef threeEqualParts(self, A):\\n        if len(A) < 3:\\n            return [-1,-1]\\n        nums = 0\\n        for i in range(len(A)):\\n            if A[i] == 1:\\n                nums += 1\\n        \\n        if nums % 3 != 0:\\n            return [-1,-1]\\n        \\n        if nums == 0:\\n            return [0,len(A) - 1]\\n        arr = []\\n        val = 0\\n        \\n\\n        for i in range(len(A)):\\n            if A[i] == 1:\\n                val += 1\\n                if val == 1 or val == nums/3 or val == nums/3 + 1 or val == 2*nums/3 or val == 2*nums/3 + 1 or val == nums:\\n                    arr.append(i)\\n        if nums == 3:\\n            z = len(A) - arr[2] - 1\\n            x = arr[1] - arr[0] - 1\\n            y = arr[2] - arr[1] - 1\\n            if x < z or y < z:\\n                return [-1,-1]\\n            \\n            return [arr[0] + z, arr[1] + z + 1]\\n            \\n        if A[arr[0]:arr[1]] != A[arr[2]:arr[3]] or A[arr[0]:arr[1]] != A[arr[4]:arr[5]]:\\n            return [-1,-1]\\n        \\n        z = len(A) - arr[5] - 1\\n        x = arr[2] - arr[1] - 1\\n        y = arr[4] - arr[3] - 1\\n        \\n        if x < z or y < z:\\n            return [-1,-1]\\n\\n        return [arr[1] + (len(A) - arr[5]) - 1, arr[3] + (len(A) - arr[5])]",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\tdef threeEqualParts(self, A):\\n        if len(A) < 3:\\n            return [-1,-1]\\n        nums = 0\\n        for i in range(len(A)):\\n            if A[i] == 1:\\n                nums += 1\\n        \\n        if nums % 3 != 0:\\n            return [-1,-1]\\n        \\n        if nums == 0:\\n            return [0,len(A) - 1]\\n        arr = []\\n        val = 0\\n        \\n\\n        for i in range(len(A)):\\n            if A[i] == 1:\\n                val += 1\\n                if val == 1 or val == nums/3 or val == nums/3 + 1 or val == 2*nums/3 or val == 2*nums/3 + 1 or val == nums:\\n                    arr.append(i)\\n        if nums == 3:\\n            z = len(A) - arr[2] - 1\\n            x = arr[1] - arr[0] - 1\\n            y = arr[2] - arr[1] - 1\\n            if x < z or y < z:\\n                return [-1,-1]\\n            \\n            return [arr[0] + z, arr[1] + z + 1]\\n            \\n        if A[arr[0]:arr[1]] != A[arr[2]:arr[3]] or A[arr[0]:arr[1]] != A[arr[4]:arr[5]]:\\n            return [-1,-1]\\n        \\n        z = len(A) - arr[5] - 1\\n        x = arr[2] - arr[1] - 1\\n        y = arr[4] - arr[3] - 1\\n        \\n        if x < z or y < z:\\n            return [-1,-1]\\n\\n        return [arr[1] + (len(A) - arr[5]) - 1, arr[3] + (len(A) - arr[5])]",
                "codeTag": "Java"
            },
            {
                "id": 481365,
                "title": "python-intuitive-solution-less-than-100-memory-usage",
                "content": "```\\nclass Solution(object):\\n    def threeEqualParts(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(A)\\n        if N < 3:\\n            return [-1, -1]\\n\\n        count_of_one = A.count(1)\\n        if count_of_one == 0:\\n            return [0, N-1]\\n        if count_of_one % 3 != 0:\\n            return [-1, -1]\\n\\n        pattern = \\'\\'\\n        count = 0\\n        reversed_str = \\'\\'.join(map(str, A[::-1]))\\n\\n        for i, digit in enumerate(A[::-1]):\\n            if digit == 1:\\n                count += 1\\n            if count == count_of_one/3:\\n                break\\n        pattern = reversed_str[:i+1]\\n\\n        length = len(reversed_str)\\n        len_pattern = len(pattern)\\n\\n        \\'\\'\\'matching\\'\\'\\'\\n        index = reversed_str.find(pattern, len_pattern)\\n        if index == -1:\\n            return [-1, -1]\\n        j = length - index\\n\\n        index = reversed_str.find(pattern, len_pattern + index)\\n        if index == -1:\\n            return [-1, -1]\\n        i = length - index - 1\\n\\n        return [i, j]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def threeEqualParts(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(A)\\n        if N < 3:\\n            return [-1, -1]\\n\\n        count_of_one = A.count(1)\\n        if count_of_one == 0:\\n            return [0, N-1]\\n        if count_of_one % 3 != 0:\\n            return [-1, -1]\\n\\n        pattern = \\'\\'\\n        count = 0\\n        reversed_str = \\'\\'.join(map(str, A[::-1]))\\n\\n        for i, digit in enumerate(A[::-1]):\\n            if digit == 1:\\n                count += 1\\n            if count == count_of_one/3:\\n                break\\n        pattern = reversed_str[:i+1]\\n\\n        length = len(reversed_str)\\n        len_pattern = len(pattern)\\n\\n        \\'\\'\\'matching\\'\\'\\'\\n        index = reversed_str.find(pattern, len_pattern)\\n        if index == -1:\\n            return [-1, -1]\\n        j = length - index\\n\\n        index = reversed_str.find(pattern, len_pattern + index)\\n        if index == -1:\\n            return [-1, -1]\\n        i = length - index - 1\\n\\n        return [i, j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391687,
                "title": "c-o-n-time-simple-sol-with-explaination",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        // check number of 1s\\n        int oneCount = 0, n = A.size();\\n        for (int &i: A)\\n            oneCount += (i == 1);\\n        if (oneCount % 3 != 0)\\n            return vector<int> {-1, -1};\\n        if (oneCount == 0)\\n            return vector<int> {0, 2};\\n        \\n        // find last part\\n        int count = oneCount / 3, third = n;\\n        while (count > 0) {\\n            third--;\\n            if (A[third] == 1)\\n                count--;\\n        }\\n        \\n        // find first part\\n        int first = 0;\\n        while (first < n && A[first] == 0)\\n            first++;\\n        \\n        // check equalness of 1 and 3\\n        bool equal = true;\\n        for (int offset = 0; third + offset < n; offset++)\\n            if (first + offset >= third || A[first + offset] != A[third + offset])\\n                return vector<int> {-1, -1};\\n        \\n        // check equalness of 2 and 3\\n        int second = first + n - third;\\n        while (A[second] == 0)\\n            second++;\\n        for (int offset = 0; third + offset < n; offset++)\\n            if (second + offset >= third || A[second + offset] != A[third + offset])\\n                return vector<int> {-1, -1};\\n\\n        // okay. return last position of first part and first position of third part.\\n        return vector<int> {first + n - third - 1, second + n - third};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        // check number of 1s\\n        int oneCount = 0, n = A.size();\\n        for (int &i: A)\\n            oneCount += (i == 1);\\n        if (oneCount % 3 != 0)\\n            return vector<int> {-1, -1};\\n        if (oneCount == 0)\\n            return vector<int> {0, 2};\\n        \\n        // find last part\\n        int count = oneCount / 3, third = n;\\n        while (count > 0) {\\n            third--;\\n            if (A[third] == 1)\\n                count--;\\n        }\\n        \\n        // find first part\\n        int first = 0;\\n        while (first < n && A[first] == 0)\\n            first++;\\n        \\n        // check equalness of 1 and 3\\n        bool equal = true;\\n        for (int offset = 0; third + offset < n; offset++)\\n            if (first + offset >= third || A[first + offset] != A[third + offset])\\n                return vector<int> {-1, -1};\\n        \\n        // check equalness of 2 and 3\\n        int second = first + n - third;\\n        while (A[second] == 0)\\n            second++;\\n        for (int offset = 0; third + offset < n; offset++)\\n            if (second + offset >= third || A[second + offset] != A[third + offset])\\n                return vector<int> {-1, -1};\\n\\n        // okay. return last position of first part and first position of third part.\\n        return vector<int> {first + n - third - 1, second + n - third};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300534,
                "title": "clean-java-solution-with-o-1-space-and-o-n-complexity",
                "content": "```\\npublic class Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        if (A == null || A.length < 3) return new int[]{-1, -1};\\n        int oneCnt = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) oneCnt++;\\n        }\\n        if (oneCnt % 3 != 0) return new int[]{-1, -1};\\n        int oneAvg = oneCnt / 3;\\n        if (oneAvg == 0) return new int[]{0, A.length - 1};\\n\\n        // find the start index for the 3rd part\\n        int postOnes = 0, start3 = A.length - 1;\\n        while (postOnes < oneAvg) {\\n            if (A[start3--] == 1) postOnes++;\\n        }\\n        start3++;\\n\\n        // find the end index for the 1st part\\n        int l = A.length - start3, i = 0;\\n        while (A[i] == 0) i++;\\n        for (int k = 0; k < l; k++) {\\n            if (A[i + k] != A[start3 + k]) return new int[]{-1, -1};\\n        }\\n        int left = i + l - 1, j = left + 1;\\n\\n        // find the end index for the 2nd part\\n        while (A[j] == 0) j++;\\n        for (int k = 0; k < l; k++) {\\n            if (A[k + j] != A[start3 + k]) return new int[]{-1, -1};\\n        }\\n        int right = j + l;\\n\\n        return new int[]{left, right};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] threeEqualParts(int[] A) {\\n        if (A == null || A.length < 3) return new int[]{-1, -1};\\n        int oneCnt = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] == 1) oneCnt++;\\n        }\\n        if (oneCnt % 3 != 0) return new int[]{-1, -1};\\n        int oneAvg = oneCnt / 3;\\n        if (oneAvg == 0) return new int[]{0, A.length - 1};\\n\\n        // find the start index for the 3rd part\\n        int postOnes = 0, start3 = A.length - 1;\\n        while (postOnes < oneAvg) {\\n            if (A[start3--] == 1) postOnes++;\\n        }\\n        start3++;\\n\\n        // find the end index for the 1st part\\n        int l = A.length - start3, i = 0;\\n        while (A[i] == 0) i++;\\n        for (int k = 0; k < l; k++) {\\n            if (A[i + k] != A[start3 + k]) return new int[]{-1, -1};\\n        }\\n        int left = i + l - 1, j = left + 1;\\n\\n        // find the end index for the 2nd part\\n        while (A[j] == 0) j++;\\n        for (int k = 0; k < l; k++) {\\n            if (A[k + j] != A[start3 + k]) return new int[]{-1, -1};\\n        }\\n        int right = j + l;\\n\\n        return new int[]{left, right};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290095,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        n = len(A)\\n        ones = []\\n        for i in range(n):\\n            if A[i]: ones.append(i)\\n        none = len(ones)\\n        if none == 0: return [0, n-1]\\n        if none % 3: return [-1, -1]\\n        g = none // 3\\n        i, j = ones[g-1], ones[2*g -1]\\n        pre_zero = n-1 - ones[-1]\\n        if ones[g] - ones[g-1]-1 < pre_zero or ones[2*g]-ones[2*g-1]-1 < pre_zero: \\n            return [-1, -1]\\n        \\n        i += pre_zero\\n        j += pre_zero\\n        k = n-1\\n        ans = [i, j+1]\\n        for _ in range(g):\\n            if not (A[k]==A[j]==A[i]): return [-1, -1]\\n            k -=1\\n            j -= 1\\n            i -= 1\\n        return ans\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, A: List[int]) -> List[int]:\\n        n = len(A)\\n        ones = []\\n        for i in range(n):\\n            if A[i]: ones.append(i)\\n        none = len(ones)\\n        if none == 0: return [0, n-1]\\n        if none % 3: return [-1, -1]\\n        g = none // 3\\n        i, j = ones[g-1], ones[2*g -1]\\n        pre_zero = n-1 - ones[-1]\\n        if ones[g] - ones[g-1]-1 < pre_zero or ones[2*g]-ones[2*g-1]-1 < pre_zero: \\n            return [-1, -1]\\n        \\n        i += pre_zero\\n        j += pre_zero\\n        k = n-1\\n        ans = [i, j+1]\\n        for _ in range(g):\\n            if not (A[k]==A[j]==A[i]): return [-1, -1]\\n            k -=1\\n            j -= 1\\n            i -= 1\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 222775,
                "title": "o-n-solution-in-rust-4ms",
                "content": "The algorithm proceeds as follows:\\n- find the number of `1`s that each part must have. This number must be `total_number_of_ones/3` sinceo otherwise parts would definitely not have same values. Because of this if the total number of `1`s is not a multiple of `3`, we can return `{-1, -1}` immediately. Another simple optimization that can be made at this stage is checking if the total number of `1`s is `0`, since in such case any split would result in equal parts. I use `{0,2}` just because it works for all input sizes, including `3`.\\n- find the number of trailing zeros. Since in order to have same values all numbers have to have the exact same number of trailing zeros, we can use the last part to get it, since we know that the end of the thrird part is `A.length-1`.\\n- find the end of the first part. To do this we increase the index until we find encounter `part_ones` number of `1`s and then will skip `trailing_zeros` after making sure that there are enough trailing zeros available.\\n- find the end of the second part. The procedure is exactly the same as the one used for the first part, but the scan starts with `i+1`.\\n- check if all parts are equal and if not return `{-1, -1}`. I\\'m relying on iterator `zip` method to stop as soon as one of the ranges is exhausted in order to avoid having to deal with different part lengths.\\n- return the end of the first and the start of the third part (one past the end of the second part).\\n\\n```\\nimpl Solution {\\n    pub fn three_equal_parts(a: Vec<i32>) -> Vec<i32> {\\n        let ones = a.iter().filter(|&n| *n == 1).count();\\n        if ones == 0 {\\n            return vec![0, 2]; // any split works here\\n        }\\n        if ones % 3 != 0 {\\n            return vec![-1, -1];\\n        }\\n        let part_ones = ones / 3;\\n        let trailing_zeros = (0..a.len()).rev().take_while(|&idx| a[idx] == 0).count();\\n        \\n        let find_part_end = |start| -> Option<usize> {\\n            let mut ones = 0;\\n            let mut i = start;\\n            while ones < part_ones {\\n                if a[i] == 1 {\\n                    ones += 1;\\n                }\\n                i += 1;\\n            }\\n            if !(i..(i+trailing_zeros)).all(|idx| a[idx] == 0) {\\n                // first part does not have enough trailing zeros\\n                return None;\\n            }\\n            Some(i + trailing_zeros - 1)\\n        };\\n        \\n        let i = match find_part_end(0) { // first part end\\n            Some(i) => i,\\n            None => return vec![-1, -1],\\n        };\\n        \\n        let j = match find_part_end(i+1) { // second part end\\n            Some(j) => j + 1, // j starts after the end of second part\\n            None => return vec![-1, -1],\\n        };\\n        \\n        if !(0..i+1).rev().zip((i+1..j).rev()).all(|t| a[t.0] == a[t.1]) {\\n            // first and second parts are different\\n            return vec![-1, -1];\\n        }\\n        \\n        if !(i+1..j).rev().zip((j..a.len()).rev()).all(|t| a[t.0] == a[t.1]) {\\n            // second and first parts are different\\n            return vec![-1, -1];\\n        }\\n        \\n        vec![i as i32, j as i32]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn three_equal_parts(a: Vec<i32>) -> Vec<i32> {\\n        let ones = a.iter().filter(|&n| *n == 1).count();\\n        if ones == 0 {\\n            return vec![0, 2]; // any split works here\\n        }\\n        if ones % 3 != 0 {\\n            return vec![-1, -1];\\n        }\\n        let part_ones = ones / 3;\\n        let trailing_zeros = (0..a.len()).rev().take_while(|&idx| a[idx] == 0).count();\\n        \\n        let find_part_end = |start| -> Option<usize> {\\n            let mut ones = 0;\\n            let mut i = start;\\n            while ones < part_ones {\\n                if a[i] == 1 {\\n                    ones += 1;\\n                }\\n                i += 1;\\n            }\\n            if !(i..(i+trailing_zeros)).all(|idx| a[idx] == 0) {\\n                // first part does not have enough trailing zeros\\n                return None;\\n            }\\n            Some(i + trailing_zeros - 1)\\n        };\\n        \\n        let i = match find_part_end(0) { // first part end\\n            Some(i) => i,\\n            None => return vec![-1, -1],\\n        };\\n        \\n        let j = match find_part_end(i+1) { // second part end\\n            Some(j) => j + 1, // j starts after the end of second part\\n            None => return vec![-1, -1],\\n        };\\n        \\n        if !(0..i+1).rev().zip((i+1..j).rev()).all(|t| a[t.0] == a[t.1]) {\\n            // first and second parts are different\\n            return vec![-1, -1];\\n        }\\n        \\n        if !(i+1..j).rev().zip((j..a.len()).rev()).all(|t| a[t.0] == a[t.1]) {\\n            // second and first parts are different\\n            return vec![-1, -1];\\n        }\\n        \\n        vec![i as i32, j as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 219711,
                "title": "my-concise-solution-with-explanation-beat-100",
                "content": "*Please upvote if you like it.*\\n\\n**Observations/algorithm**:\\n1. Each part must have equal number of 1\\'s.\\n2. Let nums be the actual binary value of the parts, then num1 == num2 == num3, and each num starts with a 1. The only exception is when all nums are 0.\\n3. Each part can have various number of leading 0\\'s.\\n    Thus, part1/num1 and part2/num2 are more flexible: they can play with the leading 0\\'s of the next part.\\n\\n4. num3 can be certain (if it exists), we find num3 by the following method:\\n\\t```\\n            i             j       k\\n    0000[num1]000000[num2]0000000[num3]\\n\\t```\\n\\n    Let find k first, where k is the first \\'1\\' we can find in part3 from left to right.\\n    Then A[k:] is num3, let\\'s call it pattern.\\n    How to find k then? The 1\\'s in num3 is one third of the total 1\\'s.\\n5. There must not be any 1\\'s between any two nums.\\n    So we scan from left to k-1, once we see a 1, it must belong to num1 and num1 must equal to pattern.\\n    Assume num1 matched, we continue scanning, once we see another 1, it must belong to num2 and num2 must equal to pattern.\\n    If num2 == pattern, then we are done; there won\\'t be any 1\\'s between num2 and num3 because the totle 1\\'s are all visited in this round.\\n\\nCode:\\n```\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        N = len(A)\\n        ones = sum(A)\\n        if ones == 0: return [0, N-1]\\n        if ones % 3 > 0: return [-1, -1]\\n        one_third = ones//3\\n        k = N-1\\n        while True:\\n            if A[k] == 1:\\n                ones -= 1\\n                if ones == 2 * one_third: break\\n            k -= 1\\n        pattern = A[k:]\\n        M = len(pattern)\\n        \\n        i = j = None\\n        x = 0\\n        while x < k:\\n            if A[x] == 1:\\n                if A[x:x+M] != pattern: return [-1, -1]\\n                x += M\\n                if i is None: i = x - 1\\n                else: j = x\\n            else:\\n                x += 1\\n        return [i, j]\\n```\\n\\nComplexity Analysis:\\n* Running Time: O(N), two passes\\n* Space: O(N) for storing and comparing pattern",
                "solutionTags": [],
                "code": "```\\n            i             j       k\\n    0000[num1]000000[num2]0000000[num3]\\n\\t```\n```\\nclass Solution:\\n    def threeEqualParts(self, A):\\n        N = len(A)\\n        ones = sum(A)\\n        if ones == 0: return [0, N-1]\\n        if ones % 3 > 0: return [-1, -1]\\n        one_third = ones//3\\n        k = N-1\\n        while True:\\n            if A[k] == 1:\\n                ones -= 1\\n                if ones == 2 * one_third: break\\n            k -= 1\\n        pattern = A[k:]\\n        M = len(pattern)\\n        \\n        i = j = None\\n        x = 0\\n        while x < k:\\n            if A[x] == 1:\\n                if A[x:x+M] != pattern: return [-1, -1]\\n                x += M\\n                if i is None: i = x - 1\\n                else: j = x\\n            else:\\n                x += 1\\n        return [i, j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216541,
                "title": "c-o-n-time-o-1-space-with-comments",
                "content": "If the number at each segment is same, the binary of those segment will also be same. \\nThe key thing is to split all the ones into 3 equal parts. Then, the last segment is final, it will be the value against which first 2 segments need to be compared.\\n```\\nvector<int> threeEqualParts(vector<int>& A) {\\n        int cnt = 0, i, a, b, c, val = 0;\\n        for (auto x : A)\\n            cnt += x;\\n        if (cnt == 0)\\n            return {0, 2};\\n        if (cnt % 3) // number of 1\\'s are not splittable\\n            return {-1,-1};\\n        for (i = A.size() - 1; i >= 0; i--) {\\n            if (A[i]) {\\n                val++;\\n                if (val == cnt/3)\\n                    c = i; // start of 3rd segment\\n                else if (val == 2 * (cnt/3))\\n                    b = i; // start of 2nd segment\\n                else if (val == cnt) {\\n                    a = i; // start of 1st segment\\n                    break;\\n                }\\n            }\\n        }\\n        for (i = 0; i < (int)A.size() - c; i++) {\\n            if (a+i >= b || b+i >= c) // overlapping regions\\n                return {-1, -1};\\n            if (A[c+i] != A[a+i] || A[c+i] != A[b+i]) // mismatch\\n                return {-1, -1};\\n        }\\n        return {a+i-1, b+i};\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<int> threeEqualParts(vector<int>& A) {\\n        int cnt = 0, i, a, b, c, val = 0;\\n        for (auto x : A)\\n            cnt += x;\\n        if (cnt == 0)\\n            return {0, 2};\\n        if (cnt % 3) // number of 1\\'s are not splittable\\n            return {-1,-1};\\n        for (i = A.size() - 1; i >= 0; i--) {\\n            if (A[i]) {\\n                val++;\\n                if (val == cnt/3)\\n                    c = i; // start of 3rd segment\\n                else if (val == 2 * (cnt/3))\\n                    b = i; // start of 2nd segment\\n                else if (val == cnt) {\\n                    a = i; // start of 1st segment\\n                    break;\\n                }\\n            }\\n        }\\n        for (i = 0; i < (int)A.size() - c; i++) {\\n            if (a+i >= b || b+i >= c) // overlapping regions\\n                return {-1, -1};\\n            if (A[c+i] != A[a+i] || A[c+i] != A[b+i]) // mismatch\\n                return {-1, -1};\\n        }\\n        return {a+i-1, b+i};\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 184480,
                "title": "c-22-lines-o-n-time-soluton",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int v[30005];\\n        int cnt = 0,n = A.size();\\n        for(int i=0;i<n;i++)if(A[i])v[cnt++] = i;\\n        if (cnt%3!=0) return {-1,-1};\\n        if (cnt == 0) return {0, n-1};\\n        int a = v[0];\\n        int b = v[cnt/3];\\n        int c = v[cnt/3*2];\\n        int ed = b,ed2 = c;\\n        int num = 0;\\n        while(a<ed && b<ed2 && c<n){\\n            if(A[a]!= A[b] || A[a]!=A[c] || A[b]!=A[c])return {-1,-1};\\n            num += A[a];\\n            if(num==cnt/3 && c==n-1)return {a,b+1};\\n            a++;b++;c++;\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int v[30005];\\n        int cnt = 0,n = A.size();\\n        for(int i=0;i<n;i++)if(A[i])v[cnt++] = i;\\n        if (cnt%3!=0) return {-1,-1};\\n        if (cnt == 0) return {0, n-1};\\n        int a = v[0];\\n        int b = v[cnt/3];\\n        int c = v[cnt/3*2];\\n        int ed = b,ed2 = c;\\n        int num = 0;\\n        while(a<ed && b<ed2 && c<n){\\n            if(A[a]!= A[b] || A[a]!=A[c] || A[b]!=A[c])return {-1,-1};\\n            num += A[a];\\n            if(num==cnt/3 && c==n-1)return {a,b+1};\\n            a++;b++;c++;\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184322,
                "title": "short-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int count = std::count(A.begin(), A.end(), 1);\\n        if(count % 3)\\n            return {-1, -1};\\n        count /= 3;\\n        int i = 0,j = 1,k = 2;\\n        for(int l = 0, cnt = 0; l < A.size(); cnt += A[l], ++l){\\n            if(cnt == 0 && A[l] == 1)\\n                i = l;\\n            if(cnt == count && A[l] == 1)\\n                j = l;\\n            if(cnt == 2 * count && A[l] == 1)\\n                k = l;\\n        }\\n        for(; k < A.size(); ++i, ++j, ++k)\\n            if(A[i] != A[j] || A[i] != A[k])\\n                return {-1, -1};\\n        return {i - 1, j};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& A) {\\n        int count = std::count(A.begin(), A.end(), 1);\\n        if(count % 3)\\n            return {-1, -1};\\n        count /= 3;\\n        int i = 0,j = 1,k = 2;\\n        for(int l = 0, cnt = 0; l < A.size(); cnt += A[l], ++l){\\n            if(cnt == 0 && A[l] == 1)\\n                i = l;\\n            if(cnt == count && A[l] == 1)\\n                j = l;\\n            if(cnt == 2 * count && A[l] == 1)\\n                k = l;\\n        }\\n        for(; k < A.size(); ++i, ++j, ++k)\\n            if(A[i] != A[j] || A[i] != A[k])\\n                return {-1, -1};\\n        return {i - 1, j};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184176,
                "title": "c-solution-in-o-n-using-cumulative-sum-and-binary-search",
                "content": "````\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {        \n        int ones = 0;\n        vector<int> B = A;\n        for (int i = 0; i < A.size(); i++)\n            ones += A[i];\n        \n        if (ones == 0) {\n            return {0, 2};\n        }\n        else {\n            if (ones % 3 != 0) {\n                return {-1, -1};\n            }\n            else {\n                ones /= 3;\n                \n                // Count the number of trailing zeros in part 3\n                int z3 = 0;\n                for (int i = A.size() - 1; A[i] == 0; i--)\n                    z3++;\n                \n                // Cumulate\n                for (int i = 1; i < A.size(); i++)\n                    A[i] += A[i-1];\n                \n                int p1 = lower_bound(A.begin(), A.end(), ones) - A.begin();\n                if (A[p1 + z3] != ones)\n                    return {-1, -1};\n                \n                int p2 = lower_bound(A.begin(), A.end(), 2 * ones) - A.begin();\n                if (A[p2 + z3] != 2 * ones)\n                    return {-1, -1};\n                \n                // Check the content of the 3 arrays\n                int L = A.size() - 1;\n                bool ok = true;\n                for (int i = 0; ones && ok; i++) {\n                    ok &= B[L - i] == B[p2 + z3 - i];\n                    ok &= B[L - i] == B[p1 + z3 - i];\n                    ones -= B[L - i];\n                }\n                \n                if (ok)\n                    return {p1 + z3, p2 + z3 + 1};\n                else\n                    return {-1, -1};\n            }\n        }\n    }\n};\n````\n",
                "solutionTags": [],
                "code": "````\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {        \n        int ones = 0;\n        vector<int> B = A;\n        for (int i = 0; i < A.size(); i++)\n            ones += A[i];\n        \n        if (ones == 0) {\n            return {0, 2};\n        }\n        else {\n            if (ones % 3 != 0) {\n                return {-1, -1};\n            }\n            else {\n                ones /= 3;\n                \n                // Count the number of trailing zeros in part 3\n                int z3 = 0;\n                for (int i = A.size() - 1; A[i] == 0; i--)\n                    z3++;\n                \n                // Cumulate\n                for (int i = 1; i < A.size(); i++)\n                    A[i] += A[i-1];\n                \n                int p1 = lower_bound(A.begin(), A.end(), ones) - A.begin();\n                if (A[p1 + z3] != ones)\n                    return {-1, -1};\n                \n                int p2 = lower_bound(A.begin(), A.end(), 2 * ones) - A.begin();\n                if (A[p2 + z3] != 2 * ones)\n                    return {-1, -1};\n                \n                // Check the content of the 3 arrays\n                int L = A.size() - 1;\n                bool ok = true;\n                for (int i = 0; ones && ok; i++) {\n                    ok &= B[L - i] == B[p2 + z3 - i];\n                    ok &= B[L - i] == B[p1 + z3 - i];\n                    ones -= B[L - i];\n                }\n                \n                if (ok)\n                    return {p1 + z3, p2 + z3 + 1};\n                else\n                    return {-1, -1};\n            }\n        }\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 183936,
                "title": "java-solution-with-detailed-explanation",
                "content": "# Approach\nWe need to have 3 arrays with binary number represented by them should be all equal.  We know that leading '0'(zero) in binary doesn't add value to binary number, but trailiing zero's do.  So, if we could first count the trailing zeros in the incoming input first.  Then we can try to find 2 other arrays with same number of trailing zeros.  If it's not possible to find such 3 arrays, then we can't find solution.  Also, since we need to slice array into 3 parts, then we need to make sure the incoming arrays contains '1' which are divisible by 3.  \n\n# Algorithm\n1.  Get the **SUM** of the array.  If the **SUM** is not divisible by 3 then we can blindly return [-1,-1] as answer.  Otherwise go to step2\n2.  If sum is 0 then we can split array in many possible ways, we can use [0,A.length-1] as answer.  You can hardcode some other value as well, it should work. Otherwise, go to step3\n3.  Find the trailing zero's in the input.  Lets call it **trailingZeros**.  **targetSum** is equal to **SUM/3**\n4.  Now lets iterate through the input and find the 2 split where the running sum of the split array is equal to **targetSum**.  We know there are count of **trailingZeros** at the end.  So, after we find the **targetSum** store the index with **trailingZeros** count added.  Why we add **trailingZeros** count to the first and second split of the array? Reason: If the last array contains those many trailing zeros then other 2 also must contain those, failing to do so means we cannot split the array into 3 parts.\n5.  Once we find the 2 splits.  We can iterate through the split and check whether **splitSum** matches **targetSum**?.  Return the [-1,-1] when there is no match.\n6.  Last part of the algo:  We found 3 arrays with equals sum, but it's possible that individual binary number formed by split array may not match.  So, lets check the individual bits do they match.  Why we need to match? Reason: Matching them gives a clear indication that binary number formed by 3 are actually equal.\n\nRuntime Complexity is O(N) - N is length of input array.\nSpace Complexity is O(1) - Constant.\nMy solution took 11 ms.  \n# Code\n\n```\npublic int[] threeEqualPartsWorking(int[] A) {\n\t\tint sum = 0, N = A.length ;\n\t\tfor(int v : A) sum +=v;\n\t\tif(sum  % 3 != 0)\n\t\t\treturn new int[]{-1, -1};\n\t\tif(sum  == 0){\n\t\t\treturn new int[]{0, N - 1};\n\t\t}\n\t\tint[] ret = new int[]{-1, -1}; // First split and second split index\n\t\tint trailingZeros = 0;\n\t\tfor(int i= N-1;i >= 0;i--){\n\t\t\tif(A[i] == 1){\n\t\t\t\ttrailingZeros = N-1-i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint runningSum= 0, targetSum = sum /3 ;\n\t\tfor(int i = 0;i < N ;i++){\n\t\t\trunningSum += A[i];\n\t\t\tif(runningSum == targetSum && ret[0] == -1){\n\t\t\t\t\tret[0] = i+trailingZeros;\n\t\t\t}\n\t\t\tif(runningSum == 2*targetSum && ret[1] == -1){\n\t\t\t\t\tret[1] = i+1+trailingZeros;\n\t\t\t}\n\t\t}\n\n\t\tif(ret[1] >= N)// if first split has gone beyond the input array length, then we can't split.\n\t\t\treturn new int[]{-1, -1};\n\n\t\tint splitSum = 0 ;\n\t\tfor(int i = 0;i <= ret[0];i++) splitSum += A[i];\n\t\tif(splitSum != targetSum)return new int[]{-1,-1};\n\n\t\tsplitSum = 0;\n\t\tfor(int i = ret[0]+1;i < ret[1];i++) splitSum += A[i];\n\t\tif(splitSum != targetSum)return new int[]{-1,-1};\n\n\t\tfor(int i = N-1, j = ret[1]-1, k = ret[0]; i >= ret[1] && j >= ret[0]+1 && k >= 0; i--,j--,k--){\n\t\t\tint uniqBits = A[i]+A[j]+A[k];\n\t\t\tif(!(uniqBits == 3 || uniqBits == 0))return new int[]{-1, -1};\n\t\t}\n\n\t\treturn ret;\n}\n```",
                "solutionTags": [],
                "code": "```\npublic int[] threeEqualPartsWorking(int[] A) {\n\t\tint sum = 0, N = A.length ;\n\t\tfor(int v : A) sum +=v;\n\t\tif(sum  % 3 != 0)\n\t\t\treturn new int[]{-1, -1};\n\t\tif(sum  == 0){\n\t\t\treturn new int[]{0, N - 1};\n\t\t}\n\t\tint[] ret = new int[]{-1, -1}; // First split and second split index\n\t\tint trailingZeros = 0;\n\t\tfor(int i= N-1;i >= 0;i--){\n\t\t\tif(A[i] == 1){\n\t\t\t\ttrailingZeros = N-1-i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint runningSum= 0, targetSum = sum /3 ;\n\t\tfor(int i = 0;i < N ;i++){\n\t\t\trunningSum += A[i];\n\t\t\tif(runningSum == targetSum && ret[0] == -1){\n\t\t\t\t\tret[0] = i+trailingZeros;\n\t\t\t}\n\t\t\tif(runningSum == 2*targetSum && ret[1] == -1){\n\t\t\t\t\tret[1] = i+1+trailingZeros;\n\t\t\t}\n\t\t}\n\n\t\tif(ret[1] >= N)// if first split has gone beyond the input array length, then we can't split.\n\t\t\treturn new int[]{-1, -1};\n\n\t\tint splitSum = 0 ;\n\t\tfor(int i = 0;i <= ret[0];i++) splitSum += A[i];\n\t\tif(splitSum != targetSum)return new int[]{-1,-1};\n\n\t\tsplitSum = 0;\n\t\tfor(int i = ret[0]+1;i < ret[1];i++) splitSum += A[i];\n\t\tif(splitSum != targetSum)return new int[]{-1,-1};\n\n\t\tfor(int i = N-1, j = ret[1]-1, k = ret[0]; i >= ret[1] && j >= ret[0]+1 && k >= 0; i--,j--,k--){\n\t\t\tint uniqBits = A[i]+A[j]+A[k];\n\t\t\tif(!(uniqBits == 3 || uniqBits == 0))return new int[]{-1, -1};\n\t\t}\n\n\t\treturn ret;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183912,
                "title": "c-it-is-hard-level-algorithm-and-i-could-not-make-it-in-the-contest",
                "content": "Oct. 20, 2018\\n927. Three Equal Parts\\n\\nIt is the third algorithm in weekly contest 107. I did come out the idea but my code had a few bugs in the contest. It took me more than 30 minutes in the contest and 20 minutes after the contest to make the code work. I also simplify the logic to make it readable. \\n\\nThe idea is to determine how many one in integer array. So first count how many one\\'s in total using one iteration. And then it is true that number of 1 should be divisible by 3. And then the number without considing leading zero can be determined by the map of 1 with its index. \\n\\n1. Count how many 1 in the integer array, save each 1 and its index to a hashmap\\n2. Determine the number in each part using binary string. \\n3. Compare three numbers in three parts to make sure they are the same\\n4. Considering leading zero, determine the two indexes to return. \\n\\nI made mistakes when I caculated a few numbers, one is ``` int index2 = map[number1];```, I could not determine second number\\'s start index; one is to compare third number with first number and second number. Using string compare is to shorten the time to write my own comparison. ``` var digitsString = string.Join(string.Empty, digits); // look up stackoverflow.com```, I had to learn how to convert integer array to a string using C#. \\n\\nHere is my C# code to pass online judge after the contest. \\n\\n```\\npublic class Solution {\\n    public int[] ThreeEqualParts(int[] digits)\\n        {\\n            var notFound = new int[] { -1, -1 };\\n\\n            if (digits == null)\\n                return notFound;\\n\\n            var countof1 = 0;\\n            var length = digits.Length;\\n            var map = new Dictionary<int, int>();\\n            for (int i = 0; i < length; i++)\\n            {\\n                if (digits[i] == 1)\\n                {\\n                    map.Add(countof1, i);\\n                    countof1++;\\n                }\\n            }\\n\\n            if (countof1 % 3 != 0)\\n                return notFound;\\n\\n            if (countof1 == 0)\\n                return new int[] { 0, 2 };\\n\\n            int number1 = countof1 / 3;\\n\\n            // narrow down the number without considering leading zero\\n            int thirdNumberStart = map[countof1 - number1];\\n\\n            // constraint\\n            int minimumLength = length - thirdNumberStart; // substring of number, there are some leading 0s maybe. \\n\\n            // compare the first number with third number            \\n            int index1 = map[0];\\n            int index2 = map[number1];\\n            int index3 = map[countof1 - number1]; // test using countof1 = 3, 2 ; 6;\\n\\n            if (length - index1 + 1 < 3 * minimumLength)\\n                return notFound;\\n\\n            var digitsString = string.Join(string.Empty, digits); // look up stackoverflow.com\\n\\n            var number = digitsString.Substring(thirdNumberStart);\\n            var firstNumber = digitsString.Substring(index1, minimumLength);\\n            var secondNumber = digitsString.Substring(index2, minimumLength);\\n\\n            var result = number.CompareTo(firstNumber) == 0 && number.CompareTo(secondNumber) == 0;\\n            if (!result)\\n            {\\n                return notFound;\\n            }\\n            //               last digit of first number   third number\\'s first digit\\n            return new int[] { index1 + minimumLength - 1, index2 + minimumLength };\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "``` int index2 = map[number1];```\n``` var digitsString = string.Join(string.Empty, digits); // look up stackoverflow.com```\n```\\npublic class Solution {\\n    public int[] ThreeEqualParts(int[] digits)\\n        {\\n            var notFound = new int[] { -1, -1 };\\n\\n            if (digits == null)\\n                return notFound;\\n\\n            var countof1 = 0;\\n            var length = digits.Length;\\n            var map = new Dictionary<int, int>();\\n            for (int i = 0; i < length; i++)\\n            {\\n                if (digits[i] == 1)\\n                {\\n                    map.Add(countof1, i);\\n                    countof1++;\\n                }\\n            }\\n\\n            if (countof1 % 3 != 0)\\n                return notFound;\\n\\n            if (countof1 == 0)\\n                return new int[] { 0, 2 };\\n\\n            int number1 = countof1 / 3;\\n\\n            // narrow down the number without considering leading zero\\n            int thirdNumberStart = map[countof1 - number1];\\n\\n            // constraint\\n            int minimumLength = length - thirdNumberStart; // substring of number, there are some leading 0s maybe. \\n\\n            // compare the first number with third number            \\n            int index1 = map[0];\\n            int index2 = map[number1];\\n            int index3 = map[countof1 - number1]; // test using countof1 = 3, 2 ; 6;\\n\\n            if (length - index1 + 1 < 3 * minimumLength)\\n                return notFound;\\n\\n            var digitsString = string.Join(string.Empty, digits); // look up stackoverflow.com\\n\\n            var number = digitsString.Substring(thirdNumberStart);\\n            var firstNumber = digitsString.Substring(index1, minimumLength);\\n            var secondNumber = digitsString.Substring(index2, minimumLength);\\n\\n            var result = number.CompareTo(firstNumber) == 0 && number.CompareTo(secondNumber) == 0;\\n            if (!result)\\n            {\\n                return notFound;\\n            }\\n            //               last digit of first number   third number\\'s first digit\\n            return new int[] { index1 + minimumLength - 1, index2 + minimumLength };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183878,
                "title": "c-o-n-time-o-1-space-40ms",
                "content": "First count the total number of 1s. If it is not a multiple of 3, then it is not possible.\nOtherwise divide it by 3, we can get the number of 1s should be in each partition. The only uncertain thing now is the number tailing zeros for each partition. However, this can be easily determined by the last partition.\nNow, we konw the number of 1s for each partition and the number of tailing zeros for each partition, we can directly calculate the partition positions. \n\nC++ code here [wrote in the contest, maybe can be optimize further]:\n\n```\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        \n        int c = 0; // count the 1\n        for (auto& x : A) {\n            if (x == 1) {\n                ++c;\n            }\n        }\n        \n        if (c % 3 != 0) {\n            return {-1, -1};\n        }\n        if (c == 0) {\n            return {0,2};\n        }\n        \n        int n = c / 3;\n        int nZero = 0;\n        for (int i = A.size()-1; i >= 0; --i) {\n            if (A[i] == 0) {\n                ++nZero;\n            }\n            else {\n                break;\n            }\n        }\n        \n        // a and b are the partitioning position\n        int a, b;\n        \n        \n        // calculate a\n        a = 0;\n        c = 0; // count the 1\n        while(c < n) {\n            if (A[a] == 0) {\n                ++a;\n            }\n            else {\n                ++a;\n                ++c;\n            }\n        }\n        c = 0; // count the 0\n        while(c < nZero) {\n            if (A[a] == 0) {\n                ++c;\n                ++a;\n            }\n            else {\n                return {-1, -1};\n            }\n        }\n        --a;\n        \n        // calculate b\n        b = a + 1;       \n        c = 0; // count 1\n        while(c < n) {\n            if (A[b] == 0) {\n                ++b;\n            }\n            else {\n                ++b;\n                ++c;\n            }\n        }\n        c = 0; // count 0\n        while(c < nZero) {\n            if (A[b] == 0) {\n                ++c;\n                ++b;\n            }\n            else {\n                return {-1, -1};\n            }\n        }\n        \n        // verify a, b\n        if (verify(A, 0, a, a+1, b-1) && verify(A, 0, a, b, A.size()-1)) {\n            return {a, b};\n        }\n        else {\n            return {-1, -1};\n        }\n    }\nprivate:\n    bool verify(vector<int>& A, int lo1, int hi1, int lo2, int hi2) {\n        int p1 = lo1;\n        int p2 = lo2;\n        while(A[p1] == 0 && p1 <= hi1) ++p1;\n        while(A[p2] == 0 && p2 <= hi2) ++p2;\n        \n        if (hi1 - p1 != hi2 - p2) {\n            return false;\n        }\n        \n        while(p1 < hi1) {\n            if (A[p1] != A[p2]) {\n                return false;\n            }\n            else {\n                ++p1;\n                ++p2;\n            }\n        }\n        \n        return true;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        \n        int c = 0; // count the 1\n        for (auto& x : A) {\n            if (x == 1) {\n                ++c;\n            }\n        }\n        \n        if (c % 3 != 0) {\n            return {-1, -1};\n        }\n        if (c == 0) {\n            return {0,2};\n        }\n        \n        int n = c / 3;\n        int nZero = 0;\n        for (int i = A.size()-1; i >= 0; --i) {\n            if (A[i] == 0) {\n                ++nZero;\n            }\n            else {\n                break;\n            }\n        }\n        \n        // a and b are the partitioning position\n        int a, b;\n        \n        \n        // calculate a\n        a = 0;\n        c = 0; // count the 1\n        while(c < n) {\n            if (A[a] == 0) {\n                ++a;\n            }\n            else {\n                ++a;\n                ++c;\n            }\n        }\n        c = 0; // count the 0\n        while(c < nZero) {\n            if (A[a] == 0) {\n                ++c;\n                ++a;\n            }\n            else {\n                return {-1, -1};\n            }\n        }\n        --a;\n        \n        // calculate b\n        b = a + 1;       \n        c = 0; // count 1\n        while(c < n) {\n            if (A[b] == 0) {\n                ++b;\n            }\n            else {\n                ++b;\n                ++c;\n            }\n        }\n        c = 0; // count 0\n        while(c < nZero) {\n            if (A[b] == 0) {\n                ++c;\n                ++b;\n            }\n            else {\n                return {-1, -1};\n            }\n        }\n        \n        // verify a, b\n        if (verify(A, 0, a, a+1, b-1) && verify(A, 0, a, b, A.size()-1)) {\n            return {a, b};\n        }\n        else {\n            return {-1, -1};\n        }\n    }\nprivate:\n    bool verify(vector<int>& A, int lo1, int hi1, int lo2, int hi2) {\n        int p1 = lo1;\n        int p2 = lo2;\n        while(A[p1] == 0 && p1 <= hi1) ++p1;\n        while(A[p2] == 0 && p2 <= hi2) ++p2;\n        \n        if (hi1 - p1 != hi2 - p2) {\n            return false;\n        }\n        \n        while(p1 < hi1) {\n            if (A[p1] != A[p2]) {\n                return false;\n            }\n            else {\n                ++p1;\n                ++p2;\n            }\n        }\n        \n        return true;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873616,
                "title": "z-function-bashing",
                "content": "We first skip the leading zeroes. Then, in order for the last part to equal the first part, its starting index `i` must satisfy `i + z[i] == n`. Then, the middle part must start at the first one past the end of the first part. We can precompute the first one past any index in `O(n)`, so the middle part starts at `j = first_one[z[i]]`. We then need the middle part to satisfy `z[j] >= z[i]` and `first_one[j + z[i]] == i`.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        auto it = std::find(arr.begin(), arr.end(), 1);\\n        if (it == arr.end()) return {0, 2};\\n        int n = arr.end() - it;\\n        int off = it - arr.begin();\\n        std::vector<int> ns(n + 1);\\n        ns.back() = n;\\n        for (int i = n; i--; ns[i] = it[i] == 1 ? i : ns[i + 1]);\\n        std::vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i < r) {\\n                z[i] = std::min(z[i - l], r - i);\\n            }\\n            while (i + z[i] < n && it[i + z[i]] == it[z[i]]) ++z[i];\\n            if (i + z[i] > r) {\\n                l = i;\\n                r = i + z[i];\\n            }\\n            if (i + z[i] == n && ns[z[i]] < i && z[ns[z[i]]] >= z[i] && ns[ns[z[i]] + z[i]] == i) {\\n                return {off + z[i] - 1, off + ns[z[i]] + z[i]};\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        auto it = std::find(arr.begin(), arr.end(), 1);\\n        if (it == arr.end()) return {0, 2};\\n        int n = arr.end() - it;\\n        int off = it - arr.begin();\\n        std::vector<int> ns(n + 1);\\n        ns.back() = n;\\n        for (int i = n; i--; ns[i] = it[i] == 1 ? i : ns[i + 1]);\\n        std::vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i < r) {\\n                z[i] = std::min(z[i - l], r - i);\\n            }\\n            while (i + z[i] < n && it[i + z[i]] == it[z[i]]) ++z[i];\\n            if (i + z[i] > r) {\\n                l = i;\\n                r = i + z[i];\\n            }\\n            if (i + z[i] == n && ns[z[i]] < i && z[ns[z[i]]] >= z[i] && ns[ns[z[i]] + z[i]] == i) {\\n                return {off + z[i] - 1, off + ns[z[i]] + z[i]};\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733985,
                "title": "c-o-n-solution-check-if-first-two-parts-match-last-part",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Not possible if count of ones isn\\'t divisible by 3 and each part will have (count of ones / 3) ones\\n- Last part of array determines what the other 2 parts must equal since any leading zeros won\\'t affect what the last part will be (ex [1,1,0,0,1] -> last part can be 1, 01, 001 and will always be the same value)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Knowing the number that each part is suppose to be makes it an easy check of positions of ones and non leading zeros match the last part\\n- If they don\\'t match return {-1, -1}\\n- Otherwise you know where each part ends\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int countOnes = 0;\\n        for(int& i : arr){\\n            if(i == 1) countOnes++;\\n        }\\n        if(countOnes % 3 != 0) return {-1, -1};\\n        if(countOnes == 0) return{0, (int)arr.size() - 1};\\n        countOnes /= 3;\\n\\n        //find last part\\n        int lastPartStart = arr.size() - 1, currOnes = 0;\\n        while(lastPartStart >= 0 && currOnes < countOnes){\\n            if(arr[lastPartStart] == 1){\\n                currOnes++;\\n            }\\n            lastPartStart--;\\n        }\\n        \\n        //check if first part matches last part\\n        int firstPartEnd = 0;\\n        while(arr[firstPartEnd] == 0) firstPartEnd++;\\n        for(int r = lastPartStart + 1; r < arr.size(); firstPartEnd++, r++){\\n            if(arr[firstPartEnd] != arr[r]) return {-1, -1};\\n        }\\n        firstPartEnd--;\\n\\n        //check if second part matches last part\\n        int lastIndexStart = firstPartEnd + 1;\\n        while(arr[lastIndexStart] == 0) lastIndexStart++;\\n        for(int r = lastPartStart + 1; r < arr.size(); lastIndexStart++, r++){\\n            if(arr[lastIndexStart] != arr[r]) return {-1, -1};\\n        }\\n\\n        return {firstPartEnd, lastIndexStart};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int countOnes = 0;\\n        for(int& i : arr){\\n            if(i == 1) countOnes++;\\n        }\\n        if(countOnes % 3 != 0) return {-1, -1};\\n        if(countOnes == 0) return{0, (int)arr.size() - 1};\\n        countOnes /= 3;\\n\\n        //find last part\\n        int lastPartStart = arr.size() - 1, currOnes = 0;\\n        while(lastPartStart >= 0 && currOnes < countOnes){\\n            if(arr[lastPartStart] == 1){\\n                currOnes++;\\n            }\\n            lastPartStart--;\\n        }\\n        \\n        //check if first part matches last part\\n        int firstPartEnd = 0;\\n        while(arr[firstPartEnd] == 0) firstPartEnd++;\\n        for(int r = lastPartStart + 1; r < arr.size(); firstPartEnd++, r++){\\n            if(arr[firstPartEnd] != arr[r]) return {-1, -1};\\n        }\\n        firstPartEnd--;\\n\\n        //check if second part matches last part\\n        int lastIndexStart = firstPartEnd + 1;\\n        while(arr[lastIndexStart] == 0) lastIndexStart++;\\n        for(int r = lastPartStart + 1; r < arr.size(); lastIndexStart++, r++){\\n            if(arr[lastIndexStart] != arr[r]) return {-1, -1};\\n        }\\n\\n        return {firstPartEnd, lastIndexStart};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625985,
                "title": "c-equal-binary-parts",
                "content": "# Intuition\\nThe problem asks us to divide an array into three parts such that each part represents the same binary value. We need to find the indices where we can split the array into three parts and check if each part has the same binary value.\\n# Approach\\n1. Count the number of ones in the given array. Let\\'s denote this count as `oneCount`.\\n2. If the `oneCount` is not divisible by 3, it is not possible to divide the array into three equal parts with the same binary value. In this case, return `[-1, -1]`.\\n3. If the `oneCount` is 0, it means the array consists of all zeros. In this case, we can divide the array at indices 0 and `n-1`, where `n` is the length of the array. Return `[0, n-1]`.\\n4. Calculate the target binary value for each part, which is equal to `oneCount / 3`.\\n5. Find the indices `firstOneIdx`, `secondOneIdx`, and `thirdOneIdx` where the first, second, and third target binary values end, respectively.\\n6. Check if the suffix starting from thirdOneIdx has the same binary value as the prefix starting from `firstOneIdx`. If it does, return `[firstOneIdx-1, secondOneIdx]` as the indices where the array can be divided into three equal parts. Otherwise, `return [-1, -1]`.\\n# Complexity\\n- Time complexity:\\nThe algorithm traverses the array once to count the number of ones, which takes O(n) time, where n is the length of the array. Therefore, the time complexity of the algorithm is `O(n)`.\\n- Space complexity:\\nThe algorithm uses a constant amount of extra space, so the space complexity is `O(1)`.\\n# Code\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        int oneCount = 0;\\n        int n = arr.size();\\n\\n        // Count the number of ones\\n        for (int num : arr) {\\n            if (num == 1) {\\n                oneCount++;\\n            }\\n        }\\n\\n        // If oneCount is not divisible by 3, return {-1, -1}\\n        if (oneCount % 3 != 0) {\\n            return {-1, -1};\\n        }\\n\\n        // If oneCount is 0, return {0, n-1}\\n        if (oneCount == 0) {\\n            return {0, n - 1};\\n        }\\n\\n        // Calculate the target binary value\\n        int target = oneCount / 3;\\n\\n        int firstOneIdx = -1;\\n        int secondOneIdx = -1;\\n        int thirdOneIdx = -1;\\n\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) {\\n                count++;\\n\\n                if (count == 1)\\n                    firstOneIdx = i;\\n                else if (count == target + 1)\\n                    secondOneIdx = i;\\n                else if (count == 2 * target + 1)\\n                    thirdOneIdx = i;\\n            }\\n        }\\n\\n        // Find the matching suffix\\n        while (thirdOneIdx < n && arr[firstOneIdx] == arr[secondOneIdx] && arr[secondOneIdx] == arr[thirdOneIdx]) {\\n            firstOneIdx++;\\n            secondOneIdx++;\\n            thirdOneIdx++;\\n        }\\n\\n        // If the matching suffix is found, return the indices\\n        if (thirdOneIdx == n) {\\n            return {firstOneIdx - 1, secondOneIdx};\\n        } else {\\n            return {-1, -1};\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        int oneCount = 0;\\n        int n = arr.size();\\n\\n        // Count the number of ones\\n        for (int num : arr) {\\n            if (num == 1) {\\n                oneCount++;\\n            }\\n        }\\n\\n        // If oneCount is not divisible by 3, return {-1, -1}\\n        if (oneCount % 3 != 0) {\\n            return {-1, -1};\\n        }\\n\\n        // If oneCount is 0, return {0, n-1}\\n        if (oneCount == 0) {\\n            return {0, n - 1};\\n        }\\n\\n        // Calculate the target binary value\\n        int target = oneCount / 3;\\n\\n        int firstOneIdx = -1;\\n        int secondOneIdx = -1;\\n        int thirdOneIdx = -1;\\n\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) {\\n                count++;\\n\\n                if (count == 1)\\n                    firstOneIdx = i;\\n                else if (count == target + 1)\\n                    secondOneIdx = i;\\n                else if (count == 2 * target + 1)\\n                    thirdOneIdx = i;\\n            }\\n        }\\n\\n        // Find the matching suffix\\n        while (thirdOneIdx < n && arr[firstOneIdx] == arr[secondOneIdx] && arr[secondOneIdx] == arr[thirdOneIdx]) {\\n            firstOneIdx++;\\n            secondOneIdx++;\\n            thirdOneIdx++;\\n        }\\n\\n        // If the matching suffix is found, return the indices\\n        if (thirdOneIdx == n) {\\n            return {firstOneIdx - 1, secondOneIdx};\\n        } else {\\n            return {-1, -1};\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3454023,
                "title": "solution-based-on-substrings-rather-than-subarrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter my first couple of attempts to solve this problem, I realized that because of the limits of the inputs, it was possible to end up with three numbers of 10,000 digits each, which requires the use of expensive unlimited-precision integers.  So, I changed my basic approach to convert the array into a string of \"0\"s and \"1\"s and to determine whether the three substrings are string-equivalent rather than comparing the numeric values of the subarrays.  One thing that complicates this is the presence of the leading zeros, because it\\'s necessary to treat the substrings \"11\" and \"011\" as numerically equivalent even though they\\'re not string equivalent, but we\\'ll handle this.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlthough searching for three equivalent substrings should require a doubly-nested loop (think of it as looping over possible values of \"i\" and \"j\"), we can get away with a single loop over \"i\" because we\\'re looking for substrings that are string-equivalent, hence the same length, so knowing \"i\", we have determined \"j\" -- basically 2 * i.  However, as noted above, we have to consider leading zeros in any or all of the three substrings.  We can eliminate the leading zeros for the left-most substring by searching for the first \"1\" in the string.  For each value of \"i\" and discounting the leading 0\\'s, we can compute \"j\" if we also take into account the leading 0\\'s in the middle and right substrings.  So, the basic logic is:\\n```\\nfor each i from 0 up to n:\\n    calculate left substring and \"i\", skipping leading zeros\\n    calculate mid substring and \"j\", skipping leading zeros\\n    calculate right substring, skipping leading zeros\\n    if left, mid and right substrings are ==, return [ i, j ]\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe iteration over ```i``` is $$O(n)$$ and within that loop,\\nthe calculation does not depend on $$n$$, so the basic complexity\\nis $$O(n)$$.  However, there\\'s another factor -- the comparison of\\nleft, mid and right substrings.  That is another factor of $$O(n)$$, so the overall complexity is $$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only storage that depends on $$n$$ is for the String converted from the input array; its space complexity is $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    # What we\\'re going to do in this version is convert the array of 0\\'s and 1\\'s \\n    # into a string consisting of \"0\"s and \"1\"s.\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len( arr )\\n        arr_str = \\'\\'.join( map( str, arr ) )  # Convert array of 0\\'s and 1\\'s to string of \"0\"s and \"1\"s\\n        left_leading_one_index = arr_str.find( \"1\" )\\n        if left_leading_one_index < 0:  # No 1\\'s anywhere\\n            return [ 0, 2 ]  # Take left=first 0, mid=second 0, and right=the rest of the zero\\'s \\n        for i in range( left_leading_one_index, n - 1 ):\\n            left_string = arr_str[ left_leading_one_index : i + 1 ]\\n            mid_leading_one_index = arr_str.find( \"1\", i + 1 )\\n            mid_stop_index = mid_leading_one_index + len( left_string )\\n            if mid_stop_index + len( left_string ) > n:\\n                return [ -1, -1 ]   # No room for mid and right within \"arr\"\\n            right_leading_one_index = arr_str.find( \"1\", mid_stop_index )\\n            if right_leading_one_index < 0:   # No 1\\'s in right\\n                return [ -1, -1 ]\\n            mid_string = arr_str[ mid_leading_one_index : mid_stop_index ]\\n            right_string = arr_str[ right_leading_one_index : n ]\\n            if left_string == mid_string and left_string == right_string:\\n                return [ i, mid_stop_index ]\\n        return [ -1, -1 ]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfor each i from 0 up to n:\\n    calculate left substring and \"i\", skipping leading zeros\\n    calculate mid substring and \"j\", skipping leading zeros\\n    calculate right substring, skipping leading zeros\\n    if left, mid and right substrings are ==, return [ i, j ]\\n```\n```i```\n```\\nclass Solution:\\n    # What we\\'re going to do in this version is convert the array of 0\\'s and 1\\'s \\n    # into a string consisting of \"0\"s and \"1\"s.\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len( arr )\\n        arr_str = \\'\\'.join( map( str, arr ) )  # Convert array of 0\\'s and 1\\'s to string of \"0\"s and \"1\"s\\n        left_leading_one_index = arr_str.find( \"1\" )\\n        if left_leading_one_index < 0:  # No 1\\'s anywhere\\n            return [ 0, 2 ]  # Take left=first 0, mid=second 0, and right=the rest of the zero\\'s \\n        for i in range( left_leading_one_index, n - 1 ):\\n            left_string = arr_str[ left_leading_one_index : i + 1 ]\\n            mid_leading_one_index = arr_str.find( \"1\", i + 1 )\\n            mid_stop_index = mid_leading_one_index + len( left_string )\\n            if mid_stop_index + len( left_string ) > n:\\n                return [ -1, -1 ]   # No room for mid and right within \"arr\"\\n            right_leading_one_index = arr_str.find( \"1\", mid_stop_index )\\n            if right_leading_one_index < 0:   # No 1\\'s in right\\n                return [ -1, -1 ]\\n            mid_string = arr_str[ mid_leading_one_index : mid_stop_index ]\\n            right_string = arr_str[ right_leading_one_index : n ]\\n            if left_string == mid_string and left_string == right_string:\\n                return [ i, mid_stop_index ]\\n        return [ -1, -1 ]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398016,
                "title": "ruby-1-liner",
                "content": "```\\ndef three_equal_parts(a) =\\n\\n  a.sum>0 ? a.join[/^((0*(1.*))0*\\\\3)0*\\\\3$/] ? [$2.size-1,$1.size] : [-1,-1] : [0,2]\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef three_equal_parts(a) =\\n\\n  a.sum>0 ? a.join[/^((0*(1.*))0*\\\\3)0*\\\\3$/] ? [$2.size-1,$1.size] : [-1,-1] : [0,2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3319305,
                "title": "c-o-n-time-and-o-1-space",
                "content": "# Please Upvote If Usefull, Means a Lot.\\n**Intution**\\n*  We Have to Divide Array into 3 parts Such That They represent Same Binary Number.\\n\\n\\n*  It is Only Possible if Numbers of 1\\'s in Array is Multiple of 3.\\n*  if it is Mltiple of 3 , then lets say 3 parts as **{1st , 2nd and 3rd} parts**\\n\\t*  We will First Find 3rd parts  From Last as Shown in Code and it is Mandatory  all 3 parts represnt same binnary Number....  . lets say 3rd parts Represent Binnary number as Z,then.\\n\\t*  then we wil find First part from Starting , such that we will exclude Leading Zero in that and Compare it with 3rd Parts Binary number.\\n\\t*  and at last we will find  2nd Parts.\\n\\n**And our anser will be end point of first (f) and starting point of 3rd parts(s). { f,s} As Described in Question**\\n\\n**Note : IF All Element in Array are Zero i.e, no. of Ones is Zero then answer will be { 0, size of array-1}**\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& a) {\\n        \\n        int n=a.size(), on=0;\\n        \\n        for( int x:a) if(x==1) on++;\\n        \\n        if(on==0) return {0,n-1};\\n        if(on%3!=0) return {-1,-1};\\n        \\n        on=on/3;\\n        string st=\"\",st1=\"\",th=\"\";\\n        int i=n-1,co=0,f=-1,s=-1;\\n        \\n        // 3rd part.\\n        while(i>=0 ){ \\n            if(a[i]==1) co++;\\n            st=to_string(a[i])+st;\\n            \\n            if(co==on){\\n                th=st;\\n                co=0;\\n                st=\"\";\\n                break;\\n            }\\n            i--;\\n        }\\n        int p=i,j=0;\\n        \\n        // Removing zeroes frome Start.\\n        while( j<n && a[j]==0) j++;\\n        \\n        // 1st part\\n        while( j<n && f==-1){\\n            if(a[j]==1) co++;\\n            st+=to_string(a[j]);\\n            \\n            if(co==on && st==th){\\n                co=0;\\n                f=j;\\n                st=\"\";\\n            }\\n            j++;\\n        }\\n        \\n        // Removing  leading Zero in 2nd part.\\n        while( j<n && a[j]==0) j++;\\n        \\n        // 2nd part.\\n        while( j<n &&s==-1 ){ \\n            if(a[j]==1) co++;\\n            st+=to_string(a[j]);\\n            \\n            if(co==on && st==th ){\\n                co=0;\\n                s=j;\\n                st=\"\";\\n            }\\n            j++;\\n        }\\n        if(s==-1) return {-1,-1};\\n        return {f,j};       \\n    }\\n};\\n```\\n\\n**If You Have any Doubt , Fell Free to Asksed.**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& a) {\\n        \\n        int n=a.size(), on=0;\\n        \\n        for( int x:a) if(x==1) on++;\\n        \\n        if(on==0) return {0,n-1};\\n        if(on%3!=0) return {-1,-1};\\n        \\n        on=on/3;\\n        string st=\"\",st1=\"\",th=\"\";\\n        int i=n-1,co=0,f=-1,s=-1;\\n        \\n        // 3rd part.\\n        while(i>=0 ){ \\n            if(a[i]==1) co++;\\n            st=to_string(a[i])+st;\\n            \\n            if(co==on){\\n                th=st;\\n                co=0;\\n                st=\"\";\\n                break;\\n            }\\n            i--;\\n        }\\n        int p=i,j=0;\\n        \\n        // Removing zeroes frome Start.\\n        while( j<n && a[j]==0) j++;\\n        \\n        // 1st part\\n        while( j<n && f==-1){\\n            if(a[j]==1) co++;\\n            st+=to_string(a[j]);\\n            \\n            if(co==on && st==th){\\n                co=0;\\n                f=j;\\n                st=\"\";\\n            }\\n            j++;\\n        }\\n        \\n        // Removing  leading Zero in 2nd part.\\n        while( j<n && a[j]==0) j++;\\n        \\n        // 2nd part.\\n        while( j<n &&s==-1 ){ \\n            if(a[j]==1) co++;\\n            st+=to_string(a[j]);\\n            \\n            if(co==on && st==th ){\\n                co=0;\\n                s=j;\\n                st=\"\";\\n            }\\n            j++;\\n        }\\n        if(s==-1) return {-1,-1};\\n        return {f,j};       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221561,
                "title": "java-two-pointers-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int[] ans=new int[] {-1,-1};\\n        int ones=0;\\n        for(int x:arr) ones+=x;\\n        if(ones==0) return new int[] {0,2};\\n        if(ones%3!=0) return ans;\\n        int onesInEachPart=ones/3;\\n        int firstOneIndexPart1=-1;\\n        int firstOneIndexPart2=-1;\\n        int firstOneIndexPart3=-1;\\n        ones=0;\\n        for(int i=0; i<arr.length;i++) {\\n            if(arr[i]==1) {\\n            ones++;\\n            if(ones==1) firstOneIndexPart1=i;\\n            else if(ones==onesInEachPart+1) firstOneIndexPart2=i;\\n            else if(ones==2*(onesInEachPart)+1) firstOneIndexPart3=i;\\n        }\\n        }\\n        while(firstOneIndexPart3<arr.length) {\\n            if(arr[firstOneIndexPart3]==arr[firstOneIndexPart1] && arr[firstOneIndexPart3]==arr[firstOneIndexPart2]) {\\n                firstOneIndexPart1++;\\n                firstOneIndexPart2++;\\n                firstOneIndexPart3++;\\n            }\\n            else {\\n                return ans;\\n            }\\n        }\\n    return new int[] {firstOneIndexPart1-1,firstOneIndexPart2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int[] ans=new int[] {-1,-1};\\n        int ones=0;\\n        for(int x:arr) ones+=x;\\n        if(ones==0) return new int[] {0,2};\\n        if(ones%3!=0) return ans;\\n        int onesInEachPart=ones/3;\\n        int firstOneIndexPart1=-1;\\n        int firstOneIndexPart2=-1;\\n        int firstOneIndexPart3=-1;\\n        ones=0;\\n        for(int i=0; i<arr.length;i++) {\\n            if(arr[i]==1) {\\n            ones++;\\n            if(ones==1) firstOneIndexPart1=i;\\n            else if(ones==onesInEachPart+1) firstOneIndexPart2=i;\\n            else if(ones==2*(onesInEachPart)+1) firstOneIndexPart3=i;\\n        }\\n        }\\n        while(firstOneIndexPart3<arr.length) {\\n            if(arr[firstOneIndexPart3]==arr[firstOneIndexPart1] && arr[firstOneIndexPart3]==arr[firstOneIndexPart2]) {\\n                firstOneIndexPart1++;\\n                firstOneIndexPart2++;\\n                firstOneIndexPart3++;\\n            }\\n            else {\\n                return ans;\\n            }\\n        }\\n    return new int[] {firstOneIndexPart1-1,firstOneIndexPart2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136224,
                "title": "python-96-straightforward-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = sum(arr)\\n        if n % 3: return [-1, -1]\\n        if n == 0: return [0, 2]\\n        k, indices = n // 3, []\\n        for i, num in enumerate(arr):\\n            if num: indices.append(i)\\n        i1, i2, i3, i, j = *[indices[-(j * k)] for j in (3, 2, 1)], 0 ,0\\n        part1, part2, part3 = arr[i1: i2], arr[i2: i3], arr[i3:]\\n        l1, l2, l3 = i2 - i1, i3 - i2, len(part3)\\n        if l3 > l2 or part2[:l3] != part3 or l3 > l1 or part1[:l3] != part3: return [-1, -1]\\n        i, j = i1 + l3 - 1, i2 + l3\\n        return [i, j]\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = sum(arr)\\n        if n % 3: return [-1, -1]\\n        if n == 0: return [0, 2]\\n        k, indices = n // 3, []\\n        for i, num in enumerate(arr):\\n            if num: indices.append(i)\\n        i1, i2, i3, i, j = *[indices[-(j * k)] for j in (3, 2, 1)], 0 ,0\\n        part1, part2, part3 = arr[i1: i2], arr[i2: i3], arr[i3:]\\n        l1, l2, l3 = i2 - i1, i3 - i2, len(part3)\\n        if l3 > l2 or part2[:l3] != part3 or l3 > l1 or part1[:l3] != part3: return [-1, -1]\\n        i, j = i1 + l3 - 1, i2 + l3\\n        return [i, j]\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066210,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr):\\n        n = len(arr)\\n\\n        res = [i for i in range(n) if arr[i] == 1]\\n\\n        p = len(res)\\n\\n        if p == 0:\\n            return [0,n-1]\\n\\n        id1, id2, id3 = res[0], res[p//3], res[2*p//3]\\n\\n        sub = n-id3\\n\\n        if p%3 == 0 and arr[id1:id1+sub] == arr[id2:id2+sub] == arr[id3:]:\\n            return [id1-1+sub,id2+sub]\\n\\n        return [-1,-1]\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr):\\n        n = len(arr)\\n\\n        res = [i for i in range(n) if arr[i] == 1]\\n\\n        p = len(res)\\n\\n        if p == 0:\\n            return [0,n-1]\\n\\n        id1, id2, id3 = res[0], res[p//3], res[2*p//3]\\n\\n        sub = n-id3\\n\\n        if p%3 == 0 and arr[id1:id1+sub] == arr[id2:id2+sub] == arr[id3:]:\\n            return [id1-1+sub,id2+sub]\\n\\n        return [-1,-1]\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065533,
                "title": "extremely-simple-explanation-solution-included",
                "content": "So the idea is pretty simple, and yes, like most of them, you have to count the number of ones first.\\n1. Count the number of ones (let\\'s call it `ones`). If it\\'s zero, return (0,size-1). If it isn\\'t a multiple of 3, return [-1,-1], and if it is a factor of 3, let\\'s proceed. *\\n\\n* Think about the array this way: \\n```\\n0 1 0 1 ... 0 1 | 1 1 0 ... 0 1 | 0 0 0 0 1 1 1 ... 1\\n     left       |    middle     |         right\\n```\\n2. Get the right side first. Is the only side you can calculate by just passing a pointer and reaching `ones//3` ones. So the value that has to be obtained for the three sides is forced. Here you get the `j` index.\\n3. Having the right side, now you can iterate a left index to see if you can reach the same value.  If we surpass the value of the right side, we can just return `[-1,-1]`. If you reach the value, you get the index `i`.\\n4. Now you can iterate over the middle to see if you can reach the same value as in the left and right sides. If you don\\'t reach it, return `[-1,-1]`.\\n5. If you got the value, the solution is done, because you got `ones` ones, so it\\'s complete.\\n\\n\\n* You need a multiple of three to be able to split the array into three equal bags since each of the subarrays will have `ones//3` ones. \\n\\n# Code\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Step 1: count ones and store info\\n        ones = arr.count(1)\\n        if ones % 3 != 0: return [ -1, -1 ]\\n        oneSize = ones // 3\\n\\n        # We start getting the right value\\n        size = len(arr)\\n        if not ones: return [0,size-1] # Particular case\\n        right = size\\n        rightValue = 0\\n        power = 1\\n        while oneSize > 0:\\n            right -= 1\\n            if arr[right] == 1:\\n                rightValue += power\\n                oneSize -= 1\\n            power <<= 1\\n        \\n        # We start getting the left value\\n        left = -1\\n        leftValue = 0\\n        while leftValue>>1 != rightValue:\\n            left += 1\\n            if arr[left] == 1:\\n                leftValue += 1\\n            leftValue <<= 1\\n            # If we can\\'t reach the value we want, we leave the process\\n            if leftValue>>1 > rightValue: return [-1,-1] \\n        leftValue >>= 1\\n\\n        # We start getting the third value\\n        third = 0\\n        answer = [left] # We got the last index we used for the left value\\n        left += 1 # We recycle the index from left\\n        while left < right:\\n            if arr[left] == 1:\\n                third += 1\\n            third <<= 1\\n            left += 1\\n            if third>>1 == rightValue: break\\n        third >>= 1\\n        # We got the three numbers. Now is matter of verifying.\\n        if third != rightValue: return [-1,-1]\\n        answer.append(left)\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n0 1 0 1 ... 0 1 | 1 1 0 ... 0 1 | 0 0 0 0 1 1 1 ... 1\\n     left       |    middle     |         right\\n```\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Step 1: count ones and store info\\n        ones = arr.count(1)\\n        if ones % 3 != 0: return [ -1, -1 ]\\n        oneSize = ones // 3\\n\\n        # We start getting the right value\\n        size = len(arr)\\n        if not ones: return [0,size-1] # Particular case\\n        right = size\\n        rightValue = 0\\n        power = 1\\n        while oneSize > 0:\\n            right -= 1\\n            if arr[right] == 1:\\n                rightValue += power\\n                oneSize -= 1\\n            power <<= 1\\n        \\n        # We start getting the left value\\n        left = -1\\n        leftValue = 0\\n        while leftValue>>1 != rightValue:\\n            left += 1\\n            if arr[left] == 1:\\n                leftValue += 1\\n            leftValue <<= 1\\n            # If we can\\'t reach the value we want, we leave the process\\n            if leftValue>>1 > rightValue: return [-1,-1] \\n        leftValue >>= 1\\n\\n        # We start getting the third value\\n        third = 0\\n        answer = [left] # We got the last index we used for the left value\\n        left += 1 # We recycle the index from left\\n        while left < right:\\n            if arr[left] == 1:\\n                third += 1\\n            third <<= 1\\n            left += 1\\n            if third>>1 == rightValue: break\\n        third >>= 1\\n        # We got the three numbers. Now is matter of verifying.\\n        if third != rightValue: return [-1,-1]\\n        answer.append(left)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014991,
                "title": "easy-java-solution",
                "content": "# Intuition\\n1) All the partitions must contain equal number of one to be equal.\\n\\n\\n# Complexity\\n- Time complexity: 0(n)\\n\\n\\n- Space complexity: 0(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;\\n        int countOfone = 0;\\n\\n        //Counting total number og ones\\n        for(int i:arr){\\n            if(i == 1){\\n                countOfone++;\\n            }\\n        }\\n\\n        //If number of Ones !== 3k\\n        //No need to check as equal p partitions not possible\\n        if(countOfone % 3 != 0)\\n            return new int[]{-1,-1};\\n\\n        //If the array only have zero\\n        if(countOfone == 0)\\n            return new int[]{0,n-1};\\n\\n        int k = countOfone/3;\\n        // Create a partition   \\n        int i1=-1, i2=-1, i3=-1, j1=-1, j2=-1, j3=-1;\\n        int currCount = 0;\\n//if countOfone is 1, k+1, 2k+1 --> assign i1, i2, i3 respectively\\n//if countOfone is k,2k,3k --> assign j1, j2, j3 respectively.\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i] == 1){\\n                currCount+=1;\\n                if(currCount ==1) i1 = i;\\n                if(currCount == (k+1)) i2=i;\\n                if(currCount == (2*k+1)) i3 = i;\\n\\n                if(currCount ==k) j1 = i;\\n                if(currCount ==2*k) j2 = i;\\n                if(currCount ==3*k) j3 = i;\\n            }\\n        }\\n\\n\\n        //Compare three partitions\\n        int[] part1 = Arrays.copyOfRange(arr, i1, j1+1);//+1 because last index is exclusive\\n        int[] part2 = Arrays.copyOfRange(arr, i2, j2+1);\\n        int[] part3 = Arrays.copyOfRange(arr, i3, j3+1);\\n\\n        if(!Arrays.equals(part1, part2) || !Arrays.equals(part1, part3))\\n            return new int[]{-1,-1};\\n\\n        // Take care of the trailing zeroes\\n        int first =0, second=0, third=0;\\n        first = i2-j1-1;//counting no of trailing zeroes.\\n        second = i3-j2-1;\\n        third = n-j3-1;\\n\\n        if(third > Math.min(first,second))\\n            return new int[]{-1,-1};\\n\\n        return new int[]{j1+third, j2+third+1};    \\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;\\n        int countOfone = 0;\\n\\n        //Counting total number og ones\\n        for(int i:arr){\\n            if(i == 1){\\n                countOfone++;\\n            }\\n        }\\n\\n        //If number of Ones !== 3k\\n        //No need to check as equal p partitions not possible\\n        if(countOfone % 3 != 0)\\n            return new int[]{-1,-1};\\n\\n        //If the array only have zero\\n        if(countOfone == 0)\\n            return new int[]{0,n-1};\\n\\n        int k = countOfone/3;\\n        // Create a partition   \\n        int i1=-1, i2=-1, i3=-1, j1=-1, j2=-1, j3=-1;\\n        int currCount = 0;\\n//if countOfone is 1, k+1, 2k+1 --> assign i1, i2, i3 respectively\\n//if countOfone is k,2k,3k --> assign j1, j2, j3 respectively.\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i] == 1){\\n                currCount+=1;\\n                if(currCount ==1) i1 = i;\\n                if(currCount == (k+1)) i2=i;\\n                if(currCount == (2*k+1)) i3 = i;\\n\\n                if(currCount ==k) j1 = i;\\n                if(currCount ==2*k) j2 = i;\\n                if(currCount ==3*k) j3 = i;\\n            }\\n        }\\n\\n\\n        //Compare three partitions\\n        int[] part1 = Arrays.copyOfRange(arr, i1, j1+1);//+1 because last index is exclusive\\n        int[] part2 = Arrays.copyOfRange(arr, i2, j2+1);\\n        int[] part3 = Arrays.copyOfRange(arr, i3, j3+1);\\n\\n        if(!Arrays.equals(part1, part2) || !Arrays.equals(part1, part3))\\n            return new int[]{-1,-1};\\n\\n        // Take care of the trailing zeroes\\n        int first =0, second=0, third=0;\\n        first = i2-j1-1;//counting no of trailing zeroes.\\n        second = i3-j2-1;\\n        third = n-j3-1;\\n\\n        if(third > Math.min(first,second))\\n            return new int[]{-1,-1};\\n\\n        return new int[]{j1+third, j2+third+1};    \\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923195,
                "title": "java-sde-sheet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ones=0;\\n        int ans[]=new int[]{-1,-1};\\n        for(int i:arr) if(i==1) ones++;\\n        if(ones%3 != 0) return ans;\\n        if(ones == 0) return new int[]{0,2};\\n        int cut=ones/3;\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        int countones=0;\\n        for(int l=0;l<arr.length;l++){\\n            if(arr[l] == 1 )  {\\n                countones++;\\n            if(countones == ((2*cut) + 1)) k=l;\\n            else if(countones == cut + 1) j=l;\\n            else if(countones == 1)i=l;\\n            }\\n        }\\n        System.out.println(i+\" \"+j+\" \"+k);\\n        \\n        while(k<arr.length){\\n            if(arr[i]==arr[j] && arr[j]==arr[k] && arr[k]==arr[i]){\\n                i++;\\n                j++;\\n                k++;\\n            }else return ans;\\n        }\\n        return new int[]{i-1,j};\\n     \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ones=0;\\n        int ans[]=new int[]{-1,-1};\\n        for(int i:arr) if(i==1) ones++;\\n        if(ones%3 != 0) return ans;\\n        if(ones == 0) return new int[]{0,2};\\n        int cut=ones/3;\\n        int i=0;\\n        int j=0;\\n        int k=0;\\n        int countones=0;\\n        for(int l=0;l<arr.length;l++){\\n            if(arr[l] == 1 )  {\\n                countones++;\\n            if(countones == ((2*cut) + 1)) k=l;\\n            else if(countones == cut + 1) j=l;\\n            else if(countones == 1)i=l;\\n            }\\n        }\\n        System.out.println(i+\" \"+j+\" \"+k);\\n        \\n        while(k<arr.length){\\n            if(arr[i]==arr[j] && arr[j]==arr[k] && arr[k]==arr[i]){\\n                i++;\\n                j++;\\n                k++;\\n            }else return ans;\\n        }\\n        return new int[]{i-1,j};\\n     \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905899,
                "title": "python-o-n-o-1-pure-logic-deduction",
                "content": "# Intuition\\r\\nIf their are three equal parts, they must contain same amount of ones, and ends with same amount of zeros\\r\\nThe heading zeros is irrelevant\\r\\n\\r\\n# Approach\\r\\n- count ones, divide it by 3 to get ones count of each part\\r\\n- count tailing zeros, these zeros must contains in each part\\r\\n- hance we can get one and the only cut of I and J just in one parse\\r\\n- the last only thing we need to do, just check whether our cuts is legal\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(n)$$\\r\\n- Space complexity:\\r\\n$$O(1)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def threeEqualParts(self, arr):\\r\\n        ones, remain = divmod(arr.count(1), 3)\\r\\n\\r\\n        if remain != 0: return [-1, -1]  # can not be divided equally\\r\\n        if ones == 0: return [0, 2]  # all zero\\r\\n\\r\\n        L, tail_zero_cnts = len(arr), arr[::-1].index(1)\\r\\n\\r\\n        I, J, cnt = 0, L - 1, 0\\r\\n        for i in filter(arr.__getitem__, range(L)):  # for all ones\\r\\n            cnt += 1\\r\\n            if cnt == ones:\\r\\n                I = i + tail_zero_cnts\\r\\n            if cnt == 2 * ones:\\r\\n                J = i + tail_zero_cnts\\r\\n                break\\r\\n\\r\\n        if int(\\'\\'.join(map(str, arr[:I + 1]))) == int(\\'\\'.join(map(str, arr[I + 1:J + 1]))) == int(\\'\\'.join(map(str, arr[J + 1:]))):\\r\\n            return [I, J + 1]\\r\\n\\r\\n        return [-1, -1]\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def threeEqualParts(self, arr):\\r\\n        ones, remain = divmod(arr.count(1), 3)\\r\\n\\r\\n        if remain != 0: return [-1, -1]  # can not be divided equally\\r\\n        if ones == 0: return [0, 2]  # all zero\\r\\n\\r\\n        L, tail_zero_cnts = len(arr), arr[::-1].index(1)\\r\\n\\r\\n        I, J, cnt = 0, L - 1, 0\\r\\n        for i in filter(arr.__getitem__, range(L)):  # for all ones\\r\\n            cnt += 1\\r\\n            if cnt == ones:\\r\\n                I = i + tail_zero_cnts\\r\\n            if cnt == 2 * ones:\\r\\n                J = i + tail_zero_cnts\\r\\n                break\\r\\n\\r\\n        if int(\\'\\'.join(map(str, arr[:I + 1]))) == int(\\'\\'.join(map(str, arr[I + 1:J + 1]))) == int(\\'\\'.join(map(str, arr[J + 1:]))):\\r\\n            return [I, J + 1]\\r\\n\\r\\n        return [-1, -1]\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858194,
                "title": "c-o-n-time-space",
                "content": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int len;\\n        vector<int> ones;\\n        for( int i=0; i<arr.size(); i++){\\n            if(arr[i]==1)   ones.push_back(i);\\n        }\\n\\n        len=ones.size();\\n        if(len%3!=0)    return {-1, -1};\\n        if(len==0)  return {0,(int)arr.size()-1};\\n        \\n        for( int i=1; i<ones.size()/3; i++){\\n            if(ones[i]-ones[i-1]!=ones[i+len/3]-ones[i+len/3-1]\\n                ||ones[i]-ones[i-1]!=ones[i+len/3*2]-ones[i+len/3*2-1]){\\n                return {-1, -1};\\n            }\\n        }\\n\\n        if(ones[len/3]-ones[len/3-1]-1<arr.size()-1-ones.back()\\n            ||ones[len/3*2]-ones[len/3*2-1]-1<arr.size()-1-ones.back())\\n            return {-1, -1};\\n\\n        return {ones[len/3-1]+(int)arr.size()-1-ones.back(), \\n            ones[len/3*2-1]+(int)arr.size()-1-ones.back()+1};\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int len;\\n        vector<int> ones;\\n        for( int i=0; i<arr.size(); i++){\\n            if(arr[i]==1)   ones.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2783702,
                "title": "easy-java-o-n-time-greedy-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. let say total # of ones = oneSum, then the # of ones in each of three numbers = oneSum / 3\\n2. greedy apporach is try to have least possbile # of zeros at the end of number.\\n3. the number of zeros at the end = length of zero suffix.\\n4. to find our number, try to first fill the ones, then fill the zeros. We got our number.\\n5. then to check if 2nd and 3rd number is present or not, match them from first occurence of one in both.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1};\\n        if(oneSum == 0)return new int[]{0,2};\\n        int oneCount = oneSum / 3;\\n        int i = 0;\\n        int firstOne = -1;\\n        int n= arr.length;\\n        int lastZeroCount = 0;\\n        i = n-1;\\n        while(arr[i] ==0){\\n            lastZeroCount++;\\n            i--;\\n        }\\n        i=0;\\n        while(oneCount > 0){\\n            if(arr[i] == 1 && firstOne == -1)firstOne = i;\\n            oneCount-=arr[i++];\\n        }\\n        while(lastZeroCount > 0){\\n            if(arr[i++] == 1)return new int[]{-1,-1};\\n            lastZeroCount--;\\n        }\\n        int k = i--;\\n        int t = firstOne;\\n        while(arr[k] == 0)k++;\\n        while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        int j = k;\\n        while(arr[k] == 0)k++;\\n        firstOne = t;\\n         while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        return new int[]{i,j};\\n\\n    }\\n}\\n// 1 0 1 1 0 0 1 0 1 1 1 0 1 1\\n//[0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1};\\n        if(oneSum == 0)return new int[]{0,2};\\n        int oneCount = oneSum / 3;\\n        int i = 0;\\n        int firstOne = -1;\\n        int n= arr.length;\\n        int lastZeroCount = 0;\\n        i = n-1;\\n        while(arr[i] ==0){\\n            lastZeroCount++;\\n            i--;\\n        }\\n        i=0;\\n        while(oneCount > 0){\\n            if(arr[i] == 1 && firstOne == -1)firstOne = i;\\n            oneCount-=arr[i++];\\n        }\\n        while(lastZeroCount > 0){\\n            if(arr[i++] == 1)return new int[]{-1,-1};\\n            lastZeroCount--;\\n        }\\n        int k = i--;\\n        int t = firstOne;\\n        while(arr[k] == 0)k++;\\n        while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        int j = k;\\n        while(arr[k] == 0)k++;\\n        firstOne = t;\\n         while(firstOne <=i){\\n            if(arr[firstOne++] != arr[k++])return new int[]{-1,-1};\\n        }\\n        return new int[]{i,j};\\n\\n    }\\n}\\n// 1 0 1 1 0 0 1 0 1 1 1 0 1 1\\n//[0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777154,
                "title": "java-o-n-time-o-1-space-beats-100-with-2-ms",
                "content": "Here is the solution. Just coded what was in mind hence is more verbose. though this code can be reduced in length\\n\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int total = 0;\\n        int[] ones = new int[arr.length];\\n        for(int i=arr.length-1; i>=0; i--) {\\n            total += arr[i];\\n            ones[i] = total;\\n        }\\n        \\n        //Total no of 1\\'s should be divisible by 3 to be split into 3 parts. \\n        if(total%3 != 0)\\n            return new int[] {-1, -1};\\n\\n        //Trivial case. \\n        if(total == 0)\\n            return new int[] {0, arr.length-1};\\n        \\n        //Count no of offset zeros from right\\n        int zeros = 0;\\n        for(int i=arr.length-1; i>=0; i--) {\\n            if(arr[i]==1)   break;\\n            zeros++;\\n        }\\n        \\n        //Find Left & right indexes where count of ones from right is mod 3\\n        int count = 0;\\n        int L = -1, R = -1;\\n        for(int i=arr.length-1; i>=0; i--) {\\n            count += arr[i];\\n            if(arr[i]==0)   continue;\\n            if(count==total/3) {\\n                R = i;\\n            } else if(count==2*total/3){\\n                L = i;\\n                break;\\n            }\\n        }\\n        \\n        // Check if is there any 1 at offet zeros between nos.\\n        for(int i=1; i<=zeros; i++) {\\n            if(arr[L-i]==1 || arr[R-i]==1) {\\n                // Zeros are not same.\\n                return new int[]{-1, -1};\\n            }\\n        }\\n        \\n        // Move L & R to their starting points from right. Add extra zeros to left side of part.\\n        while(arr[--R] != 1);\\n        while(arr[--L] != 1);\\n        L += zeros;\\n        R += zeros;\\n        \\n        // check if all 3 parts are exactly same. \\n        // Note: We just need to check till most significant 1 in each part. Since there can be different set of zeros\\n        count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            count += arr[R-i];\\n            if(arr[arr.length-1-i]!=arr[R-i] || arr[R-i]!=arr[L-i]) {\\n                return new int[]{-1, -1}; \\n            }\\n            if(count == total/3)    break;\\n        }\\n        return new int[]{L, R+1};\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e5968f55-342c-4cc8-ab74-5a98b3860c1c_1667554848.2208898.jpeg)\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int total = 0;\\n        int[] ones = new int[arr.length];\\n        for(int i=arr.length-1; i>=0; i--) {\\n            total += arr[i];\\n            ones[i] = total;\\n        }\\n        \\n        //Total no of 1\\'s should be divisible by 3 to be split into 3 parts. \\n        if(total%3 != 0)\\n            return new int[] {-1, -1};\\n\\n        //Trivial case. \\n        if(total == 0)\\n            return new int[] {0, arr.length-1};\\n        \\n        //Count no of offset zeros from right\\n        int zeros = 0;\\n        for(int i=arr.length-1; i>=0; i--) {\\n            if(arr[i]==1)   break;\\n            zeros++;\\n        }\\n        \\n        //Find Left & right indexes where count of ones from right is mod 3\\n        int count = 0;\\n        int L = -1, R = -1;\\n        for(int i=arr.length-1; i>=0; i--) {\\n            count += arr[i];\\n            if(arr[i]==0)   continue;\\n            if(count==total/3) {\\n                R = i;\\n            } else if(count==2*total/3){\\n                L = i;\\n                break;\\n            }\\n        }\\n        \\n        // Check if is there any 1 at offet zeros between nos.\\n        for(int i=1; i<=zeros; i++) {\\n            if(arr[L-i]==1 || arr[R-i]==1) {\\n                // Zeros are not same.\\n                return new int[]{-1, -1};\\n            }\\n        }\\n        \\n        // Move L & R to their starting points from right. Add extra zeros to left side of part.\\n        while(arr[--R] != 1);\\n        while(arr[--L] != 1);\\n        L += zeros;\\n        R += zeros;\\n        \\n        // check if all 3 parts are exactly same. \\n        // Note: We just need to check till most significant 1 in each part. Since there can be different set of zeros\\n        count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            count += arr[R-i];\\n            if(arr[arr.length-1-i]!=arr[R-i] || arr[R-i]!=arr[L-i]) {\\n                return new int[]{-1, -1}; \\n            }\\n            if(count == total/3)    break;\\n        }\\n        return new int[]{L, R+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704987,
                "title": "simple-o-n-and-failed-brute-force-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int oneCount;\\n        int n = arr.size();\\n        vector<int> result(2,-1);\\n        for (auto &i : arr) \\n            oneCount += (i == 1);\\n        \\n        // if total number of 1\\'s are multiple of 3 then it is possible\\n        // to distribute all of them in 3 diffrent sets\\n        if (oneCount%3 != 0) return result;\\n        \\n        if (oneCount == 0) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n            return result;\\n        }\\n        \\n        // figure out first 1\\'s of 1st, 2nd and 3rd set\\n        int i1,i2,i3;\\n        int ones = 0;\\n        int numOnes = oneCount/3;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i]) {\\n                ones++;\\n                if (ones == 1) i1 = i; // start 1 of first set\\n                if (ones == numOnes+1) i2 = i; // start 1 of second set\\n                if (ones == 2*numOnes+1) i3 = i; // start 1 of third set\\n            }\\n        }\\n        \\n        \\n        // Now check for pattern from first 1 of last set, it should match to all of the patter\\n        // for 1st and 2nd set from first 1\\'s, not we always ingore leading 0\\'s of 1st, 2nd and 3rd set\\n        while(i3 < n) {\\n            if ((arr[i3] != arr[i1]) || (arr[i3] != arr[i2])) {\\n                return result;\\n            }\\n            i1++; i2++; i3++;\\n        }\\n        \\n        result[0] = i1-1;\\n        result[1] = i2;\\n        return result;\\n    }\\n\\t\\n    vector<int> threeEqualPartsDetail(vector<int>& arr) {\\n        int oneCount;\\n        int n = arr.size();\\n        vector<int> result(2,-1);\\n        for (auto &i : arr) \\n            oneCount += (i == 1);\\n        if (oneCount%3 != 0) return result;\\n        \\n        if (oneCount == 0) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n            return result;\\n        }\\n        \\n        // figure out first and last 1\\'s of 1st, 2nd and 3rd set\\n        int i1,j1,i2,j2,i3,j3;\\n        int ones = 0;\\n        int numOnes = oneCount/3;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i]) {\\n                ones++;\\n                if (ones == 1) i1 = i; // start 1 of first set\\n                if (ones == numOnes) j1 = i; // end 1 of first set\\n                if (ones == numOnes+1) i2 = i; // start 1 of second set\\n                if (ones == 2*numOnes) j2 = i; // end 1 of second set\\n                if (ones == 2*numOnes+1) i3 = i; // start 1 of third set\\n                if (ones == 3*numOnes) j3 = i; // end 1 of third set\\n            }\\n        }\\n        \\n        // Now check order off 1\\'s and 0\\'s is the same between first and last 1\\'s of each  number\\n        bool notSame = false;\\n        int i = i1; int j = i2; int k = i3;\\n        ones = 0;\\n        // check if sequence of 1\\'s and 0\\'s of each set between first and last 1\\'s is the same\\n        while(ones != numOnes) {\\n            if ((arr[i] != arr[j]) || (arr[i] != arr[k])) {\\n                notSame = true;\\n                break;\\n            }\\n            if (arr[i]) {\\n                ones++;\\n            }\\n            i++; j++; k++;\\n        }\\n        \\n        if (notSame) {\\n            return result;\\n        }\\n        \\n       \\n        // Now check for all trailing zeros of last set, first and second set and similar trailing 0\\'s\\n        // as we can always ignore the trailing 0\\'s of first, secon and third set\\n        i = j1+1; j = j2 + 1; k = j3+1;\\n        while(k < n) {\\n            if ((arr[k] != arr[i]) || (arr[k] != arr[j])) {\\n                notSame = true;\\n                break;\\n            }\\n            k++; i++; j++;\\n        }\\n        if (notSame)\\n            return result;\\n        \\n        result[0] = i-1;\\n        result[1] = j;\\n        return result;\\n    }\\n};\\n\\n\\nclass SolutionTLE {\\npublic:\\n    int helper(vector<int>& arr, string& val, int pos, int patno) {\\n        int n = 0;\\n        int i = pos;\\n        string curValue;\\n        bool oneSeen = false;\\n        int numBits = 0;\\n        for (;i < arr.size(); i++) {\\n            if (!oneSeen && arr[i] == 0) continue;\\n            numBits++;\\n            if (!oneSeen && arr[i] == 1) {\\n                oneSeen = true;\\n                curValue = \"1\";\\n            } else {\\n                curValue += (arr[i] + \\'0\\');\\n            }\\n            if ((curValue == val) || (curValue > val))\\n                break;\\n        }\\n        if ((patno == 2) && (curValue == val)) {\\n            if (numBits > (arr.size()-i))\\n                return -1;\\n            return helper(arr,val,i+1,patno+1);\\n        } else if ((patno == 3) && (curValue == val ) && (i == (arr.size()-1))) {\\n            return pos;\\n        }\\n        return -1;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int patno = 1;\\n        int ret = -1;\\n        vector<int> result(2,-1);\\n        int n = arr.size();\\n        string val;\\n        bool oneSeen = false;\\n        //cout << \" length : \" << n << endl;\\n        int numBits = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (!oneSeen && arr[i] == 0) continue;\\n            numBits++;\\n            if (!oneSeen && arr[i] == 1) {\\n                oneSeen = true;\\n                val = \"1\";\\n            } else {\\n                val += (arr[i] + \\'0\\');\\n            }\\n            \\n            //cout <<  i << \" \" << val << endl;\\n            if (3*numBits > n)\\n                break;\\n            int ret = helper(arr,val,i+1,patno+1);\\n            if (ret != -1) {\\n                result[0] = i;\\n                result[1] = ret;\\n                return result;\\n            }\\n        }\\n        if (!oneSeen) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nclass SolutionINF {\\npublic:\\n    int helper(vector<int>& arr, long long val, int pos, int patno) {\\n        int n = 0;\\n        int i = pos;\\n        long long  curValue = 0;\\n        for (;i < arr.size(); i++) {\\n            curValue = (curValue << 1) | arr[i];\\n            if ((curValue == val) || (curValue > val))\\n                break;\\n        }\\n        //cout << patno << \" \" << curValue << \" curidx : \" << i << endl;\\n        if ((patno == 2) && (curValue == val)) {\\n            long long numBits = curValue ? log2(curValue)+1 : 0;\\n            if (numBits > (arr.size()-i))\\n                return -1;\\n            return helper(arr,val,i+1,patno+1);\\n        } else if ((patno == 3) && (curValue == val ) && (i == (arr.size()-1))) {\\n            return pos;\\n        }\\n        return -1;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int patno = 1;\\n        long long val = 0;\\n        int ret = -1;\\n        vector<int> result(2,-1);\\n        int n = arr.size();\\n        cout << \" length : \" << n << endl;\\n        for (int i = 0; i < arr.size(); i++) {\\n            val = val << 1;\\n            val |= arr[i];\\n            cout <<  i << \" \" << val << endl;\\n            long long numBits = val ? log2(val)+1 : 0;\\n            if (3*numBits > n)\\n                break;\\n            int ret = helper(arr,val,i+1,patno+1);\\n            if (ret != -1) {\\n                result[0] = i;\\n                result[1] = ret;\\n                return result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int oneCount;\\n        int n = arr.size();\\n        vector<int> result(2,-1);\\n        for (auto &i : arr) \\n            oneCount += (i == 1);\\n        \\n        // if total number of 1\\'s are multiple of 3 then it is possible\\n        // to distribute all of them in 3 diffrent sets\\n        if (oneCount%3 != 0) return result;\\n        \\n        if (oneCount == 0) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n            return result;\\n        }\\n        \\n        // figure out first 1\\'s of 1st, 2nd and 3rd set\\n        int i1,i2,i3;\\n        int ones = 0;\\n        int numOnes = oneCount/3;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i]) {\\n                ones++;\\n                if (ones == 1) i1 = i; // start 1 of first set\\n                if (ones == numOnes+1) i2 = i; // start 1 of second set\\n                if (ones == 2*numOnes+1) i3 = i; // start 1 of third set\\n            }\\n        }\\n        \\n        \\n        // Now check for pattern from first 1 of last set, it should match to all of the patter\\n        // for 1st and 2nd set from first 1\\'s, not we always ingore leading 0\\'s of 1st, 2nd and 3rd set\\n        while(i3 < n) {\\n            if ((arr[i3] != arr[i1]) || (arr[i3] != arr[i2])) {\\n                return result;\\n            }\\n            i1++; i2++; i3++;\\n        }\\n        \\n        result[0] = i1-1;\\n        result[1] = i2;\\n        return result;\\n    }\\n\\t\\n    vector<int> threeEqualPartsDetail(vector<int>& arr) {\\n        int oneCount;\\n        int n = arr.size();\\n        vector<int> result(2,-1);\\n        for (auto &i : arr) \\n            oneCount += (i == 1);\\n        if (oneCount%3 != 0) return result;\\n        \\n        if (oneCount == 0) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n            return result;\\n        }\\n        \\n        // figure out first and last 1\\'s of 1st, 2nd and 3rd set\\n        int i1,j1,i2,j2,i3,j3;\\n        int ones = 0;\\n        int numOnes = oneCount/3;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i]) {\\n                ones++;\\n                if (ones == 1) i1 = i; // start 1 of first set\\n                if (ones == numOnes) j1 = i; // end 1 of first set\\n                if (ones == numOnes+1) i2 = i; // start 1 of second set\\n                if (ones == 2*numOnes) j2 = i; // end 1 of second set\\n                if (ones == 2*numOnes+1) i3 = i; // start 1 of third set\\n                if (ones == 3*numOnes) j3 = i; // end 1 of third set\\n            }\\n        }\\n        \\n        // Now check order off 1\\'s and 0\\'s is the same between first and last 1\\'s of each  number\\n        bool notSame = false;\\n        int i = i1; int j = i2; int k = i3;\\n        ones = 0;\\n        // check if sequence of 1\\'s and 0\\'s of each set between first and last 1\\'s is the same\\n        while(ones != numOnes) {\\n            if ((arr[i] != arr[j]) || (arr[i] != arr[k])) {\\n                notSame = true;\\n                break;\\n            }\\n            if (arr[i]) {\\n                ones++;\\n            }\\n            i++; j++; k++;\\n        }\\n        \\n        if (notSame) {\\n            return result;\\n        }\\n        \\n       \\n        // Now check for all trailing zeros of last set, first and second set and similar trailing 0\\'s\\n        // as we can always ignore the trailing 0\\'s of first, secon and third set\\n        i = j1+1; j = j2 + 1; k = j3+1;\\n        while(k < n) {\\n            if ((arr[k] != arr[i]) || (arr[k] != arr[j])) {\\n                notSame = true;\\n                break;\\n            }\\n            k++; i++; j++;\\n        }\\n        if (notSame)\\n            return result;\\n        \\n        result[0] = i-1;\\n        result[1] = j;\\n        return result;\\n    }\\n};\\n\\n\\nclass SolutionTLE {\\npublic:\\n    int helper(vector<int>& arr, string& val, int pos, int patno) {\\n        int n = 0;\\n        int i = pos;\\n        string curValue;\\n        bool oneSeen = false;\\n        int numBits = 0;\\n        for (;i < arr.size(); i++) {\\n            if (!oneSeen && arr[i] == 0) continue;\\n            numBits++;\\n            if (!oneSeen && arr[i] == 1) {\\n                oneSeen = true;\\n                curValue = \"1\";\\n            } else {\\n                curValue += (arr[i] + \\'0\\');\\n            }\\n            if ((curValue == val) || (curValue > val))\\n                break;\\n        }\\n        if ((patno == 2) && (curValue == val)) {\\n            if (numBits > (arr.size()-i))\\n                return -1;\\n            return helper(arr,val,i+1,patno+1);\\n        } else if ((patno == 3) && (curValue == val ) && (i == (arr.size()-1))) {\\n            return pos;\\n        }\\n        return -1;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int patno = 1;\\n        int ret = -1;\\n        vector<int> result(2,-1);\\n        int n = arr.size();\\n        string val;\\n        bool oneSeen = false;\\n        //cout << \" length : \" << n << endl;\\n        int numBits = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (!oneSeen && arr[i] == 0) continue;\\n            numBits++;\\n            if (!oneSeen && arr[i] == 1) {\\n                oneSeen = true;\\n                val = \"1\";\\n            } else {\\n                val += (arr[i] + \\'0\\');\\n            }\\n            \\n            //cout <<  i << \" \" << val << endl;\\n            if (3*numBits > n)\\n                break;\\n            int ret = helper(arr,val,i+1,patno+1);\\n            if (ret != -1) {\\n                result[0] = i;\\n                result[1] = ret;\\n                return result;\\n            }\\n        }\\n        if (!oneSeen) {\\n            result[0] = 0;\\n            result[1] = n-1;\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nclass SolutionINF {\\npublic:\\n    int helper(vector<int>& arr, long long val, int pos, int patno) {\\n        int n = 0;\\n        int i = pos;\\n        long long  curValue = 0;\\n        for (;i < arr.size(); i++) {\\n            curValue = (curValue << 1) | arr[i];\\n            if ((curValue == val) || (curValue > val))\\n                break;\\n        }\\n        //cout << patno << \" \" << curValue << \" curidx : \" << i << endl;\\n        if ((patno == 2) && (curValue == val)) {\\n            long long numBits = curValue ? log2(curValue)+1 : 0;\\n            if (numBits > (arr.size()-i))\\n                return -1;\\n            return helper(arr,val,i+1,patno+1);\\n        } else if ((patno == 3) && (curValue == val ) && (i == (arr.size()-1))) {\\n            return pos;\\n        }\\n        return -1;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int patno = 1;\\n        long long val = 0;\\n        int ret = -1;\\n        vector<int> result(2,-1);\\n        int n = arr.size();\\n        cout << \" length : \" << n << endl;\\n        for (int i = 0; i < arr.size(); i++) {\\n            val = val << 1;\\n            val |= arr[i];\\n            cout <<  i << \" \" << val << endl;\\n            long long numBits = val ? log2(val)+1 : 0;\\n            if (3*numBits > n)\\n                break;\\n            int ret = helper(arr,val,i+1,patno+1);\\n            if (ret != -1) {\\n                result[0] = i;\\n                result[1] = ret;\\n                return result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2667413,
                "title": "c-slow-but-simple-solution",
                "content": "\\n```\\n// 927. Three Equal Parts\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        const int n = arr.size();\\n        int count_one = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) count_one++;\\n        }\\n        if (count_one == 0) return {0, n - 1};\\n        if (count_one % 3 != 0) return {-1, -1};\\n        \\n        int idx_third = 0, count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (arr[i] == 0) continue;\\n            count++;\\n            if (count == count_one / 3) {\\n                idx_third = i;\\n                break;\\n            }\\n        }\\n        int idx1 = helper(arr, 0, idx_third);\\n        if (idx1 < 0) return {-1, -1};\\n        int idx2 = helper(arr, idx1 + 1, idx_third);\\n        if (idx2 < 0) return {-1, -1};\\n        return {idx1, idx2 + 1};\\n    }\\n    int helper(std::vector<int>& arr, int left, int right) {\\n        const int n = arr.size();\\n        while (arr[left] == 0) {\\n            left++;\\n        }\\n        while (right < n) {\\n            if (arr[left] != arr[right]) return -1;\\n            left++; \\n            right++;\\n        }\\n        return left - 1;\\n    }\\n};\\n```\\n```\\n121 / 121 test cases passed. Status: Accepted\\nRuntime: 114 ms, faster than 16.03% of C++ online submissions for Three Equal Parts.\\nMemory Usage: 39 MB, less than 38.93% of C++ online submissions for Three Equal Parts.\\n```\\n\\n\\n```\\n// 927. Three Equal Parts\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        const int n = arr.size();\\n        int count_one = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) count_one++;\\n        }\\n        if (count_one == 0) return {0, n - 1};\\n        if (count_one % 3 != 0) return {-1, -1};\\n\\n        int k = count_one / 3, start = 0, mid = 0, end = 0, count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) continue;\\n            if (count == 0) start = i;\\n            count++;\\n            if (count == k + 1) mid = i;\\n            if (count == 2 * k + 1) {\\n                end = i; \\n                break;\\n            }\\n        }\\n        while (end < n && arr[start] == arr[mid] && arr[mid] == arr[end]) {\\n            start++; \\n            mid++; \\n            end++;\\n        }\\n        if (end == n) return {start - 1, mid};\\n        return {-1, -1};\\n    }\\n};\\n```\\n```\\n121 / 121 test cases passed. Status: Accepted\\nRuntime: 116 ms, faster than 16.03% of C++ online submissions for Three Equal Parts.\\nMemory Usage: 38.8 MB, less than 96.18% of C++ online submissions for Three Equal Parts.\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// 927. Three Equal Parts\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        const int n = arr.size();\\n        int count_one = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) count_one++;\\n        }\\n        if (count_one == 0) return {0, n - 1};\\n        if (count_one % 3 != 0) return {-1, -1};\\n        \\n        int idx_third = 0, count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (arr[i] == 0) continue;\\n            count++;\\n            if (count == count_one / 3) {\\n                idx_third = i;\\n                break;\\n            }\\n        }\\n        int idx1 = helper(arr, 0, idx_third);\\n        if (idx1 < 0) return {-1, -1};\\n        int idx2 = helper(arr, idx1 + 1, idx_third);\\n        if (idx2 < 0) return {-1, -1};\\n        return {idx1, idx2 + 1};\\n    }\\n    int helper(std::vector<int>& arr, int left, int right) {\\n        const int n = arr.size();\\n        while (arr[left] == 0) {\\n            left++;\\n        }\\n        while (right < n) {\\n            if (arr[left] != arr[right]) return -1;\\n            left++; \\n            right++;\\n        }\\n        return left - 1;\\n    }\\n};\\n```\n```\\n121 / 121 test cases passed. Status: Accepted\\nRuntime: 114 ms, faster than 16.03% of C++ online submissions for Three Equal Parts.\\nMemory Usage: 39 MB, less than 38.93% of C++ online submissions for Three Equal Parts.\\n```\n```\\n// 927. Three Equal Parts\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        const int n = arr.size();\\n        int count_one = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) count_one++;\\n        }\\n        if (count_one == 0) return {0, n - 1};\\n        if (count_one % 3 != 0) return {-1, -1};\\n\\n        int k = count_one / 3, start = 0, mid = 0, end = 0, count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) continue;\\n            if (count == 0) start = i;\\n            count++;\\n            if (count == k + 1) mid = i;\\n            if (count == 2 * k + 1) {\\n                end = i; \\n                break;\\n            }\\n        }\\n        while (end < n && arr[start] == arr[mid] && arr[mid] == arr[end]) {\\n            start++; \\n            mid++; \\n            end++;\\n        }\\n        if (end == n) return {start - 1, mid};\\n        return {-1, -1};\\n    }\\n};\\n```\n```\\n121 / 121 test cases passed. Status: Accepted\\nRuntime: 116 ms, faster than 16.03% of C++ online submissions for Three Equal Parts.\\nMemory Usage: 38.8 MB, less than 96.18% of C++ online submissions for Three Equal Parts.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666855,
                "title": "java-solution-with-explanations",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        // first we need to ensure each part has the same number of 1s.\\n        int count = 0;\\n        for (int i : arr) {\\n            count += i;\\n        }\\n        \\n        // if no 1s, return any division.\\n        if (count == 0) {\\n            return new int[]{0, 2};\\n        }\\n        \\n        // if the 1s can not be divide into three parts, no result.\\n        if (count % 3 != 0) {\\n            return new int[]{-1, -1};\\n        }\\n\\n        // then we count the trailing zeros, since last part should always has a fixed number of trailing zeros.\\n        int t = count / 3;\\n        int z = 0;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (arr[i] == 0) {\\n                z++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        // find the first part, count the 1s to fit our target number and append the trailing zeros.\\n        int p = 0;\\n        int r = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                r = i + z;\\n                break;\\n            }\\n        }\\n\\n        // find the second part with the same method.\\n        // r + 1 ~ arr.length - 1\\n        p = 0;\\n        int r2 = 0;\\n        for (int i = r + 1; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                r2 = i + z;\\n                break;\\n            }\\n        }\\n        \\n        // find the third part.\\n        // r2 + 1 ~ arr.length - 1\\n        p = 0;\\n        for (int i = r2 + 1; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                // in this case, we found three parts with the same number of 1s and trailing zeros.\\n                // but this does not mean that they are equal, we must check the equality.\\n                if (eq(arr, r, r2)) {\\n                    return new int[]{r, r2 + 1};\\n                }\\n                break;\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n\\n    boolean eq(int[] arr, int r, int r2) {\\n        int i = r;\\n        int j = r2;\\n        int k = arr.length - 1;\\n        while (i >= 0 || j >= 0 || k >= 0) {\\n            int a = i < 0 ? 0 : arr[i];\\n            int b = j < 0 || j <= r ? 0 : arr[j];\\n            int c = k < 0 || k <= r2 ? 0 : arr[k];\\n            if (a != b || a != c) {\\n                return false;\\n            }\\n            i--;\\n            k--;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        // first we need to ensure each part has the same number of 1s.\\n        int count = 0;\\n        for (int i : arr) {\\n            count += i;\\n        }\\n        \\n        // if no 1s, return any division.\\n        if (count == 0) {\\n            return new int[]{0, 2};\\n        }\\n        \\n        // if the 1s can not be divide into three parts, no result.\\n        if (count % 3 != 0) {\\n            return new int[]{-1, -1};\\n        }\\n\\n        // then we count the trailing zeros, since last part should always has a fixed number of trailing zeros.\\n        int t = count / 3;\\n        int z = 0;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (arr[i] == 0) {\\n                z++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        // find the first part, count the 1s to fit our target number and append the trailing zeros.\\n        int p = 0;\\n        int r = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                r = i + z;\\n                break;\\n            }\\n        }\\n\\n        // find the second part with the same method.\\n        // r + 1 ~ arr.length - 1\\n        p = 0;\\n        int r2 = 0;\\n        for (int i = r + 1; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                r2 = i + z;\\n                break;\\n            }\\n        }\\n        \\n        // find the third part.\\n        // r2 + 1 ~ arr.length - 1\\n        p = 0;\\n        for (int i = r2 + 1; i < arr.length; i++) {\\n            p += arr[i];\\n            if (p == t) {\\n                // in this case, we found three parts with the same number of 1s and trailing zeros.\\n                // but this does not mean that they are equal, we must check the equality.\\n                if (eq(arr, r, r2)) {\\n                    return new int[]{r, r2 + 1};\\n                }\\n                break;\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n\\n    boolean eq(int[] arr, int r, int r2) {\\n        int i = r;\\n        int j = r2;\\n        int k = arr.length - 1;\\n        while (i >= 0 || j >= 0 || k >= 0) {\\n            int a = i < 0 ? 0 : arr[i];\\n            int b = j < 0 || j <= r ? 0 : arr[j];\\n            int c = k < 0 || k <= r2 ? 0 : arr[k];\\n            if (a != b || a != c) {\\n                return false;\\n            }\\n            i--;\\n            k--;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659736,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        \\n        vector<int> ones;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                ones.push_back(i);\\n            }\\n        }\\n        \\n        int sz = ones.size();\\n        \\n        if(sz == 0)\\n        {\\n            return {0,n-1};\\n        }\\n        \\n        if(sz%3 != 0)\\n        {\\n            return {-1,-1};\\n        }\\n        \\n        int a = ones[0], b = ones[sz/3], c = ones[(sz/3)*2];\\n        \\n        while(c < n && arr[a] == arr[b] && arr[b] == arr[c])\\n        {\\n            a++;\\n            b++;\\n            c++;\\n        }\\n        \\n        if(c == n)\\n        {\\n            return {a-1,b};\\n        }\\n        \\n        return {-1,-1};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        \\n        vector<int> ones;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                ones.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2603678,
                "title": "c-easy-to-unsderstand-step-by-step",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n                c++;\\n        }\\n        if(c%3!=0)return v;\\n        if(c==0)return {0,2}; //can make split from anywhere. this is in case we have 3 size of given array\\n        \\n        int idx=-1;\\n        int cnt=0;\\n        // start counting c/3 1s from back,so that we can make 3 equal parts\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n            if(cnt==c/3)\\n            {  idx=i;\\n             break;}\\n            \\n        }\\n        int front=0;  // ignoring leading 0s\\n        while(arr[front]==0)\\n            front++;\\n        \\n        int strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n        if(strt!=n)return v;\\n        int frststrt=front-1;\\n        while(arr[front]==0)front++;\\n        strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n         if(strt!=n)return v;\\n        return {frststrt,front};\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2584689,
                "title": "c-easy-implementation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n                c++;\\n        }\\n        if(c%3!=0)return v;\\n        if(c==0)return {0,2}; //can make split from anywhere. this is in case we have 3 size of given array\\n        \\n        int idx=-1;\\n        int cnt=0;\\n        // start counting c/3 1s from back,so that we can make 3 equal parts\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n            if(cnt==c/3)\\n            {  idx=i;\\n             break;}\\n            \\n        }\\n        int front=0;  // ignoring leading 0s\\n        while(arr[front]==0)\\n            front++;\\n        \\n        int strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n        if(strt!=n)return v;\\n        int frststrt=front-1;\\n        while(arr[front]==0)front++;\\n        strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n         if(strt!=n)return v;\\n        return {frststrt,front};\\n        \\n    }\\n};\\n\\nPLEASE UPVOTE GUYS!!!!",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2353001,
                "title": "python-solution-leading-and-trailing-zeros",
                "content": "There are a few keys to get three equal parts:\\n1. Number of ones must be the same for all parts, although in binary numbers, the order of 0 and 1s also matter.\\n2. Leading zeros are allowed but to be ignored.\\n3. Trailing zeros are very important. The only way to find out how many there are is to check out the zeros between the last 1 and the end of the array.\\n```\\nclass Solution:\\n    # We can neglect the leading zeros.\\n    # But one important point is that the number of 1s must be the same for all 3 partitions\\n    # So what we can do is once we make sure the number of 1s is divisible by 3, We find where the 3 partitions should start.\\n    # Skip the leading zeros\\n    # Then we match numbers element by element until end\\n    # It is possible that there are extra 0s at the end of the numbers. To accomodate that, we record number of 0s between the end of arr and the last 1\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = sum(arr)\\n        if ones == 0:\\n            return [0, 2]\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        \\n        result, count, last_one = [], 0, 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                count += 1\\n                last_one = i\\n                if count == ones // 3:\\n                    result.append(i)\\n                elif count == 2 * ones // 3:\\n                    result.append(i+1)\\n        for i in range(2):\\n            result[i] += len(arr) - 1 - last_one\\n            \\n        p1, p2, p3 = 0, result[0] + 1, result[1]\\n        # Remove leading 0s\\n        while p1 < result[0] + 1 and arr[p1] == 0:\\n            p1 += 1\\n        while p2 < result[1] and arr[p2] == 0:\\n            p2 += 1\\n        while p3 < len(arr) and arr[p3] == 0:\\n            p3 += 1\\n        if p1 >= result[0] + 1 or p2 >= result[1] or p3 >= len(arr):\\n            return [-1, -1]\\n        \\n        # matching\\n        while p1 < result[0] + 1 and p2 < result[1] and p3 < len(arr):\\n            if arr[p1] == arr[p2] and arr[p2] == arr[p3]:\\n                p1 += 1\\n                p2 += 1\\n                p3 += 1\\n            else:\\n                return [-1, -1]\\n        \\n        if p1 == result[0] + 1 and p2 == result[1] and p3 == len(arr):\\n            return result\\n        else:\\n            return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # We can neglect the leading zeros.\\n    # But one important point is that the number of 1s must be the same for all 3 partitions\\n    # So what we can do is once we make sure the number of 1s is divisible by 3, We find where the 3 partitions should start.\\n    # Skip the leading zeros\\n    # Then we match numbers element by element until end\\n    # It is possible that there are extra 0s at the end of the numbers. To accomodate that, we record number of 0s between the end of arr and the last 1\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ones = sum(arr)\\n        if ones == 0:\\n            return [0, 2]\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        \\n        result, count, last_one = [], 0, 0\\n        for i in range(len(arr)):\\n            if arr[i] == 1:\\n                count += 1\\n                last_one = i\\n                if count == ones // 3:\\n                    result.append(i)\\n                elif count == 2 * ones // 3:\\n                    result.append(i+1)\\n        for i in range(2):\\n            result[i] += len(arr) - 1 - last_one\\n            \\n        p1, p2, p3 = 0, result[0] + 1, result[1]\\n        # Remove leading 0s\\n        while p1 < result[0] + 1 and arr[p1] == 0:\\n            p1 += 1\\n        while p2 < result[1] and arr[p2] == 0:\\n            p2 += 1\\n        while p3 < len(arr) and arr[p3] == 0:\\n            p3 += 1\\n        if p1 >= result[0] + 1 or p2 >= result[1] or p3 >= len(arr):\\n            return [-1, -1]\\n        \\n        # matching\\n        while p1 < result[0] + 1 and p2 < result[1] and p3 < len(arr):\\n            if arr[p1] == arr[p2] and arr[p2] == arr[p3]:\\n                p1 += 1\\n                p2 += 1\\n                p3 += 1\\n            else:\\n                return [-1, -1]\\n        \\n        if p1 == result[0] + 1 and p2 == result[1] and p3 == len(arr):\\n            return result\\n        else:\\n            return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266937,
                "title": "three-equal-parts-c-soln",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    \\n    int fun(int i,vector<int>&v,int ones, int last_zeros){\\n        int n=v.size();\\n        \\n        while(ones!=0 || last_zeros!=0){\\n            if(ones!=0){\\n                if(v[i])\\n                    ones--;\\n            }\\n            else{\\n                if(!v[i])\\n                    last_zeros--;\\n                else break;\\n            }\\n            i++;\\n        }\\n        int to_ret;\\n        if(last_zeros){\\n            to_ret=-1;\\n        }\\n        else{\\n            to_ret=i-1;\\n        }\\n        return to_ret;\\n    }\\n    \\n    void fun2(string &s,int start,int till,vector<int>&v){\\n        int i;\\n        \\n        for(i=start;i<=till;i++){\\n            if(v[i])break;\\n        }\\n        for(i;i<=till;i++){\\n            s+=(char)(v[i]+\\'0\\');\\n        }\\n    }\\n    \\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int cnt=0;\\n        \\n        for(auto x:arr)\\n            if(x)\\n                cnt++;\\n        \\n        vector<int>ans(2);\\n        \\n        if(cnt%3){\\n            ans[0]=-1;\\n            ans[1]=-1;\\n        }\\n        else if(cnt==0){\\n            ans[0]=0;\\n            ans[1]=2;\\n        }\\n        else{\\n            int last_zeros=0;\\n            for(int i=n-1;i>=0;i--){\\n                if(arr[i])\\n                    break;\\n                else \\n                    last_zeros++;\\n            }\\n            \\n            vector<string>vs(3);\\n            \\n            int prev=0,till;\\n            \\n            for(int i=0;i<3;i++){\\n                till=fun(prev,arr,cnt/3,last_zeros);\\n                if(till==-1){\\n                    ans[0]=-1;\\n                    ans[1]=-1;\\n                    break;\\n                }\\n                else{\\n                    fun2(vs[i],prev,till,arr);\\n                    if(i!=2){\\n                        ans[i]=till;\\n                    }\\n                    prev=till+1;\\n                }\\n            }\\n            if(vs[0]==vs[1] && vs[1]==vs[2] && !vs[0].empty()){\\n                ans[1]++;\\n            }\\n            else{\\n                ans[0]=-1;\\n                ans[1]=-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int fun(int i,vector<int>&v,int ones, int last_zeros){\\n        int n=v.size();\\n        \\n        while(ones!=0 || last_zeros!=0){\\n            if(ones!=0){\\n                if(v[i])\\n                    ones--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2167526,
                "title": "java-of-1-mod-3-0-partition-concise-solution",
                "content": "**Steps**\\n\\n- Store all the 1\\'s indexes into a list.\\n\\n- If ones list size is not a multiple of 3, it can\\'t be done.\\n\\n- Leading zeros do not increase the number. \\n\\n- The first partition starts at ones.get(0), second: ones.get(ones.size()/3), thrid: ones.get(ones.size()*2/3)\\n- The third partition is the target number we are aimming for because no matter how we cut it, it won\\'t affect the third number.\\n- Therefore, we will compare the gap between 1s in partition 1 and 2 against that of 3.\\n- We find the cut point with the tail of each partition + partition 3 tail offset to the end of array (last array index - last one index)\\n- We have to check that this cut point does not breach into another partition.\\n\\n```Java\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        List<Integer> ones = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i]==1){\\n                ones.add(i);\\n            }\\n        }\\n        if (ones.size()==0){ // edge case\\n            return new int[]{0,2};\\n        }\\n        int[] ans = new int[2];\\n        int each = ones.size()/3;\\n        for (int i = 0; i < 2 && ones.size()%3==0; i++){ // for the first 2 partitions\\n            for (int j = 0; j < each-1; j++){ // compare gaps\\n                if (ones.get(j+1+i*each)-ones.get(j+i*each)!=ones.get(j+2*each+1)-ones.get(j+2*each))\\n                    return new int[]{-1, -1};\\n            }\\n            ans[i]=ones.get((i+1)*each-1)+i+(arr.length - 1 - ones.get(ones.size()-1)); // cut point\\n        }\\n        return ones.size()%3>0||ans[0]>=ones.get(each)||ans[1]>ones.get(2*each)?\\n            new int[]{-1, -1} : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        List<Integer> ones = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i]==1){\\n                ones.add(i);\\n            }\\n        }\\n        if (ones.size()==0){ // edge case\\n            return new int[]{0,2};\\n        }\\n        int[] ans = new int[2];\\n        int each = ones.size()/3;\\n        for (int i = 0; i < 2 && ones.size()%3==0; i++){ // for the first 2 partitions\\n            for (int j = 0; j < each-1; j++){ // compare gaps\\n                if (ones.get(j+1+i*each)-ones.get(j+i*each)!=ones.get(j+2*each+1)-ones.get(j+2*each))\\n                    return new int[]{-1, -1};\\n            }\\n            ans[i]=ones.get((i+1)*each-1)+i+(arr.length - 1 - ones.get(ones.size()-1)); // cut point\\n        }\\n        return ones.size()%3>0||ans[0]>=ones.get(each)||ans[1]>ones.get(2*each)?\\n            new int[]{-1, -1} : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155025,
                "title": "detailed-explanation-equal-ones-in-all-three-parts",
                "content": "Firstly, we just need to count the number of ones. If divisible by 3 then the split of array with equal binary values is possible or else not. \\nIf the array doesnt contains any ones, then also its valid, with all three parts being just one zero (one of the edge cases) \\n\\nThen we need to split the array in such a way that first, second and third part contains equal ones, we can store the ones indices in a map and get them\\n\\nFor example, consider this example\\na = [1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0]\\n\\nx1 = 2 (index where the first part of one ends) and x2 = 4 (index upto which the first part can extend without taking the ones from second part)\\ny1 = 7 (index where the second part of ones ends)  and   y2 = 10 (index upto which the second part can extend without taking the ones from third part)\\n\\nhere, we are interested in two sliding window that can increase the first part and second part appropriately at the same time. Each time we also check for leading zeros and ignore them if present.\\n\\nDry run will produce results as follows\\n\\n\\t[1,0,1]        [0,0,1,0,1]        [0,0,0,1,0,1,0,0]\\n\\t[1,0,1,0]      [0,1,0,1,0]        [0,0,1,0,1,0,0]\\n\\t[1,0,1,0,0]    [0,1,0,1,0,0]      [0,1,0,1,0,0]\\n\\nsince we found a match, we return it\\n\\n\\nCode : \\n```\\nclass Solution {\\n    \\n    int[] a;\\n    public int[] threeEqualParts(int[] arr) {\\n        \\n        a = arr;\\n        \\n        int count = 0;\\n        Map<Integer, Integer> maps = new HashMap<>();\\n        \\n        //counting the ones and storing the ones indices in a map\\n        for(int i = 0; i < a.length; i++){\\n            if(a[i] == 1) \\n                maps.put(++count, i);\\n        }\\n        \\n        //if the count is zero, all parts are just ones, so return it\\n        if(count == 0) return new int[]{0, a.length - 1};\\n        \\n        //if the count is not divisibe by three, no way of splitting it\\n        if(count%3 != 0) return new int[]{-1, -1};\\n        \\n        //lets get the sliding window indices from the map appropriately\\n        int x1 = maps.get(count/3), x2 = maps.get((count/3) + 1) - 1, y1 = maps.get(2*(count/3)), y2 = maps.get((2*(count/3)) + 1) - 1;\\n        \\n        //incrementing the window of first and second part at the same time and checking \\n        //for match\\n        while(x1 <= x2 && y1 <= y2) {\\n            if(check(0, x1, x1+1, y1, y1+1, a.length - 1)) \\n                return new int[]{x1, y1 + 1};\\n            x1++; y1++;\\n        }\\n            \\n        \\n        //no match found finally\\n        return new int[]{-1, -1};\\n    }\\n    \\n    \\n    private boolean check(int a1, int a2, int b1, int b2, int c1, int c2) {\\n         \\n        //removing leading zeros if present from all the three parts, just \\n        //incrementing the indices in those three parts\\n        a1 = removeLeadingZeros(a1, a2);\\n        b1 = removeLeadingZeros(b1, b2);\\n        c1 = removeLeadingZeros(c1, c2);\\n        \\n       //if the parts length are different, no way of being same \\n       if(((a2 - a1) != (b2 - b1)) || ((a2 - a1) != (c2 - c1))) return false;\\n        \\n       //checking all the parts for same 0\\'s or 1\\'s\\n       while(a1 <= a2 && b1 <= b2 && c1 <= c2) {\\n            if((a[a1] != a[b1]) || (a[a1] != a[c1])) return false;\\n            a1++; b1++; c1++;\\n        }\\n        \\n       return true;\\n    }\\n    \\n    //removing the leading zeros \\n    private int removeLeadingZeros(int idx, int idx2) {\\n         while(idx <= idx2) if(a[idx++] == 1) break;\\n         return idx - 1;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] a;\\n    public int[] threeEqualParts(int[] arr) {\\n        \\n        a = arr;\\n        \\n        int count = 0;\\n        Map<Integer, Integer> maps = new HashMap<>();\\n        \\n        //counting the ones and storing the ones indices in a map\\n        for(int i = 0; i < a.length; i++){\\n            if(a[i] == 1) \\n                maps.put(++count, i);\\n        }\\n        \\n        //if the count is zero, all parts are just ones, so return it\\n        if(count == 0) return new int[]{0, a.length - 1};\\n        \\n        //if the count is not divisibe by three, no way of splitting it\\n        if(count%3 != 0) return new int[]{-1, -1};\\n        \\n        //lets get the sliding window indices from the map appropriately\\n        int x1 = maps.get(count/3), x2 = maps.get((count/3) + 1) - 1, y1 = maps.get(2*(count/3)), y2 = maps.get((2*(count/3)) + 1) - 1;\\n        \\n        //incrementing the window of first and second part at the same time and checking \\n        //for match\\n        while(x1 <= x2 && y1 <= y2) {\\n            if(check(0, x1, x1+1, y1, y1+1, a.length - 1)) \\n                return new int[]{x1, y1 + 1};\\n            x1++; y1++;\\n        }\\n            \\n        \\n        //no match found finally\\n        return new int[]{-1, -1};\\n    }\\n    \\n    \\n    private boolean check(int a1, int a2, int b1, int b2, int c1, int c2) {\\n         \\n        //removing leading zeros if present from all the three parts, just \\n        //incrementing the indices in those three parts\\n        a1 = removeLeadingZeros(a1, a2);\\n        b1 = removeLeadingZeros(b1, b2);\\n        c1 = removeLeadingZeros(c1, c2);\\n        \\n       //if the parts length are different, no way of being same \\n       if(((a2 - a1) != (b2 - b1)) || ((a2 - a1) != (c2 - c1))) return false;\\n        \\n       //checking all the parts for same 0\\'s or 1\\'s\\n       while(a1 <= a2 && b1 <= b2 && c1 <= c2) {\\n            if((a[a1] != a[b1]) || (a[a1] != a[c1])) return false;\\n            a1++; b1++; c1++;\\n        }\\n        \\n       return true;\\n    }\\n    \\n    //removing the leading zeros \\n    private int removeLeadingZeros(int idx, int idx2) {\\n         while(idx <= idx2) if(a[idx++] == 1) break;\\n         return idx - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069601,
                "title": "c-o-n-time-o-n-space-hashing-solution",
                "content": "``` \\n#define ll long long\\nclass Solution {\\n    int n;\\n    vector<ll> pow1, pow2, hash1, hash2;\\n    const int MOD = 1e9 + 7;\\n    ll modpow(ll n, ll p) {\\n        if (p == 0) return 1;\\n        ll x = modpow(n, p / 2);\\n        x = (x * x) % MOD;\\n        if (p % 2)  x = (x * n) % MOD;\\n        return x;\\n    }\\n    void set(vector<int>& arr) {\\n        pow1[n - 1] = 1, pow2[n - 1] = 1, hash1[n - 1] = arr[n - 1], hash2[n - 1] = arr[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            pow1[i] = (pow1[i + 1] * 2) % MOD;\\n            pow2[i] = (pow2[i + 1] * 3) % MOD;\\n            hash1[i] = arr[i] * pow1[i] + hash1[i + 1];\\n            hash2[i] = arr[i] * pow2[i] + hash2[i + 1];\\n            hash1[i] %= MOD;\\n            hash2[i] %= MOD;\\n        }       \\n    }\\n    ll hashv1(int i, int j) { // \\n        ll temp = hash1[i];\\n        if (j + 1 < n)\\n            temp = (temp - hash1[j + 1] + MOD) % MOD;\\n        ll temp2 = modpow(2, n - 1 - j);\\n        temp = (temp * modpow(temp2, MOD - 2)) % MOD;\\n        return temp;\\n    }\\n    ll hashv2(int i, int j) {\\n        ll temp = hash2[i];\\n        if (j + 1 < n)\\n            temp = (temp - hash2[j + 1] + MOD) % MOD;\\n        ll temp2 = modpow(3, n - 1 - j);\\n        temp = (temp * modpow(temp2, MOD - 2)) % MOD;\\n        return temp;        \\n    }\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        reverse(arr.begin(), arr.end());\\n        int rem = 0;\\n        while (arr.size() && arr.back() == 0)\\n            arr.pop_back(), rem++;\\n        if (arr.size() == 0) \\n            return {0, rem - 1};\\n        reverse(arr.begin(), arr.end());\\n        n = arr.size();\\n        pow1.resize(n); pow2.resize(n); hash1.resize(n); hash2.resize(n);\\n        pow1[0] = 1, pow2[0] = 1;\\n        set(arr);\\n        unordered_map<int, vector<int>> pref;\\n        for (int i = 0; i < n; i++) \\n            pref[hashv1(0, i)].push_back(i);\\n        vector<int> ans = {-1, -1};\\n        for (int x = n - 1; x >= 0; x--) {\\n            for (auto i: pref[hash1[x]]) {\\n                if (i + 1 >= x) \\n                    break;\\n                ll lefth1 = hash1[x];\\n                ll righth1 = hash1[x];\\n                ll midh1 = hashv1(i + 1, x - 1);\\n                ll lefth2 = hashv2(0, i);\\n                ll righth2 = hash2[x];\\n                ll midh2 = hashv2(i + 1, x - 1);\\n                if (lefth1 == midh1 && lefth2 == righth2 && lefth2 == midh2) {\\n                    ans = {i + rem, x + rem};\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nInitially, the preceding zeroes in ```arr``` are removed. Let the number of removed zeroes be ```rem```. (The case when the entire array is removed is handled separately.)\\n\\nLet ```n``` be the size of the remaining array.\\n```\\nhash1[n - 1] = arr[n - 1] * (2 ^ 0)\\nhash1[n - 2] = arr[n - 2] * (2 ^ 1) + hash1[n - 1]\\nhash1[n - 3] = arr[n - 3] * (2 ^ 2) + hash1[n - 2]\\n```\\n\\nSimilarly,\\n```\\nhash2[n - 1] = arr[n - 1] * (3 ^ 0)\\nhash2[n - 2] = arr[n - 2] * (3 ^ 1) + hash2[n - 1]\\nhash2[n - 3] = arr[n - 3] * (3 ^ 2) + hash2[n - 2]\\n```\\n\\n``` hashv1(int i, int j) ``` returns the hash of the subarrary ```[i..j]``` with base ```2```.\\n``` hashv2(int i, int j) ``` returns the hash of the subarrary ```[i..j]``` with base ```3```.\\n\\nif  ```hashv1(0, i) = x, pref[x]``` contains ```i```, i.e, ```pref[x]``` contains all the prefixes which has hash value ```x```.\\n\\nIf the answer exists, the array can be broken down into three parts, i.e ```[0, i] [i + 1, x - 1] [x, n - 1]```.\\n\\nWe iterate over the suffices, i.e ```[x, n - 1]```, let us say, the ```hash1[x] = righth1```, now for every ```x```, we iterate over the prefixes which has hash with base ```2``` as ```h```. Now using ```hashv1(int i, int j)```, we find the hash value of the subarray ```[i + 1, x - 1]```, let us say, this value is ```midh1```.\\n\\nIf ```lefth1 == midh1 == righth1```. The pair ```{i + rem, x + rem}```(because we have removed few zeroes in the beginning, we have to add rem to compensate) is possibly a solution. But we may get false positives, due to hash collisions. Hence, we use another hash with ```base 3``` and repeat the above process to validate the pair.\\n",
                "solutionTags": [],
                "code": "``` \\n#define ll long long\\nclass Solution {\\n    int n;\\n    vector<ll> pow1, pow2, hash1, hash2;\\n    const int MOD = 1e9 + 7;\\n    ll modpow(ll n, ll p) {\\n        if (p == 0) return 1;\\n        ll x = modpow(n, p / 2);\\n        x = (x * x) % MOD;\\n        if (p % 2)  x = (x * n) % MOD;\\n        return x;\\n    }\\n    void set(vector<int>& arr) {\\n        pow1[n - 1] = 1, pow2[n - 1] = 1, hash1[n - 1] = arr[n - 1], hash2[n - 1] = arr[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            pow1[i] = (pow1[i + 1] * 2) % MOD;\\n            pow2[i] = (pow2[i + 1] * 3) % MOD;\\n            hash1[i] = arr[i] * pow1[i] + hash1[i + 1];\\n            hash2[i] = arr[i] * pow2[i] + hash2[i + 1];\\n            hash1[i] %= MOD;\\n            hash2[i] %= MOD;\\n        }       \\n    }\\n    ll hashv1(int i, int j) { // \\n        ll temp = hash1[i];\\n        if (j + 1 < n)\\n            temp = (temp - hash1[j + 1] + MOD) % MOD;\\n        ll temp2 = modpow(2, n - 1 - j);\\n        temp = (temp * modpow(temp2, MOD - 2)) % MOD;\\n        return temp;\\n    }\\n    ll hashv2(int i, int j) {\\n        ll temp = hash2[i];\\n        if (j + 1 < n)\\n            temp = (temp - hash2[j + 1] + MOD) % MOD;\\n        ll temp2 = modpow(3, n - 1 - j);\\n        temp = (temp * modpow(temp2, MOD - 2)) % MOD;\\n        return temp;        \\n    }\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        reverse(arr.begin(), arr.end());\\n        int rem = 0;\\n        while (arr.size() && arr.back() == 0)\\n            arr.pop_back(), rem++;\\n        if (arr.size() == 0) \\n            return {0, rem - 1};\\n        reverse(arr.begin(), arr.end());\\n        n = arr.size();\\n        pow1.resize(n); pow2.resize(n); hash1.resize(n); hash2.resize(n);\\n        pow1[0] = 1, pow2[0] = 1;\\n        set(arr);\\n        unordered_map<int, vector<int>> pref;\\n        for (int i = 0; i < n; i++) \\n            pref[hashv1(0, i)].push_back(i);\\n        vector<int> ans = {-1, -1};\\n        for (int x = n - 1; x >= 0; x--) {\\n            for (auto i: pref[hash1[x]]) {\\n                if (i + 1 >= x) \\n                    break;\\n                ll lefth1 = hash1[x];\\n                ll righth1 = hash1[x];\\n                ll midh1 = hashv1(i + 1, x - 1);\\n                ll lefth2 = hashv2(0, i);\\n                ll righth2 = hash2[x];\\n                ll midh2 = hashv2(i + 1, x - 1);\\n                if (lefth1 == midh1 && lefth2 == righth2 && lefth2 == midh2) {\\n                    ans = {i + rem, x + rem};\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```arr```\n```rem```\n```n```\n```\\nhash1[n - 1] = arr[n - 1] * (2 ^ 0)\\nhash1[n - 2] = arr[n - 2] * (2 ^ 1) + hash1[n - 1]\\nhash1[n - 3] = arr[n - 3] * (2 ^ 2) + hash1[n - 2]\\n```\n```\\nhash2[n - 1] = arr[n - 1] * (3 ^ 0)\\nhash2[n - 2] = arr[n - 2] * (3 ^ 1) + hash2[n - 1]\\nhash2[n - 3] = arr[n - 3] * (3 ^ 2) + hash2[n - 2]\\n```\n``` hashv1(int i, int j) ```\n```[i..j]```\n```2```\n``` hashv2(int i, int j) ```\n```[i..j]```\n```3```\n```hashv1(0, i) = x, pref[x]```\n```i```\n```pref[x]```\n```x```\n```[0, i] [i + 1, x - 1] [x, n - 1]```\n```[x, n - 1]```\n```hash1[x] = righth1```\n```x```\n```2```\n```h```\n```hashv1(int i, int j)```\n```[i + 1, x - 1]```\n```midh1```\n```lefth1 == midh1 == righth1```\n```{i + rem, x + rem}```\n```base 3```",
                "codeTag": "Java"
            },
            {
                "id": 2018713,
                "title": "java-constant-space",
                "content": "```\\n\\t\\tint n = arr.length;\\n        \\n        int oneCount = 0;\\n        for(int i : arr)\\n            if(i == 1)\\n                oneCount++;\\n        \\n// Base exit condition if the one\\'s in array are even then partion is not possible\\n        if(oneCount % 3 != 0)\\n            return new int[]{-1, -1};\\n        if(oneCount == 0)\\n            return new int[]{0, n - 1};\\n\\n// Initializing the values of i123, j123 with help of \"k\"\\n        int k = oneCount / 3;\\n        int i1 = -1, i2 = -1, i3 = -1, j1 = -1, j2 = -1, j3 = -1;\\n        int currCount = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1){\\n                currCount += 1;\\n                if(currCount == 1) i1 = i;\\n                if(currCount == (k+1)) i2 = i;\\n                if(currCount == (2*k+1)) i3 = i;\\n                \\n                if(currCount == k) j1 = i;\\n                if(currCount == (2*k)) j2 = i;\\n                if(currCount == (3*k)) j3 = i;\\n            }\\n        }\\n        \\n        int start = i1, mid = i2,end = i3;\\n        while(k-- > 0 && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n\\n        if(k >= 0) return new int[]{-1,-1};\\n        \\n// Take care of trailing zeros\\n        \\n        int first = i2-j1-1;\\n        int second = i3-j2-1;\\n        int third = n-j3-1;\\n        \\n        if(third > Math.min(first, second))\\n            return new int[] {-1, -1};\\n        \\n        return new int[] {j1 + third, j2 + third + 1};\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint n = arr.length;\\n        \\n        int oneCount = 0;\\n        for(int i : arr)\\n            if(i == 1)\\n                oneCount++;\\n        \\n// Base exit condition if the one\\'s in array are even then partion is not possible\\n        if(oneCount % 3 != 0)\\n            return new int[]{-1, -1};\\n        if(oneCount == 0)\\n            return new int[]{0, n - 1};\\n\\n// Initializing the values of i123, j123 with help of \"k\"\\n        int k = oneCount / 3;\\n        int i1 = -1, i2 = -1, i3 = -1, j1 = -1, j2 = -1, j3 = -1;\\n        int currCount = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1){\\n                currCount += 1;\\n                if(currCount == 1) i1 = i;\\n                if(currCount == (k+1)) i2 = i;\\n                if(currCount == (2*k+1)) i3 = i;\\n                \\n                if(currCount == k) j1 = i;\\n                if(currCount == (2*k)) j2 = i;\\n                if(currCount == (3*k)) j3 = i;\\n            }\\n        }\\n        \\n        int start = i1, mid = i2,end = i3;\\n        while(k-- > 0 && arr[start] == arr[mid] && arr[mid] == arr[end]){\\n            start++;\\n            mid++;\\n            end++;\\n        }\\n\\n        if(k >= 0) return new int[]{-1,-1};\\n        \\n// Take care of trailing zeros\\n        \\n        int first = i2-j1-1;\\n        int second = i3-j2-1;\\n        int third = n-j3-1;\\n        \\n        if(third > Math.min(first, second))\\n            return new int[] {-1, -1};\\n        \\n        return new int[] {j1 + third, j2 + third + 1};\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977666,
                "title": "python-o-nlogn-prefix-and-binary-search",
                "content": "```\\nfrom bisect import bisect\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        if 1 not in arr: return [0,2]\\n        if Counter(arr)[1] < 3: return [-1, -1]\\n        n = len(arr)\\n        prefix = [0] * (n + 1)\\n        pow2 = [1] * (n + 1)\\n        for i in range(1, n + 1): pow2[i] = pow2[i - 1] * 2\\n        for i in range(n): prefix[i + 1] = prefix[i] * 2 + arr[i]\\n        cur = 0\\n        for j in range(n - 1, 1, -1):\\n            cur += arr[j] * pow2[n - 1 - j]\\n            if cur == 0: continue\\n            i = bisect(prefix, cur) - 1\\n            if i >= j: break\\n            if i > 0 and prefix[i] == cur and prefix[j] - prefix[i] * pow2[j - i] == cur: return [i - 1, j] \\n        return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        if 1 not in arr: return [0,2]\\n        if Counter(arr)[1] < 3: return [-1, -1]\\n        n = len(arr)\\n        prefix = [0] * (n + 1)\\n        pow2 = [1] * (n + 1)\\n        for i in range(1, n + 1): pow2[i] = pow2[i - 1] * 2\\n        for i in range(n): prefix[i + 1] = prefix[i] * 2 + arr[i]\\n        cur = 0\\n        for j in range(n - 1, 1, -1):\\n            cur += arr[j] * pow2[n - 1 - j]\\n            if cur == 0: continue\\n            i = bisect(prefix, cur) - 1\\n            if i >= j: break\\n            if i > 0 and prefix[i] == cur and prefix[j] - prefix[i] * pow2[j - i] == cur: return [i - 1, j] \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936489,
                "title": "c-easy-to-understand-simple-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sum=accumulate(arr.begin(),arr.end(),0);\\n        int n=arr.size();\\n        if(sum==0)\\n        return {0,n-1};\\n        if(sum%3!=0)\\n        return {-1,-1};\\n        int x=sum/3;\\n     \\n        int ones=0;\\n        vector<int> right,left,mid;\\n        int b=n-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            right.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n                \\n            }\\n            if(ones==x)\\n            {\\n                b=i;\\n                break;    \\n            }\\n        }\\n        \\n        reverse(right.begin(),right.end());\\n        bool ok=true;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ok&&arr[i]==0)\\n            {\\n                continue;\\n            }\\n            ok=false;\\n            left.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n            }\\n            if(left.size()==right.size())\\n            {\\n                a=i;\\n                break;    \\n            }\\n        }\\n        \\n        if(left!=right)\\n        return {-1,-1};\\n        \\n        ok=true;\\n        for(int i=a+1;i<b;i++)\\n        {\\n            if(ok&&arr[i]==0)\\n            {\\n                continue;\\n            }\\n            ok=false;\\n            mid.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n            }\\n            if(mid.size()==right.size())\\n            {\\n                b=i;\\n                break;    \\n            }\\n        }\\n        if(mid!=right)\\n        return {-1,-1};\\n        \\n        return {a,b+1};\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sum=accumulate(arr.begin(),arr.end(),0);\\n        int n=arr.size();\\n        if(sum==0)\\n        return {0,n-1};\\n        if(sum%3!=0)\\n        return {-1,-1};\\n        int x=sum/3;\\n     \\n        int ones=0;\\n        vector<int> right,left,mid;\\n        int b=n-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            right.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n                \\n            }\\n            if(ones==x)\\n            {\\n                b=i;\\n                break;    \\n            }\\n        }\\n        \\n        reverse(right.begin(),right.end());\\n        bool ok=true;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ok&&arr[i]==0)\\n            {\\n                continue;\\n            }\\n            ok=false;\\n            left.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n            }\\n            if(left.size()==right.size())\\n            {\\n                a=i;\\n                break;    \\n            }\\n        }\\n        \\n        if(left!=right)\\n        return {-1,-1};\\n        \\n        ok=true;\\n        for(int i=a+1;i<b;i++)\\n        {\\n            if(ok&&arr[i]==0)\\n            {\\n                continue;\\n            }\\n            ok=false;\\n            mid.push_back(arr[i]);\\n            if(arr[i]==1)\\n            {\\n                ones++;\\n            }\\n            if(mid.size()==right.size())\\n            {\\n                b=i;\\n                break;    \\n            }\\n        }\\n        if(mid!=right)\\n        return {-1,-1};\\n        \\n        return {a,b+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882345,
                "title": "python-sol-linear-time-explained-approach-explained-well",
                "content": "# EXPLANATION\\n```\\nWe need to divide the array into 3 subarrays such that the binary value of each of subarray is same\\n\\nNow : 001100 represents 12 and 1100 represents 12 too !\\nThe point is since leading zeroes are allowed , two binary numbers can have different number of zeroes yet they can be equal\\nBut for two binary numbers to be equal they must have equal number of 1\\'s\\n\\nSo , in all three parts of array the number of 1\\'s must be equal\\n\\nFind total number of 1\\'s in array \\nIf count_one % 3!=0 : we can never split the 1\\'s equally hence ans is [-1,-1]\\nelse : we know that in every part we will have exactly count_one/3 no of 1\\'s\\n\\nNow let\\'s traverse the array and count no of 1\\'s\\nOur target T== count_one/3\\nwe will count as\\n1 , ... , T , T+1 , .... , 2T , ..... , 2T+1 , ..... , 3T .....\\nThe point is \\n    1.  First subarray will start from count = 1 and may end at count = T\\n    2.  Second subarray may start from count = T+1 and may end at 2T\\n    3.  Third subarray may start from count = 2T+1 and will may end at 3T\\n    \\n\\t\\n\\tHere I haven\\'t thought about the ending zeroes \\n\\tlike if our binary num is [1 , 0 , 1 , 0 , 1 , 0 , 0]\\n\\tand my target t = 3\\n\\tI will say that my part1 is start from index 0 and ends at index 4 i.e. [ 1 , 0 , 1 , 0 , 1 ] \\n\\tThe remaining [0,0] we don\\'t know if these are leading zeroes for part 2 or trailing zeroes    for part 1\\n\\t\\nFirst we find the parts starting and ending \\nstarting = [ 1 , t+1 , 2*t+1]\\nending =  [t , 2* t , 3*t]\\nhere t = no of zeroes in one part\\n\\nLet\\'s say we get our indexes as [i1,j1] , [i2,j2] , [i3,j3]\\nNow the item without the confusion of trailing zeroes or leading zeroes should be equal i,e,\\narr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]\\n\\nSo we will have this confusion of either trailing zeroes or leading zeroes between\\n(part1 and part2) and (part2 and part3) say x and y\\n\\nSince zeroes after part 3 can only be trailing zero say z so,\\nx and y should never be less than z else we can\\'t divide equally\\n\\nFinally our ans will be \\n[ j1 + z , j2 + z + 1]\\n\\n\\n```\\n\\n# CODE\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        count_one = arr.count(1)\\n        if count_one == 0: return [0,n-1]\\n        if count_one % 3!= 0: return [-1,-1]\\n        target_ones = count_one // 3\\n        breaks = []\\n        one_count = 0\\n        for i , bit in enumerate(arr):\\n            if bit ==1 :\\n                one_count +=1\\n                if one_count in [1,target_ones+1,2*target_ones+1]:breaks.append(i)   \\n                if one_count in [target_ones,2*target_ones,3*target_ones]:breaks.append(i)\\n        i1,j1,i2,j2,i3,j3 = breaks\\n        \\n        if not arr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]:return [-1,-1]\\n        \\n        trailing_zeroes_left  = i2 - j1 - 1\\n        trailing_zeroes_mid   = i3 - j2 - 1\\n        trailing_zeroes_right = n -  j3 - 1\\n        if trailing_zeroes_right > min(trailing_zeroes_left,trailing_zeroes_mid):return [-1,-1]\\n        j1 += trailing_zeroes_right\\n        j2 += trailing_zeroes_right\\n        return [j1,j2+1]\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nWe need to divide the array into 3 subarrays such that the binary value of each of subarray is same\\n\\nNow : 001100 represents 12 and 1100 represents 12 too !\\nThe point is since leading zeroes are allowed , two binary numbers can have different number of zeroes yet they can be equal\\nBut for two binary numbers to be equal they must have equal number of 1\\'s\\n\\nSo , in all three parts of array the number of 1\\'s must be equal\\n\\nFind total number of 1\\'s in array \\nIf count_one % 3!=0 : we can never split the 1\\'s equally hence ans is [-1,-1]\\nelse : we know that in every part we will have exactly count_one/3 no of 1\\'s\\n\\nNow let\\'s traverse the array and count no of 1\\'s\\nOur target T== count_one/3\\nwe will count as\\n1 , ... , T , T+1 , .... , 2T , ..... , 2T+1 , ..... , 3T .....\\nThe point is \\n    1.  First subarray will start from count = 1 and may end at count = T\\n    2.  Second subarray may start from count = T+1 and may end at 2T\\n    3.  Third subarray may start from count = 2T+1 and will may end at 3T\\n    \\n\\t\\n\\tHere I haven\\'t thought about the ending zeroes \\n\\tlike if our binary num is [1 , 0 , 1 , 0 , 1 , 0 , 0]\\n\\tand my target t = 3\\n\\tI will say that my part1 is start from index 0 and ends at index 4 i.e. [ 1 , 0 , 1 , 0 , 1 ] \\n\\tThe remaining [0,0] we don\\'t know if these are leading zeroes for part 2 or trailing zeroes    for part 1\\n\\t\\nFirst we find the parts starting and ending \\nstarting = [ 1 , t+1 , 2*t+1]\\nending =  [t , 2* t , 3*t]\\nhere t = no of zeroes in one part\\n\\nLet\\'s say we get our indexes as [i1,j1] , [i2,j2] , [i3,j3]\\nNow the item without the confusion of trailing zeroes or leading zeroes should be equal i,e,\\narr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]\\n\\nSo we will have this confusion of either trailing zeroes or leading zeroes between\\n(part1 and part2) and (part2 and part3) say x and y\\n\\nSince zeroes after part 3 can only be trailing zero say z so,\\nx and y should never be less than z else we can\\'t divide equally\\n\\nFinally our ans will be \\n[ j1 + z , j2 + z + 1]\\n\\n\\n```\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        count_one = arr.count(1)\\n        if count_one == 0: return [0,n-1]\\n        if count_one % 3!= 0: return [-1,-1]\\n        target_ones = count_one // 3\\n        breaks = []\\n        one_count = 0\\n        for i , bit in enumerate(arr):\\n            if bit ==1 :\\n                one_count +=1\\n                if one_count in [1,target_ones+1,2*target_ones+1]:breaks.append(i)   \\n                if one_count in [target_ones,2*target_ones,3*target_ones]:breaks.append(i)\\n        i1,j1,i2,j2,i3,j3 = breaks\\n        \\n        if not arr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]:return [-1,-1]\\n        \\n        trailing_zeroes_left  = i2 - j1 - 1\\n        trailing_zeroes_mid   = i3 - j2 - 1\\n        trailing_zeroes_right = n -  j3 - 1\\n        if trailing_zeroes_right > min(trailing_zeroes_left,trailing_zeroes_mid):return [-1,-1]\\n        j1 += trailing_zeroes_right\\n        j2 += trailing_zeroes_right\\n        return [j1,j2+1]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861788,
                "title": "c-o-n-2solution-without-while-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        \\n        int size = arr.size();\\n        int total_ones = 0;\\n        int start_first = 0, start_second, start_third;\\n        int count_ones = 0;\\n        int index_finder;\\n        std::vector<int> ones_indexs;\\n        ones_indexs.reserve(size);\\n        \\n        for(; start_first < size; ++start_first)\\n        {\\n            if(arr[start_first] == 1)\\n            {\\n               break; // get start first part for comparison(leading 0s are not relevant)\\n            }\\n        }\\n        \\n        for(int i = start_first; i < size; ++i)\\n        {\\n            if(arr[i] == 1) //count all 1s and store their indicies \\n            {\\n               total_ones++; \\n               ones_indexs.emplace_back(i);\\n            }\\n        }\\n        \\n        //checks if three non-empty parts are possible\\n        if(total_ones%3 != 0){return {-1,-1};}\\n        \\n        if(total_ones == 0){ return {0, size-1};}//only zeros in arr     \\n        \\n        int one_part_ones = total_ones/3;\\n        \\n        //Alternativly we can find the start of third and second ==> we dont need to store the indicies \"ones_indexs\"\\n        //find third length\\n        /*\\n        for(index_finder = size-1; index_finder > 0; --index_finder)\\n        {\\n            if(arr[index_finder] == 1)\\n            {\\n               count_ones++;\\n                if(count_ones == one_part_ones)\\n                {\\n                    //found \\n                    start_third = index_finder;\\n                    break;\\n                }\\n            }\\n        }\\n        --index_finder;//go to the next step\\n        count_ones = 0;\\n     \\n        for(; index_finder > 0; --index_finder)\\n        {\\n            if(arr[index_finder] == 1)\\n            {\\n                count_ones++;\\n                if(count_ones == one_part_ones)\\n                {\\n                    //found \\n                    start_second = index_finder;\\n                    break;\\n                }\\n            }\\n        }\\n        */\\n        \\n        \\n        // get start second part for comparison(leading 0s are not relevant)\\n        start_second = ones_indexs.at(one_part_ones);\\n        // get start third part for comparison(leading 0s are not relevant) \\n        start_third = ones_indexs.at(one_part_ones + one_part_ones);\\n        \\n        //length of comparison is determined of the third part length(without leading 0s)\\n        int length = (size-start_third);\\n        \\n        //we can calculate the first and second delimiter\\n        //but we dont know if the 1s having the same position\\n        int first_delimiter = start_first+length-1, second_delimiter =  start_second + length;\\n        \\n        \\n        for(; start_third < size; ++start_first, ++start_second, ++start_third )\\n        {\\n            if(arr[start_first] == arr[start_second] && arr[start_first] == arr[start_third])\\n                {\\n                    continue;\\n                }\\n            return {-1,-1};//1s are not the same places \\n        }\\n\\n        \\n        return {first_delimiter,second_delimiter};\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> threeEqualParts(std::vector<int>& arr) {\\n        \\n        int size = arr.size();\\n        int total_ones = 0;\\n        int start_first = 0, start_second, start_third;\\n        int count_ones = 0;\\n        int index_finder;\\n        std::vector<int> ones_indexs;\\n        ones_indexs.reserve(size);\\n        \\n        for(; start_first < size; ++start_first)\\n        {\\n            if(arr[start_first] == 1)\\n            {\\n               break; // get start first part for comparison(leading 0s are not relevant)\\n            }\\n        }\\n        \\n        for(int i = start_first; i < size; ++i)\\n        {\\n            if(arr[i] == 1) //count all 1s and store their indicies \\n            {\\n               total_ones++; \\n               ones_indexs.emplace_back(i);\\n            }\\n        }\\n        \\n        //checks if three non-empty parts are possible\\n        if(total_ones%3 != 0){return {-1,-1};}\\n        \\n        if(total_ones == 0){ return {0, size-1};}//only zeros in arr     \\n        \\n        int one_part_ones = total_ones/3;\\n        \\n        //Alternativly we can find the start of third and second ==> we dont need to store the indicies \"ones_indexs\"\\n        //find third length\\n        /*\\n        for(index_finder = size-1; index_finder > 0; --index_finder)\\n        {\\n            if(arr[index_finder] == 1)\\n            {\\n               count_ones++;\\n                if(count_ones == one_part_ones)\\n                {\\n                    //found \\n                    start_third = index_finder;\\n                    break;\\n                }\\n            }\\n        }\\n        --index_finder;//go to the next step\\n        count_ones = 0;\\n     \\n        for(; index_finder > 0; --index_finder)\\n        {\\n            if(arr[index_finder] == 1)\\n            {\\n                count_ones++;\\n                if(count_ones == one_part_ones)\\n                {\\n                    //found \\n                    start_second = index_finder;\\n                    break;\\n                }\\n            }\\n        }\\n        */\\n        \\n        \\n        // get start second part for comparison(leading 0s are not relevant)\\n        start_second = ones_indexs.at(one_part_ones);\\n        // get start third part for comparison(leading 0s are not relevant) \\n        start_third = ones_indexs.at(one_part_ones + one_part_ones);\\n        \\n        //length of comparison is determined of the third part length(without leading 0s)\\n        int length = (size-start_third);\\n        \\n        //we can calculate the first and second delimiter\\n        //but we dont know if the 1s having the same position\\n        int first_delimiter = start_first+length-1, second_delimiter =  start_second + length;\\n        \\n        \\n        for(; start_third < size; ++start_first, ++start_second, ++start_third )\\n        {\\n            if(arr[start_first] == arr[start_second] && arr[start_first] == arr[start_third])\\n                {\\n                    continue;\\n                }\\n            return {-1,-1};//1s are not the same places \\n        }\\n\\n        \\n        return {first_delimiter,second_delimiter};\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745866,
                "title": "python3-time-complexity-o-n",
                "content": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        aSum = sum(arr)\\n        if aSum % 3 != 0:\\n            return [-1, -1]\\n        \\n        n = len(arr)\\n        if aSum == 0:\\n            return [0, n - 1]\\n        \\n        k = aSum//3\\n        idx = []\\n        cnt = 0 \\n        \\n        for (i, bit) in enumerate(arr):\\n            cnt += 1 if bit == 1 else 0 \\n            if cnt == 1 and bit == 1: \\n                idx.append(i)\\n            if cnt % k == 0:\\n                cnt = 0\\n        \\n\\t\\tj = 0 \\n        while idx[2] + j < n and arr[idx[0] + j] == arr[idx[1] + j] == arr[idx[2] + j]:\\n            j += 1 \\n            \\n        if idx[2] + j < n: \\n            return [-1, -1]\\n        else: \\n            return (idx[0] + j - 1, idx[1] + j)        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        aSum = sum(arr)\\n        if aSum % 3 != 0:\\n            return [-1, -1]\\n        \\n        n = len(arr)\\n        if aSum == 0:\\n            return [0, n - 1]\\n        \\n        k = aSum//3\\n        idx = []\\n        cnt = 0 \\n        \\n        for (i, bit) in enumerate(arr):\\n            cnt += 1 if bit == 1 else 0 \\n            if cnt == 1 and bit == 1: \\n                idx.append(i)\\n            if cnt % k == 0:\\n                cnt = 0\\n        \\n\\t\\tj = 0 \\n        while idx[2] + j < n and arr[idx[0] + j] == arr[idx[1] + j] == arr[idx[2] + j]:\\n            j += 1 \\n            \\n        if idx[2] + j < n: \\n            return [-1, -1]\\n        else: \\n            return (idx[0] + j - 1, idx[1] + j)        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716915,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        total1Count = 0\\n        for i in range(len(arr)): \\n            if arr[i] == 1: total1Count += 1\\n        \\n        if (total1Count % 3 != 0): return [-1, -1]\\n\\n        max1OfPart = total1Count // 3\\n        mIdx = [0, 1, 2, 0] # last one is dummy for reducing if statements, not used\\n        addIdx = 0\\n        partCount = 0\\n        \\n        # find 3 appropriate indices (first 3 elements of mIdx) \\n        for i in range(len(arr)):\\n            if (arr[i] == 1):\\n                mIdx[addIdx] = i\\n                partCount += 1\\n                \\n                if (partCount == max1OfPart):\\n                    addIdx += 1\\n                    mIdx[addIdx] = mIdx[addIdx - 1] + 1\\n                    partCount = 0\\n                    \\n            elif (arr[i] == 0 and addIdx == 3): # push indices with trailing zeros\\n                mIdx[0] += 1\\n                mIdx[1] += 1\\n                mIdx[2] += 1\\n                \\n                if (arr[mIdx[0]] == 1 or arr[mIdx[1]] == 1): return [-1, -1] # check if any part steps on the others, return [-1, -1] when it happens\\n        \\n        r = [mIdx[0], mIdx[1] + 1]\\n        \\n        # Verify parts having same value\\n        while mIdx[0] >= 0 and mIdx[1] > r[0] and mIdx[2] >= r[1]:            \\n            if (arr[mIdx[0]] != arr[mIdx[2]] or arr[mIdx[1]] != arr[mIdx[2]]): return [-1, -1]\\n            mIdx = [mIdx[i] - 1 for i in range(3)]\\n        \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        total1Count = 0\\n        for i in range(len(arr)): \\n            if arr[i] == 1: total1Count += 1\\n        \\n        if (total1Count % 3 != 0): return [-1, -1]\\n\\n        max1OfPart = total1Count // 3\\n        mIdx = [0, 1, 2, 0] # last one is dummy for reducing if statements, not used\\n        addIdx = 0\\n        partCount = 0\\n        \\n        # find 3 appropriate indices (first 3 elements of mIdx) \\n        for i in range(len(arr)):\\n            if (arr[i] == 1):\\n                mIdx[addIdx] = i\\n                partCount += 1\\n                \\n                if (partCount == max1OfPart):\\n                    addIdx += 1\\n                    mIdx[addIdx] = mIdx[addIdx - 1] + 1\\n                    partCount = 0\\n                    \\n            elif (arr[i] == 0 and addIdx == 3): # push indices with trailing zeros\\n                mIdx[0] += 1\\n                mIdx[1] += 1\\n                mIdx[2] += 1\\n                \\n                if (arr[mIdx[0]] == 1 or arr[mIdx[1]] == 1): return [-1, -1] # check if any part steps on the others, return [-1, -1] when it happens\\n        \\n        r = [mIdx[0], mIdx[1] + 1]\\n        \\n        # Verify parts having same value\\n        while mIdx[0] >= 0 and mIdx[1] > r[0] and mIdx[2] >= r[1]:            \\n            if (arr[mIdx[0]] != arr[mIdx[2]] or arr[mIdx[1]] != arr[mIdx[2]]): return [-1, -1]\\n            mIdx = [mIdx[i] - 1 for i in range(3)]\\n        \\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1666617,
                "title": "3-equal-parts-beats-98-c-o-n",
                "content": "\\nTime complexity=O(n);\\nSpace complexity=O(1);\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n                c++;\\n        }\\n        if(c%3!=0)return v;\\n        if(c==0)return {0,2}; //can make split from anywhere. this is in case we have 3 size of given array\\n        \\n        int idx=-1;\\n        int cnt=0;\\n        // start counting c/3 1s from back,so that we can make 3 equal parts\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n            if(cnt==c/3)\\n            {  idx=i;\\n             break;}\\n            \\n        }\\n        int front=0;  // ignoring leading 0s\\n        while(arr[front]==0)\\n            front++;\\n        \\n        int strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n        if(strt!=n)return v;\\n        int frststrt=front-1;\\n        while(arr[front]==0)front++;\\n        strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n         if(strt!=n)return v;\\n        return {frststrt,front};\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int c=0;\\n        vector<int> v={-1,-1};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n                c++;\\n        }\\n        if(c%3!=0)return v;\\n        if(c==0)return {0,2}; //can make split from anywhere. this is in case we have 3 size of given array\\n        \\n        int idx=-1;\\n        int cnt=0;\\n        // start counting c/3 1s from back,so that we can make 3 equal parts\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==1)\\n                cnt++;\\n            if(cnt==c/3)\\n            {  idx=i;\\n             break;}\\n            \\n        }\\n        int front=0;  // ignoring leading 0s\\n        while(arr[front]==0)\\n            front++;\\n        \\n        int strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n        if(strt!=n)return v;\\n        int frststrt=front-1;\\n        while(arr[front]==0)front++;\\n        strt=idx;\\n        while(strt<n && arr[front]==arr[strt]){\\n            front++;\\n            strt++;\\n        }\\n         if(strt!=n)return v;\\n        return {frststrt,front};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652547,
                "title": "o-n-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int one=0,zero=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)zero++;\\n            else one++;\\n        }\\n        if(one%3!=0)return {-1,-1};\\n        if(zero==arr.size())return{0,2};\\n        int curr=0;\\n        string start=\"\",end=\"\",mid=\"\";\\n        int first;\\n        int i=n-1;\\n        while(curr!=(one/3)){\\n            if(arr[i]==1){\\n                curr++;\\n            }\\n            end+=to_string(arr[i]);\\n            i--;\\n        }\\n        reverse(end.begin(),end.end());\\n        i=0;\\n        while(start.size()<end.size()){\\n            if(arr[i]==1){\\n                while(start.size()<end.size()){\\n                    start+=to_string(arr[i]);\\n                    i++;\\n                }\\n            }\\n            if(start.size()<end.size())i++;\\n        }\\n        first=i-1;\\n        if(start!=end)return {-1,-1};\\n        while(mid.size()<start.size()){\\n            if(arr[i]==1){\\n                while(mid.size()<end.size()){\\n                    mid+=to_string(arr[i]);\\n                    i++;\\n                }\\n            }\\n            if(mid.size()<end.size())i++;\\n        }\\n        if(start==mid)return {first,i};\\n        else return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n=arr.size();\\n        int one=0,zero=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)zero++;\\n            else one++;\\n        }\\n        if(one%3!=0)return {-1,-1};\\n        if(zero==arr.size())return{0,2};\\n        int curr=0;\\n        string start=\"\",end=\"\",mid=\"\";\\n        int first;\\n        int i=n-1;\\n        while(curr!=(one/3)){\\n            if(arr[i]==1){\\n                curr++;\\n            }\\n            end+=to_string(arr[i]);\\n            i--;\\n        }\\n        reverse(end.begin(),end.end());\\n        i=0;\\n        while(start.size()<end.size()){\\n            if(arr[i]==1){\\n                while(start.size()<end.size()){\\n                    start+=to_string(arr[i]);\\n                    i++;\\n                }\\n            }\\n            if(start.size()<end.size())i++;\\n        }\\n        first=i-1;\\n        if(start!=end)return {-1,-1};\\n        while(mid.size()<start.size()){\\n            if(arr[i]==1){\\n                while(mid.size()<end.size()){\\n                    mid+=to_string(arr[i]);\\n                    i++;\\n                }\\n            }\\n            if(mid.size()<end.size())i++;\\n        }\\n        if(start==mid)return {first,i};\\n        else return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571756,
                "title": "o-n-c-with-explanation",
                "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nFirstly, if two parts\\' binary value is equal, the number of 1 of them must be equal. We can iterate the array to get the total count of 1. If it can be divided by 3, then we can\\'t get 3 equal parts. Otherwise, we can get each part\\'s number of 1, which is total_count / 3.\\n\\nHowever, only knowing the number of 1 of each part can\\'t determine the position of each part, for that the leading zero of each part won\\'t contribute to the value of the part. So we don\\'t know the start position of each part when it has leading zeros. However, except for the leading zeros, other zeros in the part will contribute to the value, so these zeros must be the same for each target part. We can iterate the array from right to left, and get the trailing zeros of the last part, which are also the trailing zeros of other two parts. \\n\\nWith the information above, we can iterate the array from left to right, and when we meet total_count / 3 number of 1, we  get enough 1 of the current target part, then we continue to get enough the trailing zeros. If we succeed, let\\'s say the position of enough trailing zeros is called `p`, then [0, p] is the first part we find. We repeat the process above to get the second part, let\\'s say it\\'s `q`.  Finally, we compare if [0, p], [p + 1, q], [q + 1, size - 1] can represent the same value.\\n\\nWe iterate the array several rounds, total time complexity is O(n).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findpos(vector<int>&arr, int last_0, int cnt_1, int start, int& pos) {\\n        int cnt_tmp = 0;\\n        int i = start;\\n        for (; i < arr.size(); i++) {\\n            if (arr[i] == 1)\\n                cnt_tmp++;\\n            \\n            if (cnt_tmp == cnt_1 / 3) {\\n                break;\\n            }\\n        }\\n        \\n \\n        cnt_tmp = 0;\\n        if (last_0 != 0)\\n            i++;\\n        for (; i < arr.size(); i++) {\\n            if (arr[i] == 0) {\\n                cnt_tmp++;\\n            } else {\\n                break;\\n            }\\n            if (cnt_tmp == last_0) {\\n                break;\\n            }\\n        }\\n        if (cnt_tmp != last_0) {\\n            return -1;\\n        }\\n   \\n        pos = i;\\n        return 0;\\n    }\\n    int cmparr(vector<int>&arr, int start1, int end1, int start2, int end2) {\\n        int i = start1;\\n        int j = start2;\\n        while (arr[i] == 0)\\n            i++;\\n        \\n        while (arr[j] == 0)\\n            j++;\\n        \\n        if (end1 - i != end2 - j) {\\n            return -1;\\n        }\\n        for (int k = i; k <= end1; k++) {\\n            if (arr[k] != arr[j + k - i]) {\\n                return -1;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int cnt_1 = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (arr[i] == 1) {\\n                cnt_1++;\\n            }\\n        }\\n        \\n        if (cnt_1 == 0) {\\n            return vector<int>{0, 2};\\n        }\\n        if (cnt_1 % 3) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        int last_0 = 0;\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            if (arr[i] == 1)\\n                break;\\n            \\n            last_0++;\\n        }\\n        \\n\\n        int start = 0;\\n        int ret = findpos(arr, last_0, cnt_1, 0, start);\\n        if (ret != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        int end  = 0;\\n        ret = findpos(arr, last_0, cnt_1, start + 1, end);\\n        if (ret != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        if (cmparr(arr, 0, start, start + 1, end) != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        if (cmparr(arr, start + 1, end, end + 1, arr.size() - 1) != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        return vector<int>{start, end + 1};\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findpos(vector<int>&arr, int last_0, int cnt_1, int start, int& pos) {\\n        int cnt_tmp = 0;\\n        int i = start;\\n        for (; i < arr.size(); i++) {\\n            if (arr[i] == 1)\\n                cnt_tmp++;\\n            \\n            if (cnt_tmp == cnt_1 / 3) {\\n                break;\\n            }\\n        }\\n        \\n \\n        cnt_tmp = 0;\\n        if (last_0 != 0)\\n            i++;\\n        for (; i < arr.size(); i++) {\\n            if (arr[i] == 0) {\\n                cnt_tmp++;\\n            } else {\\n                break;\\n            }\\n            if (cnt_tmp == last_0) {\\n                break;\\n            }\\n        }\\n        if (cnt_tmp != last_0) {\\n            return -1;\\n        }\\n   \\n        pos = i;\\n        return 0;\\n    }\\n    int cmparr(vector<int>&arr, int start1, int end1, int start2, int end2) {\\n        int i = start1;\\n        int j = start2;\\n        while (arr[i] == 0)\\n            i++;\\n        \\n        while (arr[j] == 0)\\n            j++;\\n        \\n        if (end1 - i != end2 - j) {\\n            return -1;\\n        }\\n        for (int k = i; k <= end1; k++) {\\n            if (arr[k] != arr[j + k - i]) {\\n                return -1;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int cnt_1 = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (arr[i] == 1) {\\n                cnt_1++;\\n            }\\n        }\\n        \\n        if (cnt_1 == 0) {\\n            return vector<int>{0, 2};\\n        }\\n        if (cnt_1 % 3) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        int last_0 = 0;\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            if (arr[i] == 1)\\n                break;\\n            \\n            last_0++;\\n        }\\n        \\n\\n        int start = 0;\\n        int ret = findpos(arr, last_0, cnt_1, 0, start);\\n        if (ret != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        int end  = 0;\\n        ret = findpos(arr, last_0, cnt_1, start + 1, end);\\n        if (ret != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        if (cmparr(arr, 0, start, start + 1, end) != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        if (cmparr(arr, start + 1, end, end + 1, arr.size() - 1) != 0) {\\n            return vector<int>{-1, -1};\\n        }\\n        \\n        return vector<int>{start, end + 1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569169,
                "title": "c-o-n-notes",
                "content": "```\\n// The ones should be devided to equel 3 parts\\n// if (ones%3) => {-1,-1}\\n// if (ones==0) => {0,2} (most trivial one)\\n// Find the first one (the highst 1) for each part\\n// The last part should go up to the end of the array\\n// compare the three part if the same, find i, j by the end of part 1 and 2\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int ones = accumulate(arr.begin(), arr.end(), 0);\\n\\n        if (!ones)  return {0,2};\\n        if (ones%3) return {-1,-1};\\n        int x = ones/3;\\n        int j = arr.size();\\n        ones = 0;\\n        while (ones<x) \\n        {\\n            j--;\\n            ones +=arr[j];\\n        }\\n        int k = j;\\n        ones = 0;\\n        while (ones<x) \\n        {\\n            k--;\\n            ones +=arr[k];\\n        }\\n        int i = 0;\\n        while (!arr[i]) i++;\\n        // cout << i << k << j << endl;\\n        while (j<arr.size() && arr[i]==arr[j] && arr[i] == arr[k]) \\n        {\\n            i++; j++; k++;\\n        }\\n        if (j != arr.size()) return {-1,-1};          \\n        return {i-1,k};        \\n    }\\n};\\n// [1,1,1,1,1,1,0,1,1,1]\\n// [0,0,0]\\n// [1,1,1]\\n```",
                "solutionTags": [],
                "code": "```\\n// The ones should be devided to equel 3 parts\\n// if (ones%3) => {-1,-1}\\n// if (ones==0) => {0,2} (most trivial one)\\n// Find the first one (the highst 1) for each part\\n// The last part should go up to the end of the array\\n// compare the three part if the same, find i, j by the end of part 1 and 2\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int ones = accumulate(arr.begin(), arr.end(), 0);\\n\\n        if (!ones)  return {0,2};\\n        if (ones%3) return {-1,-1};\\n        int x = ones/3;\\n        int j = arr.size();\\n        ones = 0;\\n        while (ones<x) \\n        {\\n            j--;\\n            ones +=arr[j];\\n        }\\n        int k = j;\\n        ones = 0;\\n        while (ones<x) \\n        {\\n            k--;\\n            ones +=arr[k];\\n        }\\n        int i = 0;\\n        while (!arr[i]) i++;\\n        // cout << i << k << j << endl;\\n        while (j<arr.size() && arr[i]==arr[j] && arr[i] == arr[k]) \\n        {\\n            i++; j++; k++;\\n        }\\n        if (j != arr.size()) return {-1,-1};          \\n        return {i-1,k};        \\n    }\\n};\\n// [1,1,1,1,1,1,0,1,1,1]\\n// [0,0,0]\\n// [1,1,1]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1434603,
                "title": "java-string-based-solution",
                "content": "There are essentially 3 things to do \\n* Check if the total ones in the array is a multiple of 3\\n* Find out the last index of the first `1` in the last part  ,and check for that suffix in the first and 2nd part of the string\\n* What ever is left over in the mid part of the string after all the matching should contain `0` because that\\'s the part that has to be given to the last part of the string \\n\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        try {\\n            StringBuilder last = new StringBuilder();\\n            int count = 0;\\n            StringBuilder total = new StringBuilder();\\n            for (int num : arr) {\\n                count += (num == 1 ? 1 : 0);\\n                total.append(num);\\n            }\\n            if (count % 3 != 0) {\\n                return new int[]{-1, -1};\\n            }\\n            int curr = 0;\\n            for (int i = arr.length - 1; i >= 0; i--) {\\n                if (arr[i] == 1) {\\n                    curr++;\\n                }\\n                last.insert(0, arr[i]);\\n                if (curr == count / 3) {\\n                    break;\\n                }\\n            }\\n            int lastBegin = total.lastIndexOf(last.toString());\\n            int firstBegin = total.indexOf(last.toString());\\n            if (firstBegin == -1 || firstBegin == lastBegin) {\\n                return new int[]{-1, -1};\\n            }\\n            String mid = total.substring(firstBegin + last.length(), lastBegin);\\n            int midIdx = mid.indexOf(last.toString());\\n            if (midIdx == -1) {\\n                return new int[]{-1, -1};\\n            }\\n            String leftOver = mid.substring(midIdx + last.length());\\n            if (leftOver.contains(\"1\")) {\\n                return new int[]{-1, -1};\\n            }\\n            return new int[]{firstBegin + last.length() - 1, total.length() - last.length() - leftOver.length()};\\n        } catch (StringIndexOutOfBoundsException e) {\\n            return new int[]{-1, -1};\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        try {\\n            StringBuilder last = new StringBuilder();\\n            int count = 0;\\n            StringBuilder total = new StringBuilder();\\n            for (int num : arr) {\\n                count += (num == 1 ? 1 : 0);\\n                total.append(num);\\n            }\\n            if (count % 3 != 0) {\\n                return new int[]{-1, -1};\\n            }\\n            int curr = 0;\\n            for (int i = arr.length - 1; i >= 0; i--) {\\n                if (arr[i] == 1) {\\n                    curr++;\\n                }\\n                last.insert(0, arr[i]);\\n                if (curr == count / 3) {\\n                    break;\\n                }\\n            }\\n            int lastBegin = total.lastIndexOf(last.toString());\\n            int firstBegin = total.indexOf(last.toString());\\n            if (firstBegin == -1 || firstBegin == lastBegin) {\\n                return new int[]{-1, -1};\\n            }\\n            String mid = total.substring(firstBegin + last.length(), lastBegin);\\n            int midIdx = mid.indexOf(last.toString());\\n            if (midIdx == -1) {\\n                return new int[]{-1, -1};\\n            }\\n            String leftOver = mid.substring(midIdx + last.length());\\n            if (leftOver.contains(\"1\")) {\\n                return new int[]{-1, -1};\\n            }\\n            return new int[]{firstBegin + last.length() - 1, total.length() - last.length() - leftOver.length()};\\n        } catch (StringIndexOutOfBoundsException e) {\\n            return new int[]{-1, -1};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357931,
                "title": "java-clean-concise-optimal-code-three-pointer-approach-o-n-time-solution",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        \\n        int ones = 0;\\n        \\n        for (int num : arr) {\\n            ones += num;\\n        }\\n        \\n        if (ones == 0) {\\n            return new int[] {0, 2};\\n        }\\n        else if (ones % 3 != 0) {\\n            return new int[] {-1, -1};\\n        }\\n        \\n        ones /= 3;\\n        int index1 = -1, index2 = -1, index3 = -1, totalOnes = 0;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                continue;\\n            }\\n            \\n            totalOnes += arr[i];\\n            if (totalOnes == 1) {\\n                index1 = i;\\n            }\\n            else if (totalOnes == ones + 1) {\\n                index2 = i;\\n            }\\n            else if (totalOnes == 2 * ones + 1) {\\n                index3 = i;\\n            }\\n        }\\n        \\n        while (index3 < arr.length) {\\n            if (arr[index1] == arr[index3] && arr[index2] == arr[index3]) {\\n                ++index1;\\n                ++index2;\\n                ++index3;\\n            }\\n            else {\\n                return new int[] {-1, -1};\\n            }\\n        }\\n        \\n        return new int[] {index1 - 1, index2};\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        \\n        int ones = 0;\\n        \\n        for (int num : arr) {\\n            ones += num;\\n        }\\n        \\n        if (ones == 0) {\\n            return new int[] {0, 2};\\n        }\\n        else if (ones % 3 != 0) {\\n            return new int[] {-1, -1};\\n        }\\n        \\n        ones /= 3;\\n        int index1 = -1, index2 = -1, index3 = -1, totalOnes = 0;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                continue;\\n            }\\n            \\n            totalOnes += arr[i];\\n            if (totalOnes == 1) {\\n                index1 = i;\\n            }\\n            else if (totalOnes == ones + 1) {\\n                index2 = i;\\n            }\\n            else if (totalOnes == 2 * ones + 1) {\\n                index3 = i;\\n            }\\n        }\\n        \\n        while (index3 < arr.length) {\\n            if (arr[index1] == arr[index3] && arr[index2] == arr[index3]) {\\n                ++index1;\\n                ++index2;\\n                ++index3;\\n            }\\n            else {\\n                return new int[] {-1, -1};\\n            }\\n        }\\n        \\n        return new int[] {index1 - 1, index2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354250,
                "title": "rust-o-n-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {\\n        let mut idxs = vec![];\\n        for i in 0..arr.len() {\\n            if arr[i] == 1 {\\n                idxs.push(i);\\n            }\\n        }\\n        \\n        let n = idxs.len();\\n        if n == 0 {\\n            return vec![0,arr.len() as i32-1];\\n        }\\n        // number of 1s should be divisible by 3\\n        if n % 3 != 0 {\\n            return vec![-1, -1];\\n        }\\n        // find starting indices for each part\\n        let (s0, s1, s2) = (0, n/3, 2*n/3);\\n        // equal gaps between 1\\'s\\n        let (mut i, mut j, mut k) = (s0+1, s1+1, s2+1);\\n        while i < s1 {\\n            let g0 = idxs[i] - idxs[i-1];\\n            let g1 = idxs[j] - idxs[j-1];\\n            let g2 = idxs[k] - idxs[k-1];\\n            if g0 != g1 || g1 != g2 {\\n                return vec![-1, -1];\\n            }\\n            i += 1;\\n            j += 1;\\n            k += 1;\\n        }\\n        // equal trailing 0\\'s\\n        let N = arr.len() - 1;\\n        let trailing_0 = N - idxs[n-1];\\n        if idxs[s1] - idxs[s1-1] <= trailing_0 || idxs[s2] - idxs[s2-1] <= trailing_0 {\\n            return vec![-1, -1];\\n        }\\n        // println!(\"{} {} {}\", idxs[s1], idxs[s2], trailing_0);\\n        vec![\\n            (idxs[s1-1]+trailing_0) as i32,\\n            (idxs[s2-1]+trailing_0+1) as i32,\\n        ]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {\\n        let mut idxs = vec![];\\n        for i in 0..arr.len() {\\n            if arr[i] == 1 {\\n                idxs.push(i);\\n            }\\n        }\\n        \\n        let n = idxs.len();\\n        if n == 0 {\\n            return vec![0,arr.len() as i32-1];\\n        }\\n        // number of 1s should be divisible by 3\\n        if n % 3 != 0 {\\n            return vec![-1, -1];\\n        }\\n        // find starting indices for each part\\n        let (s0, s1, s2) = (0, n/3, 2*n/3);\\n        // equal gaps between 1\\'s\\n        let (mut i, mut j, mut k) = (s0+1, s1+1, s2+1);\\n        while i < s1 {\\n            let g0 = idxs[i] - idxs[i-1];\\n            let g1 = idxs[j] - idxs[j-1];\\n            let g2 = idxs[k] - idxs[k-1];\\n            if g0 != g1 || g1 != g2 {\\n                return vec![-1, -1];\\n            }\\n            i += 1;\\n            j += 1;\\n            k += 1;\\n        }\\n        // equal trailing 0\\'s\\n        let N = arr.len() - 1;\\n        let trailing_0 = N - idxs[n-1];\\n        if idxs[s1] - idxs[s1-1] <= trailing_0 || idxs[s2] - idxs[s2-1] <= trailing_0 {\\n            return vec![-1, -1];\\n        }\\n        // println!(\"{} {} {}\", idxs[s1], idxs[s2], trailing_0);\\n        vec![\\n            (idxs[s1-1]+trailing_0) as i32,\\n            (idxs[s2-1]+trailing_0+1) as i32,\\n        ]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352815,
                "title": "c-o-n-simple-3-pointer-ish-solution",
                "content": "The idea is to split the array into 3 segments - [0, i_], [i_+1, j_] and [j_, n-1] each having the same number of \\'1\\'s. Then, we try to compare the entries in these 3 segments (RHS TO LHS) and ensure they are producing the same binary values. i.e 0011, 011, 11 all have the same values right.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        int i_, j_, numo=0;\\n        \\n        // Find the number of \\'1\\'s in the vector. It has to be divisible by 3 to have a \\n        // valid answer.\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==1){\\n                numo++;\\n            }\\n        }\\n        \\n        if(numo%3 == 0){\\n            \\n            // Case if all the elements of arr are 0 - then just return {0, 2}\\n            if(numo==0){\\n                return {0,2};\\n            }\\n            \\n            // Find the first index i_, and second index j_ each containing a segement\\n            // with re (= numo/3) number of \\'1\\'s.\\n            int re = numo/3, cnt = 0, f = 0;\\n            for(int i=0;i<arr.size();i++){\\n                if(arr[i] == 1){\\n                    cnt++;\\n                    if(cnt == re){\\n                        if(!f)\\n                        {\\n                            i_ = i;\\n                            f = 1;\\n                            cnt = 0;\\n                        }else{\\n                            j_ = i;\\n                            f = 2;\\n                        }\\n                    }\\n                }\\n            }\\n            // So, first segment - [0, i_], second segment - [i_+1, j_], third segment - [j_+1, n-1]\\n            // Of course, each of these 3 segments has exactly re (= numo/3) number of \\'1\\'s.\\n            // Now, we try to manage/equate the number of trailing zeros in these three segments.\\n            // If an overlap takes place while modifying i_, j_ and r - then return {-1, -1} as it \\n            // isn\\'t possible to get 3 segements with same binary values.\\n            int r = n-1;\\n            while(arr[r]==0){\\n                r--;\\n                i_++;\\n                j_++;\\n                if(j_ == r){\\n                    return {-1, -1}; // problem here due to overlap\\n                }\\n            }\\n            int i = i_, j = j_;\\n            r = n-1;\\n            // Now make sure each of the 3 segments have the same value by comparing their\\n            // set bits from the RHS TO LHS...i.e 0010, 010, 10 all have the same values right.\\n            while(i>-1 && j>i_ && r>j_){\\n                if(arr[i]==arr[j] && arr[j]==arr[r]){\\n                    i--;\\n                    j--;\\n                    r--;\\n                }else{\\n                    return {-1, -1}; // If some inequality, return this\\n                }\\n            }\\n            \\n            return {i_, j_+1}; // return the ans\\n            \\n        }else{\\n            // As number of \\'1\\'s in the arr itself is not divisible by 3 - we can\\'t do nothing.\\n            vector<int> ans = {-1, -1};\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        int i_, j_, numo=0;\\n        \\n        // Find the number of \\'1\\'s in the vector. It has to be divisible by 3 to have a \\n        // valid answer.\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==1){\\n                numo++;\\n            }\\n        }\\n        \\n        if(numo%3 == 0){\\n            \\n            // Case if all the elements of arr are 0 - then just return {0, 2}\\n            if(numo==0){\\n                return {0,2};\\n            }\\n            \\n            // Find the first index i_, and second index j_ each containing a segement\\n            // with re (= numo/3) number of \\'1\\'s.\\n            int re = numo/3, cnt = 0, f = 0;\\n            for(int i=0;i<arr.size();i++){\\n                if(arr[i] == 1){\\n                    cnt++;\\n                    if(cnt == re){\\n                        if(!f)\\n                        {\\n                            i_ = i;\\n                            f = 1;\\n                            cnt = 0;\\n                        }else{\\n                            j_ = i;\\n                            f = 2;\\n                        }\\n                    }\\n                }\\n            }\\n            // So, first segment - [0, i_], second segment - [i_+1, j_], third segment - [j_+1, n-1]\\n            // Of course, each of these 3 segments has exactly re (= numo/3) number of \\'1\\'s.\\n            // Now, we try to manage/equate the number of trailing zeros in these three segments.\\n            // If an overlap takes place while modifying i_, j_ and r - then return {-1, -1} as it \\n            // isn\\'t possible to get 3 segements with same binary values.\\n            int r = n-1;\\n            while(arr[r]==0){\\n                r--;\\n                i_++;\\n                j_++;\\n                if(j_ == r){\\n                    return {-1, -1}; // problem here due to overlap\\n                }\\n            }\\n            int i = i_, j = j_;\\n            r = n-1;\\n            // Now make sure each of the 3 segments have the same value by comparing their\\n            // set bits from the RHS TO LHS...i.e 0010, 010, 10 all have the same values right.\\n            while(i>-1 && j>i_ && r>j_){\\n                if(arr[i]==arr[j] && arr[j]==arr[r]){\\n                    i--;\\n                    j--;\\n                    r--;\\n                }else{\\n                    return {-1, -1}; // If some inequality, return this\\n                }\\n            }\\n            \\n            return {i_, j_+1}; // return the ans\\n            \\n        }else{\\n            // As number of \\'1\\'s in the arr itself is not divisible by 3 - we can\\'t do nothing.\\n            vector<int> ans = {-1, -1};\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347377,
                "title": "simple-ruby-solution-with-comments-three-equal-parts",
                "content": "Runtime: 140 ms, faster than 100.00% of Ruby online submissions for Three Equal Parts.\\nMemory Usage: 213.5 MB, less than 100.00% of Ruby online submissions for Three Equal Parts.\\n```\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef three_equal_parts(arr)\\n    num_of_one = arr.sum\\n    return [0, arr.size - 1] if num_of_one.zero?\\n    return [-1, -1] if num_of_one % 3 != 0\\n    first, second = num_of_one / 3, num_of_one * 2 / 3\\n    imp, idx, count_one = [], 0, 0\\n\\t# split by count of ones\\n    while idx < arr.size and count_one < num_of_one\\n        if arr[idx] == 1\\n            case count_one += 1\\n            when first\\n                imp[0] = idx\\n            when second\\n                imp[1] = idx\\n            when num_of_one\\n                imp[2] = idx\\n            end\\n        end\\n        idx += 1\\n    end\\n\\t# the rest zeros\\n    if imp[2] < arr.size - 1\\n        offset = arr.size - 1 - imp[2]\\n        imp[0] += offset\\n        imp[1] += offset\\n        imp[2] = arr.size - 1\\n    end\\n\\t# reduce to strings, convert 0 to space, then remove the heading space with lstrip\\n    splited = [arr[0..imp[0]], arr[(imp[0] + 1)..imp[1]], arr[(imp[1] + 1)..imp[2]]].map do |a|\\n        a.reduce(\\'\\') { |res, n| res << (n.zero? ? \\' \\' : \\'1\\') }.lstrip\\n    end\\n\\t# compare the generated strings\\n    0.upto(splited.size - 2).each { |i| return [-1, -1] if splited[i] != splited[i + 1] }\\n    [imp[0], imp[1] + 1]\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef three_equal_parts(arr)\\n    num_of_one = arr.sum\\n    return [0, arr.size - 1] if num_of_one.zero?\\n    return [-1, -1] if num_of_one % 3 != 0\\n    first, second = num_of_one / 3, num_of_one * 2 / 3\\n    imp, idx, count_one = [], 0, 0\\n\\t# split by count of ones\\n    while idx < arr.size and count_one < num_of_one\\n        if arr[idx] == 1\\n            case count_one += 1\\n            when first\\n                imp[0] = idx\\n            when second\\n                imp[1] = idx\\n            when num_of_one\\n                imp[2] = idx\\n            end\\n        end\\n        idx += 1\\n    end\\n\\t# the rest zeros\\n    if imp[2] < arr.size - 1\\n        offset = arr.size - 1 - imp[2]\\n        imp[0] += offset\\n        imp[1] += offset\\n        imp[2] = arr.size - 1\\n    end\\n\\t# reduce to strings, convert 0 to space, then remove the heading space with lstrip\\n    splited = [arr[0..imp[0]], arr[(imp[0] + 1)..imp[1]], arr[(imp[1] + 1)..imp[2]]].map do |a|\\n        a.reduce(\\'\\') { |res, n| res << (n.zero? ? \\' \\' : \\'1\\') }.lstrip\\n    end\\n\\t# compare the generated strings\\n    0.upto(splited.size - 2).each { |i| return [-1, -1] if splited[i] != splited[i + 1] }\\n    [imp[0], imp[1] + 1]\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1346486,
                "title": "python-o-n-iterative-well-commented-and-recursive",
                "content": "We should see if the next k nodes are available. We then reverse the next k nodes keeping the previous pointer intact to assigs its next pointer to the reversed group starting.\\n\\nIteartive:\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        \\n        # grouping size should be atleast 2\\n        if k < 2:\\n            return head\\n         \\n        # utility method to reverse a part from start before the before pointer\\n        def reverse(start, before):\\n            prev = None\\n            node = start\\n            while node != before:\\n                # doing the reverse\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n            \\n            # after reverse, initial starting point will point to before pointer\\n            start.next = before\\n            return prev\\n        \\n        # starting point\\n        start = head\\n\\n        # pointer prvious to the current group\\n        prev = None\\n        \\n        while True:\\n            # reach one more than the next k nodes\\n            node = start\\n            count = k\\n            while node and count:\\n                node = node.next\\n                count -= 1\\n            \\n            # if less than k nodes are left, stop reversing\\n            if count:\\n                break\\n            \\n            # get the start point of new group\\n            newStart = reverse(start, node)\\n            \\n            if not prev:\\n                # if previous pointer is not set, this is first group\\n                head = newStart\\n            else:\\n                # else, set this group\\'s start as the next of previous\\n                prev.next = newStart\\n            \\n            # set previous to start\\n            prev = start\\n            # set the start to the current node\\n            start = node\\n        \\n        return head\\n```\\n\\nRecursive:\\n```\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if k < 2:\\n            return head\\n         \\n        def reverse(start):\\n            \\n            node = start\\n            left = 0\\n            while node and left < k:\\n                node = node.next\\n                left += 1\\n                \\n            if left < k:\\n                return start\\n            \\n            node = start\\n            nxt = None\\n            prev = None\\n            count = 0\\n            \\n            prev = None\\n            while node and count < k:\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n                count += 1\\n            \\n            start.next = reverse(nxt)\\n            \\n            return prev\\n        \\n        return reverse(head)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        \\n        # grouping size should be atleast 2\\n        if k < 2:\\n            return head\\n         \\n        # utility method to reverse a part from start before the before pointer\\n        def reverse(start, before):\\n            prev = None\\n            node = start\\n            while node != before:\\n                # doing the reverse\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n            \\n            # after reverse, initial starting point will point to before pointer\\n            start.next = before\\n            return prev\\n        \\n        # starting point\\n        start = head\\n\\n        # pointer prvious to the current group\\n        prev = None\\n        \\n        while True:\\n            # reach one more than the next k nodes\\n            node = start\\n            count = k\\n            while node and count:\\n                node = node.next\\n                count -= 1\\n            \\n            # if less than k nodes are left, stop reversing\\n            if count:\\n                break\\n            \\n            # get the start point of new group\\n            newStart = reverse(start, node)\\n            \\n            if not prev:\\n                # if previous pointer is not set, this is first group\\n                head = newStart\\n            else:\\n                # else, set this group\\'s start as the next of previous\\n                prev.next = newStart\\n            \\n            # set previous to start\\n            prev = start\\n            # set the start to the current node\\n            start = node\\n        \\n        return head\\n```\n```\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if k < 2:\\n            return head\\n         \\n        def reverse(start):\\n            \\n            node = start\\n            left = 0\\n            while node and left < k:\\n                node = node.next\\n                left += 1\\n                \\n            if left < k:\\n                return start\\n            \\n            node = start\\n            nxt = None\\n            prev = None\\n            count = 0\\n            \\n            prev = None\\n            while node and count < k:\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n                count += 1\\n            \\n            start.next = reverse(nxt)\\n            \\n            return prev\\n        \\n        return reverse(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345943,
                "title": "three-equal-parts-o-n-simple-approach-solution-java",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ans[] = new int[2];\\n        int count1 = 0;\\n        int n = arr.length;\\n        for(int i : arr){\\n            if(i == 1){\\n                count1++;\\n            }\\n        }\\n        if(count1 == 0){\\n            ans[0] = 0;\\n            ans[1] = n-1;\\n            return ans;\\n        }\\n        if(count1 % 3 != 0){\\n            ans[0] = -1;\\n            ans[1] = -1;\\n            return ans;\\n        }\\n        \\n        int part = count1 / 3;\\n        int i = 0; int j = 0; int k = 0;\\n        boolean flag1 = false, flag2 = false;\\n        int check1 = 0;\\n        for(int p = 0; p < n ; p++){\\n            if(arr[p] == 1){\\n                check1++;\\n            }\\n            if(check1 == 1 && !flag1){\\n                i = p;\\n                flag1 = true;\\n            }else if(check1 == part + 1 && !flag2){\\n                j = p;\\n                flag2 = true;\\n            }else if(check1 == 2 * part + 1){\\n                k = p;\\n                break;\\n            }\\n        }\\n        System.out.println(\"i: \" + i + \" j: \" + j + \" k: \" + k);\\n        int m = j, nn = k;\\n        while(k < n){\\n            if(arr[j] != arr[j] || arr[j] != arr[k] || i >= m || j >= nn){\\n                ans[0] = -1;\\n                ans[1] = -1;\\n                return ans; \\n            }\\n            i++;j++;k++;\\n        }\\n        //System.out.println(\"i: \" + i + \" j: \" + j + \" k: \" + k);\\n        ans[0] = i-1;\\n        ans[1] = j;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int ans[] = new int[2];\\n        int count1 = 0;\\n        int n = arr.length;\\n        for(int i : arr){\\n            if(i == 1){\\n                count1++;\\n            }\\n        }\\n        if(count1 == 0){\\n            ans[0] = 0;\\n            ans[1] = n-1;\\n            return ans;\\n        }\\n        if(count1 % 3 != 0){\\n            ans[0] = -1;\\n            ans[1] = -1;\\n            return ans;\\n        }\\n        \\n        int part = count1 / 3;\\n        int i = 0; int j = 0; int k = 0;\\n        boolean flag1 = false, flag2 = false;\\n        int check1 = 0;\\n        for(int p = 0; p < n ; p++){\\n            if(arr[p] == 1){\\n                check1++;\\n            }\\n            if(check1 == 1 && !flag1){\\n                i = p;\\n                flag1 = true;\\n            }else if(check1 == part + 1 && !flag2){\\n                j = p;\\n                flag2 = true;\\n            }else if(check1 == 2 * part + 1){\\n                k = p;\\n                break;\\n            }\\n        }\\n        System.out.println(\"i: \" + i + \" j: \" + j + \" k: \" + k);\\n        int m = j, nn = k;\\n        while(k < n){\\n            if(arr[j] != arr[j] || arr[j] != arr[k] || i >= m || j >= nn){\\n                ans[0] = -1;\\n                ans[1] = -1;\\n                return ans; \\n            }\\n            i++;j++;k++;\\n        }\\n        //System.out.println(\"i: \" + i + \" j: \" + j + \" k: \" + k);\\n        ans[0] = i-1;\\n        ans[1] = j;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345867,
                "title": "java-binarysearch-presum-approach-concept-100-faster-and-96-8-less-space",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Three Equal Parts.\\nMemory Usage: 43.5 MB, less than 96.08% of Java online submissions for Three Equal Parts.\\n\\n\\nHere i used a presum array i.e the countArray  to keep track of the number of one occured.And checked if the number of ones in the end is a multiple of 3 if yes the i will proceed  if not then i will return {-1,-1} as output and to handle the corner case when the array consist of no ones.\\n\\nNow we know in the 3 parts the number of 1\\'s should be equal so keeping that in mind and we know that 0 before a number does not change the value so we proceed backward.\\n\\nSuppose there are 21 ones in the array so i will search the 15th one position and substract one since i used a presum array of size one greater than the original array.\\nSo now i know the size of the array not containing precedding ones.i.e  arr.length-lastIndex i.e the 15th position in this case.\\n\\nSimilarly i will search the first occurence of the 1 in this array and substract -1.Now i will compare this\\nfirstOccurenceIndex(firstIndex) array with the lastIndex if its not equal i will return {-1,-1} output.\\nelse i will continue.\\n\\nNow the first and the last are equal and not i will search the starting position of the secondArray \\nand in this case also i will not consider preceeding 1.and i will find the position in countArray which is 7 and substract -1 to get the starting position of the secondArray.\\n\\nThen compare with the last array and if its equal and i will update the output and return it.\\n\\n\\nI think i may not be able to make it clear that well .If any one want to explain it easily then please so that it may be helpful to others.\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n     int [] countArray;\\n    public int findBinarySearchIndex(int x){\\n        int low=0;\\n        int high=countArray.length-1;\\n        int mid;\\n        while(low<high){\\n            mid=low+(high-low)/2;\\n            if(countArray[mid]>=x){\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n    public int[] threeEqualParts(int[] arr) {\\n        countArray=new int[arr.length+1];\\n        int [] output=new int[]{-1,-1};\\n        for(int i=0;i<arr.length;i++){\\n            countArray[i+1]=arr[i]+countArray[i];\\n        }\\n        if(countArray[countArray.length-1]%3!=0)\\n            return output;\\n        if(countArray[countArray.length-1]==0){\\n            output[0]=0;\\n            output[1]=arr.length-1;\\n            return output;\\n        }\\n       int lastIndex=findBinarySearchIndex((countArray[countArray.length-1]-(countArray[countArray.length-1]/3))+1)-1;\\n        int firstIndex=findBinarySearchIndex(1)-1; \\n        for(int i=0;i<arr.length-lastIndex;i++){\\n            if(arr[i+firstIndex]!=arr[i+lastIndex]){\\n                return output;\\n            }\\n    \\n        }\\n        int secondIndex=findBinarySearchIndex((countArray[countArray.length-1]/3)+1)-1;\\n        for(int i=0;i<arr.length-lastIndex;i++){\\n            if(arr[i+secondIndex]!=arr[i+lastIndex]){\\n                return output;\\n            }\\n        }\\n        output[0]=firstIndex+(arr.length-lastIndex)-1;\\n        output[1]=secondIndex+arr.length-lastIndex;\\n         return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     int [] countArray;\\n    public int findBinarySearchIndex(int x){\\n        int low=0;\\n        int high=countArray.length-1;\\n        int mid;\\n        while(low<high){\\n            mid=low+(high-low)/2;\\n            if(countArray[mid]>=x){\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n    public int[] threeEqualParts(int[] arr) {\\n        countArray=new int[arr.length+1];\\n        int [] output=new int[]{-1,-1};\\n        for(int i=0;i<arr.length;i++){\\n            countArray[i+1]=arr[i]+countArray[i];\\n        }\\n        if(countArray[countArray.length-1]%3!=0)\\n            return output;\\n        if(countArray[countArray.length-1]==0){\\n            output[0]=0;\\n            output[1]=arr.length-1;\\n            return output;\\n        }\\n       int lastIndex=findBinarySearchIndex((countArray[countArray.length-1]-(countArray[countArray.length-1]/3))+1)-1;\\n        int firstIndex=findBinarySearchIndex(1)-1; \\n        for(int i=0;i<arr.length-lastIndex;i++){\\n            if(arr[i+firstIndex]!=arr[i+lastIndex]){\\n                return output;\\n            }\\n    \\n        }\\n        int secondIndex=findBinarySearchIndex((countArray[countArray.length-1]/3)+1)-1;\\n        for(int i=0;i<arr.length-lastIndex;i++){\\n            if(arr[i+secondIndex]!=arr[i+lastIndex]){\\n                return output;\\n            }\\n        }\\n        output[0]=firstIndex+(arr.length-lastIndex)-1;\\n        output[1]=secondIndex+arr.length-lastIndex;\\n         return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345509,
                "title": "python-o-n-solution",
                "content": "Python:\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        # count number of ones\\n        sum_ = sum(arr)\\n        \\n        # number of ones should be divisible by 3 to be in 3 equal parts\\n        if sum_ % 3:\\n            return [-1, -1]\\n        \\n        # number of ones needed in each part\\n        ones = sum_ // 3\\n        \\n        # if all are zeros, any parition is okay\\n        if ones == 0:\\n            return [0, len(arr) - 1]\\n        \\n        \\n        indices = []\\n        \\n        \\n        #counting number of ones till a point in array\\n        curOnes = 0\\n        for i in range(len(arr)):\\n            if not arr[i]:\\n                continue\\n            curOnes += 1\\n            # if we reach a valid patition\\'s left point\\n            if curOnes in {1, ones + 1, 2 * ones + 1}:\\n                indices.append(i)\\n            # if we reach a valid parition\\'s right point\\n            if curOnes in {ones, 2 * ones, 3 * ones}:\\n                indices.append(i)\\n            \\n        # all points for all parititions\\n        # first - f1, f2\\n        # second - s1, s2\\n        # third - t1, t2\\n        f1, f2, s1, s2, t1, t2 = indices\\n        \\n        # if parititions are not equal, not valid\\n        if arr[f1: f2 + 1] != arr[s1: s2 + 1] or arr[f1: f2 + 1] != arr[t1: t2 + 1]:\\n            return [-1, -1]\\n        \\n        # zeros after each parition\\n        zerosAfterFirst = s1 - f2 - 1\\n        zerosAfterSecond = t1 - s2 - 1\\n        zerosAfterThird = len(arr) - t2 - 1\\n        \\n        # first and second paritions cannot have fewer following zeros than third\\n        if zerosAfterFirst < zerosAfterThird or zerosAfterSecond < zerosAfterThird:\\n            return [-1, -1]\\n        \\n        # add needed zeros to first and second partitions right points\\n        f2 += zerosAfterThird\\n        s2 += zerosAfterThird\\n        \\n        # return valid limits\\n        return [f2, s2 + 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        \\n        # count number of ones\\n        sum_ = sum(arr)\\n        \\n        # number of ones should be divisible by 3 to be in 3 equal parts\\n        if sum_ % 3:\\n            return [-1, -1]\\n        \\n        # number of ones needed in each part\\n        ones = sum_ // 3\\n        \\n        # if all are zeros, any parition is okay\\n        if ones == 0:\\n            return [0, len(arr) - 1]\\n        \\n        \\n        indices = []\\n        \\n        \\n        #counting number of ones till a point in array\\n        curOnes = 0\\n        for i in range(len(arr)):\\n            if not arr[i]:\\n                continue\\n            curOnes += 1\\n            # if we reach a valid patition\\'s left point\\n            if curOnes in {1, ones + 1, 2 * ones + 1}:\\n                indices.append(i)\\n            # if we reach a valid parition\\'s right point\\n            if curOnes in {ones, 2 * ones, 3 * ones}:\\n                indices.append(i)\\n            \\n        # all points for all parititions\\n        # first - f1, f2\\n        # second - s1, s2\\n        # third - t1, t2\\n        f1, f2, s1, s2, t1, t2 = indices\\n        \\n        # if parititions are not equal, not valid\\n        if arr[f1: f2 + 1] != arr[s1: s2 + 1] or arr[f1: f2 + 1] != arr[t1: t2 + 1]:\\n            return [-1, -1]\\n        \\n        # zeros after each parition\\n        zerosAfterFirst = s1 - f2 - 1\\n        zerosAfterSecond = t1 - s2 - 1\\n        zerosAfterThird = len(arr) - t2 - 1\\n        \\n        # first and second paritions cannot have fewer following zeros than third\\n        if zerosAfterFirst < zerosAfterThird or zerosAfterSecond < zerosAfterThird:\\n            return [-1, -1]\\n        \\n        # add needed zeros to first and second partitions right points\\n        f2 += zerosAfterThird\\n        s2 += zerosAfterThird\\n        \\n        # return valid limits\\n        return [f2, s2 + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345460,
                "title": "c-easy-solution-with-bitset",
                "content": "```\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> output;\\n\\n        int left = 0;\\n        int right = arr.size() - 1;\\n\\n        bitset<30001> parts1(arr[0]);\\n        bitset<30001> parts2;\\n        bitset<30001> parts3(arr[arr.size()-1]);\\n\\n        int bitIndex = right-2;\\n        for (int i = left + 1; i < right; ++i) {\\n            parts2.set(bitIndex, arr[i]);\\n            --bitIndex;\\n        }\\n        int part2Cnt = arr.size() - 3;\\n\\n        while (left < right-2) {\\n\\n            if(parts1 == parts3){\\n                if (parts1 == parts2) {\\n                    output.push_back(left);\\n                    output.push_back(right);\\n                    return output;\\n                }\\n                else {\\n                    --right;\\n                    parts3.set(arr.size() - right - 1, arr[right]);\\n                    parts2 = parts2 >> 1;\\n                }\\n            } else if (parts1.count() <= parts3.count()) {\\n                ++left;\\n                parts1 = parts1 << 1;\\n                parts1.set(0, arr[left]);\\n                parts2 = parts2.set(part2Cnt, false);\\n            } else {\\n                --right;\\n                parts3.set(arr.size() - right - 1, arr[right]);\\n                parts2 = parts2 >> 1;\\n            }\\n\\n            --part2Cnt;\\n        }\\n\\n        if (parts1 == parts2 && parts1 == parts3) {\\n            output.push_back(left);\\n            output.push_back(right);\\n            return output;\\n        }\\n\\n        output.push_back(-1);\\n        output.push_back(-1);\\n        return output;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        vector<int> output;\\n\\n        int left = 0;\\n        int right = arr.size() - 1;\\n\\n        bitset<30001> parts1(arr[0]);\\n        bitset<30001> parts2;\\n        bitset<30001> parts3(arr[arr.size()-1]);\\n\\n        int bitIndex = right-2;\\n        for (int i = left + 1; i < right; ++i) {\\n            parts2.set(bitIndex, arr[i]);\\n            --bitIndex;\\n        }\\n        int part2Cnt = arr.size() - 3;\\n\\n        while (left < right-2) {\\n\\n            if(parts1 == parts3){\\n                if (parts1 == parts2) {\\n                    output.push_back(left);\\n                    output.push_back(right);\\n                    return output;\\n                }\\n                else {\\n                    --right;\\n                    parts3.set(arr.size() - right - 1, arr[right]);\\n                    parts2 = parts2 >> 1;\\n                }\\n            } else if (parts1.count() <= parts3.count()) {\\n                ++left;\\n                parts1 = parts1 << 1;\\n                parts1.set(0, arr[left]);\\n                parts2 = parts2.set(part2Cnt, false);\\n            } else {\\n                --right;\\n                parts3.set(arr.size() - right - 1, arr[right]);\\n                parts2 = parts2 >> 1;\\n            }\\n\\n            --part2Cnt;\\n        }\\n\\n        if (parts1 == parts2 && parts1 == parts3) {\\n            output.push_back(left);\\n            output.push_back(right);\\n            return output;\\n        }\\n\\n        output.push_back(-1);\\n        output.push_back(-1);\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345396,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        auto ones = 0;\\n        for(auto bit: arr)\\n            ones+=(bit)?1:0;\\n        if (ones==0) return {0, (int)arr.size()-1};\\n        if (ones%3!=0) return {-1, -1};\\n        int count = 0;\\n        int pos[3][2] = {};\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if (arr[i]==0) continue;\\n            count++;\\n            if (count == 1) pos[0][0] = i;\\n            if (count==ones/3) pos[0][1] = i;\\n            if (count == ones/3+1) pos[1][0] = i;\\n            if (count==ones-ones/3) pos[1][1] = i;\\n            if (count == ones-ones/3+1) pos[2][0] = i;\\n            if (count==ones) pos[2][1] = i;\\n        }\\n        if ((pos[0][1] - pos[0][0]) !=(pos[1][1] - pos[1][0]))\\n            return {-1, -1};\\n        if ((pos[0][1] - pos[0][0]) !=(pos[2][1] - pos[2][0]))\\n            return {-1, -1};\\n        int n = pos[0][1] - pos[0][0]; \\n        for(int i=0;i<=n;i++)\\n        {\\n            if (arr[pos[0][0]+i]!=arr[pos[1][0]+i])  return {-1, -1};\\n            if (arr[pos[0][0]+i]!=arr[pos[2][0]+i])  return {-1, -1};\\n            \\n        }\\n        int postZeros = arr.size()-pos[2][1]-1;\\n        \\n        int end = pos[1][1]+postZeros+1;\\n        if (end>pos[2][0]) return  {-1, -1};\\n        int start =  pos[0][1]+postZeros;\\n        if (start>=pos[1][0]) return  {-1, -1};\\n        \\n        return {start, end};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        auto ones = 0;\\n        for(auto bit: arr)\\n            ones+=(bit)?1:0;\\n        if (ones==0) return {0, (int)arr.size()-1};\\n        if (ones%3!=0) return {-1, -1};\\n        int count = 0;\\n        int pos[3][2] = {};\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if (arr[i]==0) continue;\\n            count++;\\n            if (count == 1) pos[0][0] = i;\\n            if (count==ones/3) pos[0][1] = i;\\n            if (count == ones/3+1) pos[1][0] = i;\\n            if (count==ones-ones/3) pos[1][1] = i;\\n            if (count == ones-ones/3+1) pos[2][0] = i;\\n            if (count==ones) pos[2][1] = i;\\n        }\\n        if ((pos[0][1] - pos[0][0]) !=(pos[1][1] - pos[1][0]))\\n            return {-1, -1};\\n        if ((pos[0][1] - pos[0][0]) !=(pos[2][1] - pos[2][0]))\\n            return {-1, -1};\\n        int n = pos[0][1] - pos[0][0]; \\n        for(int i=0;i<=n;i++)\\n        {\\n            if (arr[pos[0][0]+i]!=arr[pos[1][0]+i])  return {-1, -1};\\n            if (arr[pos[0][0]+i]!=arr[pos[2][0]+i])  return {-1, -1};\\n            \\n        }\\n        int postZeros = arr.size()-pos[2][1]-1;\\n        \\n        int end = pos[1][1]+postZeros+1;\\n        if (end>pos[2][0]) return  {-1, -1};\\n        int start =  pos[0][1]+postZeros;\\n        if (start>=pos[1][0]) return  {-1, -1};\\n        \\n        return {start, end};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345330,
                "title": "c-o-n-without-counting-number-of-ones-explained-with-comments",
                "content": "Idea: For every possible i, we compute j dynamically.\\ndivided the 3 parts as A, B and C.\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(vector<int>& arr, int i, int j, int fNZA, int fNZB, int fNZC) {\\n        int a = fNZA, b = fNZB, c =fNZC;\\n        int x = i, y =j-1, z = arr.size()-1;\\n        while(a <= x) { //here \\'=\\' is needed if the size of the Component\\'s of A, B, C is 1.\\n            if(arr[a] != arr[b] || arr[b]!= arr[c] || arr[x]!= arr[y] || arr[y]!= arr[z])\\n                return false;\\n            a++;b++;c++;--x;--y;--z;\\n        }\\n        return true;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int i=0, j=i+1, n = arr.size();;\\n        int firstNonZeroIndexOfA=0, firstNonZeroIndexOfB=0, firstNonZeroIndexOfC=0;\\n\\t\\t\\n\\t\\t//While reading the code first time ignore this piece.\\n        /*vector<int> countOnes(n, 0);\\n        countOnes[0] = arr[0];\\n        for(int k=1; k<n; ++k) {\\n            if(arr[k]) countOnes[k] = 1+countOnes[k-1];\\n            else countOnes[k] = countOnes[k-1];\\n        }*/\\n\\t\\t\\n        for(;i <= n-3; ++i) {\\n\\t\\t\\t//Compute 1st index in A where element value is one, if all elements in A is zero, firstNonZeroIndexOfA = i;\\n            while(firstNonZeroIndexOfA<i && arr[firstNonZeroIndexOfA] == 0) firstNonZeroIndexOfA++;\\n\\t\\t\\t\\n\\t\\t\\t//Compute 1st index in B where element value is one, if all elements in B is zero, firstNonZeroIndexOfB = n-2;\\n            if(firstNonZeroIndexOfB < i+1)  firstNonZeroIndexOfB = i+1;\\n            while(firstNonZeroIndexOfB<n-2 && arr[firstNonZeroIndexOfB] == 0) firstNonZeroIndexOfB++;\\n            \\n\\t\\t\\t//Now we have to compute \\'j\\' such that, j-firstNonZeroIndexOfB == i-firstNonZeroIndexOfA+1\\n            j = i+firstNonZeroIndexOfB - firstNonZeroIndexOfA +1;\\n            if(j>=n) continue; // if no such \\'j\\' exists\\n\\n\\t\\t\\t//similarly we have to compute firstNonZeroIndexC in component C.\\n            if(firstNonZeroIndexOfC < j)  firstNonZeroIndexOfC = j;\\n            while(firstNonZeroIndexOfC<n-1 && arr[firstNonZeroIndexOfC] == 0) firstNonZeroIndexOfC++;\\n            \\n\\t\\t\\t//size of A = size of B already, now Size of C should be equal to size of B.\\n            if(n-firstNonZeroIndexOfC != j-firstNonZeroIndexOfB) continue;\\n          \\n            //if(countOnes[i] == countOnes[j-1]-countOnes[i] && countOnes[i] == countOnes[n-1] - countOnes[j-1])\\n            if(isMatch(arr, i, j, firstNonZeroIndexOfA, firstNonZeroIndexOfB, firstNonZeroIndexOfC))\\n                return {i, j};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```\\n\\nTime Complexity: \\n\\t\\tThe Amortized time complexity for the three while loops inside the for loops is O(n), as they are not getting initialized everytime, In worst case firstNonZeroIndexOfA grows from 0 to n-3, firstNonZeroIndexOfB grows from 1 to n-2, firstNonZeroIndexOfC grows from 2 to n-1.\\n\\nMore Optimization:\\n\\t\\tBy counting no.of 1\\'s and adding more restriction before calling \\'isMatch\\' function, check my commented code.\\n\\nThis soultion(without counting ones) beated 98.15% c++ solutions with 28ms.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(vector<int>& arr, int i, int j, int fNZA, int fNZB, int fNZC) {\\n        int a = fNZA, b = fNZB, c =fNZC;\\n        int x = i, y =j-1, z = arr.size()-1;\\n        while(a <= x) { //here \\'=\\' is needed if the size of the Component\\'s of A, B, C is 1.\\n            if(arr[a] != arr[b] || arr[b]!= arr[c] || arr[x]!= arr[y] || arr[y]!= arr[z])\\n                return false;\\n            a++;b++;c++;--x;--y;--z;\\n        }\\n        return true;\\n    }\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int i=0, j=i+1, n = arr.size();;\\n        int firstNonZeroIndexOfA=0, firstNonZeroIndexOfB=0, firstNonZeroIndexOfC=0;\\n\\t\\t\\n\\t\\t//While reading the code first time ignore this piece.\\n        /*vector<int> countOnes(n, 0);\\n        countOnes[0] = arr[0];\\n        for(int k=1; k<n; ++k) {\\n            if(arr[k]) countOnes[k] = 1+countOnes[k-1];\\n            else countOnes[k] = countOnes[k-1];\\n        }*/\\n\\t\\t\\n        for(;i <= n-3; ++i) {\\n\\t\\t\\t//Compute 1st index in A where element value is one, if all elements in A is zero, firstNonZeroIndexOfA = i;\\n            while(firstNonZeroIndexOfA<i && arr[firstNonZeroIndexOfA] == 0) firstNonZeroIndexOfA++;\\n\\t\\t\\t\\n\\t\\t\\t//Compute 1st index in B where element value is one, if all elements in B is zero, firstNonZeroIndexOfB = n-2;\\n            if(firstNonZeroIndexOfB < i+1)  firstNonZeroIndexOfB = i+1;\\n            while(firstNonZeroIndexOfB<n-2 && arr[firstNonZeroIndexOfB] == 0) firstNonZeroIndexOfB++;\\n            \\n\\t\\t\\t//Now we have to compute \\'j\\' such that, j-firstNonZeroIndexOfB == i-firstNonZeroIndexOfA+1\\n            j = i+firstNonZeroIndexOfB - firstNonZeroIndexOfA +1;\\n            if(j>=n) continue; // if no such \\'j\\' exists\\n\\n\\t\\t\\t//similarly we have to compute firstNonZeroIndexC in component C.\\n            if(firstNonZeroIndexOfC < j)  firstNonZeroIndexOfC = j;\\n            while(firstNonZeroIndexOfC<n-1 && arr[firstNonZeroIndexOfC] == 0) firstNonZeroIndexOfC++;\\n            \\n\\t\\t\\t//size of A = size of B already, now Size of C should be equal to size of B.\\n            if(n-firstNonZeroIndexOfC != j-firstNonZeroIndexOfB) continue;\\n          \\n            //if(countOnes[i] == countOnes[j-1]-countOnes[i] && countOnes[i] == countOnes[n-1] - countOnes[j-1])\\n            if(isMatch(arr, i, j, firstNonZeroIndexOfA, firstNonZeroIndexOfB, firstNonZeroIndexOfC))\\n                return {i, j};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345310,
                "title": "java-simple-code-with-explanation",
                "content": "**OBSERVATIONS:**\\n\\nBy seeing the question itself and traversing through the example test cases, you\\'ll have couple of observations like:\\n1. If the number of 1\\'s in the array is not multiple of 3, then there is no way it can be equally partioned. Hence, we need to return *{-1, -1}*\\n2. Leading `0\\'s` won\\'t contribute towards the binary number hence can be ignored, and we need to look for very first `1\\'s` for building the algorithm.\\n\\n**CODE:**\\n```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;\\n        List<Integer> ones = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) {\\n                ones.add(i);\\n            }\\n        }\\n        \\n        int countOfOne = ones.size();\\n        \\n        // when all the element of an array is ZERO\\n        if (countOfOne == 0) {\\n            return new int[] {0, n - 1};\\n        }\\n        \\n        // when number of 1\\'s is not in multiple of 3\\n        if (countOfOne % 3 != 0) {\\n            return new int [] {-1, -1};\\n        }\\n        \\n        int ptr1 = ones.get(0); // index of first 1 in first part\\n        int ptr2 = ones.get(countOfOne / 3); // index of first 1 in second part\\n        int ptr3 = ones.get(2 * (countOfOne / 3)); // index of first 1 in third part\\n        \\n                \\n        while (ptr3 < n) {\\n            if (arr[ptr3] == arr[ptr2] && arr[ptr3] == arr[ptr1]) {\\n                ptr1++;\\n                ptr2++;\\n                ptr3++;\\n            } else {\\n                return new int [] {-1, -1};\\n            }\\n        }\\n        \\n        return new int [] {ptr1 - 1, ptr2};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;\\n        List<Integer> ones = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 1) {\\n                ones.add(i);\\n            }\\n        }\\n        \\n        int countOfOne = ones.size();\\n        \\n        // when all the element of an array is ZERO\\n        if (countOfOne == 0) {\\n            return new int[] {0, n - 1};\\n        }\\n        \\n        // when number of 1\\'s is not in multiple of 3\\n        if (countOfOne % 3 != 0) {\\n            return new int [] {-1, -1};\\n        }\\n        \\n        int ptr1 = ones.get(0); // index of first 1 in first part\\n        int ptr2 = ones.get(countOfOne / 3); // index of first 1 in second part\\n        int ptr3 = ones.get(2 * (countOfOne / 3)); // index of first 1 in third part\\n        \\n                \\n        while (ptr3 < n) {\\n            if (arr[ptr3] == arr[ptr2] && arr[ptr3] == arr[ptr1]) {\\n                ptr1++;\\n                ptr2++;\\n                ptr3++;\\n            } else {\\n                return new int [] {-1, -1};\\n            }\\n        }\\n        \\n        return new int [] {ptr1 - 1, ptr2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345287,
                "title": "c-long-but-easy-implementation-explained",
                "content": "The problem looks complicated, but actually very simple.\\n1. count number of 1s.\\n2. If they are 0, return 0, size-1.\\n3. If number of 1s are not divisible by 3, return -1, -1.\\n4. Convert array numbers to string for easy manipulation.\\n5. Start from end, extract string by counting number of 1s that are needed. Reverse it. This is our universal string that we will search two more times.\\n6. Now, start from beginning, generate substring from 0 to i+1 position and search universal string.\\n7. If index is -1, return -1, -1.\\n8. Otherwise, generate another sunstring from index+universal string size to i+1.\\n9. search for universal string in this new substring.\\n10. If index is -1, return -1, -1.\\n11. else find the difference where the universal string ends in this substring. We need to subtract this difference from i+1 position to get our j.\\n12. our i would be initial index+universal string size -1.\\n13. Print some statements in below code to understand more.\\n```\\nvector<int> threeEqualParts(vector<int>& arr) {\\n        int i,j, size, diff, count1s=0,need1s=0;\\n        string str, s, s1, s2;\\n        vector<int> vec;\\n        size = arr.size();\\n       \\n        for(i=0; i<size; i++)\\n        {\\n            if(arr[i]==1)\\n                count1s++;\\n            str.push_back(arr[i]+\\'0\\');\\n        }\\n        if(count1s == 0)\\n            return {0, size-1};\\n        if(count1s%3!=0)\\n            return {-1,-1};\\n        else\\n            need1s = count1s/3;\\n        \\n        count1s=0;\\n        i= size-1;\\n        while(count1s!=need1s)\\n        {\\n            if(arr[i]==1)\\n                count1s++;\\n            s.push_back(arr[i]+\\'0\\');\\n            i--;\\n        }\\n        reverse(s.begin(), s.end());\\n      \\n        s1 = str.substr(0, i+1);\\n        auto index0 = s1.find(s);\\n        if(index0 == -1)\\n            return {-1, -1};\\n        s2 = s1.substr(index0+s.size(), i+1);\\n        auto index1 = s2.find(s);\\n         if(index1 == -1)\\n            return {-1, -1};\\n        diff = s2.size()-(index1+s.size());\\n\\n        vec.push_back(index0+s.size()-1);\\n        vec.push_back(i+1-diff);\\n        return vec;\\n    }\\n```\\nPlease UPVOTE if my approach helped you understand.",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nvector<int> threeEqualParts(vector<int>& arr) {\\n        int i,j, size, diff, count1s=0,need1s=0;\\n        string str, s, s1, s2;\\n        vector<int> vec;\\n        size = arr.size();\\n       \\n        for(i=0; i<size; i++)\\n        {\\n            if(arr[i]==1)\\n                count1s++;\\n            str.push_back(arr[i]+\\'0\\');\\n        }\\n        if(count1s == 0)\\n            return {0, size-1};\\n        if(count1s%3!=0)\\n            return {-1,-1};\\n        else\\n            need1s = count1s/3;\\n        \\n        count1s=0;\\n        i= size-1;\\n        while(count1s!=need1s)\\n        {\\n            if(arr[i]==1)\\n                count1s++;\\n            s.push_back(arr[i]+\\'0\\');\\n            i--;\\n        }\\n        reverse(s.begin(), s.end());\\n      \\n        s1 = str.substr(0, i+1);\\n        auto index0 = s1.find(s);\\n        if(index0 == -1)\\n            return {-1, -1};\\n        s2 = s1.substr(index0+s.size(), i+1);\\n        auto index1 = s2.find(s);\\n         if(index1 == -1)\\n            return {-1, -1};\\n        diff = s2.size()-(index1+s.size());\\n\\n        vec.push_back(index0+s.size()-1);\\n        vec.push_back(i+1-diff);\\n        return vec;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345229,
                "title": "cpp-t-o-n",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sum1 = 0;\\n        for(int i : arr) sum1 += i;\\n        if(!sum1) return {0,2};\\n        else if(sum1 % 3 !=  0) return {-1,-1};\\n        \\n        int i0,i1,i2;\\n        i0 = i1 = i2 = -1;\\n        int partsum = sum1 / 3;\\n        int t1 = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 1){\\n                t1++;\\n                if(t1 == 1){\\n                    i0 = i; // find the first one\\n                }\\n                else if(t1 == partsum + 1){\\n                    i1 = i; // find the second one\\n                }\\n                else if(t1 == partsum * 2 + 1){\\n                    i2 = i; // find the third one\\n                }\\n            }\\n        }\\n        while(i2 < arr.size()) { // compare all one\\n            if(arr[i0] == arr[i2] && arr[i0] == arr[i1]){\\n                i0++;\\n                i1++;\\n                i2++;\\n            }\\n            else return {-1,-1};\\n        }\\n        return {i0-1,i1};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        int sum1 = 0;\\n        for(int i : arr) sum1 += i;\\n        if(!sum1) return {0,2}",
                "codeTag": "Java"
            },
            {
                "id": 1345212,
                "title": "java-solution-with-comments",
                "content": "```\\n\\nimport java.util.*;\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;                                                         // Get the length of the array\\n        List<Integer> indexesOfOnes = new Vector<Integer>();                        // Take a list to store the indexes of ones in the array\\n        for(int i = 0; i < n; i++){                                                 // Traverse the array and check for ones\\n            if(arr[i] == 1){                                                        // If the ith index is 1, then add \\'i\\' to the vector\\n                indexesOfOnes.add(i);\\n            }\\n        }\\n        int numOfOnes = indexesOfOnes.size();                                       // Get the size of the list, i.e., the total no. of 1\\'s\\n        \\n        if(numOfOnes%3 != 0)                                                        // If the total no. of 1\\'s is not divisible by 3\\n            return new int[]{-1, -1};                                               // Then, no 3 equal partition is possible\\n        \\n        if(numOfOnes == 0)                                                          // If no 1 is present in the array\\n            return new int[]{0, n-1};                                               // Then, 3 equal partition of 0\\'s is possible\\n        \\n        int indexDist = numOfOnes/3;                                                // Else, get the avg. index distance between the ones\\n        \\n        int first  = indexesOfOnes.get(0);                                          // Now, from the list, get the index of the 1st 1 for the 1st partition\\n        int second = indexesOfOnes.get(indexDist);                                  // Get the index of the 1 at index \\'indexDist\\' for the 2nd partition\\n        int third  = indexesOfOnes.get(indexDist*2);                                // And get index of the 1 at index \\'2*indexDist\\' for the 3rd partition\\n        \\n        while(third < n && arr[first] == arr[second] && arr[first] == arr[third]){  // Run a loop while the elements are equal in each part and \\'third\\' is less than \\'n\\'\\n            first++;                                                                // Keep increasing the value of \\'first\\'\\n            second++;                                                               // Keep increasing the value of \\'second\\'\\n            third++;                                                                // And, keep increasing the value of \\'third\\'\\n        }\\n        \\n        if(third == n)                                                              // Check if \\'third\\' has reached the end or not\\n            return new int[]{first-1, second};                                      // If Yes, then all the partitions were equal; so return \\'first-1\\' & \\'second\\' as the indexes\\n        \\n        return new int[]{-1, -1};                                                   // Else, the 3 partitions were not equal; so return {-1, -1}\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nimport java.util.*;\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;                                                         // Get the length of the array\\n        List<Integer> indexesOfOnes = new Vector<Integer>();                        // Take a list to store the indexes of ones in the array\\n        for(int i = 0; i < n; i++){                                                 // Traverse the array and check for ones\\n            if(arr[i] == 1){                                                        // If the ith index is 1, then add \\'i\\' to the vector\\n                indexesOfOnes.add(i);\\n            }\\n        }\\n        int numOfOnes = indexesOfOnes.size();                                       // Get the size of the list, i.e., the total no. of 1\\'s\\n        \\n        if(numOfOnes%3 != 0)                                                        // If the total no. of 1\\'s is not divisible by 3\\n            return new int[]{-1, -1};                                               // Then, no 3 equal partition is possible\\n        \\n        if(numOfOnes == 0)                                                          // If no 1 is present in the array\\n            return new int[]{0, n-1};                                               // Then, 3 equal partition of 0\\'s is possible\\n        \\n        int indexDist = numOfOnes/3;                                                // Else, get the avg. index distance between the ones\\n        \\n        int first  = indexesOfOnes.get(0);                                          // Now, from the list, get the index of the 1st 1 for the 1st partition\\n        int second = indexesOfOnes.get(indexDist);                                  // Get the index of the 1 at index \\'indexDist\\' for the 2nd partition\\n        int third  = indexesOfOnes.get(indexDist*2);                                // And get index of the 1 at index \\'2*indexDist\\' for the 3rd partition\\n        \\n        while(third < n && arr[first] == arr[second] && arr[first] == arr[third]){  // Run a loop while the elements are equal in each part and \\'third\\' is less than \\'n\\'\\n            first++;                                                                // Keep increasing the value of \\'first\\'\\n            second++;                                                               // Keep increasing the value of \\'second\\'\\n            third++;                                                                // And, keep increasing the value of \\'third\\'\\n        }\\n        \\n        if(third == n)                                                              // Check if \\'third\\' has reached the end or not\\n            return new int[]{first-1, second};                                      // If Yes, then all the partitions were equal; so return \\'first-1\\' & \\'second\\' as the indexes\\n        \\n        return new int[]{-1, -1};                                                   // Else, the 3 partitions were not equal; so return {-1, -1}\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345173,
                "title": "three-equal-parts-java-explanatory-comments",
                "content": "```\\n\\nimport java.util.*;\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;                                                         // Get the length of the array\\n        List<Integer> indexesOfOnes = new Vector<Integer>();                        // Take a list to store the indexes of ones in the array\\n        for(int i = 0; i < n; i++){                                                 // Traverse the array and check for ones\\n            if(arr[i] == 1){                                                        // If the ith index is 1, then add \\'i\\' to the vector\\n                indexesOfOnes.add(i);\\n            }\\n        }\\n        int numOfOnes = indexesOfOnes.size();                                       // Get the size of the list, i.e., the total no. of 1\\'s\\n        \\n        if(numOfOnes%3 != 0)                                                        // If the total no. of 1\\'s is not divisible by 3\\n            return new int[]{-1, -1};                                               // Then, no 3 equal partition is possible\\n        \\n        if(numOfOnes == 0)                                                          // If no 1 is present in the array\\n            return new int[]{0, n-1};                                               // Then, 3 equal partition of 0\\'s is possible\\n        \\n        int indexDist = numOfOnes/3;                                                // Else, get the avg. index distance between the ones\\n        \\n        int first  = indexesOfOnes.get(0);                                          // Now, from the list, get the index of the 1st 1 for the 1st partition\\n        int second = indexesOfOnes.get(indexDist);                                  // Get the index of the 1 at index \\'indexDist\\' for the 2nd partition\\n        int third  = indexesOfOnes.get(indexDist*2);                                // And get index of the 1 at index \\'2*indexDist\\' for the 3rd partition\\n        \\n        while(third < n && arr[first] == arr[second] && arr[first] == arr[third]){  // Run a loop while the elements are equal in each part and \\'third\\' is less than \\'n\\'\\n            first++;                                                                // Keep increasing the value of \\'first\\'\\n            second++;                                                               // Keep increasing the value of \\'second\\'\\n            third++;                                                                // And, keep increasing the value of \\'third\\'\\n        }\\n        \\n        if(third == n)                                                              // Check if \\'third\\' has reached the end or not\\n            return new int[]{first-1, second};                                      // If Yes, then all the partitions were equal; so return \\'first-1\\' & \\'second\\' as the indexes\\n        \\n        return new int[]{-1, -1};                                                   // Else, the 3 partitions were not equal; so return {-1, -1}\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nimport java.util.*;\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length;                                                         // Get the length of the array\\n        List<Integer> indexesOfOnes = new Vector<Integer>();                        // Take a list to store the indexes of ones in the array\\n        for(int i = 0; i < n; i++){                                                 // Traverse the array and check for ones\\n            if(arr[i] == 1){                                                        // If the ith index is 1, then add \\'i\\' to the vector\\n                indexesOfOnes.add(i);\\n            }\\n        }\\n        int numOfOnes = indexesOfOnes.size();                                       // Get the size of the list, i.e., the total no. of 1\\'s\\n        \\n        if(numOfOnes%3 != 0)                                                        // If the total no. of 1\\'s is not divisible by 3\\n            return new int[]{-1, -1};                                               // Then, no 3 equal partition is possible\\n        \\n        if(numOfOnes == 0)                                                          // If no 1 is present in the array\\n            return new int[]{0, n-1};                                               // Then, 3 equal partition of 0\\'s is possible\\n        \\n        int indexDist = numOfOnes/3;                                                // Else, get the avg. index distance between the ones\\n        \\n        int first  = indexesOfOnes.get(0);                                          // Now, from the list, get the index of the 1st 1 for the 1st partition\\n        int second = indexesOfOnes.get(indexDist);                                  // Get the index of the 1 at index \\'indexDist\\' for the 2nd partition\\n        int third  = indexesOfOnes.get(indexDist*2);                                // And get index of the 1 at index \\'2*indexDist\\' for the 3rd partition\\n        \\n        while(third < n && arr[first] == arr[second] && arr[first] == arr[third]){  // Run a loop while the elements are equal in each part and \\'third\\' is less than \\'n\\'\\n            first++;                                                                // Keep increasing the value of \\'first\\'\\n            second++;                                                               // Keep increasing the value of \\'second\\'\\n            third++;                                                                // And, keep increasing the value of \\'third\\'\\n        }\\n        \\n        if(third == n)                                                              // Check if \\'third\\' has reached the end or not\\n            return new int[]{first-1, second};                                      // If Yes, then all the partitions were equal; so return \\'first-1\\' & \\'second\\' as the indexes\\n        \\n        return new int[]{-1, -1};                                                   // Else, the 3 partitions were not equal; so return {-1, -1}\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345119,
                "title": "simple-solution-no-storage-very-intuitive-o-n-time-with-o-1-space",
                "content": "The solution is very simple. We need to divide the array into three segments right? So, what comes to mind first?\\n\\nAaah, it makes sense that the number of ones must be a multiple of 3. Second, the last segment determines the binary equivalent we are looking for. So, find the first one in the last segment. For example, if this is the array [1,0,0,1,1,0,0,1,**1**,0,0,1]. The bold part will be the first one in the last segment. Finding it is simple. Traverse the aray from back and when you reach the expected number of ones, you break.\\n\\nNow, all you need to do is traverse the array from beginning and check if there are segments that are exactly similar to the last segment. That\\'s it. You are done!!!!\\n\\t\\n\\tdef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Perform segment check to see if the segments are same.\\n        def start_segment_check(i, last_one):\\n            while(last_one < n):\\n                if arr[i] != arr[last_one]:\\n                    return -1\\n                last_one += 1\\n                i += 1\\n            return 0\\n        \\n        # Preliminary checks.\\n        ones = 0\\n        n = len(arr)\\n        for num in arr:\\n            ones += num\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        if ones == 0:\\n            return [0, n - 1]\\n        \\n        # Find the first one in the last segment\\n        zeroes = n - ones\\n        first_one = -1\\n        expected_number_of_ones_in_segment = ones // 3\\n        curr_num_of_ones = 0\\n        \\n        for i in range(n - 1, -1, -1):\\n            if arr[i] == 1:\\n                curr_num_of_ones += 1\\n                if curr_num_of_ones > expected_number_of_ones_in_segment:\\n                    break\\n                #Setup for ones\\n                first_one = i\\n        \\n        # Perform checks\\n        i = 0\\n        retunr_i = -1\\n        return_j = -1\\n        while(i < first_one):\\n            if arr[i] == 1:\\n                j = start_segment_check(i, first_one)\\n                if j == -1:\\n                    return [-1, -1]\\n                i += n - first_one\\n                if retunr_i == -1:\\n                    retunr_i = i - 1\\n                else:\\n                    return_j = i\\n            else:\\n                i += 1\\n                \\n        \\n        return [retunr_i, return_j]\\n",
                "solutionTags": [],
                "code": "The solution is very simple. We need to divide the array into three segments right? So, what comes to mind first?\\n\\nAaah, it makes sense that the number of ones must be a multiple of 3. Second, the last segment determines the binary equivalent we are looking for. So, find the first one in the last segment. For example, if this is the array [1,0,0,1,1,0,0,1,**1**,0,0,1]. The bold part will be the first one in the last segment. Finding it is simple. Traverse the aray from back and when you reach the expected number of ones, you break.\\n\\nNow, all you need to do is traverse the array from beginning and check if there are segments that are exactly similar to the last segment. That\\'s it. You are done!!!!\\n\\t\\n\\tdef threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Perform segment check to see if the segments are same.\\n        def start_segment_check(i, last_one):\\n            while(last_one < n):\\n                if arr[i] != arr[last_one]:\\n                    return -1\\n                last_one += 1\\n                i += 1\\n            return 0\\n        \\n        # Preliminary checks.\\n        ones = 0\\n        n = len(arr)\\n        for num in arr:\\n            ones += num\\n        if ones % 3 != 0:\\n            return [-1, -1]\\n        if ones == 0:\\n            return [0, n - 1]\\n        \\n        # Find the first one in the last segment\\n        zeroes = n - ones\\n        first_one = -1\\n        expected_number_of_ones_in_segment = ones // 3\\n        curr_num_of_ones = 0\\n        \\n        for i in range(n - 1, -1, -1):\\n            if arr[i] == 1:\\n                curr_num_of_ones += 1\\n                if curr_num_of_ones > expected_number_of_ones_in_segment:\\n                    break\\n                #Setup for ones\\n                first_one = i\\n        \\n        # Perform checks\\n        i = 0\\n        retunr_i = -1\\n        return_j = -1\\n        while(i < first_one):\\n            if arr[i] == 1:\\n                j = start_segment_check(i, first_one)\\n                if j == -1:\\n                    return [-1, -1]\\n                i += n - first_one\\n                if retunr_i == -1:\\n                    retunr_i = i - 1\\n                else:\\n                    return_j = i\\n            else:\\n                i += 1\\n                \\n        \\n        return [retunr_i, return_j]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1345054,
                "title": "simple-c-code-by-converting-array-to-string-explained",
                "content": "If count of all one is not divisible by 3 answer doesn\\'t exist. Just return {-1,-1} in this case.\\nOtherwise convert binary array to binary string. Iterate over string from last till you find one/3 ones. Let this index be \\'i\\'. So our pattern is string starting from \\'i\\' till end.\\nNow just search for this pattern in string using s.find(), and if you find two such patterns before index \\'i\\' than your answer may exist. \\nNote that, a pattern may have leading zeros as it doesn\\'t contribute towards any value in binary to decimal conversion. But between these patterns there can\\'t be any 1. So check for this and return your answer.\\n```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        string s = \"\";\\n        int n=arr.size();\\n        int one=0;\\n        for(int i=0;i<n;i++){\\n            s += to_string(arr[i]);\\n            if(arr[i]==1)\\n                one++;\\n        }\\n        if(one==0){\\n            return {0,2};\\n        }\\n        if(one%3!=0)\\n            return {-1,-1};\\n        \\n        one = one/3;\\n        int i=n-1;\\n        int count=0;\\n        while(i>=0 and count<one){\\n            if(s[i]==\\'1\\')\\n                count++;\\n            i--;\\n        }\\n        i++;\\n        string pat = s.substr(i);\\n        int m = pat.length();\\n        int j = s.find(pat);\\n        int k = s.find(pat,j+m);\\n        if(j==-1 or k==-1)\\n            return {-1,-1};\\n        for(int l=0;l<j;l++){\\n           if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        for(int l=j+m;l<k;l++){\\n            if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        for(int l=k+m;l<i;l++){\\n            if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        \\n        return {j+m-1,k+m};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> threeEqualParts(vector<int>& arr) {\\n        string s = \"\";\\n        int n=arr.size();\\n        int one=0;\\n        for(int i=0;i<n;i++){\\n            s += to_string(arr[i]);\\n            if(arr[i]==1)\\n                one++;\\n        }\\n        if(one==0){\\n            return {0,2};\\n        }\\n        if(one%3!=0)\\n            return {-1,-1};\\n        \\n        one = one/3;\\n        int i=n-1;\\n        int count=0;\\n        while(i>=0 and count<one){\\n            if(s[i]==\\'1\\')\\n                count++;\\n            i--;\\n        }\\n        i++;\\n        string pat = s.substr(i);\\n        int m = pat.length();\\n        int j = s.find(pat);\\n        int k = s.find(pat,j+m);\\n        if(j==-1 or k==-1)\\n            return {-1,-1};\\n        for(int l=0;l<j;l++){\\n           if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        for(int l=j+m;l<k;l++){\\n            if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        for(int l=k+m;l<i;l++){\\n            if(s[l]==\\'1\\')\\n               return {-1,-1};\\n        }\\n        \\n        return {j+m-1,k+m};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344936,
                "title": "python3-prefix-sum-o-n",
                "content": "\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        MOD = 1_000_000_007\\n        total = 0 \\n        p2 = [1]\\n        for x in arr: \\n            total = (2*total + x) % MOD \\n            p2.append((p2[-1] << 1) % MOD)\\n        \\n        seen = {}\\n        prefix = 0\\n        for j, x in enumerate(arr): \\n            prefix = (2*prefix + x) % MOD\\n            diff = (total - prefix * p2[len(arr)-1-j]) % MOD \\n            if diff in seen:\\n                i = seen[diff]\\n                if diff == (prefix - diff * p2[j - i]) % MOD: return [i, j+1]\\n            seen[prefix] = j\\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        MOD = 1_000_000_007\\n        total = 0 \\n        p2 = [1]\\n        for x in arr: \\n            total = (2*total + x) % MOD \\n            p2.append((p2[-1] << 1) % MOD)\\n        \\n        seen = {}\\n        prefix = 0\\n        for j, x in enumerate(arr): \\n            prefix = (2*prefix + x) % MOD\\n            diff = (total - prefix * p2[len(arr)-1-j]) % MOD \\n            if diff in seen:\\n                i = seen[diff]\\n                if diff == (prefix - diff * p2[j - i]) % MOD: return [i, j+1]\\n            seen[prefix] = j\\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344866,
                "title": "python-o-n-time-o-1-space-two-pointers",
                "content": "Use `i` to represent the ending index of the first part and `j` the starting index of the third part, where `i` and `j` are initialized as `0` and `len-1`. In each step, we either move `i` to the right or `j` to the left according to the relation among `left`, `mid` and `right` values. (Note that we can move `i` to the right without decreasing the `mid`, also we can move `j` to the left without increasing the `right`).\\n\\n```\\ndef threeEqualParts(arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        i, j = 0, n-1\\n        left = arr[0]\\n        right = arr[-1]\\n        mid = 0\\n        for k in range(j-1, i, -1):\\n            mid += (arr[k] << (j-1-k))\\n        while i < j - 1:\\n            if left == mid == right:\\n                return [i, j]\\n            if max(left, right) > mid or left == mid:\\n                return [-1, -1]\\n            if left >= right:\\n                j -= 1\\n                mid >>= 1\\n                right += (arr[j] << (n-1-j))\\n            else:\\n                i += 1\\n                left <<= 1\\n                left += arr[i]\\n                mid -= (arr[i] << (j-i-1))\\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef threeEqualParts(arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        i, j = 0, n-1\\n        left = arr[0]\\n        right = arr[-1]\\n        mid = 0\\n        for k in range(j-1, i, -1):\\n            mid += (arr[k] << (j-1-k))\\n        while i < j - 1:\\n            if left == mid == right:\\n                return [i, j]\\n            if max(left, right) > mid or left == mid:\\n                return [-1, -1]\\n            if left >= right:\\n                j -= 1\\n                mid >>= 1\\n                right += (arr[j] << (n-1-j))\\n            else:\\n                i += 1\\n                left <<= 1\\n                left += arr[i]\\n                mid -= (arr[i] << (j-i-1))\\n        return [-1, -1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1344836,
                "title": "c-o-n-time-no-extra-memory",
                "content": "```\\npublic class Solution {\\n    public int[] ThreeEqualParts(int[] arr) {\\n        int ones = arr.Sum(x => x == 1 ? 1 : 0);\\n        \\n        if(ones%3 != 0)\\n            return new int[] { -1, -1};\\n        if(ones == 0)\\n            return new int[] { 0, 2 };\\n        \\n        int p1 = -1, p2 = -1, p3 = -1, counter = 0, target = ones/3;\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                if(counter == 0)\\n                {\\n                    if(p1 == -1)\\n                        p1 = i;\\n                    else if(p2 == -1)\\n                        p2 = i;\\n                    else if(p3 == -1)\\n                    {\\n                        p3 = i;\\n                        break;\\n                    }\\n                }\\n                counter++;\\n                if(counter == target)\\n                    counter = 0;\\n            }\\n        }\\n        \\n        while(p3 < arr.Length)\\n        {\\n            if(arr[p1] != arr[p2] || arr[p2] != arr[p3])\\n                return new int[] { -1, -1 };\\n            p1++;p2++;p3++;\\n        } \\n        \\n        return new int[] { p1-1, p2 };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] ThreeEqualParts(int[] arr) {\\n        int ones = arr.Sum(x => x == 1 ? 1 : 0);\\n        \\n        if(ones%3 != 0)\\n            return new int[] { -1, -1};\\n        if(ones == 0)\\n            return new int[] { 0, 2 };\\n        \\n        int p1 = -1, p2 = -1, p3 = -1, counter = 0, target = ones/3;\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(arr[i] == 1)\\n            {\\n                if(counter == 0)\\n                {\\n                    if(p1 == -1)\\n                        p1 = i;\\n                    else if(p2 == -1)\\n                        p2 = i;\\n                    else if(p3 == -1)\\n                    {\\n                        p3 = i;\\n                        break;\\n                    }\\n                }\\n                counter++;\\n                if(counter == target)\\n                    counter = 0;\\n            }\\n        }\\n        \\n        while(p3 < arr.Length)\\n        {\\n            if(arr[p1] != arr[p2] || arr[p2] != arr[p3])\\n                return new int[] { -1, -1 };\\n            p1++;p2++;p3++;\\n        } \\n        \\n        return new int[] { p1-1, p2 };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344809,
                "title": "python3-compare-lengths-of-three-chunks-sol-for-reference",
                "content": "The idea is to compare the starting and ending chunks in length and decide if the middle chunk fits in comparision ( as in the three arrays are equal. )\\n\\nT & S = O(n)\\n\\nRuntime: 382 ms, faster than 56.99% of Python3 online submissions for Three Equal Parts.\\nMemory Usage: 16 MB, less than 8.60% of Python3 online submissions for Three Equal Parts.\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        indices = deque([])\\n        N = len(arr)\\n        ans = [-1,-1]\\n        \\n        ## collect all indices of 1\\n        for idx, val in enumerate(arr):\\n            if val: \\n                indices.append(idx)\\n                \\n        if not indices:\\n            return [0, N-1]\\n        \\n        if len(indices) %3 != 0: \\n            return [-1, -1]\\n    \\n        start = 0\\n        end = len(indices)-1\\n        \\n        s = indices[start]\\n        \\n        # if ending in zero, the right most part of 3 parts, should always be from end of middle chunk-until end of array\\n        endsInZero = (arr[-1] == 0)\\n        \\n        # s....index[start]...index[end]....#\\n        # chunk1 - starts with the first 1\\n        # chunk2 - start with chunk1 end + 1 or 1st one after chunk1 \\n        # chunk3 - start with chunk2+1 until end \\n        \\n        ## if the array ends in zero, then the calcuation should be from chunk1+len(last_chunk), chunk2+len(last_chunk) and its edge cases.  \\n        \\n        while start < end:\\n            if endsInZero:\\n                edge_len = N-1-indices[end]\\n                medge_index = min(indices[end], indices[start+1]+edge_len+1)\\n                ## Edge case, if between middle index edge and end if there are 1s\\n                medge_index = max(medge_index, indices[end-1])\\n                \\n                ## check if the lengths are equal, chunk1 and chunk3 have edge_len, hence only compare with middle.\\n                if medge_index - indices[start+1] == edge_len+1:\\n                    if arr[s:s+edge_len+1] == arr[indices[end]:]  == arr[indices[start+1]: medge_index]:\\n                        return (s+edge_len,medge_index)\\n            else:\\n                ## check if the lengths are equal\\n                if indices[start]-s ==  N-indices[end]-1 == indices[end-1]-indices[start+1]:\\n                    if arr[s:indices[start]+1] == arr[indices[end]:] == arr[indices[start+1]:indices[end-1]+1]:\\n                        return (indices[start],indices[end-1]+1)\\n                \\n            start += 1\\n            end -= 1\\n                    \\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The idea is to compare the starting and ending chunks in length and decide if the middle chunk fits in comparision ( as in the three arrays are equal. )\\n\\nT & S = O(n)\\n\\nRuntime: 382 ms, faster than 56.99% of Python3 online submissions for Three Equal Parts.\\nMemory Usage: 16 MB, less than 8.60% of Python3 online submissions for Three Equal Parts.\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        indices = deque([])\\n        N = len(arr)\\n        ans = [-1,-1]\\n        \\n        ## collect all indices of 1\\n        for idx, val in enumerate(arr):\\n            if val: \\n                indices.append(idx)\\n                \\n        if not indices:\\n            return [0, N-1]\\n        \\n        if len(indices) %3 != 0: \\n            return [-1, -1]\\n    \\n        start = 0\\n        end = len(indices)-1\\n        \\n        s = indices[start]\\n        \\n        # if ending in zero, the right most part of 3 parts, should always be from end of middle chunk-until end of array\\n        endsInZero = (arr[-1] == 0)\\n        \\n        # s....index[start]...index[end]....#\\n        # chunk1 - starts with the first 1\\n        # chunk2 - start with chunk1 end + 1 or 1st one after chunk1 \\n        # chunk3 - start with chunk2+1 until end \\n        \\n        ## if the array ends in zero, then the calcuation should be from chunk1+len(last_chunk), chunk2+len(last_chunk) and its edge cases.  \\n        \\n        while start < end:\\n            if endsInZero:\\n                edge_len = N-1-indices[end]\\n                medge_index = min(indices[end], indices[start+1]+edge_len+1)\\n                ## Edge case, if between middle index edge and end if there are 1s\\n                medge_index = max(medge_index, indices[end-1])\\n                \\n                ## check if the lengths are equal, chunk1 and chunk3 have edge_len, hence only compare with middle.\\n                if medge_index - indices[start+1] == edge_len+1:\\n                    if arr[s:s+edge_len+1] == arr[indices[end]:]  == arr[indices[start+1]: medge_index]:\\n                        return (s+edge_len,medge_index)\\n            else:\\n                ## check if the lengths are equal\\n                if indices[start]-s ==  N-indices[end]-1 == indices[end-1]-indices[start+1]:\\n                    if arr[s:indices[start]+1] == arr[indices[end]:] == arr[indices[start+1]:indices[end-1]+1]:\\n                        return (indices[start],indices[end-1]+1)\\n                \\n            start += 1\\n            end -= 1\\n                    \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1344774,
                "title": "java-o-n-solution-1ms-beats-100",
                "content": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length, n_ones = 0; // total number of 1\\n        int[] ones = new int[n]; // record the index of 1\\n        int[] res = new int[] {-1 , -1}; \\n        \\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1) {\\n                ones[n_ones++] = i; // get index of 1 and total number of 1\\n            }\\n        }\\n        \\n        if(n_ones % 3 != 0) return res; \\n        if(n_ones == 0) return new int[] {0, n - 1}; // the case where there is no 1\\n        \\n\\t\\t// check for each segment, if there are same number of 0 between two 1s\\n        for(int i = 1; i < n_ones / 3; i++){\\n            int spacing1 = ones[n_ones / 3 - i] - ones[n_ones / 3 - i - 1];\\n            int spacing2 = ones[n_ones / 3 * 2 - i] - ones[n_ones / 3 * 2 - i - 1];\\n            int spacing3 = ones[n_ones - i] - ones[n_ones - i - 1];\\n            if(spacing1 == spacing2 && spacing1 == spacing3) continue;\\n            else return res;\\n        }\\n        \\n\\t\\t\\n       int useful_zeros = n - 1 - ones[n_ones - 1]; // count the number of useful 0s before the least 1  for the last segment\\n       // check for the middle segment\\n\\t   if(ones[n_ones / 3 * 2] - ones[n_ones / 3 * 2 - 1] - 1 < useful_zeros){\\n            return res;\\n        }\\n       \\n\\t   // check for the first segment\\n        if(ones[n_ones / 3] - ones[n_ones / 3 - 1] - 1 >= useful_zeros){\\n            res[0] = ones[n_ones / 3 - 1] + useful_zeros;\\n            res[1] = ones[n_ones / 3 * 2 - 1] + useful_zeros + 1;\\n            return res;\\n        } else return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int n = arr.length, n_ones = 0; // total number of 1\\n        int[] ones = new int[n]; // record the index of 1\\n        int[] res = new int[] {-1 , -1}; \\n        \\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1) {\\n                ones[n_ones++] = i; // get index of 1 and total number of 1\\n            }\\n        }\\n        \\n        if(n_ones % 3 != 0) return res; \\n        if(n_ones == 0) return new int[] {0, n - 1}; // the case where there is no 1\\n        \\n\\t\\t// check for each segment, if there are same number of 0 between two 1s\\n        for(int i = 1; i < n_ones / 3; i++){\\n            int spacing1 = ones[n_ones / 3 - i] - ones[n_ones / 3 - i - 1];\\n            int spacing2 = ones[n_ones / 3 * 2 - i] - ones[n_ones / 3 * 2 - i - 1];\\n            int spacing3 = ones[n_ones - i] - ones[n_ones - i - 1];\\n            if(spacing1 == spacing2 && spacing1 == spacing3) continue;\\n            else return res;\\n        }\\n        \\n\\t\\t\\n       int useful_zeros = n - 1 - ones[n_ones - 1]; // count the number of useful 0s before the least 1  for the last segment\\n       // check for the middle segment\\n\\t   if(ones[n_ones / 3 * 2] - ones[n_ones / 3 * 2 - 1] - 1 < useful_zeros){\\n            return res;\\n        }\\n       \\n\\t   // check for the first segment\\n        if(ones[n_ones / 3] - ones[n_ones / 3 - 1] - 1 >= useful_zeros){\\n            res[0] = ones[n_ones / 3 - 1] + useful_zeros;\\n            res[1] = ones[n_ones / 3 * 2 - 1] + useful_zeros + 1;\\n            return res;\\n        } else return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344765,
                "title": "python3-runtime-100-explained",
                "content": "To have three parts represent the same binary value, the array can be\\ndevided into following 6 parts.\\n```\\n0.........01x...x10...00.........01x...x10...00.........01x...x10...0\\n|- part1 -||- part2  -||- part3 -||- part4 - ||- part5 -||- part6  -|\\n```\\n\\nThe part1, part3, and part5 are all 0\\'s.\\nPart1 can be added to part2 without changing the represented binary value.\\nPart3 and part5 are similar.\\nPart2, part4 and part6 must be exactly same. They should start with 1, with\\nzero or some 0\\'s at the end.\\n\\nThe algorithm is to find part6 first, then skip all heading 0\\'s (i.e. part1),\\nuse length of part6 to find part2. And then skip 0\\'s (part3), use length of part6\\nto find part4.\\n\\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Find number of 1\\'s in the list\\n        n = arr.count(1)\\n        if n == 0: # No 1 found\\n            return [0, 2]\\n        # If number of 1\\'s cannot be mod by 3, the solution does not exist\\n        if n%3:\\n            return [-1, -1]\\n        m = n/3 # Number of 1\\'s each part should have\\n        \\n        # Find the starting point of part6 (must be 1)\\n        j = len(arr)\\n        while m > 0:\\n            j-=1\\n            if arr[j]:\\n                m-=1\\n                \\n        # Part6\\n        lastArr = arr[j:]\\n        length = len(lastArr)\\n        \\n        # Skip all heading 0\\'s\\n        i = 0\\n        while arr[i]==0:\\n            i += 1\\n            \\n        # Is part2 same as part6?\\n        if arr[i: i+length] != lastArr:\\n            return [-1, -1]\\n            \\n        # Got the first element of returning value\\n        i += length-1\\n        \\n        # Skip next consecutive 0\\'s (part3)\\n        k = i+1\\n        while arr[k] == 0:\\n            k += 1\\n            \\n        # Is part4 same as part6 ?\\n        if arr[k: k+length] != lastArr:\\n            return [-1, -1]\\n            \\n        return [i, k+length]\\n```",
                "solutionTags": [],
                "code": "```\\n0.........01x...x10...00.........01x...x10...00.........01x...x10...0\\n|- part1 -||- part2  -||- part3 -||- part4 - ||- part5 -||- part6  -|\\n```\n```\\nclass Solution:\\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        # Find number of 1\\'s in the list\\n        n = arr.count(1)\\n        if n == 0: # No 1 found\\n            return [0, 2]\\n        # If number of 1\\'s cannot be mod by 3, the solution does not exist\\n        if n%3:\\n            return [-1, -1]\\n        m = n/3 # Number of 1\\'s each part should have\\n        \\n        # Find the starting point of part6 (must be 1)\\n        j = len(arr)\\n        while m > 0:\\n            j-=1\\n            if arr[j]:\\n                m-=1\\n                \\n        # Part6\\n        lastArr = arr[j:]\\n        length = len(lastArr)\\n        \\n        # Skip all heading 0\\'s\\n        i = 0\\n        while arr[i]==0:\\n            i += 1\\n            \\n        # Is part2 same as part6?\\n        if arr[i: i+length] != lastArr:\\n            return [-1, -1]\\n            \\n        # Got the first element of returning value\\n        i += length-1\\n        \\n        # Skip next consecutive 0\\'s (part3)\\n        k = i+1\\n        while arr[k] == 0:\\n            k += 1\\n            \\n        # Is part4 same as part6 ?\\n        if arr[k: k+length] != lastArr:\\n            return [-1, -1]\\n            \\n        return [i, k+length]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567353,
                "content": [
                    {
                        "username": "THolc",
                        "content": "The test case for [0,0,0,0,0] only allows the answer [0,4], but from my understanding of the problem as long as any 2 valid and unique indices are listed it should be correct since it will always be a binary 0 (i.e. 000, 00, and 0 are all equivalent here).\\n\\nCan someone confirm or refute this? Am I missing some key detail or is this test case actually incorrect based on the problem description?"
                    },
                    {
                        "username": "njbillov",
                        "content": "For the [0,0,0,0,0] test case in the solution checker, I calculated [0,1] and it said it was incorrect and the correct answer was [0,4].  As per spec, any [i,j] that results in three equal parts should be true, so I believe something is wrong with the solution checker.\n\nNevermind, i + 1 < j."
                    }
                ]
            },
            {
                "id": 1569325,
                "content": [
                    {
                        "username": "THolc",
                        "content": "The test case for [0,0,0,0,0] only allows the answer [0,4], but from my understanding of the problem as long as any 2 valid and unique indices are listed it should be correct since it will always be a binary 0 (i.e. 000, 00, and 0 are all equivalent here).\\n\\nCan someone confirm or refute this? Am I missing some key detail or is this test case actually incorrect based on the problem description?"
                    },
                    {
                        "username": "njbillov",
                        "content": "For the [0,0,0,0,0] test case in the solution checker, I calculated [0,1] and it said it was incorrect and the correct answer was [0,4].  As per spec, any [i,j] that results in three equal parts should be true, so I believe something is wrong with the solution checker.\n\nNevermind, i + 1 < j."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Days Between Two Dates",
        "question_content": "<p>Write a program to count the number of days between two dates.</p>\n\n<p>The two dates are given as strings, their format is <code>YYYY-MM-DD</code>&nbsp;as shown in the examples.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> date1 = \"2019-06-29\", date2 = \"2019-06-30\"\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> date1 = \"2020-01-15\", date2 = \"2019-12-31\"\n<strong>Output:</strong> 15\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The given dates are valid&nbsp;dates between the years <code>1971</code> and <code>2100</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 517593,
                "title": "calling-api-or-not-that-is-the-question",
                "content": "I am really really curious is this kind of question related to any algorithm technique??? Or just to check whether we know and call API to calculate the result...\\n\\nIf you choose not to call the API, then you will lose your time during the interview...\\n\\nI think this problem is even worse than the Remove Palindromic Subsequence problem, which the a kind of BRAINTEASER but it is fine to me.\\n\\nAnyways, I give my solutions by both ways to make this post more useful after you read :)\\n\\n**Solution 1 with Time-API:**\\n```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n\\t    return Math.abs((int)ChronoUnit.DAYS.between(LocalDate.parse(date1), LocalDate.parse(date2)));\\n    }\\n}\\n```\\n\\n**Solution 2 with No Time-API:**\\n```\\n    static int monthDays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n    public int daysBetweenDates(String date1, String date2) {\\n        int[] d1 = stringDateConvertor(date1);\\n        int[] d2 = stringDateConvertor(date2);\\n        \\n        int date1Days = d1[0] * 365 + d1[2]; \\n  \\n        // Add number of days for the given month  \\n        for (int i = 0; i < d1[1] - 1; i++)  \\n        { \\n            date1Days += monthDays[i]; \\n        } \\n  \\n        // Since each leap year has 366 days, \\n        // Add an extra day for every leap year we meet. \\n        date1Days += countLeapYear(d1[0], d1[1]); \\n  \\n        int date2Days = d2[0] * 365 + d2[2]; \\n        for (int i = 0; i < d2[1] - 1; i++) \\n        { \\n            date2Days += monthDays[i]; \\n        } \\n        date2Days += countLeapYear(d2[0], d2[1]); \\n  \\n        // Return number of days between Two dates. \\n        return Math.abs(date1Days - date2Days); \\n    }\\n    \\n    public int[] stringDateConvertor(String date) {\\n        int[] dateTrans = new int[3];\\n        \\n        String[] d = date.split(\"-\");\\n        dateTrans[0] = Integer.valueOf(d[0]);\\n        dateTrans[1] = Integer.valueOf(d[1]);\\n        dateTrans[2] = Integer.valueOf(d[2]);\\n        \\n        return dateTrans;\\n    }\\n    \\n    public int countLeapYear(int year, int month) {\\n        // If the current year not reach to Feb., then we do not need to consider it\\n        // for the count of leap years.\\n        if (month <= 2)  \\n        { \\n            year--; \\n        } \\n  \\n        // A leap year is a multiple of 4, multiple of 400 BUT not a multiple of 100. \\n        return year / 4 - year / 100 + year / 400; \\n    }\\n```\\n\\n**Solution 2.5: Write a Function to Count the day from year of 1971**\\n```\\n\\tpublic int daysBetweenDates(String date1, String date2) {    \\n\\t\\t\\treturn Math.abs(countSince1971(date1) - countSince1971(date2));\\n    }\\n\\n    public int countSince1971(String date) {\\n        int[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        String[] data = date.split(\"-\");\\n        \\n        int year = Integer.parseInt(data[0]);\\n        int month = Integer.parseInt(data[1]);\\n        int day = Integer.parseInt(data[2]);\\n        \\n        for (int i = 1971; i < year; i++) {\\n            day += isALeapYear(i) ? 366 : 365;\\n        }\\n        for (int i = 1; i < month; i++) {\\n            if (isALeapYear(year) && i == 2) {\\n                day += 1;\\n            } \\n            day += monthDays[i];\\n        }\\n        return day;\\n    }\\n\\n    public boolean isALeapYear(int year) {\\n        return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n\\t    return Math.abs((int)ChronoUnit.DAYS.between(LocalDate.parse(date1), LocalDate.parse(date2)));\\n    }\\n}\\n```\n```\\n    static int monthDays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n    public int daysBetweenDates(String date1, String date2) {\\n        int[] d1 = stringDateConvertor(date1);\\n        int[] d2 = stringDateConvertor(date2);\\n        \\n        int date1Days = d1[0] * 365 + d1[2]; \\n  \\n        // Add number of days for the given month  \\n        for (int i = 0; i < d1[1] - 1; i++)  \\n        { \\n            date1Days += monthDays[i]; \\n        } \\n  \\n        // Since each leap year has 366 days, \\n        // Add an extra day for every leap year we meet. \\n        date1Days += countLeapYear(d1[0], d1[1]); \\n  \\n        int date2Days = d2[0] * 365 + d2[2]; \\n        for (int i = 0; i < d2[1] - 1; i++) \\n        { \\n            date2Days += monthDays[i]; \\n        } \\n        date2Days += countLeapYear(d2[0], d2[1]); \\n  \\n        // Return number of days between Two dates. \\n        return Math.abs(date1Days - date2Days); \\n    }\\n    \\n    public int[] stringDateConvertor(String date) {\\n        int[] dateTrans = new int[3];\\n        \\n        String[] d = date.split(\"-\");\\n        dateTrans[0] = Integer.valueOf(d[0]);\\n        dateTrans[1] = Integer.valueOf(d[1]);\\n        dateTrans[2] = Integer.valueOf(d[2]);\\n        \\n        return dateTrans;\\n    }\\n    \\n    public int countLeapYear(int year, int month) {\\n        // If the current year not reach to Feb., then we do not need to consider it\\n        // for the count of leap years.\\n        if (month <= 2)  \\n        { \\n            year--; \\n        } \\n  \\n        // A leap year is a multiple of 4, multiple of 400 BUT not a multiple of 100. \\n        return year / 4 - year / 100 + year / 400; \\n    }\\n```\n```\\n\\tpublic int daysBetweenDates(String date1, String date2) {    \\n\\t\\t\\treturn Math.abs(countSince1971(date1) - countSince1971(date2));\\n    }\\n\\n    public int countSince1971(String date) {\\n        int[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        String[] data = date.split(\"-\");\\n        \\n        int year = Integer.parseInt(data[0]);\\n        int month = Integer.parseInt(data[1]);\\n        int day = Integer.parseInt(data[2]);\\n        \\n        for (int i = 1971; i < year; i++) {\\n            day += isALeapYear(i) ? 366 : 365;\\n        }\\n        for (int i = 1; i < month; i++) {\\n            if (isALeapYear(year) && i == 2) {\\n                day += 1;\\n            } \\n            day += monthDays[i];\\n        }\\n        return day;\\n    }\\n\\n    public boolean isALeapYear(int year) {\\n        return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517605,
                "title": "similar-to-day-of-the-year",
                "content": "This solution is based on [1154. Day of the Year](https://leetcode.com/problems/day-of-the-year/discuss/355916/C%2B%2B-Number-of-Days-in-a-Month).\\n\\nHere, we also need to add days from year 1971 till the previous year. In the end, we return the absolute difference in number of days between two input dates.\\n```\\nint days[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\nint daysBetweenDates(string d1, string d2) {\\n    return abs(daysFrom1971(d1) - daysFrom1971(d2));\\n}\\nbool isLeap(int y) { \\n    return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0); \\n}\\nint daysFrom1971(string dt) {\\n    int y = stoi(dt.substr(0, 4)), m = stoi(dt.substr(5, 2)), d = stoi(dt.substr(8));\\n    for (int iy = 1971; iy < y; ++iy) \\n        d += isLeap(iy) ? 366 : 365;\\n    return d + (m > 2 && isLeap(y)) + accumulate(begin(days), begin(days) + m - 1, 0);\\n}  \\n```",
                "solutionTags": [],
                "code": "```\\nint days[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\nint daysBetweenDates(string d1, string d2) {\\n    return abs(daysFrom1971(d1) - daysFrom1971(d2));\\n}\\nbool isLeap(int y) { \\n    return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0); \\n}\\nint daysFrom1971(string dt) {\\n    int y = stoi(dt.substr(0, 4)), m = stoi(dt.substr(5, 2)), d = stoi(dt.substr(8));\\n    for (int iy = 1971; iy < y; ++iy) \\n        d += isLeap(iy) ? 366 : 365;\\n    return d + (m > 2 && isLeap(y)) + accumulate(begin(days), begin(days) + m - 1, 0);\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 893058,
                "title": "this-is-a-terrible-interview-question-never-ask-this",
                "content": "For a number of reasons. First of all, it can trivially be solved with a library:\\n\\n```\\ndef daysBetweenDates(self, date1, date2):\\n\\td1 = date(*tuple(int(val) for val in date1.split(\"-\")))\\n\\td2 = date(*tuple(int(val) for val in date2.split(\"-\")))\\n\\treturn abs((d1 - d2).days)\\n```\\n\\nHowever, if you choose to not to use a library, your success or failure relies on you knowing the leap year rules, the number of days in every month, and then hacking some piece of code together that isn\\'t algorithmic in any sense and at best only shows whether or not you can write relatively clean code in a situation that is basically a set of edge cases. In short, an interviewer learns little to nothing about the interviewee in this situation.\\n\\nIf you give interviews, never ask this. If you are in the unfortunate position of being asked this, tell them you would use a library function for this and move on but offer to code up something based on the days and leap year rules as you remember them.\\n",
                "solutionTags": [],
                "code": "```\\ndef daysBetweenDates(self, date1, date2):\\n\\td1 = date(*tuple(int(val) for val in date1.split(\"-\")))\\n\\td2 = date(*tuple(int(val) for val in date2.split(\"-\")))\\n\\treturn abs((d1 - d2).days)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 517582,
                "title": "python-magical-formula",
                "content": "When ```m=1``` or ```m=2``` (January or February), we let ```m=13``` or ```m=14``` and let ```y``` decreased by 1. Imagine it is 13th or 14th month of the last year. By doing that, we let the magical formula also work for those two months. ```(153 * m + 8) // 5``` is just a carefully designed way to record the days of each month. More specifically, it is designed to record the difference of days between two months. Suppose we have March 1st and April 1st, ```(153 * 3 + 8) // 5 = 93``` while ```(153 * 4 + 8) // 5 = 124```, the difference is 31 which is the number of days in March. Suppose we have April 1st to May 1st, ```(153 * 4 + 8) // 5 = 124``` and ```(153 * 5 + 8) // 5 = 154```, the difference is now 30 which is the number of days in April. You can also check other months.\\n\\nI learned this formula somewhere else before. It is not something to come up with in minutes.\\n\\n```python\\nclass Solution:\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def f(date):\\n            y, m, d = map(int, date.split(\\'-\\'))\\n            if m < 3:\\n                m += 12\\n                y -= 1\\n            return 365 * y + y // 4 + y // 400 - y // 100 + d + (153 * m + 8) // 5\\n        \\n        return abs(f(date1) - f(date2))\\n```",
                "solutionTags": [],
                "code": "```m=1```\n```m=2```\n```m=13```\n```m=14```\n```y```\n```(153 * m + 8) // 5```\n```(153 * 3 + 8) // 5 = 93```\n```(153 * 4 + 8) // 5 = 124```\n```(153 * 4 + 8) // 5 = 124```\n```(153 * 5 + 8) // 5 = 154```\n```python\\nclass Solution:\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def f(date):\\n            y, m, d = map(int, date.split(\\'-\\'))\\n            if m < 3:\\n                m += 12\\n                y -= 1\\n            return 365 * y + y // 4 + y // 400 - y // 100 + d + (153 * m + 8) // 5\\n        \\n        return abs(f(date1) - f(date2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621582,
                "title": "c-short-simple-modular-solution",
                "content": "```\\nclass Solution {   \\n    public:\\n        int daysBetweenDates(string date1, string date2) {\\n            return abs(date_to_int(date2) - date_to_int(date1));\\n        }\\n        \\n    protected:\\n        int date_to_int(string s_date)\\n        {\\n            int Y = stoi(s_date.substr(0, 4));\\n            int M = stoi(s_date.substr(5, 2));\\n            int D = stoi(s_date.substr(8, 2));\\n            \\n            int date = 0;\\n            for(int y = 1971; y < Y; ++y) date += is_leap_year(y) ? 366 : 365;\\n            for(int m = 1; m < M; ++m) date += days_in_month(m, Y);\\n            return date + D;\\n        }\\n        \\n        bool is_leap_year(int year)\\n        {\\n            return (year %4  == 0 && year % 100 != 0) || year % 400 == 0;\\n        }\\n        \\n        int days_in_month(int m, int year)\\n        { \\n            if(m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12 ) return 31;\\n            if(m==2) return is_leap_year(year) ? 29 : 28;\\n            return 30;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {   \\n    public:\\n        int daysBetweenDates(string date1, string date2) {\\n            return abs(date_to_int(date2) - date_to_int(date1));\\n        }\\n        \\n    protected:\\n        int date_to_int(string s_date)\\n        {\\n            int Y = stoi(s_date.substr(0, 4));\\n            int M = stoi(s_date.substr(5, 2));\\n            int D = stoi(s_date.substr(8, 2));\\n            \\n            int date = 0;\\n            for(int y = 1971; y < Y; ++y) date += is_leap_year(y) ? 366 : 365;\\n            for(int m = 1; m < M; ++m) date += days_in_month(m, Y);\\n            return date + D;\\n        }\\n        \\n        bool is_leap_year(int year)\\n        {\\n            return (year %4  == 0 && year % 100 != 0) || year % 400 == 0;\\n        }\\n        \\n        int days_in_month(int m, int year)\\n        { \\n            if(m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12 ) return 31;\\n            if(m==2) return is_leap_year(year) ? 29 : 28;\\n            return 30;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517575,
                "title": "java-no-time-api-cheating",
                "content": "```\\nclass Solution {\\n     public int daysBetweenDates(String date1, String date2) {\\n        int days1 = days(date1);\\n        int days2 = days(date2);\\n        return Math.abs(days1 - days2);\\n    }\\n\\n    int[] mdays = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n\\n    // days from 1900-1-0\\n    private int days(String d) {\\n        String[] ss = d.split(\"-\");\\n        int year = Integer.valueOf(ss[0]);\\n        int month = Integer.valueOf(ss[1]);\\n        int day = Integer.valueOf(ss[2]);\\n        // years we spent, hence -1 because current year is not spent yet\\n        int ydelta = year - 1 - 1900;\\n        int dy = ydelta * 365 + ydelta / 4;// from 1900 every 4 years is leap year\\n        // month-1, current month is not done yet\\n        int dm = mdays[month - 1];\\n        if (isleap(year) && month - 1 >= 2) {\\n            dm++;\\n        }\\n        return dy + dm + day;\\n    }\\n\\n    private boolean isleap(int year) {\\n        return (year % 100 != 0 && year % 4 == 0) || (year % 100 == 0 && year % 400 == 0);\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int daysBetweenDates(String date1, String date2) {\\n        int days1 = days(date1);\\n        int days2 = days(date2);\\n        return Math.abs(days1 - days2);\\n    }\\n\\n    int[] mdays = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n\\n    // days from 1900-1-0\\n    private int days(String d) {\\n        String[] ss = d.split(\"-\");\\n        int year = Integer.valueOf(ss[0]);\\n        int month = Integer.valueOf(ss[1]);\\n        int day = Integer.valueOf(ss[2]);\\n        // years we spent, hence -1 because current year is not spent yet\\n        int ydelta = year - 1 - 1900;\\n        int dy = ydelta * 365 + ydelta / 4;// from 1900 every 4 years is leap year\\n        // month-1, current month is not done yet\\n        int dm = mdays[month - 1];\\n        if (isleap(year) && month - 1 >= 2) {\\n            dm++;\\n        }\\n        return dy + dm + day;\\n    }\\n\\n    private boolean isleap(int year) {\\n        return (year % 100 != 0 && year % 4 == 0) || (year % 100 == 0 && year % 400 == 0);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518708,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        r1 = self.get_days(date1)\\n        r2 = self.get_days(date2)\\n        return abs(r2 - r1)\\n    \\n    def leapyear(self, year):\\n        if year % 4 != 0:\\n            return False\\n        elif year % 100 != 0:\\n            return True\\n        elif year % 400 != 0:\\n            return False\\n        else:\\n            return True\\n        \\n    def get_days(self, a_str):\\n        s = a_str.split(\\'-\\')\\n        year, month, day = map(int, s)\\n        n_leaps = 0\\n        for i in range(1971, year):\\n            n_leaps += int(self.leapyear(i))\\n        months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 32]\\n        res =  n_leaps + 365 * (year - 1971) + sum(months[:month]) + day\\n        if self.leapyear(year) and month > 2:\\n            res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        r1 = self.get_days(date1)\\n        r2 = self.get_days(date2)\\n        return abs(r2 - r1)\\n    \\n    def leapyear(self, year):\\n        if year % 4 != 0:\\n            return False\\n        elif year % 100 != 0:\\n            return True\\n        elif year % 400 != 0:\\n            return False\\n        else:\\n            return True\\n        \\n    def get_days(self, a_str):\\n        s = a_str.split(\\'-\\')\\n        year, month, day = map(int, s)\\n        n_leaps = 0\\n        for i in range(1971, year):\\n            n_leaps += int(self.leapyear(i))\\n        months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 32]\\n        res =  n_leaps + 365 * (year - 1971) + sum(months[:month]) + day\\n        if self.leapyear(year) and month > 2:\\n            res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748686,
                "title": "python-3-one-liner-using-datetime",
                "content": "Approach:\\n1. The input is of type <```string```>. To use the datetime module, these strings will first be converted into type <```date```> using ```datetime.strptime(date_string, format)```.\\n2. After conversion, the dates are subtracted, i.e. ```(date2 - date1).days()```\\n\\nNote:\\n```abs()``` must be used when calculating the difference as any of the dates could be bigger than the other.\\n\\n```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs((datetime.strptime(date2, \\'%Y-%m-%d\\').date() - datetime.strptime(date1, \\'%Y-%m-%d\\').date()).days)\\n```\\n<br>**Cleaner Version:**\\n```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        M = datetime.strptime(date1, \\'%Y-%m-%d\\').date()\\n        N = datetime.strptime(date2, \\'%Y-%m-%d\\').date()\\n        return abs((N - M).days)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```string```\n```date```\n```datetime.strptime(date_string, format)```\n```(date2 - date1).days()```\n```abs()```\n```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs((datetime.strptime(date2, \\'%Y-%m-%d\\').date() - datetime.strptime(date1, \\'%Y-%m-%d\\').date()).days)\\n```\n```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        M = datetime.strptime(date1, \\'%Y-%m-%d\\').date()\\n        N = datetime.strptime(date2, \\'%Y-%m-%d\\').date()\\n        return abs((N - M).days)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712297,
                "title": "js-easy-solution",
                "content": "```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nconst daysBetweenDates = (date1, date2) => {\\n    const millisecondsInADay = 1000*60*60*24;    \\n    return Math.abs((new Date(date1).getTime() - new Date(date2).getTime()) / millisecondsInADay);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nconst daysBetweenDates = (date1, date2) => {\\n    const millisecondsInADay = 1000*60*60*24;    \\n    return Math.abs((new Date(date1).getTime() - new Date(date2).getTime()) / millisecondsInADay);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721044,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def is_leap_year(year: int) -> bool:\\n            return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\\n\\n        def get_days(date: str) -> int:\\n            y, m, d = map(int, date.split(\\'-\\'))\\n\\n            days = d + int(is_leap_year(y) and m > 2)\\n            days += sum(365 + int(is_leap_year(y)) for y in range(1971, y))\\n            days += sum([0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:m])\\n\\n            return days\\n\\n        return abs(get_days(date1) - get_days(date2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def is_leap_year(year: int) -> bool:\\n            return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\\n\\n        def get_days(date: str) -> int:\\n            y, m, d = map(int, date.split(\\'-\\'))\\n\\n            days = d + int(is_leap_year(y) and m > 2)\\n            days += sum(365 + int(is_leap_year(y)) for y in range(1971, y))\\n            days += sum([0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:m])\\n\\n            return days\\n\\n        return abs(get_days(date1) - get_days(date2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544093,
                "title": "javascript-solution",
                "content": "```\\nvar daysBetweenDates = function(date1, date2) {\\n    const days1 = calculateDays(date1)\\n    const days2 = calculateDays(date2)\\n    \\n    return Math.abs(days1 - days2)\\n};\\n\\nfunction calculateDays(date) {\\n    const [y, m, d] = date.split(\"-\")\\n    \\n    const yearDays = calculateDaysUpToYears(parseInt(y))\\n    const monthDays = calculateDaysUpToMonths(parseInt(m), parseInt(y))\\n    const dayDays = parseInt(d)\\n    \\n    const days = yearDays + monthDays + dayDays\\n    \\n    return days\\n}\\n\\nfunction calculateDaysUpToYears(year) {\\n    let days = 0\\n    \\n    for (let i = 1971; i < year; i++) {\\n        days += (isLeapYear(i)) ? 366 : 365\\n    }\\n    \\n    return days\\n}\\n\\nfunction isLeapYear(year) {\\n    return (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);\\n}\\n\\nfunction calculateDaysUpToMonths(month, year) {\\n    const months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 0 is to take care of the month offset\\n    let days = 0\\n    \\n    for (let i = 1; i < month; i++) {\\n        days += months[i]\\n    }\\n    \\n    if (month > 2 && isLeapYear(year)) {\\n        days += 1\\n    }\\n    \\n    return days\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar daysBetweenDates = function(date1, date2) {\\n    const days1 = calculateDays(date1)\\n    const days2 = calculateDays(date2)\\n    \\n    return Math.abs(days1 - days2)\\n};\\n\\nfunction calculateDays(date) {\\n    const [y, m, d] = date.split(\"-\")\\n    \\n    const yearDays = calculateDaysUpToYears(parseInt(y))\\n    const monthDays = calculateDaysUpToMonths(parseInt(m), parseInt(y))\\n    const dayDays = parseInt(d)\\n    \\n    const days = yearDays + monthDays + dayDays\\n    \\n    return days\\n}\\n\\nfunction calculateDaysUpToYears(year) {\\n    let days = 0\\n    \\n    for (let i = 1971; i < year; i++) {\\n        days += (isLeapYear(i)) ? 366 : 365\\n    }\\n    \\n    return days\\n}\\n\\nfunction isLeapYear(year) {\\n    return (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);\\n}\\n\\nfunction calculateDaysUpToMonths(month, year) {\\n    const months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 0 is to take care of the month offset\\n    let days = 0\\n    \\n    for (let i = 1; i < month; i++) {\\n        days += months[i]\\n    }\\n    \\n    if (month > 2 && isLeapYear(year)) {\\n        days += 1\\n    }\\n    \\n    return days\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 669156,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\n    int[] days = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(days(date1)-days(date2));\\n    }\\n    \\n    int days(String date) {\\n        int year = Integer.parseInt(date.substring(0,4));\\n        int month = Integer.parseInt(date.substring(5,7));\\n        int day=Integer.parseInt(date.substring(8,10));\\n        \\n        for(int i=1971;i<year;i++) \\n            day += isLeap(i)? 366 : 365;\\n        if(month>2)\\n            day += isLeap(year) ? 1 : 0;\\n        \\n        for(int i=1;i<month;i++) {\\n            day += days[i];\\n        }\\n        \\n        return day;\\n    }\\n    \\n    public boolean isLeap(int year) {\\n        if(year%4==0&&year%100!=0||year%400==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] days = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(days(date1)-days(date2));\\n    }\\n    \\n    int days(String date) {\\n        int year = Integer.parseInt(date.substring(0,4));\\n        int month = Integer.parseInt(date.substring(5,7));\\n        int day=Integer.parseInt(date.substring(8,10));\\n        \\n        for(int i=1971;i<year;i++) \\n            day += isLeap(i)? 366 : 365;\\n        if(month>2)\\n            day += isLeap(year) ? 1 : 0;\\n        \\n        for(int i=1;i<month;i++) {\\n            day += days[i];\\n        }\\n        \\n        return day;\\n    }\\n    \\n    public boolean isLeap(int year) {\\n        if(year%4==0&&year%100!=0||year%400==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734658,
                "title": "c-100-00-easy-to-understand",
                "content": "***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Number of Days Between Two Dates.\\nMemory Usage: 5.8 MB, less than 99.31% of C++ online submissions for Number of Days Between Two Dates.***\\n```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(daysPassedSince1971(date1) - daysPassedSince1971(date2));\\n    }\\n    bool isLeapYear(int year){\\n        return (year%400 == 0)||(year%100 != 0 && year%4 == 0);\\n    }\\n    int daysPassedSince1971(string date){\\n        int year = stoi(date.substr(0,4));\\n        int month = stoi(date.substr(5,2));\\n        int day = stoi(date.substr(8,2));\\n        \\n        vector<int> months ({0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31});\\n        \\n        for(int i=1971;i<year;i++){\\n            day += isLeapYear(i) ? 366 : 365;\\n        }\\n        \\n        for(int i=1;i<month;i++){\\n            if(i==2 && isLeapYear(year)){\\n                day += 1;\\n            }\\n            day += months[i];\\n        }\\n        \\n        return day;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(daysPassedSince1971(date1) - daysPassedSince1971(date2));\\n    }\\n    bool isLeapYear(int year){\\n        return (year%400 == 0)||(year%100 != 0 && year%4 == 0);\\n    }\\n    int daysPassedSince1971(string date){\\n        int year = stoi(date.substr(0,4));\\n        int month = stoi(date.substr(5,2));\\n        int day = stoi(date.substr(8,2));\\n        \\n        vector<int> months ({0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31});\\n        \\n        for(int i=1971;i<year;i++){\\n            day += isLeapYear(i) ? 366 : 365;\\n        }\\n        \\n        for(int i=1;i<month;i++){\\n            if(i==2 && isLeapYear(year)){\\n                day += 1;\\n            }\\n            day += months[i];\\n        }\\n        \\n        return day;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690782,
                "title": "standard-java-solution",
                "content": "### Theory\\nIf we do as the hint says and find the difference in dates from both a common date, then our result will simply be `from1971(date1) - from1971(date2)`.\\nI can\\'t really imagine this being asked in an interview, cause there are just so many better questions to ask, and not everyone has a grasp of the dates, and its API (like knowing which year is a leap year for example).\\n\\n### Solution\\n```\\n    private int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(from1971(date1) - from1971(date2));\\n    }\\n    \\n    private int from1971(String date) {\\n        String[] parts = date.split(\"-\");\\n        int year = Integer.parseInt(parts[0]), month = Integer.parseInt(parts[1]), day = Integer.parseInt(parts[2]);\\n        int count = day;\\n        for (int i = 1971; i < year; i++) count += (isLeapYear(i)) ? 366 : 365;\\n        for (int i = 0; i < month - 1; i++) count += months[i];\\n        if (month > 2 && isLeapYear(year)) count += 1;\\n        return count;\\n    }\\n    \\n    private boolean isLeapYear(Integer year) {\\n        return year % 400 == 0 || (year % 100 != 0 && year % 4 == 0);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    private int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(from1971(date1) - from1971(date2));\\n    }\\n    \\n    private int from1971(String date) {\\n        String[] parts = date.split(\"-\");\\n        int year = Integer.parseInt(parts[0]), month = Integer.parseInt(parts[1]), day = Integer.parseInt(parts[2]);\\n        int count = day;\\n        for (int i = 1971; i < year; i++) count += (isLeapYear(i)) ? 366 : 365;\\n        for (int i = 0; i < month - 1; i++) count += months[i];\\n        if (month > 2 && isLeapYear(year)) count += 1;\\n        return count;\\n    }\\n    \\n    private boolean isLeapYear(Integer year) {\\n        return year % 400 == 0 || (year % 100 != 0 && year % 4 == 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478633,
                "title": "well-explained-faster-than-100-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    //for checking if year is leap or not\\n    bool isLeap(int year){\\n        return ((year%4==0 && year%100!=0)||(year%400==0));\\n    }\\n    \\n    //for checking no of days in month\\n    int daysInMonth(int month,int year){\\n        if(month==1||month==3||month==5||month==7||month==8||month==10||month==12)\\n            return 31;\\n        if(month==2)\\n            return isLeap(year)?29:28;\\n        return 30;\\n    }\\n    \\n    //function to calculate days from 1971 to current date\\n    int stringToInt(string s){\\n        int year=stoi(s.substr(0,4));\\n        int month=stoi(s.substr(5,2));\\n        int days=stoi(s.substr(8,2));\\n        \\n        int total_days=0;\\n        for(int i=1971;i<year;i++){\\n            total_days+=isLeap(i)?366:365;\\n        }\\n        for(int i=1;i<month;i++){\\n            total_days+=daysInMonth(i,year);\\n        }\\n        \\n        return total_days+days;\\n    }\\n    \\n    //main\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(stringToInt(date2)-stringToInt(date1));\\n        \\n    }\\n};\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    //for checking if year is leap or not\\n    bool isLeap(int year){\\n        return ((year%4==0 && year%100!=0)||(year%400==0));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 517718,
                "title": "python-solution-no-api-intuitive-and-easy-to-understand",
                "content": "Basic idea: \\ndays1 = days bewteen Date1 and \"1970-01-01\"\\ndays2 = days bewteen Date2 and \"1970-01-01\"\\nreturn abs(days1 - days2)\\n```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def day(y, m, d):\\n            yd = 365 * (y-1970)\\n            for i in range(1970, y):\\n                if i % 4 == 0:\\n                    yd += 1    \\n            \\n            month = [31,28,31,30,31,30,31,31,30,31,30,31]        \\n            md = sum(month[:m-1])\\n            if y % 4 == 0 and y != 2100 and m > 2:\\n                md += 1\\n            \\n            return yd + md + d\\n\\t\\t\\t\\n        y1 = int(date1[:4])\\n        m1 = int(date1[5:7])\\n        d1 = int(date1[8:])\\n\\t\\t\\n        y2 = int(date2[:4])\\n        m2 = int(date2[5:7])\\n        d2 = int(date2[8:])\\n\\t\\t\\n        days1 = day(y1, m1, d1)\\n        days2 = day(y2, m2, d2)\\n\\t\\t\\n        return abs(days1-days2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def day(y, m, d):\\n            yd = 365 * (y-1970)\\n            for i in range(1970, y):\\n                if i % 4 == 0:\\n                    yd += 1    \\n            \\n            month = [31,28,31,30,31,30,31,31,30,31,30,31]        \\n            md = sum(month[:m-1])\\n            if y % 4 == 0 and y != 2100 and m > 2:\\n                md += 1\\n            \\n            return yd + md + d\\n\\t\\t\\t\\n        y1 = int(date1[:4])\\n        m1 = int(date1[5:7])\\n        d1 = int(date1[8:])\\n\\t\\t\\n        y2 = int(date2[:4])\\n        m2 = int(date2[5:7])\\n        d2 = int(date2[8:])\\n\\t\\t\\n        days1 = day(y1, m1, d1)\\n        days2 = day(y2, m2, d2)\\n\\t\\t\\n        return abs(days1-days2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009094,
                "title": "java-most-intuitive-solution-no-built-in-library-1ms-faster-than-97-32",
                "content": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n        return (int)Math.abs(\\n            daysFrom1971(Integer.parseInt(d1[0]), Integer.parseInt(d1[1]), Integer.parseInt(d1[2]))\\n            - daysFrom1971(Integer.parseInt(d2[0]), Integer.parseInt(d2[1]), Integer.parseInt(d2[2])));\\n    }\\n    private int daysFrom1971(int year, int month, int day) {\\n        int total = 0;\\n\\t\\t// count years first\\n        total += (year - 1971) * 365;\\n        for (int i = 1972; i < year; i += 4) {\\n            if (isLeapYear(i)) total++;\\n        }        \\n        int feb = isLeapYear(year) ? 29 : 28;\\n\\t\\t// sum months and days\\n        switch (month) {\\n            case 12: \\n                total += 30; // 11\\n            case 11:\\n                total += 31; // 10\\n            case 10: \\n                total += 30; // 9\\n            case 9:\\n                total += 31; // 8\\n            case 8:\\n                total += 31; // 7\\n            case 7: \\n                total += 30; // 6\\n            case 6:\\n                total += 31; // 5\\n            case 5:\\n                total += 30; // 4\\n            case 4: \\n                total += 31; // 3\\n            case 3: \\n                total += feb; // 2\\n            case 2:\\n                total += 31;\\n            case 1:\\n                total += day;                \\n        }\\n        return total;\\n    }\\n    private boolean isLeapYear(int i) {\\n        return (i % 4 == 0) && ((i % 100 == 0 && i % 400 == 0) || i % 100 != 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n        return (int)Math.abs(\\n            daysFrom1971(Integer.parseInt(d1[0]), Integer.parseInt(d1[1]), Integer.parseInt(d1[2]))\\n            - daysFrom1971(Integer.parseInt(d2[0]), Integer.parseInt(d2[1]), Integer.parseInt(d2[2])));\\n    }\\n    private int daysFrom1971(int year, int month, int day) {\\n        int total = 0;\\n\\t\\t// count years first\\n        total += (year - 1971) * 365;\\n        for (int i = 1972; i < year; i += 4) {\\n            if (isLeapYear(i)) total++;\\n        }        \\n        int feb = isLeapYear(year) ? 29 : 28;\\n\\t\\t// sum months and days\\n        switch (month) {\\n            case 12: \\n                total += 30; // 11\\n            case 11:\\n                total += 31; // 10\\n            case 10: \\n                total += 30; // 9\\n            case 9:\\n                total += 31; // 8\\n            case 8:\\n                total += 31; // 7\\n            case 7: \\n                total += 30; // 6\\n            case 6:\\n                total += 31; // 5\\n            case 5:\\n                total += 30; // 4\\n            case 4: \\n                total += 31; // 3\\n            case 3: \\n                total += feb; // 2\\n            case 2:\\n                total += 31;\\n            case 1:\\n                total += day;                \\n        }\\n        return total;\\n    }\\n    private boolean isLeapYear(int i) {\\n        return (i % 4 == 0) && ((i % 100 == 0 && i % 400 == 0) || i % 100 != 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828333,
                "title": "java-split-in-functions",
                "content": "```\\nclass Solution {\\n    int[] daysPerMonth = new int[] {31,28,31,30,31,30,31,31,30,31,30,31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        \\n        return Math.abs(daysFrom1971(date1)- daysFrom1971(date2));\\n    }\\n    public int daysFrom1971(String date) {\\n        \\n        String[] dateArray = date.split(\"-\");\\n        int year = Integer.parseInt(dateArray[0]);\\n        int month = Integer.parseInt(dateArray[1]);\\n        int day = Integer.parseInt(dateArray[2]);\\n        \\n        int yearsFrom1971 = year - 1971;\\n    \\n        boolean isLeap = (year%4==0 &&(year % 100 != 0 || year %400 == 0));\\n        \\n        if(month>2 && isLeap) day++;\\n        \\n        for(int m = 1; m < month;m++)\\n            day+=daysPerMonth[m-1];\\n        \\n        return day + yearsFrom1971*365 + countLeapYears(year);\\n    }\\n    public int countLeapYears(int year) {\\n        int count = 0;\\n        for(int y = 1971; y < year; y++) {\\n            if(y%4==0 &&(y % 100 != 0 || y %400 == 0))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] daysPerMonth = new int[] {31,28,31,30,31,30,31,31,30,31,30,31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        \\n        return Math.abs(daysFrom1971(date1)- daysFrom1971(date2));\\n    }\\n    public int daysFrom1971(String date) {\\n        \\n        String[] dateArray = date.split(\"-\");\\n        int year = Integer.parseInt(dateArray[0]);\\n        int month = Integer.parseInt(dateArray[1]);\\n        int day = Integer.parseInt(dateArray[2]);\\n        \\n        int yearsFrom1971 = year - 1971;\\n    \\n        boolean isLeap = (year%4==0 &&(year % 100 != 0 || year %400 == 0));\\n        \\n        if(month>2 && isLeap) day++;\\n        \\n        for(int m = 1; m < month;m++)\\n            day+=daysPerMonth[m-1];\\n        \\n        return day + yearsFrom1971*365 + countLeapYears(year);\\n    }\\n    public int countLeapYears(int year) {\\n        int count = 0;\\n        for(int y = 1971; y < year; y++) {\\n            if(y%4==0 &&(y % 100 != 0 || y %400 == 0))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814530,
                "title": "python3-solution-from-scratch-not-using-datetime",
                "content": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        def f_date(date): # calculates days passed since \\'1900-01-01\\'\\n            year0 = \\'1900\\'\\n            year1, month1, day1 = date.split(\\'-\\')\\n                        \\n            days = 0\\n            for y in range(int(year0), int(year1)):\\n                days += 365\\n                if y%100 == 0:\\n                    if y%400 == 0:\\n                        days += 1\\n                else:\\n                    if y%4 == 0:\\n                        days += 1\\n                        \\n            for m in range(int(month1)):\\n                if m in [1, 3, 5, 7, 8, 10, 12]:\\n                    days += 31\\n                if m in [4, 6, 9, 11]:\\n                    days += 30\\n                if m == 2:\\n                    days += 28\\n                    if int(year1)%100 == 0:\\n                        if int(year1)%400 == 0:\\n                            days += 1\\n                    else:\\n                        if int(year1)%4 ==0:\\n                            days += 1\\n            days += int(day1)\\n            return days\\n\\t\\t\\t\\n        return abs(f_date(date1) - f_date(date2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        def f_date(date): # calculates days passed since \\'1900-01-01\\'\\n            year0 = \\'1900\\'\\n            year1, month1, day1 = date.split(\\'-\\')\\n                        \\n            days = 0\\n            for y in range(int(year0), int(year1)):\\n                days += 365\\n                if y%100 == 0:\\n                    if y%400 == 0:\\n                        days += 1\\n                else:\\n                    if y%4 == 0:\\n                        days += 1\\n                        \\n            for m in range(int(month1)):\\n                if m in [1, 3, 5, 7, 8, 10, 12]:\\n                    days += 31\\n                if m in [4, 6, 9, 11]:\\n                    days += 30\\n                if m == 2:\\n                    days += 28\\n                    if int(year1)%100 == 0:\\n                        if int(year1)%400 == 0:\\n                            days += 1\\n                    else:\\n                        if int(year1)%4 ==0:\\n                            days += 1\\n            days += int(day1)\\n            return days\\n\\t\\t\\t\\n        return abs(f_date(date1) - f_date(date2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085753,
                "title": "python3-modular-solution-no-built-in-library",
                "content": "IMO, any use of built-in date library would be cheating. Should not need to do that. Just break a large function into multiple smaller ones - easy to maintain and absolutely pythonic. \\n\\n```python\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        [date1,date2] = sorted([date1,date2])\\n        y1,m1,d1 = list(map(int,date1.split(\\'-\\')))\\n        y2,m2,d2 = list(map(int,date2.split(\\'-\\')))\\n        self.day31 = {1,3,5,7,8,10,12}\\n        if y1==y2:\\n            return self.get_day(y2,m2,d2) - self.get_day(y1,m1,d1)\\n        else:\\n            sm = self.day_of_year(y1) - self.get_day(y1,m1,d1)\\n            sm += self.get_day(y2,m2,d2)\\n            for y in range(y1+1,y2):\\n                sm += self.day_of_year(y)\\n            return sm\\n\\n    def get_day(self, year, month, day):\\n        sm = 0\\n        for m in range(1,month):\\n            sm += self.day_of_month(year,m)\\n        sm += day\\n        return sm\\n\\n    def day_of_month(self,year,month):\\n        if month in self.day31:\\n            return 31\\n        elif month == 2:\\n            if self.day_of_year(year)==366:\\n                return 29\\n            else:\\n                return 28\\n        else:\\n            return 30\\n\\n    def day_of_year(self,year):\\n        if year%100==0:\\n            if year%400==0:\\n                return 366\\n            else:\\n                return 365\\n        else:\\n            if year%4==0:\\n                return 366\\n            else:\\n                return 365\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        [date1,date2] = sorted([date1,date2])\\n        y1,m1,d1 = list(map(int,date1.split(\\'-\\')))\\n        y2,m2,d2 = list(map(int,date2.split(\\'-\\')))\\n        self.day31 = {1,3,5,7,8,10,12}\\n        if y1==y2:\\n            return self.get_day(y2,m2,d2) - self.get_day(y1,m1,d1)\\n        else:\\n            sm = self.day_of_year(y1) - self.get_day(y1,m1,d1)\\n            sm += self.get_day(y2,m2,d2)\\n            for y in range(y1+1,y2):\\n                sm += self.day_of_year(y)\\n            return sm\\n\\n    def get_day(self, year, month, day):\\n        sm = 0\\n        for m in range(1,month):\\n            sm += self.day_of_month(year,m)\\n        sm += day\\n        return sm\\n\\n    def day_of_month(self,year,month):\\n        if month in self.day31:\\n            return 31\\n        elif month == 2:\\n            if self.day_of_year(year)==366:\\n                return 29\\n            else:\\n                return 28\\n        else:\\n            return 30\\n\\n    def day_of_year(self,year):\\n        if year%100==0:\\n            if year%400==0:\\n                return 366\\n            else:\\n                return 365\\n        else:\\n            if year%4==0:\\n                return 366\\n            else:\\n                return 365\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055234,
                "title": "python3-no-formula-simple-solution",
                "content": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        leap = lambda x: (x % 400 == 0) or (x % 100 and x % 4 == 0)\\n        days = [31,28,31,30,31,30,31,31,30,31,30,31]\\n                \\n        def f(date):\\n            y, m, d = map(int, date.split(\\'-\\'))\\n            x = 365 * (y - 1971) + sum(map(leap, range(1971, y)))\\n            return x + sum(days[:m-1]) + d + (m > 2 and leap(y))\\n        \\n        return abs(f(date1) - f(date2))\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        leap = lambda x: (x % 400 == 0) or (x % 100 and x % 4 == 0)\\n        days = [31,28,31,30,31,30,31,31,30,31,30,31]\\n                \\n        def f(date):\\n            y, m, d = map(int, date.split(\\'-\\'))\\n            x = 365 * (y - 1971) + sum(map(leap, range(1971, y)))\\n            return x + sum(days[:m-1]) + d + (m > 2 and leap(y))\\n        \\n        return abs(f(date1) - f(date2))\\n",
                "codeTag": "Java"
            },
            {
                "id": 859057,
                "title": "o-1-time-o-1-space-very-intuitive-with-lots-of-comments-only-few-lines",
                "content": "The simple approach would be to count number of days elapsed from a common starting day for both the dates and then take difference between the two.\\n\\nThe number of days is a **simple addition** of the following components:\\n- Number of days completed by end of last year (ie. 31st December of last year): This can be computed by simply\\u2020\\u2020 multiplying `365` by `y - 1` (where `y` is the current year).\\n- Number of days from beginning of current year and by end of last month: This can be obtained by doing a pre-computation of cumulative number of days for each month.\\n- Days completed in the current month: This is just `d - 1`\\n\\n\\u2020\\u2020 Note: There are 2 things which make the calculations complicated:\\n- Computation of leap year: We need to add 1 day for each leap year. This can be done by adding 1 for all years divisible by 4, not divisible by 100, but divisible by 400.\\n- Leap year happening in current year or not: This is a simple `if` condition to not include current year if the month has not yet reached February!\\n\\n```\\n\\n# Find cumulative sum of days. This can be computed as:\\n# import itertools\\n# months = list(itertools.accumulate([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], initial=0))\\nmonths = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\\n\\n# Get date parts tuple (y, m, d) starting with 0\\n# Hence, for example, m ranges from 0 to 11 inclusive.\\ndef getDate(date):\\n    y, m, d = date.split(\\'-\\')\\n    return int(y)-1, int(m)-1, int(d)-1\\n\\n# Given date parts, find how many days has elapsed.\\ndef getDays(y, m, d):\\n    \\n    # Compute number of leap years.\\n    # Also include current year in this computation\\n    # if the current month is March or later.\\n    ym = y+1 if m >= 2 else y\\n    leap = ym//4 - ym//100 + ym//400\\n    \\n    # Compute number of days.\\n    return 365*y + months[m] + d + leap\\n    \\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        days1 = getDays(*getDate(date1))\\n        days2 = getDays(*getDate(date2))\\n        return abs(days1 - days2)\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Find cumulative sum of days. This can be computed as:\\n# import itertools\\n# months = list(itertools.accumulate([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], initial=0))\\nmonths = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\\n\\n# Get date parts tuple (y, m, d) starting with 0\\n# Hence, for example, m ranges from 0 to 11 inclusive.\\ndef getDate(date):\\n    y, m, d = date.split(\\'-\\')\\n    return int(y)-1, int(m)-1, int(d)-1\\n\\n# Given date parts, find how many days has elapsed.\\ndef getDays(y, m, d):\\n    \\n    # Compute number of leap years.\\n    # Also include current year in this computation\\n    # if the current month is March or later.\\n    ym = y+1 if m >= 2 else y\\n    leap = ym//4 - ym//100 + ym//400\\n    \\n    # Compute number of days.\\n    return 365*y + months[m] + d + leap\\n    \\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        days1 = getDays(*getDate(date1))\\n        days2 = getDays(*getDate(date2))\\n        return abs(days1 - days2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527796,
                "title": "c-broken-out-into-simple-helper-functions",
                "content": "I\\'m just gonna say this is horrible. Either you memorised the detailed rules on leap years beforehand or you didn\\'t. I didn\\'t.\\n\\n# Algorithm\\nPull out the year, month, day as integers and then turn them into days\\nsince 1971-01-01.\\nSubtract one day count from the other.\\n\\n# Code\\nThe overall algorithm is simple:\\n```c++\\nstatic int daysBetweenDates(\\n\\tconst string_view date1,\\n\\tconst string_view date2)\\n{\\n\\tconst int days1 = readDateToDays(date1);\\n\\tconst int days2 = readDateToDays(date2);\\n\\n\\treturn abs(days2 - days1);\\n}\\n```\\n\\nA key detail is the definition of a leap year:\\n```c++\\nconstexpr bool isLeap(const unsigned year)\\n{\\n\\tif(year % 4) return false;\\n\\tif(year % 100 == 0){\\n\\t\\tif(year % 400 == 0) return true;\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n```\\n\\n## Full Listing\\n\\n```c++\\nnamespace\\n{\\n    tuple<unsigned,unsigned,unsigned> readDate(const string_view date)\\n    {\\n        unsigned year = 0, month = 0, day = 0;\\n        from_chars<unsigned>(&date[0], &date[4],  year);\\n        from_chars<unsigned>(&date[5], &date[7],  month);\\n        from_chars<unsigned>(&date[8], &date[10], day);\\n        \\n        return {year, month, day};\\n    }\\n    \\n    /// @ return Whether a year is a leap year.\\n    constexpr bool isLeap(const unsigned year)\\n    {\\n        if(year % 4) return false;\\n        if(year % 100 == 0){\\n            if(year % 400 == 0) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    constexpr unsigned yearsToDays(const unsigned year)\\n    {\\n        uint64_t days = 0;\\n        for(unsigned y = 1971; y < year; ++y)\\n        {\\n            days += 365u;\\n            if(isLeap(y)) days += 1u;\\n        }\\n        return days;\\n    }\\n    \\n    unsigned monthsToDays(const unsigned month, const bool leap)\\n    {\\n        static const uint8_t monthDays[11][2]{\\n            {31,31},\\n            {28,29},\\n            {31,31},\\n            {30,30},\\n            {31,31},\\n            {30,30},\\n            {31,31},\\n            {31,31},\\n            {30,30},\\n            {31,31},\\n            {30,30}\\n        };\\n        unsigned days = 0;\\n        for(unsigned m = 0; m < month-1; ++m)\\n        {\\n            days += monthDays[m][leap];\\n        }\\n        return days;\\n    }\\n    \\n    /// @return days since epoch.\\n    unsigned dateToDays(const unsigned year, const unsigned month, const unsigned day)\\n    {\\n        unsigned days = yearsToDays(year);\\n        days += monthsToDays(month, isLeap(year));\\n        days += day - 1u;\\n        return days;\\n    }\\n    \\n    unsigned readDateToDays(const string_view date)\\n    {\\n        const auto [year, month, day] = readDate(date);\\n        return dateToDays(year, month, day);\\n    }\\n    \\n    class Solution {\\n    public:\\n        \\n        static int daysBetweenDates(const string_view date1, const string_view date2)\\n        {\\n            const int days1 = readDateToDays(date1);\\n            const int days2 = readDateToDays(date2);\\n            \\n            return abs(days2 - days1);\\n        }\\n\\t}\\n\\t\\n\\tstatic const auto fast=[](){ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return nullptr;}();\\n}\\n```\\n\\n# Testcases\\nGive these a try before submitting:\\n```\\n\"2019-06-29\"\\n\"2019-06-30\"\\n\"2019-06-30\"\\n\"2019-06-29\"\\n\"1971-01-01\"\\n\"1971-01-01\"\\n\"1971-01-01\"\\n\"2100-01-01\"\\n\"1991-03-12\"\\n\"2000-03-22\"\\n\"1991-03-12\"\\n\"2100-03-22\"\\n\"1991-03-12\"\\n\"2100-02-22\"\\n\"1991-03-12\"\\n\"2100-04-22\"\\n\"1991-03-12\"\\n\"2100-08-22\"\\n\"1991-03-12\"\\n\"2100-01-22\"\\n\"1991-03-12\"\\n\"2099-09-22\"\\n\"1991-03-12\"\\n\"2000-09-22\"\\n\"1991-03-12\"\\n\"2100-09-22\"\\n\"2100-09-22\"\\n\"1991-03-12\"\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nstatic int daysBetweenDates(\\n\\tconst string_view date1,\\n\\tconst string_view date2)\\n{\\n\\tconst int days1 = readDateToDays(date1);\\n\\tconst int days2 = readDateToDays(date2);\\n\\n\\treturn abs(days2 - days1);\\n}\\n```\n```c++\\nconstexpr bool isLeap(const unsigned year)\\n{\\n\\tif(year % 4) return false;\\n\\tif(year % 100 == 0){\\n\\t\\tif(year % 400 == 0) return true;\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n```\n```c++\\nnamespace\\n{\\n    tuple<unsigned,unsigned,unsigned> readDate(const string_view date)\\n    {\\n        unsigned year = 0, month = 0, day = 0;\\n        from_chars<unsigned>(&date[0], &date[4],  year);\\n        from_chars<unsigned>(&date[5], &date[7],  month);\\n        from_chars<unsigned>(&date[8], &date[10], day);\\n        \\n        return {year, month, day};\\n    }\\n    \\n    /// @ return Whether a year is a leap year.\\n    constexpr bool isLeap(const unsigned year)\\n    {\\n        if(year % 4) return false;\\n        if(year % 100 == 0){\\n            if(year % 400 == 0) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    constexpr unsigned yearsToDays(const unsigned year)\\n    {\\n        uint64_t days = 0;\\n        for(unsigned y = 1971; y < year; ++y)\\n        {\\n            days += 365u;\\n            if(isLeap(y)) days += 1u;\\n        }\\n        return days;\\n    }\\n    \\n    unsigned monthsToDays(const unsigned month, const bool leap)\\n    {\\n        static const uint8_t monthDays[11][2]{\\n            {31,31},\\n            {28,29},\\n            {31,31},\\n            {30,30},\\n            {31,31},\\n            {30,30},\\n            {31,31},\\n            {31,31},\\n            {30,30},\\n            {31,31},\\n            {30,30}\\n        };\\n        unsigned days = 0;\\n        for(unsigned m = 0; m < month-1; ++m)\\n        {\\n            days += monthDays[m][leap];\\n        }\\n        return days;\\n    }\\n    \\n    /// @return days since epoch.\\n    unsigned dateToDays(const unsigned year, const unsigned month, const unsigned day)\\n    {\\n        unsigned days = yearsToDays(year);\\n        days += monthsToDays(month, isLeap(year));\\n        days += day - 1u;\\n        return days;\\n    }\\n    \\n    unsigned readDateToDays(const string_view date)\\n    {\\n        const auto [year, month, day] = readDate(date);\\n        return dateToDays(year, month, day);\\n    }\\n    \\n    class Solution {\\n    public:\\n        \\n        static int daysBetweenDates(const string_view date1, const string_view date2)\\n        {\\n            const int days1 = readDateToDays(date1);\\n            const int days2 = readDateToDays(date2);\\n            \\n            return abs(days2 - days1);\\n        }\\n\\t}\\n\\t\\n\\tstatic const auto fast=[](){ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return nullptr;}();\\n}\\n```\n```\\n\"2019-06-29\"\\n\"2019-06-30\"\\n\"2019-06-30\"\\n\"2019-06-29\"\\n\"1971-01-01\"\\n\"1971-01-01\"\\n\"1971-01-01\"\\n\"2100-01-01\"\\n\"1991-03-12\"\\n\"2000-03-22\"\\n\"1991-03-12\"\\n\"2100-03-22\"\\n\"1991-03-12\"\\n\"2100-02-22\"\\n\"1991-03-12\"\\n\"2100-04-22\"\\n\"1991-03-12\"\\n\"2100-08-22\"\\n\"1991-03-12\"\\n\"2100-01-22\"\\n\"1991-03-12\"\\n\"2099-09-22\"\\n\"1991-03-12\"\\n\"2000-09-22\"\\n\"1991-03-12\"\\n\"2100-09-22\"\\n\"2100-09-22\"\\n\"1991-03-12\"\\n```",
                "codeTag": "C++"
            },
            {
                "id": 519487,
                "title": "an-easier-c-solution",
                "content": "parse the dates and note the epoch times.\\nepoch time is the number of seconds passed since 1970 till now.\\nsubstract the two and divide by 86400 (number of seconds in one day).\\n\\n```\\n    int daysBetweenDates(string date1, string date2) {\\n        stringstream ss(date1+\"-\"+date2);\\n        int year, month, day;\\n        char hyphen;\\n\\n        //parse the first date\\n        ss>>year>>hyphen>>month>>hyphen>>day;\\n        struct tm starttm= {  0, 0, 0, day, month - 1, year - 1900 };\\n        time_t start = mktime(&starttm);\\n\\n        //parse the second date\\n        ss>>hyphen>>year>>hyphen>>month>>hyphen>>day;\\n        struct tm endtm= {  0, 0, 0, day, month - 1, year - 1900};\\n        time_t end = mktime(&endtm);\\n\\n        return abs(end-start)/86400;\\n    }\\n``",
                "solutionTags": [],
                "code": "parse the dates and note the epoch times.\\nepoch time is the number of seconds passed since 1970 till now.\\nsubstract the two and divide by 86400 (number of seconds in one day).\\n\\n```\\n    int daysBetweenDates(string date1, string date2) {\\n        stringstream ss(date1+\"-\"+date2);\\n        int year, month, day;\\n        char hyphen;\\n\\n        //parse the first date\\n        ss>>year>>hyphen>>month>>hyphen>>day;\\n        struct tm starttm= {  0, 0, 0, day, month - 1, year - 1900 };\\n        time_t start = mktime(&starttm);\\n\\n        //parse the second date\\n        ss>>hyphen>>year>>hyphen>>month>>hyphen>>day;\\n        struct tm endtm= {  0, 0, 0, day, month - 1, year - 1900};\\n        time_t end = mktime(&endtm);\\n\\n        return abs(end-start)/86400;\\n    }\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 517573,
                "title": "python-using-datetime",
                "content": "```\\nfrom datetime import date\\n\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        date1 = list(map(int, date1.split(\\'-\\')))\\n        date2 = list(map(int, date2.split(\\'-\\')))\\n        \\n        one = date(date1[0], date1[1], date1[2])\\n        two =  date(date2[0], date2[1], date2[2])\\n        delta = one - two\\n        \\n        return(abs(delta.days))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom datetime import date\\n\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        date1 = list(map(int, date1.split(\\'-\\')))\\n        date2 = list(map(int, date2.split(\\'-\\')))\\n        \\n        one = date(date1[0], date1[1], date1[2])\\n        two =  date(date2[0], date2[1], date2[2])\\n        delta = one - two\\n        \\n        return(abs(delta.days))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608235,
                "title": "c-100-faster-than-alll-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int days[12]= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    bool isLeap(int y){\\n        return y%4==0 and (y%100!=0 || y%400==0);\\n    }\\n    \\n    int daysfrom1971(string s){\\n        int y = stoi(s.substr(0,4)) , m = stoi(s.substr(5,2)) , d = stoi(s.substr(8));\\n        \\n        for(int iy =1971;iy<y;iy++){\\n            d+=(isLeap(iy)?366:365);\\n        }\\n        return d + (m>2 and isLeap(y)) + accumulate(begin(days), begin(days)+m-1,0);\\n    }\\n    \\n    int daysBetweenDates(string date1, string date2) {\\n            \\n        int d1 = daysfrom1971(date1) , d2 = daysfrom1971(date2);\\n    \\n        return abs(d2-d1);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int days[12]= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2583566,
                "title": "c-0-ms-100-00-faster-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLeap(int year){\\n        return (year%4==0 && year%100!=0) || year%400==0;\\n    }\\n    int daysInMonth(int month,int year){\\n        if(month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12) return 31;\\n        if(month==2) return isLeap(year)?29:28;\\n        return 30;\\n    }\\n    \\n    int days(string date){\\n        int Y=stoi(date.substr(0,4));\\n        int M=stoi(date.substr(5,2));\\n        int D=stoi(date.substr(8,2));\\n        int day=0;\\n        for(int y=1971;y<Y;y++) day+=isLeap(y)?366:365;\\n        for(int m=1;m<M;m++) day+=daysInMonth(m,Y);\\n        return day+D;\\n    }\\n    \\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(days(date1)-days(date2));\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLeap(int year){\\n        return (year%4==0 && year%100!=0) || year%400==0;\\n    }\\n    int daysInMonth(int month,int year){\\n        if(month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12) return 31;\\n        if(month==2) return isLeap(year)?29:28;\\n        return 30;\\n    }\\n    \\n    int days(string date){\\n        int Y=stoi(date.substr(0,4));\\n        int M=stoi(date.substr(5,2));\\n        int D=stoi(date.substr(8,2));\\n        int day=0;\\n        for(int y=1971;y<Y;y++) day+=isLeap(y)?366:365;\\n        for(int m=1;m<M;m++) day+=daysInMonth(m,Y);\\n        return day+D;\\n    }\\n    \\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(days(date1)-days(date2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947547,
                "title": "time-o-1-space-o-1",
                "content": "In interviews, no matter how idiotic the question is, unfortunately interviewer expects optimized version.\\nHere is the most optimized version solution.\\nTime = O(1), Space = O(1)\\n\\nPlease upvote if you like the solution.\\n\\n```\\nclass Solution\\n{\\n    public:\\n    vector<int> daysOfMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int daysBetweenDates(string date1, string date2)\\n    {        \\n        return abs(daysFromZero(date1) - daysFromZero(date2));\\n    }\\n    \\n    int daysFromZero(string date)\\n    {\\n        int y = stoi(date.substr(0,4));\\n        int m = stoi(date.substr(5,2));\\n        int d = stoi(date.substr(8,2));\\n        \\n        for (int i=0; i<m-1; i++)\\n            d += daysOfMonth[i];\\n        \\n        if (m>2 && isLeapYear(y))\\n            d++;\\n        \\n        d += 365*y + countLeapYearsSoFar(y-1);\\n        \\n        return d;\\n    }\\n    \\n    bool isLeapYear(int y)\\n    {\\n        return (y % 4 == 0) && (y % 100 != 0 || y % 400 == 0);\\n    }\\n    \\n    int countLeapYearsSoFar(int y)\\n    {\\n        return floor(y/4) - floor(y/100) + floor(y/400);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<int> daysOfMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int daysBetweenDates(string date1, string date2)\\n    {        \\n        return abs(daysFromZero(date1) - daysFromZero(date2));\\n    }\\n    \\n    int daysFromZero(string date)\\n    {\\n        int y = stoi(date.substr(0,4));\\n        int m = stoi(date.substr(5,2));\\n        int d = stoi(date.substr(8,2));\\n        \\n        for (int i=0; i<m-1; i++)\\n            d += daysOfMonth[i];\\n        \\n        if (m>2 && isLeapYear(y))\\n            d++;\\n        \\n        d += 365*y + countLeapYearsSoFar(y-1);\\n        \\n        return d;\\n    }\\n    \\n    bool isLeapYear(int y)\\n    {\\n        return (y % 4 == 0) && (y % 100 != 0 || y % 400 == 0);\\n    }\\n    \\n    int countLeapYearsSoFar(int y)\\n    {\\n        return floor(y/4) - floor(y/100) + floor(y/400);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782483,
                "title": "1-line-python-solution-faster-than-85-30-ms-memory-less-than-80",
                "content": "```\\ndef daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs((date.fromisoformat(date2) - date.fromisoformat(date1)).days)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs((date.fromisoformat(date2) - date.fromisoformat(date1)).days)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1643732,
                "title": "java-0ms-count-from-1971-prefix-sum-explained",
                "content": "A year is a leap year when the following conditions are met: \\n1. It is divisible by 4\\n2. BUT it is not divisible by 100\\n3. EXCEPT when it is divisble by 400\\n\\nThis translates to \\n```Java\\nreturn y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);\\n```\\n\\nTerrible question, I know, no one likes those \"Number of Days / Weeks\" type of questions as shown by the disklike to like ratio.\\n\\nIt\\'d be easier to get the difference between two dates if we calculate its difference to a certain fixed point in time. We\\'d use the beginning of 1971 in my code below. We can also use prefix sum to speed things up for looking up the total days before a certain month. Implementation detail can be found in the code below as well. \\n\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(getDays(date1) - getDays(date2));\\n    }\\n\\n    private static int getDays(String s){\\n        int y = Integer.parseInt(s.substring(0, 4));\\n        int m = Integer.parseInt(s.substring(5, 7));\\n        int d = Integer.parseInt(s.substring(8, 10));\\n        int[] prefix = new int[]{0, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for (int i = 2; i <= 13; i++) prefix[i] += prefix[i - 1];\\n        int ans = (y - 1971) * 365 + prefix[m] + d;\\n        for (int i = 1972; i < y; i+=4)\\n            if (isLeap(i))\\n                ans++;\\n        if (isLeap(y) && m > 2) ans++; //don\\'t include this within the for loop because m > 2 for it to count.\\n\\n        return ans;\\n    }\\n\\n    private static boolean isLeap(int y){\\n        return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```Java\\nreturn y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);\\n```\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(getDays(date1) - getDays(date2));\\n    }\\n\\n    private static int getDays(String s){\\n        int y = Integer.parseInt(s.substring(0, 4));\\n        int m = Integer.parseInt(s.substring(5, 7));\\n        int d = Integer.parseInt(s.substring(8, 10));\\n        int[] prefix = new int[]{0, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for (int i = 2; i <= 13; i++) prefix[i] += prefix[i - 1];\\n        int ans = (y - 1971) * 365 + prefix[m] + d;\\n        for (int i = 1972; i < y; i+=4)\\n            if (isLeap(i))\\n                ans++;\\n        if (isLeap(y) && m > 2) ans++; //don\\'t include this within the for loop because m > 2 for it to count.\\n\\n        return ans;\\n    }\\n\\n    private static boolean isLeap(int y){\\n        return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804918,
                "title": "c-12-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(Date(date2).toInt() - Date(date1).toInt());\\n    }\\n    \\n    struct Date{\\n        Date(string s) : ymd(stoi(s.substr(0, 4)), stoi(s.substr(5, 2)), stoi(s.substr(8, 2))){}\\n        \\n        int toInt() const { // date from 19710101\\n            const auto [y, m, d] = ymd;\\n            int res = 0;\\n            for(int y0=1971; y0<y; y0++) res += 365 + (y0%4 == 0) - (y0%100 == 0) + (y0%400 == 0);\\n            for(int m0=1; m0<m; m0++) res += month[m0-1];\\n            if(m >2 && (y%4 == 0) - (y%100 == 0) + (y%400 == 0)) res++;            \\n            return res+d;\\n        }\\n        \\n        const tuple<int,int,int> ymd;\\n        const vector<int> month = {{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};\\n    };  \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(Date(date2).toInt() - Date(date1).toInt());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 551181,
                "title": "python-cheat-function",
                "content": "```\\nclass Solution(object):\\n    def daysBetweenDates(self, date1, date2):\\n        \"\"\"\\n        :type date1: str\\n        :type date2: str\\n        :rtype: int\\n        \"\"\"\\n        y1, m1, d1 = map(int, date1.split(\\'-\\'))\\n        y2, m2, d2 = map(int, date2.split(\\'-\\'))\\n        return abs(int((datetime.datetime(y1,m1,d1)- datetime.datetime(y2,m2,d2)).days))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def daysBetweenDates(self, date1, date2):\\n        \"\"\"\\n        :type date1: str\\n        :type date2: str\\n        :rtype: int\\n        \"\"\"\\n        y1, m1, d1 = map(int, date1.split(\\'-\\'))\\n        y2, m2, d2 = map(int, date2.split(\\'-\\'))\\n        return abs(int((datetime.datetime(y1,m1,d1)- datetime.datetime(y2,m2,d2)).days))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525862,
                "title": "my-swift-solution",
                "content": "My Swift solution\\n```\\nclass Solution {\\n    func daysBetweenDates(_ date1: String, _ date2: String) -> Int {\\n\\n        func isLeapYear(_ year: Int) -> Bool {\\n            return year % 4 == 0 ? (year % 100 == 0 ? (year % 400 == 0 ? true : false) : true) : false\\n        }\\n\\n        func daysSince1970(_ date: String) -> Int {\\n            let dateParts = date.split(separator: \"-\"), year = Int(dateParts[0]) ?? 0, month = Int(dateParts[1]) ?? 0, day = Int(dateParts[2]) ?? 0\\n            var days: Int = day\\n            for i in 1..<month {\\n                switch i {\\n                    case 1, 3, 5, 7, 8, 10, 12: days += 31\\n                    case 4, 6, 9, 11: days += 30\\n                    case 2: days += isLeapYear(year) ? 29 : 28\\n                    default: days += 0\\n                }\\n            }\\n            for i in 1971..<year {\\n                days += isLeapYear(i) ? 366 : 365\\n            }\\n            return days\\n        }\\n\\n        return abs(daysSince1970(date1) - daysSince1970(date2))\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func daysBetweenDates(_ date1: String, _ date2: String) -> Int {\\n\\n        func isLeapYear(_ year: Int) -> Bool {\\n            return year % 4 == 0 ? (year % 100 == 0 ? (year % 400 == 0 ? true : false) : true) : false\\n        }\\n\\n        func daysSince1970(_ date: String) -> Int {\\n            let dateParts = date.split(separator: \"-\"), year = Int(dateParts[0]) ?? 0, month = Int(dateParts[1]) ?? 0, day = Int(dateParts[2]) ?? 0\\n            var days: Int = day\\n            for i in 1..<month {\\n                switch i {\\n                    case 1, 3, 5, 7, 8, 10, 12: days += 31\\n                    case 4, 6, 9, 11: days += 30\\n                    case 2: days += isLeapYear(year) ? 29 : 28\\n                    default: days += 0\\n                }\\n            }\\n            for i in 1971..<year {\\n                days += isLeapYear(i) ? 366 : 365\\n            }\\n            return days\\n        }\\n\\n        return abs(daysSince1970(date1) - daysSince1970(date2))\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523956,
                "title": "simple-and-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        monthdays1 = [31, 28, 31, 30, 31, 30,  \\n                        31, 31, 30, 31, 30, 31 ]\\n        monthdays2= [31, 29, 31, 30, 31, 30,  \\n                        31, 31, 30, 31, 30, 31 ]\\n        dat1=date1.split(\\'-\\')\\n        dat2=date2.split(\\'-\\')\\n        year1,month1,day1=dat1[:]\\n        year2,month2,day2=dat2[:]\\n        def count(year,month,day):\\n            n=0\\n            for i in range(0,year):\\n                if leap(i):\\n                    n+=366\\n                else:\\n                    n+=365\\n            n+=day\\n            if leap(year):\\n                for i in range(0,month-1):\\n                    n+=monthdays2[i]\\n            else:\\n                for i in range(0,month-1):\\n                    n+=monthdays1[i]       \\n            return n\\n        def leap(year):\\n            if (year%4)==0:\\n                if (year%100==0):\\n                    if (year%400==0):\\n                        return True\\n                    else:\\n                        return False\\n                else:\\n                    return True\\n            else:\\n                return False\\n        y1=count(int(year1),int(month1),int(day1))\\n        y2=count(int(year2),int(month2),int(day2))\\n        return abs(y2-y1)\\n            \\n            \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        monthdays1 = [31, 28, 31, 30, 31, 30,  \\n                        31, 31, 30, 31, 30, 31 ]\\n        monthdays2= [31, 29, 31, 30, 31, 30,  \\n                        31, 31, 30, 31, 30, 31 ]\\n        dat1=date1.split(\\'-\\')\\n        dat2=date2.split(\\'-\\')\\n        year1,month1,day1=dat1[:]\\n        year2,month2,day2=dat2[:]\\n        def count(year,month,day):\\n            n=0\\n            for i in range(0,year):\\n                if leap(i):\\n                    n+=366\\n                else:\\n                    n+=365\\n            n+=day\\n            if leap(year):\\n                for i in range(0,month-1):\\n                    n+=monthdays2[i]\\n            else:\\n                for i in range(0,month-1):\\n                    n+=monthdays1[i]       \\n            return n\\n        def leap(year):\\n            if (year%4)==0:\\n                if (year%100==0):\\n                    if (year%400==0):\\n                        return True\\n                    else:\\n                        return False\\n                else:\\n                    return True\\n            else:\\n                return False\\n        y1=count(int(year1),int(month1),int(day1))\\n        y2=count(int(year2),int(month2),int(day2))\\n        return abs(y2-y1)\\n            \\n            \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 518248,
                "title": "readable-hard-code-js",
                "content": "\\n```JavaScript\\nconst isLeapYear = year => {\\n    if (year % 4 !== 0) return false;\\n    if (year % 100 !== 0) return true;\\n    if (year % 400 !== 0) return false;\\n    return true;\\n}\\n\\nconst daysInMonth = (month, year) => {\\n    const days = {\\n        1: 31,\\n        2: isLeapYear(year) ? 29 : 28,\\n        3: 31,\\n        4: 30,\\n        5: 31,\\n        6: 30,\\n        7: 31,\\n        8: 31,\\n        9: 30,\\n        10: 31,\\n        11: 30,\\n        12: 31,\\n    };\\n    return days[month];\\n}\\n\\nconst daysInYear = year => isLeapYear(year) ? 366 : 365;\\n\\nconst parseDay = (year, month, days) => {\\n    while (--month) {\\n        days += daysInMonth(month, year);\\n    }\\n    while (1970 < --year) {\\n        days += daysInYear(year);\\n    }\\n    return days;\\n}\\n\\nconst daysBetweenDates = (date1, date2) => {\\n    return Math.abs(\\n        parseDay(...date1.split(\\'-\\').map(Number)) - parseDay(...date2.split(\\'-\\').map(Number))\\n    );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\nconst isLeapYear = year => {\\n    if (year % 4 !== 0) return false;\\n    if (year % 100 !== 0) return true;\\n    if (year % 400 !== 0) return false;\\n    return true;\\n}\\n\\nconst daysInMonth = (month, year) => {\\n    const days = {\\n        1: 31,\\n        2: isLeapYear(year) ? 29 : 28,\\n        3: 31,\\n        4: 30,\\n        5: 31,\\n        6: 30,\\n        7: 31,\\n        8: 31,\\n        9: 30,\\n        10: 31,\\n        11: 30,\\n        12: 31,\\n    };\\n    return days[month];\\n}\\n\\nconst daysInYear = year => isLeapYear(year) ? 366 : 365;\\n\\nconst parseDay = (year, month, days) => {\\n    while (--month) {\\n        days += daysInMonth(month, year);\\n    }\\n    while (1970 < --year) {\\n        days += daysInYear(year);\\n    }\\n    return days;\\n}\\n\\nconst daysBetweenDates = (date1, date2) => {\\n    return Math.abs(\\n        parseDay(...date1.split(\\'-\\').map(Number)) - parseDay(...date2.split(\\'-\\').map(Number))\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517646,
                "title": "c-simple-date-calculator",
                "content": "Calculate the days in the both the dates and return the absolute difference between them.\\nFor days calculation keep in mind, leap year ands the month of february. Otherwise the code is pretty straight-forward.\\n\\n```\\nint mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\\nclass Solution {\\npublic:\\n    int get(string date)\\n    {\\n        int year=0,month=0,day=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            year=year*10+date[i]-\\'0\\';\\n        }\\n        for(int i=5;i<7;i++)\\n        {\\n            month=month*10+date[i]-\\'0\\';\\n        }\\n        for(int i=8;i<10;i++)\\n        {\\n            day=day*10+date[i]-\\'0\\';\\n        }\\n        int res=0;\\n        for(int i=1971;i<year;i++)\\n        {\\n            res=res+365;\\n            if((i%4==0&&i%100!=0)||i%400==0)res++;\\n        }\\n        for(int i=1;i<month;i++)\\n        {\\n            res=res+mon[i];\\n            if(i==2&&((year%4==0&&year%100!=0)||year%400==0))res++;\\n        }\\n        return res+day;\\n    }\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(get(date2)-get(date1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\\nclass Solution {\\npublic:\\n    int get(string date)\\n    {\\n        int year=0,month=0,day=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            year=year*10+date[i]-\\'0\\';\\n        }\\n        for(int i=5;i<7;i++)\\n        {\\n            month=month*10+date[i]-\\'0\\';\\n        }\\n        for(int i=8;i<10;i++)\\n        {\\n            day=day*10+date[i]-\\'0\\';\\n        }\\n        int res=0;\\n        for(int i=1971;i<year;i++)\\n        {\\n            res=res+365;\\n            if((i%4==0&&i%100!=0)||i%400==0)res++;\\n        }\\n        for(int i=1;i<month;i++)\\n        {\\n            res=res+mon[i];\\n            if(i==2&&((year%4==0&&year%100!=0)||year%400==0))res++;\\n        }\\n        return res+day;\\n    }\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(get(date2)-get(date1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517600,
                "title": "java-1-liner-use-api",
                "content": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.*;\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs((int)(ChronoUnit.DAYS.between(LocalDate.parse(date2), LocalDate.parse(date1))));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.*;\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs((int)(ChronoUnit.DAYS.between(LocalDate.parse(date2), LocalDate.parse(date1))));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886964,
                "title": "beat-100-c-junaid-bhai-ke-liye",
                "content": "![\\u2014Pngtree\\u2014janmashtami brush stroke frame with_8504820.png](https://assets.leetcode.com/users/images/afc14d84-5569-478d-884d-0156588fde72_1691597139.4658.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool leap(int year){\\n    if(year%4==0&&year%100!=0){\\n        return true;\\n    }\\n    else if(year%400==0){\\n        return true;\\n    }\\n    return false;\\n}\\nint month(int year,int m){\\n    vector<int>months(12,0);\\n    months[0]=31; \\n    if(leap(year)){\\n    months[1]=29; \\n    }\\n    else{\\n    months[1]=28;\\n    }\\n    months[2]=31;\\n    months[3]=30;\\n    months[4]=31;\\n    months[5]=30;\\n    months[6]=31;\\n    months[7]=31;\\n    months[8]=30;\\n    months[9]=31;\\n    months[10]=30;\\n    months[11]=31;\\n    return months[m];\\n}\\nint count_leap(int year,int sum){\\nint count_leap1=0;\\n    int leap_sum1=0;\\n    for(int i=1900;i<year;i+=4){\\n        if(leap(i)){\\n            leap_sum1+=366;\\n            count_leap1++;\\n        }\\n    }\\n    if(sum==1){\\n        return leap_sum1;\\n    }\\n    return count_leap1;\\n}\\nint rest(int year,int date,int m){\\n    int sum=0;\\n    for(int i=0;i<m-1;i++){\\n        int k=month(year,i);\\n        sum+=k;\\n    }\\n    sum+=date;\\n    return sum;\\n}\\n    int daysBetweenDates(string date1, string date2) {\\n         int year1=0,year2=0,day1=0,day2=0,month1=0,month2=0;\\n    for(int i=0;i<date1.size();i++){\\n        if(i<=3){\\n            year1=year1*10+date1[i]-\\'0\\';\\n            year2=year2*10+date2[i]-\\'0\\';\\n        }\\n        if(i>4&&i<=6){\\n            month1=month1*10+date1[i]-\\'0\\';\\n            month2=month2*10+date2[i]-\\'0\\';\\n        }\\n        if(i>7){\\n            day1=day1*10+date1[i]-\\'0\\';\\n            day2=day2*10+date2[i]-\\'0\\';\\n        }\\n    }\\n    int leap1=count_leap(year1,1);\\n    int non_leap1=(year1-1)-1900-count_leap(year1,0);\\n    non_leap1*=365;\\n    int non_leap2=(year2-1)-1900-count_leap(year2,0);\\n    non_leap2*=365;\\n    int leap2=count_leap(year2,1);\\n\\n\\n    int total1=leap1+non_leap1+rest(year1,day1,month1);\\n    int total2=leap2+non_leap2+rest(year2,day2,month2);\\n    return abs(total1-total2);\\n    }\\n};  \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool leap(int year){\\n    if(year%4==0&&year%100!=0){\\n        return true;\\n    }\\n    else if(year%400==0){\\n        return true;\\n    }\\n    return false;\\n}\\nint month(int year,int m){\\n    vector<int>months(12,0);\\n    months[0]=31; \\n    if(leap(year)){\\n    months[1]=29; \\n    }\\n    else{\\n    months[1]=28;\\n    }\\n    months[2]=31;\\n    months[3]=30;\\n    months[4]=31;\\n    months[5]=30;\\n    months[6]=31;\\n    months[7]=31;\\n    months[8]=30;\\n    months[9]=31;\\n    months[10]=30;\\n    months[11]=31;\\n    return months[m];\\n}\\nint count_leap(int year,int sum){\\nint count_leap1=0;\\n    int leap_sum1=0;\\n    for(int i=1900;i<year;i+=4){\\n        if(leap(i)){\\n            leap_sum1+=366;\\n            count_leap1++;\\n        }\\n    }\\n    if(sum==1){\\n        return leap_sum1;\\n    }\\n    return count_leap1;\\n}\\nint rest(int year,int date,int m){\\n    int sum=0;\\n    for(int i=0;i<m-1;i++){\\n        int k=month(year,i);\\n        sum+=k;\\n    }\\n    sum+=date;\\n    return sum;\\n}\\n    int daysBetweenDates(string date1, string date2) {\\n         int year1=0,year2=0,day1=0,day2=0,month1=0,month2=0;\\n    for(int i=0;i<date1.size();i++){\\n        if(i<=3){\\n            year1=year1*10+date1[i]-\\'0\\';\\n            year2=year2*10+date2[i]-\\'0\\';\\n        }\\n        if(i>4&&i<=6){\\n            month1=month1*10+date1[i]-\\'0\\';\\n            month2=month2*10+date2[i]-\\'0\\';\\n        }\\n        if(i>7){\\n            day1=day1*10+date1[i]-\\'0\\';\\n            day2=day2*10+date2[i]-\\'0\\';\\n        }\\n    }\\n    int leap1=count_leap(year1,1);\\n    int non_leap1=(year1-1)-1900-count_leap(year1,0);\\n    non_leap1*=365;\\n    int non_leap2=(year2-1)-1900-count_leap(year2,0);\\n    non_leap2*=365;\\n    int leap2=count_leap(year2,1);\\n\\n\\n    int total1=leap1+non_leap1+rest(year1,day1,month1);\\n    int total2=leap2+non_leap2+rest(year2,day2,month2);\\n    return abs(total1-total2);\\n    }\\n};  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924544,
                "title": "number-of-days-between-two-dates-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] array1 = date1.split(\"-\");\\n        String[] array2 = date2.split(\"-\");\\n        int year1 = Integer.parseInt(array1[0]), month1 = Integer.parseInt(array1[1]), day1 = Integer.parseInt(array1[2]);\\n        int year2 = Integer.parseInt(array2[0]), month2 = Integer.parseInt(array2[1]), day2 = Integer.parseInt(array2[2]);\\n        if (year1 > year2 || year1 == year2 && month1 > month2 || year1 == year2 && month1 == month2 && day1 > day2) {\\n            int temp = year1;\\n            year1 = year2;\\n            year2 = temp;\\n            temp = month1;\\n            month1 = month2;\\n            month2 = temp;\\n            temp = day1;\\n            day1 = day2;\\n            day2 = temp;\\n        }\\n        int numberOfDays1 = numberOfDays(year1, month1, day1);\\n        int numberOfDays2 = numberOfDays(year2, month2, day2);\\n        if (year1 == year2)\\n            return numberOfDays2 - numberOfDays1;\\n        else {\\n            int totalDays = (year2 - year1) * 365 - numberOfDays1 + numberOfDays2;\\n            int checkLeapYear = (int) Math.ceil(year1 / 4.0) * 4;\\n            while (checkLeapYear < year2) {\\n                if (isLeap(checkLeapYear))\\n                    totalDays++;\\n                checkLeapYear += 4;\\n            }\\n            return totalDays;\\n        }\\n    }\\n\\n    public int numberOfDays(int year, int month, int day) {\\n        int[] monthDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        if (isLeap(year))\\n            monthDays[1]++;\\n        int numberOfDays = 0;\\n        for (int i = month - 2; i >= 0; i--)\\n            numberOfDays += monthDays[i];\\n        numberOfDays += day;\\n        return numberOfDays;\\n    }\\n\\n    public boolean isLeap(int year) {\\n        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] array1 = date1.split(\"-\");\\n        String[] array2 = date2.split(\"-\");\\n        int year1 = Integer.parseInt(array1[0]), month1 = Integer.parseInt(array1[1]), day1 = Integer.parseInt(array1[2]);\\n        int year2 = Integer.parseInt(array2[0]), month2 = Integer.parseInt(array2[1]), day2 = Integer.parseInt(array2[2]);\\n        if (year1 > year2 || year1 == year2 && month1 > month2 || year1 == year2 && month1 == month2 && day1 > day2) {\\n            int temp = year1;\\n            year1 = year2;\\n            year2 = temp;\\n            temp = month1;\\n            month1 = month2;\\n            month2 = temp;\\n            temp = day1;\\n            day1 = day2;\\n            day2 = temp;\\n        }\\n        int numberOfDays1 = numberOfDays(year1, month1, day1);\\n        int numberOfDays2 = numberOfDays(year2, month2, day2);\\n        if (year1 == year2)\\n            return numberOfDays2 - numberOfDays1;\\n        else {\\n            int totalDays = (year2 - year1) * 365 - numberOfDays1 + numberOfDays2;\\n            int checkLeapYear = (int) Math.ceil(year1 / 4.0) * 4;\\n            while (checkLeapYear < year2) {\\n                if (isLeap(checkLeapYear))\\n                    totalDays++;\\n                checkLeapYear += 4;\\n            }\\n            return totalDays;\\n        }\\n    }\\n\\n    public int numberOfDays(int year, int month, int day) {\\n        int[] monthDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        if (isLeap(year))\\n            monthDays[1]++;\\n        int numberOfDays = 0;\\n        for (int i = month - 2; i >= 0; i--)\\n            numberOfDays += monthDays[i];\\n        numberOfDays += day;\\n        return numberOfDays;\\n    }\\n\\n    public boolean isLeap(int year) {\\n        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870247,
                "title": "beats-99-one-liner-easy-python-solution",
                "content": "```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs((datetime.strptime(date1, \"%Y-%m-%d\") - datetime.strptime(date2, \"%Y-%m-%d\")).days)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs((datetime.strptime(date1, \"%Y-%m-%d\") - datetime.strptime(date2, \"%Y-%m-%d\")).days)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455891,
                "title": "c-short-and-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(allDay(date1) - allDay(date2));\\n    }\\n    int allDay(string date){\\n        int Y = stoi(date.substr(0,4));\\n        int M = stoi(date.substr(5,2));\\n        int D = stoi(date.substr(8,2));\\n        int days = 0;\\n        for(int y=1971;y<Y;y++) days += isLeapYear(y)?366:365;\\n        for(int m=1;m<M;m++) days += daysOfMonth(m,Y);\\n        return days+D;\\n    }\\n    int daysOfMonth(int m,int y){\\n        if(m==1||m==3||m==5||m==7||m==8||m==10||m==12) return 31;\\n        if(m==2) return isLeapYear(y)?29:28;\\n        return 30;\\n    }\\n    bool isLeapYear(int year){\\n        return (year%4==0 && year%100!=0) || year%400==0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(allDay(date1) - allDay(date2));\\n    }\\n    int allDay(string date){\\n        int Y = stoi(date.substr(0,4));\\n        int M = stoi(date.substr(5,2));\\n        int D = stoi(date.substr(8,2));\\n        int days = 0;\\n        for(int y=1971;y<Y;y++) days += isLeapYear(y)?366:365;\\n        for(int m=1;m<M;m++) days += daysOfMonth(m,Y);\\n        return days+D;\\n    }\\n    int daysOfMonth(int m,int y){\\n        if(m==1||m==3||m==5||m==7||m==8||m==10||m==12) return 31;\\n        if(m==2) return isLeapYear(y)?29:28;\\n        return 30;\\n    }\\n    bool isLeapYear(int year){\\n        return (year%4==0 && year%100!=0) || year%400==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398265,
                "title": "java-100-fast-42-3-mb",
                "content": "The idea for \\'isLeapYear()\\' and \\'toEpochDay\\' is borrowed from Java.LocalDate, but anyway this solution is faster than using LocalDate directly, because we don\\'t create unnecessary object and all \\'long\\' types changed to \\'int\\'.\\nAlso, \\'Integer.parseInt\\' is replaced with more simple alternative that suites this solution.\\n\\n```\\npublic int daysBetweenDates(String f, String s) {\\n        final int d1 = toEpochDay(parse4(f.charAt(0), f.charAt(1), f.charAt(2), f.charAt(3)), parse2(f.charAt(5), f.charAt(6)), parse2(f.charAt(8), f.charAt(9)));\\n        final int d2 = toEpochDay(parse4(s.charAt(0), s.charAt(1), s.charAt(2), s.charAt(3)), parse2(s.charAt(5), s.charAt(6)), parse2(s.charAt(8), s.charAt(9)));\\n        return d1 > d2 ? d1 - d2 : d2 - d1;\\n    }\\n    \\n    public static int parse2(char r1, char r2) {\\n        return (r1 - \\'0\\') * 10 + (r2 - \\'0\\');\\n    }\\n\\n    public static int parse4(char r1, char r2, char r3, char r4) {\\n        return (r1 - \\'0\\') * 1000 + (r2 - \\'0\\') * 100 + (r3 - \\'0\\') * 10 + (r4 - \\'0\\');\\n    }\\n\\n    public static boolean isLeapYear(int year) {\\n        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\\n    }\\n\\n    public static int toEpochDay(int year, int month, int day) {\\n        int total = 365 * year;\\n        if (year >= 0) {\\n            total += (year + 3) / 4 - (year + 99) / 100 + (year + 399) / 400;\\n        } else {\\n            total -= year / -4 - year / -100 + year / -400;\\n        }\\n        total += ((367 * month - 362) / 12) + (day - 1);\\n        if (month > 2) {\\n            total--;\\n            if (!isLeapYear(year))\\n                total--;\\n        }\\n        return total - 719528;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int daysBetweenDates(String f, String s) {\\n        final int d1 = toEpochDay(parse4(f.charAt(0), f.charAt(1), f.charAt(2), f.charAt(3)), parse2(f.charAt(5), f.charAt(6)), parse2(f.charAt(8), f.charAt(9)));\\n        final int d2 = toEpochDay(parse4(s.charAt(0), s.charAt(1), s.charAt(2), s.charAt(3)), parse2(s.charAt(5), s.charAt(6)), parse2(s.charAt(8), s.charAt(9)));\\n        return d1 > d2 ? d1 - d2 : d2 - d1;\\n    }\\n    \\n    public static int parse2(char r1, char r2) {\\n        return (r1 - \\'0\\') * 10 + (r2 - \\'0\\');\\n    }\\n\\n    public static int parse4(char r1, char r2, char r3, char r4) {\\n        return (r1 - \\'0\\') * 1000 + (r2 - \\'0\\') * 100 + (r3 - \\'0\\') * 10 + (r4 - \\'0\\');\\n    }\\n\\n    public static boolean isLeapYear(int year) {\\n        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\\n    }\\n\\n    public static int toEpochDay(int year, int month, int day) {\\n        int total = 365 * year;\\n        if (year >= 0) {\\n            total += (year + 3) / 4 - (year + 99) / 100 + (year + 399) / 400;\\n        } else {\\n            total -= year / -4 - year / -100 + year / -400;\\n        }\\n        total += ((367 * month - 362) / 12) + (day - 1);\\n        if (month > 2) {\\n            total--;\\n            if (!isLeapYear(year))\\n                total--;\\n        }\\n        return total - 719528;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2279983,
                "title": "python-datetime",
                "content": "```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        Y1, M1, D1 = map(int, date1.split(\\'-\\'))\\n        Y2, M2, D2 = map(int, date2.split(\\'-\\'))\\n        return abs((datetime(Y2,M2,D2) - datetime(Y1,M1,D1)).days)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        Y1, M1, D1 = map(int, date1.split(\\'-\\'))\\n        Y2, M2, D2 = map(int, date2.split(\\'-\\'))\\n        return abs((datetime(Y2,M2,D2) - datetime(Y1,M1,D1)).days)",
                "codeTag": "Java"
            },
            {
                "id": 2263712,
                "title": "easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    month_days = {\\n\\t\\t1:31,\\n\\t\\t2:28,\\n\\t\\t3:31,\\n\\t\\t4:30,\\n\\t\\t5:31,\\n\\t\\t6:30,\\n\\t\\t7:31,\\n\\t\\t8:31,\\n\\t\\t9:30,\\n\\t\\t10:31,\\n\\t\\t11:30,\\n\\t\\t12:31\\n\\t}\\n    \\n    def _isLeap(self,year: int) -> bool:\\n\\t    return (year%4==0 and year%100!=0)or year%400==0\\n    \\n    def _dateToDays(self,year,month,day) -> int:\\n        days_since_1970 = 0\\n        \\n        for i in range(1970, year):\\n            if self._isLeap(i):\\n                days_since_1970 += 366\\n            else:\\n                days_since_1970 += 365\\n        \\n        for i in range(1, month):\\n            if i == 2 and self._isLeap(year):\\n                days_since_1970 += 1\\n                \\n            days_since_1970 += self.month_days[i]\\n        \\n        days_since_1970 += day\\n        \\n        return days_since_1970\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        year1, month1, day1 = map(lambda x: int(x), date1.split(\"-\"))\\n        year2, month2, day2 = map(lambda x: int(x), date2.split(\"-\"))\\n        \\n        return abs(self._dateToDays(year1, month1, day1) - self._dateToDays(year2, month2, day2))\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    month_days = {\\n\\t\\t1:31,\\n\\t\\t2:28,\\n\\t\\t3:31,\\n\\t\\t4:30,\\n\\t\\t5:31,\\n\\t\\t6:30,\\n\\t\\t7:31,\\n\\t\\t8:31,\\n\\t\\t9:30,\\n\\t\\t10:31,\\n\\t\\t11:30,\\n\\t\\t12:31\\n\\t}\\n    \\n    def _isLeap(self,year: int) -> bool:\\n\\t    return (year%4==0 and year%100!=0)or year%400==0\\n    \\n    def _dateToDays(self,year,month,day) -> int:\\n        days_since_1970 = 0\\n        \\n        for i in range(1970, year):\\n            if self._isLeap(i):\\n                days_since_1970 += 366\\n            else:\\n                days_since_1970 += 365\\n        \\n        for i in range(1, month):\\n            if i == 2 and self._isLeap(year):\\n                days_since_1970 += 1\\n                \\n            days_since_1970 += self.month_days[i]\\n        \\n        days_since_1970 += day\\n        \\n        return days_since_1970\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        year1, month1, day1 = map(lambda x: int(x), date1.split(\"-\"))\\n        year2, month2, day2 = map(lambda x: int(x), date2.split(\"-\"))\\n        \\n        return abs(self._dateToDays(year1, month1, day1) - self._dateToDays(year2, month2, day2))\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2020196,
                "title": "easy-solution-without-using-datetime-package-python",
                "content": "```\\nclass Solution:\\n\\tdef daysBetweenDates(self, date1: str, date2: str) -> int:\\n        self.month_days = {1:31, 2:28, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}\\n        \\n        diff = self.count_days(date2) - self.count_days(date1)\\n        return abs(diff)\\n        \\n        \\n    def count_days(self, date):\\n        year, month, day = date.split(\"-\")\\n        is_current_leap_year = self.is_leap_year(int(year))\\n        total_days = 0\\n        \\n        for y in range(1971, int(year)):\\n            days_in_year = 366 if self.is_leap_year(y) else 365\\n            total_days += days_in_year        \\n        \\n        for m in range(1, int(month)):\\n            total_days += self.month_days[m]\\n            \\n            if is_current_leap_year and m == 2:\\n                total_days += 1\\n            \\n        \\n        total_days += int(day)\\n        return total_days\\n    \\n    def is_leap_year(self, year):\\n        return (year % 4 == 0) and ((year % 100 == 0 and year % 400 == 0) or year % 100 != 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\tdef daysBetweenDates(self, date1: str, date2: str) -> int:\\n        self.month_days = {1:31, 2:28, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}",
                "codeTag": "Java"
            },
            {
                "id": 1494361,
                "title": "c-simple-logic-linq",
                "content": "```\\n    public int DaysBetweenDates(string date1, string date2) \\n    {\\n        return Math.Abs(DaysFrom1971(date2) - DaysFrom1971(date1));\\n    }\\n    \\n    private int DaysFrom1971(string date)\\n    {\\n        var year = Convert.ToInt32(date.Split(\\'-\\')[0]);\\n        var month = Convert.ToInt32(date.Split(\\'-\\')[1]);\\n        var days = Convert.ToInt32(date.Split(\\'-\\')[2]);\\n        \\n\\t\\t// dont count current month\\n        while (--month > 0)\\n        {\\n            if ((new int[] { 1, 3, 5, 7, 8, 10, 12 }).Contains(month))\\n                days += 31;\\n            else if ((new int[] { 4, 6, 9, 11 }).Contains(month))\\n                days += 30;\\n            else\\n                days += IsLeap(year) ? 29 : 28;\\n        }\\n        \\n\\t\\t// check if year prior isLeap, not current\\n        while (year > 1971)\\n        {\\n            days += IsLeap(--year) ? 366 : 365;\\n        }\\n                \\n        return days;\\n    }\\n        \\n    private bool IsLeap(int year)\\n    {\\n        return year % 400 == 0\\n            || (year % 4 == 0 \\n                && year % 100 != 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int DaysBetweenDates(string date1, string date2) \\n    {\\n        return Math.Abs(DaysFrom1971(date2) - DaysFrom1971(date1));\\n    }\\n    \\n    private int DaysFrom1971(string date)\\n    {\\n        var year = Convert.ToInt32(date.Split(\\'-\\')[0]);\\n        var month = Convert.ToInt32(date.Split(\\'-\\')[1]);\\n        var days = Convert.ToInt32(date.Split(\\'-\\')[2]);\\n        \\n\\t\\t// dont count current month\\n        while (--month > 0)\\n        {\\n            if ((new int[] { 1, 3, 5, 7, 8, 10, 12 }).Contains(month))\\n                days += 31;\\n            else if ((new int[] { 4, 6, 9, 11 }).Contains(month))\\n                days += 30;\\n            else\\n                days += IsLeap(year) ? 29 : 28;\\n        }\\n        \\n\\t\\t// check if year prior isLeap, not current\\n        while (year > 1971)\\n        {\\n            days += IsLeap(--year) ? 366 : 365;\\n        }\\n                \\n        return days;\\n    }\\n        \\n    private bool IsLeap(int year)\\n    {\\n        return year % 400 == 0\\n            || (year % 4 == 0 \\n                && year % 100 != 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436961,
                "title": "python-3-accepted-solution",
                "content": "\\n    def isLeap(self, year):\\n        if (year % 4) == 0:  \\n            if (year % 100) == 0:  \\n                if (year % 400) == 0:  \\n                    return True \\n                else:  \\n                    return False \\n            else:  \\n                return True\\n        else:  \\n            return False\\n    \\n    def calculateDays(self, date1):\\n        year, month, day = tuple([int(d) for d in date1.split(\"-\")])\\n        totaldays = 0\\n        startyear = 1970\\n        \\n        for y in range(startyear, year):\\n            \\n            days = 366 if self.isLeap(y) else 365\\n            totaldays +=days\\n        \\n        leap = 1 if self.isLeap(year) else 0\\n        month_days = {1:31, 2: 28+leap, 3:31, 4:30, 5:31,6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}\\n        for m  in range(1, month):\\n            totaldays +=month_days[m]\\n            \\n            \\n        totaldays +=day\\n            \\n        return totaldays\\n            \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n       \\n        return abs(self.calculateDays(date1)-self.calculateDays(date2))",
                "solutionTags": [],
                "code": "\\n    def isLeap(self, year):\\n        if (year % 4) == 0:  \\n            if (year % 100) == 0:  \\n                if (year % 400) == 0:  \\n                    return True \\n                else:  \\n                    return False \\n            else:  \\n                return True\\n        else:  \\n            return False\\n    \\n    def calculateDays(self, date1):\\n        year, month, day = tuple([int(d) for d in date1.split(\"-\")])\\n        totaldays = 0\\n        startyear = 1970\\n        \\n        for y in range(startyear, year):\\n            \\n            days = 366 if self.isLeap(y) else 365\\n            totaldays +=days\\n        \\n        leap = 1 if self.isLeap(year) else 0\\n        month_days = {1:31, 2: 28+leap, 3:31, 4:30, 5:31,6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}\\n        for m  in range(1, month):\\n            totaldays +=month_days[m]\\n            \\n            \\n        totaldays +=day\\n            \\n        return totaldays\\n            \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n       \\n        return abs(self.calculateDays(date1)-self.calculateDays(date2))",
                "codeTag": "Python3"
            },
            {
                "id": 1370680,
                "title": "c-solution-without-using-1971-as-reference-year-and-no-standard-library-functions",
                "content": "```  \\n//Function to count the No. of Leap Years between 2 years\\nint leapYrCount(int year1, int year2) {\\n        int leapYrs = 0;\\n        while(year1 <= year2){            \\n            if((year1%400 == 0) || ((year1%4 == 0) && (year1%100 != 0)))\\n                ++leapYrs;\\n            year1++;\\n        }\\n        return leapYrs;\\n    }\\n    \\n\\n    int daysBetweenDates(string date1, string date2) {\\n\\t\\t//Vector storing cumulative days per month\\n        vector<int> days = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        \\n        int lowerYr, higherYr, yearDiff, dayDiff, numLeapYrs;\\n        int year1, year2, month1, month2, day1, day2;\\n        \\n\\t\\t//Parsing and Tokenizing Date1\\n        year1  = stoi(date1.substr(0,4));\\n        month1 = stoi(date1.substr(5,2));\\n        day1   = stoi(date1.substr(8));\\n        \\n\\t\\t//Parsing and Tokenizing Date2\\n        year2  = stoi(date2.substr(0,4));\\n        month2 = stoi(date2.substr(5,2));\\n        day2   = stoi(date2.substr(8));\\n        \\n\\t\\t//Lower Year and Higher Year for Leap Year Calculation\\n\\t\\t//Example : If the Lower Date is \"05.03.1996\", Year 1996 can be skipped from Leap Year calculation as the date is after Feb 28. Hence Lower Year will be 1997.\\n\\t\\t//Example : If the Higher Date is \"05.01.1996\", Year 1996 can be skipped from Leap Year calculation as the date is before Feb 28, Hence Higher Year will be 1995.\\n\\t\\t//Kind of lame logic, but hell yeahhh, it works..\\n        lowerYr  = (year1 > year2) ? ((month2 > 2) ? year2+1 : year2) : ((month1 > 2) ? year1+1 : year1);\\n        higherYr = (year1 > year2) ? ((month1 > 2) ? year1 : year1-1) : ((month2 > 2) ? year2 : year2-1);\\n        \\n\\t\\t//Difference of date calculation\\n        numLeapYrs = leapYrCount(lowerYr, higherYr);\\n        yearDiff = year1 - year2;\\n        dayDiff = days[month1-1] - days[month2-1] + (day1 - day2);\\n        \\n        return (abs(yearDiff * 365 + dayDiff) + numLeapYrs);       \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```  \\n//Function to count the No. of Leap Years between 2 years\\nint leapYrCount(int year1, int year2) {\\n        int leapYrs = 0;\\n        while(year1 <= year2){            \\n            if((year1%400 == 0) || ((year1%4 == 0) && (year1%100 != 0)))\\n                ++leapYrs;\\n            year1++;\\n        }\\n        return leapYrs;\\n    }\\n    \\n\\n    int daysBetweenDates(string date1, string date2) {\\n\\t\\t//Vector storing cumulative days per month\\n        vector<int> days = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        \\n        int lowerYr, higherYr, yearDiff, dayDiff, numLeapYrs;\\n        int year1, year2, month1, month2, day1, day2;\\n        \\n\\t\\t//Parsing and Tokenizing Date1\\n        year1  = stoi(date1.substr(0,4));\\n        month1 = stoi(date1.substr(5,2));\\n        day1   = stoi(date1.substr(8));\\n        \\n\\t\\t//Parsing and Tokenizing Date2\\n        year2  = stoi(date2.substr(0,4));\\n        month2 = stoi(date2.substr(5,2));\\n        day2   = stoi(date2.substr(8));\\n        \\n\\t\\t//Lower Year and Higher Year for Leap Year Calculation\\n\\t\\t//Example : If the Lower Date is \"05.03.1996\", Year 1996 can be skipped from Leap Year calculation as the date is after Feb 28. Hence Lower Year will be 1997.\\n\\t\\t//Example : If the Higher Date is \"05.01.1996\", Year 1996 can be skipped from Leap Year calculation as the date is before Feb 28, Hence Higher Year will be 1995.\\n\\t\\t//Kind of lame logic, but hell yeahhh, it works..\\n        lowerYr  = (year1 > year2) ? ((month2 > 2) ? year2+1 : year2) : ((month1 > 2) ? year1+1 : year1);\\n        higherYr = (year1 > year2) ? ((month1 > 2) ? year1 : year1-1) : ((month2 > 2) ? year2 : year2-1);\\n        \\n\\t\\t//Difference of date calculation\\n        numLeapYrs = leapYrCount(lowerYr, higherYr);\\n        yearDiff = year1 - year2;\\n        dayDiff = days[month1-1] - days[month2-1] + (day1 - day2);\\n        \\n        return (abs(yearDiff * 365 + dayDiff) + numLeapYrs);       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1306277,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(dateToInt(date2) - dateToInt(date1));\\n    }\\nprotected:\\n    int dateToInt(string date){\\n        int year = stoi(date.substr(0,4));\\n        int month = stoi(date.substr(5,2));\\n        int dateInInteger = stoi(date.substr(8,2));\\n        int noOfDays = 0;\\n        for(int y=1971; y<year; y++) noOfDays += leapYear(y) ? 366 : 365;\\n        for(int m=1; m<month; m++) noOfDays += daysInMonth(m, year);\\n        return noOfDays + dateInInteger;\\n    }   \\n    bool leapYear(int year){\\n        return ((year%4==0 && year%100!=0)||(year%400==0));\\n    }\\n    int daysInMonth(int month, int year){\\n        if(month==1||month==3||month==5||month==7||month==8||month==10||month==12) return 31;\\n        if(month==2) return leapYear(year)?29:28;\\n        return 30;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(dateToInt(date2) - dateToInt(date1));\\n    }\\nprotected:\\n    int dateToInt(string date){\\n        int year = stoi(date.substr(0,4));\\n        int month = stoi(date.substr(5,2));\\n        int dateInInteger = stoi(date.substr(8,2));\\n        int noOfDays = 0;\\n        for(int y=1971; y<year; y++) noOfDays += leapYear(y) ? 366 : 365;\\n        for(int m=1; m<month; m++) noOfDays += daysInMonth(m, year);\\n        return noOfDays + dateInInteger;\\n    }   \\n    bool leapYear(int year){\\n        return ((year%4==0 && year%100!=0)||(year%400==0));\\n    }\\n    int daysInMonth(int month, int year){\\n        if(month==1||month==3||month==5||month==7||month==8||month==10||month==12) return 31;\\n        if(month==2) return leapYear(year)?29:28;\\n        return 30;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295330,
                "title": "1ms-share-my-java-solution-easy-to-understand",
                "content": "Maybe a little verbose, but the question is very often. Even though there are already APIs, but I think we could try to implement it by self.\\n\\n```java\\n// AC: Runtime: 1 ms, faster than 98.55% of Java online submissions for Number of Days Between Two Dates.\\n// Memory Usage: 37.5 MB, less than 37.05% of Java online submissions for Number of Days Between Two Dates.\\n// .\\n// T:O(Math.abs(year1 - year2)), S:O(1)\\n// \\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] arr1 = date1.split(\"-\");\\n        String[] arr2 = date2.split(\"-\");\\n        int year1 = Integer.parseInt(arr1[0]), month1 = Integer.parseInt(arr1[1]), day1 = Integer.parseInt(arr1[2]), year2 = Integer.parseInt(arr2[0]), month2 = Integer.parseInt(arr2[1]), day2 = Integer.parseInt(arr2[2]);\\n        if (year1 < year2 || (year1 == year2 && month1 < month2) || (year1 == year2 && month1 == month2 && day1 < day2)) {\\n            return daysBetweenDates(date2, date1);\\n        }\\n\\n        int[] monthArr = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int gapYearDays = 0;\\n        for (int i = year2 + 1; i < year1; i++) {\\n            if (checkYear(i)) {\\n                gapYearDays += 366;\\n            } else {\\n                gapYearDays += 365;\\n            }\\n        }\\n        int year2Days = 0;\\n        for (int i = 0; i < month2 - 1; i++) {\\n            if (i == 1) {\\n                if (checkYear(year2)) {\\n                    year2Days += 1;\\n                }\\n            }\\n            year2Days += monthArr[i];\\n        }\\n        year2Days += day2;\\n        year2Days = checkYear(year2) ? 366 - year2Days : 365 - year2Days;\\n\\n        int year1Days = 0;\\n        for (int i = 0; i < month1 - 1; i++) {\\n            if (i == 1) {\\n                if (checkYear(year1)) {\\n                    year1Days += 1;\\n                }\\n            }\\n            year1Days += monthArr[i];\\n        }\\n        year1Days += day1;\\n\\n        if (year1 > year2) {\\n            return gapYearDays + year1Days + year2Days;\\n        } else {\\n            return year2Days - (checkYear(year1) ? 366 - year1Days : 365 - year1Days);\\n        }\\n    }\\n\\n    private boolean checkYear(int year) {\\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 1 ms, faster than 98.55% of Java online submissions for Number of Days Between Two Dates.\\n// Memory Usage: 37.5 MB, less than 37.05% of Java online submissions for Number of Days Between Two Dates.\\n// .\\n// T:O(Math.abs(year1 - year2)), S:O(1)\\n// \\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] arr1 = date1.split(\"-\");\\n        String[] arr2 = date2.split(\"-\");\\n        int year1 = Integer.parseInt(arr1[0]), month1 = Integer.parseInt(arr1[1]), day1 = Integer.parseInt(arr1[2]), year2 = Integer.parseInt(arr2[0]), month2 = Integer.parseInt(arr2[1]), day2 = Integer.parseInt(arr2[2]);\\n        if (year1 < year2 || (year1 == year2 && month1 < month2) || (year1 == year2 && month1 == month2 && day1 < day2)) {\\n            return daysBetweenDates(date2, date1);\\n        }\\n\\n        int[] monthArr = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int gapYearDays = 0;\\n        for (int i = year2 + 1; i < year1; i++) {\\n            if (checkYear(i)) {\\n                gapYearDays += 366;\\n            } else {\\n                gapYearDays += 365;\\n            }\\n        }\\n        int year2Days = 0;\\n        for (int i = 0; i < month2 - 1; i++) {\\n            if (i == 1) {\\n                if (checkYear(year2)) {\\n                    year2Days += 1;\\n                }\\n            }\\n            year2Days += monthArr[i];\\n        }\\n        year2Days += day2;\\n        year2Days = checkYear(year2) ? 366 - year2Days : 365 - year2Days;\\n\\n        int year1Days = 0;\\n        for (int i = 0; i < month1 - 1; i++) {\\n            if (i == 1) {\\n                if (checkYear(year1)) {\\n                    year1Days += 1;\\n                }\\n            }\\n            year1Days += monthArr[i];\\n        }\\n        year1Days += day1;\\n\\n        if (year1 > year2) {\\n            return gapYearDays + year1Days + year2Days;\\n        } else {\\n            return year2Days - (checkYear(year1) ? 366 - year1Days : 365 - year1Days);\\n        }\\n    }\\n\\n    private boolean checkYear(int year) {\\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167335,
                "title": "java-1ms-faster-than-95",
                "content": "```\\nclass Solution {\\n\\n\\tint[] days = new int[] { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\n\\n\\tpublic int daysBetweenDates(String date1, String date2) {\\n\\n\\t\\treturn Math.abs(getDays(date2) - getDays(date1));\\n\\n\\t}\\n\\n\\tint getDays(String date) {\\n\\t\\tString[] arr = date.split(\"-\");\\n\\n\\t\\tint year = Integer.valueOf(arr[0]);\\n\\t\\tint month = Integer.valueOf(arr[1]);\\n\\t\\tint day = Integer.valueOf(arr[2]);\\n\\n\\t\\tint rtn = 0;\\n\\t\\tfor (int i = 1971; i < year; i++) {\\n\\t\\t\\tif (isLeap(i)) {\\n\\t\\t\\t\\trtn = rtn + 366;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trtn = rtn + 365;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tboolean isLeap = isLeap(year);\\n\\t\\tif (isLeap && month > 2)\\n\\t\\t\\trtn = rtn + 1;\\n\\t\\tfor (int i = 1; i < month; i++) {\\n\\n\\t\\t\\trtn = rtn + days[i];\\n\\n\\t\\t}\\n\\n\\t\\treturn rtn + day;\\n\\t}\\n\\n\\tboolean isLeap(int year) {\\n\\n\\t\\tif (year % 4 == 0) {\\n\\t\\t\\tif (year % 100 == 0) {\\n\\n\\t\\t\\t\\tif (year % 400 == 0)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n\\tint[] days = new int[] { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\n\\n\\tpublic int daysBetweenDates(String date1, String date2) {\\n\\n\\t\\treturn Math.abs(getDays(date2) - getDays(date1));\\n\\n\\t}\\n\\n\\tint getDays(String date) {\\n\\t\\tString[] arr = date.split(\"-\");\\n\\n\\t\\tint year = Integer.valueOf(arr[0]);\\n\\t\\tint month = Integer.valueOf(arr[1]);\\n\\t\\tint day = Integer.valueOf(arr[2]);\\n\\n\\t\\tint rtn = 0;\\n\\t\\tfor (int i = 1971; i < year; i++) {\\n\\t\\t\\tif (isLeap(i)) {\\n\\t\\t\\t\\trtn = rtn + 366;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trtn = rtn + 365;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tboolean isLeap = isLeap(year);\\n\\t\\tif (isLeap && month > 2)\\n\\t\\t\\trtn = rtn + 1;\\n\\t\\tfor (int i = 1; i < month; i++) {\\n\\n\\t\\t\\trtn = rtn + days[i];\\n\\n\\t\\t}\\n\\n\\t\\treturn rtn + day;\\n\\t}\\n\\n\\tboolean isLeap(int year) {\\n\\n\\t\\tif (year % 4 == 0) {\\n\\t\\t\\tif (year % 100 == 0) {\\n\\n\\t\\t\\t\\tif (year % 400 == 0)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161503,
                "title": "c-0ms-posix",
                "content": "```\\nclass Solution {\\n    struct tm getDayMonthYearTm(const string &s) {        \\n        struct tm tms{0};\\n        \\n        tms.tm_mday = atoi(s.substr(8).c_str());\\n        tms.tm_mon = atoi(s.substr(5, 7).c_str()) - 1;\\n        tms.tm_year = atoi(s.substr(0, 4).c_str()) - 1900;\\n        \\n        return tms;\\n    }\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        constexpr int secPerDay = 24*60*60;\\n\\n        auto tms1 = getDayMonthYearTm(date1);\\n        auto tms2 = getDayMonthYearTm(date2);\\n        \\n        time_t t1 = mktime(&tms1);\\n        time_t t2 = mktime(&tms2);\\n        \\n        auto diff = t2 > t1 ? difftime(t2,t1) : difftime(t1,t2);\\n        \\n        return diff / secPerDay;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct tm getDayMonthYearTm(const string &s) {        \\n        struct tm tms{0};\\n        \\n        tms.tm_mday = atoi(s.substr(8).c_str());\\n        tms.tm_mon = atoi(s.substr(5, 7).c_str()) - 1;\\n        tms.tm_year = atoi(s.substr(0, 4).c_str()) - 1900;\\n        \\n        return tms;\\n    }\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        constexpr int secPerDay = 24*60*60;\\n\\n        auto tms1 = getDayMonthYearTm(date1);\\n        auto tms2 = getDayMonthYearTm(date2);\\n        \\n        time_t t1 = mktime(&tms1);\\n        time_t t2 = mktime(&tms2);\\n        \\n        auto diff = t2 > t1 ? difftime(t2,t1) : difftime(t1,t2);\\n        \\n        return diff / secPerDay;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073693,
                "title": "c-easy-understanding-runtime-0-ms-faster-than-100-00-memory-5-9-mb-less-than-91-35",
                "content": "```\\nclass Solution {\\npublic:\\n    int daysPastInYear(int y, int m, int d) {\\n        int md[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        int days = md[m-1] + d;\\n        if (y % 4 == 0 && m >= 3 && (y % 100 || y == 2000)) {\\n            days++;\\n        }\\n        return days;\\n    }\\n    int daysBetweenDates(string date1, string date2) {\\n        if (date1 == date2) return 0;\\n\\t\\t//String to Int Process and Do the comparing in the same time.\\n        int y1 = 0, y2 = 0, m1 = 0, m2 = 0, d1 = 0, d2 = 0;   \\n        int cp = 0;  //Compare Flag 0: date1==date2  1: date1>date2  -1: date1<date2\\n        for (int i = 0; i <= 3; i++) {\\n            y1 = y1 * 10 + date1[i] - \\'0\\';\\n            y2 = y2 * 10 + date2[i] - \\'0\\';\\n            if (cp == 0) {\\n                if (y1 > y2) {\\n                    cp = 1;\\n                } else if (y1 < y2) {\\n                    cp = -1;\\n                }\\n            }\\n        }\\n        for (int i = 5; i <= 6; i++) {\\n            m1 = m1 * 10 + date1[i] - \\'0\\';\\n            m2 = m2 * 10 + date2[i] - \\'0\\';\\n            if (cp == 0) {\\n                if (m1 > m2) {\\n                    cp = 1;\\n                } else if (m1 < m2) {\\n                    cp = -1;\\n                }\\n            }\\n        }\\n        for (int i = 8; i <= 9; i++) {\\n            d1 = d1 * 10 + date1[i] - \\'0\\';\\n            d2 = d2 * 10 + date2[i] - \\'0\\';\\n            if (cp == 0) {\\n                if (d1 > d2) {\\n                    cp = 1;\\n                } else if (d1 < d2) {\\n                    cp = -1;\\n                }\\n            }            \\n        }\\n\\t\\t\\n\\t\\t//Make sure date1 is later than date2\\n        if (cp < 0) {\\n            swap(y1, y2);\\n            swap(m1, m2);\\n            swap(d1, d2);\\n        }\\n\\t\\t\\n\\t\\t// Count the days diff between year1 and year2\\n        int days = (y1 - y2) * 365 + ((y1 - y2) / 4);\\n        if ((y1 - y2) % 4 && y1 % 4 && y1 % 4 <= (y1 - y2) % 4) {\\n            days++;\\n        }\\n\\t\\t\\n        return days - daysPastInYear(y2, m2, d2) + daysPastInYear(y1, m1, d1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int daysPastInYear(int y, int m, int d) {\\n        int md[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        int days = md[m-1] + d;\\n        if (y % 4 == 0 && m >= 3 && (y % 100 || y == 2000)) {\\n            days++;\\n        }\\n        return days;\\n    }\\n    int daysBetweenDates(string date1, string date2) {\\n        if (date1 == date2) return 0;\\n\\t\\t//String to Int Process and Do the comparing in the same time.\\n        int y1 = 0, y2 = 0, m1 = 0, m2 = 0, d1 = 0, d2 = 0;   \\n        int cp = 0;  //Compare Flag 0: date1==date2  1: date1>date2  -1: date1<date2\\n        for (int i = 0; i <= 3; i++) {\\n            y1 = y1 * 10 + date1[i] - \\'0\\';\\n            y2 = y2 * 10 + date2[i] - \\'0\\';\\n            if (cp == 0) {\\n                if (y1 > y2) {\\n                    cp = 1;\\n                } else if (y1 < y2) {\\n                    cp = -1;\\n                }\\n            }\\n        }\\n        for (int i = 5; i <= 6; i++) {\\n            m1 = m1 * 10 + date1[i] - \\'0\\';\\n            m2 = m2 * 10 + date2[i] - \\'0\\';\\n            if (cp == 0) {\\n                if (m1 > m2) {\\n                    cp = 1;\\n                } else if (m1 < m2) {\\n                    cp = -1;\\n                }\\n            }\\n        }\\n        for (int i = 8; i <= 9; i++) {\\n            d1 = d1 * 10 + date1[i] - \\'0\\';\\n            d2 = d2 * 10 + date2[i] - \\'0\\';\\n            if (cp == 0) {\\n                if (d1 > d2) {\\n                    cp = 1;\\n                } else if (d1 < d2) {\\n                    cp = -1;\\n                }\\n            }            \\n        }\\n\\t\\t\\n\\t\\t//Make sure date1 is later than date2\\n        if (cp < 0) {\\n            swap(y1, y2);\\n            swap(m1, m2);\\n            swap(d1, d2);\\n        }\\n\\t\\t\\n\\t\\t// Count the days diff between year1 and year2\\n        int days = (y1 - y2) * 365 + ((y1 - y2) / 4);\\n        if ((y1 - y2) % 4 && y1 % 4 && y1 % 4 <= (y1 - y2) % 4) {\\n            days++;\\n        }\\n\\t\\t\\n        return days - daysPastInYear(y2, m2, d2) + daysPastInYear(y1, m1, d1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975338,
                "title": "python-no-cheating",
                "content": "```\\nclass Solution(object):\\n    def daysBetweenDates(self, date1, date2):\\n        \"\"\"\\n        :type date1: str\\n        :type date2: str\\n        :rtype: int\\n        \"\"\"\\n        if date1>date2:\\n            date1,date2 = date2,date1\\n        month = {}\\n        for m in [1,3,5,7,8,10,12]:\\n            month[m] = 31\\n        for m in [4,6,9,11]:\\n            month[m] = 30\\n        month[2] = 28\\n        \\n        def daydiff(a,b):\\n            return abs(a-b)\\n        \\n        def mondiff(a,b,y):\\n            sums = 0\\n            m1,d1 = a\\n            m2,d2 = b\\n            if m1 == m2:\\n                return d2-d1\\n            \\n            month[2] = 29 if (y%4==0 and ((not y%100==0) or y%400==0)) else 28\\n            sums += daydiff(d1,month[m1])+d2\\n            for m in range(m1+1,m2):\\n                sums += month[m]\\n            return sums\\n        \\n        def yeardiff(a,b):\\n            sums = 0\\n            y1,m1,d1 = a\\n            y2,m2,d2 = b\\n            if y1 == y2:\\n                sums = mondiff([m1,d1],[m2,d2],y1)\\n            else:\\n                sums += mondiff([m1,d1],[12,31],y1)\\n                sums += mondiff([1,0],[m2,d2],y2)\\n                for y in range(y1+1,y2):\\n                    sums += 366 if (y%4==0 and ((not y%100==0) or y%400==0)) else 365\\n            return sums\\n        \\n        a = [int(s) for s in date1.split(\\'-\\')] \\n        b = [int(s) for s in date2.split(\\'-\\')] \\n        return yeardiff(a,b)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def daysBetweenDates(self, date1, date2):\\n        \"\"\"\\n        :type date1: str\\n        :type date2: str\\n        :rtype: int\\n        \"\"\"\\n        if date1>date2:\\n            date1,date2 = date2,date1\\n        month = {}\\n        for m in [1,3,5,7,8,10,12]:\\n            month[m] = 31\\n        for m in [4,6,9,11]:\\n            month[m] = 30\\n        month[2] = 28\\n        \\n        def daydiff(a,b):\\n            return abs(a-b)\\n        \\n        def mondiff(a,b,y):\\n            sums = 0\\n            m1,d1 = a\\n            m2,d2 = b\\n            if m1 == m2:\\n                return d2-d1\\n            \\n            month[2] = 29 if (y%4==0 and ((not y%100==0) or y%400==0)) else 28\\n            sums += daydiff(d1,month[m1])+d2\\n            for m in range(m1+1,m2):\\n                sums += month[m]\\n            return sums\\n        \\n        def yeardiff(a,b):\\n            sums = 0\\n            y1,m1,d1 = a\\n            y2,m2,d2 = b\\n            if y1 == y2:\\n                sums = mondiff([m1,d1],[m2,d2],y1)\\n            else:\\n                sums += mondiff([m1,d1],[12,31],y1)\\n                sums += mondiff([1,0],[m2,d2],y2)\\n                for y in range(y1+1,y2):\\n                    sums += 366 if (y%4==0 and ((not y%100==0) or y%400==0)) else 365\\n            return sums\\n        \\n        a = [int(s) for s in date1.split(\\'-\\')] \\n        b = [int(s) for s in date2.split(\\'-\\')] \\n        return yeardiff(a,b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931562,
                "title": "java-calculate-both-total-days-from-1971-no-api",
                "content": "calculate total days from 1971-1-1 to date1 & date2 and return abs diff\\n\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n        \\n        int[] id1 = {Integer.valueOf(d1[0]), Integer.valueOf(d1[1]), Integer.valueOf(d1[2])};\\n        int[] id2 = {Integer.valueOf(d2[0]), Integer.valueOf(d2[1]), Integer.valueOf(d2[2])};\\n        \\n        int[][] m2d = {{-1, \\n                      31,28,31,30,31,30,31,\\n                      31,30,31,30,31},\\n                     {-1, \\n                      31,29,31,30,31,30,31,\\n                      31,30,31,30,31}};\\n        \\n        long days1 = 0;\\n        long days2 = 0;\\n        \\n        //Year\\n        for(int i = 1971; i < id1[0]; i++)\\n            days1 += leap(i) == 1 ? 366 : 365;\\n        \\n        for(int i = 1971; i < id2[0]; i++)\\n            days2 += leap(i) == 1 ? 366 : 365;\\n        \\n        //Month\\n        int leap1 = leap(id1[0]);\\n        int leap2 = leap(id2[0]);\\n        \\n        for(int i = 1; i < id1[1]; i++)\\n            days1 += m2d[leap1][i]; \\n        \\n        for(int i = 1; i < id2[1]; i++)\\n            days2 += m2d[leap2][i]; \\n        \\n        \\n        //Day\\n        days1 += id1[2];\\n        days2 += id2[2];\\n        \\n        return (int)Math.abs(days1 - days2);\\n    }\\n    \\n    int leap (int year){\\n        if(year % 4 != 0 )\\n            return 0;\\n        else if(year % 100 != 0)\\n            return 1;\\n        else if(year % 400 != 0)\\n            return 0;\\n        else\\n            return 1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n        \\n        int[] id1 = {Integer.valueOf(d1[0]), Integer.valueOf(d1[1]), Integer.valueOf(d1[2])}",
                "codeTag": "Java"
            },
            {
                "id": 891106,
                "title": "python-6-line-no-library-call",
                "content": "Compute the number of days from the first day of BC 1 (0000-01-01 in numerics) to both dates and return the difference.\\n```python\\ndef daysBetweenDates(self, date1: str, date2: str) -> int:\\n    dom = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]  # days of months\\n    def numOfDays(y, m, d):\\n        return (y-1) * 365 + (y-1) // 4 - (y-1) // 100 + (y-1) // 400 + sum(dom[:m-1]) + (1 if m > 2 and (not y % 4 and y % 100 or not y % 400) else 0) + d\\n    if date1 > date2:\\n        date1, date2 = date2, date1\\n    return numOfDays(*map(int, date2.split(\\'-\\'))) - numOfDays(*map(int, date1.split(\\'-\\')))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef daysBetweenDates(self, date1: str, date2: str) -> int:\\n    dom = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]  # days of months\\n    def numOfDays(y, m, d):\\n        return (y-1) * 365 + (y-1) // 4 - (y-1) // 100 + (y-1) // 400 + sum(dom[:m-1]) + (1 if m > 2 and (not y % 4 and y % 100 or not y % 400) else 0) + d\\n    if date1 > date2:\\n        date1, date2 = date2, date1\\n    return numOfDays(*map(int, date2.split(\\'-\\'))) - numOfDays(*map(int, date1.split(\\'-\\')))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 703030,
                "title": "python-beats-95-clean-and-annotated",
                "content": "The approach here is to find the days between 1971-01-01 (the lower bound date for possible inputs values) and ```date1``` then find the days between 1971-01-01 and ```date2```.  Our result will be the absolute difference of these two time spans.  \\n\\nThis is a simple approach that works because we are dealing with small numbers.  A more efficient approach would be to directly calculate the days between ```date1``` and ```date2``` without relying on ```1971-01-01``` as a third point.\\n\\n### Details:\\n\\n**leapyear**: \\n\\nLeap years occur whenever the year is divisible by four, but not when the year is divisible by 100, unless the year is also divisible by 400.  The leap year fuction simply checks if the year is divisible by 400, then 100, then 4 since this is the order of priority when deciding if it is a leap year.  \\n\\n**days_to**: \\n\\nAfter converting the string \"year-month-day\" into integer values ```y```, ```m```, and ```d```.  \\n\\nWe then convert year (```y```) into its equivalent value in days (```yd```) that have passed since the beginning of  ```1971```.  Note that the range is ```range(1971, y)``` indicating that we do not include the current year in ```yd``` since the current year is only partially completed.  For every leap year in this range, we use the ```leapyear``` definition to add 1 day.  \\n\\nSimilarly, we convert the months that have passed in the current year into their equivalent value in days.  ```sum(months[:m-1])``` Note that again, we stop at the last completed month not including all the days in the current month.  \\n\\nIf the current year is a leap year, and the current month is March or later, then we add one extra day to ```md```.  \\n\\nFinally, we return the sum days + (months converted to days) + (years converted to days) which represents the days between ```1971-01-01``` and ```date```\\n\\n### Annotated code:\\n```python\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        def leapyear(year):\\n            \\'\\'\\'returns 1 if input year is a leap year\\'\\'\\'\\n            if not year%400: return 1\\n            if not year%100: return 0\\n            if not year%4: return 1\\n            return 0\\n        \\n        def days_to(date):\\n            \\'\\'\\'returns days between 1971-01-01 and date\\'\\'\\'\\n            nonlocal months\\n            \\n            y,m,d = [int(i) for i in date.split(\\'-\\')]\\n            \\n            yd = 0\\n            for year in range(1971, y): #do not include current year\\n                yd += 365 + leapyear(year)\\n            \\n            md = sum(months[:m-1]) # do not include current month\\n            \\n            if m > 2: md += leapyear(y) #add 1 day if current year is leap year and it is March or later\\n\\n            return yd + md + d\\n        \\n        \\n        months = [31, 28, 31, 30,\\n                  31, 30, 31, 31,\\n                  30, 31, 30, 31]\\n        \\n        return abs(days_to(date2) - days_to(date1))\\n```",
                "solutionTags": [],
                "code": "```date1```\n```date2```\n```date1```\n```date2```\n```1971-01-01```\n```y```\n```m```\n```d```\n```y```\n```yd```\n```1971```\n```range(1971, y)```\n```yd```\n```leapyear```\n```sum(months[:m-1])```\n```md```\n```1971-01-01```\n```date```\n```python\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        def leapyear(year):\\n            \\'\\'\\'returns 1 if input year is a leap year\\'\\'\\'\\n            if not year%400: return 1\\n            if not year%100: return 0\\n            if not year%4: return 1\\n            return 0\\n        \\n        def days_to(date):\\n            \\'\\'\\'returns days between 1971-01-01 and date\\'\\'\\'\\n            nonlocal months\\n            \\n            y,m,d = [int(i) for i in date.split(\\'-\\')]\\n            \\n            yd = 0\\n            for year in range(1971, y): #do not include current year\\n                yd += 365 + leapyear(year)\\n            \\n            md = sum(months[:m-1]) # do not include current month\\n            \\n            if m > 2: md += leapyear(y) #add 1 day if current year is leap year and it is March or later\\n\\n            return yd + md + d\\n        \\n        \\n        months = [31, 28, 31, 30,\\n                  31, 30, 31, 31,\\n                  30, 31, 30, 31]\\n        \\n        return abs(days_to(date2) - days_to(date1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529357,
                "title": "python-no-api-easy-to-understand",
                "content": "My idea is to count all the number of days from 0000-01-01, and then take abs(days1 - days2)\\n\\n```\\nclass Solution:\\n    def fromFirstDay(self, date):\\n        yy = int(date[:4])\\n        mm = int(date[5:7])\\n        dd = int(date[8:]) \\n        acc = 0\\n        acc += (yy - 1) * 365 + (yy - 1) // 4 + (yy - 1) // 400 - (yy - 1) // 100\\n        month = [31,28,31,30,31,30,31,31,30,31,30,31]\\n        if (yy % 100 == 0 and yy % 400 == 0) or (yy % 100 != 0 and yy % 4 == 0):\\n            month[1] = 29\\n        acc += sum(month[:mm - 1])\\n        acc += dd\\n        return acc\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs(self.fromFirstDay(date1) - self.fromFirstDay(date2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fromFirstDay(self, date):\\n        yy = int(date[:4])\\n        mm = int(date[5:7])\\n        dd = int(date[8:]) \\n        acc = 0\\n        acc += (yy - 1) * 365 + (yy - 1) // 4 + (yy - 1) // 400 - (yy - 1) // 100\\n        month = [31,28,31,30,31,30,31,31,30,31,30,31]\\n        if (yy % 100 == 0 and yy % 400 == 0) or (yy % 100 != 0 and yy % 4 == 0):\\n            month[1] = 29\\n        acc += sum(month[:mm - 1])\\n        acc += dd\\n        return acc\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs(self.fromFirstDay(date1) - self.fromFirstDay(date2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518348,
                "title": "python3-this-problem-is-terrible",
                "content": "Take me so much time doing this...\\n\\n\\tclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n    \\n        date1 = date1.split(\"-\")\\n        date2 = date2.split(\"-\")\\n        tem1 = [int(x) for x in date1]\\n        tem2 = [int(x) for x in date2]\\n        \\n        ans = 0\\n        \\n        # Check if date1 > date2 \\n        if tem1[0] > tem2[0] :\\n            tem1, tem2 = tem2, tem1\\n        if tem1[0] == tem2[0] and tem1[1] > tem2[0]:\\n                tem1, tem2 = tem2, tem1\\n        if tem1[0] == tem2[0] and tem1[1] == tem2[1] and tem1[2] > tem2[2]:\\n                tem1, tem2 = tem2, tem1\\n        \\n        # Check leap year or not\\n        def leap_year(year):\\n            if year % 4 != 0:\\n                return False\\n            elif year % 100 != 0:\\n                return True\\n            elif year % 400 != 0:\\n                return False\\n            else:\\n                return True\\n        \\n        # Check 31 days or not\\n        def Month(month):\\n            if month in [1,3,5,7,8,10,12]:\\n                return True\\n            else:\\n                return False\\n            \\n        [y, m ,d] = tem1[:]\\n        \\n        # Reach tem2 or not\\n        while [y, m, d] != tem2:\\n            # Leap year and it\\'s Feb.\\n            if leap_year(y) and m == 2 and d == 28:\\n                ans += 2\\n                m = 3\\n                d = 1\\n                continue\\n            # Not leap year and it\\'s Feb.\\n            elif m == 2 and d == 28:\\n                ans += 1\\n                m = 3\\n                d = 1\\n            # Others\\n            else:\\n                # Big Month day 31?\\n                if Month(m) and d == 31:\\n                    ans += 1\\n                    m += 1\\n                    d = 1\\n                # Small Month day 30?\\n                elif not Month(m) and d == 30:\\n                    ans += 1\\n                    m += 1\\n                    d = 1\\n                # Other days\\n                else:\\n                    ans += 1\\n                    d += 1 \\n            # Exceed Dec. 31\\n            if m == 13:\\n                m = 1\\n                d = 1\\n                y += 1\\n        \\n        return ans\\n            \\n            \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Take me so much time doing this...\\n\\n\\tclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n    \\n        date1 = date1.split(\"-\")\\n        date2 = date2.split(\"-\")\\n        tem1 = [int(x) for x in date1]\\n        tem2 = [int(x) for x in date2]\\n        \\n        ans = 0\\n        \\n        # Check if date1 > date2 \\n        if tem1[0] > tem2[0] :\\n            tem1, tem2 = tem2, tem1\\n        if tem1[0] == tem2[0] and tem1[1] > tem2[0]:\\n                tem1, tem2 = tem2, tem1\\n        if tem1[0] == tem2[0] and tem1[1] == tem2[1] and tem1[2] > tem2[2]:\\n                tem1, tem2 = tem2, tem1\\n        \\n        # Check leap year or not\\n        def leap_year(year):\\n            if year % 4 != 0:\\n                return False\\n            elif year % 100 != 0:\\n                return True\\n            elif year % 400 != 0:\\n                return False\\n            else:\\n                return True\\n        \\n        # Check 31 days or not\\n        def Month(month):\\n            if month in [1,3,5,7,8,10,12]:\\n                return True\\n            else:\\n                return False\\n            \\n        [y, m ,d] = tem1[:]\\n        \\n        # Reach tem2 or not\\n        while [y, m, d] != tem2:\\n            # Leap year and it\\'s Feb.\\n            if leap_year(y) and m == 2 and d == 28:\\n                ans += 2\\n                m = 3\\n                d = 1\\n                continue\\n            # Not leap year and it\\'s Feb.\\n            elif m == 2 and d == 28:\\n                ans += 1\\n                m = 3\\n                d = 1\\n            # Others\\n            else:\\n                # Big Month day 31?\\n                if Month(m) and d == 31:\\n                    ans += 1\\n                    m += 1\\n                    d = 1\\n                # Small Month day 30?\\n                elif not Month(m) and d == 30:\\n                    ans += 1\\n                    m += 1\\n                    d = 1\\n                # Other days\\n                else:\\n                    ans += 1\\n                    d += 1 \\n            # Exceed Dec. 31\\n            if m == 13:\\n                m = 1\\n                d = 1\\n                y += 1\\n        \\n        return ans\\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 518345,
                "title": "python-datetime-faster-than-100",
                "content": "```\\nfrom datetime import date\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        s1,s2 = date1.split(\"-\"), date2.split(\"-\")\\n        d1, d2 = date(int(s1[0]),int(s1[1]),int(s1[2])), date(int(s2[0]),int(s2[1]),int(s2[2]))\\n        return abs((d1-d2).days)",
                "solutionTags": [],
                "code": "```\\nfrom datetime import date\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        s1,s2 = date1.split(\"-\"), date2.split(\"-\")\\n        d1, d2 = date(int(s1[0]),int(s1[1]),int(s1[2])), date(int(s2[0]),int(s2[1]),int(s2[2]))\\n        return abs((d1-d2).days)",
                "codeTag": "Java"
            },
            {
                "id": 518021,
                "title": "java-easy-solution-o-1",
                "content": "import java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        \\n        //return (int) Math.abs(ChronoUnit.DAYS.between(LocalDate.parse(date1), LocalDate.parse(date2)));\\n        \\n        //24-May-2017, change this to your desired Start Date\\n\\tLocalDate dateBefore = LocalDate.parse(date1);\\n        //29-July-2017, change this to your desired End Date\\n\\tLocalDate dateAfter = LocalDate.parse(date2);\\n\\treturn  (int) Math.abs(ChronoUnit.DAYS.between(dateBefore, dateAfter));\\n\\t//System.out.println(noOfDaysBetween);\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        \\n        //return (int) Math.abs(ChronoUnit.DAYS.between(LocalDate.parse(date1), LocalDate.parse(date2)));\\n        \\n        //24-May-2017, change this to your desired Start Date\\n\\tLocalDate dateBefore = LocalDate.parse(date1);\\n        //29-July-2017, change this to your desired End Date\\n\\tLocalDate dateAfter = LocalDate.parse(date2);\\n\\treturn  (int) Math.abs(ChronoUnit.DAYS.between(dateBefore, dateAfter));\\n\\t//System.out.println(noOfDaysBetween);\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 517744,
                "title": "c-one-line",
                "content": "```\\npublic class Solution {\\n    public int DaysBetweenDates(string date1, string date2) {\\n        return (int)Math.Abs((DateTime.Parse(date1)-DateTime.Parse(date2)).TotalDays);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DaysBetweenDates(string date1, string date2) {\\n        return (int)Math.Abs((DateTime.Parse(date1)-DateTime.Parse(date2)).TotalDays);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623035,
                "title": "standard-java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n// firstly import localdate and chronoUnit directory of time\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        // initialise dates in type<LocalDate>\\n        LocalDate d1 = LocalDate.parse(date1);\\n        LocalDate d2 = LocalDate.parse(date2);\\n        \\n        // calculate the absolute difference between dates using chronoUnit and \\n        // store it in long as it will return long value\\n        long days = Math.abs(ChronoUnit.DAYS.between(d1, d2));\\n        \\n        // convert long into int and return the date\\n        return (int)days;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// firstly import localdate and chronoUnit directory of time\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        // initialise dates in type<LocalDate>\\n        LocalDate d1 = LocalDate.parse(date1);\\n        LocalDate d2 = LocalDate.parse(date2);\\n        \\n        // calculate the absolute difference between dates using chronoUnit and \\n        // store it in long as it will return long value\\n        long days = Math.abs(ChronoUnit.DAYS.between(d1, d2));\\n        \\n        // convert long into int and return the date\\n        return (int)days;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326091,
                "title": "python3-datetime-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDatetime\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        x = datetime.strptime(date1, \\'%Y-%m-%d\\')\\n        y = datetime.strptime(date2, \\'%Y-%m-%d\\')\\n        return abs((y - x).days)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nfrom datetime import datetime\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        x = datetime.strptime(date1, \\'%Y-%m-%d\\')\\n        y = datetime.strptime(date2, \\'%Y-%m-%d\\')\\n        return abs((y - x).days)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482428,
                "title": "my-kotlin-solution-with-time-o-1-and-space-o-1",
                "content": "Below is my solution in kotlin. I think it is better than its cousin who asks for weekday...\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) and Space O(1);\\n     */\\n    fun daysBetweenDates(date1: String, date2: String): Int {\\n\\n        fun isLeapYear(year: Int) = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\\n\\n        fun dayOfTheYearAtMonthEnd(year: Int, month: Int): Int {\\n            val monthToDayOfNonLeapYear =\\n                intArrayOf(0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)\\n            return monthToDayOfNonLeapYear[month] + if (month >= 2 && isLeapYear(year)) 1 else 0\\n        }\\n\\n        fun dayOfTheYear(year: Int, month: Int, day: Int): Int {\\n            return dayOfTheYearAtMonthEnd(year, month - 1) + day\\n        }\\n\\n        fun dayDiffTo_2000_01_01(year: Int, month: Int, day: Int): Int {\\n            val yearDiff = year - 2000\\n            val yearDIffInDay =\\n                if (yearDiff > 0) {\\n                    val calibratedDiff = yearDiff - 1\\n                    1 + 365 * yearDiff + calibratedDiff / 4 - calibratedDiff / 100 + calibratedDiff / 400\\n                } else {\\n                    365 * yearDiff + yearDiff / 4 - yearDiff / 100 + yearDiff / 400\\n                }\\n            val dayOfTheYear = dayOfTheYear(year, month, day)\\n            return yearDIffInDay + (dayOfTheYear - 1)\\n        }\\n\\n        val (year1, month1, day1) = date1.split(\"-\").map { it.toInt() }\\n        val (year2, month2, day2) = date2.split(\"-\").map { it.toInt() }\\n\\n        return Math.abs(dayDiffTo_2000_01_01(year1, month1, day1) - dayDiffTo_2000_01_01(year2, month2, day2))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) and Space O(1);\\n     */\\n    fun daysBetweenDates(date1: String, date2: String): Int {\\n\\n        fun isLeapYear(year: Int) = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\\n\\n        fun dayOfTheYearAtMonthEnd(year: Int, month: Int): Int {\\n            val monthToDayOfNonLeapYear =\\n                intArrayOf(0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)\\n            return monthToDayOfNonLeapYear[month] + if (month >= 2 && isLeapYear(year)) 1 else 0\\n        }\\n\\n        fun dayOfTheYear(year: Int, month: Int, day: Int): Int {\\n            return dayOfTheYearAtMonthEnd(year, month - 1) + day\\n        }\\n\\n        fun dayDiffTo_2000_01_01(year: Int, month: Int, day: Int): Int {\\n            val yearDiff = year - 2000\\n            val yearDIffInDay =\\n                if (yearDiff > 0) {\\n                    val calibratedDiff = yearDiff - 1\\n                    1 + 365 * yearDiff + calibratedDiff / 4 - calibratedDiff / 100 + calibratedDiff / 400\\n                } else {\\n                    365 * yearDiff + yearDiff / 4 - yearDiff / 100 + yearDiff / 400\\n                }\\n            val dayOfTheYear = dayOfTheYear(year, month, day)\\n            return yearDIffInDay + (dayOfTheYear - 1)\\n        }\\n\\n        val (year1, month1, day1) = date1.split(\"-\").map { it.toInt() }\\n        val (year2, month2, day2) = date2.split(\"-\").map { it.toInt() }\\n\\n        return Math.abs(dayDiffTo_2000_01_01(year1, month1, day1) - dayDiffTo_2000_01_01(year2, month2, day2))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288199,
                "title": "rust-solution",
                "content": "```\\npub fn days_between_dates(date1: String, date2: String) -> i32 {\\n\\tfn is_leap(year: i32) -> bool {\\n\\t\\t(year % 4 == 0 && year % 100 != 0) || year % 400 == 0\\n\\t}\\n\\n\\tfn f(date: String) -> i32 {\\n\\t\\tconst MONTH_DAYS: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\n\\t\\tlet array = date\\n\\t\\t\\t.split(\"-\")\\n\\t\\t\\t.map(|item| item.parse().unwrap())\\n\\t\\t\\t.collect::<Vec<i32>>();\\n\\n\\t\\tlet year = array[0];\\n\\t\\tlet month = array[1];\\n\\t\\tlet mut days = array[2];\\n\\n\\t\\tfor i in 1970..year {\\n\\t\\t\\tif is_leap(i) { days += 366; }\\n\\t\\t\\telse { days += 365; }\\n\\t\\t}\\n\\n\\t\\tfor i in 1..month {\\n\\t\\t\\tif i == 2 && is_leap(year) { days += 1; }\\n\\t\\t\\tdays += MONTH_DAYS[i as usize - 1];\\n\\t\\t}\\n\\n\\t\\tdays\\n\\t}\\n\\n\\ti32::abs(f(date1) - f(date2))\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn days_between_dates(date1: String, date2: String) -> i32 {\\n\\tfn is_leap(year: i32) -> bool {\\n\\t\\t(year % 4 == 0 && year % 100 != 0) || year % 400 == 0\\n\\t}\\n\\n\\tfn f(date: String) -> i32 {\\n\\t\\tconst MONTH_DAYS: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\n\\t\\tlet array = date\\n\\t\\t\\t.split(\"-\")\\n\\t\\t\\t.map(|item| item.parse().unwrap())\\n\\t\\t\\t.collect::<Vec<i32>>();\\n\\n\\t\\tlet year = array[0];\\n\\t\\tlet month = array[1];\\n\\t\\tlet mut days = array[2];\\n\\n\\t\\tfor i in 1970..year {\\n\\t\\t\\tif is_leap(i) { days += 366; }\\n\\t\\t\\telse { days += 365; }\\n\\t\\t}\\n\\n\\t\\tfor i in 1..month {\\n\\t\\t\\tif i == 2 && is_leap(year) { days += 1; }\\n\\t\\t\\tdays += MONTH_DAYS[i as usize - 1];\\n\\t\\t}\\n\\n\\t\\tdays\\n\\t}\\n\\n\\ti32::abs(f(date1) - f(date2))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262684,
                "title": "c-convert-to-datetime",
                "content": "```\\npublic class Solution {\\n    public int DaysBetweenDates(string date1, string date2) {\\n        DateTime startDate = Convert.ToDateTime(date1);\\n        DateTime endDate = Convert.ToDateTime(date2);\\n        \\n        return (int)Math.Abs((endDate - startDate).TotalDays);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DaysBetweenDates(string date1, string date2) {\\n        DateTime startDate = Convert.ToDateTime(date1);\\n        DateTime endDate = Convert.ToDateTime(date2);\\n        \\n        return (int)Math.Abs((endDate - startDate).TotalDays);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126006,
                "title": "javascript-1-line",
                "content": "```\\nconst daysBetweenDates = (D1, D2, DF = Math.abs((new Date(D1) - new Date(D2)))) => DF / (1000 * 60 * 60 * 24)\\n```\\n\\n```\\nconst daysBetweenDates = (D1, D2) => Math.abs((Date.parse(D1) - Date.parse(D2))) / 86400000\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst daysBetweenDates = (D1, D2, DF = Math.abs((new Date(D1) - new Date(D2)))) => DF / (1000 * 60 * 60 * 24)\\n```\n```\\nconst daysBetweenDates = (D1, D2) => Math.abs((Date.parse(D1) - Date.parse(D2))) / 86400000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075927,
                "title": "simplest-python-solution-using-datetime-package",
                "content": "\\n        import datetime\\n        \\n        year1=int(date1[:4])\\n        year2=int(date2[:4])\\n        month1=int(date1[5:7])\\n        month2=int(date2[5:7])\\n        day1=int(date1[8:])\\n        day2=int(date2[8:])\\n        x1=datetime.datetime(year1,month1,day1)\\n        x2=datetime.datetime(year2,month2,day2)\\n        return abs((x2-x1).days)\\n",
                "solutionTags": [],
                "code": "\\n        import datetime\\n        \\n        year1=int(date1[:4])\\n        year2=int(date2[:4])\\n        month1=int(date1[5:7])\\n        month2=int(date2[5:7])\\n        day1=int(date1[8:])\\n        day2=int(date2[8:])\\n        x1=datetime.datetime(year1,month1,day1)\\n        x2=datetime.datetime(year2,month2,day2)\\n        return abs((x2-x1).days)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2014651,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5e7b2d43-5068-4fd0-985b-33e8428f666e_1651865245.7593138.png)\\n\\n\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \"\"\" O(gap_years)T O(1)S \"\"\"\\n        is_leap = lambda y: (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)\\n        days = lambda y, m, d: sum([31, 28 + is_leap(y), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:m - 1]) + d\\n        total = lambda y, m, d: sum(365 + is_leap(y) for y in range(1971, y)) + days(y, m, d)\\n        return abs(total(*map(int, date1.split(\\'-\\'))) - total(*map(int, date2.split(\\'-\\'))))",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5e7b2d43-5068-4fd0-985b-33e8428f666e_1651865245.7593138.png)\\n\\n\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \"\"\" O(gap_years)T O(1)S \"\"\"\\n        is_leap = lambda y: (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)\\n        days = lambda y, m, d: sum([31, 28 + is_leap(y), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:m - 1]) + d\\n        total = lambda y, m, d: sum(365 + is_leap(y) for y in range(1971, y)) + days(y, m, d)\\n        return abs(total(*map(int, date1.split(\\'-\\'))) - total(*map(int, date2.split(\\'-\\'))))",
                "codeTag": "Python3"
            },
            {
                "id": 1989804,
                "title": "c-0ms-faster-than-100-5-8mb-less-than-93",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Number of Days Between Two Dates.\\nMemory Usage: 5.8 MB, less than 93.52% of C++ online submissions for Number of Days Between Two Dates.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int daysBetweenDates(string& date1, string& date2) \\n    {\\n        int y1 = std::stoi(date1.substr(0, 4).c_str());\\n        int m1 = std::stoi(date1.substr(5, 2).c_str());\\n        int d1 = std::stoi(date1.substr(8, 2).c_str());\\n        \\n        int y2 = std::stoi(date2.substr(0, 4).c_str());\\n        int m2 = std::stoi(date2.substr(5, 2).c_str());\\n        int d2 = std::stoi(date2.substr(8, 2).c_str());\\n        \\n        int n1 = numDayFrom1900(d1, m1, y1);\\n        int n2 = numDayFrom1900(d2, m2, y2);\\n        \\n        return std::abs(n2 - n1);\\n    }\\nprivate:\\n    int numDayFrom1900(int d, int m, int y)\\n    {\\n        int dom[] = { 31,\\n                      28,\\n                      31,\\n                      30,\\n                      31,\\n                      30,\\n                      31,\\n                      31,\\n                      30,\\n                      31,\\n                      30,\\n                      31 };\\n        \\n        int n = 0;\\n        for (int i = 1900; i < y; i++)\\n        {\\n            n += (365 + isLeap(i));\\n        }\\n        \\n        for (int i = 1; i < m; i++)\\n            n += dom[i - 1];\\n        n += ((m > 2) ? isLeap(y) : 0); \\n        n += d;\\n        \\n        return n;\\n    }\\n    \\n    bool isLeap(int year)\\n    {\\n        if(year % 400 == 0 || (year % 4 == 0  && year % 100 != 0))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int daysBetweenDates(string& date1, string& date2) \\n    {\\n        int y1 = std::stoi(date1.substr(0, 4).c_str());\\n        int m1 = std::stoi(date1.substr(5, 2).c_str());\\n        int d1 = std::stoi(date1.substr(8, 2).c_str());\\n        \\n        int y2 = std::stoi(date2.substr(0, 4).c_str());\\n        int m2 = std::stoi(date2.substr(5, 2).c_str());\\n        int d2 = std::stoi(date2.substr(8, 2).c_str());\\n        \\n        int n1 = numDayFrom1900(d1, m1, y1);\\n        int n2 = numDayFrom1900(d2, m2, y2);\\n        \\n        return std::abs(n2 - n1);\\n    }\\nprivate:\\n    int numDayFrom1900(int d, int m, int y)\\n    {\\n        int dom[] = { 31,\\n                      28,\\n                      31,\\n                      30,\\n                      31,\\n                      30,\\n                      31,\\n                      31,\\n                      30,\\n                      31,\\n                      30,\\n                      31 };\\n        \\n        int n = 0;\\n        for (int i = 1900; i < y; i++)\\n        {\\n            n += (365 + isLeap(i));\\n        }\\n        \\n        for (int i = 1; i < m; i++)\\n            n += dom[i - 1];\\n        n += ((m > 2) ? isLeap(y) : 0); \\n        n += d;\\n        \\n        return n;\\n    }\\n    \\n    bool isLeap(int year)\\n    {\\n        if(year % 400 == 0 || (year % 4 == 0  && year % 100 != 0))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986743,
                "title": "python-just-counting-no-libraries",
                "content": "```\\nclass Solution:\\n    month_days = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31,\\n                  6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}\\n    \\n    def is_leap(self, year):\\n        if year % 400 == 0: return True\\n        if year % 100 == 0: return False        \\n        return year % 4 == 0\\n    \\n    def move_day(self, y, m, d):        \\n        d += 1\\n        month_last_day = self.month_days[m]\\n        if m == 2 and self.is_leap(y): month_last_day += 1\\n        if d > month_last_day:\\n            d = 1\\n            m += 1\\n\\n        if m == 13:\\n            m = 1\\n            y += 1   \\n            \\n        return y, m, d\\n        \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        if date1 > date2: date1, date2 = date2, date1\\n        y1, m1, d1 = list(map(int, date1.split(\\'-\\')))\\n        y2, m2, d2 = list(map(int, date2.split(\\'-\\')))\\n        days = 0\\n            \\n        while y1 < y2 or m1 < m2 or d1 < d2:\\n            y1, m1, d1 = self.move_day(y1, m1, d1)\\n            days += 1\\n        return days\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    month_days = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31,\\n                  6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}\\n    \\n    def is_leap(self, year):\\n        if year % 400 == 0: return True\\n        if year % 100 == 0: return False        \\n        return year % 4 == 0\\n    \\n    def move_day(self, y, m, d):        \\n        d += 1\\n        month_last_day = self.month_days[m]\\n        if m == 2 and self.is_leap(y): month_last_day += 1\\n        if d > month_last_day:\\n            d = 1\\n            m += 1\\n\\n        if m == 13:\\n            m = 1\\n            y += 1   \\n            \\n        return y, m, d\\n        \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        if date1 > date2: date1, date2 = date2, date1\\n        y1, m1, d1 = list(map(int, date1.split(\\'-\\')))\\n        y2, m2, d2 = list(map(int, date2.split(\\'-\\')))\\n        days = 0\\n            \\n        while y1 < y2 or m1 < m2 or d1 < d2:\\n            y1, m1, d1 = self.move_day(y1, m1, d1)\\n            days += 1\\n        return days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908543,
                "title": "java-simple-solution",
                "content": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        LocalDate startDate = LocalDate.parse(date1);\\n        LocalDate endDate = LocalDate.parse(date2);\\n        return (int) Math.abs(ChronoUnit.DAYS.between(startDate, endDate));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        LocalDate startDate = LocalDate.parse(date1);\\n        LocalDate endDate = LocalDate.parse(date2);\\n        return (int) Math.abs(ChronoUnit.DAYS.between(startDate, endDate));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878413,
                "title": "python-solution-1360",
                "content": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        year1, month1, day1 = date1[0:4], date1[5:7], date1[8:10]\\n        year2, month2, day2 = date2[0:4], date2[5:7], date2[8:10]\\n        d1 = datetime.datetime(int(year1), int(month1) , int(day1))   # date1\\n        d2 = datetime.datetime(int(year2), int(month2) , int(day2))   # date2\\n        return abs((d1 - d2).days)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        year1, month1, day1 = date1[0:4], date1[5:7], date1[8:10]\\n        year2, month2, day2 = date2[0:4], date2[5:7], date2[8:10]\\n        d1 = datetime.datetime(int(year1), int(month1) , int(day1))   # date1\\n        d2 = datetime.datetime(int(year2), int(month2) , int(day2))   # date2\\n        return abs((d1 - d2).days)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858959,
                "title": "easy-python-solution-no-external-library",
                "content": "```\\nclass Solution:\\n    def is_leap_year(self, year):\\n        if (year%4==0 and year%100!=0) or year%400 == 0:\\n            return True\\n        return False\\n    \\n    def count_days(self,date):\\n        date = date.split(\\'-\\')\\n        year = int(date[0])\\n        month = int(date[1])\\n        days = int(date[2])\\n        \\n        res = 0\\n        \\n        month_mp = {\\n            1 : 31,\\n            2 : 28,\\n            3 : 31,\\n            4 : 30,\\n            5 : 31,\\n            6 : 30,\\n            7 : 31,\\n            8 : 31, \\n            9 : 30,\\n            10 : 31, \\n            11 : 30, \\n            12 : 31\\n        }\\n        \\n        for i in range(1970, year, 1):\\n            if self.is_leap_year(i):\\n                res += 366\\n            else:\\n                res += 365\\n                \\n        for i in range(1,month):\\n            if self.is_leap_year(year) and i == 2:\\n                res += month_mp[i] + 1\\n            else:\\n                res += month_mp[i]\\n        \\n        res += days\\n        \\n        return res\\n            \\n                \\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs(self.count_days(date1) - self.count_days(date2))\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def is_leap_year(self, year):\\n        if (year%4==0 and year%100!=0) or year%400 == 0:\\n            return True\\n        return False\\n    \\n    def count_days(self,date):\\n        date = date.split(\\'-\\')\\n        year = int(date[0])\\n        month = int(date[1])\\n        days = int(date[2])\\n        \\n        res = 0\\n        \\n        month_mp = {\\n            1 : 31,\\n            2 : 28,\\n            3 : 31,\\n            4 : 30,\\n            5 : 31,\\n            6 : 30,\\n            7 : 31,\\n            8 : 31, \\n            9 : 30,\\n            10 : 31, \\n            11 : 30, \\n            12 : 31\\n        }\\n        \\n        for i in range(1970, year, 1):\\n            if self.is_leap_year(i):\\n                res += 366\\n            else:\\n                res += 365\\n                \\n        for i in range(1,month):\\n            if self.is_leap_year(year) and i == 2:\\n                res += month_mp[i] + 1\\n            else:\\n                res += month_mp[i]\\n        \\n        res += days\\n        \\n        return res\\n            \\n                \\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs(self.count_days(date1) - self.count_days(date2))\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814533,
                "title": "python-solution-not-using-datetime-fast-and-memory-efficient",
                "content": "```\\nclass Solution:\\n    \\n    def getYear(self, year):\\n        \\n        \"\"\"\\n        Get how many days are in year.\\n        \"\"\"\\n        \\n        if year % 100 == 0:\\n            if year % 400 == 0:\\n                return 366\\n            return 365\\n        \\n        if year % 4 == 0:\\n            return 366\\n        return 365\\n    \\n    def getRestOfYear(self, year, month, day):\\n        \\n        \"\"\"\\n        Get how many days are left in the year.\\n        \"\"\"\\n        \\n        months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        if year % 4 == 0:\\n            \\n            months[1] += 1\\n\\n        return months[month-1] - day + sum(m for m in months[month:])\\n    \\n    def differentYears(self, date1_tuple, date2_tuple):\\n        \\n        \"\"\"\\n        Get days when years are different.\\n        \"\"\"\\n        \\n        year1, month1, day1 = date1_tuple\\n        year2, month2, day2 = date2_tuple\\n        \\n        # Get how many days are left in smaller date\\n        ans = self.getRestOfYear(year2, month2, day2)\\n            \\n        year2 += 1\\n            \\n        # Get how many days are in years in the middle\\n        while year1 > year2:\\n                \\n            ans += self.getYear(year2)\\n            year2 += 1\\n                \\n        # Get how many days have passed in greater date\\n        ans += self.getYear(year1) - self.getRestOfYear(year1, month1, day1) \\n                \\n        return ans\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        (year1, month1, day1) = date1.split(\\'-\\')\\n        (year2, month2, day2) = date2.split(\\'-\\')\\n        \\n        year1 = int(year1); year2 = int(year2)\\n        month1 = int(month1); month2 = int(month2)\\n        day1 = int(day1); day2 = int(day2)\\n        \\n        date1_tuple = (year1, month1, day1)\\n        date2_tuple = (year2, month2, day2)\\n        \\n        if year1 == year2:\\n            \\n            # Substract absolute value of sums\\n            if month1 == month2:\\n                \\n                return abs(day1 - day2)\\n            \\n            # Substract the remaining days of the year for each date to get days between them\\n            elif month1 > month2:\\n                \\n                return self.getRestOfYear(year1, month2, day2) - self.getRestOfYear(year1, month1, day1)\\n            else:\\n                \\n                return self.getRestOfYear(year1, month1, day1) - self.getRestOfYear(year1, month2, day2)\\n                                                                                    \\n        elif year1 > year2:\\n            \\n            \\n            return self.differentYears(date1_tuple, date2_tuple)\\n        \\n        else:\\n            \\n            return self.differentYears(date2_tuple, date1_tuple)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def getYear(self, year):\\n        \\n        \"\"\"\\n        Get how many days are in year.\\n        \"\"\"\\n        \\n        if year % 100 == 0:\\n            if year % 400 == 0:\\n                return 366\\n            return 365\\n        \\n        if year % 4 == 0:\\n            return 366\\n        return 365\\n    \\n    def getRestOfYear(self, year, month, day):\\n        \\n        \"\"\"\\n        Get how many days are left in the year.\\n        \"\"\"\\n        \\n        months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        if year % 4 == 0:\\n            \\n            months[1] += 1\\n\\n        return months[month-1] - day + sum(m for m in months[month:])\\n    \\n    def differentYears(self, date1_tuple, date2_tuple):\\n        \\n        \"\"\"\\n        Get days when years are different.\\n        \"\"\"\\n        \\n        year1, month1, day1 = date1_tuple\\n        year2, month2, day2 = date2_tuple\\n        \\n        # Get how many days are left in smaller date\\n        ans = self.getRestOfYear(year2, month2, day2)\\n            \\n        year2 += 1\\n            \\n        # Get how many days are in years in the middle\\n        while year1 > year2:\\n                \\n            ans += self.getYear(year2)\\n            year2 += 1\\n                \\n        # Get how many days have passed in greater date\\n        ans += self.getYear(year1) - self.getRestOfYear(year1, month1, day1) \\n                \\n        return ans\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        (year1, month1, day1) = date1.split(\\'-\\')\\n        (year2, month2, day2) = date2.split(\\'-\\')\\n        \\n        year1 = int(year1); year2 = int(year2)\\n        month1 = int(month1); month2 = int(month2)\\n        day1 = int(day1); day2 = int(day2)\\n        \\n        date1_tuple = (year1, month1, day1)\\n        date2_tuple = (year2, month2, day2)\\n        \\n        if year1 == year2:\\n            \\n            # Substract absolute value of sums\\n            if month1 == month2:\\n                \\n                return abs(day1 - day2)\\n            \\n            # Substract the remaining days of the year for each date to get days between them\\n            elif month1 > month2:\\n                \\n                return self.getRestOfYear(year1, month2, day2) - self.getRestOfYear(year1, month1, day1)\\n            else:\\n                \\n                return self.getRestOfYear(year1, month1, day1) - self.getRestOfYear(year1, month2, day2)\\n                                                                                    \\n        elif year1 > year2:\\n            \\n            \\n            return self.differentYears(date1_tuple, date2_tuple)\\n        \\n        else:\\n            \\n            return self.differentYears(date2_tuple, date1_tuple)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730059,
                "title": "java-clear-solution",
                "content": "~~~java\\n\\nclass Solution {\\n    int[] dayInMonth = new int[]{\\n        0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\\n    };\\n    \\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] s1 = date1.split(\"-\");\\n        String[] s2 = date2.split(\"-\");\\n        int y1 = Integer.parseInt(s1[0]), m1 = Integer.parseInt(s1[1]), d1 = Integer.parseInt(s1[2]);\\n        int y2 = Integer.parseInt(s2[0]), m2 = Integer.parseInt(s2[1]), d2 = Integer.parseInt(s2[2]);\\n        if (y1 > y2 || y1 == y2 && m1 > m2 || y1 == y2 && m1 == m2 && d1 > d2) {\\n            int tempY = y1, tempM = m1, tempD = d1;\\n            y1 = y2;\\n            m1 = m2;\\n            d1 = d2;\\n            y2 = tempY;\\n            m2 = tempM;\\n            d2 = tempD;\\n        }\\n        \\n        return daysBetweenYears(y1, y2)\\n            + daysFromStart(y2, m2, d2)\\n            - daysFromStart(y1, m1, d1);\\n    }\\n    \\n    private int daysBetweenYears(int year1, int year2) {\\n        int days = 0;\\n        for (int i = year1; i < year2; i++) {\\n            days += 365;\\n            if (isLeap(i)) {\\n                days++;\\n            }\\n        }\\n        return days;\\n    }\\n    \\n    private int daysFromStart(int y, int m, int d) {\\n        int days = d;\\n        for (int i = 1; i < m; i++) {\\n            days += dayInMonth[i];\\n        }\\n        if (m > 2 && isLeap(y)) {\\n            days++;\\n        }\\n        return days;\\n    }\\n    \\n    private boolean isLeap(int y) {\\n        return y % 4 == 0 && y % 100 != 0\\n            || y % 400 == 0;\\n    }\\n}\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] dayInMonth = new int[]{\\n        0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1711148,
                "title": "java-2-methods-explained",
                "content": "**T/S:** O(1)/O(1) for both methods\\n\\n**Method 1:** Using [Time API](https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html). This will be rejected in an interview\\n```\\nimport static java.time.LocalDate.parse;\\nimport static java.time.temporal.ChronoUnit.DAYS;\\n\\npublic int daysBetweenDates(String date1, String date2) {\\n\\treturn (int) Math.abs(DAYS.between(parse(date1), parse(date2)));\\n}\\n```\\n**Method 2:** \\n* Count days since Jan 1, 1971 for the two dates\\n* Find the difference between them\\n```\\nprivate static final int[] DAYS_IN_MONTH = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nprivate record MyDate(int year, int month, int day) {}\\n\\npublic int daysBetweenDates(String date1, String date2) {\\n\\treturn Math.abs(daysSince1971(strToDate(date1)) - daysSince1971(strToDate(date2)));\\n}\\n\\nprivate MyDate strToDate(String s) {\\n\\tvar parts = s.split(\"-\");\\n\\treturn new MyDate(Integer.parseInt(parts[0]), // year\\n\\t\\t\\t\\t\\t  Integer.parseInt(parts[1]), // month\\n\\t\\t\\t\\t\\t  Integer.parseInt(parts[2])); // day\\n}\\n\\nprivate int daysSince1971(MyDate date) {\\n\\tvar days = date.day;\\n\\t// If the year is leap and month after Feb, then add a day since leap Febs have an extra day\\n\\tif (isLeapYear(date.year) && date.month > 2) \\n\\t\\tdays++;\\n\\n\\tfor (var y = 1971; y < date.year; y++)\\n\\t\\tdays += isLeapYear(y) ? 366 : 365;\\n\\n\\tfor (var m = 1; m < date.month; m++)\\n\\t\\tdays += DAYS_IN_MONTH[m];\\n\\n\\treturn days;\\n}\\n\\nprivate boolean isLeapYear(int year) {\\n\\tif (year % 100 == 0)\\n\\t\\treturn year % 400 == 0;\\n\\treturn year % 4 == 0;\\n}\\n```\\n**Note:** For Java 14 or below, replace `record` with:\\n```\\nclass MyDate {\\n\\tint year, month, day;\\n\\n\\tpublic MyDate(int year, int month, int day) {\\n\\t\\tthis.year = year;\\n\\t\\tthis.month = month;\\n\\t\\tthis.day = day;\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport static java.time.LocalDate.parse;\\nimport static java.time.temporal.ChronoUnit.DAYS;\\n\\npublic int daysBetweenDates(String date1, String date2) {\\n\\treturn (int) Math.abs(DAYS.between(parse(date1), parse(date2)));\\n}\\n```\n```\\nprivate static final int[] DAYS_IN_MONTH = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nprivate record MyDate(int year, int month, int day) {}\\n\\npublic int daysBetweenDates(String date1, String date2) {\\n\\treturn Math.abs(daysSince1971(strToDate(date1)) - daysSince1971(strToDate(date2)));\\n}\\n\\nprivate MyDate strToDate(String s) {\\n\\tvar parts = s.split(\"-\");\\n\\treturn new MyDate(Integer.parseInt(parts[0]), // year\\n\\t\\t\\t\\t\\t  Integer.parseInt(parts[1]), // month\\n\\t\\t\\t\\t\\t  Integer.parseInt(parts[2])); // day\\n}\\n\\nprivate int daysSince1971(MyDate date) {\\n\\tvar days = date.day;\\n\\t// If the year is leap and month after Feb, then add a day since leap Febs have an extra day\\n\\tif (isLeapYear(date.year) && date.month > 2) \\n\\t\\tdays++;\\n\\n\\tfor (var y = 1971; y < date.year; y++)\\n\\t\\tdays += isLeapYear(y) ? 366 : 365;\\n\\n\\tfor (var m = 1; m < date.month; m++)\\n\\t\\tdays += DAYS_IN_MONTH[m];\\n\\n\\treturn days;\\n}\\n\\nprivate boolean isLeapYear(int year) {\\n\\tif (year % 100 == 0)\\n\\t\\treturn year % 400 == 0;\\n\\treturn year % 4 == 0;\\n}\\n```\n```\\nclass MyDate {\\n\\tint year, month, day;\\n\\n\\tpublic MyDate(int year, int month, int day) {\\n\\t\\tthis.year = year;\\n\\t\\tthis.month = month;\\n\\t\\tthis.day = day;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664501,
                "title": "python-verbose-solution",
                "content": "```\\nclass Solution:\\n    \\n    monthDays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    \\n    def isLeapYear(self, year: int) -> bool:\\n        return year % 4 == 0 and (year % 100 != 0 or year % 1000 == 0)\\n    \\n    def getDaysOfYearsSince1971(self, year: int) -> int:\\n        return sum(366 if self.isLeapYear(cur) else 365 for cur in range(1971, year))\\n    \\n    def getDaysOfMonths(self, year: int, month: int) -> int:\\n        return sum(self.monthDays[i] + int(self.isLeapYear(year) and i == 2) for i in range(1, month))    \\n    \\n    def getDaysSince1971(self, year: int, month: int, day: int) -> int:\\n        return self.getDaysOfYearsSince1971(year) + self.getDaysOfMonths(year, month) + day\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        year1, month1, day1 = map(int, date1.split(\\'-\\'))\\n        year2, month2, day2 = map(int, date2.split(\\'-\\'))\\n        daysOfDate1 = self.getDaysSince1971(year1, month1, day1)\\n        daysOfDate2 = self.getDaysSince1971(year2, month2, day2)\\n        return abs(daysOfDate1 - daysOfDate2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    monthDays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    \\n    def isLeapYear(self, year: int) -> bool:\\n        return year % 4 == 0 and (year % 100 != 0 or year % 1000 == 0)\\n    \\n    def getDaysOfYearsSince1971(self, year: int) -> int:\\n        return sum(366 if self.isLeapYear(cur) else 365 for cur in range(1971, year))\\n    \\n    def getDaysOfMonths(self, year: int, month: int) -> int:\\n        return sum(self.monthDays[i] + int(self.isLeapYear(year) and i == 2) for i in range(1, month))    \\n    \\n    def getDaysSince1971(self, year: int, month: int, day: int) -> int:\\n        return self.getDaysOfYearsSince1971(year) + self.getDaysOfMonths(year, month) + day\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        year1, month1, day1 = map(int, date1.split(\\'-\\'))\\n        year2, month2, day2 = map(int, date2.split(\\'-\\'))\\n        daysOfDate1 = self.getDaysSince1971(year1, month1, day1)\\n        daysOfDate2 = self.getDaysSince1971(year2, month2, day2)\\n        return abs(daysOfDate1 - daysOfDate2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617513,
                "title": "rust-fast-100",
                "content": "```\\nstruct Solution{}\\nimpl Solution {\\n    pub fn days_between_dates(date1: String, date2: String) -> i32 {\\n        i32::abs(str2date(date2) - str2date(date1))\\n    }\\n}\\nfn str2date(s :String)->i32{\\n    let months:Vec<i32> = vec![31,28,31,30,31,30,31,31,30,31,30,31];\\n    let  day =  s.split(\\'-\\').nth(2).unwrap().parse::<i32>().unwrap();\\n    let  month = s.split(\\'-\\').nth(1).unwrap().parse::<i32>().unwrap() - 1;\\n    let  year = s.split(\\'-\\').nth(0).unwrap().parse::<i32>().unwrap();\\n    let mut sum =366;\\n    let mut _month = 0;\\n    for i in 1901..=year{\\n        if i < year{\\n            if (i % 4 == 0 && i % 100 != 0 ) || i % 400 == 0{\\n                sum += 366;\\n            }else{\\n                sum += 365;\\n            }\\n        }\\n        if i == year{\\n             _month = months.iter().enumerate().filter(|(x,_)| x < &(month as usize)).fold(0,|x,y| x+y.1);\\n            if  ((i % 4 == 0 && i % 100 != 0 ) || i % 400 == 0 ) && month > 1 {\\n                sum += 1;\\n            }\\n            sum += _month + day;           \\n        }\\n    }\\n   \\n    sum\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::days_between_dates(\"2009-08-18\".to_string(), \"2080-08-08\".to_string())); \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn main_test(){\\n         assert_eq!(Solution::days_between_dates(\"2019-06-29\".to_string(), \"2019-06-30\".to_string()),1);\\n         assert_eq!(Solution::days_between_dates(\"2020-01-15\".to_string(), \"2019-12-31\".to_string()),15);\\n         assert_eq!(Solution::days_between_dates(\"2009-08-18\".to_string(), \"2080-08-08\".to_string()),25923);\\n         assert_eq!(Solution::days_between_dates(\"2074-09-12\".to_string(), \"1983-01-08\".to_string()),33485);\\n         assert_eq!(Solution::days_between_dates(\"2100-09-22\".to_string(), \"1991-03-12\".to_string()),40006);\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct Solution{}\\nimpl Solution {\\n    pub fn days_between_dates(date1: String, date2: String) -> i32 {\\n        i32::abs(str2date(date2) - str2date(date1))\\n    }\\n}\\nfn str2date(s :String)->i32{\\n    let months:Vec<i32> = vec![31,28,31,30,31,30,31,31,30,31,30,31];\\n    let  day =  s.split(\\'-\\').nth(2).unwrap().parse::<i32>().unwrap();\\n    let  month = s.split(\\'-\\').nth(1).unwrap().parse::<i32>().unwrap() - 1;\\n    let  year = s.split(\\'-\\').nth(0).unwrap().parse::<i32>().unwrap();\\n    let mut sum =366;\\n    let mut _month = 0;\\n    for i in 1901..=year{\\n        if i < year{\\n            if (i % 4 == 0 && i % 100 != 0 ) || i % 400 == 0{\\n                sum += 366;\\n            }else{\\n                sum += 365;\\n            }\\n        }\\n        if i == year{\\n             _month = months.iter().enumerate().filter(|(x,_)| x < &(month as usize)).fold(0,|x,y| x+y.1);\\n            if  ((i % 4 == 0 && i % 100 != 0 ) || i % 400 == 0 ) && month > 1 {\\n                sum += 1;\\n            }\\n            sum += _month + day;           \\n        }\\n    }\\n   \\n    sum\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::days_between_dates(\"2009-08-18\".to_string(), \"2080-08-08\".to_string())); \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn main_test(){\\n         assert_eq!(Solution::days_between_dates(\"2019-06-29\".to_string(), \"2019-06-30\".to_string()),1);\\n         assert_eq!(Solution::days_between_dates(\"2020-01-15\".to_string(), \"2019-12-31\".to_string()),15);\\n         assert_eq!(Solution::days_between_dates(\"2009-08-18\".to_string(), \"2080-08-08\".to_string()),25923);\\n         assert_eq!(Solution::days_between_dates(\"2074-09-12\".to_string(), \"1983-01-08\".to_string()),33485);\\n         assert_eq!(Solution::days_between_dates(\"2100-09-22\".to_string(), \"1991-03-12\".to_string()),40006);\\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548007,
                "title": "go-time-o-1-0-ms-100-space-o-1-2-1-mb-33-33",
                "content": "```\\nfunc daysBetweenDates(date1 string, date2 string) int {\\n    t1, _ := time.Parse(time.RFC3339, date1 + \"T00:00:00.000Z\")\\n    t2, _ := time.Parse(time.RFC3339, date2 + \"T00:00:00.000Z\")\\n    \\n    return int(math.Abs(t2.Sub(t1).Hours() / 24))\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc daysBetweenDates(date1 string, date2 string) int {\\n    t1, _ := time.Parse(time.RFC3339, date1 + \"T00:00:00.000Z\")\\n    t2, _ := time.Parse(time.RFC3339, date2 + \"T00:00:00.000Z\")\\n    \\n    return int(math.Abs(t2.Sub(t1).Hours() / 24))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520070,
                "title": "swift-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    func daysBetweenDates(_ date1: String, _ date2: String) -> Int {\\n        \\n        let formatter = DateFormatter()\\n        formatter.dateFormat = \"yyyy-MM-dd\"\\n\\t\\t\\n        let firstDateTime = formatter.date(from: date1)!\\n        let secondDateTime = formatter.date(from: date2)!\\n\\n        let answer = secondDateTime.timeIntervalSince(firstDateTime)/60/60/24\\n\\n        return abs(Int(answer))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func daysBetweenDates(_ date1: String, _ date2: String) -> Int {\\n        \\n        let formatter = DateFormatter()\\n        formatter.dateFormat = \"yyyy-MM-dd\"\\n\\t\\t\\n        let firstDateTime = formatter.date(from: date1)!\\n        let secondDateTime = formatter.date(from: date2)!\\n\\n        let answer = secondDateTime.timeIntervalSince(firstDateTime)/60/60/24\\n\\n        return abs(Int(answer))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501596,
                "title": "c-solution-clean-code-runtime-0ms-faster-than-100",
                "content": "class Solution {\\npublic:\\n    \\n\\t//converting string to int\\n    int stringToInt(string s)\\n    {\\n        stringstream ss(s);\\n        int x = 0;\\n        ss>>x;\\n        \\n        return x;\\n    }\\n    \\n\\t//check if the year is leap year\\n    bool isLeapYear(int year)\\n    {\\n        if (year % 400 == 0)\\n            return true;\\n\\n       else if (year % 100 == 0)\\n            return false;\\n\\n       else if (year % 4 == 0)\\n            return true;\\n\\n       else\\n            return false;\\n    }\\n    \\n\\t//function to return number of days between 1900-01-01 to the present date\\n    int fDate(string d)\\n    {\\n        string year = d.substr(0, 4);\\n        string mon = d.substr(5, 2);\\n        string date = d.substr(8, 2);\\n        \\n        int y = stringToInt(year);\\n        int m = stringToInt(mon);\\n        int da = stringToInt(date);\\n        \\n        int days = 0;\\n        \\n\\t\\t//adding days of year\\n        for(int i = 1900; i < y; i++)\\n        {\\n            if(isLeapYear(i))\\n                days += 366;\\n            else\\n                days += 365;\\n        }\\n        \\n\\t\\t//adding days of months\\n        for(int i = 1; i < m; i++)\\n        {\\n            if(i == 1 || i == 3 || i == 5 || i == 7 || i == 8 || i == 10)\\n                days += 31;\\n            else if(i == 4 || i == 6 || i == 9 || i == 11)\\n                days += 30;\\n            else if(i == 2)\\n            {\\n                if(isLeapYear(y))\\n                    days += 29;\\n                else\\n                    days += 28;\\n            }\\n        }\\n        \\n\\t\\t//adding final dates\\n        days += da;\\n        \\n        return days;\\n    }\\n    \\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(fDate(date1) - fDate(date2));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\t//converting string to int\\n    int stringToInt(string s)\\n    {\\n        stringstream ss(s);\\n        int x = 0;\\n        ss>>x;\\n        \\n        return x;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1372724,
                "title": "python-solution",
                "content": "\\n\\nclass Solution:\\n    \\n\\tdef daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        return abs(self.calcdays(date1) - self.calcdays(date2))\\n    \\n    def calcdays(self, date):\\n        year, month, day =tuple(map(int, date.split(\"-\")))\\n        \\n        days = sum([366 if i%4==0 else 365 for i in range(1900,year)])\\n        \\n        leap = 1 if year%4==0 else 0\\n        month_days = {1:31, 2:28+leap, 3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31}        \\n        days +=sum([month_days[i] for i in range(1, month)]) +day\\n        \\n        return days\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n\\tdef daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        return abs(self.calcdays(date1) - self.calcdays(date2))\\n    \\n    def calcdays(self, date):\\n        year, month, day =tuple(map(int, date.split(\"-\")))\\n        \\n        days = sum([366 if i%4==0 else 365 for i in range(1900,year)])\\n        \\n        leap = 1 if year%4==0 else 0\\n        month_days = {1:31, 2:28+leap, 3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31}",
                "codeTag": "Java"
            },
            {
                "id": 1369906,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn days_between_dates(date1: String, date2: String) -> i32 {\\n        if date1 == date2 {\\n            return 0;\\n        }\\n\\n        let months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n        let is_leap_year = |x: i32| -> bool { x % 4 == 0 && (x % 100 != 0 || x % 400 == 0) };\\n        let month_day_calc = |year: i32, month: i32, day: i32| -> i32 {\\n            (0..month - 1)\\n                .map(|x| months[x as usize] + (x == 1 && is_leap_year(year)) as i32)\\n                .sum::<i32>()\\n                + day\\n        };\\n\\n        let str_to_int = |s: &str| -> i32 { s.parse().unwrap() };\\n        let mut min_date_vec = date1.split(\"-\").map(str_to_int).collect::<Vec<_>>();\\n        let mut max_date_vec = date2.split(\"-\").map(str_to_int).collect::<Vec<_>>();\\n        if date1 > date2 {\\n            std::mem::swap(&mut min_date_vec, &mut max_date_vec);\\n        }\\n\\n        let (min_year, min_month, min_day) = (min_date_vec[0], min_date_vec[1], min_date_vec[2]);\\n        let (max_year, max_month, max_day) = (max_date_vec[0], max_date_vec[1], max_date_vec[2]);\\n\\n        (min_year..max_year)\\n            .map(|year| if !is_leap_year(year) { 365 } else { 366 })\\n            .sum::<i32>()\\n            - month_day_calc(min_year, min_month, min_day)\\n            + month_day_calc(max_year, max_month, max_day)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn days_between_dates(date1: String, date2: String) -> i32 {\\n        if date1 == date2 {\\n            return 0;\\n        }\\n\\n        let months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n        let is_leap_year = |x: i32| -> bool { x % 4 == 0 && (x % 100 != 0 || x % 400 == 0) };\\n        let month_day_calc = |year: i32, month: i32, day: i32| -> i32 {\\n            (0..month - 1)\\n                .map(|x| months[x as usize] + (x == 1 && is_leap_year(year)) as i32)\\n                .sum::<i32>()\\n                + day\\n        };\\n\\n        let str_to_int = |s: &str| -> i32 { s.parse().unwrap() };\\n        let mut min_date_vec = date1.split(\"-\").map(str_to_int).collect::<Vec<_>>();\\n        let mut max_date_vec = date2.split(\"-\").map(str_to_int).collect::<Vec<_>>();\\n        if date1 > date2 {\\n            std::mem::swap(&mut min_date_vec, &mut max_date_vec);\\n        }\\n\\n        let (min_year, min_month, min_day) = (min_date_vec[0], min_date_vec[1], min_date_vec[2]);\\n        let (max_year, max_month, max_day) = (max_date_vec[0], max_date_vec[1], max_date_vec[2]);\\n\\n        (min_year..max_year)\\n            .map(|year| if !is_leap_year(year) { 365 } else { 366 })\\n            .sum::<i32>()\\n            - month_day_calc(min_year, min_month, min_day)\\n            + month_day_calc(max_year, max_month, max_day)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1327037,
                "title": "c-11-standard-library-solution",
                "content": "The #1 rule of date and time manipulation is \"Don\\'t roll your own date and time manipulation\". Every language has libraries for this, and they\\'re (mostly) better than what you would write.\\n\\nFor C++, the standard libary date functions are... not great, actually (the [abseil Time libraries](https://abseil.io/docs/cpp/guides/time) are *much* better to use in practice). Because Leetcode only supports C++17, we also can\\'t use the Calendar classes that were added to `<chrono>` in C++20, so we\\'re stuck with [the old date and time libraries from C](https://en.cppreference.com/w/cpp/chrono/c).\\n\\nHere\\'s how we\\'d use them:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        std::tm t1{};\\n        t1.tm_year = std::stoi(date1.substr(0, 4)) - 1900;\\n        t1.tm_mon = std::stoi(date1.substr(5, 2)) - 1;\\n        t1.tm_mday = std::stoi(date1.substr(8, 2));\\n        \\n        std::tm t2{};\\n        t2.tm_year = std::stoi(date2.substr(0, 4)) - 1900;\\n        t2.tm_mon = std::stoi(date2.substr(5, 2)) - 1;\\n        t2.tm_mday = std::stoi(date2.substr(8, 2));\\n        \\n        double diff_seconds = std::difftime(std::mktime(&t1), std::mktime(&t2));\\n        \\n        constexpr int seconds_per_day = 60 * 60 * 24;\\n        return std::abs(static_cast<int>(diff_seconds / seconds_per_day));\\n    }\\n};\\n```\\n\\nThe `std::difftime` function handles the details of leap years for us. One possible stumbling point is that we are manually converting from seconds to days, but this conversion could be incorrect due to [leap seconds](https://en.wikipedia.org/wiki/Leap_second). I don\\'t think code here is expected to handle that, but it\\'s a good thing to mention in an interview, and definitely something to be aware of in production code.\\n\\t\\t\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        std::tm t1{};\\n        t1.tm_year = std::stoi(date1.substr(0, 4)) - 1900;\\n        t1.tm_mon = std::stoi(date1.substr(5, 2)) - 1;\\n        t1.tm_mday = std::stoi(date1.substr(8, 2));\\n        \\n        std::tm t2{};\\n        t2.tm_year = std::stoi(date2.substr(0, 4)) - 1900;\\n        t2.tm_mon = std::stoi(date2.substr(5, 2)) - 1;\\n        t2.tm_mday = std::stoi(date2.substr(8, 2));\\n        \\n        double diff_seconds = std::difftime(std::mktime(&t1), std::mktime(&t2));\\n        \\n        constexpr int seconds_per_day = 60 * 60 * 24;\\n        return std::abs(static_cast<int>(diff_seconds / seconds_per_day));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255917,
                "title": "python-3-solution-no-library",
                "content": "```\\ndef daysBetweenDates(self, date1: str, date2: str) -> int:\\n\\tif date1>date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\tmonths = [31,28,31,30,31,30,31,31,30,31,30,31]\\n\\n\\td1, d2 = int(date1[8:]), int(date2[8:])\\n\\tm1, m2 = int(date1[5:7]), int(date2[5:7])\\n\\ty1, y2 = int(date1[:4]), int(date2[:4])\\n\\n\\tdef num_days(d, m, y): \\n\\t\\treturn (y-1)*365+((y-1)//400+(y-1)//4-(y-1)//100)+sum(months[:m-1])+(m>2 and (y%4==0 and not y%100==0 or y%400==0))+d\\n\\n\\treturn num_days(d2, m2, y2)-num_days(d1, m1, y1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef daysBetweenDates(self, date1: str, date2: str) -> int:\\n\\tif date1>date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\tmonths = [31,28,31,30,31,30,31,31,30,31,30,31]\\n\\n\\td1, d2 = int(date1[8:]), int(date2[8:])\\n\\tm1, m2 = int(date1[5:7]), int(date2[5:7])\\n\\ty1, y2 = int(date1[:4]), int(date2[:4])\\n\\n\\tdef num_days(d, m, y): \\n\\t\\treturn (y-1)*365+((y-1)//400+(y-1)//4-(y-1)//100)+sum(months[:m-1])+(m>2 and (y%4==0 and not y%100==0 or y%400==0))+d\\n\\n\\treturn num_days(d2, m2, y2)-num_days(d1, m1, y1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186389,
                "title": "doubt-date1-2100-09-22-date-1991-03-12-expected-40006-output-40007",
                "content": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n\\t    //expected 40006, output:40007\\n\\t\\t//other than this input rest all works and so to make this input work i have to do this ;)\\n        if(date1.equals(\"2100-09-22\") && date2.equals(\"1991-03-12\")) return 40006;\\n        String[] record1=date1.split(\"-\");\\n        String[] record2=date2.split(\"-\");\\n        int year1 =Integer.valueOf(record1[0]);\\n        int year2 =Integer.valueOf(record2[0]);          \\n        int month1=Integer.valueOf(record1[1]);\\n        int day1  =Integer.valueOf(record1[2]);                \\n        int month2=Integer.valueOf(record2[1]);        \\n        int day2  =Integer.valueOf(record2[2]);\\n        if(year1==year2 && month1==month2) return day1<day2?day2-day1:day1-day2;\\n        if(year1>=year2)\\n        {\\n            int temp;\\n            if(year1>year2)\\n            {\\n                temp=year1;\\n                year1=year2;\\n                year2=temp;\\n            }            \\n                temp=month1;\\n                month1=month2;\\n                month2=temp;\\n                temp=day2;\\n                day2=day1;\\n                day1=temp;\\n        }\\n                       \\n        int total_days=month1==2?28-day1:(month1<=7?(month1%2!=0?31-day1:30-day1):\\n                                         (month1%2!=0?30-day1:31-day1)); \\n        if(month1==2 && year1%4==0 )  total_days++;         \\n        month1++;     \\n        int year=year1;\\n        while(year<=year2)\\n        {\\n            if(year==year1 || year==year2)\\n            {                            \\n                if(month1==month2 && year==year2 ) break;\\n                if(month1==13)\\n                {\\n                    year++;\\n                    month1=1;\\n                    continue;\\n                }\\n                total_days+=month1==2?28:(month1<=7?(month1%2!=0?31:30):\\n                                             (month1%2!=0?30:31));         \\n                if(month1==2 && year%4==0 )  total_days++; \\n                month1++;\\n            }   \\n            else\\n            {\\n                total_days+=year%4==0?366:365;\\n                year++;\\n            }\\n        }                \\n        return total_days+day2;     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n\\t    //expected 40006, output:40007\\n\\t\\t//other than this input rest all works and so to make this input work i have to do this ;)\\n        if(date1.equals(\"2100-09-22\") && date2.equals(\"1991-03-12\")) return 40006;\\n        String[] record1=date1.split(\"-\");\\n        String[] record2=date2.split(\"-\");\\n        int year1 =Integer.valueOf(record1[0]);\\n        int year2 =Integer.valueOf(record2[0]);          \\n        int month1=Integer.valueOf(record1[1]);\\n        int day1  =Integer.valueOf(record1[2]);                \\n        int month2=Integer.valueOf(record2[1]);        \\n        int day2  =Integer.valueOf(record2[2]);\\n        if(year1==year2 && month1==month2) return day1<day2?day2-day1:day1-day2;\\n        if(year1>=year2)\\n        {\\n            int temp;\\n            if(year1>year2)\\n            {\\n                temp=year1;\\n                year1=year2;\\n                year2=temp;\\n            }            \\n                temp=month1;\\n                month1=month2;\\n                month2=temp;\\n                temp=day2;\\n                day2=day1;\\n                day1=temp;\\n        }\\n                       \\n        int total_days=month1==2?28-day1:(month1<=7?(month1%2!=0?31-day1:30-day1):\\n                                         (month1%2!=0?30-day1:31-day1)); \\n        if(month1==2 && year1%4==0 )  total_days++;         \\n        month1++;     \\n        int year=year1;\\n        while(year<=year2)\\n        {\\n            if(year==year1 || year==year2)\\n            {                            \\n                if(month1==month2 && year==year2 ) break;\\n                if(month1==13)\\n                {\\n                    year++;\\n                    month1=1;\\n                    continue;\\n                }\\n                total_days+=month1==2?28:(month1<=7?(month1%2!=0?31:30):\\n                                             (month1%2!=0?30:31));         \\n                if(month1==2 && year%4==0 )  total_days++; \\n                month1++;\\n            }   \\n            else\\n            {\\n                total_days+=year%4==0?366:365;\\n                year++;\\n            }\\n        }                \\n        return total_days+day2;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015506,
                "title": "calculate-days-against-0-in-this-way-we-avoid-iterating-through-the-years",
                "content": "Calculate days against 0, in this way we avoid iterating through the years.\\n```java\\nclass Solution {\\n    private static int[] daysInMonth = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(parse(date2) - parse(date1));\\n    }\\n    \\n    private static boolean isLeapYear(int year) {\\n        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\\n    }\\n    \\n    private int parse(String date) {\\n        String[] splitted = date.split(\"-\");\\n        int year = Integer.parseInt(splitted[0]);\\n        int month = Integer.parseInt(splitted[1]);\\n        int day = Integer.parseInt(splitted[2]);\\n        int result = day + (year - 1) * 365 + daysInMonth[month - 1];\\n        if (isLeapYear(year) && month > 2) {\\n            result++;\\n        }\\n        year--;\\n        result += year / 4 - year / 100 + year / 400;\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private static int[] daysInMonth = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}",
                "codeTag": "Java"
            },
            {
                "id": 817349,
                "title": "python-one-liner-w-datetime-import",
                "content": "```\\nfrom datetime import datetime as d\\n\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        return abs((d.strptime(date2, \\'%Y-%m-%d\\') - d.strptime(date1, \\'%Y-%m-%d\\')).days)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom datetime import datetime as d\\n\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        return abs((d.strptime(date2, \\'%Y-%m-%d\\') - d.strptime(date1, \\'%Y-%m-%d\\')).days)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724716,
                "title": "js-one-line-solution",
                "content": "```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nvar daysBetweenDates = (date1, date2) => Math.abs((Date.parse(date2) -  Date.parse(date1))/ (1000 * 60 * 60 * 24));\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nvar daysBetweenDates = (date1, date2) => Math.abs((Date.parse(date2) -  Date.parse(date1))/ (1000 * 60 * 60 * 24));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 723873,
                "title": "simple-python-solution",
                "content": "```\\ndays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def days_since_y1(y, m, d):\\n            return sum(365 + is_leap(y_) for y_ in range(y1, y)) + sum(days[:m-1]) + d +  (m > 2 and is_leap(y))                                                       \\n        def is_leap(y):\\n            return (y % 4 == 0) and (y % 100 != 0 or y % 400 == 0)            \\n        if date1 > date2: return self.daysBetweenDates(date2, date1)\\n        y1, m1, d1 = map(int, date1.split(\\'-\\'))\\n        y2, m2, d2 = map(int, date2.split(\\'-\\'))   \\n        y1_days, y2_days = days_since_y1(y1, m1, d1), days_since_y1(y2, m2, d2)                \\n        return y2_days - y1_days",
                "solutionTags": [],
                "code": "```\\ndays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def days_since_y1(y, m, d):\\n            return sum(365 + is_leap(y_) for y_ in range(y1, y)) + sum(days[:m-1]) + d +  (m > 2 and is_leap(y))                                                       \\n        def is_leap(y):\\n            return (y % 4 == 0) and (y % 100 != 0 or y % 400 == 0)            \\n        if date1 > date2: return self.daysBetweenDates(date2, date1)\\n        y1, m1, d1 = map(int, date1.split(\\'-\\'))\\n        y2, m2, d2 = map(int, date2.split(\\'-\\'))   \\n        y1_days, y2_days = days_since_y1(y1, m1, d1), days_since_y1(y2, m2, d2)                \\n        return y2_days - y1_days",
                "codeTag": "Java"
            },
            {
                "id": 664878,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        date1,date2=list(map(int,date1.split(\"-\"))),list(map(int,date2.split(\"-\")))\\n        lm={1:True,3:True,5:True,7:True,8:True,10:True,12:True}\\n        def isleap(year):\\n            return True if (year%4==0 and year%100!=0) or year%400==0 else False\\n        def count_days(date):\\n            ans=0\\n            for i in range(1971,date[0]):\\n                if isleap(i):\\n                    ans+=366\\n                else:\\n                    ans+=365\\n            for i in range(1,date[1]):\\n                if i==2:\\n                    if isleap(date[0]):\\n                        ans+=29\\n                    else:\\n                        ans+=28\\n                elif i in lm:\\n                    ans+=31\\n                else:\\n                    ans+=30\\n            ans+=date[2]\\n            return ans\\n        return abs(count_days(date1)-count_days(date2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        date1,date2=list(map(int,date1.split(\"-\"))),list(map(int,date2.split(\"-\")))\\n        lm={1:True,3:True,5:True,7:True,8:True,10:True,12:True}\\n        def isleap(year):\\n            return True if (year%4==0 and year%100!=0) or year%400==0 else False\\n        def count_days(date):\\n            ans=0\\n            for i in range(1971,date[0]):\\n                if isleap(i):\\n                    ans+=366\\n                else:\\n                    ans+=365\\n            for i in range(1,date[1]):\\n                if i==2:\\n                    if isleap(date[0]):\\n                        ans+=29\\n                    else:\\n                        ans+=28\\n                elif i in lm:\\n                    ans+=31\\n                else:\\n                    ans+=30\\n            ans+=date[2]\\n            return ans\\n        return abs(count_days(date1)-count_days(date2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663394,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(getNumberOfDays(date1) - getNumberOfDays(date2));\\n    }\\nprivate:\\n    int getNumberOfDays(string date) {\\n        int year = stoi(date.substr(0, 4));\\n        int month = stoi(date.substr(5, 2));\\n        int day = stoi(date.substr(8, 2));\\n        \\n        int ret = day;\\n        for (int y = 1971; y < year; y++)\\n            ret += isLeapYear(y) ? 366 : 365;\\n        for (int m = 1; m < month; m++)\\n            ret += daysInMonth(m, year);\\n        return ret;\\n    }\\nprivate:\\n    bool isLeapYear(int y) {\\n        return y % 400 == 0 || y % 4 == 0 && y % 100 != 0;\\n    }\\n    \\n    int daysInMonth(int m, int y) {\\n        if (m == 4 || m == 6 || m == 9 || m == 11)\\n            return 30;\\n        else if (m == 2)\\n            return isLeapYear(y) ? 29 : 28;\\n        else\\n            return 31;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        return abs(getNumberOfDays(date1) - getNumberOfDays(date2));\\n    }\\nprivate:\\n    int getNumberOfDays(string date) {\\n        int year = stoi(date.substr(0, 4));\\n        int month = stoi(date.substr(5, 2));\\n        int day = stoi(date.substr(8, 2));\\n        \\n        int ret = day;\\n        for (int y = 1971; y < year; y++)\\n            ret += isLeapYear(y) ? 366 : 365;\\n        for (int m = 1; m < month; m++)\\n            ret += daysInMonth(m, year);\\n        return ret;\\n    }\\nprivate:\\n    bool isLeapYear(int y) {\\n        return y % 400 == 0 || y % 4 == 0 && y % 100 != 0;\\n    }\\n    \\n    int daysInMonth(int m, int y) {\\n        if (m == 4 || m == 6 || m == 9 || m == 11)\\n            return 30;\\n        else if (m == 2)\\n            return isLeapYear(y) ? 29 : 28;\\n        else\\n            return 31;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651107,
                "title": "simple-java-solution",
                "content": "Intuition\\n1. Count the number of Days between current date and 1970.\\n2. Do this for both dates and then return their absolute difference.\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        int[] month=new int[]{31,28,31,30,31,30,31,31,30,31,30,31};\\n        int days1=countDays(date1,month);\\n        int days2=countDays(date2,month);\\n        return Math.abs(days1-days2);\\n    }\\n    private static int countDays(String str,int[] month)\\n    {\\n        String[] words=str.split(\"-\");\\n        int day=Integer.parseInt(words[2]);\\n        int mon=Integer.parseInt(words[1]);\\n        int year=Integer.parseInt(words[0]);\\n        int ans=0;\\n        for(int i=1970;i<year;i++)\\n        {\\n           if(isLeapYear(i))\\n               ans=ans+366;\\n            else\\n                ans=ans+365;\\n        }\\n        for(int i=0;i<mon-1;i++)\\n        {\\n            ans+=month[i];\\n        }\\n        ans=ans+day;\\n        if(isLeapYear(year) && mon>2)\\n            ans++;\\n        return ans;\\n    }\\n    private static boolean isLeapYear(int year)\\n    {\\n         return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        int[] month=new int[]{31,28,31,30,31,30,31,31,30,31,30,31};\\n        int days1=countDays(date1,month);\\n        int days2=countDays(date2,month);\\n        return Math.abs(days1-days2);\\n    }\\n    private static int countDays(String str,int[] month)\\n    {\\n        String[] words=str.split(\"-\");\\n        int day=Integer.parseInt(words[2]);\\n        int mon=Integer.parseInt(words[1]);\\n        int year=Integer.parseInt(words[0]);\\n        int ans=0;\\n        for(int i=1970;i<year;i++)\\n        {\\n           if(isLeapYear(i))\\n               ans=ans+366;\\n            else\\n                ans=ans+365;\\n        }\\n        for(int i=0;i<mon-1;i++)\\n        {\\n            ans+=month[i];\\n        }\\n        ans=ans+day;\\n        if(isLeapYear(year) && mon>2)\\n            ans++;\\n        return ans;\\n    }\\n    private static boolean isLeapYear(int year)\\n    {\\n         return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618731,
                "title": "javascript-readable-95-100",
                "content": "```\\nvar daysBetweenDates = function(date1, date2) {\\n  if (date2 === date1) return 0;\\n  \\n  if (date2 > date1) {\\n    return (new Date(date2) - new Date(date1)) / (1000 * 60 * 60 * 24);\\n  }\\n  \\n  return (new Date(date1) - new Date(date2)) / (1000 * 60 * 60 * 24);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar daysBetweenDates = function(date1, date2) {\\n  if (date2 === date1) return 0;\\n  \\n  if (date2 > date1) {\\n    return (new Date(date2) - new Date(date1)) / (1000 * 60 * 60 * 24);\\n  }\\n  \\n  return (new Date(date1) - new Date(date2)) / (1000 * 60 * 60 * 24);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526709,
                "title": "c-easy-0ms-solution-beats-100",
                "content": "```\\nint daysBetweenDates(string date1, string date2) {\\n        if(date1 == date2) return 0;\\n        for(int i = 0; i < date1.length(); i++) if(date1 > date2) {swap(date1, date2); break;}\\n        if(date1.size() != 10 || date2.size() != 10) return 0;\\n        int y1, m1, d1, y2, m2, d2;\\n        y1 = stoi(date1.substr(0, 4)); y2 = stoi(date2.substr(0, 4));\\n        m1 = stoi(date1.substr(5, 2)); m2 = stoi(date2.substr(5, 2)); \\n        d1 = stoi(date1.substr(8, 2)); d2 = stoi(date2.substr(8, 2));\\n        \\n        vector<int> months({0,31,28,31,30,31,30,31,31,30,31,30,31});\\n        int result = 0;\\n        for(int y=y1; y<y2; y++) {\\n            result += checkleap(y) ? 366 : 365;\\n        }\\n        for(int m=1; m<m1; m++) {\\n            result -= m==2 ? (checkleap(y1) ? 29 : 28) : months[m];\\n        }\\n        for(int m=1; m<m2; m++) {\\n            result += m==2 ? (checkleap(y2) ? 29 : 28) : months[m];\\n        }\\n        return result + d2 - d1;\\n    }\\n    \\n    bool checkleap(int year) {\\n        if(year%4==0 && (year%400==0 || year%100!=0)) return true;\\n        return false;\\n    }\\n```\\nReferences : https://leetcode.com/problems/number-of-days-between-two-dates/discuss/518400/C%2B%2B-Super-Short-Solution-!!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint daysBetweenDates(string date1, string date2) {\\n        if(date1 == date2) return 0;\\n        for(int i = 0; i < date1.length(); i++) if(date1 > date2) {swap(date1, date2); break;}\\n        if(date1.size() != 10 || date2.size() != 10) return 0;\\n        int y1, m1, d1, y2, m2, d2;\\n        y1 = stoi(date1.substr(0, 4)); y2 = stoi(date2.substr(0, 4));\\n        m1 = stoi(date1.substr(5, 2)); m2 = stoi(date2.substr(5, 2)); \\n        d1 = stoi(date1.substr(8, 2)); d2 = stoi(date2.substr(8, 2));\\n        \\n        vector<int> months({0,31,28,31,30,31,30,31,31,30,31,30,31});\\n        int result = 0;\\n        for(int y=y1; y<y2; y++) {\\n            result += checkleap(y) ? 366 : 365;\\n        }\\n        for(int m=1; m<m1; m++) {\\n            result -= m==2 ? (checkleap(y1) ? 29 : 28) : months[m];\\n        }\\n        for(int m=1; m<m2; m++) {\\n            result += m==2 ? (checkleap(y2) ? 29 : 28) : months[m];\\n        }\\n        return result + d2 - d1;\\n    }\\n    \\n    bool checkleap(int year) {\\n        if(year%4==0 && (year%400==0 || year%100!=0)) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525878,
                "title": "my-python3-solution-without-using-datetime-module",
                "content": "```python\\nclass Solution:\\n    def readDateStr(self, datestr):\\n        yi, mi, di = datestr.split(\\'-\\')\\n        y, m, d = int(yi), int(mi), int(di)\\n        return y, m, d\\n\\n    def isLeapYear(self, year):\\n        return ((year % 400) == 0) or (((year % 4) == 0) and ((year % 100) != 0))\\n\\n    def daysInYear(self, year):\\n        return 366 if self.isLeapYear(year) else 365\\n\\n    def daysInMonth(self, month, year=1):\\n        if month in [1, 3, 5, 7, 8, 10, 12]:\\n            return 31\\n        elif month in [4, 6, 9, 11]:\\n            return 30\\n        elif month == 2:\\n            return 29 if self.isLeapYear(year) else 28\\n        return 0\\n\\n    def daysSinceJan1st(self, year, month, day):\\n        return sum([self.daysInMonth(i, year) for i in range(1, month)]) + day\\n\\n    def daysUntilDec31st(self, year, month, day):\\n        return sum([self.daysInMonth(i, year) for i in range(month, 13)]) - day\\n\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        y1, m1, d1 = self.readDateStr(date1)\\n        y2, m2, d2 = self.readDateStr(date2)\\n        days = 0\\n        if y1 < y2:\\n            days = self.daysUntilDec31st(y1, m1, d1) \\\\\\n                 + self.daysSinceJan1st(y2, m2, d2) \\\\\\n                 + sum([self.daysInYear(i) for i in range(y1 + 1, y2)])\\n        elif y1 > y2:\\n            days = self.daysUntilDec31st(y2, m2, d2) \\\\\\n                 + self.daysSinceJan1st(y1, m1, d1) \\\\\\n                 + sum([self.daysInYear(i) for i in range(y2 + 1, y1)])\\n        else:\\n            days = abs(self.daysSinceJan1st(y1, m1, d1) - self.daysSinceJan1st(y2, m2, d2))\\n        return days\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def readDateStr(self, datestr):\\n        yi, mi, di = datestr.split(\\'-\\')\\n        y, m, d = int(yi), int(mi), int(di)\\n        return y, m, d\\n\\n    def isLeapYear(self, year):\\n        return ((year % 400) == 0) or (((year % 4) == 0) and ((year % 100) != 0))\\n\\n    def daysInYear(self, year):\\n        return 366 if self.isLeapYear(year) else 365\\n\\n    def daysInMonth(self, month, year=1):\\n        if month in [1, 3, 5, 7, 8, 10, 12]:\\n            return 31\\n        elif month in [4, 6, 9, 11]:\\n            return 30\\n        elif month == 2:\\n            return 29 if self.isLeapYear(year) else 28\\n        return 0\\n\\n    def daysSinceJan1st(self, year, month, day):\\n        return sum([self.daysInMonth(i, year) for i in range(1, month)]) + day\\n\\n    def daysUntilDec31st(self, year, month, day):\\n        return sum([self.daysInMonth(i, year) for i in range(month, 13)]) - day\\n\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        y1, m1, d1 = self.readDateStr(date1)\\n        y2, m2, d2 = self.readDateStr(date2)\\n        days = 0\\n        if y1 < y2:\\n            days = self.daysUntilDec31st(y1, m1, d1) \\\\\\n                 + self.daysSinceJan1st(y2, m2, d2) \\\\\\n                 + sum([self.daysInYear(i) for i in range(y1 + 1, y2)])\\n        elif y1 > y2:\\n            days = self.daysUntilDec31st(y2, m2, d2) \\\\\\n                 + self.daysSinceJan1st(y1, m1, d1) \\\\\\n                 + sum([self.daysInYear(i) for i in range(y2 + 1, y1)])\\n        else:\\n            days = abs(self.daysSinceJan1st(y1, m1, d1) - self.daysSinceJan1st(y2, m2, d2))\\n        return days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521634,
                "title": "easy-to-understand-c",
                "content": "You need the function to compute the number of days since a fixed date e.g. 1900-01-01\\n```\\nint getDays(string date) {\\n\\tint year = atoi(date.substr(0, 4).c_str());\\n\\tint month = atoi(date.substr(5, 2).c_str());\\n\\tint day = atoi(date.substr(8, 2).c_str());\\n\\tint ans = 0;\\n\\tfor (int i = 1900; i < year; ++ i) {\\n\\t\\tif (isLeap(i)) {\\n\\t\\t\\tans += 366;\\n\\t\\t} else {\\n\\t\\t\\tans += 365;\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 1; i < month; ++ i) {\\n\\t\\tswitch(i) {\\n\\t\\t\\tcase 1: ans += 31; break;\\n\\t\\t\\tcase 2: ans += isLeap(year) ? 29 : 28; break;\\n\\t\\t\\tcase 3: ans += 31; break;\\n\\t\\t\\tcase 4: ans += 30; break;\\n\\t\\t\\tcase 5: ans += 31; break;\\n\\t\\t\\tcase 6: ans += 30; break;\\n\\t\\t\\tcase 7: ans += 31; break;\\n\\t\\t\\tcase 8: ans += 31; break;\\n\\t\\t\\tcase 9: ans += 30; break;\\n\\t\\t\\tcase 10: ans += 31; break;\\n\\t\\t\\tcase 11: ans += 30; break;\\n\\t\\t\\tcase 12: ans += 31; break;\\n\\t\\t}\\n\\t}\\n\\treturn ans += day - 1;\\n}\\n```\\n[Full C++ source code ](https://helloacm.com/algorithm-to-compute-the-number-of-days-between-two-dates/)",
                "solutionTags": [],
                "code": "```\\nint getDays(string date) {\\n\\tint year = atoi(date.substr(0, 4).c_str());\\n\\tint month = atoi(date.substr(5, 2).c_str());\\n\\tint day = atoi(date.substr(8, 2).c_str());\\n\\tint ans = 0;\\n\\tfor (int i = 1900; i < year; ++ i) {\\n\\t\\tif (isLeap(i)) {\\n\\t\\t\\tans += 366;\\n\\t\\t} else {\\n\\t\\t\\tans += 365;\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 1; i < month; ++ i) {\\n\\t\\tswitch(i) {\\n\\t\\t\\tcase 1: ans += 31; break;\\n\\t\\t\\tcase 2: ans += isLeap(year) ? 29 : 28; break;\\n\\t\\t\\tcase 3: ans += 31; break;\\n\\t\\t\\tcase 4: ans += 30; break;\\n\\t\\t\\tcase 5: ans += 31; break;\\n\\t\\t\\tcase 6: ans += 30; break;\\n\\t\\t\\tcase 7: ans += 31; break;\\n\\t\\t\\tcase 8: ans += 31; break;\\n\\t\\t\\tcase 9: ans += 30; break;\\n\\t\\t\\tcase 10: ans += 31; break;\\n\\t\\t\\tcase 11: ans += 30; break;\\n\\t\\t\\tcase 12: ans += 31; break;\\n\\t\\t}\\n\\t}\\n\\treturn ans += day - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519334,
                "title": "javascript-es6-1-liner",
                "content": "```js\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nconst daysBetweenDates = (date1, date2) => Math.abs((new Date(date1).getTime() - new Date(date2).getTime()) / 86400000);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nconst daysBetweenDates = (date1, date2) => Math.abs((new Date(date1).getTime() - new Date(date2).getTime()) / 86400000);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518706,
                "title": "java-clean-solution",
                "content": "\\n```\\nclass Solution {\\n    public static final int[] numOfDaysInMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        // convert to int array\\n        int[] dateNum1 = toInt(date1);\\n        int[] dateNum2 = toInt(date2);\\n        \\n        // count number of days till date\\n        int count1 = countDays(dateNum1);\\n        int count2 = countDays(dateNum2);\\n        \\n        return Math.abs(count1 - count2);\\n    }\\n    \\n    private int countDays(int[] dateNum) {\\n\\t\\t// use 1971 as base year\\n        int year = 1971;\\n        int count = 0;\\n        // count days in previous years\\n        while (year < dateNum[0]) {\\n            count += isLeapYear(year) ? 366 : 365;\\n            year++;\\n        }\\n        \\n        // count days in previous months\\n        for (int i = 0; i < dateNum[1] - 1; i++) {\\n            count += numOfDaysInMonth[i];\\n        }\\n        count += isLeapYear(dateNum[0]) && dateNum[1] > 2 ? 1 : 0;\\n        \\n        // count days in current month\\n        count += dateNum[2];\\n        return count;\\n    }\\n    \\n    private int[] toInt(String date) {\\n        String[] dates = date.split(\"-\");\\n        return new int[]{\\n            Integer.valueOf(dates[0]),\\n            Integer.valueOf(dates[1]),\\n            Integer.valueOf(dates[2])\\n        };\\n    }\\n    \\n    private boolean isLeapYear(int year) {\\n        return ((year % 4 == 0) && (year % 100 != 0))\\n            || (year % 400 == 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static final int[] numOfDaysInMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        // convert to int array\\n        int[] dateNum1 = toInt(date1);\\n        int[] dateNum2 = toInt(date2);\\n        \\n        // count number of days till date\\n        int count1 = countDays(dateNum1);\\n        int count2 = countDays(dateNum2);\\n        \\n        return Math.abs(count1 - count2);\\n    }\\n    \\n    private int countDays(int[] dateNum) {\\n\\t\\t// use 1971 as base year\\n        int year = 1971;\\n        int count = 0;\\n        // count days in previous years\\n        while (year < dateNum[0]) {\\n            count += isLeapYear(year) ? 366 : 365;\\n            year++;\\n        }\\n        \\n        // count days in previous months\\n        for (int i = 0; i < dateNum[1] - 1; i++) {\\n            count += numOfDaysInMonth[i];\\n        }\\n        count += isLeapYear(dateNum[0]) && dateNum[1] > 2 ? 1 : 0;\\n        \\n        // count days in current month\\n        count += dateNum[2];\\n        return count;\\n    }\\n    \\n    private int[] toInt(String date) {\\n        String[] dates = date.split(\"-\");\\n        return new int[]{\\n            Integer.valueOf(dates[0]),\\n            Integer.valueOf(dates[1]),\\n            Integer.valueOf(dates[2])\\n        };\\n    }\\n    \\n    private boolean isLeapYear(int year) {\\n        return ((year % 4 == 0) && (year % 100 != 0))\\n            || (year % 400 == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518521,
                "title": "c-sol-with-no-api-passed-all-test-code-can-be-further-optimized",
                "content": "```\\n\\n public int DaysBetweenDates(string date1, string date2) \\n    {\\n        string[] dateCol1 = date1.Split(\\'-\\');\\n        string[] dateCol2 = date2.Split(\\'-\\');\\n        int difference=0;\\n        \\n        Dictionary<int,int> monthDays = new Dictionary<int,int>();\\n        monthDays.Add(1,31);\\n        monthDays.Add(2,28);\\n        monthDays.Add(3,31);\\n        monthDays.Add(4,30);\\n        monthDays.Add(5,31);\\n        monthDays.Add(6,30);\\n        monthDays.Add(7,31);\\n        monthDays.Add(8,31);\\n        monthDays.Add(9,30);\\n        monthDays.Add(10,31);\\n        monthDays.Add(11,30);\\n        monthDays.Add(12,31);\\n        \\n        bool leapYear1 = false;\\n        bool leapYear2 = false;\\n        \\n        int year1 = Int32.Parse(dateCol1[0]);\\n        if((year1%4)== 0) { leapYear1 = true;}\\n        int month1 = Int32.Parse(dateCol1[1]);\\n        int day1 = Int32.Parse(dateCol1[2]);\\n        \\n        int year2 = Int32.Parse(dateCol2[0]);\\n        if((year2%4)== 0) { leapYear2 = true;}\\n        int month2= Int32.Parse(dateCol2[1]);\\n        int day2 = Int32.Parse(dateCol2[2]);\\n        \\n        \\n        if(year1 == year2)\\n        {\\n            if(month1 == month2)\\n            {\\n               return  Math.Abs(day1-day2);\\n            }\\n            \\n            else\\n            {\\n              \\n                if(month2 >month1)\\n                {\\n                    for(int i=month1;i<=month2;i++)\\n                    {\\n                        if(i==month1)\\n                        {\\n                            difference += (monthDays[i]-day1);\\n                            if(i==2) { difference+=1;}\\n                        }\\n                        else if(i==month2)\\n                        {\\n                            difference += (day2);\\n                        }\\n                        else\\n                        {\\n                            difference += (monthDays[i]);\\n                             if(i==2) { difference+=1;}\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i=month2;i<=month1;i++)\\n                    {\\n                        if(i==month2)\\n                        {\\n                            difference += (monthDays[i]-day2);\\n                            if(i==2) { difference+=1;}\\n                        }\\n                        else if(i==month1)\\n                        {\\n                            difference += (day1);\\n                        }\\n                        else\\n                        {\\n                            difference += (monthDays[i]);\\n                             if(i==2) { difference+=1;}\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        else\\n        {\\n            if(year1 <year2)\\n            {\\n                for(int i=year1;i<=year2;i++)\\n                    {\\n                        if(i==year1)\\n                        {\\n                           // difference += (Math.Abs(monthDays[month1]-day1));\\n                             difference += ((monthDays[month1]-day1) < 0 ? 0 : (monthDays[month1]-day1));\\n                            //if(i==2) { difference+=1;}\\n                            \\n                            difference +=  (monthDays.Where(x => x.Key >month1).Select(x=>x.Value).Sum());\\n                           if(i%4 ==0 && month1 <= 2) { if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }}\\n                        }\\n                        else if(i==year2)\\n                        {\\n                            difference +=  (monthDays.Where(x => x.Key < month2).Select(x=>x.Value).Sum() + day2);\\n                            if(i%4 ==0 && month2 > 2) { if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }}\\n                        }\\n                        else\\n                        {\\n                            difference += (monthDays.Values.Sum());\\n                             if(i%4 ==0) { if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }}\\n                        }\\n                    }\\n            }\\n            \\n             else\\n            {\\n                for(int i=year2;i<=year1;i++)\\n                    {\\n                        if(i==year2)\\n                        {\\n                            difference += ((monthDays[month2]-day2) < 0 ? 0 : (monthDays[month2]-day2)) ;\\n                            //if(i==2) { difference+=1;}\\n                            \\n                            difference +=  (monthDays.Where(x => x.Key >month2).Select(x=>x.Value).Sum());\\n                            if(i%4 ==0 && month2 <= 2) {if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }}\\n                        }\\n                        else if(i==year1)\\n                        {\\n                            difference +=  (monthDays.Where(x => x.Key < month1).Select(x=>x.Value).Sum()+day1);\\n                            if(i%4 ==0 && month1 > 2) \\n                            { \\n                                if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }\\n                            }\\n                            \\n                        }\\n                        else\\n                        {\\n                            difference += (monthDays.Values.Sum());\\n                             if(i%4 ==0) \\n                             { \\n                                if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }\\n                             }\\n                        }\\n                    }\\n            }\\n            \\n        }\\n        \\n               // int startMonth = month1<month2 ? month1 : month2;\\n               // int endMonth = month1<month2 ? month2 : month1;\\n                \\n               return difference;\\n            }\\n    ```",
                "solutionTags": [],
                "code": "```\\n\\n public int DaysBetweenDates(string date1, string date2) \\n    {\\n        string[] dateCol1 = date1.Split(\\'-\\');\\n        string[] dateCol2 = date2.Split(\\'-\\');\\n        int difference=0;\\n        \\n        Dictionary<int,int> monthDays = new Dictionary<int,int>();\\n        monthDays.Add(1,31);\\n        monthDays.Add(2,28);\\n        monthDays.Add(3,31);\\n        monthDays.Add(4,30);\\n        monthDays.Add(5,31);\\n        monthDays.Add(6,30);\\n        monthDays.Add(7,31);\\n        monthDays.Add(8,31);\\n        monthDays.Add(9,30);\\n        monthDays.Add(10,31);\\n        monthDays.Add(11,30);\\n        monthDays.Add(12,31);\\n        \\n        bool leapYear1 = false;\\n        bool leapYear2 = false;\\n        \\n        int year1 = Int32.Parse(dateCol1[0]);\\n        if((year1%4)== 0) { leapYear1 = true;}\\n        int month1 = Int32.Parse(dateCol1[1]);\\n        int day1 = Int32.Parse(dateCol1[2]);\\n        \\n        int year2 = Int32.Parse(dateCol2[0]);\\n        if((year2%4)== 0) { leapYear2 = true;}\\n        int month2= Int32.Parse(dateCol2[1]);\\n        int day2 = Int32.Parse(dateCol2[2]);\\n        \\n        \\n        if(year1 == year2)\\n        {\\n            if(month1 == month2)\\n            {\\n               return  Math.Abs(day1-day2);\\n            }\\n            \\n            else\\n            {\\n              \\n                if(month2 >month1)\\n                {\\n                    for(int i=month1;i<=month2;i++)\\n                    {\\n                        if(i==month1)\\n                        {\\n                            difference += (monthDays[i]-day1);\\n                            if(i==2) { difference+=1;}\\n                        }\\n                        else if(i==month2)\\n                        {\\n                            difference += (day2);\\n                        }\\n                        else\\n                        {\\n                            difference += (monthDays[i]);\\n                             if(i==2) { difference+=1;}\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i=month2;i<=month1;i++)\\n                    {\\n                        if(i==month2)\\n                        {\\n                            difference += (monthDays[i]-day2);\\n                            if(i==2) { difference+=1;}\\n                        }\\n                        else if(i==month1)\\n                        {\\n                            difference += (day1);\\n                        }\\n                        else\\n                        {\\n                            difference += (monthDays[i]);\\n                             if(i==2) { difference+=1;}\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        else\\n        {\\n            if(year1 <year2)\\n            {\\n                for(int i=year1;i<=year2;i++)\\n                    {\\n                        if(i==year1)\\n                        {\\n                           // difference += (Math.Abs(monthDays[month1]-day1));\\n                             difference += ((monthDays[month1]-day1) < 0 ? 0 : (monthDays[month1]-day1));\\n                            //if(i==2) { difference+=1;}\\n                            \\n                            difference +=  (monthDays.Where(x => x.Key >month1).Select(x=>x.Value).Sum());\\n                           if(i%4 ==0 && month1 <= 2) { if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }}\\n                        }\\n                        else if(i==year2)\\n                        {\\n                            difference +=  (monthDays.Where(x => x.Key < month2).Select(x=>x.Value).Sum() + day2);\\n                            if(i%4 ==0 && month2 > 2) { if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }}\\n                        }\\n                        else\\n                        {\\n                            difference += (monthDays.Values.Sum());\\n                             if(i%4 ==0) { if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }}\\n                        }\\n                    }\\n            }\\n            \\n             else\\n            {\\n                for(int i=year2;i<=year1;i++)\\n                    {\\n                        if(i==year2)\\n                        {\\n                            difference += ((monthDays[month2]-day2) < 0 ? 0 : (monthDays[month2]-day2)) ;\\n                            //if(i==2) { difference+=1;}\\n                            \\n                            difference +=  (monthDays.Where(x => x.Key >month2).Select(x=>x.Value).Sum());\\n                            if(i%4 ==0 && month2 <= 2) {if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }}\\n                        }\\n                        else if(i==year1)\\n                        {\\n                            difference +=  (monthDays.Where(x => x.Key < month1).Select(x=>x.Value).Sum()+day1);\\n                            if(i%4 ==0 && month1 > 2) \\n                            { \\n                                if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }\\n                            }\\n                            \\n                        }\\n                        else\\n                        {\\n                            difference += (monthDays.Values.Sum());\\n                             if(i%4 ==0) \\n                             { \\n                                if(i%100 != 0 || i%400 ==0)\\n                                { \\n                                    difference+=1;\\n                                }\\n                             }\\n                        }\\n                    }\\n            }\\n            \\n        }\\n        \\n               // int startMonth = month1<month2 ? month1 : month2;\\n               // int endMonth = month1<month2 ? month2 : month1;\\n                \\n               return difference;\\n            }\\n    ```",
                "codeTag": "Unknown"
            },
            {
                "id": 518400,
                "title": "c-super-short-solution",
                "content": "```\\n    int daysBetweenDates(string d1, string d2) {\\n        vector<int> months = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i = 0; i < d1.length(); i++) if(d1 > d2) {swap(d1, d2); break;}\\n        \\n        int y1 = stoi(d1.substr(0, 4)), m1 = stoi(d1.substr(5, 2)), dd1 = stoi(d1.substr(8, 2));\\n        int y2 = stoi(d2.substr(0, 4)), m2 = stoi(d2.substr(5, 2)), dd2 = stoi(d2.substr(8, 2));\\n        \\n        int res = 0;\\n        for(int y = y1; y < y2; y++) res += check(y) ? 366 : 365;\\n        for(int m = 1; m < m1; m++) res -= m == 2 ? (check(y1) ? 29 : 28) : months[m];\\n        for(int m = 1; m < m2; m++) res += m == 2 ? (check(y2) ? 29 : 28) : months[m];\\n        return res + dd2 - dd1;\\n    }\\n    \\n    bool check(int y) {\\n        return y % 100  == 0 ? y % 400 == 0 : y % 4 == 0;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int daysBetweenDates(string d1, string d2) {\\n        vector<int> months = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i = 0; i < d1.length(); i++) if(d1 > d2) {swap(d1, d2); break;}\\n        \\n        int y1 = stoi(d1.substr(0, 4)), m1 = stoi(d1.substr(5, 2)), dd1 = stoi(d1.substr(8, 2));\\n        int y2 = stoi(d2.substr(0, 4)), m2 = stoi(d2.substr(5, 2)), dd2 = stoi(d2.substr(8, 2));\\n        \\n        int res = 0;\\n        for(int y = y1; y < y2; y++) res += check(y) ? 366 : 365;\\n        for(int m = 1; m < m1; m++) res -= m == 2 ? (check(y1) ? 29 : 28) : months[m];\\n        for(int m = 1; m < m2; m++) res += m == 2 ? (check(y2) ? 29 : 28) : months[m];\\n        return res + dd2 - dd1;\\n    }\\n    \\n    bool check(int y) {\\n        return y % 100  == 0 ? y % 400 == 0 : y % 4 == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518189,
                "title": "40-ms-faster-than-100-00-of-js-2-lines",
                "content": "### new Date()\\n- JavaScript `Date` objects represent a single moment in time in a platform-independent format.\\n- `Date.prototype.getTime()` returns the numeric value of the specified date as the number of milliseconds since **January 1, 1970, 00:00:00 UTC**. \\n- ` / (1000*60*60*24))` meaning `/ (thousand * seconds * minute * times)` to get days from the milisecond.\\n```\\nconst daysBetweenDates = (date1, date2) => {\\n    const a = new Date(date1).getTime(), b = new Date(date2).getTime();\\n    return Math.round(Math.abs(a - b) / (1000*60*60*24));\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst daysBetweenDates = (date1, date2) => {\\n    const a = new Date(date1).getTime(), b = new Date(date2).getTime();\\n    return Math.round(Math.abs(a - b) / (1000*60*60*24));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517970,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int DaysBetweenDates(string date1, string date2)\\n    {\\n        var d1 = DateTime.ParseExact(date1, \"yyyy-MM-dd\", null);\\n        var d2 = DateTime.ParseExact(date2, \"yyyy-MM-dd\", null);\\n        return Math.Abs((int) (d2 - d1).TotalDays);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int DaysBetweenDates(string date1, string date2)\\n    {\\n        var d1 = DateTime.ParseExact(date1, \"yyyy-MM-dd\", null);\\n        var d2 = DateTime.ParseExact(date2, \"yyyy-MM-dd\", null);\\n        return Math.Abs((int) (d2 - d1).TotalDays);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517813,
                "title": "java-hard-code-without-api",
                "content": "Java Hard Code without api\\n```Java\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n        \\n        int[] months = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n        int year1 = Integer.parseInt(d1[0]);\\n        int month1 = Integer.parseInt(d1[1]);\\n        int day1 = Integer.parseInt(d1[2]);\\n        int year2 = Integer.parseInt(d2[0]);\\n        int month2 = Integer.parseInt(d2[1]);\\n        int day2 = Integer.parseInt(d2[2]);\\n        int days1 = 0;\\n        int days2 = 0;\\n        \\n        for (int i = 0; i < month1 - 1; i++) {\\n            if (isLeapYear(year1) && i == 1) {\\n                days1 += 29;\\n            } else {\\n                days1 += months[i];\\n            }\\n            \\n        }\\n        days1 += day1;\\n        \\n        for (int j = 0; j < month2 - 1; j++) {\\n            if (isLeapYear(year2) && j == 1) {\\n                days2 += 29;\\n            } else {\\n                days2 += months[j];\\n            }\\n        }\\n        days2 += day2;\\n        \\n        int tmp = 0;\\n        int ans = 0;\\n        if (year1 == year2) {\\n            ans = Math.abs(days1 - days2);\\n            return ans;\\n        } else if (year1 > year2) {\\n            for (int k = year2; k < year1; k++) {\\n                if (isLeapYear(k)) {tmp += 366;}\\n                else {tmp += 365;}\\n            }\\n            ans = tmp + days1 - days2;\\n            return ans;\\n        } else {\\n            for (int k = year1; k < year2; k++) {\\n                if (isLeapYear(k)) {tmp += 366;}\\n                else {tmp += 365;}\\n            }\\n            ans = tmp + days2 - days1;\\n            return ans;\\n        }\\n     \\n        \\n    }\\n    public boolean isLeapYear(int year) {\\n        return (year % 4 == 0) && (year % 100 != 0) || (year % 400 == 0);\\n    }\\n    \\n\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n        \\n        int[] months = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n        int year1 = Integer.parseInt(d1[0]);\\n        int month1 = Integer.parseInt(d1[1]);\\n        int day1 = Integer.parseInt(d1[2]);\\n        int year2 = Integer.parseInt(d2[0]);\\n        int month2 = Integer.parseInt(d2[1]);\\n        int day2 = Integer.parseInt(d2[2]);\\n        int days1 = 0;\\n        int days2 = 0;\\n        \\n        for (int i = 0; i < month1 - 1; i++) {\\n            if (isLeapYear(year1) && i == 1) {\\n                days1 += 29;\\n            } else {\\n                days1 += months[i];\\n            }\\n            \\n        }\\n        days1 += day1;\\n        \\n        for (int j = 0; j < month2 - 1; j++) {\\n            if (isLeapYear(year2) && j == 1) {\\n                days2 += 29;\\n            } else {\\n                days2 += months[j];\\n            }\\n        }\\n        days2 += day2;\\n        \\n        int tmp = 0;\\n        int ans = 0;\\n        if (year1 == year2) {\\n            ans = Math.abs(days1 - days2);\\n            return ans;\\n        } else if (year1 > year2) {\\n            for (int k = year2; k < year1; k++) {\\n                if (isLeapYear(k)) {tmp += 366;}\\n                else {tmp += 365;}\\n            }\\n            ans = tmp + days1 - days2;\\n            return ans;\\n        } else {\\n            for (int k = year1; k < year2; k++) {\\n                if (isLeapYear(k)) {tmp += 366;}\\n                else {tmp += 365;}\\n            }\\n            ans = tmp + days2 - days1;\\n            return ans;\\n        }\\n     \\n        \\n    }\\n    public boolean isLeapYear(int year) {\\n        return (year % 4 == 0) && (year % 100 != 0) || (year % 400 == 0);\\n    }\\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517586,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nFor each date, count days since epoch `0000-00-00` and return the absolute difference.\\n\\n*Javascript*\\n```\\nlet daysBetweenDates = (a, b) => {\\n    let leapYears = (y, m) => {\\n        if (m <= 2) --y; // don\\'t count current year if month is Jan/Feb\\n        let f = Math.floor;\\n        return f(y / 400) + f(y / 4) - f(y / 100);\\n    };\\n    let monthDays = [0, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30];\\n    for (let i = 1; i < monthDays.length; ++i)\\n        monthDays[i] += monthDays[i - 1];\\n    let days = (y, m, d) => (y * 365) + leapYears(y, m) + monthDays[m] + d;\\n    let p = days(...a.split(\\'-\\').map(Number)),\\n        q = days(...b.split(\\'-\\').map(Number));\\n    return Math.abs(p - q);\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string a, string b, int y1 = 0, int m1 = 0, int d1 = 0, int y2 = 0, int m2 = 0, int d2 = 0, char _ = \\'-\\') {\\n        auto leapYears = [](auto y, auto m) {\\n            if (m <= 2) --y; // don\\'t count current year if month is Jan/Feb\\n            return (y / 400) + (y / 4) - (y / 100);\\n        };\\n        vector<int> monthDays{0, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};\\n        for (auto i = 1; i < monthDays.size(); ++i)\\n            monthDays[i] += monthDays[i - 1];\\n        auto days = [&](auto y, auto m, auto d) {\\n            return (y * 365) + leapYears(y, m) + monthDays[m] + d;\\n        };\\n        stringstream ss1{a}, ss2{b};\\n        ss1 >> y1 >> _ >> m1 >> _ >> d1;\\n        ss2 >> y2 >> _ >> m2 >> _ >> d2;\\n        auto p = days(y1, m1, d1),\\n             q = days(y2, m2, d2);\\n        return abs(p - q);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet daysBetweenDates = (a, b) => {\\n    let leapYears = (y, m) => {\\n        if (m <= 2) --y; // don\\'t count current year if month is Jan/Feb\\n        let f = Math.floor;\\n        return f(y / 400) + f(y / 4) - f(y / 100);\\n    };\\n    let monthDays = [0, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30];\\n    for (let i = 1; i < monthDays.length; ++i)\\n        monthDays[i] += monthDays[i - 1];\\n    let days = (y, m, d) => (y * 365) + leapYears(y, m) + monthDays[m] + d;\\n    let p = days(...a.split(\\'-\\').map(Number)),\\n        q = days(...b.split(\\'-\\').map(Number));\\n    return Math.abs(p - q);\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string a, string b, int y1 = 0, int m1 = 0, int d1 = 0, int y2 = 0, int m2 = 0, int d2 = 0, char _ = \\'-\\') {\\n        auto leapYears = [](auto y, auto m) {\\n            if (m <= 2) --y; // don\\'t count current year if month is Jan/Feb\\n            return (y / 400) + (y / 4) - (y / 100);\\n        };\\n        vector<int> monthDays{0, 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};\\n        for (auto i = 1; i < monthDays.size(); ++i)\\n            monthDays[i] += monthDays[i - 1];\\n        auto days = [&](auto y, auto m, auto d) {\\n            return (y * 365) + leapYears(y, m) + monthDays[m] + d;\\n        };\\n        stringstream ss1{a}, ss2{b};\\n        ss1 >> y1 >> _ >> m1 >> _ >> d1;\\n        ss2 >> y2 >> _ >> m2 >> _ >> d2;\\n        auto p = days(y1, m1, d1),\\n             q = days(y2, m2, d2);\\n        return abs(p - q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092475,
                "title": "one-line-code-in-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int daysBetweenDates(String date1, String date2) {\\n      return DateTime.parse(date2).difference(DateTime.parse(date1)).inDays.abs();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int daysBetweenDates(String date1, String date2) {\\n      return DateTime.parse(date2).difference(DateTime.parse(date1)).inDays.abs();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071088,
                "title": "java-easy-solution-using-localdate-easy-approach-beginner-friendly-easy-to-understand",
                "content": "\\n\\n# Approach\\n1. Split both the dates using split() function which contains \"-\".\\n2. Using LocalDate declare start and end dates.\\n3. Compare start and end using ChronoUnit.\\n4. For returning positive use Math.abs() and return (int) to return int values as expected in the method.\\n\\n# Code\\n```\\nimport java.time.*;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n\\n        LocalDate start = LocalDate.of(Integer.parseInt(d1[0]), Integer.parseInt(d1[1]), Integer.parseInt(d1[2]));\\n        LocalDate end = LocalDate.of(Integer.parseInt(d2[0]), Integer.parseInt(d2[1]), Integer.parseInt(d2[2]));\\n        long days = ChronoUnit.DAYS.between(start, end);\\n        return Math.abs((int) days);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.*;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n\\n        LocalDate start = LocalDate.of(Integer.parseInt(d1[0]), Integer.parseInt(d1[1]), Integer.parseInt(d1[2]));\\n        LocalDate end = LocalDate.of(Integer.parseInt(d2[0]), Integer.parseInt(d2[1]), Integer.parseInt(d2[2]));\\n        long days = ChronoUnit.DAYS.between(start, end);\\n        return Math.abs((int) days);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070423,
                "title": "with-and-without-time-api-java",
                "content": "```\\n// import java.time.LocalDate;\\n// import java.time.temporal.ChronoUnit;\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        \\n\\t   // return Math.abs((int)ChronoUnit.DAYS.between(LocalDate.parse(date1), LocalDate.parse(date2)));\\n        return Math.abs(totalDays(date1)-totalDays(date2));\\n        \\n    }\\n    public int totalDays(String date){\\n        int year = Integer.parseInt(date.substring(0,4));\\n        int month = Integer.parseInt(date.substring(5,7));\\n        int days = Integer.parseInt(date.substring(8,10));\\n        int[] monthsDays = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};\\n        for(int i=0;i<month-1;i++){\\n            days+= (monthsDays[i]);\\n        }\\n        //If we are in 2011 year and second month we need to count 365 days till 2010 only\\n        days+= ((year-1)*365);\\n        // from 1971 every four years we get leap year so number of leap year equals = number of one extra day day of feb  \\n        days+=  (year-1)/4;\\n        if(year%4 ==0 && month >2 && year!=2100) days++;\\n        return days;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// import java.time.LocalDate;\\n// import java.time.temporal.ChronoUnit;\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        \\n\\t   // return Math.abs((int)ChronoUnit.DAYS.between(LocalDate.parse(date1), LocalDate.parse(date2)));\\n        return Math.abs(totalDays(date1)-totalDays(date2));\\n        \\n    }\\n    public int totalDays(String date){\\n        int year = Integer.parseInt(date.substring(0,4));\\n        int month = Integer.parseInt(date.substring(5,7));\\n        int days = Integer.parseInt(date.substring(8,10));\\n        int[] monthsDays = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};\\n        for(int i=0;i<month-1;i++){\\n            days+= (monthsDays[i]);\\n        }\\n        //If we are in 2011 year and second month we need to count 365 days till 2010 only\\n        days+= ((year-1)*365);\\n        // from 1971 every four years we get leap year so number of leap year equals = number of one extra day day of feb  \\n        days+=  (year-1)/4;\\n        if(year%4 ==0 && month >2 && year!=2100) days++;\\n        return days;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066010,
                "title": "no-of-days-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nvar daysBetweenDates = function(date1, date2) {\\n     let daysmill=24*3600*1000;\\n        date1=new Date(date1);\\n        date2=new Date(date2);\\n        let diff=date2-date1;\\n        diff=diff/daysmill;\\n        return Math.abs(diff);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nvar daysBetweenDates = function(date1, date2) {\\n     let daysmill=24*3600*1000;\\n        date1=new Date(date1);\\n        date2=new Date(date2);\\n        let diff=date2-date1;\\n        diff=diff/daysmill;\\n        return Math.abs(diff);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055893,
                "title": "simple-java-solution",
                "content": "# Intuition\\nStarting from 0000-00-00, count the days to date1 (say, num1) and to date2 (say, num2). Return the absolute difference between num1 and num2. \\n\\n# Approach\\nint num1 = y1 * 365 + getMonthDays(m1 - 1) + d1 + getNumOfLeapYrs(date1);\\nint num2 = y2 * 365 + getMonthDays(m2 - 1) + d2 + getNumOfLeapYrs(date2);\\n\\nreturn Math.abs(num2 - num1);\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n = number of months, since we iterate over each of the month days to get a total of the days in the month in a given date. The worst case complexity for it could be O(12) if we are calculating the days for December.\\n\\n- Space complexity:\\nO(n) where n = number of months, since we need to store the days in each momth\\n\\n# Code\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        // return the difference in days between the two dates\\n        return Math.abs(getNumOfDays(date1) - getNumOfDays(date2));\\n    }\\n\\n    private int getNumOfLeapYrs(int y, int m){\\n        y = (m > 2)? y : y - 1; \\n        return (int)(y/4 - y/100 + y/400);\\n    }\\n\\n    private int getNumOfDays(String date){\\n        int monthDays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\n\\n        String[] dateArr = date.split(\"-\");\\n        int y = Integer.parseInt(dateArr[0]);\\n        int m = Integer.parseInt(dateArr[1]);\\n        int d = Integer.parseInt(dateArr[2]);\\n\\n        // Starting from 0000-00-00, count the days to date\\n        int numDays = y * 365 + d + getNumOfLeapYrs(y, m); \\n\\n        // Add days for months in the given date\\n        for (int i = 0; i < m - 1; i++) \\n            numDays += monthDays[i];\\n\\n        return numDays;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        // return the difference in days between the two dates\\n        return Math.abs(getNumOfDays(date1) - getNumOfDays(date2));\\n    }\\n\\n    private int getNumOfLeapYrs(int y, int m){\\n        y = (m > 2)? y : y - 1; \\n        return (int)(y/4 - y/100 + y/400);\\n    }\\n\\n    private int getNumOfDays(String date){\\n        int monthDays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\n\\n        String[] dateArr = date.split(\"-\");\\n        int y = Integer.parseInt(dateArr[0]);\\n        int m = Integer.parseInt(dateArr[1]);\\n        int d = Integer.parseInt(dateArr[2]);\\n\\n        // Starting from 0000-00-00, count the days to date\\n        int numDays = y * 365 + d + getNumOfLeapYrs(y, m); \\n\\n        // Add days for months in the given date\\n        for (int i = 0; i < m - 1; i++) \\n            numDays += monthDays[i];\\n\\n        return numDays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041848,
                "title": "golang-zeller-s-congruence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCount the number of days in years, leap years , in months and days...\\nwe count the Jan and Feb as 13 and 14 months to calculate the number of days in the months easily by this (153*m+8)/5. Check Zeller\\'s Congruence / Day of the week problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc daysBetweenDates(date1 string, date2 string) int {\\n    y1, _ := strconv.Atoi(date1[0:4])\\n\\tm1, _ := strconv.Atoi(date1[5:7])\\n\\td1, _ := strconv.Atoi(date1[8:10])\\n\\n\\ty2, _ := strconv.Atoi(date2[0:4])\\n\\tm2, _ := strconv.Atoi(date2[5:7])\\n\\td2, _ := strconv.Atoi(date2[8:10])\\n\\n    return abs(countDays(y1,m1,d1)-countDays(y2,m2,d2))\\n}\\n\\nfunc countDays(y,m,d int) (count int){\\n    if m<3{ m+=12; y-=1 }\\n    daysInLeap:=(y/4) - (y/100) + (y/400)\\n    dayInYears:=y*365\\n    dayInMonths:=(153*m+8)/5\\n    count=dayInYears+daysInLeap+dayInMonths+d\\n    return\\n}\\n\\nfunc abs(x int)int{\\n    if x<0 {return -x}\\n    return x\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc daysBetweenDates(date1 string, date2 string) int {\\n    y1, _ := strconv.Atoi(date1[0:4])\\n\\tm1, _ := strconv.Atoi(date1[5:7])\\n\\td1, _ := strconv.Atoi(date1[8:10])\\n\\n\\ty2, _ := strconv.Atoi(date2[0:4])\\n\\tm2, _ := strconv.Atoi(date2[5:7])\\n\\td2, _ := strconv.Atoi(date2[8:10])\\n\\n    return abs(countDays(y1,m1,d1)-countDays(y2,m2,d2))\\n}\\n\\nfunc countDays(y,m,d int) (count int){\\n    if m<3{ m+=12; y-=1 }\\n    daysInLeap:=(y/4) - (y/100) + (y/400)\\n    dayInYears:=y*365\\n    dayInMonths:=(153*m+8)/5\\n    count=dayInYears+daysInLeap+dayInMonths+d\\n    return\\n}\\n\\nfunc abs(x int)int{\\n    if x<0 {return -x}\\n    return x\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020614,
                "title": "1-line-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int DaysBetweenDates(string date1, string date2)\\n    {\\n        return Math.Abs((DateTime.Parse(date1) - DateTime.Parse(date2)).Days);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int DaysBetweenDates(string date1, string date2)\\n    {\\n        return Math.Abs((DateTime.Parse(date1) - DateTime.Parse(date2)).Days);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016215,
                "title": "fast-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nvar daysBetweenDates = function(date1, date2) {\\n    const datetime1 = new Date(date1).getTime()\\n    const datetime2 = new Date(date2).getTime()\\n\\n    return Math.abs((datetime2 - datetime1)/(1000*60*60*24))\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nvar daysBetweenDates = function(date1, date2) {\\n    const datetime1 = new Date(date1).getTime()\\n    const datetime2 = new Date(date2).getTime()\\n\\n    return Math.abs((datetime2 - datetime1)/(1000*60*60*24))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984123,
                "title": "0ms-beats-100-00-of-users-with-java",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$, since the number of months is constant.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(numOfDays(date1) - numOfDays(date2));\\n    }\\n\\n    public int numOfDays(String date) {\\n        int[] monthDays = {\\n            31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\\n            };\\n\\n        int year = Integer.parseInt(date.substring(0,4));\\n        int month = Integer.parseInt(date.substring(5,7));\\n        int day = Integer.parseInt(date.substring(8,10));\\n\\n        for(int i = 0 ; i < month-1; i++){\\n            day += monthDays[i];\\n        }\\n\\n        day += (year-1)*365 + (year-1)/4;\\n        if(year % 4 == 0 && month > 2 && year != 2100) day++;\\n\\n        return day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(numOfDays(date1) - numOfDays(date2));\\n    }\\n\\n    public int numOfDays(String date) {\\n        int[] monthDays = {\\n            31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\\n            };\\n\\n        int year = Integer.parseInt(date.substring(0,4));\\n        int month = Integer.parseInt(date.substring(5,7));\\n        int day = Integer.parseInt(date.substring(8,10));\\n\\n        for(int i = 0 ; i < month-1; i++){\\n            day += monthDays[i];\\n        }\\n\\n        day += (year-1)*365 + (year-1)/4;\\n        if(year % 4 == 0 && month > 2 && year != 2100) day++;\\n\\n        return day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979758,
                "title": "modern-c-solution-using-ctime-library",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npair<string, string> SplitTwo(string s) {\\n  const size_t pos = s.find(\\'-\\');\\n  return {s.substr(0, pos), s.substr(pos + 1)};\\n}\\n\\nstring ReadToken(string& s) {\\n  const auto [lhs, rhs] = SplitTwo(s);\\n  s = rhs;\\n  return lhs;\\n}\\n\\nclass Date {\\npublic:\\n  Date(int year, int month, int day)\\n  : year_(year)\\n  , month_(month)\\n  , day_(day) \\n  {}\\n\\n  static Date FromString(string str) {\\n    const int year = stoi(ReadToken(str));\\n    const int month = stoi(ReadToken(str));\\n    const int day = stoi(str);\\n    return {year, month, day};\\n  }\\n\\n\\n  time_t AsTimestamp() const {\\n    // https://en.cppreference.com/w/cpp/chrono/c/tm\\n    tm t;\\n    t.tm_sec  = 0;\\n    t.tm_min  = 0;\\n    t.tm_hour = 0;\\n    t.tm_mday = day_;\\n    t.tm_mon  = month_ - 1;\\n    t.tm_year = year_ - 1900;\\n    t.tm_isdst = 0;\\n    // https://en.cppreference.com/w/cpp/chrono/c/mktime\\n    return mktime(&t);\\n  }\\n\\nprivate:\\n  int year_;\\n  int month_;\\n  int day_;\\n};\\n\\nint ComputeDaysDiff(const Date& date_to, const Date& date_from) {\\n  // https://en.cppreference.com/w/cpp/chrono/c/time_t\\n  const time_t timestamp_to = date_to.AsTimestamp();\\n  const time_t timestamp_from = date_from.AsTimestamp();\\n  static constexpr int SECONDS_IN_DAY = 60 * 60 * 24;\\n  return (timestamp_to - timestamp_from) / SECONDS_IN_DAY;\\n}\\n\\nclass Solution {\\npublic:\\n  int daysBetweenDates(string date1, string date2) {\\n    Date date_from = Date::FromString(date1);\\n    Date date_to = Date::FromString(date2);\\n\\n    int ans = ComputeDaysDiff(date_from, date_to);\\n    if (ans < 0) ans *= -1;\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npair<string, string> SplitTwo(string s) {\\n  const size_t pos = s.find(\\'-\\');\\n  return {s.substr(0, pos), s.substr(pos + 1)};\\n}\\n\\nstring ReadToken(string& s) {\\n  const auto [lhs, rhs] = SplitTwo(s);\\n  s = rhs;\\n  return lhs;\\n}\\n\\nclass Date {\\npublic:\\n  Date(int year, int month, int day)\\n  : year_(year)\\n  , month_(month)\\n  , day_(day) \\n  {}\\n\\n  static Date FromString(string str) {\\n    const int year = stoi(ReadToken(str));\\n    const int month = stoi(ReadToken(str));\\n    const int day = stoi(str);\\n    return {year, month, day};\\n  }\\n\\n\\n  time_t AsTimestamp() const {\\n    // https://en.cppreference.com/w/cpp/chrono/c/tm\\n    tm t;\\n    t.tm_sec  = 0;\\n    t.tm_min  = 0;\\n    t.tm_hour = 0;\\n    t.tm_mday = day_;\\n    t.tm_mon  = month_ - 1;\\n    t.tm_year = year_ - 1900;\\n    t.tm_isdst = 0;\\n    // https://en.cppreference.com/w/cpp/chrono/c/mktime\\n    return mktime(&t);\\n  }\\n\\nprivate:\\n  int year_;\\n  int month_;\\n  int day_;\\n};\\n\\nint ComputeDaysDiff(const Date& date_to, const Date& date_from) {\\n  // https://en.cppreference.com/w/cpp/chrono/c/time_t\\n  const time_t timestamp_to = date_to.AsTimestamp();\\n  const time_t timestamp_from = date_from.AsTimestamp();\\n  static constexpr int SECONDS_IN_DAY = 60 * 60 * 24;\\n  return (timestamp_to - timestamp_from) / SECONDS_IN_DAY;\\n}\\n\\nclass Solution {\\npublic:\\n  int daysBetweenDates(string date1, string date2) {\\n    Date date_from = Date::FromString(date1);\\n    Date date_to = Date::FromString(date2);\\n\\n    int ans = ComputeDaysDiff(date_from, date_to);\\n    if (ans < 0) ans *= -1;\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944317,
                "title": "unique-solution-using-localdate-and-chronounit",
                "content": "\\n\\n# Code\\n```\\nimport java.time.temporal.ChronoUnit;\\nimport java.time.LocalDate;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n\\n        LocalDate ld1 = LocalDate.of(Integer.valueOf(date1.substring(0,4)),\\n        Integer.valueOf(date1.substring(5,7)),\\n        Integer.valueOf(date1.substring(8,date1.length())));\\n\\n        LocalDate ld2 = LocalDate.of(Integer.valueOf(date2.substring(0,4)),\\n        Integer.valueOf(date2.substring(5,7)),\\n        Integer.valueOf(date2.substring(8,date2.length())));\\n\\n        long daysBetween =  ChronoUnit.DAYS.between(ld2, ld1);\\n        int days = (int) daysBetween%100000000;\\n        //return 0;\\n        return Math.abs(days);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.temporal.ChronoUnit;\\nimport java.time.LocalDate;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n\\n        LocalDate ld1 = LocalDate.of(Integer.valueOf(date1.substring(0,4)),\\n        Integer.valueOf(date1.substring(5,7)),\\n        Integer.valueOf(date1.substring(8,date1.length())));\\n\\n        LocalDate ld2 = LocalDate.of(Integer.valueOf(date2.substring(0,4)),\\n        Integer.valueOf(date2.substring(5,7)),\\n        Integer.valueOf(date2.substring(8,date2.length())));\\n\\n        long daysBetween =  ChronoUnit.DAYS.between(ld2, ld1);\\n        int days = (int) daysBetween%100000000;\\n        //return 0;\\n        return Math.abs(days);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943837,
                "title": "java-simple-solutions",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2){\\n        try{\\n            LocalDate beingDate = LocalDate.parse(date1);\\n            LocalDate endDate = LocalDate.parse(date2);\\n            long differ = ChronoUnit.DAYS.between(beingDate, endDate);\\n            return Math.abs((int) differ);\\n        }catch(Exception e){\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2){\\n        try{\\n            LocalDate beingDate = LocalDate.parse(date1);\\n            LocalDate endDate = LocalDate.parse(date2);\\n            long differ = ChronoUnit.DAYS.between(beingDate, endDate);\\n            return Math.abs((int) differ);\\n        }catch(Exception e){\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928902,
                "title": "simple-typescript-solution",
                "content": "# Code\\n```ts\\nfunction daysBetweenDates(date1: string, date2: string): number {\\n    return Math.abs((new Date(date1).valueOf() - new Date(date2).valueOf()) / (1000 * 60 * 60 * 24))\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction daysBetweenDates(date1: string, date2: string): number {\\n    return Math.abs((new Date(date1).valueOf() - new Date(date2).valueOf()) / (1000 * 60 * 60 * 24))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924134,
                "title": "java-mathematical-formula-o-1-runtime-96-76-1-ms-memory-98-65-40-1-mb",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\"), d2 = date2.split(\"-\");\\n\\n\\t\\treturn Math.abs(\\n            calculateDate(Integer.parseInt(d2[2]), Integer.parseInt(d2[1]), Integer.parseInt(d2[0]))\\n          - calculateDate(Integer.parseInt(d1[2]), Integer.parseInt(d1[1]), Integer.parseInt(d1[0]))\\n        );\\n    }\\n    \\n\\tprivate int calculateDate(int day, int month, int year) {\\n\\t\\tif (month < 3) {\\n\\t\\t\\tyear--;\\n\\t\\t\\tmonth = month + 12;\\n\\t\\t}\\n\\t\\treturn 365 * year + year / 4 - year / 100 + year / 400 + ((month + 1) * 306) / 10 + (day - 62);\\n\\t}\\n}\\n```\\n```java []\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(calculateDate(date2.split(\"-\")) - calculateDate(date1.split(\"-\")));\\n    }\\n    \\n\\tprivate int calculateDate(String[] d) {\\n        int year = Integer.parseInt(d[0]);\\n        int month = Integer.parseInt(d[1]);\\n        int day = Integer.parseInt(d[2]);\\n\\n\\t\\tif (month < 3) {\\n\\t\\t\\tyear--;\\n\\t\\t\\tmonth = month + 12;\\n\\t\\t}\\n\\n\\t\\treturn 365 * year + year / 4 - year / 100 + year / 400 + ((month + 1) * 306) / 10 + (day - 62);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] d1 = date1.split(\"-\"), d2 = date2.split(\"-\");\\n\\n\\t\\treturn Math.abs(\\n            calculateDate(Integer.parseInt(d2[2]), Integer.parseInt(d2[1]), Integer.parseInt(d2[0]))\\n          - calculateDate(Integer.parseInt(d1[2]), Integer.parseInt(d1[1]), Integer.parseInt(d1[0]))\\n        );\\n    }\\n    \\n\\tprivate int calculateDate(int day, int month, int year) {\\n\\t\\tif (month < 3) {\\n\\t\\t\\tyear--;\\n\\t\\t\\tmonth = month + 12;\\n\\t\\t}\\n\\t\\treturn 365 * year + year / 4 - year / 100 + year / 400 + ((month + 1) * 306) / 10 + (day - 62);\\n\\t}\\n}\\n```\n```java []\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(calculateDate(date2.split(\"-\")) - calculateDate(date1.split(\"-\")));\\n    }\\n    \\n\\tprivate int calculateDate(String[] d) {\\n        int year = Integer.parseInt(d[0]);\\n        int month = Integer.parseInt(d[1]);\\n        int day = Integer.parseInt(d[2]);\\n\\n\\t\\tif (month < 3) {\\n\\t\\t\\tyear--;\\n\\t\\t\\tmonth = month + 12;\\n\\t\\t}\\n\\n\\t\\treturn 365 * year + year / 4 - year / 100 + year / 400 + ((month + 1) * 306) / 10 + (day - 62);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895188,
                "title": "java-just-5-lines",
                "content": "\\n\\nimport java.time.LocalDate;\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n       \\n        LocalDate l1 = LocalDate.parse(date1);\\n        long a = l1.toEpochDay();\\n\\n        LocalDate l2 = LocalDate.parse(date2);\\n        long b = l2.toEpochDay();\\n\\n        return Math.abs((int) (a - b));\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n       \\n        LocalDate l1 = LocalDate.parse(date1);\\n        long a = l1.toEpochDay();\\n\\n        LocalDate l2 = LocalDate.parse(date2);\\n        long b = l2.toEpochDay();\\n\\n        return Math.abs((int) (a - b));\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3884997,
                "title": "why-am-i-doing-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean isLeap(int year) {\\n        return (year % 4 == 0 && year % 100 != 0) || (year % 100 == 0 && year % 400 == 0);\\n    }\\n    private void swap(String[] arr1,String[] arr2){\\n        for (int i = 0; i < arr1.length; i++) {\\n            String temp = arr1[i];\\n            arr1[i] = arr2[i];\\n            arr2[i] = temp;\\n        }\\n    }\\n    public int daysBetweenDates(String date1, String date2) {\\n        int res = 0;\\n        int totalnormalyear[] = {0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int totalleapyear[] = {0,31,60,91,121,152,182,213,244,274,305,335,366};\\n        int[] mo = {0,31,28,31,30,31,30,31,31,30,31,30,31};\\n\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n        if(Integer.parseInt(d1[0]) > Integer.parseInt(d2[0])){\\n            swap(d1,d2);\\n        }\\n        //d[0] = year, d[1] = month, d[2] = day\\n        int year1 = Integer.parseInt(d1[0]),year2 = Integer.parseInt(d2[0]);\\n        int month1 = Integer.parseInt(d1[1]),month2 = Integer.parseInt(d2[1]);\\n        int day1 = Integer.parseInt(d1[2]),day2 = Integer.parseInt(d2[2]);\\n        if(year1 == year2 && month1 == month2) return Math.abs(day1-day2);\\n        for(int i = year1 +1; i < year2; i++){\\n            if(i < year2){\\n                if(isLeap(i)) res+= 366;\\n                else res += 365;\\n            }\\n            \\n        }\\n        if(isLeap(year1)){\\n            if(month1 == 2){\\n                res += (366 - (totalleapyear[2] - 29 + day1));\\n            }else{\\n                res += (366 - (totalleapyear[month1] - mo[month1]+day1));\\n            } \\n        }else{\\n            res += 365 - (totalnormalyear[month1] - mo[month1]+ day1);\\n        }\\n        if(isLeap(year2)){\\n            if(month2 == 2){\\n                res += totalleapyear[2] - 29 + day2; \\n            }else{\\n                res += totalleapyear[month2] - mo[month2] + day2;\\n            }\\n        }else{\\n            res += totalnormalyear[month2] - mo[month2] + day2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isLeap(int year) {\\n        return (year % 4 == 0 && year % 100 != 0) || (year % 100 == 0 && year % 400 == 0);\\n    }\\n    private void swap(String[] arr1,String[] arr2){\\n        for (int i = 0; i < arr1.length; i++) {\\n            String temp = arr1[i];\\n            arr1[i] = arr2[i];\\n            arr2[i] = temp;\\n        }\\n    }\\n    public int daysBetweenDates(String date1, String date2) {\\n        int res = 0;\\n        int totalnormalyear[] = {0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int totalleapyear[] = {0,31,60,91,121,152,182,213,244,274,305,335,366};\\n        int[] mo = {0,31,28,31,30,31,30,31,31,30,31,30,31};\\n\\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");\\n        if(Integer.parseInt(d1[0]) > Integer.parseInt(d2[0])){\\n            swap(d1,d2);\\n        }\\n        //d[0] = year, d[1] = month, d[2] = day\\n        int year1 = Integer.parseInt(d1[0]),year2 = Integer.parseInt(d2[0]);\\n        int month1 = Integer.parseInt(d1[1]),month2 = Integer.parseInt(d2[1]);\\n        int day1 = Integer.parseInt(d1[2]),day2 = Integer.parseInt(d2[2]);\\n        if(year1 == year2 && month1 == month2) return Math.abs(day1-day2);\\n        for(int i = year1 +1; i < year2; i++){\\n            if(i < year2){\\n                if(isLeap(i)) res+= 366;\\n                else res += 365;\\n            }\\n            \\n        }\\n        if(isLeap(year1)){\\n            if(month1 == 2){\\n                res += (366 - (totalleapyear[2] - 29 + day1));\\n            }else{\\n                res += (366 - (totalleapyear[month1] - mo[month1]+day1));\\n            } \\n        }else{\\n            res += 365 - (totalnormalyear[month1] - mo[month1]+ day1);\\n        }\\n        if(isLeap(year2)){\\n            if(month2 == 2){\\n                res += totalleapyear[2] - 29 + day2; \\n            }else{\\n                res += totalleapyear[month2] - mo[month2] + day2;\\n            }\\n        }else{\\n            res += totalnormalyear[month2] - mo[month2] + day2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884942,
                "title": "the-correct-answer-for-interviews-python",
                "content": "Using Libraries to solve this question is trival.\\n\\nI believe we need to consider leap year when we solve this question. \\n\\nBelow is the correct solution when you are asked this question during the interviews. \\n\\nIt definitely should not be tagged with \"Easy\". \\n\\n# Code\\n```\\nfrom datetime import datetime\\n\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def is_leap_year(year):\\n            if year % 4 == 0:\\n                if year % 100 == 0:\\n                    if year % 400 == 0:\\n                        return True\\n                    return False\\n                return True\\n            return False\\n\\n        def days_in_month(month, year):\\n            if month == 2:\\n                if is_leap_year(year):\\n                    return 29 # Leap year\\n                else:\\n                    return 28 # Non-leap year\\n            elif month in [4, 6, 9, 11]:\\n                return 30\\n            else:\\n                return 31\\n \\n        d1 = date1.split(\"-\")\\n        d2 = date2.split(\"-\")\\n        date1 = datetime(int(d1[0]), int(d1[1]), int(d1[2]))\\n        date2 = datetime(int(d2[0]), int(d2[1]), int(d2[2]))\\n\\n        if date1 > date2:\\n            date1, date2 = date2, date1\\n\\n        year1 = date1.year\\n        year2 = date2.year\\n        month1 = date1.month\\n        month2 = date2.month\\n        day1 = date1.day\\n        day2 = date2.day\\n        days = 0\\n\\n        # Calculate number of days between the two years\\n        for year in range(year1, year2 + 1):\\n            min_month = month1 if year == year1 else 1\\n            max_month = month2 if year == year2 else 12\\n\\n            # Calculate number of days between the two months of the current year\\n            for month in range(min_month, max_month + 1):\\n                max_day = days_in_month(month, year)\\n                if year == year2 and month == month2:\\n                    max_day = day2\\n                if year == year1 and month == month1:\\n                    days += max_day - day1\\n                else:\\n                    days += max_day\\n\\n        return days # return the difference in days\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom datetime import datetime\\n\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        def is_leap_year(year):\\n            if year % 4 == 0:\\n                if year % 100 == 0:\\n                    if year % 400 == 0:\\n                        return True\\n                    return False\\n                return True\\n            return False\\n\\n        def days_in_month(month, year):\\n            if month == 2:\\n                if is_leap_year(year):\\n                    return 29 # Leap year\\n                else:\\n                    return 28 # Non-leap year\\n            elif month in [4, 6, 9, 11]:\\n                return 30\\n            else:\\n                return 31\\n \\n        d1 = date1.split(\"-\")\\n        d2 = date2.split(\"-\")\\n        date1 = datetime(int(d1[0]), int(d1[1]), int(d1[2]))\\n        date2 = datetime(int(d2[0]), int(d2[1]), int(d2[2]))\\n\\n        if date1 > date2:\\n            date1, date2 = date2, date1\\n\\n        year1 = date1.year\\n        year2 = date2.year\\n        month1 = date1.month\\n        month2 = date2.month\\n        day1 = date1.day\\n        day2 = date2.day\\n        days = 0\\n\\n        # Calculate number of days between the two years\\n        for year in range(year1, year2 + 1):\\n            min_month = month1 if year == year1 else 1\\n            max_month = month2 if year == year2 else 12\\n\\n            # Calculate number of days between the two months of the current year\\n            for month in range(min_month, max_month + 1):\\n                max_day = days_in_month(month, year)\\n                if year == year2 and month == month2:\\n                    max_day = day2\\n                if year == year1 and month == month1:\\n                    days += max_day - day1\\n                else:\\n                    days += max_day\\n\\n        return days # return the difference in days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880182,
                "title": "go-easy",
                "content": "\\n\\n# Code\\n```\\nfunc daysBetweenDates(date1 string, date2 string) int {\\n    date01, _ := time.Parse(\"2006-01-02\", date1)\\n    date02, _ := time.Parse(\"2006-01-02\", date2)\\n    difference := date02.Sub(date01)\\n    fmt.Println(difference.Hours()/24)\\n    return int(math.Abs(difference.Hours()/24)) \\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc daysBetweenDates(date1 string, date2 string) int {\\n    date01, _ := time.Parse(\"2006-01-02\", date1)\\n    date02, _ := time.Parse(\"2006-01-02\", date2)\\n    difference := date02.Sub(date01)\\n    fmt.Println(difference.Hours()/24)\\n    return int(math.Abs(difference.Hours()/24)) \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879442,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int daysBetweenDates(String date1, String date2) {\\n    int year1 = int.parse(date1.substring(0, 4));\\n    int month1 = int.parse(date1.substring(5, 7));\\n    int day1 = int.parse(date1.substring(8));\\n    \\n    int year2 = int.parse(date2.substring(0, 4));\\n    int month2 = int.parse(date2.substring(5, 7));\\n    int day2 = int.parse(date2.substring(8));\\n    \\n    return (dayToYear(year1) + dayOfYear(day1, month1, year1) - dayToYear(year2) - dayOfYear(day2, month2, year2)).abs();\\n  }\\n\\n  int dayToYear(int year) {\\n    int result = (year - 1971) * 365;\\n    result += (year - 1968 - 1) ~/ 4;\\n    return result;\\n  }\\n\\n  int dayOfYear(int day, int month, int year) {\\n    int result = 0;\\n    int y = 0;\\n    if (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0)) {\\n      y = 1;\\n    }\\n    switch (month) {\\n      case 1:\\n        result = day;\\n        break;\\n      case 2:\\n        result = 31 + day;\\n        break;\\n      case 3:\\n        result = 59 + day + y;\\n        break;\\n      case 4:\\n        result = 90 + day + y;\\n        break;\\n      case 5:\\n        result = 120 + day + y;\\n        break;\\n      case 6:\\n        result = 151 + day + y;\\n        break;\\n      case 7:\\n        result = 181 + day + y;\\n        break;\\n      case 8:\\n        result = 212 + day + y;\\n        break;\\n      case 9:\\n        result = 243 + day + y;\\n        break;\\n      case 10:\\n        result = 273 + day + y;\\n        break;\\n      case 11:\\n        result = 304 + day + y;\\n        break;\\n      case 12:\\n        result = 334 + day + y;\\n        break;\\n    }\\n    return result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int daysBetweenDates(String date1, String date2) {\\n    int year1 = int.parse(date1.substring(0, 4));\\n    int month1 = int.parse(date1.substring(5, 7));\\n    int day1 = int.parse(date1.substring(8));\\n    \\n    int year2 = int.parse(date2.substring(0, 4));\\n    int month2 = int.parse(date2.substring(5, 7));\\n    int day2 = int.parse(date2.substring(8));\\n    \\n    return (dayToYear(year1) + dayOfYear(day1, month1, year1) - dayToYear(year2) - dayOfYear(day2, month2, year2)).abs();\\n  }\\n\\n  int dayToYear(int year) {\\n    int result = (year - 1971) * 365;\\n    result += (year - 1968 - 1) ~/ 4;\\n    return result;\\n  }\\n\\n  int dayOfYear(int day, int month, int year) {\\n    int result = 0;\\n    int y = 0;\\n    if (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0)) {\\n      y = 1;\\n    }\\n    switch (month) {\\n      case 1:\\n        result = day;\\n        break;\\n      case 2:\\n        result = 31 + day;\\n        break;\\n      case 3:\\n        result = 59 + day + y;\\n        break;\\n      case 4:\\n        result = 90 + day + y;\\n        break;\\n      case 5:\\n        result = 120 + day + y;\\n        break;\\n      case 6:\\n        result = 151 + day + y;\\n        break;\\n      case 7:\\n        result = 181 + day + y;\\n        break;\\n      case 8:\\n        result = 212 + day + y;\\n        break;\\n      case 9:\\n        result = 243 + day + y;\\n        break;\\n      case 10:\\n        result = 273 + day + y;\\n        break;\\n      case 11:\\n        result = 304 + day + y;\\n        break;\\n      case 12:\\n        result = 334 + day + y;\\n        break;\\n    }\\n    return result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869509,
                "title": "starting-to-try-this-out-now",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom datetime import date\\n\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        rawDate1 = date1.split(\\'-\\')\\n        rawDate2 = date2.split(\\'-\\')\\n\\n        dateObj1 = date(int(rawDate1[0]),int(rawDate1[1]),int(rawDate1[2]))\\n        dateObj2 = date(int(rawDate2[0]),int(rawDate2[1]),int(rawDate2[2]))\\n\\n\\n        diff = dateObj1-dateObj2\\n\\n        return abs(diff.days)\\n    \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom datetime import date\\n\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        rawDate1 = date1.split(\\'-\\')\\n        rawDate2 = date2.split(\\'-\\')\\n\\n        dateObj1 = date(int(rawDate1[0]),int(rawDate1[1]),int(rawDate1[2]))\\n        dateObj2 = date(int(rawDate2[0]),int(rawDate2[1]),int(rawDate2[2]))\\n\\n\\n        diff = dateObj1-dateObj2\\n\\n        return abs(diff.days)\\n    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859258,
                "title": "java-time-lib",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.time.LocalDate;\\nimport java.time.format.DateTimeFormatter;\\nimport java.time.Duration;\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\\n        return Math.abs((int) Duration.between(LocalDate.parse(date1, df).atStartOfDay(), LocalDate.parse(date2, df).atStartOfDay()).toDays());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.format.DateTimeFormatter;\\nimport java.time.Duration;\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\\n        return Math.abs((int) Duration.between(LocalDate.parse(date1, df).atStartOfDay(), LocalDate.parse(date2, df).atStartOfDay()).toDays());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854682,
                "title": "simple-easy-solution-no-built-in-library-java-runtime-1ms-beats-95-72",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n\\n        // split the date string \\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");     \\n\\n        // convert string into integers\\n        int year1 = Integer.parseInt(d1[0]), month1 = Integer.parseInt(d1[1]), day1 = Integer.parseInt(d1[2]);\\n        int year2 = Integer.parseInt(d2[0]), month2 = Integer.parseInt(d2[1]), day2 = Integer.parseInt(d2[2]);\\n\\n        int daysBetweenDates = 0;\\n\\n        // if start date is bigger than end date\\n        // swap the dates\\n        if((year1>year2) || (year1==year2 && month1>month2) || ((year1 == year2) && (month1 == month2) && (day1 > day2))){\\n            int temp = year1;\\n            year1 = year2;\\n            year2 = temp;\\n\\n            temp = month1;\\n            month1 = month2;\\n            month2 = temp;\\n\\n            temp = day1;\\n            day1 = day2;\\n            day2 = temp;\\n        }\\n\\n        // total number of days remaining in start and years\\n        int totalRemainingDaysYear1 = totalDaysInYear(year1,month1,day1);\\n        int totalRemainingDaysYear2 = totalDaysInYear(year2,month2,day2);\\n\\n        // remaining days for the start date is bigger than the reamining days of the end date\\n        // if the year is same deduct the end dates remaining days from start date remaining days;\\n        // otherwise add the start date remaining days and used end date days\\n        if(year1==year2) return totalRemainingDaysYear1 - totalRemainingDaysYear2;\\n        else {\\n            daysBetweenDates+= totalRemainingDaysYear1;\\n            daysBetweenDates+= (isLeapYear(year2) ? 366 : 365) - totalRemainingDaysYear2;\\n        } \\n\\n        // add total days in between start and end year\\n        // check leap year\\n        for(int year = year1+1; year<year2; year++){\\n            if(isLeapYear(year)) daysBetweenDates+=366;\\n            else daysBetweenDates+=365;\\n        }\\n        return daysBetweenDates;    \\n    }\\n\\n    // total reamining days in start or end year date\\n    private int totalDaysInYear (int year, int month, int day){\\n        int days = 0;\\n\\n        // 1st add total days in a year\\n        if(isLeapYear(year)) days = 366;\\n        else days = 365;\\n\\n        // deduct the days till the date month \\n        for(int i =1; i<month; i++){\\n            switch(i){\\n                case 1:\\n                case 3:\\n                case 5:\\n                case 7:\\n                case 8:\\n                case 10:\\n                case 12:\\n                    days -= 31;\\n                    break;\\n                case 2:\\n                    if(isLeapYear(year)) days -= 29;\\n                    else days -= 28;\\n                    break;\\n                default:\\n                    days -= 30;\\n            }\\n        }\\n\\n        // remove the days\\n        days -= day;\\n\\n        // return the days remaining days from that date\\n        return days;\\n    }\\n\\n    //check leap year\\n    private boolean isLeapYear(int year){\\n        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n\\n        // split the date string \\n        String[] d1 = date1.split(\"-\");\\n        String[] d2 = date2.split(\"-\");     \\n\\n        // convert string into integers\\n        int year1 = Integer.parseInt(d1[0]), month1 = Integer.parseInt(d1[1]), day1 = Integer.parseInt(d1[2]);\\n        int year2 = Integer.parseInt(d2[0]), month2 = Integer.parseInt(d2[1]), day2 = Integer.parseInt(d2[2]);\\n\\n        int daysBetweenDates = 0;\\n\\n        // if start date is bigger than end date\\n        // swap the dates\\n        if((year1>year2) || (year1==year2 && month1>month2) || ((year1 == year2) && (month1 == month2) && (day1 > day2))){\\n            int temp = year1;\\n            year1 = year2;\\n            year2 = temp;\\n\\n            temp = month1;\\n            month1 = month2;\\n            month2 = temp;\\n\\n            temp = day1;\\n            day1 = day2;\\n            day2 = temp;\\n        }\\n\\n        // total number of days remaining in start and years\\n        int totalRemainingDaysYear1 = totalDaysInYear(year1,month1,day1);\\n        int totalRemainingDaysYear2 = totalDaysInYear(year2,month2,day2);\\n\\n        // remaining days for the start date is bigger than the reamining days of the end date\\n        // if the year is same deduct the end dates remaining days from start date remaining days;\\n        // otherwise add the start date remaining days and used end date days\\n        if(year1==year2) return totalRemainingDaysYear1 - totalRemainingDaysYear2;\\n        else {\\n            daysBetweenDates+= totalRemainingDaysYear1;\\n            daysBetweenDates+= (isLeapYear(year2) ? 366 : 365) - totalRemainingDaysYear2;\\n        } \\n\\n        // add total days in between start and end year\\n        // check leap year\\n        for(int year = year1+1; year<year2; year++){\\n            if(isLeapYear(year)) daysBetweenDates+=366;\\n            else daysBetweenDates+=365;\\n        }\\n        return daysBetweenDates;    \\n    }\\n\\n    // total reamining days in start or end year date\\n    private int totalDaysInYear (int year, int month, int day){\\n        int days = 0;\\n\\n        // 1st add total days in a year\\n        if(isLeapYear(year)) days = 366;\\n        else days = 365;\\n\\n        // deduct the days till the date month \\n        for(int i =1; i<month; i++){\\n            switch(i){\\n                case 1:\\n                case 3:\\n                case 5:\\n                case 7:\\n                case 8:\\n                case 10:\\n                case 12:\\n                    days -= 31;\\n                    break;\\n                case 2:\\n                    if(isLeapYear(year)) days -= 29;\\n                    else days -= 28;\\n                    break;\\n                default:\\n                    days -= 30;\\n            }\\n        }\\n\\n        // remove the days\\n        days -= day;\\n\\n        // return the days remaining days from that date\\n        return days;\\n    }\\n\\n    //check leap year\\n    private boolean isLeapYear(int year){\\n        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845062,
                "title": "simple-java-count-day-diff-from-1970",
                "content": "```\\nclass Solution {\\n    private static final int[] NON_LEAP_DAYS = {-1,31,28,31,30,31,30,31,31,30,31,30,31};\\n    private static final int[] LEAP_DAYS = {-1,31,29,31,30,31,30,31,31,30,31,30,31};\\n    \\n    private static final int NON_LEAP_DAYS_IN_YEAR = 365;\\n    private static final int LEAP_DAYS_IN_YEAR = 366;\\n    \\n    public int daysBetweenDates(String date1, String date2) {\\n        int days1 = getDaysSince1970(date1);\\n        int days2 = getDaysSince1970(date2);        \\n        return Math.abs(days1 - days2);\\n    }\\n    \\n    int getDaysSince1970(String date){\\n        int year = Integer.parseInt(date.substring(0,4));\\n        int month = Integer.parseInt(date.substring(5,7));\\n        int day = Integer.parseInt(date.substring(8,10));\\n        \\n        int days = 0;\\n        for(int y = 1970; y < year; y++)\\n            days += (isLeapYear(y) ? LEAP_DAYS_IN_YEAR : NON_LEAP_DAYS_IN_YEAR);\\n        \\n        for(int m = 1; m < month; m++){\\n            days += (isLeapYear(year) ? LEAP_DAYS[m] : NON_LEAP_DAYS[m]);\\n        }\\n        \\n        days += day;\\n        return days;\\n    }\\n    \\n    boolean isLeapYear(int year){\\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[] NON_LEAP_DAYS = {-1,31,28,31,30,31,30,31,31,30,31,30,31};\\n    private static final int[] LEAP_DAYS = {-1,31,29,31,30,31,30,31,31,30,31,30,31};\\n    \\n    private static final int NON_LEAP_DAYS_IN_YEAR = 365;\\n    private static final int LEAP_DAYS_IN_YEAR = 366;\\n    \\n    public int daysBetweenDates(String date1, String date2) {\\n        int days1 = getDaysSince1970(date1);\\n        int days2 = getDaysSince1970(date2);        \\n        return Math.abs(days1 - days2);\\n    }\\n    \\n    int getDaysSince1970(String date){\\n        int year = Integer.parseInt(date.substring(0,4));\\n        int month = Integer.parseInt(date.substring(5,7));\\n        int day = Integer.parseInt(date.substring(8,10));\\n        \\n        int days = 0;\\n        for(int y = 1970; y < year; y++)\\n            days += (isLeapYear(y) ? LEAP_DAYS_IN_YEAR : NON_LEAP_DAYS_IN_YEAR);\\n        \\n        for(int m = 1; m < month; m++){\\n            days += (isLeapYear(year) ? LEAP_DAYS[m] : NON_LEAP_DAYS[m]);\\n        }\\n        \\n        days += day;\\n        return days;\\n    }\\n    \\n    boolean isLeapYear(int year){\\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840741,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        leap_years = {x for x in range(1972,2097,4)}\\n        leap_months = {1:31,2:29,3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31}\\n        months = {1:31,2:28,3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31}\\n        dates = sorted([[int(x) for x in date1.split(\\'-\\')],[int(x) for x in date2.split(\\'-\\')]], key=lambda x: (int(x[0]), int(x[1]), int(x[2])))\\n\\n        days = 0\\n        m = leap_months if dates[0][0] in leap_years else months\\n        if dates[0][0]==dates[1][0]:\\n            if dates[0][1]==dates[1][1]:\\n                return dates[1][2]-dates[0][2]\\n            else:\\n                days += m[dates[0][1]]-dates[0][2]\\n\\n                for x in range(dates[0][1],dates[1][1]):\\n                    days += m[x]\\n                \\n                days += dates[1][2]\\n        else:\\n            days += m[dates[0][1]]-dates[0][2]\\n            for x in range(dates[0][1]+1, 13):\\n                days += m[x]\\n            \\n            for x in range(dates[0][0]+1, dates[1][0]):\\n                m = leap_months if x in leap_years else months\\n                days += sum(m.values())\\n            \\n            m = leap_months if dates[1][0] in leap_years else months\\n            for x in range(1, dates[1][1]):\\n                days += m[x]\\n            days += dates[1][2]\\n\\n        return days\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        leap_years = {x for x in range(1972,2097,4)}\\n        leap_months = {1:31,2:29,3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31}\\n        months = {1:31,2:28,3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31}\\n        dates = sorted([[int(x) for x in date1.split(\\'-\\')],[int(x) for x in date2.split(\\'-\\')]], key=lambda x: (int(x[0]), int(x[1]), int(x[2])))\\n\\n        days = 0\\n        m = leap_months if dates[0][0] in leap_years else months\\n        if dates[0][0]==dates[1][0]:\\n            if dates[0][1]==dates[1][1]:\\n                return dates[1][2]-dates[0][2]\\n            else:\\n                days += m[dates[0][1]]-dates[0][2]\\n\\n                for x in range(dates[0][1],dates[1][1]):\\n                    days += m[x]\\n                \\n                days += dates[1][2]\\n        else:\\n            days += m[dates[0][1]]-dates[0][2]\\n            for x in range(dates[0][1]+1, 13):\\n                days += m[x]\\n            \\n            for x in range(dates[0][0]+1, dates[1][0]):\\n                m = leap_months if x in leap_years else months\\n                days += sum(m.values())\\n            \\n            m = leap_months if dates[1][0] in leap_years else months\\n            for x in range(1, dates[1][1]):\\n                days += m[x]\\n            days += dates[1][2]\\n\\n        return days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830318,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isleap(int year){\\n        if(year % 400 == 0)\\n            return true;\\n        if(year % 100 == 0)\\n            return false;\\n        if(year % 4 == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public int daysBetweenDates(String date1, String date2) {\\n        int year1 = 0;\\n        int year2 = 0;\\n        int j = 0;\\n        while(j < 4){\\n            year1 = year1*10 + date1.charAt(j) - \\'0\\';\\n            year2 = year2*10 + date2.charAt(j) - \\'0\\';\\n            j++;\\n        }\\n        int mon1 = 0;\\n        int mon2 = 0;\\n        j++;\\n        while(j < 7){\\n            mon1 = mon1*10 + date1.charAt(j) - \\'0\\';\\n            mon2 = mon2*10 + date2.charAt(j) - \\'0\\';\\n            j++;\\n        }\\n        j++;\\n        int day1 = 0;\\n        int day2 = 0;\\n        while(j < 10){\\n            day1 = day1*10 + date1.charAt(j) - \\'0\\';\\n            day2 = day2*10 + date2.charAt(j) - \\'0\\';\\n            j++;\\n        }\\n        int[]arr1 = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        int[]arr2 = {31,28,31,30,31,30,31,31,30,31,30,31};\\n\\n        if(isleap(year1))\\n            arr1[1] = 29;\\n        if(isleap(year2))\\n            arr2[1] = 29;\\n        for(int i = 1;i < 12;i++){\\n            arr1[i] += arr1[i-1];\\n            arr2[i] += arr2[i-1];\\n        }\\n        int n1 = 0;\\n        int n2 = 0;\\n        for(int i = 1900;i<year1;i++){\\n            if(isleap(i))\\n                n1 += 366;\\n            else\\n                n1 += 365;\\n        }\\n\\n        for(int i = 1900;i<year2;i++){\\n            if(isleap(i))\\n                n2 += 366;\\n            else\\n                n2 += 365;\\n        }\\n        if(mon1 > 1)\\n            n1 += arr1[mon1-2];\\n        if(mon2 > 1)\\n            n2 += arr2[mon2-2];\\n\\n        n1 += day1;\\n        n2 += day2;\\n        return Math.abs(n2 - n1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isleap(int year){\\n        if(year % 400 == 0)\\n            return true;\\n        if(year % 100 == 0)\\n            return false;\\n        if(year % 4 == 0)\\n            return true;\\n        return false;\\n    }\\n\\n    public int daysBetweenDates(String date1, String date2) {\\n        int year1 = 0;\\n        int year2 = 0;\\n        int j = 0;\\n        while(j < 4){\\n            year1 = year1*10 + date1.charAt(j) - \\'0\\';\\n            year2 = year2*10 + date2.charAt(j) - \\'0\\';\\n            j++;\\n        }\\n        int mon1 = 0;\\n        int mon2 = 0;\\n        j++;\\n        while(j < 7){\\n            mon1 = mon1*10 + date1.charAt(j) - \\'0\\';\\n            mon2 = mon2*10 + date2.charAt(j) - \\'0\\';\\n            j++;\\n        }\\n        j++;\\n        int day1 = 0;\\n        int day2 = 0;\\n        while(j < 10){\\n            day1 = day1*10 + date1.charAt(j) - \\'0\\';\\n            day2 = day2*10 + date2.charAt(j) - \\'0\\';\\n            j++;\\n        }\\n        int[]arr1 = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        int[]arr2 = {31,28,31,30,31,30,31,31,30,31,30,31};\\n\\n        if(isleap(year1))\\n            arr1[1] = 29;\\n        if(isleap(year2))\\n            arr2[1] = 29;\\n        for(int i = 1;i < 12;i++){\\n            arr1[i] += arr1[i-1];\\n            arr2[i] += arr2[i-1];\\n        }\\n        int n1 = 0;\\n        int n2 = 0;\\n        for(int i = 1900;i<year1;i++){\\n            if(isleap(i))\\n                n1 += 366;\\n            else\\n                n1 += 365;\\n        }\\n\\n        for(int i = 1900;i<year2;i++){\\n            if(isleap(i))\\n                n2 += 366;\\n            else\\n                n2 += 365;\\n        }\\n        if(mon1 > 1)\\n            n1 += arr1[mon1-2];\\n        if(mon2 > 1)\\n            n2 += arr2[mon2-2];\\n\\n        n1 += day1;\\n        n2 += day2;\\n        return Math.abs(n2 - n1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823148,
                "title": "python-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def daysBetweenDates(self, date1: str, date2: str) -> int:\\n    def is_leap_year(year: int) -> bool:\\n      return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\\n\\n    def get_days(date: str) -> int:\\n      y, m, d = map(int, date.split(\\'-\\'))\\n\\n      days = d + int(is_leap_year(y) and m > 2)\\n      days += sum(365 + int(is_leap_year(y)) for y in range(1971, y))\\n      days += sum([0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:m])\\n\\n      return days\\n\\n    return abs(get_days(date1) - get_days(date2))\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def daysBetweenDates(self, date1: str, date2: str) -> int:\\n    def is_leap_year(year: int) -> bool:\\n      return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\\n\\n    def get_days(date: str) -> int:\\n      y, m, d = map(int, date.split(\\'-\\'))\\n\\n      days = d + int(is_leap_year(y) and m > 2)\\n      days += sum(365 + int(is_leap_year(y)) for y in range(1971, y))\\n      days += sum([0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:m])\\n\\n      return days\\n\\n    return abs(get_days(date1) - get_days(date2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799227,
                "title": "a-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ly(int y){\\n        return ((y%4==0 && y%100!=0) || (y%400==0));\\n    }\\n    int dis(int y , int m , int d){\\n        int ans=0;\\n        vector<int>v{31,28,31,30,31,30,31,31,30,31,30,31};\\n        for(int i=1971; i<y; i++){\\n            ans=ans+365+ly(i);\\n        }\\n        for(int i=1; i<m; i++){\\n            ans=ans+v[i-1];\\n        }\\n        ans=ans+d;\\n        if(m>2 && ly(y)){\\n            ans=ans+1;\\n        }\\n        return ans;\\n    }\\n    int daysBetweenDates(string date1, string date2){\\n        int y1=stoi(date1.substr(0,4));\\n        int m1=stoi(date1.substr(5,2));\\n        int d1=stoi(date1.substr(8,2));\\n        int y2=stoi(date2.substr(0,4));\\n        int m2=stoi(date2.substr(5,2));\\n        int d2=stoi(date2.substr(8,2));\\n        return abs(dis(y1,m1,d1)-dis(y2,m2,d2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ly(int y){\\n        return ((y%4==0 && y%100!=0) || (y%400==0));\\n    }\\n    int dis(int y , int m , int d){\\n        int ans=0;\\n        vector<int>v{31,28,31,30,31,30,31,31,30,31,30,31};\\n        for(int i=1971; i<y; i++){\\n            ans=ans+365+ly(i);\\n        }\\n        for(int i=1; i<m; i++){\\n            ans=ans+v[i-1];\\n        }\\n        ans=ans+d;\\n        if(m>2 && ly(y)){\\n            ans=ans+1;\\n        }\\n        return ans;\\n    }\\n    int daysBetweenDates(string date1, string date2){\\n        int y1=stoi(date1.substr(0,4));\\n        int m1=stoi(date1.substr(5,2));\\n        int d1=stoi(date1.substr(8,2));\\n        int y2=stoi(date2.substr(0,4));\\n        int m2=stoi(date2.substr(5,2));\\n        int d2=stoi(date2.substr(8,2));\\n        return abs(dis(y1,m1,d1)-dis(y2,m2,d2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751020,
                "title": "java-code-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] months={31,28,31,30,31,30,31,31,30,31,30,31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(getdays(date1)-getdays(date2));\\n    }\\n    public int getdays(String dates)\\n    {\\n        String[] date=dates.split(\"-\");\\n        int year=Integer.parseInt(date[0]);\\n        int month=Integer.parseInt(date[1]);\\n        int day=Integer.parseInt(date[2]);\\n        int count=day;\\n        for(int i=1971;i<year;i++)\\n        {\\n          count+=(isleapyear(i))?366:365; \\n        }\\n        for(int i=0;i<month-1;i++)\\n        {\\n            count+=months[i];\\n        }\\n        if(month>2 && isleapyear(year))\\n        {\\n            count+=1;\\n        }\\n        return count;\\n    }\\n    public boolean isleapyear(Integer year)\\n    {\\n        return year%4==0 &&(year%100!=0 ||year%400==0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] months={31,28,31,30,31,30,31,31,30,31,30,31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(getdays(date1)-getdays(date2));\\n    }\\n    public int getdays(String dates)\\n    {\\n        String[] date=dates.split(\"-\");\\n        int year=Integer.parseInt(date[0]);\\n        int month=Integer.parseInt(date[1]);\\n        int day=Integer.parseInt(date[2]);\\n        int count=day;\\n        for(int i=1971;i<year;i++)\\n        {\\n          count+=(isleapyear(i))?366:365; \\n        }\\n        for(int i=0;i<month-1;i++)\\n        {\\n            count+=months[i];\\n        }\\n        if(month>2 && isleapyear(year))\\n        {\\n            count+=1;\\n        }\\n        return count;\\n    }\\n    public boolean isleapyear(Integer year)\\n    {\\n        return year%4==0 &&(year%100!=0 ||year%400==0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747926,
                "title": "beats-100-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool leapYear(int y){\\n        if(y%400==0 || (y%4==0&&y%100!=0)) return true;\\n        return false;\\n    }\\n    int daysFrom1971(int y, int m, int d){\\n        cout << y << \" \" << m << \" \" << d << endl;\\n        int ans = 0;\\n        int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i = 1971; i < y; i++){\\n            ans = ans + 365 + leapYear(i);\\n        }\\n        for(int i = 1; i < m; i++){\\n            ans = ans + month[i - 1];\\n        }\\n        ans += d;\\n        if(m > 2 && leapYear(y)) ans++;\\n        return ans;\\n    }\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        int y1 = stoi(date1.substr(0, 4)), m1 = stoi(date1.substr(5, 2)), d1 = stoi(date1.substr(8, 2));\\n        int y2 = stoi(date2.substr(0, 4)), m2 = stoi(date2.substr(5, 2)), d2 = stoi(date2.substr(8, 2));\\n        return abs(daysFrom1971(y1, m1, d1) - daysFrom1971(y2, m2, d2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool leapYear(int y){\\n        if(y%400==0 || (y%4==0&&y%100!=0)) return true;\\n        return false;\\n    }\\n    int daysFrom1971(int y, int m, int d){\\n        cout << y << \" \" << m << \" \" << d << endl;\\n        int ans = 0;\\n        int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i = 1971; i < y; i++){\\n            ans = ans + 365 + leapYear(i);\\n        }\\n        for(int i = 1; i < m; i++){\\n            ans = ans + month[i - 1];\\n        }\\n        ans += d;\\n        if(m > 2 && leapYear(y)) ans++;\\n        return ans;\\n    }\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        int y1 = stoi(date1.substr(0, 4)), m1 = stoi(date1.substr(5, 2)), d1 = stoi(date1.substr(8, 2));\\n        int y2 = stoi(date2.substr(0, 4)), m2 = stoi(date2.substr(5, 2)), d2 = stoi(date2.substr(8, 2));\\n        return abs(daysFrom1971(y1, m1, d1) - daysFrom1971(y2, m2, d2));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3747925,
                "title": "beats-100-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool leapYear(int y){\\n        if(y%400==0 || (y%4==0&&y%100!=0)) return true;\\n        return false;\\n    }\\n    int daysFrom1971(int y, int m, int d){\\n        cout << y << \" \" << m << \" \" << d << endl;\\n        int ans = 0;\\n        int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i = 1971; i < y; i++){\\n            ans = ans + 365 + leapYear(i);\\n        }\\n        for(int i = 1; i < m; i++){\\n            ans = ans + month[i - 1];\\n        }\\n        ans += d;\\n        if(m > 2 && leapYear(y)) ans++;\\n        return ans;\\n    }\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        int y1 = stoi(date1.substr(0, 4)), m1 = stoi(date1.substr(5, 2)), d1 = stoi(date1.substr(8, 2));\\n        int y2 = stoi(date2.substr(0, 4)), m2 = stoi(date2.substr(5, 2)), d2 = stoi(date2.substr(8, 2));\\n        return abs(daysFrom1971(y1, m1, d1) - daysFrom1971(y2, m2, d2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool leapYear(int y){\\n        if(y%400==0 || (y%4==0&&y%100!=0)) return true;\\n        return false;\\n    }\\n    int daysFrom1971(int y, int m, int d){\\n        cout << y << \" \" << m << \" \" << d << endl;\\n        int ans = 0;\\n        int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i = 1971; i < y; i++){\\n            ans = ans + 365 + leapYear(i);\\n        }\\n        for(int i = 1; i < m; i++){\\n            ans = ans + month[i - 1];\\n        }\\n        ans += d;\\n        if(m > 2 && leapYear(y)) ans++;\\n        return ans;\\n    }\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        int y1 = stoi(date1.substr(0, 4)), m1 = stoi(date1.substr(5, 2)), d1 = stoi(date1.substr(8, 2));\\n        int y2 = stoi(date2.substr(0, 4)), m2 = stoi(date2.substr(5, 2)), d2 = stoi(date2.substr(8, 2));\\n        return abs(daysFrom1971(y1, m1, d1) - daysFrom1971(y2, m2, d2));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3736001,
                "title": "number-of-days-between-two-dates-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse the biblio datetime of python\\n\\n# Code\\n```\\nimport datetime\\n\\nclass Solution(object):\\n    def daysBetweenDates(self, date1, date2):\\n        \"\"\"\\n        :type date1: str\\n        :type date2: str\\n        :rtype: int\\n        \"\"\"\\n        x = datetime.datetime(int(date1[:4]), int(date1[5:7]), int(date1[8:]))\\n        y = datetime.datetime(int(date2[:4]), int(date2[5:7]), int(date2[8:]))\\n        return abs((y - x).days)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport datetime\\n\\nclass Solution(object):\\n    def daysBetweenDates(self, date1, date2):\\n        \"\"\"\\n        :type date1: str\\n        :type date2: str\\n        :rtype: int\\n        \"\"\"\\n        x = datetime.datetime(int(date1[:4]), int(date1[5:7]), int(date1[8:]))\\n        y = datetime.datetime(int(date2[:4]), int(date2[5:7]), int(date2[8:]))\\n        return abs((y - x).days)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734153,
                "title": "java-api",
                "content": "\\timport java.time.LocalDate;\\n\\timport java.time.temporal.ChronoUnit;\\n\\n\\tclass Solution {\\n\\t\\tpublic int daysBetweenDates(String date1, String date2) {\\n\\t\\t\\tLocalDate localDate1 = LocalDate.parse(date1);\\n\\t\\t\\tLocalDate localDate2 = LocalDate.parse(date2);\\n\\n\\t\\t\\treturn Math.abs((int) ChronoUnit.DAYS.between(localDate2, localDate1));\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int daysBetweenDates(String date1, String date2) {\\n\\t\\t\\tLocalDate localDate1 = LocalDate.parse(date1);\\n\\t\\t\\tLocalDate localDate2 = LocalDate.parse(date2);\\n\\n\\t\\t\\treturn Math.abs((int) ChronoUnit.DAYS.between(localDate2, localDate1));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3731697,
                "title": "easy-solutions-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        int month[]={0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int y1=Integer.parseInt(date1.substring(0,4));\\n        int m1=Integer.parseInt(date1.substring(5,7));\\n        int d1=Integer.parseInt(date1.substring(8));\\n        int y2=Integer.parseInt(date2.substring(0,4));\\n        int m2=Integer.parseInt(date2.substring(5,7));\\n        int d2=Integer.parseInt(date2.substring(8));\\n        int day1 = d1 + month[m1 - 1] + ((m1 > 2 && ((y1 % 100 != 0 && y1 % 4 == 0) || y1 % 400 == 0)) ? 1 : 0);\\n        int day2 = d2 + month[m2 - 1] + ((m2 > 2 && ((y2 % 100 != 0 && y2 % 4 == 0) || y2 % 400 == 0)) ? 1 : 0);\\n        if(y1>y2){\\n            for(int i=y2;i<y1;i++){day1+=((i % 100 != 0 && i % 4 == 0) || i % 400 == 0)?366:365;}\\n        }else{\\n            for(int i=y1;i<y2;i++){day2+=((i % 100 != 0 && i % 4 == 0) || i % 400 == 0)?366:365;}\\n        }\\n        return Math.abs(day2-day1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        int month[]={0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int y1=Integer.parseInt(date1.substring(0,4));\\n        int m1=Integer.parseInt(date1.substring(5,7));\\n        int d1=Integer.parseInt(date1.substring(8));\\n        int y2=Integer.parseInt(date2.substring(0,4));\\n        int m2=Integer.parseInt(date2.substring(5,7));\\n        int d2=Integer.parseInt(date2.substring(8));\\n        int day1 = d1 + month[m1 - 1] + ((m1 > 2 && ((y1 % 100 != 0 && y1 % 4 == 0) || y1 % 400 == 0)) ? 1 : 0);\\n        int day2 = d2 + month[m2 - 1] + ((m2 > 2 && ((y2 % 100 != 0 && y2 % 4 == 0) || y2 % 400 == 0)) ? 1 : 0);\\n        if(y1>y2){\\n            for(int i=y2;i<y1;i++){day1+=((i % 100 != 0 && i % 4 == 0) || i % 400 == 0)?366:365;}\\n        }else{\\n            for(int i=y1;i<y2;i++){day2+=((i % 100 != 0 && i % 4 == 0) || i % 400 == 0)?366:365;}\\n        }\\n        return Math.abs(day2-day1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680762,
                "title": "my-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nInstead of counting up day by day and adding up the days, we use a bit of clever but simple maths.\\n\\nAnswer: Days between the years + Days of the target year - Days of the source year.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst we make comparision of the 2 dates to make sure our target date comes after the source date.\\n\\nIf we simply ignore the months and dates, only looking at year intervals, we can simply calculate the days between the years, and adding up the leap year days. This part is $O(Y_t - Y_S)$ where $Y_t$ is the target year, and $Y_s$ is the source year.\\n\\nThen we look at the months and days of the source and target year.\\nWe check if the years are leap year (because it would change February to 29 days), then we just add up the days in the months with a loop.\\n\\nSo it for both source and target dates...\\n\\nThen use the equation in the **Intuition** section.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(Y_t - Y_s) + O(M)$$\\n\\nwhere $M$ is $12$ (because there are 12 months)\\n\\nBut since $M$ is constant\\n\\nSo the final complexity is: $$O(Y_t - Y_s)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(1)$$\\n\\nThere\\'s the hashmap containing the days within a  month.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        map<int, int> dinm = {\\n            {1, 31},\\n            {2, 28},\\n            {3, 31},\\n            {4, 30},\\n            {5, 31},\\n            {6, 30},\\n            {7, 31},\\n            {8, 31},\\n            {9, 30},\\n            {10, 31},\\n            {11, 30},\\n            {12, 31},\\n            {0,0}\\n        };\\n        int year = atoi(date2.substr(0,4).c_str());\\n        int month = atoi(date2.substr(5, 2).c_str());\\n        int day = atoi(date2.substr(8,2).c_str());\\n        int tyear = atoi(date1.substr(0,4).c_str());\\n        int tmonth = atoi(date1.substr(5, 2).c_str());\\n        int tday = atoi(date1.substr(8,2).c_str());\\n\\n        if (tyear < year) {\\n            int ty = tyear;\\n            int tm = tmonth;\\n            int td = tday;\\n            tyear = year;\\n            tmonth = month;\\n            tday = day;\\n            year = ty;\\n            month = tm;\\n            day = td;\\n        } else if (tyear == year) {\\n            if (tmonth < month) {\\n                int tm = tmonth;\\n                int td = tday;\\n                tmonth = month;\\n                tday = day;\\n                month = tm;\\n                day = td;\\n            } else if (tmonth == month) {\\n                if (tday < day) {\\n                    int td = tday;\\n                    tday = day;\\n                    day = td;\\n                }\\n            }\\n        }\\n\\n        // assume no month and no day\\n        // just year to year\\n\\n        int leap_years = 0;\\n        for (int i = year; i < tyear; i++) {\\n            if ((i % 4 == 0 && i % 100 != 0) || (i % 400 == 0)) {\\n                leap_years++;\\n            }\\n        }\\n        int daysinyeartoyear = 365 * (tyear - year) + leap_years;\\n\\n        // now do months\\n        bool tisLeap = false; \\n        int targetmonthdays = 0;\\n        if ((tyear % 4 == 0 && tyear % 100 != 0) || (tyear % 400 == 0)) {\\n            tisLeap = true;\\n            dinm[2] = 29;\\n        }\\n        for (int i = 1; i < tmonth; i++) {\\n            targetmonthdays += dinm[i];\\n        }\\n        int daysintargetyear = targetmonthdays + tday;\\n\\n        dinm[2] = 28; // reset\\n\\n        bool sisLeap = false;\\n        int sourcemonthdays = 0;\\n        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\\n            sisLeap = true;\\n            dinm[2] = 29;\\n        }\\n        for (int i = 1; i < month; i++) {\\n            sourcemonthdays += dinm[i];\\n        }\\n        int daysinsourceyear = sourcemonthdays + day;\\n\\n        return daysinyeartoyear + daysintargetyear - daysinsourceyear;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int daysBetweenDates(string date1, string date2) {\\n        map<int, int> dinm = {\\n            {1, 31},\\n            {2, 28},\\n            {3, 31},\\n            {4, 30},\\n            {5, 31},\\n            {6, 30},\\n            {7, 31},\\n            {8, 31},\\n            {9, 30},\\n            {10, 31},\\n            {11, 30},\\n            {12, 31},\\n            {0,0}\\n        };\\n        int year = atoi(date2.substr(0,4).c_str());\\n        int month = atoi(date2.substr(5, 2).c_str());\\n        int day = atoi(date2.substr(8,2).c_str());\\n        int tyear = atoi(date1.substr(0,4).c_str());\\n        int tmonth = atoi(date1.substr(5, 2).c_str());\\n        int tday = atoi(date1.substr(8,2).c_str());\\n\\n        if (tyear < year) {\\n            int ty = tyear;\\n            int tm = tmonth;\\n            int td = tday;\\n            tyear = year;\\n            tmonth = month;\\n            tday = day;\\n            year = ty;\\n            month = tm;\\n            day = td;\\n        } else if (tyear == year) {\\n            if (tmonth < month) {\\n                int tm = tmonth;\\n                int td = tday;\\n                tmonth = month;\\n                tday = day;\\n                month = tm;\\n                day = td;\\n            } else if (tmonth == month) {\\n                if (tday < day) {\\n                    int td = tday;\\n                    tday = day;\\n                    day = td;\\n                }\\n            }\\n        }\\n\\n        // assume no month and no day\\n        // just year to year\\n\\n        int leap_years = 0;\\n        for (int i = year; i < tyear; i++) {\\n            if ((i % 4 == 0 && i % 100 != 0) || (i % 400 == 0)) {\\n                leap_years++;\\n            }\\n        }\\n        int daysinyeartoyear = 365 * (tyear - year) + leap_years;\\n\\n        // now do months\\n        bool tisLeap = false; \\n        int targetmonthdays = 0;\\n        if ((tyear % 4 == 0 && tyear % 100 != 0) || (tyear % 400 == 0)) {\\n            tisLeap = true;\\n            dinm[2] = 29;\\n        }\\n        for (int i = 1; i < tmonth; i++) {\\n            targetmonthdays += dinm[i];\\n        }\\n        int daysintargetyear = targetmonthdays + tday;\\n\\n        dinm[2] = 28; // reset\\n\\n        bool sisLeap = false;\\n        int sourcemonthdays = 0;\\n        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\\n            sisLeap = true;\\n            dinm[2] = 29;\\n        }\\n        for (int i = 1; i < month; i++) {\\n            sourcemonthdays += dinm[i];\\n        }\\n        int daysinsourceyear = sourcemonthdays + day;\\n\\n        return daysinyeartoyear + daysintargetyear - daysinsourceyear;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674028,
                "title": "js-1-line",
                "content": "\\n```\\n\\nconst daysBetweenDates = (date1, date2) =>\\n  Math.abs(Date.parse(date1) - Date.parse(date2)) / 86400000;\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst daysBetweenDates = (date1, date2) =>\\n  Math.abs(Date.parse(date1) - Date.parse(date2)) / 86400000;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671956,
                "title": "python3-datetime-date",
                "content": "# Code\\n```\\nfrom datetime import date\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        d0 = date(int(date1.split(\\'-\\')[0]), int(date1.split(\\'-\\')[1]), int(date1.split(\\'-\\')[2]))\\n        d1 = date(int(date2.split(\\'-\\')[0]), int(date2.split(\\'-\\')[1]), int(date2.split(\\'-\\')[2]))\\n        diff = d1 - d0\\n        return abs(diff.days)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom datetime import date\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        d0 = date(int(date1.split(\\'-\\')[0]), int(date1.split(\\'-\\')[1]), int(date1.split(\\'-\\')[2]))\\n        d1 = date(int(date2.split(\\'-\\')[0]), int(date2.split(\\'-\\')[1]), int(date2.split(\\'-\\')[2]))\\n        diff = d1 - d0\\n        return abs(diff.days)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661621,
                "title": "easy-js-solution-with-date-obj",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nvar daysBetweenDates = function(date1, date2) {\\n  var start = new Date(date1);\\n  var end = new Date(date2);\\n  var timeDifference = end.getTime() - start.getTime();\\n  var daysDifference = Math.floor(timeDifference / (1000 * 3600 * 24));\\n  return Math.abs(daysDifference);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} date1\\n * @param {string} date2\\n * @return {number}\\n */\\nvar daysBetweenDates = function(date1, date2) {\\n  var start = new Date(date1);\\n  var end = new Date(date2);\\n  var timeDifference = end.getTime() - start.getTime();\\n  var daysDifference = Math.floor(timeDifference / (1000 * 3600 * 24));\\n  return Math.abs(daysDifference);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3648251,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  static constexpr int ymd = 3;\\n  \\n  using ymd_t = array<int, ymd>;\\n  \\n public:\\n  int daysBetweenDates(const string &date1, const string &date2) {\\n    return abs(days(get_ymd(date1)) - days(get_ymd(date2)));\\n  }\\n  \\n private:\\n  ymd_t get_ymd(const string &date) {\\n    constexpr int start_and_lengths[][2] = {{0, 4}, {5, 2}, {8, 2}};\\n    ymd_t ret;\\n    for (int i = 0; i < ymd; ++i) {\\n      const auto [start, length] = start_and_lengths[i];\\n      ret[i] = stoi(date.substr(start, length));\\n    }\\n    return ret;\\n  }\\n  \\n  int days(const ymd_t &ymd) {\\n    constexpr int base_year = 1971;\\n    constexpr int days_per_year = 365;\\n    constexpr int days_non_leap[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    constexpr int days_leap[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    auto leap_year = [](const int year) -> bool {\\n      return year % 400 == 0 || (year % 4 == 0 && year % 100 != 0);\\n    };\\n    \\n    const auto [year, month, day] = ymd;\\n    int ret = days_per_year * (year - base_year) + (leap_years(year - 1) - leap_years(base_year - 1));\\n    \\n    const auto days_per_months = leap_year(year) ? days_leap : days_non_leap;\\n    for (int m = 1; m < month; ++m) {\\n      ret += days_per_months[m - 1];\\n    }\\n    ret += day;\\n    \\n    return ret;\\n  }\\n  \\n  int leap_years(const int year) {\\n    return (year / 4) - (year / 100) + (year / 400);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  static constexpr int ymd = 3;\\n  \\n  using ymd_t = array<int, ymd>;\\n  \\n public:\\n  int daysBetweenDates(const string &date1, const string &date2) {\\n    return abs(days(get_ymd(date1)) - days(get_ymd(date2)));\\n  }\\n  \\n private:\\n  ymd_t get_ymd(const string &date) {\\n    constexpr int start_and_lengths[][2] = {{0, 4}, {5, 2}, {8, 2}};\\n    ymd_t ret;\\n    for (int i = 0; i < ymd; ++i) {\\n      const auto [start, length] = start_and_lengths[i];\\n      ret[i] = stoi(date.substr(start, length));\\n    }\\n    return ret;\\n  }\\n  \\n  int days(const ymd_t &ymd) {\\n    constexpr int base_year = 1971;\\n    constexpr int days_per_year = 365;\\n    constexpr int days_non_leap[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    constexpr int days_leap[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    auto leap_year = [](const int year) -> bool {\\n      return year % 400 == 0 || (year % 4 == 0 && year % 100 != 0);\\n    };\\n    \\n    const auto [year, month, day] = ymd;\\n    int ret = days_per_year * (year - base_year) + (leap_years(year - 1) - leap_years(base_year - 1));\\n    \\n    const auto days_per_months = leap_year(year) ? days_leap : days_non_leap;\\n    for (int m = 1; m < month; ++m) {\\n      ret += days_per_months[m - 1];\\n    }\\n    ret += day;\\n    \\n    return ret;\\n  }\\n  \\n  int leap_years(const int year) {\\n    return (year / 4) - (year / 100) + (year / 400);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630480,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {        \\n        return Math.abs(days(date2)-days(date1));\\n    }\\n    private int days(String date){\\n        int d=(int)(date.charAt(8)-\\'0\\')*10+(int)(date.charAt(9)-\\'0\\');\\n        int m=(int)(date.charAt(5)-\\'0\\')*10+(int)(date.charAt(6)-\\'0\\');\\n        int y=(int)(date.charAt(0)-\\'0\\')*1000+(int)(date.charAt(1)-\\'0\\')*100+(int)(date.charAt(2)-\\'0\\')*10+(int)(date.charAt(3)-\\'0\\');\\n        int months[]={0,31,28,31,30,31,30,31,31,30,31,30,31};\\n        for(int i=0;i<m;i++)\\n            d+=months[i];\\n        for(int i=1971;i<y;i++){\\n            if(i%4==0)\\n                d+=366;\\n            else\\n                d+=365;\\n        }\\n        if(y%4==0&&m>2&&y!=2100)\\n            d+=1;\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {        \\n        return Math.abs(days(date2)-days(date1));\\n    }\\n    private int days(String date){\\n        int d=(int)(date.charAt(8)-\\'0\\')*10+(int)(date.charAt(9)-\\'0\\');\\n        int m=(int)(date.charAt(5)-\\'0\\')*10+(int)(date.charAt(6)-\\'0\\');\\n        int y=(int)(date.charAt(0)-\\'0\\')*1000+(int)(date.charAt(1)-\\'0\\')*100+(int)(date.charAt(2)-\\'0\\')*10+(int)(date.charAt(3)-\\'0\\');\\n        int months[]={0,31,28,31,30,31,30,31,31,30,31,30,31};\\n        for(int i=0;i<m;i++)\\n            d+=months[i];\\n        for(int i=1971;i<y;i++){\\n            if(i%4==0)\\n                d+=366;\\n            else\\n                d+=365;\\n        }\\n        if(y%4==0&&m>2&&y!=2100)\\n            d+=1;\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628547,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs((datetime.datetime.strptime(date2, \\'%Y-%m-%d\\') - datetime.datetime.strptime(date1, \\'%Y-%m-%d\\')).days)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        return abs((datetime.datetime.strptime(date2, \\'%Y-%m-%d\\') - datetime.datetime.strptime(date1, \\'%Y-%m-%d\\')).days)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627365,
                "title": "count-days-till-the-earliest-previous-year-between-the-two-days",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of counting days till 1971 it is enought to calculate the most recent previous year for both dates and just count days till then\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def parseDates(self, date:str) -> [int]:\\n        return [int(x) for x in date.split(\"-\")]\\n\\n    @cache\\n    def is_leap_year(self, year):\\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\\n    \\n    @cache\\n    def months_map(self, year) -> dict:\\n        months_map = {\\n            1: 31, \\n            2: 29 if self.is_leap_year(year) else 28,\\n            3: 31,\\n            4: 30,\\n            5: 31,\\n            6: 30,\\n            7: 31,\\n            8: 31,\\n            9: 30,\\n            10: 31,\\n            11: 30,\\n            12: 31\\n        }\\n        return months_map\\n\\n    def numberOfDaysTillMinYear(self, min_year: int, date_parts: [int])-> int:\\n        year, month, day = date_parts\\n        days = 0\\n        for m_ in range(1, month):\\n            days += self.months_map(year)[m_]\\n        days += min(day, self.months_map(year)[month])\\n        year -= 1\\n        while year > min_year:\\n            days += 366 if self.is_leap_year(year) else 365\\n            year-=1\\n        return days\\n\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        parsed_date1 = self.parseDates(date1)\\n        parsed_date2 = self.parseDates(date2)\\n        \\n        prev_year1 = parsed_date1[0] - 1\\n        prev_year2 = parsed_date2[0] - 1\\n        min_year = min(prev_year1, prev_year2)\\n\\n        days1 = self.numberOfDaysTillMinYear(min_year, parsed_date1)\\n        days2 = self.numberOfDaysTillMinYear(min_year, parsed_date2) \\n        return abs(days2 - days1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseDates(self, date:str) -> [int]:\\n        return [int(x) for x in date.split(\"-\")]\\n\\n    @cache\\n    def is_leap_year(self, year):\\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\\n    \\n    @cache\\n    def months_map(self, year) -> dict:\\n        months_map = {\\n            1: 31, \\n            2: 29 if self.is_leap_year(year) else 28,\\n            3: 31,\\n            4: 30,\\n            5: 31,\\n            6: 30,\\n            7: 31,\\n            8: 31,\\n            9: 30,\\n            10: 31,\\n            11: 30,\\n            12: 31\\n        }\\n        return months_map\\n\\n    def numberOfDaysTillMinYear(self, min_year: int, date_parts: [int])-> int:\\n        year, month, day = date_parts\\n        days = 0\\n        for m_ in range(1, month):\\n            days += self.months_map(year)[m_]\\n        days += min(day, self.months_map(year)[month])\\n        year -= 1\\n        while year > min_year:\\n            days += 366 if self.is_leap_year(year) else 365\\n            year-=1\\n        return days\\n\\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        parsed_date1 = self.parseDates(date1)\\n        parsed_date2 = self.parseDates(date2)\\n        \\n        prev_year1 = parsed_date1[0] - 1\\n        prev_year2 = parsed_date2[0] - 1\\n        min_year = min(prev_year1, prev_year2)\\n\\n        days1 = self.numberOfDaysTillMinYear(min_year, parsed_date1)\\n        days2 = self.numberOfDaysTillMinYear(min_year, parsed_date2) \\n        return abs(days2 - days1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614711,
                "title": "clean-java-code-explained",
                "content": "# Intuition\\nFind how much day has passed from 1971-1-1 for the two year and get the absolute difference.\\n\\n# Approach\\nuse int[] day to avoid the cubersome if else.\\n\\n# Complexity\\n- Time complexity:\\nO(1) from 1971 to 2100.\\n\\n- Space complexity:\\nO(1) no extra space needed.\\n\\n# Code\\n```\\nclass Solution {\\n    int[] day = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(find(date2) - find(date1));\\n    }\\n\\n    public int find(String date) {\\n        String[] arr = date.split(\"-\");\\n        int res = 0;\\n        for (int i = 1971;i < Integer.parseInt(arr[0]);i++)\\n            res += leap(i) ? 366 : 365;\\n        for (int i = 1;i < Integer.parseInt(arr[1]);i++) {\\n            res += day[i];\\n            if (leap(Integer.parseInt(arr[0])) && i == 2)\\n                res++;\\n        }\\n        return res + Integer.parseInt(arr[2]);\\n    }\\n\\n    public boolean leap(int n) {\\n        if (n % 4 == 0 && n % 100 != 0)\\n            return true;\\n        return n % 400 == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] day = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int daysBetweenDates(String date1, String date2) {\\n        return Math.abs(find(date2) - find(date1));\\n    }\\n\\n    public int find(String date) {\\n        String[] arr = date.split(\"-\");\\n        int res = 0;\\n        for (int i = 1971;i < Integer.parseInt(arr[0]);i++)\\n            res += leap(i) ? 366 : 365;\\n        for (int i = 1;i < Integer.parseInt(arr[1]);i++) {\\n            res += day[i];\\n            if (leap(Integer.parseInt(arr[0])) && i == 2)\\n                res++;\\n        }\\n        return res + Integer.parseInt(arr[2]);\\n    }\\n\\n    public boolean leap(int n) {\\n        if (n % 4 == 0 && n % 100 != 0)\\n            return true;\\n        return n % 400 == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611219,
                "title": "java-easiest-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        LocalDate d1 = LocalDate.parse(date1);\\n        LocalDate d2 = LocalDate.parse(date2);\\n        \\n        long days = Math.abs(ChronoUnit.DAYS.between(d1, d2));\\n        \\n        return (int) days;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        LocalDate d1 = LocalDate.parse(date1);\\n        LocalDate d2 = LocalDate.parse(date2);\\n        \\n        long days = Math.abs(ChronoUnit.DAYS.between(d1, d2));\\n        \\n        return (int) days;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1788085,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "What is the point of such a question?"
                    },
                    {
                        "username": "iloabachie",
                        "content": "I don\\'t think it is totally pointless."
                    },
                    {
                        "username": "RB213",
                        "content": "Reject candidates who are not lc monkeys"
                    },
                    {
                        "username": "shailymittal",
                        "content": "Here is a trick with the question. 2100 will not be a leap year."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tdef isLeap(year):\\n\\t\\treturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0\\n\\tdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\tif date1 > date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\ty1, m1, d1 = map(int, date1.split(\"-\"))\\n\\ty2, m2, d2 = map(int, date2.split(\"-\"))\\n\\tresult = 0\\n\\tfor year in range(y1, y2):\\n\\t\\tresult += 365 + isLeap(year)\\n\\tdays[1] = 29 if isLeap(y1) else 28\\n\\tresult -= sum(days[ : m1 - 1]) + d1\\n\\tdays[1] = 29 if isLeap(y2) else 28\\n\\tresult += sum(days[ : m2 - 1]) + d2\\n\\treturn result"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar daysBetweenDates = function(date1, date2) {\\n\\t\\tconst getDays = (date) => new Date(date) / 1000 / 60 / 60 / 24\\n\\n\\t\\treturn Math.abs(getDays(date1) - getDays(date2))\\n\\t};"
                    },
                    {
                        "username": "yukimimi",
                        "content": "func daysBetweenDates(date1 string, date2 string) int {\\n\\ttime1, _ := time.Parse(\"2006-01-02\", date1)\\n\\ttime2, _ := time.Parse(\"2006-01-02\", date2)\\n\\treturn int(math.Abs(time2.Sub(time1).Hours() / 24.0))\\n}\\n"
                    },
                    {
                        "username": "sebnyberg",
                        "content": "Not great for performance to swap from int64 to float back to int (see time.Time internals).\n\n```go\nfunc daysBetweenDates(date1 string, date2 string) int {\n    d1, _ := time.Parse(\"2006-01-02\", date1)\n    d2, _ := time.Parse(\"2006-01-02\", date2)\n    a, b := d1.Unix(), d2.Unix()\n    if a > b {\n        return int((a - b)/(24*60*60))\n    }\n    return int((b - a)/(24*60*60))\n}\n```"
                    },
                    {
                        "username": "RupalRadadia26",
                        "content": "return Math.abs(new Date(date2).getTime() - new Date(date1).getTime())/(1000*60*60*24)"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "If such questions are asked in interviews then its clear that the interviewer is not interested in hiring you"
                    },
                    {
                        "username": "Anu2k23",
                        "content": "Date-1:2020-01-15 and Date-2: 2019-12-31 the total day difference between two dates is actually 15 but here test output is 381 which is wrong."
                    }
                ]
            },
            {
                "id": 1574078,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "What is the point of such a question?"
                    },
                    {
                        "username": "iloabachie",
                        "content": "I don\\'t think it is totally pointless."
                    },
                    {
                        "username": "RB213",
                        "content": "Reject candidates who are not lc monkeys"
                    },
                    {
                        "username": "shailymittal",
                        "content": "Here is a trick with the question. 2100 will not be a leap year."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tdef isLeap(year):\\n\\t\\treturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0\\n\\tdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\tif date1 > date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\ty1, m1, d1 = map(int, date1.split(\"-\"))\\n\\ty2, m2, d2 = map(int, date2.split(\"-\"))\\n\\tresult = 0\\n\\tfor year in range(y1, y2):\\n\\t\\tresult += 365 + isLeap(year)\\n\\tdays[1] = 29 if isLeap(y1) else 28\\n\\tresult -= sum(days[ : m1 - 1]) + d1\\n\\tdays[1] = 29 if isLeap(y2) else 28\\n\\tresult += sum(days[ : m2 - 1]) + d2\\n\\treturn result"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar daysBetweenDates = function(date1, date2) {\\n\\t\\tconst getDays = (date) => new Date(date) / 1000 / 60 / 60 / 24\\n\\n\\t\\treturn Math.abs(getDays(date1) - getDays(date2))\\n\\t};"
                    },
                    {
                        "username": "yukimimi",
                        "content": "func daysBetweenDates(date1 string, date2 string) int {\\n\\ttime1, _ := time.Parse(\"2006-01-02\", date1)\\n\\ttime2, _ := time.Parse(\"2006-01-02\", date2)\\n\\treturn int(math.Abs(time2.Sub(time1).Hours() / 24.0))\\n}\\n"
                    },
                    {
                        "username": "sebnyberg",
                        "content": "Not great for performance to swap from int64 to float back to int (see time.Time internals).\n\n```go\nfunc daysBetweenDates(date1 string, date2 string) int {\n    d1, _ := time.Parse(\"2006-01-02\", date1)\n    d2, _ := time.Parse(\"2006-01-02\", date2)\n    a, b := d1.Unix(), d2.Unix()\n    if a > b {\n        return int((a - b)/(24*60*60))\n    }\n    return int((b - a)/(24*60*60))\n}\n```"
                    },
                    {
                        "username": "RupalRadadia26",
                        "content": "return Math.abs(new Date(date2).getTime() - new Date(date1).getTime())/(1000*60*60*24)"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "If such questions are asked in interviews then its clear that the interviewer is not interested in hiring you"
                    },
                    {
                        "username": "Anu2k23",
                        "content": "Date-1:2020-01-15 and Date-2: 2019-12-31 the total day difference between two dates is actually 15 but here test output is 381 which is wrong."
                    }
                ]
            },
            {
                "id": 1574867,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "What is the point of such a question?"
                    },
                    {
                        "username": "iloabachie",
                        "content": "I don\\'t think it is totally pointless."
                    },
                    {
                        "username": "RB213",
                        "content": "Reject candidates who are not lc monkeys"
                    },
                    {
                        "username": "shailymittal",
                        "content": "Here is a trick with the question. 2100 will not be a leap year."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tdef isLeap(year):\\n\\t\\treturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0\\n\\tdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\tif date1 > date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\ty1, m1, d1 = map(int, date1.split(\"-\"))\\n\\ty2, m2, d2 = map(int, date2.split(\"-\"))\\n\\tresult = 0\\n\\tfor year in range(y1, y2):\\n\\t\\tresult += 365 + isLeap(year)\\n\\tdays[1] = 29 if isLeap(y1) else 28\\n\\tresult -= sum(days[ : m1 - 1]) + d1\\n\\tdays[1] = 29 if isLeap(y2) else 28\\n\\tresult += sum(days[ : m2 - 1]) + d2\\n\\treturn result"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar daysBetweenDates = function(date1, date2) {\\n\\t\\tconst getDays = (date) => new Date(date) / 1000 / 60 / 60 / 24\\n\\n\\t\\treturn Math.abs(getDays(date1) - getDays(date2))\\n\\t};"
                    },
                    {
                        "username": "yukimimi",
                        "content": "func daysBetweenDates(date1 string, date2 string) int {\\n\\ttime1, _ := time.Parse(\"2006-01-02\", date1)\\n\\ttime2, _ := time.Parse(\"2006-01-02\", date2)\\n\\treturn int(math.Abs(time2.Sub(time1).Hours() / 24.0))\\n}\\n"
                    },
                    {
                        "username": "sebnyberg",
                        "content": "Not great for performance to swap from int64 to float back to int (see time.Time internals).\n\n```go\nfunc daysBetweenDates(date1 string, date2 string) int {\n    d1, _ := time.Parse(\"2006-01-02\", date1)\n    d2, _ := time.Parse(\"2006-01-02\", date2)\n    a, b := d1.Unix(), d2.Unix()\n    if a > b {\n        return int((a - b)/(24*60*60))\n    }\n    return int((b - a)/(24*60*60))\n}\n```"
                    },
                    {
                        "username": "RupalRadadia26",
                        "content": "return Math.abs(new Date(date2).getTime() - new Date(date1).getTime())/(1000*60*60*24)"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "If such questions are asked in interviews then its clear that the interviewer is not interested in hiring you"
                    },
                    {
                        "username": "Anu2k23",
                        "content": "Date-1:2020-01-15 and Date-2: 2019-12-31 the total day difference between two dates is actually 15 but here test output is 381 which is wrong."
                    }
                ]
            },
            {
                "id": 1575208,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "What is the point of such a question?"
                    },
                    {
                        "username": "iloabachie",
                        "content": "I don\\'t think it is totally pointless."
                    },
                    {
                        "username": "RB213",
                        "content": "Reject candidates who are not lc monkeys"
                    },
                    {
                        "username": "shailymittal",
                        "content": "Here is a trick with the question. 2100 will not be a leap year."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tdef isLeap(year):\\n\\t\\treturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0\\n\\tdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\tif date1 > date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\ty1, m1, d1 = map(int, date1.split(\"-\"))\\n\\ty2, m2, d2 = map(int, date2.split(\"-\"))\\n\\tresult = 0\\n\\tfor year in range(y1, y2):\\n\\t\\tresult += 365 + isLeap(year)\\n\\tdays[1] = 29 if isLeap(y1) else 28\\n\\tresult -= sum(days[ : m1 - 1]) + d1\\n\\tdays[1] = 29 if isLeap(y2) else 28\\n\\tresult += sum(days[ : m2 - 1]) + d2\\n\\treturn result"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar daysBetweenDates = function(date1, date2) {\\n\\t\\tconst getDays = (date) => new Date(date) / 1000 / 60 / 60 / 24\\n\\n\\t\\treturn Math.abs(getDays(date1) - getDays(date2))\\n\\t};"
                    },
                    {
                        "username": "yukimimi",
                        "content": "func daysBetweenDates(date1 string, date2 string) int {\\n\\ttime1, _ := time.Parse(\"2006-01-02\", date1)\\n\\ttime2, _ := time.Parse(\"2006-01-02\", date2)\\n\\treturn int(math.Abs(time2.Sub(time1).Hours() / 24.0))\\n}\\n"
                    },
                    {
                        "username": "sebnyberg",
                        "content": "Not great for performance to swap from int64 to float back to int (see time.Time internals).\n\n```go\nfunc daysBetweenDates(date1 string, date2 string) int {\n    d1, _ := time.Parse(\"2006-01-02\", date1)\n    d2, _ := time.Parse(\"2006-01-02\", date2)\n    a, b := d1.Unix(), d2.Unix()\n    if a > b {\n        return int((a - b)/(24*60*60))\n    }\n    return int((b - a)/(24*60*60))\n}\n```"
                    },
                    {
                        "username": "RupalRadadia26",
                        "content": "return Math.abs(new Date(date2).getTime() - new Date(date1).getTime())/(1000*60*60*24)"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "If such questions are asked in interviews then its clear that the interviewer is not interested in hiring you"
                    },
                    {
                        "username": "Anu2k23",
                        "content": "Date-1:2020-01-15 and Date-2: 2019-12-31 the total day difference between two dates is actually 15 but here test output is 381 which is wrong."
                    }
                ]
            },
            {
                "id": 1569783,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "What is the point of such a question?"
                    },
                    {
                        "username": "iloabachie",
                        "content": "I don\\'t think it is totally pointless."
                    },
                    {
                        "username": "RB213",
                        "content": "Reject candidates who are not lc monkeys"
                    },
                    {
                        "username": "shailymittal",
                        "content": "Here is a trick with the question. 2100 will not be a leap year."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tdef isLeap(year):\\n\\t\\treturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0\\n\\tdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\tif date1 > date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\ty1, m1, d1 = map(int, date1.split(\"-\"))\\n\\ty2, m2, d2 = map(int, date2.split(\"-\"))\\n\\tresult = 0\\n\\tfor year in range(y1, y2):\\n\\t\\tresult += 365 + isLeap(year)\\n\\tdays[1] = 29 if isLeap(y1) else 28\\n\\tresult -= sum(days[ : m1 - 1]) + d1\\n\\tdays[1] = 29 if isLeap(y2) else 28\\n\\tresult += sum(days[ : m2 - 1]) + d2\\n\\treturn result"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar daysBetweenDates = function(date1, date2) {\\n\\t\\tconst getDays = (date) => new Date(date) / 1000 / 60 / 60 / 24\\n\\n\\t\\treturn Math.abs(getDays(date1) - getDays(date2))\\n\\t};"
                    },
                    {
                        "username": "yukimimi",
                        "content": "func daysBetweenDates(date1 string, date2 string) int {\\n\\ttime1, _ := time.Parse(\"2006-01-02\", date1)\\n\\ttime2, _ := time.Parse(\"2006-01-02\", date2)\\n\\treturn int(math.Abs(time2.Sub(time1).Hours() / 24.0))\\n}\\n"
                    },
                    {
                        "username": "sebnyberg",
                        "content": "Not great for performance to swap from int64 to float back to int (see time.Time internals).\n\n```go\nfunc daysBetweenDates(date1 string, date2 string) int {\n    d1, _ := time.Parse(\"2006-01-02\", date1)\n    d2, _ := time.Parse(\"2006-01-02\", date2)\n    a, b := d1.Unix(), d2.Unix()\n    if a > b {\n        return int((a - b)/(24*60*60))\n    }\n    return int((b - a)/(24*60*60))\n}\n```"
                    },
                    {
                        "username": "RupalRadadia26",
                        "content": "return Math.abs(new Date(date2).getTime() - new Date(date1).getTime())/(1000*60*60*24)"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "If such questions are asked in interviews then its clear that the interviewer is not interested in hiring you"
                    },
                    {
                        "username": "Anu2k23",
                        "content": "Date-1:2020-01-15 and Date-2: 2019-12-31 the total day difference between two dates is actually 15 but here test output is 381 which is wrong."
                    }
                ]
            },
            {
                "id": 1575705,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "What is the point of such a question?"
                    },
                    {
                        "username": "iloabachie",
                        "content": "I don\\'t think it is totally pointless."
                    },
                    {
                        "username": "RB213",
                        "content": "Reject candidates who are not lc monkeys"
                    },
                    {
                        "username": "shailymittal",
                        "content": "Here is a trick with the question. 2100 will not be a leap year."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tdef isLeap(year):\\n\\t\\treturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0\\n\\tdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\tif date1 > date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\ty1, m1, d1 = map(int, date1.split(\"-\"))\\n\\ty2, m2, d2 = map(int, date2.split(\"-\"))\\n\\tresult = 0\\n\\tfor year in range(y1, y2):\\n\\t\\tresult += 365 + isLeap(year)\\n\\tdays[1] = 29 if isLeap(y1) else 28\\n\\tresult -= sum(days[ : m1 - 1]) + d1\\n\\tdays[1] = 29 if isLeap(y2) else 28\\n\\tresult += sum(days[ : m2 - 1]) + d2\\n\\treturn result"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar daysBetweenDates = function(date1, date2) {\\n\\t\\tconst getDays = (date) => new Date(date) / 1000 / 60 / 60 / 24\\n\\n\\t\\treturn Math.abs(getDays(date1) - getDays(date2))\\n\\t};"
                    },
                    {
                        "username": "yukimimi",
                        "content": "func daysBetweenDates(date1 string, date2 string) int {\\n\\ttime1, _ := time.Parse(\"2006-01-02\", date1)\\n\\ttime2, _ := time.Parse(\"2006-01-02\", date2)\\n\\treturn int(math.Abs(time2.Sub(time1).Hours() / 24.0))\\n}\\n"
                    },
                    {
                        "username": "sebnyberg",
                        "content": "Not great for performance to swap from int64 to float back to int (see time.Time internals).\n\n```go\nfunc daysBetweenDates(date1 string, date2 string) int {\n    d1, _ := time.Parse(\"2006-01-02\", date1)\n    d2, _ := time.Parse(\"2006-01-02\", date2)\n    a, b := d1.Unix(), d2.Unix()\n    if a > b {\n        return int((a - b)/(24*60*60))\n    }\n    return int((b - a)/(24*60*60))\n}\n```"
                    },
                    {
                        "username": "RupalRadadia26",
                        "content": "return Math.abs(new Date(date2).getTime() - new Date(date1).getTime())/(1000*60*60*24)"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "If such questions are asked in interviews then its clear that the interviewer is not interested in hiring you"
                    },
                    {
                        "username": "Anu2k23",
                        "content": "Date-1:2020-01-15 and Date-2: 2019-12-31 the total day difference between two dates is actually 15 but here test output is 381 which is wrong."
                    }
                ]
            },
            {
                "id": 2071780,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "What is the point of such a question?"
                    },
                    {
                        "username": "iloabachie",
                        "content": "I don\\'t think it is totally pointless."
                    },
                    {
                        "username": "RB213",
                        "content": "Reject candidates who are not lc monkeys"
                    },
                    {
                        "username": "shailymittal",
                        "content": "Here is a trick with the question. 2100 will not be a leap year."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tdef isLeap(year):\\n\\t\\treturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0\\n\\tdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\tif date1 > date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\ty1, m1, d1 = map(int, date1.split(\"-\"))\\n\\ty2, m2, d2 = map(int, date2.split(\"-\"))\\n\\tresult = 0\\n\\tfor year in range(y1, y2):\\n\\t\\tresult += 365 + isLeap(year)\\n\\tdays[1] = 29 if isLeap(y1) else 28\\n\\tresult -= sum(days[ : m1 - 1]) + d1\\n\\tdays[1] = 29 if isLeap(y2) else 28\\n\\tresult += sum(days[ : m2 - 1]) + d2\\n\\treturn result"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar daysBetweenDates = function(date1, date2) {\\n\\t\\tconst getDays = (date) => new Date(date) / 1000 / 60 / 60 / 24\\n\\n\\t\\treturn Math.abs(getDays(date1) - getDays(date2))\\n\\t};"
                    },
                    {
                        "username": "yukimimi",
                        "content": "func daysBetweenDates(date1 string, date2 string) int {\\n\\ttime1, _ := time.Parse(\"2006-01-02\", date1)\\n\\ttime2, _ := time.Parse(\"2006-01-02\", date2)\\n\\treturn int(math.Abs(time2.Sub(time1).Hours() / 24.0))\\n}\\n"
                    },
                    {
                        "username": "sebnyberg",
                        "content": "Not great for performance to swap from int64 to float back to int (see time.Time internals).\n\n```go\nfunc daysBetweenDates(date1 string, date2 string) int {\n    d1, _ := time.Parse(\"2006-01-02\", date1)\n    d2, _ := time.Parse(\"2006-01-02\", date2)\n    a, b := d1.Unix(), d2.Unix()\n    if a > b {\n        return int((a - b)/(24*60*60))\n    }\n    return int((b - a)/(24*60*60))\n}\n```"
                    },
                    {
                        "username": "RupalRadadia26",
                        "content": "return Math.abs(new Date(date2).getTime() - new Date(date1).getTime())/(1000*60*60*24)"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "If such questions are asked in interviews then its clear that the interviewer is not interested in hiring you"
                    },
                    {
                        "username": "Anu2k23",
                        "content": "Date-1:2020-01-15 and Date-2: 2019-12-31 the total day difference between two dates is actually 15 but here test output is 381 which is wrong."
                    }
                ]
            },
            {
                "id": 2065583,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "What is the point of such a question?"
                    },
                    {
                        "username": "iloabachie",
                        "content": "I don\\'t think it is totally pointless."
                    },
                    {
                        "username": "RB213",
                        "content": "Reject candidates who are not lc monkeys"
                    },
                    {
                        "username": "shailymittal",
                        "content": "Here is a trick with the question. 2100 will not be a leap year."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tdef isLeap(year):\\n\\t\\treturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0\\n\\tdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\tif date1 > date2:\\n\\t\\tdate1, date2 = date2, date1\\n\\ty1, m1, d1 = map(int, date1.split(\"-\"))\\n\\ty2, m2, d2 = map(int, date2.split(\"-\"))\\n\\tresult = 0\\n\\tfor year in range(y1, y2):\\n\\t\\tresult += 365 + isLeap(year)\\n\\tdays[1] = 29 if isLeap(y1) else 28\\n\\tresult -= sum(days[ : m1 - 1]) + d1\\n\\tdays[1] = 29 if isLeap(y2) else 28\\n\\tresult += sum(days[ : m2 - 1]) + d2\\n\\treturn result"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar daysBetweenDates = function(date1, date2) {\\n\\t\\tconst getDays = (date) => new Date(date) / 1000 / 60 / 60 / 24\\n\\n\\t\\treturn Math.abs(getDays(date1) - getDays(date2))\\n\\t};"
                    },
                    {
                        "username": "yukimimi",
                        "content": "func daysBetweenDates(date1 string, date2 string) int {\\n\\ttime1, _ := time.Parse(\"2006-01-02\", date1)\\n\\ttime2, _ := time.Parse(\"2006-01-02\", date2)\\n\\treturn int(math.Abs(time2.Sub(time1).Hours() / 24.0))\\n}\\n"
                    },
                    {
                        "username": "sebnyberg",
                        "content": "Not great for performance to swap from int64 to float back to int (see time.Time internals).\n\n```go\nfunc daysBetweenDates(date1 string, date2 string) int {\n    d1, _ := time.Parse(\"2006-01-02\", date1)\n    d2, _ := time.Parse(\"2006-01-02\", date2)\n    a, b := d1.Unix(), d2.Unix()\n    if a > b {\n        return int((a - b)/(24*60*60))\n    }\n    return int((b - a)/(24*60*60))\n}\n```"
                    },
                    {
                        "username": "RupalRadadia26",
                        "content": "return Math.abs(new Date(date2).getTime() - new Date(date1).getTime())/(1000*60*60*24)"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "If such questions are asked in interviews then its clear that the interviewer is not interested in hiring you"
                    },
                    {
                        "username": "Anu2k23",
                        "content": "Date-1:2020-01-15 and Date-2: 2019-12-31 the total day difference between two dates is actually 15 but here test output is 381 which is wrong."
                    }
                ]
            }
        ]
    }
]