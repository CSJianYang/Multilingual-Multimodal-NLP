[
    {
        "title": "Allow One Function Call",
        "question_content": "Given a function fn, return a new function that is identical to the original function except that it ensures&nbsp;fn&nbsp;is&nbsp;called at most once.\n\n\tThe first time the returned function is called, it should return the same result as&nbsp;fn.\n\tEvery subsequent time it is called, it should return&nbsp;undefined.\n\n&nbsp;\nExample 1:\n\nInput: fn = (a,b,c) => (a + b + c), calls = [[1,2,3],[2,3,6]]\nOutput: [{\"calls\":1,\"value\":6}]\nExplanation:\nconst onceFn = once(fn);\nonceFn(1, 2, 3); // 6\nonceFn(2, 3, 6); // undefined, fn was not called\n\nExample 2:\n\nInput: fn = (a,b,c) => (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]]\nOutput: [{\"calls\":1,\"value\":140}]\nExplanation:\nconst onceFn = once(fn);\nonceFn(5, 7, 4); // 140\nonceFn(2, 3, 6); // undefined, fn was not called\nonceFn(4, 6, 8); // undefined, fn was not called\n\n&nbsp;\nConstraints:\n\n\tcalls is a valid JSON array\n\t1 <= calls.length <= 10\n\t1 <= calls[i].length <= 100\n\t2 <= JSON.stringify(calls).length <= 1000",
        "solutions": [
            {
                "id": 3514065,
                "title": "o-1-sc-o-1-tc-4-diff-method-solution-in-js-and-typescript-day-8",
                "content": "# Intuition\\nThe problem is asking us to return a `new function` that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return `undefined` without calling the original function again.\\n\\n# Approach\\nTo solve this problem, we can return a `new function `that keeps track of whether it has been called before. We can do this by using a `closure `to store a `boolean flag` that is initially set to false. The first time the new function is called, we call the original function and set the flag to `true`. We also store the result of the original function. Subsequent calls to the new function simply return `undefined `without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\nO(1) for both the first and subsequent calls to the returned function. This is because checking the hasBeenCalled flag and returning either the result or undefined are constant-time operations.\\n\\n- Space complexity:\\nO(1) as well. This is because we only use a constant amount of extra space to store the hasBeenCalled flag and the result of the original function. \\n\\n# Learning \\nThe key idea behind this problem is to use a closure to store the state of the returned function. By doing this, we can keep track of whether the function has been called before and behave accordingly.\\n\\n# Code In JS\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n```\\n\\n# Code In TypeScript\\n```\\ntype Func<T, U> = (...args: T[]) => U;\\n\\nfunction once<T, U>(fn: Func<T, U>): Func<T, U | undefined> {\\n  let hasBeenCalled = false;\\n  let result: U;\\n\\n  return function (...args: T[]): U | undefined {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\n// Example usage:\\nlet fn = (a: number, b: number, c: number) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1, 2, 3)); // 6\\nconsole.log(onceFn(2, 3, 6)); // undefined\\n\\n```\\n\\n# Using a closure and an arrow function\\n\\nIn this approach, we use an `arrow function` to create the returned function. We store the` hasBeenCalled flag` and result in a closure, and use an if statement to check whether the function has already been called.\\n\\n```\\nfunction once(fn) {\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return (...args) => {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n\\n# Using a class\\n\\nIn this approach, we define a `Once class` that has a call method that behaves like the returned function in the previous approaches. We use a class property to store the hasBeenCalled flag and result.\\n\\n```\\nclass Once {\\n  hasBeenCalled = false;\\n  result;\\n\\n  call(fn, ...args) {\\n    if (!this.hasBeenCalled) {\\n      this.result = fn(...args);\\n      this.hasBeenCalled = true;\\n      return this.result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\nfunction once(fn) {\\n  const instance = new Once();\\n  return instance.call.bind(instance, fn);\\n}\\n\\n```\\n# Using a traditional function and an object\\n\\nwe use a` traditional function` to create the returned function. Instead of using a `closure`, we store the `hasBeenCalled flag` and result in an object that is passed as an argument to the returned function.\\n\\n```\\nfunction once(fn) {\\n  return function(...args) {\\n    const state = {\\n      hasBeenCalled: false,\\n      result: undefined\\n    };\\n\\n    if (!state.hasBeenCalled) {\\n      state.result = fn(...args);\\n      state.hasBeenCalled = true;\\n      return state.result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n![upvote-2.png](https://assets.leetcode.com/users/images/e79ad083-6070-43a5-903c-7a0bdf69dcf4_1683853739.9399579.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n```\n```\\ntype Func<T, U> = (...args: T[]) => U;\\n\\nfunction once<T, U>(fn: Func<T, U>): Func<T, U | undefined> {\\n  let hasBeenCalled = false;\\n  let result: U;\\n\\n  return function (...args: T[]): U | undefined {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\n// Example usage:\\nlet fn = (a: number, b: number, c: number) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1, 2, 3)); // 6\\nconsole.log(onceFn(2, 3, 6)); // undefined\\n\\n```\n```\\nfunction once(fn) {\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return (...args) => {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\n```\\nclass Once {\\n  hasBeenCalled = false;\\n  result;\\n\\n  call(fn, ...args) {\\n    if (!this.hasBeenCalled) {\\n      this.result = fn(...args);\\n      this.hasBeenCalled = true;\\n      return this.result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\nfunction once(fn) {\\n  const instance = new Once();\\n  return instance.call.bind(instance, fn);\\n}\\n\\n```\n```\\nfunction once(fn) {\\n  return function(...args) {\\n    const state = {\\n      hasBeenCalled: false,\\n      result: undefined\\n    };\\n\\n    if (!state.hasBeenCalled) {\\n      state.result = fn(...args);\\n      state.hasBeenCalled = true;\\n      return state.result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514233,
                "title": "dry-run-beginner-friendly-explanation-js-ts-o-1-sc-o-1-tc-day8",
                "content": "## Intuition: \\nWe can keep a boolean which can track if a function is called or not\\n***\\n## Explanation: \\n* The returned function uses a **[Closure](https://leetcode.com/problems/counter/discuss/3491300/Day2O(1)greaterUnderstanding-Closure-in-easy-way-and-its-practical-uses!!)** to keep track of whether `fn` has already been called. The `usedOnce` variable is initially set to `false`, indicating that `fn` has not yet been called.\\n* When the returned function is **called for the first time**, it sets `usedOnce` to `true`, calls `fn` with the input arguments `args`, stores the result in the `result` variable, and returns the `result`.\\n* When the returned function is **called subsequent times**, it simply returns `undefined`, since fn has already been called and its result has been stored in result.\\n* The use of the rest parameter `...args` allows the returned function to **accept any number of arguments**, which are then passed to `fn`.\\n\\t* To be more clear, `...args` represents the **input arguments** that are passed to the returned function. The use of the **spread syntax** allows the function to accept any number of input arguments, which are then passed as an **array** to the `fn` function using the spread syntax `...args`.\\n\\t* **For example,** if you call the returned function with `myFunc(1, 2, 4)`, the `...args` syntax will **convert the input arguments** into an `array [1, 2, 4]` that can be passed to the `fn` function using the spread syntax `...args`.\\n\\n*Dry Run is given after the solution part :)*\\n***\\n**JavaScript Solution:** \\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let usedOnce = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!usedOnce) {\\n      result = fn(...args);\\n      usedOnce = true;\\n      return result;\\n    }\\n    return undefined;\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n***\\n**TypeScript Solution:**\\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n     let usedOnce = false;\\n  return function (...args) {\\n      if(!usedOnce){\\n          usedOnce = true;\\n          return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n***\\n**Dry Run :**\\n```\\nvar myFunc = function(a, b, c) {\\n  return a + b + c;\\n};\\nvar onceFunc = once(myFunc);\\nconsole.log(onceFunc(1, 2, 3));    // O/P:6\\nconsole.log(onceFunc(4, 5, 6));    // O/P:undefined\\n```\\n* We call `onceFunc` for the first time with arguments `1, 2, 3.` Since this is the first call to `onceFunc`, the `usedOnce` variable is `false`, so the `result` variable is set to the `result` of calling `myFunc` with the arguments `1, 2, 3`, and `usedOnce` is set to `true`. The value of `result (= 6)` is then returned by `onceFunc`.\\n* We then call `onceFunc` for the second time with `arguments 4, 5, 6`. Since `usedOnce` is now `true`, `onceFunc` does not call `myFunc`, but instead returns `undefined`.\\n***\\n**Time Complexity: O(1)\\nSpace Complexity: O(1)**\\n***",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let usedOnce = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!usedOnce) {\\n      result = fn(...args);\\n      usedOnce = true;\\n      return result;\\n    }\\n    return undefined;\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n     let usedOnce = false;\\n  return function (...args) {\\n      if(!usedOnce){\\n          usedOnce = true;\\n          return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```\\nvar myFunc = function(a, b, c) {\\n  return a + b + c;\\n};\\nvar onceFunc = once(myFunc);\\nconsole.log(onceFunc(1, 2, 3));    // O/P:6\\nconsole.log(onceFunc(4, 5, 6));    // O/P:undefined\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514984,
                "title": "2666-allow-one-function-call-level-up-your-javascript-skills-day-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>The goal of the `once` function is to create a new function that ensures the original function is called at most once. The implementation achieves this by defining a variable that keeps track of whether the function has been called already, and returning a new function that checks whether the function has been called already before calling the original function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>The approach taken by the `once` function is to return a new function that wraps the original function and ensures that it is called at most once. The implementation achieves this by defining a variable `called` that keeps track of whether the function has been called already. The returned function checks whether `called` is true or false. If `called` is false, it calls the original function with the given arguments and stores the result in a variable `result`. It then sets `called` to true and returns `result`. If `called` is true, it simply returns `undefined` without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The time complexity of the `once` function is O(1) for the returned function since it checks the value of a single boolean variable before calling the original function. The time complexity of the original function passed to `once` is not considered since it depends on the implementation of the function itself\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>The space complexity of the `once` function is O(1) since it only defines a few variables that are used to keep track of whether the function has been called and store the result of the first call. The space complexity of the original function passed to `once` is not considered since it depends on the implementation of the function itself.\\n\\n\\n# Code\\n``` JS []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result;\\n    let called = false;\\n    return function(...args) {\\n        if (!called) {\\n            result = fn(...args);\\n            called = true;\\n            return result;\\n        }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n``` TS []\\nfunction once<T extends (...args: any[]) => any>(fn: T): ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n  let called = false;\\n  let result: ReturnType<T>;\\n\\n  return function (...args: Parameters<T>) {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n> Here are a few more ways to implement the `once` function in JavaScript:\\n\\n\\n1.Using a `closure` and an `arrow function`:\\n```\\nconst once = (fn) => {\\n  let called = false;\\n  let result;\\n  \\n  return (...args) => {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    }\\n  };\\n};\\n\\n```\\n>In this implementation, we use an arrow function to define the returned function. The rest of the implementation is similar to the closure-based implementation described earlier.\\n\\n2. Using an `object` with a `method`:\\n```\\nfunction once(fn) {\\n  return {\\n    called: false,\\n    result: undefined,\\n    execute(...args) {\\n      if (!this.called) {\\n        this.result = fn(...args);\\n        this.called = true;\\n      }\\n      return this.result;\\n    }\\n  };\\n}\\n```\\n>In this implementation, we define an object with two properties: `called` and `result`. We also define a method `execute` that checks whether `called` is true or false. If `called` is false, it calls the original function with the given arguments and stores the result in `result`. It then sets `called` to true and returns `result`. If called` is true, it simply returns `result` without calling the original function again.\\n\\n3. Using a `class`:\\n```\\nclass Once {\\n  constructor(fn) {\\n    this.called = false;\\n    this.result = undefined;\\n    this.fn = fn;\\n  }\\n  \\n  execute(...args) {\\n    if (!this.called) {\\n      this.result = this.fn(...args);\\n      this.called = true;\\n    }\\n    return this.result;\\n  }\\n}\\n\\nconst onceFn = new Once(fn).execute;\\nonceFn(1, 2, 3); // returns 6\\nonceFn(2, 3, 6); // returns undefined\\n\\n```\\n\\n# Important topic to Learn\\n\\n##### One important topic related to this problem is the concept of \"memoization\". \\n>Memoization is a technique used in computer science to speed up computations by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\\n\\n>The once function we have implemented is a simple example of memoization, as it ensures that the original function is only called once, and then returns the cached result on subsequent calls.\\n\\n>Memoization can be used to optimize performance in a wide range of scenarios, such as:\\n\\n1. >Recursive functions that repeatedly compute the same value for different inputs.\\n2. >Functions that make expensive network requests or database queries.\\n3. >Functions that perform complex computations that are computationally expensive. By memoizing these functions, we can avoid recomputing the same values multiple times, which can lead to significant performance improvements.\\n\\n>It\\'s worth noting that memoization should be used judiciously, as caching results can also use up memory and slow down the program if not managed properly. Additionally, memoization can only be used when the function being memoized is pure (i.e. it always returns the same output for a given input), otherwise the cached result may not be correct.\\n\\n| Sr No. | Topic |\\n|-----|-----|\\n1.|Array methods|\\n2.|Functional programming|\\n3.|Higher-order functions|\\n4.|Memoization|\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` JS []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result;\\n    let called = false;\\n    return function(...args) {\\n        if (!called) {\\n            result = fn(...args);\\n            called = true;\\n            return result;\\n        }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n``` TS []\\nfunction once<T extends (...args: any[]) => any>(fn: T): ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n  let called = false;\\n  let result: ReturnType<T>;\\n\\n  return function (...args: Parameters<T>) {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nconst once = (fn) => {\\n  let called = false;\\n  let result;\\n  \\n  return (...args) => {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    }\\n  };\\n};\\n\\n```\n```\\nfunction once(fn) {\\n  return {\\n    called: false,\\n    result: undefined,\\n    execute(...args) {\\n      if (!this.called) {\\n        this.result = fn(...args);\\n        this.called = true;\\n      }\\n      return this.result;\\n    }\\n  };\\n}\\n```\n```\\nclass Once {\\n  constructor(fn) {\\n    this.called = false;\\n    this.result = undefined;\\n    this.fn = fn;\\n  }\\n  \\n  execute(...args) {\\n    if (!this.called) {\\n      this.result = this.fn(...args);\\n      this.called = true;\\n    }\\n    return this.result;\\n  }\\n}\\n\\nconst onceFn = new Once(fn).execute;\\nonceFn(1, 2, 3); // returns 6\\nonceFn(2, 3, 6); // returns undefined\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484232,
                "title": "save-an-internal-boolean",
                "content": "# Intuition\\nSave an internal boolean.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n \\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (!called) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n \\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (!called) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3512772,
                "title": "simple-and-easy-solution-using-javascript-with-intuition-and-approach-o-1-tc-and-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We will use a variable which handle the count of times function has been called .\\n- On the basis of count ,we will return result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  1. Declare a variable `times` and intialize it with zero.`times`  will holds number of times given function has been called.  \\n  2. If `times` is one,fn() will be ans.\\n  3. Else undefined will return. \\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let times=0;\\n    return function(...args){\\n           times+=1;     \\n           if(times==1)\\n               return fn(...args);\\n           return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let times=0;\\n    return function(...args){\\n           times+=1;     \\n           if(times==1)\\n               return fn(...args);\\n           return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514408,
                "title": "day-o-1-o-7-commented-with-examples",
                "content": "This code defines a JavaScript function called **once**, which is used to create a new function that can only be invoked once. The ***once function*** takes another function fn as its ***parameter***.\\n\\nHere\\'s how the code works:\\n\\n* The ***once function*** creates a variable ans and initializes it to true. This variable keeps track of whether the wrapped function has been invoked before or not.\\n\\n* The ***once function*** returns an ***anonymous*** function that accepts any number of arguments using the rest parameter syntax (...args).\\n\\n* Inside the anonymous function, there is an if statement that checks the value of the ans variable. If it is true, it means that the wrapped function has not been invoked before.\\n \\n* If the condition is true, the ans variable is set to false to indicate that the wrapped function has now been invoked.\\n \\n* Finally, the wrapped **function** (fn) is called with the provided arguments using the spread operator (...args), and its result is returned.\\n\\nLet\\'s see an example to better understand how this code can be used:\\n```\\n// Example function\\nfunction sayHello(name) {\\n  console.log(\"Hello, \" + name);\\n}\\n\\n// Creating a new function using `once`\\nvar sayHelloOnce = once(sayHello);\\n\\n// Invoking the new function multiple times\\nsayHelloOnce(\"Alice\"); // Output: Hello, Alice\\nsayHelloOnce(\"Bob\");   // (no output)\\n\\n// The wrapped function is invoked only once\\n\\n```\\n\\nIn this example, the ***sayHelloOnce function*** is created using the once function and wraps the sayHello function. When sayHelloOnce is called the first time with the **argument** \"Alice\",\\n it invokes the wrapped sayHello function and prints \"Hello, Alice\" to the console. \\nHowever, when sayHelloOnce is called the second time with the **argument** \"Bob\", nothing happens because the wrapped function is set to be invoked only once.\\n\\n\\n***Here is the code to the current Problem :- ***\\n\\n```\\n\\nvar once = function(fn) {\\n    let ans = true;\\n    return function(...args){\\n        if (ans) {\\n            ans = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n// Example function\\nfunction sayHello(name) {\\n  console.log(\"Hello, \" + name);\\n}\\n\\n// Creating a new function using `once`\\nvar sayHelloOnce = once(sayHello);\\n\\n// Invoking the new function multiple times\\nsayHelloOnce(\"Alice\"); // Output: Hello, Alice\\nsayHelloOnce(\"Bob\");   // (no output)\\n\\n// The wrapped function is invoked only once\\n\\n```\n```\\n\\nvar once = function(fn) {\\n    let ans = true;\\n    return function(...args){\\n        if (ans) {\\n            ans = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514735,
                "title": "understand-question-step-by-step-solution-with-comments-javascript-typescript",
                "content": "# Understand the problem\\n\\nGiven a function `fn`, return a new function that is identical to the original function except that it ensures `fn` is called at most once.\\n\\nBreakdown -\\n\\nGiven a function `fn` -> means we have to give a function `fn` as an input\\n```\\n// give fn as an input\\nvar once = function(fn){\\n\\n}\\n```\\n\\nreturn a new function -> we have to return a function \\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n    }\\n};\\n```\\n\\nthat is identical to the original function -> means return function is identical like original function ,**that means it should also return a function becasue original function is return a function.**\\n\\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n      // it will also return a function\\n      return someFunction(...args){ }\\n    }\\n};\\n```\\n\\n except that it ensures `fn` is called at most once -> means we have to return a function `fn` and ensure one thing that it called only one time, means we have to track that function is called or not. \\n\\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // for tracking like function is called or not\\n    let isCalled = false;\\n    // we have to return a function\\n    return function(...args){\\n        // if function is called , we have to return undefined\\n        if(isCalled) return undefined;\\n        // change is called to true\\n        isCalled = !isCalled;\\n        // it will also return a function (otherwise)\\n        return fn(...args);\\n    }\\n};\\n```\\n\\nTypescript \\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCalled = false;\\n        return function(...args){\\n            if(isCalled) return undefined;\\n            isCalled = !isCalled;\\n            return fn(...args);\\n        }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// give fn as an input\\nvar once = function(fn){\\n\\n}\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n    }\\n};\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n      // it will also return a function\\n      return someFunction(...args){ }\\n    }\\n};\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // for tracking like function is called or not\\n    let isCalled = false;\\n    // we have to return a function\\n    return function(...args){\\n        // if function is called , we have to return undefined\\n        if(isCalled) return undefined;\\n        // change is called to true\\n        isCalled = !isCalled;\\n        // it will also return a function (otherwise)\\n        return fn(...args);\\n    }\\n};\\n```\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCalled = false;\\n        return function(...args){\\n            if(isCalled) return undefined;\\n            isCalled = !isCalled;\\n            return fn(...args);\\n        }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485421,
                "title": "2-solutions-closure-and-return-by-reference",
                "content": "# Closure\\n\\n```\\nfunction once(fn) {\\n    let called = false;\\n\\n    return (...args) => {\\n        if (called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n```\\n\\n# Return by reference\\n\\n```\\nfunction once(fn) {\\n    return (...args) => {\\n        const result = fn(...args);\\n\\n        fn = Function();\\n\\n        return result;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction once(fn) {\\n    let called = false;\\n\\n    return (...args) => {\\n        if (called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n```\n```\\nfunction once(fn) {\\n    return (...args) => {\\n        const result = fn(...args);\\n\\n        fn = Function();\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516813,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514632,
                "title": "java-script-solution-for-allow-one-function-call-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the once function is to create a wrapper function that ensures the original function fn is called only once. Subsequent calls to the wrapper function will not invoke fn but return undefined instead.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken by the once function is to use a closure to store a flag (hasBeenCalled) indicating whether fn has already been called. The wrapper function checks the flag and conditionally invokes fn only if it has not been called before\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the once function is O(1) because it performs a constant number of operations regardless of the size of the input.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n    return function(...args){\\n        if (!hasBeenCalled) {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n    return function(...args){\\n        if (!hasBeenCalled) {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836594,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516941,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        cnt++;\\n        if(cnt == 1)\\n        {\\n            return fn(...args);\\n        }\\n        return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        cnt++;\\n        if(cnt == 1)\\n        {\\n            return fn(...args);\\n        }\\n        return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516647,
                "title": "javascript-day-8-of-30-days-challange",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515793,
                "title": "limit-function-to-one-call",
                "content": "The code defines a function called `once` that takes a function `fn` as its parameter. The `once` function returns a new function that wraps around `fn` and ensures that it is called at most once.\\n\\nThe inner function keeps track of whether `fn` has been called before by setting a boolean variable `hasBeenCalled` to `false`. It also declares a variable `result` that will store the result of the first call to `fn`.\\n\\nThe inner function takes any number of arguments using the spread syntax `(...args)`. When the inner function is called for the first time, it checks whether `hasBeenCalled` is `false`. If so, it calls `fn` with the provided arguments using the spread syntax `fn(...args)`, and stores the result in the `result` variable. It then sets `hasBeenCalled` to `true` and returns the result.\\n\\nIf the inner function is called a second time or later, `hasBeenCalled` will be true, and the inner function will simply return `undefined`. This ensures that `fn` is only called once.\\n\\nThe expression `hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)))` is used as the return value of the inner function. If `hasBeenCalled` is true, the function returns `undefined`. Otherwise, it sets `hasBeenCalled` to true, calls `fn` with the provided arguments, and stores the result in `result`, then returns `result`.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n  let result;\\n  let hasBeenCalled = false;\\n  return (...args) => hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)));\\n}\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n  let result;\\n  let hasBeenCalled = false;\\n  return (...args) => hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)));\\n}\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515785,
                "title": "javascript-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/708964a3-2181-4495-af4b-dfc3650f3c50_1683887783.4264705.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515110,
                "title": "simplest-code-in-javascript-using-counter-variable",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515043,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 52 ms, faster than 88.74% of JavaScript online submissions for Allow One Function Call.\\n# Memory Usage: 41.8 MB, less than 62.02% of JavaScript online submissions for Allow One Function Call.\\n\\tvar once = function(fn) {\\n\\n\\t\\tlet Flag = true\\n\\t\\treturn function(...args){\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n# Approach 2 Using Typescript :\\n# Runtime: 63 ms, faster than 54.55% of TypeScript online submissions for Allow One Function Call.\\n# Memory Usage: 42.8 MB, less than 62.03% of TypeScript online submissions for Allow One Function Call.\\n\\n\\tfunction once<T extends (...args: any[]) => any>(fn: T): \\n\\t ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n\\n\\t\\tlet Flag = true\\n\\n\\t\\treturn function (...args) {\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\n\\t  };\\n\\t}\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 52 ms, faster than 88.74% of JavaScript online submissions for Allow One Function Call.\\n# Memory Usage: 41.8 MB, less than 62.02% of JavaScript online submissions for Allow One Function Call.\\n\\tvar once = function(fn) {\\n\\n\\t\\tlet Flag = true\\n\\t\\treturn function(...args){\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n# Approach 2 Using Typescript :\\n# Runtime: 63 ms, faster than 54.55% of TypeScript online submissions for Allow One Function Call.\\n# Memory Usage: 42.8 MB, less than 62.03% of TypeScript online submissions for Allow One Function Call.\\n\\n\\tfunction once<T extends (...args: any[]) => any>(fn: T): \\n\\t ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n\\n\\t\\tlet Flag = true\\n\\n\\t\\treturn function (...args) {\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\n\\t  };\\n\\t}\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3514953,
                "title": "javascript-solution-best-solution-with-99-efficiency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe `once` function takes a function `fn` as an argument and returns a new function that ensures `fn` is called at most once. The new function returns the result of the first call to `fn` and returns `undefined` for all subsequent calls.\\n\\n![Screenshot 2023-05-12 113031.png](https://assets.leetcode.com/users/images/886d7a34-d878-493f-a074-fb88a12e4aeb_1683871248.2008448.png)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. `once` is a function that takes a function `fn` as an argument.\\n\\n2. Inside the `once` function, we initialize a boolean flag `flag` to `true`. This `flag` will be used to determine whether `fn` has been called before.\\n\\n3. We also declare a variable `result` to store the result of the function. This will allow us to return the same `result` every time the function is called.\\n\\n4. We return a new function that takes any number of arguments using the rest parameter syntax `...args`.\\n\\n5. Inside the new function, we check if the `flag` is `true`. If it is, we call the original function fn with the `args`, store the result in result, set the `flag` to `false`, and return the `result`.\\n\\n6. If the `flag` is `false`, we simply return `undefined` without calling the original function.\\n\\n7. We now have a new function that behaves like the original function, but ensures that it is only called `once`.\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    let result;\\n    return function(...args){\\n        if(flag) {\\n            result = fn(...args);\\n            flag = false;\\n            return result;\\n        } else return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    let result;\\n    return function(...args){\\n        if(flag) {\\n            result = fn(...args);\\n            flag = false;\\n            return result;\\n        } else return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514757,
                "title": "editorial-one-in-javascript-0-0",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let hasBeenCalled = false;\\n  return function(...args){\\n    if (hasBeenCalled) {\\n      return undefined;\\n    } else {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let hasBeenCalled = false;\\n  return function(...args){\\n    if (hasBeenCalled) {\\n      return undefined;\\n    } else {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514370,
                "title": "simple-javascript-solution-o-1",
                "content": "# Intuition\\nTake a boolean variable or integer variable and track if function is called once.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let count  = 0;\\n    return function(...args){\\n        if(count<1) {\\n            count++;\\n            return fn(...args);\\n        }\\n        else {\\n         return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count  = 0;\\n    return function(...args){\\n        if(count<1) {\\n            count++;\\n            return fn(...args);\\n        }\\n        else {\\n         return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500997,
                "title": "js-simple-solution",
                "content": "# Approach\\nWe must keep the information if we\\'ve already triggered the function in a variable. Then on first trigger just set it and from then just return undefined.\\n\\nIt is possible to use Function.apply also to trigger the function with an array of arguments (works in older versions of ES):\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```js\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n    let isTriggered = false\\n    return (...args) => {\\n        if (isTriggered) return\\n        isTriggered = true\\n        return fn(...args)\\n    }\\n};\\n```\\n\\nAlternatively, we can use Function.apply method:\\n```js\\nfn.apply(this, args)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n    let isTriggered = false\\n    return (...args) => {\\n        if (isTriggered) return\\n        isTriggered = true\\n        return fn(...args)\\n    }\\n};\\n```\n```js\\nfn.apply(this, args)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493253,
                "title": "my-once",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let calls = false;\\n  \\n  return function (...args) {\\n    if (calls === false) {\\n      calls = true;\\n      return fn(...args);\\n    }\\n    else\\n      return undefined;\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let calls = false;\\n  \\n  return function (...args) {\\n    if (calls === false) {\\n      calls = true;\\n      return fn(...args);\\n    }\\n    else\\n      return undefined;\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488425,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return function(...args){\\n        const ans=fn(...args);\\n        fn=Function();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return function(...args){\\n        const ans=fn(...args);\\n        fn=Function();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485777,
                "title": "1-liner",
                "content": "```\\nvar once = f => (...a) => f ? [f(...a), f=undefined][0] : f\\n```",
                "solutionTags": [],
                "code": "```\\nvar once = f => (...a) => f ? [f(...a), f=undefined][0] : f\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485501,
                "title": "3-lines-js-solution-beats-100",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let count=0;\\n    return function(...args){\\n        if (count++==0) return fn(...args);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count=0;\\n    return function(...args){\\n        if (count++==0) return fn(...args);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523010,
                "title": "very-easy-to-understand-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let used = false;\\n    return function(...args){\\n       if(used) return undefined\\n       used = true\\n       return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let used = false;\\n    return function(...args){\\n       if(used) return undefined\\n       used = true\\n       return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514171,
                "title": "use-a-generator-function",
                "content": "# Intuition\\nUse generator function and put an infinite loop with a undefined yeild.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    function* OnceOnly()\\n    {\\n        const args = yield;\\n        const result = fn.apply(null, args);\\n        yield result;\\n        while (true)\\n        {\\n            yield undefined\\n        }\\n    }\\n    \\n    const gen = OnceOnly();\\n    \\n    return function(...args)\\n    {\\n        gen.next(args); // First value sent to generator is always lost. we will run it twice every subsequent time but thats fine because after second call the generator always returns undefined\\n        let result = gen.next(args)\\n        \\n        return result.value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    function* OnceOnly()\\n    {\\n        const args = yield;\\n        const result = fn.apply(null, args);\\n        yield result;\\n        while (true)\\n        {\\n            yield undefined\\n        }\\n    }\\n    \\n    const gen = OnceOnly();\\n    \\n    return function(...args)\\n    {\\n        gen.next(args); // First value sent to generator is always lost. we will run it twice every subsequent time but thats fine because after second call the generator always returns undefined\\n        let result = gen.next(args)\\n        \\n        return result.value;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502193,
                "title": "ts-simple-boolean-flag-52ms-41-9mb",
                "content": "Pretty simple problem to be solved with encapsulation, similar to other [base](https://leetcode.com/problems/counter/solutions/3492591/) [ones](https://leetcode.com/problems/counter-ii/solutions/3492633/) we already solved with a wrapper. The classic [debounce challenge](https://leetcode.com/problems/debounce/) ([solved here](https://leetcode.com/problems/debounce/solutions/3517553/)) might be a good next step.\\n\\nIn this specific case we will just need a boolean flag `isCallable` initially set to `true`, right outside the wrapper function we are going to `return`.\\n\\nSaid wrapper will check if `callable == true` and if so, it will:\\n* flag `isCallable` to `false`;\\n* `return` the expected result, invoking `fn` with all the arguments (`args`) it was called with.\\n\\nIf the flag is set to `false`, it means `fn` was already invoked once, so we will just `return` `undefined`.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```ts\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCallable = true;\\n    return function (...args) {\\n        return isCallable ? (isCallable = false, fn(...args)) : undefined;\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```ts\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCallable = true;\\n    return function (...args) {\\n        return isCallable ? (isCallable = false, fn(...args)) : undefined;\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494782,
                "title": "simple-solution-happy-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result = false;\\n    return function(...args){\\n        if(!result){\\n            result = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result = false;\\n    return function(...args){\\n        if(!result){\\n            result = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100680,
                "title": "allow-one-function-call-javascript-solution-by-bharadwaj",
                "content": "# Approach\\nFunctional Programming\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let count = 0;\\n    return function(...args){\\n        if(count++ === 0) return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count = 0;\\n    return function(...args){\\n        if(count++ === 0) return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097518,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = true\\n\\treturn function(...args){\\n        if(called) {\\n            called = false\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = true\\n\\treturn function(...args){\\n        if(called) {\\n            called = false\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096082,
                "title": "the-solution-only-by-two-lines-of-code",
                "content": "\\n# Code\\n```\\nvar once = function (fn)\\n{\\n      let expired = false;\\n      // if expired == true  retrun undefined\\n      // else set expierd to true and return orginal function\\n      //this is calld ternany operator \\n      return (...args) => (expired ? undefined : ((expired = true), fn(...args)));\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function (fn)\\n{\\n      let expired = false;\\n      // if expired == true  retrun undefined\\n      // else set expierd to true and return orginal function\\n      //this is calld ternany operator \\n      return (...args) => (expired ? undefined : ((expired = true), fn(...args)));\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096013,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasCalled = false;\\n\\treturn function(...args){\\n        if(!hasCalled){\\n            result  = fn(...args);\\n            hasCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasCalled = false;\\n\\treturn function(...args){\\n        if(!hasCalled){\\n            result  = fn(...args);\\n            hasCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088217,
                "title": "allow-function-to-be-called-only-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n -->\\nClosure concept: internal function will have access to the lexical scope of its parent, \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso we can keep a flag or number there to check if the internal function has been called or not\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype OnceFn = (...args: JSONValue[]) => JSONValue | undefined\\n\\nfunction once(fn: Function): OnceFn {\\n    let called = false;\\n    return function (...args) {\\n        if (called) {\\n            return;\\n        }\\n        else {\\n            called = true;\\n            return fn(...args);\\n        }\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype OnceFn = (...args: JSONValue[]) => JSONValue | undefined\\n\\nfunction once(fn: Function): OnceFn {\\n    let called = false;\\n    return function (...args) {\\n        if (called) {\\n            return;\\n        }\\n        else {\\n            called = true;\\n            return fn(...args);\\n        }\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087225,
                "title": "why-not-nullify-func-after-first-call",
                "content": "# Intuition\\nMy first thoughts in solving this problems were to either keep track of whether the func call was made or simply nullify the func. So that the actual fn call is not made. \\n\\nIdeally this approach should not be used, as it tampers the func definition, which we do not want. A calling function in general does not expect the called function to update any of its params. \\n\\nBut here we are solving the problems in all ways possible for the sake of learning!\\n\\n# Approach\\nJust nullify the func after invoke statement\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return (...args) => {\\n        let a = fn(...args);\\n        fn = () => {null};\\n        return a;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return (...args) => {\\n        let a = fn(...args);\\n        fn = () => {null};\\n        return a;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082559,
                "title": "solution-with-conditional-ternary-operator-and-apply-method-using-count-in-a-let-to-manage-state",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let count = 0\\n\\n    return function (...args) {\\n        count += 1\\n        return count > 1 ?  undefined :  fn.apply(this, args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let count = 0\\n\\n    return function (...args) {\\n        count += 1\\n        return count > 1 ?  undefined :  fn.apply(this, args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081167,
                "title": "js-simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(isCalled) return;\\n        isCalled = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(isCalled) return;\\n        isCalled = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078995,
                "title": "very-very-simple-and-clean-javascript-typescript-solution",
                "content": "```\\nconst once = (fn) => {\\n    let isCalled = 0;\\n    \\n    return function(...args) {\\n        if (isCalled) return;\\n\\n        isCalled = true;\\n\\n        return fn.apply(this, args);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst once = (fn) => {\\n    let isCalled = 0;\\n    \\n    return function(...args) {\\n        if (isCalled) return;\\n\\n        isCalled = true;\\n\\n        return fn.apply(this, args);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072258,
                "title": "straightforward-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calledBefore = false;\\n    return function(...args){\\n        if(!calledBefore){\\n            calledBefore = true;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calledBefore = false;\\n    return function(...args){\\n        if(!calledBefore){\\n            calledBefore = true;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071326,
                "title": "allow-one-function-call-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let status = false;\\n    return function(...args){\\n        if(status){\\n            return undefined;\\n        }\\n        status = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let status = false;\\n    return function(...args){\\n        if(status){\\n            return undefined;\\n        }\\n        status = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069367,
                "title": "js-closure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    \\n    return function(...args){\\n        if (isCalled) {\\n            return undefined;\\n        } else {\\n            isCalled = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    \\n    return function(...args){\\n        if (isCalled) {\\n            return undefined;\\n        } else {\\n            isCalled = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068172,
                "title": "beats-97-48-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let called=false;\\n\\n    return (...args) => {\\n        if(called) return;\\n        \\n        called=true;\\n        \\n        return fn(...args)\\n    }\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let called=false;\\n\\n    return (...args) => {\\n        if(called) return;\\n        \\n        called=true;\\n        \\n        return fn(...args)\\n    }\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068158,
                "title": "allow-one-function-call-with-constant-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$Big-O = O(1) - Constant$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet once = function (fn) {\\n  let flag = false;\\n  return function (...args) {\\n    if (!flag) {\\n      flag = true;\\n     return fn(...args)\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet once = function (fn) {\\n  let flag = false;\\n  return function (...args) {\\n    if (!flag) {\\n      flag = true;\\n     return fn(...args)\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067085,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0;\\n\\n    return function(...args){\\n       \\n        if (count > 0) return undefined; count++;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0;\\n\\n    return function(...args){\\n       \\n        if (count > 0) return undefined; count++;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062288,
                "title": "beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var count=0;\\n    let result;\\n    return function(...args){\\n       if(count<1){\\n           result = fn(...args);\\n           count += 1\\n           return result;\\n       }else{\\n           return undefined;\\n       }\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var count=0;\\n    let result;\\n    return function(...args){\\n       if(count<1){\\n           result = fn(...args);\\n           count += 1\\n           return result;\\n       }else{\\n           return undefined;\\n       }\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058710,
                "title": "simplest-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let x;\\n    return function(...args){\\n        if(x == null) return x = fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let x;\\n    return function(...args){\\n        if(x == null) return x = fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056677,
                "title": "simple-function-for-return-func-one-tiome",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let runner = 0\\n    return function(...args){\\n        for(let i = 0; i < args.length; i++) {\\n            if(runner === 0) {\\n            runner = 1\\n            return fn(...args)\\n            } else {\\n                return undefined\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let runner = 0\\n    return function(...args){\\n        for(let i = 0; i < args.length; i++) {\\n            if(runner === 0) {\\n            runner = 1\\n            return fn(...args)\\n            } else {\\n                return undefined\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055983,
                "title": "the-fastest-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    counter = 0;\\n    return function(...args){\\n        if(counter > 0) return undefined\\n        counter++\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    counter = 0;\\n    return function(...args){\\n        if(counter > 0) return undefined\\n        counter++\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051156,
                "title": "simple-solution-in-js-ts",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n    let fnCalled: boolean = false;\\n\\n    return function (...args): Fn {\\n        if (fnCalled) return undefined;\\n\\n        fnCalled = true;\\n        return fn(...args);\\n\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n    let fnCalled: boolean = false;\\n\\n    return function (...args): Fn {\\n        if (fnCalled) return undefined;\\n\\n        fnCalled = true;\\n        return fn(...args);\\n\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048303,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let hasBeenCalled = false;\\n    let result;\\n\\n    return function(...args){\\n        if(!hasBeenCalled){\\n            result = fn(...args);\\n            hasBeenCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let hasBeenCalled = false;\\n    let result;\\n\\n    return function(...args){\\n        if(!hasBeenCalled){\\n            result = fn(...args);\\n            hasBeenCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048005,
                "title": "js-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nconst once = (fn: Fn): Fn  =>{\\n    let fun;\\n  return function (...args) {\\n    if(fun !== undefined) return undefined;\\n   return fun = fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nconst once = (fn: Fn): Fn  =>{\\n    let fun;\\n  return function (...args) {\\n    if(fun !== undefined) return undefined;\\n   return fun = fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047007,
                "title": "creating-a-javascript-once-function-execute-functions-only-once-and-cache-results",
                "content": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this code is to create a function called `once` that takes another function (`fn`) as its argument and returns a new function. This new function ensures that the original `fn` is executed only once, and its result is cached and returned on subsequent calls.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI\\'ve implemented the `once` function to encapsulate the behavior of the original function (`fn`). Here\\'s how it works:\\n\\n- We initialize a `called` variable to track whether the `fn` function has been called before.\\n- We also declare a `result` variable to store the result of the `fn` function when it\\'s called.\\n\\n- The returned function accepts any number of arguments using the `...args` syntax. This allows it to work with functions that accept different argument lists.\\n\\n- Inside the returned function:\\n  - It checks if `called` is `true`. If it\\'s true, the function returns the cached `result` without calling `fn` again.\\n  - If `called` is `false`, it sets `called` to `true`, calls the original `fn` with the provided `args`, stores the result in `result`, and then returns the result.\\n\\nThis design ensures that the `fn` function is executed only once, and subsequent calls return the cached result.\\n\\n# Code\\n```javascript\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false \\n    let result;\\n    return function(...args){\\n        if(called) return undefined\\n        called = true \\n        result = fn(...args)\\n        return result \\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false \\n    let result;\\n    return function(...args){\\n        if(called) return undefined\\n        called = true \\n        result = fn(...args)\\n        return result \\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044293,
                "title": "once",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    var hasUsed:boolean = false    \\n    return function (...args) {\\n        var result = hasUsed ? undefined : fn(...args); hasUsed = true; return result;\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    var hasUsed:boolean = false    \\n    return function (...args) {\\n        var result = hasUsed ? undefined : fn(...args); hasUsed = true; return result;\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044275,
                "title": "once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar c = true;\\nvar once = (fn) => {\\n    c = true\\n    return (...args) => {\\n        var res = c ? fn(...args) : undefined\\n        c = false\\n        return res\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar c = true;\\nvar once = (fn) => {\\n    c = true\\n    return (...args) => {\\n        var res = c ? fn(...args) : undefined\\n        c = false\\n        return res\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044140,
                "title": "the-most-simple-single-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(1)\\n- Space complexity:\\n    O(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0\\n    return function(...args){\\n        if(!count++) return fn(...args)    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0\\n    return function(...args){\\n        if(!count++) return fn(...args)    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041566,
                "title": "using-clouser",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let hasBeenCalled = false\\n    let result;\\n    return function (...args) {\\n        if (!hasBeenCalled) {\\n            hasBeenCalled = 1 //true\\n            result = fn(...args)\\n            return result\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let hasBeenCalled = false\\n    let result;\\n    return function (...args) {\\n        if (!hasBeenCalled) {\\n            hasBeenCalled = 1 //true\\n            result = fn(...args)\\n            return result\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041206,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n\\n    return function(...args) {\\n        if (hasBeenCalled) return undefined;\\n        hasBeenCalled = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n\\n    return function(...args) {\\n        if (hasBeenCalled) return undefined;\\n        hasBeenCalled = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037119,
                "title": "a-c-analogy",
                "content": "### cpp thoughts...\\n New to js. Related to cpp to make sense of it! Thought of sharing!\\n\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let flag=false;\\n    return function(...args){\\n        if(!flag){ \\n            flag=true;\\n            // console.log(args[0]);\\n            return fn(...args); \\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n```cpp []\\n// made my data type- func() :)\\n\\nfunc() once(function){\\n    // code\\n    return function(); // obv\\n}\\n\\nfunc() x=once(fn); // x is a function right?! `once` returns x\\nx(...args); // now x can be parameterized (this case).\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let flag=false;\\n    return function(...args){\\n        if(!flag){ \\n            flag=true;\\n            // console.log(args[0]);\\n            return fn(...args); \\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```cpp []\\n// made my data type- func() :)\\n\\nfunc() once(function){\\n    // code\\n    return function(); // obv\\n}\\n\\nfunc() x=once(fn); // x is a function right?! `once` returns x\\nx(...args); // now x can be parameterized (this case).\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036829,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var Oncecall=true;\\n    return function(...args){\\n        if(Oncecall){\\n            Oncecall=false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var Oncecall=true;\\n    return function(...args){\\n        if(Oncecall){\\n            Oncecall=false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036301,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false\\n    return function(...args){\\n         if(!isCalled){\\n            isCalled=true\\n            return fn(...args)\\n         }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false\\n    return function(...args){\\n         if(!isCalled){\\n            isCalled=true\\n            return fn(...args)\\n         }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035292,
                "title": "learn-closures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if(!isCalled){\\n           \\n            isCalled=true;\\n             return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if(!isCalled){\\n           \\n            isCalled=true;\\n             return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029763,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    let flag = false;\\n    return function(...args){\\n        \\n        if(!flag) {\\n            flag = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    let flag = false;\\n    return function(...args){\\n        \\n        if(!flag) {\\n            flag = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026281,
                "title": "ok",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n   \\n    let called = false;\\n    return function(...args){\\n         \\n        if(called){\\n            return undefined\\n        }\\n       called = true;\\n\\n    if(called){\\n        return fn(...args);\\n    }\\n\\n\\n\\n\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n   \\n    let called = false;\\n    return function(...args){\\n         \\n        if(called){\\n            return undefined\\n        }\\n       called = true;\\n\\n    if(called){\\n        return fn(...args);\\n    }\\n\\n\\n\\n\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024273,
                "title": "perfect-solution-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet fn = (a,b,c) => (a + b + c);\\nvar once = function(fn) {\\n    let call = 0;\\n    return function(...args){\\n        if (call ==0){\\n            call +=1;\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet fn = (a,b,c) => (a + b + c);\\nvar once = function(fn) {\\n    let call = 0;\\n    return function(...args){\\n        if (call ==0){\\n            call +=1;\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019836,
                "title": "x",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n var once = function(fn) {\\n let o = true\\n  let onceFn    \\n    return function(...args){\\n        if(o){  \\n        o = false\\n       onceFn = fn(...args)\\n     return onceFn;         \\n     }else{\\n      return undefined  \\n        }  \\n    }\\n};\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n var once = function(fn) {\\n let o = true\\n  let onceFn    \\n    return function(...args){\\n        if(o){  \\n        o = false\\n       onceFn = fn(...args)\\n     return onceFn;         \\n     }else{\\n      return undefined  \\n        }  \\n    }\\n};\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018094,
                "title": "clean-solution-with-detailed-explanation",
                "content": "#  Explanation\\nWhen `once` is called the first time, it returns another function and do nothing. Since it is a closure, the inner function will still have access to lexical scope or the arguments that were passed in the parent function.. which is `fn` in this case. We don\\'t know the internals of what that function does but **OUR TASK** is to pass all the arguments we have to that callback function and let it do its part. The only thing we need to make sure is we should only let this function invoke once. To solve this, define a variable, `called` in my case and set it to `false` and set it to `true` before we call the `callback fn` and wrap this logic with.\\n```\\nif(!called) {\\n    called = true\\n    return fn(...args)\\n}\\n```\\nI could have `if/else` condition here like `if(called) return undefined`. But just wrapping it like this will do the trick too. If the `if condition` is not met, then `javascript` will return `undefined` itself since there is nothing to return.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false\\n    \\n    return function(...args){\\n    if(!called) {\\n        called = true\\n        return fn(...args)\\n    }\\n    }\\n};\\n\\n\\n  // let fn = (a,b,c) => (a + b + c)\\n  // let onceFn = once(fn)\\n \\n  // onceFn(1,2,3); // 6\\n  // onceFn(2,3,6); // returns undefined without calling fn\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nif(!called) {\\n    called = true\\n    return fn(...args)\\n}\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false\\n    \\n    return function(...args){\\n    if(!called) {\\n        called = true\\n        return fn(...args)\\n    }\\n    }\\n};\\n\\n\\n  // let fn = (a,b,c) => (a + b + c)\\n  // let onceFn = once(fn)\\n \\n  // onceFn(1,2,3); // 6\\n  // onceFn(2,3,6); // returns undefined without calling fn\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005231,
                "title": "js-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    var cnt=0;  \\n    return function(...args){\\n        cnt++;\\n         if(cnt==1)return fn(...args)\\n         else return undefined\\n         \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    var cnt=0;  \\n    return function(...args){\\n        cnt++;\\n         if(cnt==1)return fn(...args)\\n         else return undefined\\n         \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000085,
                "title": "javascript-solution-for-beginners",
                "content": "# JavaScript Solution\\n1.```let called = false;``` Inside the once function, a variable ***called*** is declared and initialized with false. This variable is used to keep track of whether the fn function has been called before.\\n\\n2.```if (called === false) { ... }```: Inside the inner function, it checks if the called variable is false, which means that fn has not been called before.\\n\\n3.```called = true;``` If fn has not been called before, it sets called to true, indicating that fn has now been called.\\n\\n4.```return fn(...args);``` It then calls the fn function with the provided arguments (args) and returns its result. This essentially allows you to call fn only once, and subsequent calls will return undefined.\\n\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let called = false;\\n  \\n    return function (...args) {\\n        if (called === false) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        else return undefined;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```let called = false;```\n```if (called === false) { ... }```\n```called = true;```\n```return fn(...args);```\n```\\nvar once = function(fn) {\\n    let called = false;\\n  \\n    return function (...args) {\\n        if (called === false) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        else return undefined;\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997948,
                "title": "javascript-easy-simple-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<!-- upvote if it helps -->\\n\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let t=true;\\n    let result;\\n    return function(...args){\\n        if(t)\\n        {\\n            result = fn(...args);\\n            t= false;\\n            return result;\\n        }\\n        else\\n       { return undefined;}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n<!-- upvote if it helps -->\\n\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let t=true;\\n    let result;\\n    return function(...args){\\n        if(t)\\n        {\\n            result = fn(...args);\\n            t= false;\\n            return result;\\n        }\\n        else\\n       { return undefined;}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997718,
                "title": "best-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n      if(c==0)  {\\n          c++;\\n          return fn(...args);\\n      }\\n      else{\\n          return undefined;\\n      }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n      if(c==0)  {\\n          c++;\\n          return fn(...args);\\n      }\\n      else{\\n          return undefined;\\n      }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996909,
                "title": "yea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = (fn) => {\\n  let executed = false;\\n  return (...args) => {\\n    if (!executed) {\\n      executed = true;\\n      return fn(...args);\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = (fn) => {\\n  let executed = false;\\n  return (...args) => {\\n    if (!executed) {\\n      executed = true;\\n      return fn(...args);\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983468,
                "title": "easy-to-understand",
                "content": "\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let call=0;\\n  return function (...args) {\\n      if(call==1) return undefined\\n      ++call;\\n      return fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let call=0;\\n  return function (...args) {\\n      if(call==1) return undefined\\n      ++call;\\n      return fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982969,
                "title": "a-really-short-solution",
                "content": "# Solution\\nJust change the reference of the argument, we do not need any more extra variables.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n        let rs = fn(...args);\\n        fn = ()=>undefined;\\n        return rs;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n        let rs = fn(...args);\\n        fn = ()=>undefined;\\n        return rs;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978446,
                "title": "explaining-a-closure-based-once-only-function-counter",
                "content": "# Intuition\\nThe purpose of this code is to create a function `once` that takes another function `fn` as input and returns a new function. This new function ensures that the provided function `fn` is executed only the first time it\\'s called, and subsequent calls will not execute `fn` again.\\n\\n# Approach\\n\\nThe code uses a closure and a counter variable to achieve its goal. Here\\'s how it works:\\n\\n1. The `once` function is called with an input function `fn`.\\n\\n2. Inside `once`, a `counter` variable is initialized with a value of 0.\\n\\n3. The `once` function returns an inner function (a closure) that captures the `counter` variable and takes any number of arguments using the spread operator `...args`.\\n\\n4. When the inner function is called, it first increments the `counter` using `++counter`. This means that the `counter` is incremented before its value is used in the comparison.\\n\\n5. The incremented value of `counter` is then compared to 1 using `=== 1`. If the comparison is true (meaning this is the first call to the inner function), it executes the original function `fn` with the provided arguments using `fn(...args)`.\\n\\n6. If the comparison is false (meaning this is not the first call), the inner function returns `undefined` without executing `fn`.\\n\\n**Explanation of ++counter:**\\nThe `++counter` part is a pre-increment operation on the `counter` variable. This means that before the value of counter is used for comparison, it is incremented by 1. In other words, the value of `counter` is increased by 1 before it\\'s checked in the comparison `++counter === 1`.\\n\\nThis pre-increment is crucial for ensuring that fn is executed only on the very first call to the inner function. Once the counter is incremented to 1 and the comparison succeeds, it ensures that subsequent calls to the inner function will result in counter being greater than 1, thus preventing fn from executing again.\\n\\n# Complexity\\n**- Time complexity:**\\nThe time complexity of this code is constant time, `O(1)`, regardless of how many times the functions are called.\\n\\n\\n**- Space complexity:**\\nThe space complexity is also constant, `O(1)`, as the memory used is fixed and does not increase with the number of function calls.\\n\\nIn summary, the code leverages a closure and a pre-increment operation to create a function that executes the provided function only on its first call and returns `undefined` on `subsequent calls`.\\n\\n\\n# Code\\n```\\nconst once = fn => {\\n  let counter = 0\\n\\n  return (...args) => (++counter === 1 ? fn(...args) : undefined)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst once = fn => {\\n  let counter = 0\\n\\n  return (...args) => (++counter === 1 ? fn(...args) : undefined)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975950,
                "title": "l",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\nif(called){\\n    return  undefined;\\n}\\ncalled = true;\\n              return fn.apply(this,args)\\n\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\nif(called){\\n    return  undefined;\\n}\\ncalled = true;\\n              return fn.apply(this,args)\\n\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973416,
                "title": "super-simple-and-straightforward-approach-stringifying-the-function-with-map-javascript",
                "content": "# Intuition\\nThis seems like the Memoization problem, except we want to remember the function itself.\\n\\n# Approach\\n- We can save the function into a Map as a string.\\n- When a function is passed, we check if it exist in the map, if it does, return undefined.\\n- If it doesn\\'t, stringify the function, save it as an entry in the map, and returns the function result with the argument paramenter \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const map = new Map();\\n    \\n    return function(...args) {\\n        if (map.get(\"\" + fn)) return undefined;\\n        map.set(\"\" + fn, 1);\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const map = new Map();\\n    \\n    return function(...args) {\\n        if (map.get(\"\" + fn)) return undefined;\\n        map.set(\"\" + fn, 1);\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972906,
                "title": "o-1-sc-o-1-tc-solution-in-js-day-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to return a new function that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return undefined without calling the original function again.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can return a new function that keeps track of whether it has been called before. We can do this by using a closure to store a boolean flag that is initially set to false. The first time the new function is called, we call the original function and set the flag to true. We also store the result of the original function. Subsequent calls to the new function simply return undefined without calling the original function again\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) for both the first and subsequent calls to the returned function. This is because checking the hasBeenCalled flag and returning either the result or undefined are constant-time operations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as well. This is because we only use a constant amount of extra space to store the hasBeenCalled flag and the result of the original function\\n# Code In JS\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972004,
                "title": "easy-solution-runtime-53-ms-space-41-77-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved if we somehow restrict the function(...args) from calling it more than one time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we can start with initialising a boolean variable witha true value (example let val = true) outside the function to be returned and by using a while loop we can check for val as the condition for the while loop. When the function is being called for once we can change the value of val to false. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let val =true;\\n    return function(...args){\\n        while(val){\\n            val = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let val =true;\\n    return function(...args){\\n        while(val){\\n            val = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971151,
                "title": "simple-o-1-o-1-complexities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n            if(counter ===0){\\n                counter++;\\n                return fn(...args)\\n            }\\n            return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n            if(counter ===0){\\n                counter++;\\n                return fn(...args)\\n            }\\n            return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966505,
                "title": "sweet-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args) {\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args) {\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963242,
                "title": "one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let trigger = 0;\\n    return function(...args){\\n        if(trigger == 0){\\n            trigger++;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let trigger = 0;\\n    return function(...args){\\n        if(trigger == 0){\\n            trigger++;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962458,
                "title": "closure",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = function(fn) {\\n\\n    let wasCalled = false\\n    \\n    return function(...args){\\n        if (!wasCalled) {\\n            wasCalled = true\\n            const result = fn(...args)\\n            return result\\n        }    \\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = function(fn) {\\n\\n    let wasCalled = false\\n    \\n    return function(...args){\\n        if (!wasCalled) {\\n            wasCalled = true\\n            const result = fn(...args)\\n            return result\\n        }    \\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957853,
                "title": "very-simple-solution-using-flag",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955653,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let k=0;\\n\\n    return function(...args){\\n        \\n        if(k>0){\\n            return undefined;\\n        }\\n\\n        k++;\\n        return fn(...args);\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let k=0;\\n\\n    return function(...args){\\n        \\n        if(k>0){\\n            return undefined;\\n        }\\n\\n        k++;\\n        return fn(...args);\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955273,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0 \\n    return function(...args){\\n        if(count < 1){\\n            count++\\n            return fn(...args)\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0 \\n    return function(...args){\\n        if(count < 1){\\n            count++\\n            return fn(...args)\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954054,
                "title": "allow-one-function-call-day-10-javascript-solution-apply",
                "content": "# Intuition\\nThe problem is asking us to return a result as fn but on consequent calls it should return undefined.\\n\\n# Approach\\n- Assign a new variable `val` to the result of calling the passed function.\\n- Reassign the function `fn` to return undefined.\\n- Return the new variable `val`.\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n      const val = fn.apply(this, args)\\n      fn = () => undefined\\n      return val\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n      const val = fn.apply(this, args)\\n      fn = () => undefined\\n      return val\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953782,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(called === false){\\n            called=true;\\n            return fn(...args);\\n        }\\n        else {\\n            return undefined;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(called === false){\\n            called=true;\\n            return fn(...args);\\n        }\\n        else {\\n            return undefined;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3948148,
                "title": "allow-once-function-call-in-simple-way",
                "content": "# Intuition\\nFunction needs to be called only once we need counter or we need to assign null or undefined to that function and first call will return function so function needs to be stored as variable of outer function so we can use closure concept\\n\\n# Approach\\nfirst we assigned function to variable in outerfunction so returned function will hold reference to that function due to closure and when first time called if check will be true and after calling we will assign undefined or null so next time call that if check will fail and return undefined\\n\\n# Complexity\\n- Time complexity:\\n  -\\n\\n- Space complexity:\\n -\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnToCall = fn;\\n    return function(...args){\\n      if(fnToCall) {\\n       let result =  fnToCall(...arguments);\\n       fnToCall = undefined;\\n       return result;\\n      }\\n      return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnToCall = fn;\\n    return function(...args){\\n      if(fnToCall) {\\n       let result =  fnToCall(...arguments);\\n       fnToCall = undefined;\\n       return result;\\n      }\\n      return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947942,
                "title": "easy-solution-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let firstCalled = false;\\n    return function(...args){\\n // we have  first need to return the same function \\n//    with its argument (...args)\\n   \\n   // to check wheather it is called for one time only\\n   if (firstCalled ){\\n       return undefined;\\n   }\\n    firstCalled =!firstCalled\\n    return fn(...args)\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let firstCalled = false;\\n    return function(...args){\\n // we have  first need to return the same function \\n//    with its argument (...args)\\n   \\n   // to check wheather it is called for one time only\\n   if (firstCalled ){\\n       return undefined;\\n   }\\n    firstCalled =!firstCalled\\n    return fn(...args)\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947476,
                "title": "javascript-solution",
                "content": "\\n- se crea un state called para saber cuando una fn fue llamada\\n\\n- el if (called) si es true significa que la funci\\xF3n ya fue llamada entonces retornara undefined\\n\\n- si no es true proceder\\xE1 a convertir called=true y llamar la funci\\xF3n que este quiera ejecutar\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) {\\n            return undefined;\\n        }\\n        called = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) {\\n            return undefined;\\n        }\\n        called = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946528,
                "title": "no-return-undefined-needed-if-statement-only",
                "content": "# Approach\\nSimple if statement to check if the function has been called at least once. It returns undefined automatically if we remove the return statement.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = (fn) => {\\n    let res\\n    return (...args) => {\\n        if (!res) {\\n            res = fn(...args)\\n            return res \\n        } \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = (fn) => {\\n    let res\\n    return (...args) => {\\n        if (!res) {\\n            res = fn(...args)\\n            return res \\n        } \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945579,
                "title": "shortest-typescript-solution",
                "content": "# Approach\\nThe once function creates a closure over a `counter` variable, which is incremented each time the returned function is called. If `counter` is equal to 1, the original function is called with the provided arguments and its result is returned. Otherwise, `undefined` is returned.\\n\\n# Complexity\\nTime complexity: The time complexity of calling the returned function is `O(1)`, since it only involves incrementing a counter and checking its value.\\nSpace complexity: The space complexity of the once function is `O(1)`, since it only needs to store a single counter variable. However, keep in mind that the returned function also maintains a reference to the original function and its arguments, so the total space complexity will depend on the size of those objects.\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let counter = 0;\\n  return function (...args) {\\n    counter++;\\n    return counter === 1 ? fn(...args) : undefined;\\n  };\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let counter = 0;\\n  return function (...args) {\\n    counter++;\\n    return counter === 1 ? fn(...args) : undefined;\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944565,
                "title": "resolved-the-problem-using-js",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const memorizeFunction = {}\\n    \\n    return (...arg) => {\\n        if(fn in memorizeFunction) {\\n           return undefined\\n        }\\n        \\n        let result = fn(...arg)\\n        memorizeFunction[fn] = result\\n        return result\\n    }\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const memorizeFunction = {}\\n    \\n    return (...arg) => {\\n        if(fn in memorizeFunction) {\\n           return undefined\\n        }\\n        \\n        let result = fn(...arg)\\n        memorizeFunction[fn] = result\\n        return result\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3941484,
                "title": "simple-logic",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936617,
                "title": "function-as-objects-smart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn Javascript functions are treated as objects. We can leverage this property and use it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd a count variable to the function `fn`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\t  fn.count = 0\\n    return function(...args){\\n\\t\\t\\t if(fn.count == 1){\\n\\t\\t\\t\\t return undefined\\n\\t\\t\\t }else{\\n\\t\\t\\t\\t fn.count = 1\\n\\t\\t\\t\\t return fn(...args)\\n\\t\\t\\t }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\t  fn.count = 0\\n    return function(...args){\\n\\t\\t\\t if(fn.count == 1){\\n\\t\\t\\t\\t return undefined\\n\\t\\t\\t }else{\\n\\t\\t\\t\\t fn.count = 1\\n\\t\\t\\t\\t return fn(...args)\\n\\t\\t\\t }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936595,
                "title": "flag-closure-and-one-if-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, you just need a flag to say when is the first time and then you turn it to false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used closure in the first function and then i added a condition to the second function with just 1 \"if\", cause that\\'s the only one we need and in the same if we change the value of the \"flag\" to \"false\", so it won\\'t run in the second time and return \"undefined\" by default.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    return function(...args){\\n        if(flag){\\n        flag = false;\\n        return fn(...args)\\n    }\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    return function(...args){\\n        if(flag){\\n        flag = false;\\n        return fn(...args)\\n    }\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935468,
                "title": "allow-one-function-call-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to return a new function that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return undefined without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled =false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled=true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled =false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled=true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927737,
                "title": "alternative-approach-using-a-ternary",
                "content": "# Intuition\\nI solved this first with the a separate `hasBeenCalled` variable. In that solution I was already declaring `result` which also gets changed, so I worked out a solution relies on this change instead.\\n\\n# Approach\\nSince `result` is already declared, we set its value to null (to avoid any issues with `fn()` returning a falsy value). Then we use a ternary to reassign `result` if it\\'s not still `null`.\\n\\n# Complexity\\n- Time complexity: Constant\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let result = null;\\n    \\n    return (...args) => {\\n        result = result === null ? fn(...args) : undefined;\\n        \\n        return result;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let result = null;\\n    \\n    return (...args) => {\\n        result = result === null ? fn(...args) : undefined;\\n        \\n        return result;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925559,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let usedOnce = false;\\n    let result;\\n\\n    return function (...args) {\\n        if (!usedOnce) {\\n            result = fn(...args);\\n            usedOnce = true;\\n            return result;\\n        }\\n        return undefined;\\n    };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let usedOnce = false;\\n    let result;\\n\\n    return function (...args) {\\n        if (!usedOnce) {\\n            result = fn(...args);\\n            usedOnce = true;\\n            return result;\\n        }\\n        return undefined;\\n    };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924468,
                "title": "typescript-my-solution",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let wasCalled = false;    \\n  return function (...args) {\\n      return wasCalled ? undefined : (wasCalled = true) && fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let wasCalled = false;    \\n  return function (...args) {\\n      return wasCalled ? undefined : (wasCalled = true) && fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923735,
                "title": "simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: *```O()```* -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    \\n    let callStatus = false;\\n\\n    return function(...args){\\n    \\n        if(callStatus)\\n            return undefined;\\n    \\n        let result = fn(...args);\\n        callStatus = true;\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```O()```\n```\\nvar once = function(fn) {\\n    \\n    let callStatus = false;\\n\\n    return function(...args){\\n    \\n        if(callStatus)\\n            return undefined;\\n    \\n        let result = fn(...args);\\n        callStatus = true;\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916412,
                "title": "easy-javascript-solution",
                "content": "> Vote Up if You Like it\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called=true;\\n    return function(...args){\\n        let value=fn(...args)\\n        if(called){\\n           called=false\\n           return value\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called=true;\\n    return function(...args){\\n        let value=fn(...args)\\n        if(called){\\n           called=false\\n           return value\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914774,
                "title": "js-solution-with-explanation",
                "content": "# Approach\\nWhat we have to do here is that, we have to return the result of fn if once is called atmost 1 time else we return undefined.\\n\\n- So, to keep track of calling we keep a boolean variable HasBeenCalled initially to true.\\n- and for the first time it will enter the fn function and return the result and also set HasBeenCalled to true.\\n- What happens now is that if fn function is called directly then, it will check if !hasbeencalled which will result in false and the undefined will be returned. \\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) =>{\\n    let HasbeenCalled = false;\\n    let  result;\\n\\n    return (...args) =>{\\n      if(!HasbeenCalled){\\n        result = fn(...args)\\n        HasbeenCalled = true;\\n        return result;\\n      }\\n      else{\\n        return undefined;\\n      }\\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) =>{\\n    let HasbeenCalled = false;\\n    let  result;\\n\\n    return (...args) =>{\\n      if(!HasbeenCalled){\\n        result = fn(...args)\\n        HasbeenCalled = true;\\n        return result;\\n      }\\n      else{\\n        return undefined;\\n      }\\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914293,
                "title": "easiest-way-javascript-closure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = false;\\n    return function(...args){\\n        if(call) return;\\n        call = true;\\n        return fn(...args);\\n    }\\n};\\n\\n\\nlet fn = (a,b,c) => (a + b + c)\\nlet onceFn = once(fn)\\n\\nonceFn(1,2,3); // 6\\nonceFn(2,3,6); // returns undefined without calling fn\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = false;\\n    return function(...args){\\n        if(call) return;\\n        call = true;\\n        return fn(...args);\\n    }\\n};\\n\\n\\nlet fn = (a,b,c) => (a + b + c)\\nlet onceFn = once(fn)\\n\\nonceFn(1,2,3); // 6\\nonceFn(2,3,6); // returns undefined without calling fn\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912370,
                "title": "js-solution",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let beenCalled = false\\n    let result\\n    return function(...args){\\n        if (!beenCalled) {\\n            result = fn(...args)\\n            beenCalled = true\\n            return result\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let beenCalled = false\\n    let result\\n    return function(...args){\\n        if (!beenCalled) {\\n            result = fn(...args)\\n            beenCalled = true\\n            return result\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908795,
                "title": "easy-peasy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn){\\n    var c = true;\\n    return (...args) =>  c ? (()=>{ c = !c ; return fn(...args) })()  : undefined\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn){\\n    var c = true;\\n    return (...args) =>  c ? (()=>{ c = !c ; return fn(...args) })()  : undefined\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907216,
                "title": "simple-solution",
                "content": "\\n```\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        if(++cnt > 1) return undefined;\\n        return fn(...args)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        if(++cnt > 1) return undefined;\\n        return fn(...args)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906380,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args)=>{\\n        if(called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args)=>{\\n        if(called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899310,
                "title": "beginner-friendly-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe must have a boolean trigger to prevent function from running twice or more. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this solution this boolean value represented by `let onced`\\nThen we check condition and if fuction hasn\\'t ran before we set `onced` to `true` return input fn with its `...args`. Otherwise we return `undefined`\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let onced = false\\n    return function(...args){\\n        if(!onced){\\n            onced = true\\n            return fn(...args)\\n        }else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let onced = false\\n    return function(...args){\\n        if(!onced){\\n            onced = true\\n            return fn(...args)\\n        }else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897336,
                "title": "simple-two-line-solution-javascript-using-boolean-variable",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialised a boolean variable , for checking the data as if it is  called at least once.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if (!isCalled) {\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if (!isCalled) {\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892509,
                "title": "beats-98-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 40ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 41.2mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892035,
                "title": "js-solution-runtime-48-ms-beats-91-2-memory-41-7-mb-beats-66-11",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n\\nvar once = function(fn) {\\n    this.isCalled = false;\\n    return function(...args){\\n        if(this.isCalled )return ;\\n        this.isCalled = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n\\nvar once = function(fn) {\\n    this.isCalled = false;\\n    return function(...args){\\n        if(this.isCalled )return ;\\n        this.isCalled = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888922,
                "title": "single-invocation-enforcer-for-javascript-functions",
                "content": "# Intuition and Approach:\\nThe intuition behind the solution is to use closure and a flag to keep track of whether the original function has been called before. The approach involves creating a new function that checks this flag. If the original function hasn\\'t been called before, it invokes the original function with the provided arguments and returns the result. Subsequent calls return undefined, ensuring that the original function is executed only once.\\n\\n# Time Complexity:\\nThe time complexity of the once function is constant (O(1)) for each call, regardless of the original function\\'s complexity. The main operation is checking the hasBeenCalled flag and invoking the original function if necessary.\\n\\n# Space Complexity:\\nThe space complexity is influenced by the closure created by the returned function and the storage of the hasBeenCalled flag and result. This takes up constant space (O(1)) for each invocation.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let Hascalled=false;\\n    let result;\\n    return function(...args){\\n        if(!Hascalled){\\n            result=fn(...args);\\n            Hascalled = true;\\n            return result;\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n\\n```\\nThe once function is designed to wrap an original function and ensure it\\'s called at most once. It achieves this by creating a new function that keeps track of whether the original function has been invoked. The solution has a constant time and space complexity and enhances control over function invocations.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let Hascalled=false;\\n    let result;\\n    return function(...args){\\n        if(!Hascalled){\\n            result=fn(...args);\\n            Hascalled = true;\\n            return result;\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888089,
                "title": "simple-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    was_executed = false\\n    return function(...args){\\n        if (!was_executed){\\n            was_executed = true\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    was_executed = false\\n    return function(...args){\\n        if (!was_executed){\\n            was_executed = true\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887719,
                "title": "allow-one-function-call",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var called = false; \\n    return function(...args){\\n        if(!called){\\n        //return args.reduce(fn);\\n        called = true;\\n        return fn(...args);\\n        }\\n    } \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var called = false; \\n    return function(...args){\\n        if(!called){\\n        //return args.reduce(fn);\\n        called = true;\\n        return fn(...args);\\n        }\\n    } \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879026,
                "title": "top-1-answer",
                "content": "# Intuition\\nFirst is done. When it is called, it triggered a flag and done. then just pass the function and array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have to handle the done variable. I don\\'t use boolean but use integer as boolean variable. So, I can omit update statement of done.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let done = 0\\n    return function(...args){\\n        return (done++)? undefined: fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let done = 0\\n    return function(...args){\\n        return (done++)? undefined: fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878454,
                "title": "easy-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = 0;\\n\\n    return function(...args){\\n        if(call>0)\\n            return undefined;\\n        call += 1 ; \\n        let ans = fn(...args);\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = 0;\\n\\n    return function(...args){\\n        if(call>0)\\n            return undefined;\\n        call += 1 ; \\n        let ans = fn(...args);\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3868848,
                "title": "3-lines-of-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let count = 0;\\n    return function (...args) {\\n        count++;\\n        return count === 1 ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let count = 0;\\n    return function (...args) {\\n        count++;\\n        return count === 1 ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864483,
                "title": "easy-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n  \\nvar once = function(fn) {\\n\\n    return function(...args){\\n\\n            var k = fn(...args)\\n           if(k[\"calls\"]==1){\\n               return k\\n           }\\n            \\n     \\n      \\n     \\n        \\n    }\\n}\\n\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n  \\nvar once = function(fn) {\\n\\n    return function(...args){\\n\\n            var k = fn(...args)\\n           if(k[\"calls\"]==1){\\n               return k\\n           }\\n            \\n     \\n      \\n     \\n        \\n    }\\n}\\n\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861979,
                "title": "intuitive-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Closure to track the number of functions calls\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUtilize Closure to keep track of how many times fn has been called, return undefined after the first call\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnCalls = 0;\\n    \\n    return function(...args){\\n        if(fnCalls < 1){\\n            fnCalls++\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnCalls = 0;\\n    \\n    return function(...args){\\n        if(fnCalls < 1){\\n            fnCalls++\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855225,
                "title": "simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n        if(counter == 0){\\n            counter =1;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n        if(counter == 0){\\n            counter =1;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854212,
                "title": "simpler-js-code-with-o-1-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    x = 0\\n    return function(...args){\\n        if(x == 0){x++; return fn(...args)}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    x = 0\\n    return function(...args){\\n        if(x == 0){x++; return fn(...args)}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854062,
                "title": "1-line-simple-solution-with-minimal-code-unique-approach",
                "content": "# Intuition\\nThese approach emphasizes achieving performance with minimal code.\\n\\n1. Use of **Arrow functions** to reduce the code.\\n2. Utilization of **ternary operator and parentheses** to simplify the code.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args) => \\n        (called == true) ? undefined : ((called = true), (fn(...args)));\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args) => \\n        (called == true) ? undefined : ((called = true), (fn(...args)));\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851517,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let func_called = true;\\n\\n    return function(...args){\\n        if(func_called){\\n            func_called = false;\\n            return fn(...args);\\n        }    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let func_called = true;\\n\\n    return function(...args){\\n        if(func_called){\\n            func_called = false;\\n            return fn(...args);\\n        }    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850182,
                "title": "very-easy-short-solution-javascript",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n\\n    let cont = 0;\\n\\n    return function(...args){\\n\\n        return cont !== 0 ? undefined : (cont++, fn(...args));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n\\n    let cont = 0;\\n\\n    return function(...args){\\n\\n        return cont !== 0 ? undefined : (cont++, fn(...args));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847941,
                "title": "runtime-beats-75-01-memory-beats-91-04",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let iscalled=false;\\n    \\n    return function(...args){\\n        if(!iscalled){\\n            iscalled=true;\\n            return fn(...args);\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let iscalled=false;\\n    \\n    return function(...args){\\n        if(!iscalled){\\n            iscalled=true;\\n            return fn(...args);\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845396,
                "title": "simple-js-solution",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (called) return undefined;\\n      called = true;\\n      return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (called) return undefined;\\n      called = true;\\n      return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3843912,
                "title": "typescript-based",
                "content": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n  let called: boolean = false;\\n  return function (...args) {\\n    if (called) return undefined;\\n    called = true;\\n    return fn.apply(this,args);\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n  let called: boolean = false;\\n  return function (...args) {\\n    if (called) return undefined;\\n    called = true;\\n    return fn.apply(this,args);\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838780,
                "title": "use-boolearn-internal-to-solve-this-question",
                "content": "# Intuition\\nJust use an internal boolean to test whether it\\'s been called or not.\\nIf not once, one can define a counter to check how many times `fn` can be called.\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let called = false;\\n  return function (...args) {\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let called = false;\\n  return function (...args) {\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837534,
                "title": "day3-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n        if(c==0){\\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n        if(c==0){\\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836632,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = \\'a\\'\\n    return function(...args){\\n        if(limiter == \\'a\\'){\\n            limiter = \\'b\\'\\n            return fn(...args)\\n        }\\n        else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = \\'a\\'\\n    return function(...args){\\n        if(limiter == \\'a\\'){\\n            limiter = \\'b\\'\\n            return fn(...args)\\n        }\\n        else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836615,
                "title": "concise-fast-memory-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the fact that booleans are only two bytes as compared to 4 for ints, setting a simple \"counter\" with bool not only faster but saves memory\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = false\\n    return function(...args){\\n      return (!limiter++) ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = false\\n    return function(...args){\\n      return (!limiter++) ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831581,
                "title": "fast-js-w-o-booleans",
                "content": "# Code\\n```\\nlet once = (fn) => {\\n    return (...args) => { \\n        let x = fn(...args);\\n        fn = () => {};\\n        return x;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet once = (fn) => {\\n    return (...args) => { \\n        let x = fn(...args);\\n        fn = () => {};\\n        return x;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831572,
                "title": "2666-allow-one-function-call-top-96",
                "content": "# Intuition\\nThe goal of this problem is to create a new function that behaves exactly like the original function fn, but it should only execute fn once and return the result on the first call. All subsequent calls to the new function should return undefined.\\n\\n# Approach\\nWe can use a closure to keep track of whether fn has been called before. By using a single variable to store the result of the first call, we can easily determine if the function has already been executed. If it has, we return undefined, otherwise, we call fn and store the result for future reference.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the once function is O(1) because it only performs a constant number of operations, regardless of the number of times the returned function is called.\\n\\n- Space complexity:\\nThe space complexity of the once function is also O(1) because it uses a fixed amount of memory to store the result and whether fn has been called before. The size of the input does not affect the space complexity.\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let result;\\n\\n    return function(...args) {\\n        if (typeof result === \\'undefined\\') {\\n            result = fn(...args);\\n            return result;\\n        } else {\\n            return undefined;\\n        }\\n    };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let result;\\n\\n    return function(...args) {\\n        if (typeof result === \\'undefined\\') {\\n            result = fn(...args);\\n            return result;\\n        } else {\\n            return undefined;\\n        }\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831099,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  return function (...args) {\\n    if (fn) {\\n      let f = fn;\\n      fn = undefined;\\n      return f(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  return function (...args) {\\n    if (fn) {\\n      let f = fn;\\n      fn = undefined;\\n      return f(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819719,
                "title": "beginner-s-attempt-at-a-beginners-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially I figured the simplest way would be to implement some sort of counter variable that would keep track of how many times fn was called.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI initialized the counter variable outside of the return function so that it would not be overwritten.\\n`var counter = 0;`\\n\\nAfter learning that \"...args\" is called a **spread** I was able to understand that \"...args\" is essentially just passing the arguments from \"fn\" to this return function.\\n\\nI then implemented a loop to check if counter is greater than 0. If so it returns \"undefined\". It is important to ensure that you increment counter by 1 each time the function is called.\\n```\\nif (counter > 0) {\\n    return undefined;\\n}\\n\\ncounter++;\\n```\\nAt this stage I ran into a wall with trying to simply input the \"args\" array of values into the fn. This wasn\\'t working but after looking in the Function documents for JavaScript I found a prototype called \"apply\" which is similar to \"call()\" but you are able to pass in an array of values.\\n\\nThe main difference between call() and apply is that call() typically only handles lists of elements like:\\n\\n```\\nfn.call(this, \"value0\", \"value1\", \"value2\", \"...\")\\n\\nconst exampleArray = [\"value0\", \"value1\", \"value2\",\"...\"]\\n\\nfn.apply(this, exampleArray)\\n```\\nWith apply you are also able to call an arbitrary value for the \"this\" if you are calling an existing function:\\n```\\nfn.apply(null, exampleArray)\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) -> Since we are going through each function 1 at a time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    var counter = 0;\\n    \\n    return function(...args){\\n\\n        if (counter > 0) {\\n            return undefined;\\n        }\\n\\n        counter++;\\n\\n        let value = fn.apply(null, args);\\n\\n        return value;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nif (counter > 0) {\\n    return undefined;\\n}\\n\\ncounter++;\\n```\n```\\nfn.call(this, \"value0\", \"value1\", \"value2\", \"...\")\\n\\nconst exampleArray = [\"value0\", \"value1\", \"value2\",\"...\"]\\n\\nfn.apply(this, exampleArray)\\n```\n```\\nfn.apply(null, exampleArray)\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    var counter = 0;\\n    \\n    return function(...args){\\n\\n        if (counter > 0) {\\n            return undefined;\\n        }\\n\\n        counter++;\\n\\n        let value = fn.apply(null, args);\\n\\n        return value;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818939,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function (fn) {\\n    var first_call = true;\\n    return function (...args) {\\n        if (first_call) {\\n            first_call = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function (fn) {\\n    var first_call = true;\\n    return function (...args) {\\n        if (first_call) {\\n            first_call = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815584,
                "title": "just-use-a-boolean-switch",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    <!-- boolean switch -->\\n    let once = true;\\n\\n    return function(...args){        \\n        if(once){\\n            once = false\\n            return fn(...args)\\n        }\\n        return\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    <!-- boolean switch -->\\n    let once = true;\\n\\n    return function(...args){        \\n        if(once){\\n            once = false\\n            return fn(...args)\\n        }\\n        return\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813299,
                "title": "line-by-line-beat-80-90-in-terms-of-time-memory",
                "content": "# Intuition\\nFirst, we have to understand the question thoroughly. It is a skill of its own.\\n\\n1. From the code template: `var once = function(fn){...}` we can derive 2 things:\\n    i. There is a function called `once` with a parameter that is another function. The parameter takes on an argument called `fn`.\\n    ii. Since `once` is a function and can take another function `fn` as an argument, we can conclude that `once` is a higher-order function.\\n\\n2. From the code template: `return function(...args){...}` we can confirm 1 thing:\\n    i. `once` is indeed a higher-order function since it is a function that returns another function.\\n\\n3. `fn` is a function that takes on a parameter of arrays. The arguments have been left as `...args`.\\n\\n**What the question wants**\\n- When `once(fn)` is called, return `fn(...args)` as is.\\n- If `once(fn)` is called for the >1th time, return the value `undefined`.\\n\\n# Approach\\nThere are multiple approaches to this question. I prefer doing each step one at a time.\\n\\n**When `once(fn)` is called, return `fn(...args)` as is:**\\n\\n`return function(...args) {`\\n(when `once(fn)` is called with `...args`...)\\n`result = fn(...args);` \\n(run `fn(...args)` and save the output as a variable called `result`)\\n`return result; }`\\n(return the output stored as `result`)\\n\\nThe first step is now done.\\n\\n**If `once(fn)` is called for the >1th time, return the value `undefined`**\\n\\n`let called = false;`\\n(use a variable called `called` to check if `once(fn)` has been called before)\\n`let result;`\\n(create a variable called `result` which has no value at first, giving an output of `undefined`)\\n\\n`if(called===false){`\\n(if the variable `called` has a value of `false`, run the next lines of code)\\n`called = true;`\\n(change the value of `called` to `true`)\\n\\nNow, the second step is done.\\n\\nI was not able to explain where each line of code should go into. Please check my code solution below to decipher that on your own.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    let result;\\n\\n    return function(...args){\\n        if (called == false) {\\n            called = true;\\n            result = fn(...args);\\n            return result;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    let result;\\n\\n    return function(...args){\\n        if (called == false) {\\n            called = true;\\n            result = fn(...args);\\n            return result;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810623,
                "title": "limiter-function",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0\\n    return function(...args){\\n        if(calls<=0){\\n            calls++\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0\\n    return function(...args){\\n        if(calls<=0){\\n            calls++\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806322,
                "title": "javascript-o-1-solution",
                "content": "# Intuition\\nFlag based approach, early exit if already executed\\n\\n# Approach\\n1. Take a flag and initialize it to false. \\n2. Write the trigger condition for it to be true inside the function capturing the inputs. \\n3. Now that trigger has been set, one line above it, handle the early exit condition for the function when flag value is \"true\"\\n4. Below the trigger, use apply method to pass the captured inputs to the input function.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let executed = false;\\n    return function(...args){\\n        if(executed) return;\\n        executed = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let executed = false;\\n    return function(...args){\\n        if(executed) return;\\n        executed = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805268,
                "title": "crisp-and-clear",
                "content": "\\n\\n# Code\\n```\\nconst once = (fn) => {\\n  let calls = 0\\n  return (...args) => {\\n    if (calls > 0) return \\n    ++calls\\n    return fn(...args.flat(Infinity))\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst once = (fn) => {\\n  let calls = 0\\n  return (...args) => {\\n    if (calls > 0) return \\n    ++calls\\n    return fn(...args.flat(Infinity))\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800962,
                "title": "js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0;\\n    return function(...args){\\n        if (!calls) {\\n            calls++;\\n            return fn(...args)\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0;\\n    return function(...args){\\n        if (!calls) {\\n            calls++;\\n            return fn(...args)\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797338,
                "title": "call-only-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let count = 0\\n  \\n    return function (...args) {\\n        if(!(count > 0)){\\n            count++;\\n            return fn(...args);\\n        }   \\n    };\\n  \\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let count = 0\\n  \\n    return function (...args) {\\n        if(!(count > 0)){\\n            count++;\\n            return fn(...args);\\n        }   \\n    };\\n  \\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796932,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count =0;\\n    return function(...args){\\n       if(count<1){\\n        count++;\\n        return fn(...args)\\n       }else return undefined\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count =0;\\n    return function(...args){\\n       if(count<1){\\n        count++;\\n        return fn(...args)\\n       }else return undefined\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796631,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n      let hasBeenCalled = 0;\\n   return function (...args) {\\n      hasBeenCalled ++;\\n   if(hasBeenCalled==1)\\n    {\\n    return fn(...args); \\n    } \\n    return undefined;\\n   }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n      let hasBeenCalled = 0;\\n   return function (...args) {\\n      hasBeenCalled ++;\\n   if(hasBeenCalled==1)\\n    {\\n    return fn(...args); \\n    } \\n    return undefined;\\n   }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794963,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794962,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794769,
                "title": "javascript-solution-and-order-of-execution",
                "content": "# Execution Order of Code\\nI found this super useful website that shows the order in which JavaScript code gets executed. It\\'s just for anyone who\\'s just starting out with JS like me. Here\\'s the link:  https://pythontutor.com/visualize.html#mode=edit\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\nlet times=[];\\n\\n\\n    return function(...args){\\n  \\n    times.push(1); \\n    if(times.length ===1){\\n        return (fn(...args))\\n        }else {\\n\\n    return undefined}\\n    \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\nlet times=[];\\n\\n\\n    return function(...args){\\n  \\n    times.push(1); \\n    if(times.length ===1){\\n        return (fn(...args))\\n        }else {\\n\\n    return undefined}\\n    \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788847,
                "title": "using-if-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought is clicked on my mind is we need to returns a new function but condition is it will call only once so setting counter to 0 and checking with condition if counter is 0 then increment by 1 and call the function if it will try to run on counter 2 return undefined because we cannot run twice.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconditional statement \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter = 0\\n    return function(...args){\\n        if(counter == 0){\\n            counter ++\\n            return fn(...args)\\n        }else{\\n        return undefined\\n        }\\n        \\n    }\\n\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter = 0\\n    return function(...args){\\n        if(counter == 0){\\n            counter ++\\n            return fn(...args)\\n        }else{\\n        return undefined\\n        }\\n        \\n    }\\n\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1890874,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1951035,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890911,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2017399,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890956,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2005696,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1965347,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891536,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891145,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890795,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890874,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1951035,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890911,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2017399,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890956,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2005696,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1965347,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891536,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891145,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890795,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            }
        ]
    }
]