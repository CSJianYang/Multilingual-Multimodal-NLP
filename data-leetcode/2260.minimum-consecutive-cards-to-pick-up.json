[
    {
        "title": "Maximum Value of K Coins From Piles",
        "question_content": "There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations.\nIn one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.\nGiven a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.\n&nbsp;\nExample 1:\n\nInput: piles = [[1,100,3],[7,8,9]], k = 2\nOutput: 101\nExplanation:\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n\nExample 2:\n\nInput: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\nOutput: 706\nExplanation:\nThe maximum total can be obtained if we choose all coins from the last pile.\n\n&nbsp;\nConstraints:\n\n\tn == piles.length\n\t1 <= n <= 1000\n\t1 <= piles[i][j] <= 105\n\t1 <= k <= sum(piles[i].length) <= 2000",
        "solutions": [
            {
                "id": 1887010,
                "title": "java-c-python-top-down-dp-solution",
                "content": "# **Intuition**\\nTop down dynamic programming.\\nAlso noticed that some people already get accepted, a dp program.\\n<br>\\n\\n# **Explanation**\\n`dp[i,k]` means picking `k` elements from `pile[i]` to `pile[n-1]`.\\nWe can pick 0,1,2,3... elements from the current `pile[i]` one by one.\\nIt asks for the maximum total value of coins we can have,\\nso we need to return `max` of all the options.\\n<br>\\n\\n# **Complexity**\\nTime `O(nm)`\\nSpace `O(nk)`\\nwhere `m = sum(piles[i].length) <= 2000`\\n<br>\\n\\n**Java**\\nFrom @ssmegentle\\n```java\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        Integer[][] memo = new Integer[piles.size() + 1][k + 1];\\n\\n        return dp(piles, memo, 0, k);\\n    }\\n    public int dp(List<List<Integer>> piles, Integer[][] memo, int i, int k) {\\n        if (k == 0 || i == piles.size()) return 0;\\n        if (memo[i][k] != null) return memo[i][k];\\n\\n        int res = dp(piles, memo, i + 1, k);\\n        int cur = 0;\\n\\n        for (int j = 0; j < Math.min(piles.get(i).size(), k); ++j) {\\n            cur += piles.get(i).get(j);\\n            res = Math.max(res, cur + dp(piles, memo, i + 1, k - j - 1));\\n        }\\n        return memo[i][k] = res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxValueOfCoins(vector<vector<int>>& A, int K) {\\n        int n = A.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(K + 1, 0));\\n        function<int(int, int)> dp = [&](int i, int k) {\\n            if (memo[i][k] > 0) return memo[i][k];\\n            if (i == n || k == 0) return 0;\\n            int res = dp(i + 1, k), cur = 0;\\n            for (int j = 0; j < A[i].size() && j < k; ++j) {\\n                cur += A[i][j];\\n                res = max(res, dp(i + 1, k - j - 1) + cur);\\n            }\\n            memo[i][k] = res;\\n            return res;\\n        };\\n        return dp(0, K);\\n    }\\n```\\n**Python**\\n```py\\n    def maxValueOfCoins(self, A, K):\\n        \\n        @functools.lru_cache(None)\\n        def dp(i, k):\\n            if k == 0 or i == len(A): return 0\\n            res, cur = dp(i + 1, k), 0\\n            for j in range(min(len(A[i]), k)):\\n                cur += A[i][j]\\n                res = max(res, cur + dp(i+1, k-j-1))\\n            return res\\n        \\n        return dp(0, K)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        Integer[][] memo = new Integer[piles.size() + 1][k + 1];\\n\\n        return dp(piles, memo, 0, k);\\n    }\\n    public int dp(List<List<Integer>> piles, Integer[][] memo, int i, int k) {\\n        if (k == 0 || i == piles.size()) return 0;\\n        if (memo[i][k] != null) return memo[i][k];\\n\\n        int res = dp(piles, memo, i + 1, k);\\n        int cur = 0;\\n\\n        for (int j = 0; j < Math.min(piles.get(i).size(), k); ++j) {\\n            cur += piles.get(i).get(j);\\n            res = Math.max(res, cur + dp(piles, memo, i + 1, k - j - 1));\\n        }\\n        return memo[i][k] = res;\\n    }\\n```\n```cpp\\n    int maxValueOfCoins(vector<vector<int>>& A, int K) {\\n        int n = A.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(K + 1, 0));\\n        function<int(int, int)> dp = [&](int i, int k) {\\n            if (memo[i][k] > 0) return memo[i][k];\\n            if (i == n || k == 0) return 0;\\n            int res = dp(i + 1, k), cur = 0;\\n            for (int j = 0; j < A[i].size() && j < k; ++j) {\\n                cur += A[i][j];\\n                res = max(res, dp(i + 1, k - j - 1) + cur);\\n            }\\n            memo[i][k] = res;\\n            return res;\\n        };\\n        return dp(0, K);\\n    }\\n```\n```py\\n    def maxValueOfCoins(self, A, K):\\n        \\n        @functools.lru_cache(None)\\n        def dp(i, k):\\n            if k == 0 or i == len(A): return 0\\n            res, cur = dp(i + 1, k), 0\\n            for j in range(min(len(A[i]), k)):\\n                cur += A[i][j]\\n                res = max(res, cur + dp(i+1, k-j-1))\\n            return res\\n        \\n        return dp(0, K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3417959,
                "title": "image-explanation-top-down-dp-easy-concise-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Maximum Value of K Coins From Piles` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/9eaa66d1-03e7-4394-93c0-4875df24d5d7_1681526852.9686515.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/91939f49-936e-4f8b-97d7-3d48ebd5355f_1681522506.1156633.png)\\n![image.png](https://assets.leetcode.com/users/images/b1342805-93ea-4693-948d-8c1b0702a36a_1681522520.1675975.png)\\n![image.png](https://assets.leetcode.com/users/images/61d2fbf7-ce76-4475-8495-c2697471c49c_1681522531.6415837.png)\\n![image.png](https://assets.leetcode.com/users/images/5aab26d9-86f1-4b11-af58-776da724f822_1681522548.880134.png)\\n![image.png](https://assets.leetcode.com/users/images/af325b84-0f8b-4825-b3ef-3d2239aed68b_1681522557.3164456.png)\\n![image.png](https://assets.leetcode.com/users/images/3af07571-8d76-486f-96df-540499f3110e_1681522565.693431.png)\\n![image.png](https://assets.leetcode.com/users/images/319fcde5-983d-4ed5-bba1-29c5ee4eed9a_1681522573.987136.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int func(int i, int k, vector<vector<int>>& piles, vector<vector<int>>& dp){\\n        if (dp[i][k] > 0) return dp[i][k];\\n        if (i == piles.size() || k == 0) return 0;\\n        int res = func(i + 1, k, piles, dp), cur = 0;\\n        for (int j = 0; j < piles[i].size() && j < k; ++j) {\\n            cur += piles[i][j];\\n            res = max(res, func(i + 1, k - j - 1, piles, dp) + cur);\\n        }\\n        dp[i][k] = res;\\n        return res;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int K) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(K + 1, 0));\\n        return func(0, K, piles, dp);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int func(int i, int k, List<List<Integer>> piles, int[][] dp) {\\n        if (dp[i][k] > 0) return dp[i][k];\\n        if (i == piles.size() || k == 0) return 0;\\n        int res = func(i + 1, k, piles, dp), cur = 0;\\n        for (int j = 0; j < piles.get(i).size() && j < k; ++j) {\\n            cur += piles.get(i).get(j);\\n            res = Math.max(res, func(i + 1, k - j - 1, piles, dp) + cur);\\n        }\\n        dp[i][k] = res;\\n        return res;\\n    }\\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        int[][] dp = new int[n + 1][K + 1];\\n        return func(0, K, piles, dp);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def _search(rest_k: int, pile_pos: int) -> int:\\n            \"\"\"Searches for best accumulated coin value starting from pile at position `pile_pos`.\\n            \\n            Args:\\n              - rest_k: The rest of coins we could pick.\\n              - pile_pos: The starting position of pile we are working on.\\n            \"\"\"\\n            if rest_k == 0 or pile_pos == len(piles): return 0\\n\\n            # Ignore the current pile and moving to next pile\\n            current_mv_found = _search(rest_k, pile_pos+1)\\n\\n            # Start looking solution with current pile being involved\\n            current_pile = piles[pile_pos]\\n            accum_coin_value = 0\\n            for i in range(min(rest_k, len(current_pile))):\\n                # Accumulate the coins\\n                accum_coin_value += current_pile[i]\\n\\n                # Moving to next pile with accumulated coin value in current pile\\n                current_mv_found = max(\\n                    current_mv_found, \\n                    accum_coin_value + _search(rest_k-i-1, pile_pos+1))\\n\\n            # Return the maximum accumulated coin value found from current pile.\\n            return current_mv_found\\n\\n        # Start searching with initial `k` and first pile\\n        return _search(k, 0)\\n```\\nCredits: Python Solution commented beautifully by @puremonkey2001\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int func(int i, int k, vector<vector<int>>& piles, vector<vector<int>>& dp){\\n        if (dp[i][k] > 0) return dp[i][k];\\n        if (i == piles.size() || k == 0) return 0;\\n        int res = func(i + 1, k, piles, dp), cur = 0;\\n        for (int j = 0; j < piles[i].size() && j < k; ++j) {\\n            cur += piles[i][j];\\n            res = max(res, func(i + 1, k - j - 1, piles, dp) + cur);\\n        }\\n        dp[i][k] = res;\\n        return res;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int K) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(K + 1, 0));\\n        return func(0, K, piles, dp);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int func(int i, int k, List<List<Integer>> piles, int[][] dp) {\\n        if (dp[i][k] > 0) return dp[i][k];\\n        if (i == piles.size() || k == 0) return 0;\\n        int res = func(i + 1, k, piles, dp), cur = 0;\\n        for (int j = 0; j < piles.get(i).size() && j < k; ++j) {\\n            cur += piles.get(i).get(j);\\n            res = Math.max(res, func(i + 1, k - j - 1, piles, dp) + cur);\\n        }\\n        dp[i][k] = res;\\n        return res;\\n    }\\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        int[][] dp = new int[n + 1][K + 1];\\n        return func(0, K, piles, dp);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def _search(rest_k: int, pile_pos: int) -> int:\\n            \"\"\"Searches for best accumulated coin value starting from pile at position `pile_pos`.\\n            \\n            Args:\\n              - rest_k: The rest of coins we could pick.\\n              - pile_pos: The starting position of pile we are working on.\\n            \"\"\"\\n            if rest_k == 0 or pile_pos == len(piles): return 0\\n\\n            # Ignore the current pile and moving to next pile\\n            current_mv_found = _search(rest_k, pile_pos+1)\\n\\n            # Start looking solution with current pile being involved\\n            current_pile = piles[pile_pos]\\n            accum_coin_value = 0\\n            for i in range(min(rest_k, len(current_pile))):\\n                # Accumulate the coins\\n                accum_coin_value += current_pile[i]\\n\\n                # Moving to next pile with accumulated coin value in current pile\\n                current_mv_found = max(\\n                    current_mv_found, \\n                    accum_coin_value + _search(rest_k-i-1, pile_pos+1))\\n\\n            # Return the maximum accumulated coin value found from current pile.\\n            return current_mv_found\\n\\n        # Start searching with initial `k` and first pile\\n        return _search(k, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418129,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be approached using dynamic programming by breaking it down into subproblems. We can create a 2D array dp[i][j] to store the maximum value of coins for choosing j coins from the first i piles. Then, we can iterate through the array and compute the maximum value of coins for each subproblem by trying all possible choices for the current pile and updating the maximum result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a 2D array dp[i][j] to store the maximum value of coins for choosing j coins from the first i piles.\\n2. Fill the first row and column of the array with zeros.\\n3. Iterate through the array and compute the maximum value of coins for each subproblem by trying all possible choices for the current pile and updating the maximum result.\\n4. If not choosing any coin from the current pile gives a better result, use that instead.\\n5. The last element of the array is the maximum value of coins for choosing k coins from all the piles.\\n\\n  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3), where n is the maximum number of coins in a pile. The outer loop runs n times, the inner loop runs k times, and the innermost loop runs n times in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nk), since we are using a 2D array of size (n+1) x (k+1) to store the results.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        // create a 2D array to store the maximum value of coins for choosing j coins from the first i piles\\n        int[][] dp = new int[piles.size() + 1][k + 1];\\n        // fill the first row of the array with zeros\\n        Arrays.fill(dp[0], 0);\\n        // fill the first column of the array with zeros\\n        for (int i = 1; i <= piles.size(); i++) {\\n            dp[i][0] = 0;\\n        }\\n        // iterate through the array and compute the maximum value of coins for each subproblem\\n        for (int i = 1; i <= piles.size(); i++) {\\n            for (int j = 1; j <= k; j++) {\\n                int cur = 0;\\n                // try all possible choices for the current pile and update the maximum result\\n                for (int x = 0; x < Math.min(piles.get(i - 1).size(), j); x++) {\\n                    cur += piles.get(i - 1).get(x);\\n                    dp[i][j] = Math.max(dp[i][j], cur + dp[i - 1][j - x - 1]);\\n                }\\n                // if not choosing any coin from the current pile gives a better result, use that instead\\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n            }\\n        }\\n        // the last element of the array is the maximum value of coins for choosing k coins from all the piles\\n        return dp[piles.size()][k];\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * @param {number[][]} piles\\n * @param {number} k\\n * @return {number}\\n */\\n \\nvar maxValueOfCoins = function(piles, k) {\\n    // Initialize a 2D array dp with dimensions (n+1) x (k+1) to store the maximum value of coins\\n    // for choosing j coins from the first i piles\\n    const n = piles.length;\\n    const dp = Array(n + 1).fill().map(() => Array(k + 1).fill(0));\\n    \\n    // Iterate through the rows of dp and compute the maximum value of coins for each subproblem\\n    for (let i = 1; i <= n; i++) {\\n        // Iterate through the columns of dp and compute the maximum value of coins for each subproblem\\n        for (let j = 1; j <= k; j++) {\\n            let cur = 0;\\n            // Iterate through the first j coins of the ith pile and compute the maximum value of coins\\n            // for choosing x coins from the ith pile and (j-x) coins from the first (i-1) piles\\n            for (let x = 0; x < Math.min(j, piles[i-1].length); x++) {\\n                cur += piles[i-1][x];\\n                dp[i][j] = Math.max(dp[i][j], cur + dp[i-1][j-x-1]);\\n            }\\n            // Take the maximum value of coins for choosing j coins from the first (i-1) piles\\n            dp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\\n        }\\n    }\\n    // Return the maximum value of coins for choosing k coins from all the piles\\n    return dp[n][k];\\n};\\n\\n```\\n```python []\\nclass Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        \"\"\"\\n        :type piles: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0] * (k + 1) for _ in range(len(piles) + 1)]\\n        for i in range(1, len(piles) + 1):\\n            for j in range(1, k + 1):\\n                cur = 0\\n                for x in range(min(len(piles[i - 1]), j)):\\n                    cur += piles[i - 1][x]\\n                    dp[i][j] = max(dp[i][j], cur + dp[i - 1][j - x - 1])\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\\n        return dp[len(piles)][k]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                int cur = 0;\\n                for (int x = 0; x < min(j, (int)piles[i-1].size()); x++) {\\n                    cur += piles[i-1][x];\\n                    dp[i][j] = max(dp[i][j], cur + dp[i-1][j-x-1]);\\n                }\\n                dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        // create a 2D array to store the maximum value of coins for choosing j coins from the first i piles\\n        int[][] dp = new int[piles.size() + 1][k + 1];\\n        // fill the first row of the array with zeros\\n        Arrays.fill(dp[0], 0);\\n        // fill the first column of the array with zeros\\n        for (int i = 1; i <= piles.size(); i++) {\\n            dp[i][0] = 0;\\n        }\\n        // iterate through the array and compute the maximum value of coins for each subproblem\\n        for (int i = 1; i <= piles.size(); i++) {\\n            for (int j = 1; j <= k; j++) {\\n                int cur = 0;\\n                // try all possible choices for the current pile and update the maximum result\\n                for (int x = 0; x < Math.min(piles.get(i - 1).size(), j); x++) {\\n                    cur += piles.get(i - 1).get(x);\\n                    dp[i][j] = Math.max(dp[i][j], cur + dp[i - 1][j - x - 1]);\\n                }\\n                // if not choosing any coin from the current pile gives a better result, use that instead\\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n            }\\n        }\\n        // the last element of the array is the maximum value of coins for choosing k coins from all the piles\\n        return dp[piles.size()][k];\\n    }\\n}\\n```\n```javascript []\\n/**\\n * @param {number[][]} piles\\n * @param {number} k\\n * @return {number}\\n */\\n \\nvar maxValueOfCoins = function(piles, k) {\\n    // Initialize a 2D array dp with dimensions (n+1) x (k+1) to store the maximum value of coins\\n    // for choosing j coins from the first i piles\\n    const n = piles.length;\\n    const dp = Array(n + 1).fill().map(() => Array(k + 1).fill(0));\\n    \\n    // Iterate through the rows of dp and compute the maximum value of coins for each subproblem\\n    for (let i = 1; i <= n; i++) {\\n        // Iterate through the columns of dp and compute the maximum value of coins for each subproblem\\n        for (let j = 1; j <= k; j++) {\\n            let cur = 0;\\n            // Iterate through the first j coins of the ith pile and compute the maximum value of coins\\n            // for choosing x coins from the ith pile and (j-x) coins from the first (i-1) piles\\n            for (let x = 0; x < Math.min(j, piles[i-1].length); x++) {\\n                cur += piles[i-1][x];\\n                dp[i][j] = Math.max(dp[i][j], cur + dp[i-1][j-x-1]);\\n            }\\n            // Take the maximum value of coins for choosing j coins from the first (i-1) piles\\n            dp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\\n        }\\n    }\\n    // Return the maximum value of coins for choosing k coins from all the piles\\n    return dp[n][k];\\n};\\n\\n```\n```python []\\nclass Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        \"\"\"\\n        :type piles: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0] * (k + 1) for _ in range(len(piles) + 1)]\\n        for i in range(1, len(piles) + 1):\\n            for j in range(1, k + 1):\\n                cur = 0\\n                for x in range(min(len(piles[i - 1]), j)):\\n                    cur += piles[i - 1][x]\\n                    dp[i][j] = max(dp[i][j], cur + dp[i - 1][j - x - 1])\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\\n        return dp[len(piles)][k]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                int cur = 0;\\n                for (int x = 0; x < min(j, (int)piles[i-1].size()); x++) {\\n                    cur += piles[i-1][x];\\n                    dp[i][j] = max(dp[i][j], cur + dp[i-1][j-x-1]);\\n                }\\n                dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886905,
                "title": "python-dp-solution-complexity-updated-explained",
                "content": "Let use dp with states `dp(n, k)`, where it is `(current index of pile, nubmer of elements we still need to take)`. Then on each state we can try to take `0, ..., min(k, len(piles[m]))` elements from pile `m`. Also if `n == N`, that is we reached the last pile and `k == 0`, we are happy, return `0`. If `k > 0`, it means that we reached the last pile and did not take `k` elements, we are not happy, return `-inf`.\\n\\n#### Complexity\\nImagine, that piles have `x1, ..., xn` elements in them. Then for state `(1, k)` we have `x1` possible transactions, for state `(2, k)` we have `x2` possible transactions and so on. In total we have `x1 + ... + xn` transactions for every value of `k`. So, in total we have time complexity `O(M * K)`, where `M = x1 + ... + xn`. Space is `O(n * K)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles, K):\\n        N = len(piles)\\n        @lru_cache(None)\\n        def dp(n, k):\\n            if n == N:\\n                if k == 0: return 0\\n                if k > 0: return -float(\"inf\")\\n            ans = dp(n + 1, k)\\n            sm = 0\\n            for i in range(min(k, len(piles[n]))):\\n                sm += piles[n][i]\\n                ans = max(ans, dp(n + 1, k - i - 1) + sm)\\n            return ans\\n\\n        return dp(0, K)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles, K):\\n        N = len(piles)\\n        @lru_cache(None)\\n        def dp(n, k):\\n            if n == N:\\n                if k == 0: return 0\\n                if k > 0: return -float(\"inf\")\\n            ans = dp(n + 1, k)\\n            sm = 0\\n            for i in range(min(k, len(piles[n]))):\\n                sm += piles[n][i]\\n                ans = max(ans, dp(n + 1, k - i - 1) + sm)\\n            return ans\\n\\n        return dp(0, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886912,
                "title": "again-knapsack-variation-easy-to-understand",
                "content": "TC - O(N*M) n=size of piles, m=size of piles[i]\\n**JAVA**\\n```\\nclass Solution {\\n    Integer dp[][];\\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        this.dp = new Integer[piles.size() + 1][k + 1];\\n        return solve(0, piles, k);\\n    }\\n\\n    private int solve(int index, List<List<Integer>> p, int k) {\\n        if (index >= p.size()) return 0;\\n        int max = 0, sum = 0;\\n        if (dp[index][k] != null) return dp[index][k];\\n        //either dont take from that pile\\n        max = Math.max(max, solve(index + 1, p, k));\\n        for (int i = 0; i < p.get(index).size(); i++) {\\n            sum += p.get(index).get(i);\\n            //or take some certain prefix from that pile, if we can take that much elements.\\n            if (k - (i + 1) >= 0) max = Math.max(max, sum + solve(index + 1, p, k - (i + 1)));\\n        }\\n        return dp[index][k] = max; // return max\\n    }\\n}\\n```\\n**CPP**\\n```\\nclass Solution {\\n    public:\\n        int dp[2001][2001] = { 0 };\\n    int maxValueOfCoins(vector < vector < int >> & piles, int k) {\\n        return solve(0, piles, k);\\n    }\\n    int solve(int index, vector < vector < int >> & piles, int k) {\\n        if (index >= piles.size()) return 0;\\n        if (dp[index][k] != 0) return dp[index][k];\\n        int maxi = 0, sum = 0;\\n        //either dont take from that pile\\n        maxi = max(maxi, solve(index + 1, piles, k));\\n        for (int i = 0; i < piles[index].size(); i++) {\\n            sum += piles[index][i];\\n            //or take some certain prefix from that pile, if we can take that much elements.\\n            if (k - (i + 1) >= 0) maxi = max(maxi, sum + solve(index + 1, piles, k - (i + 1)));\\n        }\\n        return dp[index][k] = maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][];\\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        this.dp = new Integer[piles.size() + 1][k + 1];\\n        return solve(0, piles, k);\\n    }\\n\\n    private int solve(int index, List<List<Integer>> p, int k) {\\n        if (index >= p.size()) return 0;\\n        int max = 0, sum = 0;\\n        if (dp[index][k] != null) return dp[index][k];\\n        //either dont take from that pile\\n        max = Math.max(max, solve(index + 1, p, k));\\n        for (int i = 0; i < p.get(index).size(); i++) {\\n            sum += p.get(index).get(i);\\n            //or take some certain prefix from that pile, if we can take that much elements.\\n            if (k - (i + 1) >= 0) max = Math.max(max, sum + solve(index + 1, p, k - (i + 1)));\\n        }\\n        return dp[index][k] = max; // return max\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public:\\n        int dp[2001][2001] = { 0 };\\n    int maxValueOfCoins(vector < vector < int >> & piles, int k) {\\n        return solve(0, piles, k);\\n    }\\n    int solve(int index, vector < vector < int >> & piles, int k) {\\n        if (index >= piles.size()) return 0;\\n        if (dp[index][k] != 0) return dp[index][k];\\n        int maxi = 0, sum = 0;\\n        //either dont take from that pile\\n        maxi = max(maxi, solve(index + 1, piles, k));\\n        for (int i = 0; i < piles[index].size(); i++) {\\n            sum += piles[index][i];\\n            //or take some certain prefix from that pile, if we can take that much elements.\\n            if (k - (i + 1) >= 0) maxi = max(maxi, sum + solve(index + 1, piles, k - (i + 1)));\\n        }\\n        return dp[index][k] = maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887130,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int maxValueOfCoins(vector<vector < int>> &p, int k)\\n        {\\n            int n = p.size();\\n            vector<vector < int>> dp(n + 1, vector<int> (k + 1, -1));\\n            return solve(0, dp, p, k);\\n        }\\n        int solve(int index, vector<vector < int>> &dp, vector< vector< int>> &p, int k)\\n        {\\n            if (index >= p.size())\\n                return 0;\\n\\n            int maxi = 0, sum = 0;\\n\\n            if (dp[index][k] != -1)\\n                return dp[index][k];\\n            \\n            //dont take from that pile\\n            maxi = max(maxi, solve(index + 1, dp, p, k));\\n\\n            for (int i = 0; i < p[index].size(); i++)\\n            {\\n                sum += p[index][i];\\n                \\n                //take some certain prefix from that pile, if we can take that much elements.\\n                if (k - (i + 1) >= 0)\\n                    maxi = max(maxi, sum + solve(index + 1, dp, p, k - (i + 1)));\\n            }\\n            return dp[index][k] = maxi;\\t// return max\\n        }\\n};\\n```\\n\\nC++ version of @x21svage \\'s code",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxValueOfCoins(vector<vector < int>> &p, int k)\\n        {\\n            int n = p.size();\\n            vector<vector < int>> dp(n + 1, vector<int> (k + 1, -1));\\n            return solve(0, dp, p, k);\\n        }\\n        int solve(int index, vector<vector < int>> &dp, vector< vector< int>> &p, int k)\\n        {\\n            if (index >= p.size())\\n                return 0;\\n\\n            int maxi = 0, sum = 0;\\n\\n            if (dp[index][k] != -1)\\n                return dp[index][k];\\n            \\n            //dont take from that pile\\n            maxi = max(maxi, solve(index + 1, dp, p, k));\\n\\n            for (int i = 0; i < p[index].size(); i++)\\n            {\\n                sum += p[index][i];\\n                \\n                //take some certain prefix from that pile, if we can take that much elements.\\n                if (k - (i + 1) >= 0)\\n                    maxi = max(maxi, sum + solve(index + 1, dp, p, k - (i + 1)));\\n            }\\n            return dp[index][k] = maxi;\\t// return max\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418438,
                "title": "easy-dp-solution-approach-explained-beginner-friendly",
                "content": "# Intuition\\nThe intuition here is to understand that when we are on any currentPile we have two choices\\n- either to exclude that pile and move on to next one or\\n- pick from currentPile one or two or three coins and so on till <= K(coinsLeft to pick) and currentPile is not exhausted of coins and then move on to new pile if coins are left\\n\\nNow when we try to solve with above approach, we see that there are repeating sub problems so we will go ahead and store results of repeating subproblems in a 2D DP array.\\n\\nDP[i][j] represent the max-value of coins(or sum) from j coins, when we are on ith pile.\\n\\n---\\n\\n\\n# Approach\\n1) We declare dp[n+1][k+1], we need to intialise DP with some variable so that we know if we have solved that subproblem so either intialise all elements *by -1* or i have made *dp = new Integer[][]* so that by default it is intialised *to null values*.\\n\\n2) Following top down approach we start iterating from last pile\\n- check base conditions\\n- return if we have already solved for that case already\\n\\n3) If above coditions don\\'t pass then we calcualte what is coinPickLimit\\n```\\nint coinsPickLimit = Math.min(coinsLeft, piles.get(currentPile).size());\\n```\\nminmium we are taking since the each piles coins can get exhausted if we plan to take multiple coins from it.\\n\\n4) for currentPile either we \\n- exclude it and move on to next pile \\n```\\nint excludeCurrentPile = helper(piles, currentPile-1, coinsLeft);\\n```\\n- or we include the currentPile and take 1 or 2 or .. coins from it(so for loop), we calculate sum and move onto next pile. Each time we pick a coin from curretPile we add to sum and move on to next pile get the result, we can repeat this till cointsLeftLimit.\\n\\nSo we calculate all possiblities of currentPile if we take one coint move on to next pile, then if we took 2 coins from currentPile and moved on to next pile and so on\\n\\nNow we have both result from excludeCurrentPile, includeCurentPile we do\\n```\\nMath.max(includeCurentPile, excludeCurrentPile)\\n```\\nand set it to dp[currentPile][coinsLeft]\\n\\nTry dry the code with 3 piles you will get the idea and why dp is imp as we are reusing our results.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\nO(n*k) where n is the total number of coins in all the piles\\n\\n---\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n----\\n\\n# Code\\n```\\nclass Solution {\\n    private Integer dp[][];\\n    private int helper(List<List<Integer>> piles, int currentPile, int coinsLeft){\\n        if(currentPile<0 || coinsLeft == 0)\\n            return 0;\\n        if(dp[currentPile][coinsLeft]!=null)\\n            return dp[currentPile][coinsLeft];\\n\\n        int coinsPickLimit = Math.min(coinsLeft, piles.get(currentPile).size());\\n\\n        //not including that currentPile, so coinsLeft remain same\\n        int excludeCurrentPile = helper(piles, currentPile-1, coinsLeft);\\n        \\n        int includeCurentPile=0;\\n        for(int j=0, sum=0; j<coinsPickLimit ; j++){\\n            sum+= piles.get(currentPile).get(j);\\n            //doing coinsLeft-(j+1) as we are starting from index 0 and coin picked cannot pe 0 if we pick it is > 0\\n            includeCurentPile = Math.max(sum + helper(piles, currentPile-1, coinsLeft-(j+1)), includeCurentPile);\\n        }\\n        \\n        int res = Math.max(includeCurentPile, excludeCurrentPile);\\n        dp[currentPile][coinsLeft] = res;\\n        return res;\\n\\n    } \\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        dp = new Integer[n + 1][K + 1];\\n        return helper(piles, n-1, K);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint coinsPickLimit = Math.min(coinsLeft, piles.get(currentPile).size());\\n```\n```\\nint excludeCurrentPile = helper(piles, currentPile-1, coinsLeft);\\n```\n```\\nMath.max(includeCurentPile, excludeCurrentPile)\\n```\n```\\nclass Solution {\\n    private Integer dp[][];\\n    private int helper(List<List<Integer>> piles, int currentPile, int coinsLeft){\\n        if(currentPile<0 || coinsLeft == 0)\\n            return 0;\\n        if(dp[currentPile][coinsLeft]!=null)\\n            return dp[currentPile][coinsLeft];\\n\\n        int coinsPickLimit = Math.min(coinsLeft, piles.get(currentPile).size());\\n\\n        //not including that currentPile, so coinsLeft remain same\\n        int excludeCurrentPile = helper(piles, currentPile-1, coinsLeft);\\n        \\n        int includeCurentPile=0;\\n        for(int j=0, sum=0; j<coinsPickLimit ; j++){\\n            sum+= piles.get(currentPile).get(j);\\n            //doing coinsLeft-(j+1) as we are starting from index 0 and coin picked cannot pe 0 if we pick it is > 0\\n            includeCurentPile = Math.max(sum + helper(piles, currentPile-1, coinsLeft-(j+1)), includeCurentPile);\\n        }\\n        \\n        int res = Math.max(includeCurentPile, excludeCurrentPile);\\n        dp[currentPile][coinsLeft] = res;\\n        return res;\\n\\n    } \\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        dp = new Integer[n + 1][K + 1];\\n        return helper(piles, n-1, K);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417927,
                "title": "recursion-top-down-bottom-up-easy-to-understand-code",
                "content": "### RECURSION, TLE\\n```\\nclass Solution {\\npublic:\\n    //startPileIdx is always 0\\n    //piles under consideration for each call ==> [pileIdx = 0 to pileIdx = endPileIdx]\\n    int solve(vector<vector<int>>&piles, int endPileIdx, int k)\\n    {\\n        if (endPileIdx < 0 || k == 0) return 0;\\n        \\n        int currPileSize = piles[endPileIdx].size(); \\n        int maxCanPick = min(k, currPileSize);\\n        \\n        //consider \\'not picking\\' any coin\\n        int maxSum = solve(piles, endPileIdx - 1, k);  //DON\\'T PICK ANY COIN FROM CURR PILE\\n        int pickedSum = 0;\\n        //===============================================================================\\n        //now consider picking some coins\\n        for (int i = 0; i < maxCanPick; i++)\\n        {\\n            int coinValue = piles[endPileIdx][i];\\n            pickedSum += coinValue;\\n            \\n            int nextMaxSum = solve(piles, endPileIdx - 1, k - i - 1); \\n            maxSum = max(maxSum, pickedSum + nextMaxSum);\\n        }\\n        //=================================================================================\\n        return maxSum;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        int ans = solve(piles, n - 1, k);\\n        return ans;\\n        \\n    }\\n};\\n```\\n//====================================================================================================================\\n\\n### TOP DOWN [Memoization], Accepted\\n```\\nclass Solution {\\npublic:\\n    //startPileIdx is always 0\\n    //piles under consideration for each call ==> [pileIdx = 0 to pileIdx = endPileIdx]\\n    int solve(vector<vector<int>>&piles, vector<vector<int>>&dp, int endPileIdx, int k)\\n    {\\n        if (endPileIdx < 0 || k == 0) return 0;\\n        if (dp[endPileIdx][k] != -1) return dp[endPileIdx][k];\\n        \\n        int currPileSize = piles[endPileIdx].size(); \\n        int maxCanPick = min(k, currPileSize);\\n        \\n        //consider \\'not picking\\' any coin\\n        int maxSum = solve(piles, dp, endPileIdx - 1, k);  //DON\\'T PICK ANY COIN FROM CURR PILE\\n        int pickedSum = 0;\\n        //===============================================================================\\n        //now consider picking some coins\\n        for (int i = 0; i < maxCanPick; i++)\\n        {\\n            int coinValue = piles[endPileIdx][i];\\n            pickedSum += coinValue;\\n            \\n            int nextMaxSum = solve(piles, dp, endPileIdx - 1, k - i - 1); \\n            maxSum = max(maxSum, pickedSum + nextMaxSum);\\n        }\\n        //=================================================================================\\n        return dp[endPileIdx][k] = maxSum;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(k + 1, -1));\\n        int ans = solve(piles, dp, n - 1, k);\\n        return ans;\\n    }\\n};\\n```\\n//================================================================================================================================\\n\\n### BOTTOM UP, Accepted\\n\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(k + 1, 0)); \\n        //for considering [number of piles = n]\\n        //we must already have answers for [number of piles = (n - 1)]\\n        //thus we need to go bottom up\\n        //we need to go from [no. of piles under consideration = 1 to n]\\n        \\n        //consider only (endPileIdx + 1) number of piles at a time\\n        for (int endPileIdx = 0; endPileIdx < n; endPileIdx++) //count of piles = endPileIdx + 1\\n        {\\n            int currPileSize = piles[endPileIdx].size();\\n            for (int coinsToPick = 1; coinsToPick <= k; coinsToPick++)\\n            {\\n                //=============================================================================\\n                //DON\\'T PICK ANY COIN FROM CURR PILE\\n                int maxSum = (endPileIdx - 1 < 0)? 0 : dp[endPileIdx - 1][coinsToPick];  \\n                \\n                int maxCanPick = min(coinsToPick, currPileSize);\\n                int pickedSum = 0;\\n                //now consider picking some coins\\n                for (int i = 0; i < maxCanPick; i++)\\n                {\\n                    int coinValue = piles[endPileIdx][i];\\n                    pickedSum += coinValue;\\n                    \\n                    int nextMaxSum = 0;\\n                    if (endPileIdx > 0) \\n                        nextMaxSum = dp[endPileIdx - 1][coinsToPick - i - 1];\\n                    maxSum = max(maxSum, pickedSum + nextMaxSum);\\n                }\\n                //=======================================================================================\\n                dp[endPileIdx][coinsToPick] = maxSum;\\n            }\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n````\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //startPileIdx is always 0\\n    //piles under consideration for each call ==> [pileIdx = 0 to pileIdx = endPileIdx]\\n    int solve(vector<vector<int>>&piles, int endPileIdx, int k)\\n    {\\n        if (endPileIdx < 0 || k == 0) return 0;\\n        \\n        int currPileSize = piles[endPileIdx].size(); \\n        int maxCanPick = min(k, currPileSize);\\n        \\n        //consider \\'not picking\\' any coin\\n        int maxSum = solve(piles, endPileIdx - 1, k);  //DON\\'T PICK ANY COIN FROM CURR PILE\\n        int pickedSum = 0;\\n        //===============================================================================\\n        //now consider picking some coins\\n        for (int i = 0; i < maxCanPick; i++)\\n        {\\n            int coinValue = piles[endPileIdx][i];\\n            pickedSum += coinValue;\\n            \\n            int nextMaxSum = solve(piles, endPileIdx - 1, k - i - 1); \\n            maxSum = max(maxSum, pickedSum + nextMaxSum);\\n        }\\n        //=================================================================================\\n        return maxSum;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        int ans = solve(piles, n - 1, k);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //startPileIdx is always 0\\n    //piles under consideration for each call ==> [pileIdx = 0 to pileIdx = endPileIdx]\\n    int solve(vector<vector<int>>&piles, vector<vector<int>>&dp, int endPileIdx, int k)\\n    {\\n        if (endPileIdx < 0 || k == 0) return 0;\\n        if (dp[endPileIdx][k] != -1) return dp[endPileIdx][k];\\n        \\n        int currPileSize = piles[endPileIdx].size(); \\n        int maxCanPick = min(k, currPileSize);\\n        \\n        //consider \\'not picking\\' any coin\\n        int maxSum = solve(piles, dp, endPileIdx - 1, k);  //DON\\'T PICK ANY COIN FROM CURR PILE\\n        int pickedSum = 0;\\n        //===============================================================================\\n        //now consider picking some coins\\n        for (int i = 0; i < maxCanPick; i++)\\n        {\\n            int coinValue = piles[endPileIdx][i];\\n            pickedSum += coinValue;\\n            \\n            int nextMaxSum = solve(piles, dp, endPileIdx - 1, k - i - 1); \\n            maxSum = max(maxSum, pickedSum + nextMaxSum);\\n        }\\n        //=================================================================================\\n        return dp[endPileIdx][k] = maxSum;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(k + 1, -1));\\n        int ans = solve(piles, dp, n - 1, k);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(k + 1, 0)); \\n        //for considering [number of piles = n]\\n        //we must already have answers for [number of piles = (n - 1)]\\n        //thus we need to go bottom up\\n        //we need to go from [no. of piles under consideration = 1 to n]\\n        \\n        //consider only (endPileIdx + 1) number of piles at a time\\n        for (int endPileIdx = 0; endPileIdx < n; endPileIdx++) //count of piles = endPileIdx + 1\\n        {\\n            int currPileSize = piles[endPileIdx].size();\\n            for (int coinsToPick = 1; coinsToPick <= k; coinsToPick++)\\n            {\\n                //=============================================================================\\n                //DON\\'T PICK ANY COIN FROM CURR PILE\\n                int maxSum = (endPileIdx - 1 < 0)? 0 : dp[endPileIdx - 1][coinsToPick];  \\n                \\n                int maxCanPick = min(coinsToPick, currPileSize);\\n                int pickedSum = 0;\\n                //now consider picking some coins\\n                for (int i = 0; i < maxCanPick; i++)\\n                {\\n                    int coinValue = piles[endPileIdx][i];\\n                    pickedSum += coinValue;\\n                    \\n                    int nextMaxSum = 0;\\n                    if (endPileIdx > 0) \\n                        nextMaxSum = dp[endPileIdx - 1][coinsToPick - i - 1];\\n                    maxSum = max(maxSum, pickedSum + nextMaxSum);\\n                }\\n                //=======================================================================================\\n                dp[endPileIdx][coinsToPick] = maxSum;\\n            }\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886987,
                "title": "java-bottom-up-dp-with-clear-explanation-and-code",
                "content": "Either pick all k from previous piles, or choose j from current pile and pick k-j from previous piles\\n**Recurrence relation**:\\n`f(n,k)` represents the max sum of coins collected from first `n` piles and choosing `k` top coins.\\n```\\nf(n,k) = max(\\n\\t\\t\\tf(n-1,k) // pick k from previous n-1 piles\\n\\t\\t\\t,max(f(n-1,k-j-1)+sum(0 to j) for j = 0 to min(k,p[n-1].size())) // pick j+1 from current pile and k-j-1 from previous n-1 piles\\n\\t\\t)\\n```\\nif k = 0, i.e. you can\\'t pick any coin then ans = 0\\nif n = 0, i.e. you don\\'t have any piles then ans = 0\\n**Base cases** :\\n`f(0,k) = 0`\\n`f(n,0) = 0`\\n\\n```\\n/*\\nf(i,k) = max(f(i-1,k),max(f(i-1,k-j-1)+sum(j) for j = 0 to max(k,p[i-1].length)))\\nf(i,0) = 0\\nf(0,k) = 0\\n*/\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        int[][] dp = new int[n+1][K+1];\\n        \\n        for(int i = 1; i <= n; i ++) {\\n            for(int k = 1; k <= K; k ++) {\\n                dp[i][k] = dp[i-1][k];\\n                int sum = 0;\\n                int picked = 1;\\n                for(int v: piles.get(i-1)) {\\n                    if(k-picked < 0) {\\n                        break;\\n                    }\\n                    sum += v;\\n                    dp[i][k] = Math.max(dp[i][k], dp[i-1][k-picked]+sum);\\n                    picked ++;\\n                }\\n            }\\n        }\\n        return dp[n][K];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nf(n,k) = max(\\n\\t\\t\\tf(n-1,k) // pick k from previous n-1 piles\\n\\t\\t\\t,max(f(n-1,k-j-1)+sum(0 to j) for j = 0 to min(k,p[n-1].size())) // pick j+1 from current pile and k-j-1 from previous n-1 piles\\n\\t\\t)\\n```\n```\\n/*\\nf(i,k) = max(f(i-1,k),max(f(i-1,k-j-1)+sum(j) for j = 0 to max(k,p[i-1].length)))\\nf(i,0) = 0\\nf(0,k) = 0\\n*/\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        int[][] dp = new int[n+1][K+1];\\n        \\n        for(int i = 1; i <= n; i ++) {\\n            for(int k = 1; k <= K; k ++) {\\n                dp[i][k] = dp[i-1][k];\\n                int sum = 0;\\n                int picked = 1;\\n                for(int v: piles.get(i-1)) {\\n                    if(k-picked < 0) {\\n                        break;\\n                    }\\n                    sum += v;\\n                    dp[i][k] = Math.max(dp[i][k], dp[i-1][k-picked]+sum);\\n                    picked ++;\\n                }\\n            }\\n        }\\n        return dp[n][K];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888175,
                "title": "explained-solution-by-relating-it-to-coin-change-problem-memoisation-c",
                "content": "### **Intution and Relation with Coin Change**\\nLets try to recall what do we do in coin change , we go to every index and either pick or not pick the element.\\nSimilarly , in this question , we go to every index and because we can pick atmost k elements so , we try all the possibilities of picking elements from 0 to min(piles[idx].size() , k ) and we have to take max of all the possibilities \\nwe tried and return . As simple as that. For the memoisation part , the two parameters that are changing are memoised to reduce the \\n**Time complexity from O(K^n) to (O(k*n)**\\nIf you dont understand any part , try to recall coin change problem thoroughly or comment below. I would be happy to explain further.\\n\\n\\n```\\n    int fun(vector<vector<int>>& piles, vector<vector<int>>& dp , int idx , int k)\\n    {\\n        if(idx == piles.size() || k==0) return 0;\\n        \\n        if(dp[idx][k]!= -1) return dp[idx][k] ;\\n        \\n        int ans = fun(piles, dp , idx+1 , k ) ;\\n        int sum = 0;\\n        \\n        for(int i=0; i< min(int(piles[idx].size()) , k) ; i++)\\n        {\\n            sum+=piles[idx][i] ;\\n            ans = max(ans , sum + fun(piles , dp , idx+1 , k-i-1)) ;\\n        }\\n        \\n        return dp[idx][k] = ans ;\\n        \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         \\n         int n = piles.size();\\n         vector<vector<int> > dp(n+1 , vector<int>(k+1 , -1)) ;\\n      \\n        return fun(piles , dp , 0 , k) ;\\n        \\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "### **Intution and Relation with Coin Change**\\nLets try to recall what do we do in coin change , we go to every index and either pick or not pick the element.\\nSimilarly , in this question , we go to every index and because we can pick atmost k elements so , we try all the possibilities of picking elements from 0 to min(piles[idx].size() , k ) and we have to take max of all the possibilities \\nwe tried and return . As simple as that. For the memoisation part , the two parameters that are changing are memoised to reduce the \\n**Time complexity from O(K^n) to (O(k*n)**\\nIf you dont understand any part , try to recall coin change problem thoroughly or comment below. I would be happy to explain further.\\n\\n\\n```\\n    int fun(vector<vector<int>>& piles, vector<vector<int>>& dp , int idx , int k)\\n    {\\n        if(idx == piles.size() || k==0) return 0;\\n        \\n        if(dp[idx][k]!= -1) return dp[idx][k] ;\\n        \\n        int ans = fun(piles, dp , idx+1 , k ) ;\\n        int sum = 0;\\n        \\n        for(int i=0; i< min(int(piles[idx].size()) , k) ; i++)\\n        {\\n            sum+=piles[idx][i] ;\\n            ans = max(ans , sum + fun(piles , dp , idx+1 , k-i-1)) ;\\n        }\\n        \\n        return dp[idx][k] = ans ;\\n        \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         \\n         int n = piles.size();\\n         vector<vector<int> > dp(n+1 , vector<int>(k+1 , -1)) ;\\n      \\n        return fun(piles , dp , 0 , k) ;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1888833,
                "title": "c-top-down-memoization-with-explanation",
                "content": "**Approach:-**\\n-->This is the **DP Approach with Memoization.**\\n-->We have Choices for any i\\'th index Pile. :-\\n 1)Either We should not take any Coin from  i\\'th index pile.\\n 2)Either we take one top coin from it.\\n 3)Either we take 2 consecutive top coin from that pile.\\n And So ...on \\n -->And After that We call for (i+1)th index Pile.\\n ```\\nclass Solution {\\npublic:\\n    int dp[1001][2001]; //Dp array For Memoization.\\n    int solve(vector<vector<int>>&v,int index,int coin)\\n    {\\n        if(index>=v.size()||coin==0)  //Base Condition\\n            return 0;\\n        if(dp[index][coin]!=-1) //Check wheather It is Already Calculated Or not.\\n            return dp[index][coin];\\n        \\n        \\n        /* Our 1st choice :- We not take any Coin from that pile*/\\n        int ans=solve(v,index+1,coin); //Just Call function for next Pile.\\n        \\n       \\n        /*Otherwise we can take Coins from that Pile.*/\\n        int loop=v[index].size()-1;\\n        int sum=0;\\n        \\n        for(int j=0;j<=min(coin-1,loop);j++) //\\n        {\\n            sum=sum+v[index][j];\\n            ans=max(ans,sum+solve(v,index+1,coin-(j+1)));\\n            \\n            /*Above we Pass coin-(j+1). Because till j\\'th index we have taken j+1 coin from that pile.*/\\n        }\\n        \\n        return dp[index][coin]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,0,k);\\n    }\\n};\\n```\\n*If you find it Helpful .Please Upvote.*",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2001]; //Dp array For Memoization.\\n    int solve(vector<vector<int>>&v,int index,int coin)\\n    {\\n        if(index>=v.size()||coin==0)  //Base Condition\\n            return 0;\\n        if(dp[index][coin]!=-1) //Check wheather It is Already Calculated Or not.\\n            return dp[index][coin];\\n        \\n        \\n        /* Our 1st choice :- We not take any Coin from that pile*/\\n        int ans=solve(v,index+1,coin); //Just Call function for next Pile.\\n        \\n       \\n        /*Otherwise we can take Coins from that Pile.*/\\n        int loop=v[index].size()-1;\\n        int sum=0;\\n        \\n        for(int j=0;j<=min(coin-1,loop);j++) //\\n        {\\n            sum=sum+v[index][j];\\n            ans=max(ans,sum+solve(v,index+1,coin-(j+1)));\\n            \\n            /*Above we Pass coin-(j+1). Because till j\\'th index we have taken j+1 coin from that pile.*/\\n        }\\n        \\n        return dp[index][coin]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886924,
                "title": "2d-dp",
                "content": "We search and memoize the maximum value for `k` coins and `i` piles. \\n\\n**C++**\\n```cpp\\nint dp[1001][2001] = {};\\nint maxValueOfCoins(vector<vector<int>>& piles, int k, int i = 0) {\\n    if (i == piles.size() || k == 0)\\n        return 0;\\n    if (dp[i][k] == 0)\\n        for (int j = 0, sum = 0; j <= piles[i].size() && k - j >= 0; ++j) {\\n            dp[i][k] = max(dp[i][k], sum + maxValueOfCoins(piles, k - j, i + 1));\\n            if (j < piles[i].size())\\n                sum += piles[i][j];\\n        }\\n    return dp[i][k];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[1001][2001] = {};\\nint maxValueOfCoins(vector<vector<int>>& piles, int k, int i = 0) {\\n    if (i == piles.size() || k == 0)\\n        return 0;\\n    if (dp[i][k] == 0)\\n        for (int j = 0, sum = 0; j <= piles[i].size() && k - j >= 0; ++j) {\\n            dp[i][k] = max(dp[i][k], sum + maxValueOfCoins(piles, k - j, i + 1));\\n            if (j < piles[i].size())\\n                sum += piles[i][j];\\n        }\\n    return dp[i][k];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418505,
                "title": "c-recursive-dp-memoization-prefix-sum-commented-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n    int dp[1001][2001];\\n    int help(int idx, int k, vector<vector<int>> &piles)\\n    {\\n        // if no coins left then return 0\\n        if (k == 0)\\n            return 0;\\n\\n        // if we have processed all the piles\\n        if (idx == piles.size())\\n        {\\n            // if k is 0 then we have chosen all the coins so return 0\\n            if (k == 0)\\n                return 0;   \\n            // if k is not 0, then this is not valid so return -infinity\\n            return -inf;\\n        }\\n\\n        // if we have calculated the state before then return it\\n        if (dp[idx][k] != -1)\\n            return dp[idx][k];\\n            \\n        // for the current state initialize answer as 0\\n        int ans = -inf;\\n\\n        // case1: take coins from the current prices {we can choose maximum \\'min(k, current pile size)\\' coins from the current pile}\\n        for (int i = 0; i < min(k, (int)piles[idx].size()); i++)\\n            ans = max(ans, piles[idx][i] + help(idx + 1, k - (i + 1), piles));\\n\\n        // -----------------max(take,nottake)----------------\\n        return dp[idx][k] = max(ans, help(idx + 1, k, piles));\\n    }\\n    int maxValueOfCoins(vector<vector<int>> &piles, int k)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        int n = piles.size();\\n\\n        // storing pref in the piles itself\\n        for (int i = 0; i < n; i++)\\n            for (int j = 1; j < piles[i].size(); j++)\\n                piles[i][j] += piles[i][j - 1];\\n\\n        // answer\\n        return help(0, k, piles);\\n    }\\n};\\n```\\n\\n### Please UPVOTE if you liked.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n    int dp[1001][2001];\\n    int help(int idx, int k, vector<vector<int>> &piles)\\n    {\\n        // if no coins left then return 0\\n        if (k == 0)\\n            return 0;\\n\\n        // if we have processed all the piles\\n        if (idx == piles.size())\\n        {\\n            // if k is 0 then we have chosen all the coins so return 0\\n            if (k == 0)\\n                return 0;   \\n            // if k is not 0, then this is not valid so return -infinity\\n            return -inf;\\n        }\\n\\n        // if we have calculated the state before then return it\\n        if (dp[idx][k] != -1)\\n            return dp[idx][k];\\n            \\n        // for the current state initialize answer as 0\\n        int ans = -inf;\\n\\n        // case1: take coins from the current prices {we can choose maximum \\'min(k, current pile size)\\' coins from the current pile}\\n        for (int i = 0; i < min(k, (int)piles[idx].size()); i++)\\n            ans = max(ans, piles[idx][i] + help(idx + 1, k - (i + 1), piles));\\n\\n        // -----------------max(take,nottake)----------------\\n        return dp[idx][k] = max(ans, help(idx + 1, k, piles));\\n    }\\n    int maxValueOfCoins(vector<vector<int>> &piles, int k)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        int n = piles.size();\\n\\n        // storing pref in the piles itself\\n        for (int i = 0; i < n; i++)\\n            for (int j = 1; j < piles[i].size(); j++)\\n                piles[i][j] += piles[i][j - 1];\\n\\n        // answer\\n        return help(0, k, piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417918,
                "title": "simple-dp-solution-go-c",
                "content": "Go\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n\\tmemo := make([][]int, len(piles)+1)\\n\\tfor i := range memo {\\n\\t\\tmemo[i] = make([]int, k+1)\\n\\t}\\n\\n\\treturn dp(piles, memo, 0, k)\\n}\\n\\nfunc dp(piles [][]int, memo [][]int, i int, k int) int {\\n\\tif k == 0 || i == len(piles) {\\n\\t\\treturn 0\\n\\t}\\n\\tif memo[i][k] != 0 {\\n\\t\\treturn memo[i][k]\\n\\t}\\n\\n\\tres := dp(piles, memo, i+1, k)\\n\\tcur := 0\\n\\n\\tfor j := 0; j < min(len(piles[i]), k); j++ {\\n\\t\\tcur += piles[i][j]\\n\\t\\tres = max(res, cur+dp(piles, memo, i+1, k-j-1))\\n\\t}\\n\\n\\tmemo[i][k] = res\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n        int n = piles.Count;\\n        int[][] memo = new int[n + 1][];\\n        for (int i = 0; i <= n; i++) {\\n            memo[i] = new int[k + 1];\\n            Array.Fill(memo[i], -1);\\n        }\\n\\n        return DP(piles, memo, 0, k);\\n    }\\n\\n    public int DP(IList<IList<int>> piles, int[][] memo, int i, int k) {\\n        if (k == 0 || i == piles.Count) return 0;\\n        if (memo[i][k] != -1) return memo[i][k];\\n\\n        int res = DP(piles, memo, i + 1, k);\\n        int cur = 0;\\n\\n        for (int j = 0; j < Math.Min(piles[i].Count, k); ++j) {\\n            cur += piles[i][j];\\n            res = Math.Max(res, cur + DP(piles, memo, i + 1, k - j - 1));\\n        }\\n        return memo[i][k] = res;\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n\\tmemo := make([][]int, len(piles)+1)\\n\\tfor i := range memo {\\n\\t\\tmemo[i] = make([]int, k+1)\\n\\t}\\n\\n\\treturn dp(piles, memo, 0, k)\\n}\\n\\nfunc dp(piles [][]int, memo [][]int, i int, k int) int {\\n\\tif k == 0 || i == len(piles) {\\n\\t\\treturn 0\\n\\t}\\n\\tif memo[i][k] != 0 {\\n\\t\\treturn memo[i][k]\\n\\t}\\n\\n\\tres := dp(piles, memo, i+1, k)\\n\\tcur := 0\\n\\n\\tfor j := 0; j < min(len(piles[i]), k); j++ {\\n\\t\\tcur += piles[i][j]\\n\\t\\tres = max(res, cur+dp(piles, memo, i+1, k-j-1))\\n\\t}\\n\\n\\tmemo[i][k] = res\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n        int n = piles.Count;\\n        int[][] memo = new int[n + 1][];\\n        for (int i = 0; i <= n; i++) {\\n            memo[i] = new int[k + 1];\\n            Array.Fill(memo[i], -1);\\n        }\\n\\n        return DP(piles, memo, 0, k);\\n    }\\n\\n    public int DP(IList<IList<int>> piles, int[][] memo, int i, int k) {\\n        if (k == 0 || i == piles.Count) return 0;\\n        if (memo[i][k] != -1) return memo[i][k];\\n\\n        int res = DP(piles, memo, i + 1, k);\\n        int cur = 0;\\n\\n        for (int j = 0; j < Math.Min(piles[i].Count, k); ++j) {\\n            cur += piles[i][j];\\n            res = Math.Max(res, cur + DP(piles, memo, i + 1, k - j - 1));\\n        }\\n        return memo[i][k] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889647,
                "title": "python-bottom-up-dp-solution",
                "content": "**Intuition**\\nBottom-up dynamic programming.\\n\\n\\n**Explanation**\\nTop-down DP solution is well-explained in @lee215\\'s [post](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/discuss/1887010/JavaC%2B%2BPython-Top-down-DP-solution). Here we present the Bottom-up DP solution.\\n`dp[i][j]` is the maximum total value from `pile[0]` to `pile[i]`, if choosing exactly `j` coins optimally.\\nWe can pick `0, 1, 2, 3, ... , len(pile[i])` elements from the current `pile[i]` one by one.\\nIt asks for the maximum total value of coins we can have, so we need to return max of all the options.\\n\\n\\n**Complexity**\\nTime `O(m * k)`\\nSpace `O(n * k)`\\nwhere `m = sum(piles[i].length) <= 2000`.\\nTime complexity is well-explained in @DBabichev\\'s [post](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/discuss/1886905/Python-dp-solution-(complexity-updated)-explained), don\\'t be scared by the triple for-loop here.\\n\\n\\n**Python 3 solution**\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n, m = len(piles), 0\\n        prefixSum = []\\n        for i in range(n):\\n            temp = [0]\\n            for j in range(len(piles[i])):\\n                temp.append(temp[-1] + piles[i][j])\\n                m += 1\\n            prefixSum.append(temp)\\n        if m == k:\\n            return sum(temp[-1] for temp in prefixSum)\\n            \\n        dp = [[0] * (k + 1) for _ in range(n)]\\n        for j in range(1, k + 1):\\n            if j < len(prefixSum[0]):\\n                dp[0][j] = prefixSum[0][j]\\n        \\n        for i in range(1, n):\\n            for j in range(1, k + 1):\\n                for l in range(len(prefixSum[i])):\\n                    if l > j:\\n                        break\\n                    dp[i][j] = max(dp[i][j], prefixSum[i][l] + dp[i - 1][j - l])\\n        return dp[n - 1][k]\\n```\\nPlease upvote if you find this solution helpful.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n, m = len(piles), 0\\n        prefixSum = []\\n        for i in range(n):\\n            temp = [0]\\n            for j in range(len(piles[i])):\\n                temp.append(temp[-1] + piles[i][j])\\n                m += 1\\n            prefixSum.append(temp)\\n        if m == k:\\n            return sum(temp[-1] for temp in prefixSum)\\n            \\n        dp = [[0] * (k + 1) for _ in range(n)]\\n        for j in range(1, k + 1):\\n            if j < len(prefixSum[0]):\\n                dp[0][j] = prefixSum[0][j]\\n        \\n        for i in range(1, n):\\n            for j in range(1, k + 1):\\n                for l in range(len(prefixSum[i])):\\n                    if l > j:\\n                        break\\n                    dp[i][j] = max(dp[i][j], prefixSum[i][l] + dp[i - 1][j - l])\\n        return dp[n - 1][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418561,
                "title": "recursion-memoization-tabulation-c-striver-beginner-friendly-solution",
                "content": "# Intuition\\nSimple pick or not pick approach. For pick we run a for loop through the array.  \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\n# Recusive code which will give you TLE\\n\\nint sumi(int ind, vector<vector<int>> &piles, int k, int n){\\n    if(ind==n or k==0) return 0;\\n    int notPick=sumi(ind+1,piles,k,n);\\n    int pick=0,coins=k,sum=0;\\n    for(int i=0;i<piles[ind].size() and coins>0;i++){\\n        sum+=piles[ind][i];\\n        coins--;\\n        int x=sum+sumi(ind+1,piles,coins,n);\\n        pick=max(pick,x);\\n    }\\n    return max(pick,notPick);\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int ind=0;\\n        return sumi(ind,piles,k,n);\\n    }\\n```\\n\\n\\n\\n\\n```\\n# Memoized Solution of above\\nclass Solution {\\npublic:\\n\\nint sumi(int ind, vector<vector<int>> &piles, int k, int n, vector<vector<int>> &dp){\\n    if(ind==n or k==0) return 0;\\n    if(dp[ind][k]!=-1) return dp[ind][k];\\n    int notPick=sumi(ind+1,piles,k,n,dp);\\n    int pick=0,coins=k,sum=0;\\n    for(int i=0;i<piles[ind].size() and coins>0;i++){\\n        sum+=piles[ind][i];\\n        coins--;\\n        int x=sum+sumi(ind+1,piles,coins,n,dp);\\n        pick=max(pick,x);\\n    }\\n    return dp[ind][k]=max(pick,notPick);\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int ind=0;\\n        vector<vector<int>> dp(n, vector<int> (k+1,-1));\\n        return sumi(ind,piles,k,n,dp);\\n    }\\n};\\n```\\n```\\n# Tabulation\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n, vector<int> (k+1,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=0;\\n        }\\n        int sum=0;\\n        for(int i=1;i<=k and i<=piles[0].size();i++){\\n            sum+=piles[0][i-1];\\n            dp[0][i]=sum;\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<=k;j++){\\n                int notPick=dp[i-1][j];\\n                int pick=0;\\n                int sum=0;\\n                for(int k=1;k<=j and k<=piles[i].size();k++){\\n                    sum+=piles[i][k-1];\\n                    pick=max(pick,sum+dp[i-1][j-k]);\\n                }\\n                dp[i][j]=max(pick,notPick);\\n            }\\n        }\\n        return dp[n-1][k];\\n    }\\n};\\n```\\n# ***Please upvote if it helped!***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n# Recusive code which will give you TLE\\n\\nint sumi(int ind, vector<vector<int>> &piles, int k, int n){\\n    if(ind==n or k==0) return 0;\\n    int notPick=sumi(ind+1,piles,k,n);\\n    int pick=0,coins=k,sum=0;\\n    for(int i=0;i<piles[ind].size() and coins>0;i++){\\n        sum+=piles[ind][i];\\n        coins--;\\n        int x=sum+sumi(ind+1,piles,coins,n);\\n        pick=max(pick,x);\\n    }\\n    return max(pick,notPick);\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int ind=0;\\n        return sumi(ind,piles,k,n);\\n    }\\n```\n```\\n# Memoized Solution of above\\nclass Solution {\\npublic:\\n\\nint sumi(int ind, vector<vector<int>> &piles, int k, int n, vector<vector<int>> &dp){\\n    if(ind==n or k==0) return 0;\\n    if(dp[ind][k]!=-1) return dp[ind][k];\\n    int notPick=sumi(ind+1,piles,k,n,dp);\\n    int pick=0,coins=k,sum=0;\\n    for(int i=0;i<piles[ind].size() and coins>0;i++){\\n        sum+=piles[ind][i];\\n        coins--;\\n        int x=sum+sumi(ind+1,piles,coins,n,dp);\\n        pick=max(pick,x);\\n    }\\n    return dp[ind][k]=max(pick,notPick);\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int ind=0;\\n        vector<vector<int>> dp(n, vector<int> (k+1,-1));\\n        return sumi(ind,piles,k,n,dp);\\n    }\\n};\\n```\n```\\n# Tabulation\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n, vector<int> (k+1,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=0;\\n        }\\n        int sum=0;\\n        for(int i=1;i<=k and i<=piles[0].size();i++){\\n            sum+=piles[0][i-1];\\n            dp[0][i]=sum;\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<=k;j++){\\n                int notPick=dp[i-1][j];\\n                int pick=0;\\n                int sum=0;\\n                for(int k=1;k<=j and k<=piles[i].size();k++){\\n                    sum+=piles[i][k-1];\\n                    pick=max(pick,sum+dp[i-1][j-k]);\\n                }\\n                dp[i][j]=max(pick,notPick);\\n            }\\n        }\\n        return dp[n-1][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886910,
                "title": "c-top-down-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Top-down DP\\n\\nLet `dp[i][j]` be the max value of `j` coins using piles `i ~ N-1`. The answer is `dp[0][k]`.\\n\\nFor `dp[i][j]`, we can try using `t` elements from `A[i]` (`0 <= t <= min(j, A[i].size())`), getting `A[i][0] + ... + A[i][t-1]` value plus `dp[i+1][j-t]` value (the max value of `j-t` coins using piles `i+1 ~ N-1`). We try different `t`s and assign the max value to `dp[i][j]`.\\n\\n```\\ndp[i][j] = max( dp[i+1][j-t] + sum(i, t) | 0 <= t <= min(j, A[i].size()) )\\n            where sum(i, t) = A[i][0] + ... + A[i][t-1]\\n```\\n\\nTrivial case is `dp[N][j] = 0`, i.e. we can\\'t get any value from the nonexistent `A[N]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-286/problems/maximum-value-of-k-coins-from-piles/\\n// Author: github.com/lzl124631x\\n// Time: O(NK)\\n// Space: O(NK)\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& A, int k) {\\n        int N = A.size(), m[1001][2001] = {};\\n        memset(m, -1, sizeof(m));\\n        function<int(int, int)> dp =[&](int i, int j) {\\n            if (m[i][j] != -1) return m[i][j];\\n            if (i == N) return 0;\\n            int ans = dp(i + 1, j), sum = 0;\\n            for (int t = 1; t <= j && t <= A[i].size(); ++t) {\\n                sum += A[i][t - 1];\\n                ans = max(ans, dp(i + 1, j - t) + sum);\\n            }\\n            return m[i][j] = ans;\\n        };\\n        return dp(0, k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = max( dp[i+1][j-t] + sum(i, t) | 0 <= t <= min(j, A[i].size()) )\\n            where sum(i, t) = A[i][0] + ... + A[i][t-1]\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-286/problems/maximum-value-of-k-coins-from-piles/\\n// Author: github.com/lzl124631x\\n// Time: O(NK)\\n// Space: O(NK)\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& A, int k) {\\n        int N = A.size(), m[1001][2001] = {};\\n        memset(m, -1, sizeof(m));\\n        function<int(int, int)> dp =[&](int i, int j) {\\n            if (m[i][j] != -1) return m[i][j];\\n            if (i == N) return 0;\\n            int ans = dp(i + 1, j), sum = 0;\\n            for (int t = 1; t <= j && t <= A[i].size(); ++t) {\\n                sum += A[i][t - 1];\\n                ans = max(ans, dp(i + 1, j - t) + sum);\\n            }\\n            return m[i][j] = ans;\\n        };\\n        return dp(0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418169,
                "title": "leetcode-the-hard-way-dp-memo-explained",
                "content": "Let `dp[i][j]` be the maximum total value we can have if we pick `j` elements starting from `piles[i]`. The answer is `dp[0][k]`. First we calculate the value if we pick any elements in the current pile. Then we try to pick at most `min((int) piles[i].size(), k)` elements and find out the max result.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        function<int(int,int)> dfs = [&](int i, int k) {\\n            // reach the end - return 0\\n            if (i == n || k == 0) return 0;\\n            // calculated previously - return immediately\\n            if (dp[i][k] != -1) return dp[i][k];\\n            // do not take \\n            int res = dfs(i + 1, k), val = 0;\\n            // try to take it one by one \\n            // calculate the value we could have\\n            for (int j = 0; j < min((int) piles[i].size(), k); j++) {\\n                // take this element\\n                val += piles[i][j];\\n                res = max(res, dfs(i + 1, k - 1 - j) + val);\\n            }\\n            return dp[i][k] = res;\\n        };\\n        return dfs(0, k);\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        @lru_cache(None)\\n        def dp(i, k):\\n            # reach the end - return 0\\n            if i == len(piles) or k == 0:\\n                return 0\\n            res = 0\\n            # do not take \\n            res += dp(i + 1, k)\\n            # try to take it one by one \\n            # calculate the value we could have\\n            take = 0\\n            for j in range(min(k, len(piles[i]))):\\n                # take this element\\n                take += piles[i][j]\\n                res = max(res, dp(i + 1, k - 1 - j) + take)\\n            return res\\n        return dp(0, k)\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        function<int(int,int)> dfs = [&](int i, int k) {\\n            // reach the end - return 0\\n            if (i == n || k == 0) return 0;\\n            // calculated previously - return immediately\\n            if (dp[i][k] != -1) return dp[i][k];\\n            // do not take \\n            int res = dfs(i + 1, k), val = 0;\\n            // try to take it one by one \\n            // calculate the value we could have\\n            for (int j = 0; j < min((int) piles[i].size(), k); j++) {\\n                // take this element\\n                val += piles[i][j];\\n                res = max(res, dfs(i + 1, k - 1 - j) + val);\\n            }\\n            return dp[i][k] = res;\\n        };\\n        return dfs(0, k);\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        @lru_cache(None)\\n        def dp(i, k):\\n            # reach the end - return 0\\n            if i == len(piles) or k == 0:\\n                return 0\\n            res = 0\\n            # do not take \\n            res += dp(i + 1, k)\\n            # try to take it one by one \\n            # calculate the value we could have\\n            take = 0\\n            for j in range(min(k, len(piles[i]))):\\n                # take this element\\n                take += piles[i][j]\\n                res = max(res, dp(i + 1, k - 1 - j) + take)\\n            return res\\n        return dp(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136042,
                "title": "dp-memoization-easy-to-understand",
                "content": "In the problem, we have to select ****K**** coins from the given piles of coins. In one step we can select one coin from the top of the n piles.\\nOur task is to ****maximize the total money we can get****.\\nFrom the ith pile, we can select between 0 to k coins.\\nTherefore, for every pile we have choice to take 0 coin to k coins. Simply, we can write the recursive code exploring all the choices.\\n\\n**Recursive Solution-**\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& piles,int ind,int k)\\n    {\\n        if(k==0 )return 0; // no more coins can be taken\\n        if(ind==piles.size())return INT_MIN;// no more piles are left\\n        int ans=fun(piles,ind+1,k); // if we take 0 coin from the pile\\n        int score=0;\\n        int secAns=INT_MIN;\\n        for(int i=0;i<k && i<piles[ind].size();i++)// taking 1 to k coins from the pile\\n        {\\n            score+=piles[ind][i];\\n            secAns=max(secAns,score+fun(piles,ind+1,k-i-1));\\n        }\\n        return max(ans,secAns);                                      \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        return fun(piles,0,k);\\n    }\\n};\\n```\\nAs we can clearly see, we have overlapping subproblems, therefore,  we can solve the problem with the help of Dynamic Programming. \\nThe state variables for the given dynamic programming problem are ind(index) and k. \\nWe can create a **dp[n][k+1]** and store the answer for the problem with i and k state variables.\\n\\n**Dynamic Programming (Memoization)-**\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& piles,int ind,int k,vector<vector<int>>&dp)\\n    {\\n        if(k==0 )return 0;   //no more coins can be taken \\n        if(ind==piles.size())return INT_MIN; // no more piles are left\\n        if(dp[ind][k]!=-1)return dp[ind][k]; // if already calculated, simply return\\n        int ans=fun(piles,ind+1,k,dp); // if we take 0 coin from the pile\\n        int score=0;\\n        int secAns=INT_MIN;\\n        for(int i=0;i<k && i<piles[ind].size();i++) // taking 1 to k coins from the pile\\n        {\\n            score+=piles[ind][i];\\n            secAns=max(secAns,score+fun(piles,ind+1,k-i-1,dp));\\n        }\\n        return dp[ind][k] = max(ans,secAns);                                      \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        return fun(piles,0,k,dp);\\n    }\\n};\\n```\\nThe above is the memoized dynamic programming solution.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& piles,int ind,int k)\\n    {\\n        if(k==0 )return 0; // no more coins can be taken\\n        if(ind==piles.size())return INT_MIN;// no more piles are left\\n        int ans=fun(piles,ind+1,k); // if we take 0 coin from the pile\\n        int score=0;\\n        int secAns=INT_MIN;\\n        for(int i=0;i<k && i<piles[ind].size();i++)// taking 1 to k coins from the pile\\n        {\\n            score+=piles[ind][i];\\n            secAns=max(secAns,score+fun(piles,ind+1,k-i-1));\\n        }\\n        return max(ans,secAns);                                      \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        return fun(piles,0,k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& piles,int ind,int k,vector<vector<int>>&dp)\\n    {\\n        if(k==0 )return 0;   //no more coins can be taken \\n        if(ind==piles.size())return INT_MIN; // no more piles are left\\n        if(dp[ind][k]!=-1)return dp[ind][k]; // if already calculated, simply return\\n        int ans=fun(piles,ind+1,k,dp); // if we take 0 coin from the pile\\n        int score=0;\\n        int secAns=INT_MIN;\\n        for(int i=0;i<k && i<piles[ind].size();i++) // taking 1 to k coins from the pile\\n        {\\n            score+=piles[ind][i];\\n            secAns=max(secAns,score+fun(piles,ind+1,k-i-1,dp));\\n        }\\n        return dp[ind][k] = max(ans,secAns);                                      \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        return fun(piles,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417924,
                "title": "java-easy-solution-dp",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int numPiles = piles.size();\\n        \\n        int[][] dp = new int[numPiles+1][k+1];\\n        \\n        for(int i=1; i<=numPiles; i++){\\n            for(int j=1; j<=k; j++){\\n                dp[i][j] = dp[i-1][j]; \\n                List<Integer> currPile = piles.get(i-1);\\n                int coinSum = 0;\\n                for(int l=0; l < Math.min(currPile.size(), j); l++){\\n                    coinSum += currPile.get(l);\\n                    dp[i][j] = Math.max(dp[i][j], coinSum + dp[i-1][j - l - 1]); \\n                }\\n            }\\n        }\\n        \\n        return dp[numPiles][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int numPiles = piles.size();\\n        \\n        int[][] dp = new int[numPiles+1][k+1];\\n        \\n        for(int i=1; i<=numPiles; i++){\\n            for(int j=1; j<=k; j++){\\n                dp[i][j] = dp[i-1][j]; \\n                List<Integer> currPile = piles.get(i-1);\\n                int coinSum = 0;\\n                for(int l=0; l < Math.min(currPile.size(), j); l++){\\n                    coinSum += currPile.get(l);\\n                    dp[i][j] = Math.max(dp[i][j], coinSum + dp[i-1][j - l - 1]); \\n                }\\n            }\\n        }\\n        \\n        return dp[numPiles][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886976,
                "title": "c-memoization",
                "content": "```\\nvector<vector<int>> dp;\\n    int func(vector<vector<int>>& p,int i,int k){\\n        if(i==p.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=func(p,i+1,k);\\n        int a=0;\\n        for(int j=0;j<p[i].size()&&j<k;j++){\\n            a+=p[i][j];\\n            ans=max(ans,a+func(p,i+1,k-j-1));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        dp=vector<vector<int>>(p.size(),vector<int>(k+1,-1));\\n        return func(p,0,k);\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvector<vector<int>> dp;\\n    int func(vector<vector<int>>& p,int i,int k){\\n        if(i==p.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=func(p,i+1,k);\\n        int a=0;\\n        for(int j=0;j<p[i].size()&&j<k;j++){\\n            a+=p[i][j];\\n            ans=max(ans,a+func(p,i+1,k-j-1));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        dp=vector<vector<int>>(p.size(),vector<int>(k+1,-1));\\n        return func(p,0,k);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1886922,
                "title": "java-bottom-up-dp",
                "content": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        int[][] ans = new int[n+1][2001];\\n        Collections.sort(piles, (List<Integer> a, List<Integer> b) ->  b.size() - a.size());\\n        for(int i = 1; i <= k; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                int sizeOfPile = piles.get(j-1).size();\\n                List<Integer> pile = piles.get(j-1);\\n                int sum = 0;\\n                ans[j][i] = ans[j-1][i];\\n                for(int l = 1; l <= Math.min(i, sizeOfPile); l++) {\\n                    // Take K from this pile + remaining from previous piles\\n                    sum += pile.get(l-1);\\n                    int rem = i - l;\\n                    ans[j][i] = Math.max(ans[j][i], sum + ans[j-1][rem]);\\n                }\\n            }\\n        }\\n        \\n        return ans[n][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        int[][] ans = new int[n+1][2001];\\n        Collections.sort(piles, (List<Integer> a, List<Integer> b) ->  b.size() - a.size());\\n        for(int i = 1; i <= k; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                int sizeOfPile = piles.get(j-1).size();\\n                List<Integer> pile = piles.get(j-1);\\n                int sum = 0;\\n                ans[j][i] = ans[j-1][i];\\n                for(int l = 1; l <= Math.min(i, sizeOfPile); l++) {\\n                    // Take K from this pile + remaining from previous piles\\n                    sum += pile.get(l-1);\\n                    int rem = i - l;\\n                    ans[j][i] = Math.max(ans[j][i], sum + ans[j-1][rem]);\\n                }\\n            }\\n        }\\n        \\n        return ans[n][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419285,
                "title": "golang-recursive-mem-optimised-dp",
                "content": "# Intuition\\nWe need to find a Min/Max of something in an array/matrix => It\\'s a Dynamic Programming problem (rarely a Greedy problem).\\n\\n# Approach - Simple recursive function\\nDon\\'t try to write a final optimized code from the start, it will break your mind. Always start with defining a recursive function:\\n\\n`rec(pile_idx, used) = max_over_j(sum_of_j_coins_from_this_pile + rec(pile_idx + 1, used - j)`\\nAnd the answer can be found with `rec(0, k)`\\n\\nThe following code works fine with small test cases but will hit the TimeLimit if you submit it. Check out the next approach.\\n\\n\\n# Code - Simple recursive function\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n\\n    var rec func(int, int) int\\n    rec = func(i int, used int) int {\\n        if i == n { return 0 }\\n        accum := 0\\n        res := rec(i+1, used)\\n        for j:=0; j<min(len(piles[i]), used); j++ {\\n            accum += piles[i][j]\\n            res = max(res, accum + rec(i+1, used-j-1))\\n        }\\n        return res\\n    }\\n    return rec(0, k)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n---\\n\\n# Approach - Recursive function with Memo\\nCreate a memo matrix with size of `len(piles)\\u22C5k` and use it for caching `rec()` results. It will pass all test cases.\\n\\n![Screenshot 2023-04-15 at 14.40.13.png](https://assets.leetcode.com/users/images/2dc8d044-7249-40d1-86b7-62400f33d94f_1681555225.9792976.png)\\n\\n# Code - Recursive function with Memo\\n\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    memo := make([][]int, n)\\n    for i := range memo {\\n        memo[i] = make([]int, k+1)\\n    }\\n\\n    var rec func(int, int) int\\n    rec = func(i int, used int) int {\\n        if i == n { return 0 }\\n        if memo[i][used] > 0 { return memo[i][used] }\\n        accum := 0\\n        res := rec(i+1, used)\\n        for j:=0; j<min(len(piles[i]), used); j++ {\\n            accum += piles[i][j]\\n            res = max(res, accum + rec(i+1, used-j-1))\\n        }\\n        memo[i][used] = res\\n        return res\\n    }\\n    return rec(0, k)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n---\\n\\n# Approach - Bottom-up DP\\nWe understand how our memo matrix must look like and how we can fill it in recursively. Now we need to do the same using loops.\\n\\nTraverse all `piles` and `used` in a nested loop and change `rec(i+1, used)` into `memo[i+1][used]`. Almost all the code remains the same (that\\'s the neat part of this process).\\n\\n![Screenshot 2023-04-15 at 14.45.07.png](https://assets.leetcode.com/users/images/c84423aa-bdc7-4753-9365-bfdc9ab27d5d_1681555517.5403607.png)\\n\\n# Code - Bottom-up DP\\n\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    memo := make([][]int, n+1)\\n    for i := range memo {\\n        memo[i] = make([]int, k+1)\\n    }\\n\\n    for i:=n-1; i>=0; i-- {\\n        for used:=0; used<=k; used++ {\\n            accum := 0\\n            res := memo[i+1][used]\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                res = max(res, accum + memo[i+1][used-j-1])\\n            }\\n            memo[i][used] = res\\n        }\\n    }\\n    return memo[0][k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n---\\n\\n# Approach - Bottom-up Mem Optimised DP\\nNotice that we need only the values from `memo[i]` and `memo[i+1]`, so no need to keep the whole matrix in the memory. Just create a one dimensional list `dp` of size `k`.\\n\\n![Screenshot 2023-04-15 at 15.00.41.png](https://assets.leetcode.com/users/images/82ad0e39-fd25-4e03-a4c8-2dad71573b2b_1681556636.8669186.png)\\n\\n# Code - Bottom-up Mem Optimised DP\\n\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    dp := make([]int, k+1)\\n\\n    for i:=n-1; i>=0; i-- {\\n        for used:=k; used>=0; used-- {\\n            accum := 0\\n            res := dp[used]\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                res = max(res, accum + dp[used-j-1])\\n            }\\n            dp[used] = res\\n        }\\n    }\\n    return dp[k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n### Do some code optimisations\\n\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    dp := make([]int, k+1)\\n\\n    for i := range piles {\\n        for used:=k; used>=0; used-- {\\n            accum := 0\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                dp[used] = max(dp[used], accum + dp[used-j-1])\\n            }\\n        }\\n    }\\n    return dp[k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(totalCoinsNum\\u22C5k)$$\\n\\n- Space complexity: $$O(k)$$",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n\\n    var rec func(int, int) int\\n    rec = func(i int, used int) int {\\n        if i == n { return 0 }\\n        accum := 0\\n        res := rec(i+1, used)\\n        for j:=0; j<min(len(piles[i]), used); j++ {\\n            accum += piles[i][j]\\n            res = max(res, accum + rec(i+1, used-j-1))\\n        }\\n        return res\\n    }\\n    return rec(0, k)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    memo := make([][]int, n)\\n    for i := range memo {\\n        memo[i] = make([]int, k+1)\\n    }\\n\\n    var rec func(int, int) int\\n    rec = func(i int, used int) int {\\n        if i == n { return 0 }\\n        if memo[i][used] > 0 { return memo[i][used] }\\n        accum := 0\\n        res := rec(i+1, used)\\n        for j:=0; j<min(len(piles[i]), used); j++ {\\n            accum += piles[i][j]\\n            res = max(res, accum + rec(i+1, used-j-1))\\n        }\\n        memo[i][used] = res\\n        return res\\n    }\\n    return rec(0, k)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    memo := make([][]int, n+1)\\n    for i := range memo {\\n        memo[i] = make([]int, k+1)\\n    }\\n\\n    for i:=n-1; i>=0; i-- {\\n        for used:=0; used<=k; used++ {\\n            accum := 0\\n            res := memo[i+1][used]\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                res = max(res, accum + memo[i+1][used-j-1])\\n            }\\n            memo[i][used] = res\\n        }\\n    }\\n    return memo[0][k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    dp := make([]int, k+1)\\n\\n    for i:=n-1; i>=0; i-- {\\n        for used:=k; used>=0; used-- {\\n            accum := 0\\n            res := dp[used]\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                res = max(res, accum + dp[used-j-1])\\n            }\\n            dp[used] = res\\n        }\\n    }\\n    return dp[k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    dp := make([]int, k+1)\\n\\n    for i := range piles {\\n        for used:=k; used>=0; used-- {\\n            accum := 0\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                dp[used] = max(dp[used], accum + dp[used-j-1])\\n            }\\n        }\\n    }\\n    return dp[k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418388,
                "title": "space-optimised-tabulation-memoization-recursion",
                "content": "# Intuition\\nThe problem is to maximize the sum of k coins collected from n piles of coins, where each pile has a different number of coins. The constraint is that you can only take coins from the top of each pile. The given solution uses a depth-first search (DFS) approach to explore all possible choices of taking coins from different piles and computes the maximum sum of coins that can be collected.\\n\\n<hr>\\n\\n# Approach\\nThe solution is implemented using a recursive function `helper()` which takes three parameters: `idx` (the current pile index), `coins` (the number of coins left to collect), and `piles` (the 2D vector of piles with coins).\\n\\nThe base case for the recursion is when the current pile index `idx` reaches the total number of `piles`. In this case, the function `returns 0`, as no more coins can be collected.\\n\\nThe main logic is divided into two cases:\\n1. Not taking any coins from the current pile, in which case we move to the next pile by calling the `helper()` function with `idx + 1` and the same number of coins left to collect.\\n2. Taking some coins from the current pile. In this case, we iterate through the coins in the current pile, taking at most `min(n, coins)` coins, where n is the total number of coins in the current pile. For each coin taken, we add its value to the `curr_total`, and then call the `helper()` function for the next pile with `idx + 1` and the updated number of coins left to collect `(coins - i - 1)`. We keep track of the maximum total coins collected in `max_total`.\\n\\nIn the end, the helper function returns `max_total` which is the maximum sum of coins that can be collected by considering all possible choices of taking coins from the current pile and subsequent piles.\\n\\nThe main function `maxValueOfCoins()` initiates the recursion by calling the `helper()` function with `idx = 0` (starting pile) and `coins = k` (the total number of coins to collect).\\n<hr>\\n\\n# Implementations\\n\\n## Recursion - _Time Limit Exceeded_ \\u203C\\uFE0F\\n```\\nclass Solution {\\nprivate:\\n    int helper(int idx, int coins, vector<vector<int>>& piles) {\\n        //Base case\\n        if(idx == piles.size()) {\\n            return 0;\\n        }\\n\\n        //Explore all paths\\n        int n = piles[idx].size();\\n\\n        //Path 1 - Not take any coin from the current pile\\n        int max_total = helper(idx + 1, coins, piles);\\n\\n        //Path 2 - Take (i + 1) number of coins from the current pile\\n        int curr_total = 0;\\n        for(int i = 0; i < min(n, coins); i++) {\\n            curr_total += piles[idx][i];\\n            int next_total = helper(idx + 1, coins - i - 1, piles);\\n            max_total = max(max_total, curr_total + next_total);\\n        }\\n        return max_total;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return helper(0, k, piles);\\n    }\\n};\\n```\\n\\nIf `k` is the number of coins to collect, `m` is the number of piles and `n` is the total number of coins in all piles then:\\n- **Time complexity:** $$O(k^n)$$\\n\\n- **Space complexity:** $$O(k * m)$$\\n<hr>\\n\\n## Memoization (Top-Down) - _Accepted_ \\u2705\\nIt can be clearly seen from the recursive approcah that we are doing a lot of repeated work and there are overlapping sub-problems hence we can use dynamic programming to optimise out recursive approach. So let us memoize our recursion.\\n```\\nclass Solution {\\nprivate:\\n    int helper(int idx, int coins, vector<vector<int>>& piles, vector<vector<int>>& dp) {\\n        //Base case\\n        if(idx == piles.size()) {\\n            return 0;\\n        }\\n        if(dp[idx][coins] != -1) {\\n            return dp[idx][coins];\\n        }\\n\\n        //Explore all paths\\n        int n = piles[idx].size();\\n\\n        //Path 1 - Not take any coin from the current pile\\n        int max_total = helper(idx + 1, coins, piles, dp);\\n\\n        //Path 2 - Take (i + 1) number of coins from the current pile\\n        int curr_total = 0;\\n        for(int i = 0; i < min(n, coins); i++) {\\n            curr_total += piles[idx][i];\\n            int next_total = helper(idx + 1, coins - i - 1, piles, dp);\\n            max_total = max(max_total, curr_total + next_total);\\n        }\\n        return dp[idx][coins] = max_total;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\\n        return helper(0, k, piles, dp);\\n    }\\n};\\n```\\n\\nIf `k` is the number of coins to collect, `m` is the number of piles and `n` is the total number of coins in all piles then:\\n- **Time complexity:** $$O(k * n)$$\\n\\n- **Space complexity:** $$O(k * m)$$\\n<hr>\\n\\n## Tabulation (Bottom-Up) - _Accepted_ \\u2705\\u2705\\nLet us now tabulise the memoization solution that we did above.\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(k + 1, 0));\\n        for(int idx = m - 1; idx >= 0; idx--) {\\n            for(int coins = 1; coins <= k; coins++) {\\n                //Explore all paths\\n                int n = piles[idx].size();\\n\\n                //Path 1 - Not take any coin from the current pile\\n                int max_total = dp[idx + 1][coins];\\n\\n                //Path 2 - Take (i + 1) number of coins from the current pile\\n                int curr_total = 0;\\n                for(int i = 0; i < min(n, coins); i++) {\\n                    curr_total += piles[idx][i];\\n                    int next_total = dp[idx + 1][coins - i - 1];\\n                    max_total = max(max_total, curr_total + next_total);\\n                }\\n                dp[idx][coins] = max_total;                \\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\\n\\nIf `k` is the number of coins to collect, `m` is the number of piles and `n` is the total number of coins in all piles then:\\n- **Time complexity:** $$O(k * n)$$\\n\\n- **Space complexity:** $$O(k * m)$$\\n<hr>\\n\\n## Space Optimised Tabulation - _Accepted_ \\u2705\\u2705\\u2705\\nFrom the above tabulation code we can observe that the current pile `(dp[idx])` is always dependant on the next pile `(dp[idx + 1])`. So why not just keep 2 vectors of size `k + 1` each, one for `dp[idx]` and one for `dp[idx + 1]`. In this way we can save a lot of space by just computing two rows of the dp table at any instant instead of the entire `k x n` grid.\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        vector<int> curr(k + 1), next(k + 1, 0);\\n        for(int idx = m - 1; idx >= 0; idx--) {\\n            for(int coins = 1; coins <= k; coins++) {\\n                //Explore all paths\\n                int n = piles[idx].size();\\n\\n                //Path 1 - Not take any coin from the current pile\\n                int max_total = next[coins];\\n\\n                //Path 2 - Take (i + 1) number of coins from the current pile\\n                int curr_total = 0;\\n                for(int i = 0; i < min(n, coins); i++) {\\n                    curr_total += piles[idx][i];\\n                    int next_total = next[coins - i - 1];\\n                    max_total = max(max_total, curr_total + next_total);\\n                }\\n                curr[coins] = max_total;                \\n            }\\n            next = curr; //Make next = current for the next iteration\\n        }\\n        return next[k];\\n    }\\n};\\n```\\n\\nIf `k` is the number of coins to collect, `m` is the number of piles and `n` is the total number of coins in all piles then:\\n- **Time complexity:** $$O(k * n)$$\\n\\n- **Space complexity:** $$O(k)$$\\n<hr>\\n\\n\\uD83D\\uDE4F **_If you like the entire explanation and all the implementations I showed, please do take a moment to upvote this post._** \\uD83D\\uDE4F",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int idx, int coins, vector<vector<int>>& piles) {\\n        //Base case\\n        if(idx == piles.size()) {\\n            return 0;\\n        }\\n\\n        //Explore all paths\\n        int n = piles[idx].size();\\n\\n        //Path 1 - Not take any coin from the current pile\\n        int max_total = helper(idx + 1, coins, piles);\\n\\n        //Path 2 - Take (i + 1) number of coins from the current pile\\n        int curr_total = 0;\\n        for(int i = 0; i < min(n, coins); i++) {\\n            curr_total += piles[idx][i];\\n            int next_total = helper(idx + 1, coins - i - 1, piles);\\n            max_total = max(max_total, curr_total + next_total);\\n        }\\n        return max_total;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return helper(0, k, piles);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int helper(int idx, int coins, vector<vector<int>>& piles, vector<vector<int>>& dp) {\\n        //Base case\\n        if(idx == piles.size()) {\\n            return 0;\\n        }\\n        if(dp[idx][coins] != -1) {\\n            return dp[idx][coins];\\n        }\\n\\n        //Explore all paths\\n        int n = piles[idx].size();\\n\\n        //Path 1 - Not take any coin from the current pile\\n        int max_total = helper(idx + 1, coins, piles, dp);\\n\\n        //Path 2 - Take (i + 1) number of coins from the current pile\\n        int curr_total = 0;\\n        for(int i = 0; i < min(n, coins); i++) {\\n            curr_total += piles[idx][i];\\n            int next_total = helper(idx + 1, coins - i - 1, piles, dp);\\n            max_total = max(max_total, curr_total + next_total);\\n        }\\n        return dp[idx][coins] = max_total;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\\n        return helper(0, k, piles, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(k + 1, 0));\\n        for(int idx = m - 1; idx >= 0; idx--) {\\n            for(int coins = 1; coins <= k; coins++) {\\n                //Explore all paths\\n                int n = piles[idx].size();\\n\\n                //Path 1 - Not take any coin from the current pile\\n                int max_total = dp[idx + 1][coins];\\n\\n                //Path 2 - Take (i + 1) number of coins from the current pile\\n                int curr_total = 0;\\n                for(int i = 0; i < min(n, coins); i++) {\\n                    curr_total += piles[idx][i];\\n                    int next_total = dp[idx + 1][coins - i - 1];\\n                    max_total = max(max_total, curr_total + next_total);\\n                }\\n                dp[idx][coins] = max_total;                \\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        vector<int> curr(k + 1), next(k + 1, 0);\\n        for(int idx = m - 1; idx >= 0; idx--) {\\n            for(int coins = 1; coins <= k; coins++) {\\n                //Explore all paths\\n                int n = piles[idx].size();\\n\\n                //Path 1 - Not take any coin from the current pile\\n                int max_total = next[coins];\\n\\n                //Path 2 - Take (i + 1) number of coins from the current pile\\n                int curr_total = 0;\\n                for(int i = 0; i < min(n, coins); i++) {\\n                    curr_total += piles[idx][i];\\n                    int next_total = next[coins - i - 1];\\n                    max_total = max(max_total, curr_total + next_total);\\n                }\\n                curr[coins] = max_total;                \\n            }\\n            next = curr; //Make next = current for the next iteration\\n        }\\n        return next[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738377,
                "title": "c-recursion-top-down",
                "content": "// recursion \\n```\\nint solve(vector<vector<int>>& arr,int i,int k,int n){\\n    if (k==0 || i==n)\\n    {\\n        return 0;\\n    }\\n    int ans=0;\\n    for (int j = 0; j <=k; j++)\\n    {\\n        if (arr[i].size()>=j)\\n        {\\n            if(j==0){\\n                ans=max(ans,solve(arr,i+1,k,n)) ;\\n            }\\n            else{\\n            ans=max(ans,arr[i][j-1]+solve(arr,i+1,k-j,n));\\n            }\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n    return ans;\\n}\\n int maxValueOfCoins(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < arr[i].size(); j++)\\n            {\\n               arr[i][j]+=arr[i][j-1];\\n            }\\n            \\n        }\\n        return solve(arr,0,k,n);\\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n```\\n\\t// Top-Down\\n\\n```\\nint solve(vector<vector<int>>& arr,int k2,int n){\\n    vector<vector<int>>dp(n+1,vector<int>(k2+1,0));\\n    for (int i = n-1; i >=0; i--)\\n    {\\n        for (int k = 0; k<=k2; k++)\\n        {\\n          \\n                for (int j = 0; j <=k; j++)\\n                {\\n                    if (arr[i].size()>=j)\\n                    {\\n                        if(j==0){\\n                            dp[i][k]=max(dp[i][k],dp[i+1][k]) ;\\n                        }\\n                        else{\\n                        dp[i][k]=max(dp[i][k],arr[i][j-1]+dp[i+1][k-j]);\\n                        }\\n                    }\\n                    else{\\n                        break;\\n                    }\\n    }\\n   \\n\\n\\n        }\\n        \\n    }\\n    return dp[0][k2];\\n    \\n\\n\\n\\n }\\n\\n  int maxValueOfCoins(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < arr[i].size(); j++)\\n            {\\n               arr[i][j]+=arr[i][j-1];\\n            }\\n            \\n        }\\n        return solve(arr,k,n);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nint solve(vector<vector<int>>& arr,int i,int k,int n){\\n    if (k==0 || i==n)\\n    {\\n        return 0;\\n    }\\n    int ans=0;\\n    for (int j = 0; j <=k; j++)\\n    {\\n        if (arr[i].size()>=j)\\n        {\\n            if(j==0){\\n                ans=max(ans,solve(arr,i+1,k,n)) ;\\n            }\\n            else{\\n            ans=max(ans,arr[i][j-1]+solve(arr,i+1,k-j,n));\\n            }\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n    return ans;\\n}\\n int maxValueOfCoins(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < arr[i].size(); j++)\\n            {\\n               arr[i][j]+=arr[i][j-1];\\n            }\\n            \\n        }\\n        return solve(arr,0,k,n);\\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n```\n```\\nint solve(vector<vector<int>>& arr,int k2,int n){\\n    vector<vector<int>>dp(n+1,vector<int>(k2+1,0));\\n    for (int i = n-1; i >=0; i--)\\n    {\\n        for (int k = 0; k<=k2; k++)\\n        {\\n          \\n                for (int j = 0; j <=k; j++)\\n                {\\n                    if (arr[i].size()>=j)\\n                    {\\n                        if(j==0){\\n                            dp[i][k]=max(dp[i][k],dp[i+1][k]) ;\\n                        }\\n                        else{\\n                        dp[i][k]=max(dp[i][k],arr[i][j-1]+dp[i+1][k-j]);\\n                        }\\n                    }\\n                    else{\\n                        break;\\n                    }\\n    }\\n   \\n\\n\\n        }\\n        \\n    }\\n    return dp[0][k2];\\n    \\n\\n\\n\\n }\\n\\n  int maxValueOfCoins(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < arr[i].size(); j++)\\n            {\\n               arr[i][j]+=arr[i][j-1];\\n            }\\n            \\n        }\\n        return solve(arr,k,n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418857,
                "title": "c-easy-dp-recursive-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int c(vector<vector<int>>& p,int i,int k,vector<vector<int>>&dp){\\n        if(k==0)return 0;\\n        if(i>=p.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans=0;\\n        int mx=c(p,i+1,k,dp);\\n        for(int j=0;j<p[i].size();j++){\\n            ans += p[i][j];\\n            if(k>=j+1)\\n           mx = max(mx,ans+c(p,i+1,k-j-1,dp));\\n           else break;\\n        }\\n        dp[i][k]=mx;\\n        return mx;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        return c(p,0,k,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/6562a796-f88c-4354-91ae-9f672244bb39_1681546108.315926.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int c(vector<vector<int>>& p,int i,int k,vector<vector<int>>&dp){\\n        if(k==0)return 0;\\n        if(i>=p.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans=0;\\n        int mx=c(p,i+1,k,dp);\\n        for(int j=0;j<p[i].size();j++){\\n            ans += p[i][j];\\n            if(k>=j+1)\\n           mx = max(mx,ans+c(p,i+1,k-j-1,dp));\\n           else break;\\n        }\\n        dp[i][k]=mx;\\n        return mx;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        return c(p,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417903,
                "title": "prefix-sum-bottom-up-dp-detailed-explanation-c-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        // total n piles and k coins we can choose.\\n        // so for any dp[i][j] it will store the max coins we\\n        // get using i piles and j coins used.\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n        // Since we want to be dealing with the sums of coins,\\n        // it would be real convenient, if our piles just stored\\n        // the prefix sum instead. This can be done on the piles\\n        // matrix directly, however, it is a good practice to not\\n        // to change anything provided in the problem. Make pref\\n        vector<vector<int>> pref(n, vector<int>()); // prefix-sum\\n        for (int i = 0; i < n; i++) {\\n            pref[i].resize(piles[i].size()); // uneven matrix so resize()\\n            pref[i][0] = piles[i][0]; // initialize for pref_sum\\n            for (int j = 1; j < piles[i].size(); j++) {\\n                // calculating prefix sum\\n                pref[i][j] = pref[i][j - 1] + piles[i][j];\\n            }\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                // Let the coins chosen from the current pile be cur\\n                for (int cur = 0; cur <= piles[i - 1].size(); cur++) {\\n                    // Check for all combinations of coins that sum up to j coins.\\n                    // We can pick w coins from this pile and j-w coins from previous piles (dp[i-1][j-w]).\\n                    // i.e., (j-w) + w = j coins in total.\\n                    if(cur <= j)\\n                        if(cur > 0){\\n                            // if cur > 0 we can consider prefix sum since in-bounds\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + pref[i - 1][cur - 1]);\\n                        }\\n                        else{\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur]);\\n                        }\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n\\n\\n```\\nPython code for the same:\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        pref = [[] for _ in range(n)]  \\n        for i in range(n):\\n            pref[i] = [0] * len(piles[i])  \\n            pref[i][0] = piles[i][0]  \\n            for j in range(1, len(piles[i])):\\n                pref[i][j] = pref[i][j - 1] + piles[i][j]\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, k + 1):\\n                for cur in range(len(piles[i - 1]) + 1):\\n                    if cur <= j:\\n                        if cur > 0:\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + pref[i - 1][cur - 1])\\n                        else:\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur])\\n        return dp[n][k]\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        // total n piles and k coins we can choose.\\n        // so for any dp[i][j] it will store the max coins we\\n        // get using i piles and j coins used.\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n        // Since we want to be dealing with the sums of coins,\\n        // it would be real convenient, if our piles just stored\\n        // the prefix sum instead. This can be done on the piles\\n        // matrix directly, however, it is a good practice to not\\n        // to change anything provided in the problem. Make pref\\n        vector<vector<int>> pref(n, vector<int>()); // prefix-sum\\n        for (int i = 0; i < n; i++) {\\n            pref[i].resize(piles[i].size()); // uneven matrix so resize()\\n            pref[i][0] = piles[i][0]; // initialize for pref_sum\\n            for (int j = 1; j < piles[i].size(); j++) {\\n                // calculating prefix sum\\n                pref[i][j] = pref[i][j - 1] + piles[i][j];\\n            }\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                // Let the coins chosen from the current pile be cur\\n                for (int cur = 0; cur <= piles[i - 1].size(); cur++) {\\n                    // Check for all combinations of coins that sum up to j coins.\\n                    // We can pick w coins from this pile and j-w coins from previous piles (dp[i-1][j-w]).\\n                    // i.e., (j-w) + w = j coins in total.\\n                    if(cur <= j)\\n                        if(cur > 0){\\n                            // if cur > 0 we can consider prefix sum since in-bounds\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + pref[i - 1][cur - 1]);\\n                        }\\n                        else{\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur]);\\n                        }\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        pref = [[] for _ in range(n)]  \\n        for i in range(n):\\n            pref[i] = [0] * len(piles[i])  \\n            pref[i][0] = piles[i][0]  \\n            for j in range(1, len(piles[i])):\\n                pref[i][j] = pref[i][j - 1] + piles[i][j]\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, k + 1):\\n                for cur in range(len(piles[i - 1]) + 1):\\n                    if cur <= j:\\n                        if cur > 0:\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + pref[i - 1][cur - 1])\\n                        else:\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur])\\n        return dp[n][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059614,
                "title": "java-knapsack-variation-dynammic-programming-easy-to-undestand",
                "content": "TC - O(N*M) \\nn=size of piles,\\nm=size of piles[i]\\n\\nclass Solution {\\n    public int helper(List<List<Integer>> piles,int idx,int k,int [][]dp){\\n        \\n        if(idx<0 || k == 0) return 0;\\n        if(dp[idx][k] != -1) return dp[idx][k];\\n        \\n    \\n        // exclude case \\n        int exclude = helper(piles,idx-1,k,dp);\\n        \\n        \\n        // include case\\n        int sum = 0;\\n        int include = 0;\\n        \\n        List<Integer> curr_pile = piles.get(idx);\\n        \\n        for(int i=0;i<Math.min(curr_pile.size(),k);i++){\\n            sum += curr_pile.get(i);\\n            include = Math.max(sum + helper(piles,idx-1,k-i-1,dp),include);\\n        }\\n        return dp[idx][k] = Math.max(include,exclude);\\n    }\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n       \\n        int n = piles.size();\\n        int [][]dp = new int[n+1][k+1];\\n        for(int []d:dp) Arrays.fill(d,-1);\\n        \\n        return helper(piles,n-1,k,dp);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int helper(List<List<Integer>> piles,int idx,int k,int [][]dp){\\n        \\n        if(idx<0 || k == 0) return 0;\\n        if(dp[idx][k] != -1) return dp[idx][k];\\n        \\n    \\n        // exclude case \\n        int exclude = helper(piles,idx-1,k,dp);\\n        \\n        \\n        // include case\\n        int sum = 0;\\n        int include = 0;\\n        \\n        List<Integer> curr_pile = piles.get(idx);\\n        \\n        for(int i=0;i<Math.min(curr_pile.size(),k);i++){\\n            sum += curr_pile.get(i);\\n            include = Math.max(sum + helper(piles,idx-1,k-i-1,dp),include);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1901374,
                "title": "recursion-to-space-optimized-dp-java-explained-solution-easy-to-understand",
                "content": "\\nThis question is a variation of 0/1 Unbounded Knapsack. Here we are allowed to pick coins any no. of times with 2 included constraints. \\n- These picking up of coins from a particular pile cannot exceed k\\n- The coins in a particular pile are of different denomination\\n\\nIf these two constraints are removed the question is basic 0/1 Unbounded knapsack. So, similarly we have two options to go for.\\n- either to not pick any coin from a pile\\n- or pick 1 to k coins from a pile\\n\\nRecursion\\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        return solve(piles,n,k);\\n    }\\n    \\n    public int solve(List<List<Integer>> piles,int i,int k){\\n        if(k==0)return 0;\\n        if(i==0)return 0;\\n        int best=solve(piles,i-1,k);\\n        List<Integer> pile=piles.get(i-1);\\n        int sum=0;\\n        for(int x=0;x<Math.min(k,pile.size());x++){\\n            sum+=pile.get(x);\\n            best=Math.max(best,+solve(piles,i-1,k-(x+1)));\\n        }\\n        return best;\\n    }\\n```\\nTC= Exponential (For every pile we have either to pick upto k coins or not pick at all)\\nSC= O(nk)\\n\\nRecursion with Memoization\\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n\\t\\tint[][] dp=new int[n+1][k+1];\\n        for(int i=0;i<=n;i++)\\n\\t\\t\\tArrays.fill(dp[i],-1);\\n        return solve(piles,n,k,dp);\\n    }\\n    \\n    public int solve(List<List<Integer>> piles,int i,int k,int[][] dp){\\n\\t\\tif(k==0)return 0;\\n        if(i==0)return 0;\\n\\t\\tif(dp[i][k]!=-1)return dp[i][k];\\n        int best=solve(piles,i-1,k,dp);\\n        List<Integer> pile=piles.get(i-1);\\n        int sum=0;\\n        for(int x=0;x<Math.min(k,pile.size());x++){\\n            sum+=pile.get(x);\\n            best=Math.max(best,+solve(piles,i-1,k-(x+1),dp));\\n        }\\n        return dp[i][k]= best;\\n    }\\n```\\nTC= O(nk)\\nSC= O(nk)+O(nk)\\n\\nTabulation DP\\n```\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[][] dp=new int[n+1][k+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=k;j++){\\n                if(i==0 || j==0)dp[i][j]=0;\\n                else{\\n                    int best=dp[i-1][j];\\n                    List<Integer> pile=piles.get(i-1);\\n                    int sum=0;\\n                    for(int x=0;x<Math.min(j,pile.size());x++){\\n                        sum+=pile.get(x);\\n                        best=Math.max(best,sum+dp[i-1][j-(x+1)]);\\n                    }\\n                    dp[i][j]= best;\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n```\\nTC= O(nk)\\nSC= O(nk)\\n\\nTabulation DP with Space optimization\\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] prev=new int[k+1];\\n        for(int i=0;i<=n;i++){\\n            int[] curr=new int[k+1];\\n            for(int j=0;j<=k;j++){\\n                if(i==0 || j==0)curr[j]=0;\\n                else{\\n                    int best=prev[j];\\n                    List<Integer> pile=piles.get(i-1);\\n                    int sum=0;\\n                    for(int x=0;x<Math.min(j,pile.size());x++){\\n                        sum+=pile.get(x);\\n                        best=Math.max(best,sum+prev[j-(x+1)]);\\n                    }\\n                    curr[j]= best;\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[k];\\n    }\\n```\\nTC= O(nk)\\nSC= O(2k)=O(k)\\n\\nHope you liked the solution. If yes, do upvote. Thanks!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        return solve(piles,n,k);\\n    }\\n    \\n    public int solve(List<List<Integer>> piles,int i,int k){\\n        if(k==0)return 0;\\n        if(i==0)return 0;\\n        int best=solve(piles,i-1,k);\\n        List<Integer> pile=piles.get(i-1);\\n        int sum=0;\\n        for(int x=0;x<Math.min(k,pile.size());x++){\\n            sum+=pile.get(x);\\n            best=Math.max(best,+solve(piles,i-1,k-(x+1)));\\n        }\\n        return best;\\n    }\\n```\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n\\t\\tint[][] dp=new int[n+1][k+1];\\n        for(int i=0;i<=n;i++)\\n\\t\\t\\tArrays.fill(dp[i],-1);\\n        return solve(piles,n,k,dp);\\n    }\\n    \\n    public int solve(List<List<Integer>> piles,int i,int k,int[][] dp){\\n\\t\\tif(k==0)return 0;\\n        if(i==0)return 0;\\n\\t\\tif(dp[i][k]!=-1)return dp[i][k];\\n        int best=solve(piles,i-1,k,dp);\\n        List<Integer> pile=piles.get(i-1);\\n        int sum=0;\\n        for(int x=0;x<Math.min(k,pile.size());x++){\\n            sum+=pile.get(x);\\n            best=Math.max(best,+solve(piles,i-1,k-(x+1),dp));\\n        }\\n        return dp[i][k]= best;\\n    }\\n```\n```\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[][] dp=new int[n+1][k+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=k;j++){\\n                if(i==0 || j==0)dp[i][j]=0;\\n                else{\\n                    int best=dp[i-1][j];\\n                    List<Integer> pile=piles.get(i-1);\\n                    int sum=0;\\n                    for(int x=0;x<Math.min(j,pile.size());x++){\\n                        sum+=pile.get(x);\\n                        best=Math.max(best,sum+dp[i-1][j-(x+1)]);\\n                    }\\n                    dp[i][j]= best;\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n```\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] prev=new int[k+1];\\n        for(int i=0;i<=n;i++){\\n            int[] curr=new int[k+1];\\n            for(int j=0;j<=k;j++){\\n                if(i==0 || j==0)curr[j]=0;\\n                else{\\n                    int best=prev[j];\\n                    List<Integer> pile=piles.get(i-1);\\n                    int sum=0;\\n                    for(int x=0;x<Math.min(j,pile.size());x++){\\n                        sum+=pile.get(x);\\n                        best=Math.max(best,sum+prev[j-(x+1)]);\\n                    }\\n                    curr[j]= best;\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[k];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887263,
                "title": "cpp-dp-recursive-approach-easy-to-understand",
                "content": "**Explantion**: The problem is similar to knapsack\\'s dp solution, where everything all boils down to select / not select current value. Similary In this problem we traverse pile by pile (denoted by `i`) and for every value in pile (`j`) we select (add `pile[i][j]` to our wallet) or we move to next pile (`i+1`). For Memoization, we make use of variables `i` and `k` denoting pile number and coin added in wallet respectively. We store value in DP vector only when our value of `j` is 0 i.e we have moved to new pile.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int solve (vector<vector<int>> &piles, int i, int j, int k, vector<vector<int>> &dp) {\\n        if (k == 0)\\n            return 0;\\n        \\n        if (i >= piles.size())\\n            return INT_MIN;\\n        \\n        if (j >= piles[i].size())\\n            return solve (piles, i+1, 0, k, dp); // emptied current pile, move to next pile\\n\\t\\t\\t\\n        if (dp[i][k] != -1 && j == 0)\\n            return dp[i][k];\\n\\t\\t\\t\\n        int a = 0, b = 0;\\n        a = solve (piles, i, j+1, k-1, dp) + piles[i][j];   // Pick current pile\\'s top\\n        b = solve (piles, i+1, 0, k, dp);                   // Don\\'t pick and move to next pile\\n        \\n        if (j == 0)\\n            dp[i][k] = max (a, b);\\n        \\n        return max (a, b);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));\\n        int ans = solve (piles, 0, 0, k, dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve (vector<vector<int>> &piles, int i, int j, int k, vector<vector<int>> &dp) {\\n        if (k == 0)\\n            return 0;\\n        \\n        if (i >= piles.size())\\n            return INT_MIN;\\n        \\n        if (j >= piles[i].size())\\n            return solve (piles, i+1, 0, k, dp); // emptied current pile, move to next pile\\n\\t\\t\\t\\n        if (dp[i][k] != -1 && j == 0)\\n            return dp[i][k];\\n\\t\\t\\t\\n        int a = 0, b = 0;\\n        a = solve (piles, i, j+1, k-1, dp) + piles[i][j];   // Pick current pile\\'s top\\n        b = solve (piles, i+1, 0, k, dp);                   // Don\\'t pick and move to next pile\\n        \\n        if (j == 0)\\n            dp[i][k] = max (a, b);\\n        \\n        return max (a, b);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));\\n        int ans = solve (piles, 0, 0, k, dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887025,
                "title": "java-top-down-dp",
                "content": "**Logic**\\nYou have n piles\\nSo you can take from `ith` pile min = 0 coins and atmost max(sizeOf(pile), k) \\nWe can do it with dynamic programming using dp table\\n\\n\\n```\\nclass Solution {\\n    Integer dp[][]; // store state\\n    private int solve(List<List<Integer>>piles, int i, int k){\\n        // if i < 0 there are no piles or \\n        // k <= 0 you cannnot pick any \\n        // return 0\\n        if(i < 0 || k <= 0) return 0; \\n        // if already stored that state return value\\n        if(dp[i][k] != null) return dp[i][k];\\n        // you can take max(size of that pile, k)\\n        int n = Math.min(piles.get(i).size(), k);\\n        // you will not choose that pile\\n        int exclude = solve(piles, i-1, k);\\n        // you will take 1, 2, ... k from that pile\\n        // and store the max in \\'include\\' variable\\n        int include = 0;\\n        for(int j=0, sum=0; j<n; j++){\\n            // store the sum from 0th index to jth index\\n            sum += piles.get(i).get(j);\\n            // take max from (sum + remaining k coins) and max value \\n            include = Math.max(sum + solve(piles, i-1, k-j-1), include);\\n        }\\n        // take max of include, exclude\\n        int res = Math.max(include, exclude);\\n        // store in dp\\n        dp[i][k] = res;\\n        return res;\\n    }\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        dp = new Integer[n+5][k+5];\\n        return solve(piles, piles.size()-1, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][]; // store state\\n    private int solve(List<List<Integer>>piles, int i, int k){\\n        // if i < 0 there are no piles or \\n        // k <= 0 you cannnot pick any \\n        // return 0\\n        if(i < 0 || k <= 0) return 0; \\n        // if already stored that state return value\\n        if(dp[i][k] != null) return dp[i][k];\\n        // you can take max(size of that pile, k)\\n        int n = Math.min(piles.get(i).size(), k);\\n        // you will not choose that pile\\n        int exclude = solve(piles, i-1, k);\\n        // you will take 1, 2, ... k from that pile\\n        // and store the max in \\'include\\' variable\\n        int include = 0;\\n        for(int j=0, sum=0; j<n; j++){\\n            // store the sum from 0th index to jth index\\n            sum += piles.get(i).get(j);\\n            // take max from (sum + remaining k coins) and max value \\n            include = Math.max(sum + solve(piles, i-1, k-j-1), include);\\n        }\\n        // take max of include, exclude\\n        int res = Math.max(include, exclude);\\n        // store in dp\\n        dp[i][k] = res;\\n        return res;\\n    }\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        dp = new Integer[n+5][k+5];\\n        return solve(piles, piles.size()-1, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418187,
                "title": "easy-c-dp",
                "content": "# Intuition\\nSome point that are directly hit to mind.\\n`if we take piles[i][j] coin we need to take all the coins above index j in that i pile.`\\n\\n`from above we can conlude that instead of taking one by one coin from a given row we take in bunch`\\n\\n# Approach\\n\\n`TRY ALL POSSIBLE WAYS`\\n\\n`To take bunch of coins we used presum of all indivisual piles of coins`\\n```\\nfor(int i=0;i<n;i++){\\n  int su=0;\\n    for( int a : pp[i]){\\n        pre[i].push_back(su);\\n        su+=a;\\n    }\\n    pre[i].push_back(su);\\n}\\n```\\nZero index means we are not taking any coin from that pile.\\n\\nNow we can take connect whole problem to 0/1 knapsack\\n\\nNeed to select a index from every presum of piles of coins and add to aur answer , and eqaully dicreasing count of k.\\n\\n`NOW USE DP`\\n\\nHere we can easily see only current number of pile and count remaning to add (k) is changing in our recursive code.\\n\\nso lets make 2D DP vector to store. \\n\\n# Complexity\\n- Time complexity:\\nO(N2)    {mota mota}\\n\\n- Space complexity:\\nO(N*K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(vector<vector<int>> &pp , int cu , int k, vector<vector<int>> &dp ){\\n        if(cu>=pp.size()) return 0;\\n        if(dp[cu][k] != -1 ) return dp[cu][k];\\n        int mx=0;\\n        for(int i=0;i<pp[cu].size();i++){\\n            if(k-i>=0) mx = max(mx , pp[cu][i]+fun(pp,cu+1,k-i,dp));\\n        }\\n        return dp[cu][k] = mx;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& pp, int k) {\\n        int  n = pp.size();\\n        vector<vector<int>> pre(n);\\n        vector<vector<int>> dp(n+2,vector<int>(k+2,-1));\\n        for(int i=0;i<n;i++){\\n            int su=0;\\n            for( int a : pp[i]){\\n                pre[i].push_back(su);\\n                su+=a;\\n            }\\n            pre[i].push_back(su);\\n        }\\n        return fun(pre,0,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor(int i=0;i<n;i++){\\n  int su=0;\\n    for( int a : pp[i]){\\n        pre[i].push_back(su);\\n        su+=a;\\n    }\\n    pre[i].push_back(su);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int fun(vector<vector<int>> &pp , int cu , int k, vector<vector<int>> &dp ){\\n        if(cu>=pp.size()) return 0;\\n        if(dp[cu][k] != -1 ) return dp[cu][k];\\n        int mx=0;\\n        for(int i=0;i<pp[cu].size();i++){\\n            if(k-i>=0) mx = max(mx , pp[cu][i]+fun(pp,cu+1,k-i,dp));\\n        }\\n        return dp[cu][k] = mx;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& pp, int k) {\\n        int  n = pp.size();\\n        vector<vector<int>> pre(n);\\n        vector<vector<int>> dp(n+2,vector<int>(k+2,-1));\\n        for(int i=0;i<n;i++){\\n            int su=0;\\n            for( int a : pp[i]){\\n                pre[i].push_back(su);\\n                su+=a;\\n            }\\n            pre[i].push_back(su);\\n        }\\n        return fun(pre,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418060,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def dp(i,K):\\n            if k==0 or i==len(piles):\\n                return 0\\n\\n            res,cur=dp(i+1,K),0\\n\\n            for j in range(min(len(piles[i]),K)):\\n                cur+=piles[i][j]\\n                res=max(res,cur+dp(i+1,K-j-1))\\n\\n            return res\\n\\n\\n        return dp(0,k)          \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def dp(i,K):\\n            if k==0 or i==len(piles):\\n                return 0\\n\\n            res,cur=dp(i+1,K),0\\n\\n            for j in range(min(len(piles[i]),K)):\\n                cur+=piles[i][j]\\n                res=max(res,cur+dp(i+1,K-j-1))\\n\\n            return res\\n\\n\\n        return dp(0,k)          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683141,
                "title": "easy-understanding-dp-memoziation-solution",
                "content": "UPVOTE IF YOU LIKE THE SOLUTION.\\n```\\nclass Solution {\\npublic:\\n    //memoization Solution\\n    int helper(int i, vector<vector<int>>& piles, int k, vector<vector<int>>& dp){\\n        //base condition\\n        if(i == piles.size() || k <= 0){\\n            return 0;\\n        }\\n        \\n        //check if this condition is reached before\\n        if(dp[i][k] != -1){\\n            return dp[i][k];\\n        }\\n        \\n        long long ans = INT_MIN;\\n        for(int j = 0; j < piles[i].size(); j++){\\n            //if j becomes greater than k-1 break\\n            if(j > k-1)\\n                break;\\n            \\n            //take starting j+1 coins from the ith pile\\n            long long take = piles[i][j] + helper(i+1, piles, k-j-1, dp);\\n            \\n            //store the max value in ans\\n            ans = max(ans, take);\\n        }\\n        \\n        //donot take any coins from ith piles\\n        long long ntake = helper(i+1, piles, k, dp);\\n        ans = max(ans, ntake);\\n        \\n        //memoize it\\n        return dp[i][k] = ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //dp vector\\n        vector<vector<int>> dp(piles.size(), vector<int>(k+1,-1));\\n        \\n        //prefix vector\\n        vector<vector<int>> prefix;\\n        for(auto a: piles){\\n            int n = a.size();\\n            vector<int> temp(n);\\n            temp[0] = a[0];\\n            for(int i = 1; i < n; i++){\\n                temp[i] = temp[i-1] + a[i];\\n            }\\n            prefix.push_back(temp);\\n        }\\n        return helper(0, prefix, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //memoization Solution\\n    int helper(int i, vector<vector<int>>& piles, int k, vector<vector<int>>& dp){\\n        //base condition\\n        if(i == piles.size() || k <= 0){\\n            return 0;\\n        }\\n        \\n        //check if this condition is reached before\\n        if(dp[i][k] != -1){\\n            return dp[i][k];\\n        }\\n        \\n        long long ans = INT_MIN;\\n        for(int j = 0; j < piles[i].size(); j++){\\n            //if j becomes greater than k-1 break\\n            if(j > k-1)\\n                break;\\n            \\n            //take starting j+1 coins from the ith pile\\n            long long take = piles[i][j] + helper(i+1, piles, k-j-1, dp);\\n            \\n            //store the max value in ans\\n            ans = max(ans, take);\\n        }\\n        \\n        //donot take any coins from ith piles\\n        long long ntake = helper(i+1, piles, k, dp);\\n        ans = max(ans, ntake);\\n        \\n        //memoize it\\n        return dp[i][k] = ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //dp vector\\n        vector<vector<int>> dp(piles.size(), vector<int>(k+1,-1));\\n        \\n        //prefix vector\\n        vector<vector<int>> prefix;\\n        for(auto a: piles){\\n            int n = a.size();\\n            vector<int> temp(n);\\n            temp[0] = a[0];\\n            for(int i = 1; i < n; i++){\\n                temp[i] = temp[i-1] + a[i];\\n            }\\n            prefix.push_back(temp);\\n        }\\n        return helper(0, prefix, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520676,
                "title": "python-explained-with-diagram-iterative-dp-solution-beats-98-tc",
                "content": "Worst Case time complexity = O(n*k^2)\\n\\n**Intuition** - Let\\'s say we are standing at pile[i] and have already computed piles<i. And we have calculated the maximum possible sum of r (0<r<=k) number of coins uptill pile[i]. Now to calculate maximum possible sum using pile[i]  following steps can be followed:-\\n1) maximum sum uptill pile[i] is stored in array max_arr for 0<coins<=k\\n2) maintain an array cur_arr which stores coin sum including pile[i]. In pile[i], we have to calculate sum one by one using  0<top-coins<=k from pile[i]. cur_arr will hold the maximum value for a particular no. of coins less than using pile[i].\\n3) After cur_arr is calculated using k coins of pile[i], max_arr is updated to include greater values from cur_arr.\\n4) After all n piles are iterated, return max_arr[k].\\n  ![image](https://assets.leetcode.com/users/images/219e4955-2835-4798-a905-b715042b5a07_1662145396.921648.jpeg)![image](https://assets.leetcode.com/users/images/44ad72f0-8d6e-4775-ba27-aec22309741d_1662145445.133529.jpeg)\\n![image](https://assets.leetcode.com/users/images/fc346985-0b6e-4cb5-9d5c-27f6b126a5a4_1662146313.2433224.jpeg)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        n=len(piles)\\n        topk=[]\\n            \\n        cur_arr=[0]*(k+1)\\n        max_arr=[0]*(k+1)\\n        \\n        for x in piles:\\n            i=0\\n            cursum=0\\n            while i<k and i<len(x):\\n                cursum+=x[i]\\n                j=0\\n                while i+1+j<=k:\\n                    if j>0 and max_arr[j]==0:\\n                        break\\n                    cur_arr[i+1+j]=max(cur_arr[i+1+j],max_arr[j]+cursum)\\n                    j+=1\\n                i+=1\\n                \\n            for t in range(i+j):\\n                if cur_arr[t]>max_arr[t]:\\n                    max_arr[t]=cur_arr[t]\\n                    \\n        return max_arr[k]\\n            \\n            \\n                ```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        n=len(piles)\\n        topk=[]\\n            \\n        cur_arr=[0]*(k+1)\\n        max_arr=[0]*(k+1)\\n        \\n        for x in piles:\\n            i=0\\n            cursum=0\\n            while i<k and i<len(x):\\n                cursum+=x[i]\\n                j=0\\n                while i+1+j<=k:\\n                    if j>0 and max_arr[j]==0:\\n                        break\\n                    cur_arr[i+1+j]=max(cur_arr[i+1+j],max_arr[j]+cursum)\\n                    j+=1\\n                i+=1\\n                \\n            for t in range(i+j):\\n                if cur_arr[t]>max_arr[t]:\\n                    max_arr[t]=cur_arr[t]\\n                    \\n        return max_arr[k]\\n            \\n            \\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 1896747,
                "title": "dp-memoization-well-explained-c",
                "content": "The main idea here is to use **Dynamic programming** and I have used **prefix sum** to get the total sum of the top elements uptil the index where I am standing at any instance.\\n\\nDp states are :  (index , k) \\n* ***index*** defines the stack which we are currently on \\n* ***k*** defines the number of elements which we can remove from the top of the stacks\\n\\nWe have 2 choice sstanding at any index : either take the elements \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tor skip the current stack and find for optimal answers in other indexes;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nIf we take the elements from the stack we have options to take as much elements from the current stack as we want( limitations : until k gets finished or the stack gets finished ) by running a loop we can iterate over all the possibilities and get the optimal option from it.\\n\\nDo upvote if you like my approach!! \\n\\n```\\nclass Solution {\\n    \\n    int help(int ind , int k, vector<vector<int>>&a, vector<vector<int>>&dp){\\n\\t\\t//base cases\\n\\t\\tif(k == 0)  return 0;\\n        if(k < 0)   return INT_MIN;\\n        if(ind < 0)    return 0;\\n\\t\\t\\n\\t\\t//memoization step\\n        int &ans = dp[ind][k];\\n        if(ans != -1)   return ans;     \\n\\t\\t//you can either skip the current stack or take from it\\n\\t\\t\\n        ans = help(ind-1, k , a, dp);  // option 1. skip the current stack\\n        int current_pile_size = a[ind].size();\\n\\t\\t// this is the limit of elements you can take from the current stack\\n        int limit = min(k, current_pile_size-1);  \\n        \\n        for(int i=0;i<=limit;i++){ //this loop will give me how many items i can take from the stack\\n            int take = a[ind][i] ;   // since prefix sum is done we get the total elements uptil this index using a[ind][i]\\n            ans = max(ans, take + help(ind-1, k-i-1, a, dp));  // we take the max of all the available options\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int size = piles.size(); \\n        for(auto &it: piles){\\n            int n = it.size();\\n            for(int i=1;i<n;i++)\\n                it[i] += it[i-1];  // prefix sum ...so we can get cumulative sum upto a point\\n        }\\n        vector<vector<int>>dp(size+1, vector<int>(k+1, -1));\\n        return help(size-1, k, piles, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int help(int ind , int k, vector<vector<int>>&a, vector<vector<int>>&dp){\\n\\t\\t//base cases\\n\\t\\tif(k == 0)  return 0;\\n        if(k < 0)   return INT_MIN;\\n        if(ind < 0)    return 0;\\n\\t\\t\\n\\t\\t//memoization step\\n        int &ans = dp[ind][k];\\n        if(ans != -1)   return ans;     \\n\\t\\t//you can either skip the current stack or take from it\\n\\t\\t\\n        ans = help(ind-1, k , a, dp);  // option 1. skip the current stack\\n        int current_pile_size = a[ind].size();\\n\\t\\t// this is the limit of elements you can take from the current stack\\n        int limit = min(k, current_pile_size-1);  \\n        \\n        for(int i=0;i<=limit;i++){ //this loop will give me how many items i can take from the stack\\n            int take = a[ind][i] ;   // since prefix sum is done we get the total elements uptil this index using a[ind][i]\\n            ans = max(ans, take + help(ind-1, k-i-1, a, dp));  // we take the max of all the available options\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int size = piles.size(); \\n        for(auto &it: piles){\\n            int n = it.size();\\n            for(int i=1;i<n;i++)\\n                it[i] += it[i-1];  // prefix sum ...so we can get cumulative sum upto a point\\n        }\\n        vector<vector<int>>dp(size+1, vector<int>(k+1, -1));\\n        return help(size-1, k, piles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887607,
                "title": "typescript-dp-iterative-beats-100-00-time-o-nk-2-space-o-k",
                "content": "Time: O(nk^2)\\nSpace: O(k)\\nLanguage: javascript, typescript\\n\\nRuntime: 325 ms, faster than 100.00%\\nMemory Usage: 45.1 MB, less than 100.00%\\n\\n```\\nfunction maxValueOfCoins(piles: number[][], coins: number): number {\\n    let dp = new Array(coins + 1).fill(0);\\n    \\n    for (let i = 0; i < piles.length; ++i) {\\n\\t    for (let j = coins; j > 0; --j) {\\n\\t\\t\\t// \"sum\" is a count of coins from piles[i]\\n            let sum = 0;\\n\\n            for (let k = 1; k <= Math.min(j, piles[i].length); k++) {\\n                sum += piles[i][k - 1];\\n\\n\\t\\t\\t\\t// take \"k\" coins from piles[i] and the previous best \"j-k\" coins\\n                dp[j] = Math.max(dp[j], dp[j-k] + sum);\\n            }\\n        }\\n    }\\n    \\n    return dp[coins];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nfunction maxValueOfCoins(piles: number[][], coins: number): number {\\n    let dp = new Array(coins + 1).fill(0);\\n    \\n    for (let i = 0; i < piles.length; ++i) {\\n\\t    for (let j = coins; j > 0; --j) {\\n\\t\\t\\t// \"sum\" is a count of coins from piles[i]\\n            let sum = 0;\\n\\n            for (let k = 1; k <= Math.min(j, piles[i].length); k++) {\\n                sum += piles[i][k - 1];\\n\\n\\t\\t\\t\\t// take \"k\" coins from piles[i] and the previous best \"j-k\" coins\\n                dp[j] = Math.max(dp[j], dp[j-k] + sum);\\n            }\\n        }\\n    }\\n    \\n    return dp[coins];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420493,
                "title": "python-3-9-lines-recursion-t-m-91-33",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```\\n[https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/submissions/934256020/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*^2).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420464,
                "title": "python-3-9-lines-recursion-t-m-91-33",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```\\n[https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/submissions/934247436/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*^2).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418977,
                "title": "rust-dp-concise",
                "content": "# Intuition\\nThis is dynamic programming task. The only tricky part is to find subtask.\\nThe subtask is to solve it for smaller number of piles (i left most piles) and for smaller k.\\nOn each step we iterate over new pile for all numbers from `0` to `k` and search for best value of `l` coins from new pile and `k - l` from previous subtask.\\n\\n\\n# Code\\n```\\nuse std::cmp::{min,max};\\n\\nimpl Solution {\\n    pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let mut dp = vec![vec![0; k + 1]; piles.len() + 1];\\n        for i in 1..dp.len() {\\n            for j in 1..k + 1 {\\n                let mut s = 0;\\n                for l in 0..min(j + 1, piles[i - 1].len() + 1) {\\n                    dp[i][j] = max(dp[i][j], s + dp[i - 1][j - l]);\\n                    if l < piles[i - 1].len() {\\n                        s += piles[i - 1][l];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[piles.len()][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::{min,max};\\n\\nimpl Solution {\\n    pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let mut dp = vec![vec![0; k + 1]; piles.len() + 1];\\n        for i in 1..dp.len() {\\n            for j in 1..k + 1 {\\n                let mut s = 0;\\n                for l in 0..min(j + 1, piles[i - 1].len() + 1) {\\n                    dp[i][j] = max(dp[i][j], s + dp[i - 1][j - l]);\\n                    if l < piles[i - 1].len() {\\n                        s += piles[i - 1][l];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[piles.len()][k];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418374,
                "title": "c-memoization-dp-easy-to-understnad",
                "content": "````\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &v,vector<vector<int>> &dp,int s,int k,int &n){\\n        if(s>=n)return 0;\\n        if(k==0)return 0;\\n        if(dp[s][k] != -1)return dp[s][k];\\n        int mx = solve(v,dp,s+1,k,n);\\n        int cur = 0;\\n        for(int i = 0; i < v[s].size(); i++){\\n            cur += v[s][i];\\n            if(k-i-1 >= 0){\\n                mx = max(mx,cur+solve(v,dp,s+1,k-i-1,n));\\n            }\\n        }\\n        return dp[s][k] = mx;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(piles,dp,0,k,n);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &v,vector<vector<int>> &dp,int s,int k,int &n){\\n        if(s>=n)return 0;\\n        if(k==0)return 0;\\n        if(dp[s][k] != -1)return dp[s][k];\\n        int mx = solve(v,dp,s+1,k,n);\\n        int cur = 0;\\n        for(int i = 0; i < v[s].size(); i++){\\n            cur += v[s][i];\\n            if(k-i-1 >= 0){\\n                mx = max(mx,cur+solve(v,dp,s+1,k-i-1,n));\\n            }\\n        }\\n        return dp[s][k] = mx;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(piles,dp,0,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418160,
                "title": "basic-approach-java-dp",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        //dp[i][j] means when we just use the first i piles and j picks, the maximum coins we can get\\n        int[][] dp = new int[piles.size()+1][k+1];\\n        for (int i = 1; i <= piles.size(); i++){\\n            for (int j = 1; j <= k; j++){\\n                int sum = 0;\\n                // At first we don\\'t pick anything, so the coins you can get is the same and for i-1 condition\\n                dp[i][j] = dp[i-1][j];\\n                //Begin to traverse the ith pile\\n                //Note here we use min function to prevent index out of bound\\n                for (int h = 0; h < Math.min(j, piles.get(i-1).size()); h++){\\n                    //We take the current (hth) coin\\n                    sum += piles.get(i-1).get(h);\\n                    //Check if pick it can maximize our score\\n                    //Note that if we pick it, we can only get the coins for j-1-h picks when we are at i-1th coin\\n                    dp[i][j] = Math.max(dp[i][j], sum + dp[i-1][j-1-h]);\\n                }\\n            }\\n        }\\n        //The result is when we use all of the piles and k picks\\n        return dp[piles.size()][k]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        //dp[i][j] means when we just use the first i piles and j picks, the maximum coins we can get\\n        int[][] dp = new int[piles.size()+1][k+1];\\n        for (int i = 1; i <= piles.size(); i++){\\n            for (int j = 1; j <= k; j++){\\n                int sum = 0;\\n                // At first we don\\'t pick anything, so the coins you can get is the same and for i-1 condition\\n                dp[i][j] = dp[i-1][j];\\n                //Begin to traverse the ith pile\\n                //Note here we use min function to prevent index out of bound\\n                for (int h = 0; h < Math.min(j, piles.get(i-1).size()); h++){\\n                    //We take the current (hth) coin\\n                    sum += piles.get(i-1).get(h);\\n                    //Check if pick it can maximize our score\\n                    //Note that if we pick it, we can only get the coins for j-1-h picks when we are at i-1th coin\\n                    dp[i][j] = Math.max(dp[i][j], sum + dp[i-1][j-1-h]);\\n                }\\n            }\\n        }\\n        //The result is when we use all of the piles and k picks\\n        return dp[piles.size()][k]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418100,
                "title": "easy-to-understand-python-logically-explained-dp",
                "content": "**Pre-Requisites - 0/1 Knapsack**\\n\\n**Solution -**\\nLet\\'s do some ground work first.\\nFor all the piles we can make them into prefix sum arrays\\neg:- [2, 7, 3] -> [0, 2, 9, 12]\\nNow the question is not how many of elements of each array to take rather which element of each prefix sum array to take.\\nAlso, we can associate weights with each element (basically denoting the number of elements taken from that array).\\nTaking the previous array, [[0, 0], [2, 1], [9, 2], [12, 3]] - 0, 1, 2, 3 are the number of elements taken\\n\\nNow, we have to take one of them from each pile and the sum of weights should be k, seems kinda like knapsack, right?\\nThe only difference is we can\\'t independently take elements as taking [2, 1] & [9, 2] would just mean we\\'re taking the element \\'2\\' twice.\\nSo we have to take one element from each pile (more preceisely one element of prefix sum array)\\n\\nNow this is easily solvable as in 0/1 knapsack, we used to go to the previous row to check the maximum possible answer with remaining weight (column_number - weight) and in this we\\'ll go to the last row which contained weights from the previous pile and not the current one (to avoid picking up any weight twice)\\n\\n**Code -**\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        n = len(piles)\\n            \\n        prefix = []\\n        \\n        #prev array represents where the elements from last pile ended\\n        prev = [0]\\n        \\n        for pile in piles:\\n            curr = [0]\\n            for ele in pile:\\n                curr.append(curr[-1]+ele)\\n            prefix.append(curr)\\n            \\n            prev.append(prev[-1]+len(pile))\\n            \\n        dp = [[0]*(k+1) for i in range(prev[-1]+1)]\\n            \\n        for i in range(n):\\n            for j in range(1, len(prefix[i])):\\n                \\n                profit = prefix[i][j]\\n                wt = j\\n\\n                # lvl represents row number\\n                # We\\'ve given a different row to every prefix sum array element.   \\n                lvl = prev[i]+j \\n                \\n                for w in range(1, k+1): \\n                    if wt > w:\\n                        dp[lvl][w] = dp[lvl-1][w]\\n                    else:\\n                        dp[lvl][w] = max(dp[lvl-1][w], profit+dp[prev[i]][w-wt])\\n        return dp[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "**Pre-Requisites - 0/1 Knapsack**\\n\\n**Solution -**\\nLet\\'s do some ground work first.\\nFor all the piles we can make them into prefix sum arrays\\neg:- [2, 7, 3] -> [0, 2, 9, 12]\\nNow the question is not how many of elements of each array to take rather which element of each prefix sum array to take.\\nAlso, we can associate weights with each element (basically denoting the number of elements taken from that array).\\nTaking the previous array, [[0, 0], [2, 1], [9, 2], [12, 3]] - 0, 1, 2, 3 are the number of elements taken\\n\\nNow, we have to take one of them from each pile and the sum of weights should be k, seems kinda like knapsack, right?\\nThe only difference is we can\\'t independently take elements as taking [2, 1] & [9, 2] would just mean we\\'re taking the element \\'2\\' twice.\\nSo we have to take one element from each pile (more preceisely one element of prefix sum array)\\n\\nNow this is easily solvable as in 0/1 knapsack, we used to go to the previous row to check the maximum possible answer with remaining weight (column_number - weight) and in this we\\'ll go to the last row which contained weights from the previous pile and not the current one (to avoid picking up any weight twice)\\n\\n**Code -**\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        n = len(piles)\\n            \\n        prefix = []\\n        \\n        #prev array represents where the elements from last pile ended\\n        prev = [0]\\n        \\n        for pile in piles:\\n            curr = [0]\\n            for ele in pile:\\n                curr.append(curr[-1]+ele)\\n            prefix.append(curr)\\n            \\n            prev.append(prev[-1]+len(pile))\\n            \\n        dp = [[0]*(k+1) for i in range(prev[-1]+1)]\\n            \\n        for i in range(n):\\n            for j in range(1, len(prefix[i])):\\n                \\n                profit = prefix[i][j]\\n                wt = j\\n\\n                # lvl represents row number\\n                # We\\'ve given a different row to every prefix sum array element.   \\n                lvl = prev[i]+j \\n                \\n                for w in range(1, k+1): \\n                    if wt > w:\\n                        dp[lvl][w] = dp[lvl-1][w]\\n                    else:\\n                        dp[lvl][w] = max(dp[lvl-1][w], profit+dp[prev[i]][w-wt])\\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 3417985,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            int sz = piles[i-1].size();\\n            for(int j=1; j<=k; j++)\\n            {\\n                int tmp = dp[i-1][j];\\n                int curr = 0, s = 0;\\n                for(int t=1; t<=sz; t++)\\n                {\\n                    s += piles[i-1][t-1];\\n                    if(j-t >= 0)\\n                        curr = max(curr, dp[i-1][j-t] + s);\\n\\n                    dp[i][j] = max(dp[i-1][j], curr);\\n                }\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            int sz = piles[i-1].size();\\n            for(int j=1; j<=k; j++)\\n            {\\n                int tmp = dp[i-1][j];\\n                int curr = 0, s = 0;\\n                for(int t=1; t<=sz; t++)\\n                {\\n                    s += piles[i-1][t-1];\\n                    if(j-t >= 0)\\n                        curr = max(curr, dp[i-1][j-t] + s);\\n\\n                    dp[i][j] = max(dp[i-1][j], curr);\\n                }\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417871,
                "title": "daily-leetcoding-challenge-april-day-15",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1977616,
                "title": "java-c-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Java***\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];// k steps dynamic programming;\\n        // for each pile to do dp.\\n        for(List<Integer> pile:piles){\\n            //use prefix sum to record each pile\\'s first i elments;\\n            int m=pile.size();\\n            int[] cum=new int[m+1];\\n            for(int i=0;i<m;i++) cum[i+1]=cum[i]+pile.get(i);\\n            //use current pile to do dp, the dp is\\n            // we have two pile previous pile\\'s dp result and current pile--> reduce to two pile problem.\\n            // pile 0, 1 ,2 ,3 , 4, ...\\n            // pile (0,1),2,3,4...\\n            //      (0,1) is dp result for next calculation.\\n            // pile (0,1,2),3,4...\\n            // ...\\n            // pile (0,1,2,3,4... )\\n            int[] curdp=new int[k+1];\\n            for(int i=0;i<=k;i++){\\n                for(int j=0;j<=m&& i+j <=k;j++){\\n                    curdp[i+j]=Math.max(curdp[i+j],dp[i]+cum[j]);\\n                }\\n            }\\n            dp=curdp;\\n        }\\n        return dp[k];\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n   int dp[1001][2001]; //Dp array For Memoization.\\n   int solve(vector<vector<int>>&v,int index,int coin)\\n   {\\n       if(index>=v.size()||coin==0)  //Base Condition\\n           return 0;\\n       if(dp[index][coin]!=-1) //Check wheather It is Already Calculated Or not.\\n           return dp[index][coin];\\n       \\n       \\n       /* Our 1st choice :- We not take any Coin from that pile*/\\n       int ans=solve(v,index+1,coin); //Just Call function for next Pile.\\n       \\n      \\n       /*Otherwise we can take Coins from that Pile.*/\\n       int loop=v[index].size()-1;\\n       int sum=0;\\n       \\n       for(int j=0;j<=min(coin-1,loop);j++) //\\n       {\\n           sum=sum+v[index][j];\\n           ans=max(ans,sum+solve(v,index+1,coin-(j+1)));\\n           \\n           /*Aove we Pass coin-(j+1). Because till j\\'th index we have taken j+1 coin from that pile.*/\\n       }\\n       \\n       return dp[index][coin]=ans;\\n   }\\n   int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n       memset(dp,-1,sizeof(dp));\\n       return solve(piles,0,k);\\n   }\\n};\\n```\\n\\n***Python***\\n```\\nimport numpy as np\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        best = np.zeros(k+1)\\n        for pile in piles:\\n            temp = best.copy()\\n            for used, value in enumerate(accumulate(pile), 1):\\n                if used > k: break\\n                temp2 = best+value\\n                temp2 = np.concatenate((np.zeros(used), temp2[:-used]))\\n                temp = np.maximum(temp, temp2)\\n            best = temp\\n        return int(best[-1])\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];// k steps dynamic programming;\\n        // for each pile to do dp.\\n        for(List<Integer> pile:piles){\\n            //use prefix sum to record each pile\\'s first i elments;\\n            int m=pile.size();\\n            int[] cum=new int[m+1];\\n            for(int i=0;i<m;i++) cum[i+1]=cum[i]+pile.get(i);\\n            //use current pile to do dp, the dp is\\n            // we have two pile previous pile\\'s dp result and current pile--> reduce to two pile problem.\\n            // pile 0, 1 ,2 ,3 , 4, ...\\n            // pile (0,1),2,3,4...\\n            //      (0,1) is dp result for next calculation.\\n            // pile (0,1,2),3,4...\\n            // ...\\n            // pile (0,1,2,3,4... )\\n            int[] curdp=new int[k+1];\\n            for(int i=0;i<=k;i++){\\n                for(int j=0;j<=m&& i+j <=k;j++){\\n                    curdp[i+j]=Math.max(curdp[i+j],dp[i]+cum[j]);\\n                }\\n            }\\n            dp=curdp;\\n        }\\n        return dp[k];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n   int dp[1001][2001]; //Dp array For Memoization.\\n   int solve(vector<vector<int>>&v,int index,int coin)\\n   {\\n       if(index>=v.size()||coin==0)  //Base Condition\\n           return 0;\\n       if(dp[index][coin]!=-1) //Check wheather It is Already Calculated Or not.\\n           return dp[index][coin];\\n       \\n       \\n       /* Our 1st choice :- We not take any Coin from that pile*/\\n       int ans=solve(v,index+1,coin); //Just Call function for next Pile.\\n       \\n      \\n       /*Otherwise we can take Coins from that Pile.*/\\n       int loop=v[index].size()-1;\\n       int sum=0;\\n       \\n       for(int j=0;j<=min(coin-1,loop);j++) //\\n       {\\n           sum=sum+v[index][j];\\n           ans=max(ans,sum+solve(v,index+1,coin-(j+1)));\\n           \\n           /*Aove we Pass coin-(j+1). Because till j\\'th index we have taken j+1 coin from that pile.*/\\n       }\\n       \\n       return dp[index][coin]=ans;\\n   }\\n   int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n       memset(dp,-1,sizeof(dp));\\n       return solve(piles,0,k);\\n   }\\n};\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        best = np.zeros(k+1)\\n        for pile in piles:\\n            temp = best.copy()\\n            for used, value in enumerate(accumulate(pile), 1):\\n                if used > k: break\\n                temp2 = best+value\\n                temp2 = np.concatenate((np.zeros(used), temp2[:-used]))\\n                temp = np.maximum(temp, temp2)\\n            best = temp\\n        return int(best[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887372,
                "title": "c-2d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& P, int k) {\\n        int m = P.size();\\n        for(int i = 0 ; i< m ; i++){\\n            int n = P[i].size();\\n            for(int j = 1 ; j<n; ++j){\\n                P[i][j] += P[i][j-1];\\n            }\\n        }// sum of value if we take j elements from top of any pile of coins.\\n        vector<int> mxc(k+1,0);\\n        for(int j = min(k,(int)P[0].size()) ; j>0; --j){\\n            mxc[j] = P[0][j-1];\\n        }\\n        for(int i = 1 ; i< m ; i++){\\n            int n = P[i].size();\\n            for(int j=k; j>0 ; --j){//Final Sum\\n                for(int l=min(j,n); l>0; --l){\\n                    mxc[j] = max(mxc[j-l]+P[i][l-1],mxc[j]);\\n                }\\n                 \\n            }\\n        }\\n        return mxc[k];\\n        \\n    }\\n};\\n```\\n\\n0-1 Knapsack problem variant.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& P, int k) {\\n        int m = P.size();\\n        for(int i = 0 ; i< m ; i++){\\n            int n = P[i].size();\\n            for(int j = 1 ; j<n; ++j){\\n                P[i][j] += P[i][j-1];\\n            }\\n        }// sum of value if we take j elements from top of any pile of coins.\\n        vector<int> mxc(k+1,0);\\n        for(int j = min(k,(int)P[0].size()) ; j>0; --j){\\n            mxc[j] = P[0][j-1];\\n        }\\n        for(int i = 1 ; i< m ; i++){\\n            int n = P[i].size();\\n            for(int j=k; j>0 ; --j){//Final Sum\\n                for(int l=min(j,n); l>0; --l){\\n                    mxc[j] = max(mxc[j-l]+P[i][l-1],mxc[j]);\\n                }\\n                 \\n            }\\n        }\\n        return mxc[k];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886926,
                "title": "c-solution-simple-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[2005][2005];\\n    \\n    int K;\\n    long long MaxValue(vector<vector<int>>& piles, int taken,int pile)\\n    {\\n        if(taken==K) return 0;\\n        if(pile>=piles.size()||taken>K) return INT_MIN;\\n       \\n        if(dp[taken][pile]!=-1) return dp[taken][pile];\\n        \\n        long long ans=0;\\n\\t\\t// if we want to pick and try atleast one coin from this pile\\n\\t\\t\\n        for(int i=0;i<piles[pile].size();i++)\\n        {\\n            ans=max(ans,piles[pile][i]+MaxValue(piles,taken+i+1,pile+1));\\n        }\\n        \\n        ans=max(ans,MaxValue(piles,taken,pile+1)); // if we want to skip this pile altogether\\n        \\n        return dp[taken][pile]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t\\n\\t\\t// storing the prefix sum so as to know if we pick the ith coin out of a pile, what will be the total sum of all the coins above the ith coin \\n\\t\\t\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            for(int j=1;j<piles[i].size();j++) piles[i][j]+=piles[i][j-1];\\n        }\\n        \\n        K=k;\\n        return MaxValue(piles,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[2005][2005];\\n    \\n    int K;\\n    long long MaxValue(vector<vector<int>>& piles, int taken,int pile)\\n    {\\n        if(taken==K) return 0;\\n        if(pile>=piles.size()||taken>K) return INT_MIN;\\n       \\n        if(dp[taken][pile]!=-1) return dp[taken][pile];\\n        \\n        long long ans=0;\\n\\t\\t// if we want to pick and try atleast one coin from this pile\\n\\t\\t\\n        for(int i=0;i<piles[pile].size();i++)\\n        {\\n            ans=max(ans,piles[pile][i]+MaxValue(piles,taken+i+1,pile+1));\\n        }\\n        \\n        ans=max(ans,MaxValue(piles,taken,pile+1)); // if we want to skip this pile altogether\\n        \\n        return dp[taken][pile]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t\\n\\t\\t// storing the prefix sum so as to know if we pick the ith coin out of a pile, what will be the total sum of all the coins above the ith coin \\n\\t\\t\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            for(int j=1;j<piles[i].size();j++) piles[i][j]+=piles[i][j-1];\\n        }\\n        \\n        K=k;\\n        return MaxValue(piles,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543128,
                "title": "c-memoization-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& piles, int k, int ind, vector<vector<int>> & dp){\\n        if(ind<0)return 0;\\n        if(k==0)return 0;\\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        int a=helper(piles, k, ind-1, dp);\\n        \\n        int ans=a;\\n        for(int i=0; i<piles[ind].size(); i++){\\n            int b=0;\\n            if(i+1<=k){\\n                b=piles[ind][i]+helper(piles, k-i-1, ind-1, dp);\\n                ans=max(ans, b);\\n            }\\n        }\\n        return dp[ind][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        for(int i=0; i<piles.size(); i++){\\n            for(int j=1; j<piles[i].size(); j++){\\n                piles[i][j]+=piles[i][j-1];\\n            }\\n        }\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return helper(piles, k, n-1, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& piles, int k, int ind, vector<vector<int>> & dp){\\n        if(ind<0)return 0;\\n        if(k==0)return 0;\\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        int a=helper(piles, k, ind-1, dp);\\n        \\n        int ans=a;\\n        for(int i=0; i<piles[ind].size(); i++){\\n            int b=0;\\n            if(i+1<=k){\\n                b=piles[ind][i]+helper(piles, k-i-1, ind-1, dp);\\n                ans=max(ans, b);\\n            }\\n        }\\n        return dp[ind][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        for(int i=0; i<piles.size(); i++){\\n            for(int j=1; j<piles[i].size(); j++){\\n                piles[i][j]+=piles[i][j-1];\\n            }\\n        }\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return helper(piles, k, n-1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421114,
                "title": "python-short-and-clean-recursive-dp-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(m * k)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere,\\n`m is number of total coins from all piles`\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles: list[list[int]], k_: int) -> int:\\n        prefix_piles = [list(accumulate(p, initial=0)) for p in piles]\\n\\n        @cache\\n        def max_value(n: int, k: int) -> int:\\n            return max(\\n                max_value(n - 1, k - i) + x\\n                for i, x in enumerate(islice(prefix_piles[n - 1], k + 1))\\n            ) if n and k else 0\\n        \\n        return max_value(len(piles), k_)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles: list[list[int]], k_: int) -> int:\\n        prefix_piles = [list(accumulate(p, initial=0)) for p in piles]\\n\\n        @cache\\n        def max_value(n: int, k: int) -> int:\\n            return max(\\n                max_value(n - 1, k - i) + x\\n                for i, x in enumerate(islice(prefix_piles[n - 1], k + 1))\\n            ) if n and k else 0\\n        \\n        return max_value(len(piles), k_)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421056,
                "title": "prefix-sum-2d-dp",
                "content": "# Intuition\\nUse DP and prefix sum\\n\\n# Approach\\nFirst for each pile, build a prefix sum (aka cummulative sum) up to k elements (we can just trim/ignore if there is more).\\n\\nThen focus on the first pile.\\nWe can take first coin, or two, or ... k and then deal with smaller problem (one less pile and same or less coins to consider).\\n\\nSo the base cases are:\\n- we have considered all piles\\n- we have no more coins to take\\n\\nIn the meoized helper DP function, we take two parameters:\\n`start_pile` - index of the pile we focus on (and later deal only with piles with bigger index)\\n`hp` - the helper version of k, that is remaining coins we need to consider\\n\\nOn the helper function we looking for the maximum,\\nconsidering taking from the start_pile 0 up to hk coins and remaining coins from the next piles recursively.\\n\\nHaving such helper function, the answer will be found by `helper(start_pile=0, hk=k)`\\n\\nIf you find it helpful please up-vote. Thank you!\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\times k)$$ I think...\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n\\\\times k)$$ I think...\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n\\n        # Turn each pile to cummulative sum trimmed to k elements\\n        for pi in range(n):\\n            piles[pi] = list(accumulate(piles[pi][:k]))\\n        \\n        @cache\\n        def helper(start_pile: int, hk: int):\\n            if start_pile >= n or hk == 0:\\n                return 0\\n            # Consider we don\\'t take anything from start_pile\\n            ans = helper(start_pile + 1, hk)\\n            for i, v in enumerate(piles[start_pile], start=1):\\n                # Consider we take first i coins from start_pile\\n                ans = max(ans, v + helper(start_pile + 1, hk - i))\\n                if i == hk:\\n                    break\\n            return ans\\n        \\n        return helper(0, k)```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n\\n        # Turn each pile to cummulative sum trimmed to k elements\\n        for pi in range(n):\\n            piles[pi] = list(accumulate(piles[pi][:k]))\\n        \\n        @cache\\n        def helper(start_pile: int, hk: int):\\n            if start_pile >= n or hk == 0:\\n                return 0\\n            # Consider we don\\'t take anything from start_pile\\n            ans = helper(start_pile + 1, hk)\\n            for i, v in enumerate(piles[start_pile], start=1):\\n                # Consider we take first i coins from start_pile\\n                ans = max(ans, v + helper(start_pile + 1, hk - i))\\n                if i == hk:\\n                    break\\n            return ans\\n        \\n        return helper(0, k)```",
                "codeTag": "Java"
            },
            {
                "id": 3419911,
                "title": "c-recursion-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][2001];\\n    int fun(int i, int k, vector<vector<int>> &v, int n, vector<vector<int>> &pre){\\n        if(i>=n || k==0) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int maxi=-1;\\n        for(int p=0;p<=min(k,(int)v[i].size());p++){\\n            int ans=0;\\n            if(p==0){\\n                if(dp[i+1][k]!=-1)\\n                ans+=dp[i+1][k];\\n                else\\n                ans+=fun(i+1,k,v,n,pre);\\n            }\\n            else{\\n                ans+=pre[i][min({p,k,(int)v[i].size()})-1];\\n                if(dp[i+1][k-min({p,k,(int)v[i].size()})]!=-1)\\n                ans+=dp[i+1][k-min({p,k,(int)v[i].size()})];\\n                else\\n                ans+=fun(i+1,k-min({p,k,(int)v[i].size()}),v,n,pre);\\n            }\\n            maxi=max(maxi,ans);\\n        }\\n        return dp[i][k]=maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<int>> pre;\\n        for(int i=0;i<piles.size();i++){\\n            int sum=0;\\n            vector<int> p;\\n            for(int j=0;j<piles[i].size();j++){\\n                sum+=piles[i][j];\\n                p.push_back(sum);\\n            }\\n            pre.push_back(p);\\n        }\\n        \\n        return fun(0,k,piles,piles.size(),pre);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2001];\\n    int fun(int i, int k, vector<vector<int>> &v, int n, vector<vector<int>> &pre){\\n        if(i>=n || k==0) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int maxi=-1;\\n        for(int p=0;p<=min(k,(int)v[i].size());p++){\\n            int ans=0;\\n            if(p==0){\\n                if(dp[i+1][k]!=-1)\\n                ans+=dp[i+1][k];\\n                else\\n                ans+=fun(i+1,k,v,n,pre);\\n            }\\n            else{\\n                ans+=pre[i][min({p,k,(int)v[i].size()})-1];\\n                if(dp[i+1][k-min({p,k,(int)v[i].size()})]!=-1)\\n                ans+=dp[i+1][k-min({p,k,(int)v[i].size()})];\\n                else\\n                ans+=fun(i+1,k-min({p,k,(int)v[i].size()}),v,n,pre);\\n            }\\n            maxi=max(maxi,ans);\\n        }\\n        return dp[i][k]=maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<int>> pre;\\n        for(int i=0;i<piles.size();i++){\\n            int sum=0;\\n            vector<int> p;\\n            for(int j=0;j<piles[i].size();j++){\\n                sum+=piles[i][j];\\n                p.push_back(sum);\\n            }\\n            pre.push_back(p);\\n        }\\n        \\n        return fun(0,k,piles,piles.size(),pre);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419681,
                "title": "c-recursion-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int> (k + 1, -1));\\n        return helper(piles, 0, k, dp);\\n    }\\n\\n    int helper(vector<vector<int>> &piles, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i >= piles.size() || k == 0)\\n            return 0;\\n\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n\\n        int mx = helper(piles, i + 1, k, dp), sum = 0;\\n        for(int j = 0; j < piles[i].size() && j < k; j++)\\n            mx = max(mx, (sum += piles[i][j]) + helper(piles, i + 1, k - j - 1, dp));\\n\\n        return dp[i][k] = mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int> (k + 1, -1));\\n        return helper(piles, 0, k, dp);\\n    }\\n\\n    int helper(vector<vector<int>> &piles, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i >= piles.size() || k == 0)\\n            return 0;\\n\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n\\n        int mx = helper(piles, i + 1, k, dp), sum = 0;\\n        for(int j = 0; j < piles[i].size() && j < k; j++)\\n            mx = max(mx, (sum += piles[i][j]) + helper(piles, i + 1, k - j - 1, dp));\\n\\n        return dp[i][k] = mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419393,
                "title": "ruby-prefix-sum-and-recursion",
                "content": "# Code\\n```ruby\\nclass Array\\n  def scan(st) = map { st = yield st, _1 }\\n  def prefsum = scan(0, &:+).unshift(0)\\nend\\n\\ndef max_value_of_coins(piles, k)\\n  @pile_prefs = piles.map(&:prefsum)\\n  @size_prefs = piles.map(&:size).prefsum\\n  @_dp = Array.new(piles.size) { [] } << -> _ { 0 }\\n  dp(0, k)\\nend\\n\\ndef dp(i, k)\\n  @_dp[i][k] ||= begin\\n    pref = @pile_prefs[i]\\n    rem = @size_prefs[-1] - @size_prefs[i + 1]\\n    (max(0, k - rem)..min(k, pref.size - 1)).map { pref[_1] + dp(i + 1, k - _1) }.max\\n  end\\nend\\n\\ndef min(a, b) = a < b ? a : b\\ndef max(a, b) = a > b ? a : b\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(\\\\sum|\\\\text{piles}_i|)$$\\n\\n# Space complexity\\n\\n$$\\\\mathcal{O}(\\\\sum|\\\\text{piles}_i|)$$",
                "solutionTags": [
                    "Ruby",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```ruby\\nclass Array\\n  def scan(st) = map { st = yield st, _1 }\\n  def prefsum = scan(0, &:+).unshift(0)\\nend\\n\\ndef max_value_of_coins(piles, k)\\n  @pile_prefs = piles.map(&:prefsum)\\n  @size_prefs = piles.map(&:size).prefsum\\n  @_dp = Array.new(piles.size) { [] } << -> _ { 0 }\\n  dp(0, k)\\nend\\n\\ndef dp(i, k)\\n  @_dp[i][k] ||= begin\\n    pref = @pile_prefs[i]\\n    rem = @size_prefs[-1] - @size_prefs[i + 1]\\n    (max(0, k - rem)..min(k, pref.size - 1)).map { pref[_1] + dp(i + 1, k - _1) }.max\\n  end\\nend\\n\\ndef min(a, b) = a < b ? a : b\\ndef max(a, b) = a > b ? a : b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419223,
                "title": "easy-java-solution-dynamic-programming",
                "content": "![upvote.png](https://assets.leetcode.com/users/images/944f8a25-3a7e-4b2c-80ef-3eea96f03fd4_1681555329.6333501.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[][];\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        dp = new int[n+1][k+1];\\n        for(int i = 1; i <= n; i++){\\n            for(int coins = 0; coins <= k; coins++){\\n                dp[i][coins] = -1;\\n            }\\n        }\\n        return helper(piles,n,k);\\n    }\\n\\n    private int helper(List<List<Integer>> piles, int i, int coins){\\n        if(i==0)return 0;\\n\\n        if(dp[i][coins] != -1)return dp[i][coins];\\n\\n        int currSum = 0;\\n        for(int currCoins = 0; currCoins <= Math.min(piles.get(i-1).size(), coins); currCoins++){\\n            if(currCoins > 0){\\n                currSum += piles.get(i-1).get(currCoins-1);\\n            }\\n            dp[i][coins] = Math.max(dp[i][coins], helper(piles, i-1, coins-currCoins)+currSum);\\n        }\\n        return dp[i][coins];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        dp = new int[n+1][k+1];\\n        for(int i = 1; i <= n; i++){\\n            for(int coins = 0; coins <= k; coins++){\\n                dp[i][coins] = -1;\\n            }\\n        }\\n        return helper(piles,n,k);\\n    }\\n\\n    private int helper(List<List<Integer>> piles, int i, int coins){\\n        if(i==0)return 0;\\n\\n        if(dp[i][coins] != -1)return dp[i][coins];\\n\\n        int currSum = 0;\\n        for(int currCoins = 0; currCoins <= Math.min(piles.get(i-1).size(), coins); currCoins++){\\n            if(currCoins > 0){\\n                currSum += piles.get(i-1).get(currCoins-1);\\n            }\\n            dp[i][coins] = Math.max(dp[i][coins], helper(piles, i-1, coins-currCoins)+currSum);\\n        }\\n        return dp[i][coins];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419107,
                "title": "simple-solution-using-recursion-and-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  int sumi(int index, vector<vector<int>> &piles, int k, int n, vector<vector<int>> &dp)\\n  {\\n    if (index == n or k == 0)\\n      return 0;\\n    if (dp[index][k] != -1)\\n      return dp[index][k];\\n    int notPick = sumi(index + 1, piles, k, n, dp);\\n    int pick = 0, coins = k, sum = 0;\\n    for (int i = 0; i < piles[index].size() and coins > 0; i++)\\n    {\\n      sum += piles[index][i];\\n      coins--;\\n      int x = sum + sumi(index + 1, piles, coins, n, dp);\\n      pick = max(pick, x);\\n    }\\n    return dp[index][k] = max(pick, notPick);\\n  }\\n  int maxValueOfCoins(vector<vector<int>> &piles, int k)\\n  {\\n    int n = piles.size();\\n    int index = 0;\\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n    return sumi(index, piles, k, n, dp);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int sumi(int index, vector<vector<int>> &piles, int k, int n, vector<vector<int>> &dp)\\n  {\\n    if (index == n or k == 0)\\n      return 0;\\n    if (dp[index][k] != -1)\\n      return dp[index][k];\\n    int notPick = sumi(index + 1, piles, k, n, dp);\\n    int pick = 0, coins = k, sum = 0;\\n    for (int i = 0; i < piles[index].size() and coins > 0; i++)\\n    {\\n      sum += piles[index][i];\\n      coins--;\\n      int x = sum + sumi(index + 1, piles, coins, n, dp);\\n      pick = max(pick, x);\\n    }\\n    return dp[index][k] = max(pick, notPick);\\n  }\\n  int maxValueOfCoins(vector<vector<int>> &piles, int k)\\n  {\\n    int n = piles.size();\\n    int index = 0;\\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n    return sumi(index, piles, k, n, dp);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419062,
                "title": "bottom-up-dp-explained",
                "content": "We define `dp[i][j]` as the the answer considering 1st `i` piles for at most `j` coins. Hence final answer is `dp[n][k]`. In base case we consider `i=0` ie considering zero piles. This row will be just zeroes. Similarly for `j=0` column also, it will be all zeroes. \\n\\nConsider any general `dp[i][j]`. \\n\\nWe can take 0 coins from `i`th pile and all the `j` coins from the first `i-1` piles. The value for this situation is `dp[i-1][j] + 0`.\\n\\nWe can also take 3 coins from `ith pile` (assume valid) and `j-3` coins from the first `i-1` piles. The value for this situation is `dp[i-1][j-3] + piles[i-1][0]+piles[i-1][1]+piles[i-1][2]`. \\n\\nSimilarly we can have other possiblities as well. `dp[i][j]` is the maximum of all these possibilities.\\n\\nWe define `cur` as the number of coins we take from the current pile and `curSum` as the sum of values of these `cur` coins.\\n\\n\\n```\\nint maxValueOfCoins(vector<vector<int>>& piles, int k) \\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n+1, vector<int>(k+1, 0));\\n    for (int i=1; i<=n; i++)\\n    {\\n        for (int j=0; j<=k; j++)\\n        {\\n            dp[i][j] = dp[i-1][j]; // cur=0\\n            int curSum = 0;\\n            for (int cur=1; cur<=min((int)piles[i-1].size(),j); cur++)\\n            {\\n                curSum += piles[i-1][cur-1];\\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cur]+curSum);\\n            }\\n        }\\n    }\\n    return dp[n][k];\\n}\\n```\\n\\n$$TC= O(n\\\\sum_{i=1}^n {P_i})$$ where $P_i$ is the size of ith pile.\\n$$SC: O(nk)$$",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxValueOfCoins(vector<vector<int>>& piles, int k) \\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n+1, vector<int>(k+1, 0));\\n    for (int i=1; i<=n; i++)\\n    {\\n        for (int j=0; j<=k; j++)\\n        {\\n            dp[i][j] = dp[i-1][j]; // cur=0\\n            int curSum = 0;\\n            for (int cur=1; cur<=min((int)piles[i-1].size(),j); cur++)\\n            {\\n                curSum += piles[i-1][cur-1];\\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cur]+curSum);\\n            }\\n        }\\n    }\\n    return dp[n][k];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419035,
                "title": "c-easiest-solution-memoization-top-down-dp-recursive",
                "content": "**APPROACH**\\n**I have two option**\\n**Option 1: I will not anything from the current ith pile**\\n**Option 2: I wiil take some coins the from current ith pile and rest from other piles**\\n```\\nclass Solution\\n{\\n    public:\\n        int dp[1001][2001];\\n    int solver(vector<vector < int>> &arr, int coins, int idx=0)\\n    {\\n\\n       \\t// I have no coin and no piles\\n        if (idx >= arr.size() || coins == 0) return 0;\\n\\n        if (dp[idx][coins] != -1) return dp[idx][coins];\\n\\n        int ans = INT_MIN;\\n\\n       \\t//Option1: I will not take anything from this pile\\n        ans = solver(arr, coins, idx + 1);\\n\\n       \\t//options2: I will try to take some coins from here and other coins from some other pile ..so that I can have maximum amount\\n\\n\\t\\t//current pile size\\n        int sz = arr[idx].size();\\n        int sum = 0;\\n\\t\\t\\n\\t //[Need to iterate till min(coins,sz)because we can take only k coins  at max ]\\n        for (int i = 0; i < min(coins, sz); i++)\\n        {\\n            sum = sum + arr[idx][i];\\n\\n           \\t//trying to take some coins from others also including mine\\n            ans = max(ans, sum + solver(arr, coins - (i + 1), idx + 1));\\n        }\\n\\n        return dp[idx][coins] = ans;\\n    }\\n    int maxValueOfCoins(vector<vector < int>> &piles, int k)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return solver(piles, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int dp[1001][2001];\\n    int solver(vector<vector < int>> &arr, int coins, int idx=0)\\n    {\\n\\n       \\t// I have no coin and no piles\\n        if (idx >= arr.size() || coins == 0) return 0;\\n\\n        if (dp[idx][coins] != -1) return dp[idx][coins];\\n\\n        int ans = INT_MIN;\\n\\n       \\t//Option1: I will not take anything from this pile\\n        ans = solver(arr, coins, idx + 1);\\n\\n       \\t//options2: I will try to take some coins from here and other coins from some other pile ..so that I can have maximum amount\\n\\n\\t\\t//current pile size\\n        int sz = arr[idx].size();\\n        int sum = 0;\\n\\t\\t\\n\\t //[Need to iterate till min(coins,sz)because we can take only k coins  at max ]\\n        for (int i = 0; i < min(coins, sz); i++)\\n        {\\n            sum = sum + arr[idx][i];\\n\\n           \\t//trying to take some coins from others also including mine\\n            ans = max(ans, sum + solver(arr, coins - (i + 1), idx + 1));\\n        }\\n\\n        return dp[idx][coins] = ans;\\n    }\\n    int maxValueOfCoins(vector<vector < int>> &piles, int k)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return solver(piles, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418491,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int func(vector<vector<int>>& p,int i,int k)\\n    {\\n        if(i==p.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=func(p,i+1,k);\\n        int a=0;\\n        for(int j=0;j<p[i].size()&&j<k;j++)\\n        {\\n            a+=p[i][j];\\n            ans=max(ans,a+func(p,i+1,k-j-1));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) \\n    {\\n        dp=vector<vector<int>>(p.size(),vector<int>(k+1,-1));\\n        return func(p,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int func(vector<vector<int>>& p,int i,int k)\\n    {\\n        if(i==p.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=func(p,i+1,k);\\n        int a=0;\\n        for(int j=0;j<p[i].size()&&j<k;j++)\\n        {\\n            a+=p[i][j];\\n            ans=max(ans,a+func(p,i+1,k-j-1));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) \\n    {\\n        dp=vector<vector<int>>(p.size(),vector<int>(k+1,-1));\\n        return func(p,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418108,
                "title": "python-easy-solution-with-explanation-recursion-with-caching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndynamic programming problem \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we first skip all nodes to start from last assume i have 4 piles (try last piles , then try 3rd and last pile , etc)\\n- with base case if i ==n or k ==0 return 0\\n- in for loop i try all possible coins in cur pile to last pile in limit with k\\n- cur_val save the value of cur try , ans res save max res of all tries \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        \"\"\"\\n        :type piles: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        cache ={}\\n        def dfs(i,k ):\\n            if (i,k) in cache:\\n                return cache[(i,k)]\\n            if k==0 or i == len(piles):\\n                return 0\\n            # skip piles until reach end , then try all possible from last to first \\n            dfs(i+1 , k) \\n            res , cur_val = dfs(i+1 , k),0\\n            for j in range(min(k , len(piles[i]))):\\n                cur_val += piles[i][j]\\n                # print(cur_val ,res )\\n                res = max(res , cur_val + dfs(i+1 , k-j-1))\\n            cache[(i,k)]=res\\n            return cache[(i,k)]\\n        return dfs(0,k)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        \"\"\"\\n        :type piles: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        cache ={}\\n        def dfs(i,k ):\\n            if (i,k) in cache:\\n                return cache[(i,k)]\\n            if k==0 or i == len(piles):\\n                return 0\\n            # skip piles until reach end , then try all possible from last to first \\n            dfs(i+1 , k) \\n            res , cur_val = dfs(i+1 , k),0\\n            for j in range(min(k , len(piles[i]))):\\n                cur_val += piles[i][j]\\n                # print(cur_val ,res )\\n                res = max(res , cur_val + dfs(i+1 , k-j-1))\\n            cache[(i,k)]=res\\n            return cache[(i,k)]\\n        return dfs(0,k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637855,
                "title": "dp-isn-t-scary-dude",
                "content": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n     /*\\n     -> Pick the first coin from the pile and move to next.\\n     -> Don\\'t pick the first coin from pile and move to next.\\n     -> Pick first coin and stay on the same pile to pick the next coin.\\n     */   \\n        int[][] dp = new int[piles.size()][k + 1];\\n        for(var i:dp) Arrays.fill(i,-1);\\n        return move(piles,k,0,dp);\\n    }\\n    private int move(List<List<Integer>> piles, int k, int pileInd,int[][] dp) {\\n        if(k == 0) return 0;\\n        if(pileInd == piles.size())\\n            return 0;\\n        if(dp[pileInd][k] != -1) return dp[pileInd][k];\\n        int dontPick = move(piles,k,pileInd + 1,dp);\\n        int s = 0;\\n        for(int i = 0; i < k && i < piles.get(pileInd).size(); i++) {\\n            s += piles.get(pileInd).get(i);\\n            dontPick = Math.max(dontPick,s + move(piles,k - (i + 1), pileInd + 1,dp));\\n        }\\n        // int dontPick = move(piles,k,pileInd + 1,sum,dp);\\n        return dp[pileInd][k] = dontPick;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n     /*\\n     -> Pick the first coin from the pile and move to next.\\n     -> Don\\'t pick the first coin from pile and move to next.\\n     -> Pick first coin and stay on the same pile to pick the next coin.\\n     */   \\n        int[][] dp = new int[piles.size()][k + 1];\\n        for(var i:dp) Arrays.fill(i,-1);\\n        return move(piles,k,0,dp);\\n    }\\n    private int move(List<List<Integer>> piles, int k, int pileInd,int[][] dp) {\\n        if(k == 0) return 0;\\n        if(pileInd == piles.size())\\n            return 0;\\n        if(dp[pileInd][k] != -1) return dp[pileInd][k];\\n        int dontPick = move(piles,k,pileInd + 1,dp);\\n        int s = 0;\\n        for(int i = 0; i < k && i < piles.get(pileInd).size(); i++) {\\n            s += piles.get(pileInd).get(i);\\n            dontPick = Math.max(dontPick,s + move(piles,k - (i + 1), pileInd + 1,dp));\\n        }\\n        // int dontPick = move(piles,k,pileInd + 1,sum,dp);\\n        return dp[pileInd][k] = dontPick;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522444,
                "title": "c-solution-dp-o-m-k-time-o-k-space",
                "content": "`Time Complexity` : `O(m * k)`\\n`Space Complexity` : `O(k)`\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<int> dp(k + 1, 0);\\n        for(auto& pile: piles) {\\n            for(size_t i = k; i >= 1; i--) {\\n                int csum = 0;\\n                for(int j = 0; j < min(i, pile.size()); j++) {\\n                    csum += pile[j];\\n                    dp[i] = max(dp[i], dp[i - j - 1] + csum);\\n                }\\n            }\\n        }\\n        return dp[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<int> dp(k + 1, 0);\\n        for(auto& pile: piles) {\\n            for(size_t i = k; i >= 1; i--) {\\n                int csum = 0;\\n                for(int j = 0; j < min(i, pile.size()); j++) {\\n                    csum += pile[j];\\n                    dp[i] = max(dp[i], dp[i - j - 1] + csum);\\n                }\\n            }\\n        }\\n        return dp[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446235,
                "title": "recursive-3d-dp-with-2d-1d-mapping-reduction-using-hashing",
                "content": "I kept 3 variables for a state ,\\nIndex_of_pile --> which pile am i currently standing at  --> [i]\\nindex_in_current_pile  --> which index is at the top at the moment for piles[index], -->  [j]\\nNo_of_purchaces_remaining  ---> how many transactions do I have left with me ---> [k]\\n\\nDp[i][j][k] = returns me the maximum money i can retreive from here \\nat this state i have 2 choices \\ntake the jth coin (topmost coin) on pile i  and stay on the same pile\\ndont take the jth coin and move the next pile\\n\\ntake : piles[i][j] + func(i , j + 1 , k - 1)\\ndont take : func(i + 1 , 0 , k - 1 ) --> 0 because now 0 is the topmost coin of the new pile\\n\\nTime Complexity : O(piles.size()*K + calculationforhas = Piles.size())\\n\\n```class Solution {\\n   \\n    \\n   \\n    \\n    int dp[3003][2001];\\n\\t\\n\\t /*\\n    state which i can think of is that \\n    given (index_of_pile , index_in_pile , no_of_transactions_left) \\n    what is the maximum money i can generate \\n    index_in_pile---> the index of the coin to be pick from pile(index_of_pile)\\n    */\\n     \\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        vector<vector<int>> has;\\n        int cnt = -1;\\n        \\n        for(int i = 0 ; i < piles.size() ; i ++ ) {\\n            vector<int> row;\\n            for(int j = 0 ; j < piles[i].size() ; j ++) {\\n                row.push_back(-1);\\n            }\\n            row.push_back(-1);\\n            has.push_back(row);\\n        }\\n        \\n       \\n        for(int i = 0 ; i < has.size() ; i ++ ) {\\n            for(int j = 0 ; j < has[i].size() ; j ++ ) {\\n                has[i][j] = ++cnt;\\n                // this has function is \\n                // converting the row and the col of the  cell \\n                // into a single value\\n                // has{i , j} ---> cnt\\n            }\\n        } \\n        \\n    \\n        return func(piles , k , 0 , 0 , has);\\n      \\n    }\\n    \\n   \\n    \\n    int func(vector<vector<int>>& piles, int no_of_transactions , int index , int pileposition , \\n         vector<vector<int>>& has  ) {\\n        if(index >= piles.size() or no_of_transactions <= 0 ) \\n            return 0;\\n        \\n        // if(pileposition >= piles[index].size()) {\\n        //     return 0;\\n        // }\\n        int i = index;\\n        int j = pileposition;\\n        int k = no_of_transactions;\\n        \\n        if(dp[has[i][j]][k] != -1)\\n        return dp[has[i][j]][k];    \\n    \\n        \\n        int take = 0;\\n        int dont_take = 0;\\n        // two choices , i decide to take the index\\n        if(pileposition < piles[index].size()) {\\n            take = +piles[index][pileposition] + func(piles , no_of_transactions - 1 , index , pileposition + 1 , has);\\n        }\\n        \\n        // I stop taking values from pile number index and start taking from the next pile , hence the pile no index will never be \\n        // considered in the future if i make this move\\n        // pile position will now become 0 , because am again going to take coins from the top of the new pile \\n        // we increment the index of the pile to index + 1\\n        dont_take = func(piles , no_of_transactions  , index + 1 , 0 , has);\\n        \\n        // if(pileposition >= piles[index].size()) {\\n        //     // i did this just to make the 3rd dp state call pass , \\n        //     // since we dont have entry for pileposition >= piles[index].size\\n        //     // in the has table so we have to query this way \\n        //     // but am proud of the state table that i came up with myself \\n        //     return dont_take;\\n        // }\\n        return dp[has[i][j]][k] = max(take , dont_take);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n    \\n   \\n    \\n    int dp[3003][2001];\\n\\t\\n\\t /*\\n    state which i can think of is that \\n    given (index_of_pile , index_in_pile , no_of_transactions_left) \\n    what is the maximum money i can generate \\n    index_in_pile---> the index of the coin to be pick from pile(index_of_pile)\\n    */\\n     \\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        vector<vector<int>> has;\\n        int cnt = -1;\\n        \\n        for(int i = 0 ; i < piles.size() ; i ++ ) {\\n            vector<int> row;\\n            for(int j = 0 ; j < piles[i].size() ; j ++) {\\n                row.push_back(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2223585,
                "title": "c-top-down-dp-solution-with-explaination",
                "content": "**Intuition**\\nTop down dynamic programming.\\n\\n\\n**Explanation**\\ndp[i,k] means picking k elements from pile[i] to pile[n-1].\\nWe can pick 0,1,2,3... elements from the current pile[i] one by one.\\nIt asks for the maximum total value of coins we can have,\\nso we need to return max of all the options.\\n\\n\\n**Complexity**\\nTime `O(nm)`\\nSpace `O(nk)`\\nwhere `m = sum(piles[i].length) <= 2000`\\n\\n***C++ CODE :***\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int n=piles.size();\\n        vector<vector<int>> memo(n+1, vector<int>(k+1,0));\\n        \\n        function <int (int,int)> dp = [&](int i,int k){\\n            if(i==n || k==0)\\n                return 0;\\n            if(memo[i][k]) \\n                return memo[i][k];\\n            \\n            int res=dp(i+1,k), curr=0;\\n            \\n            for(int j=0;j<piles[i].size() and j<k ;++j){\\n                curr += piles[i][j];\\n                res=max(res,dp(i+1,k-j-1)+curr);\\n            }\\n            return memo[i][k]=res;\\n        };\\n        return dp(0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int n=piles.size();\\n        vector<vector<int>> memo(n+1, vector<int>(k+1,0));\\n        \\n        function <int (int,int)> dp = [&](int i,int k){\\n            if(i==n || k==0)\\n                return 0;\\n            if(memo[i][k]) \\n                return memo[i][k];\\n            \\n            int res=dp(i+1,k), curr=0;\\n            \\n            for(int j=0;j<piles[i].size() and j<k ;++j){\\n                curr += piles[i][j];\\n                res=max(res,dp(i+1,k-j-1)+curr);\\n            }\\n            return memo[i][k]=res;\\n        };\\n        return dp(0,k);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1901776,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n\\nRecursively include each `j`<sup>th</sup> value of each `i`<sup>th</sup> row of the input matrix `A` onto a running total `t` to consider each candidate `cand` in order to find the `best` candidate for each `i`<sup>th</sup> row.  Then we have 2 choices for each each `i`<sup>th</sup> row\\'s `best` candidate:\\n\\n1. \\u2705 include\\n2. \\uD83D\\uDEAB exclude\\n\\nOptimally choose the maximum at each `i`<sup>th</sup> sub-problem to formulate the overall optimal solution as the recursive stack unwinds.\\n\\n**Note:** the problem statement\\'s image is misleading, ie. \"buckets\" are drawn as columns, however, the \"buckets\" are actually stored in the input matrix `A` as rows.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (i == M || k == 0)\\n                return 0\\n            var (t, best) = Pair(0, 0)\\n            for (j in 0 until Math.min(A[i].size, k)) {\\n                t += A[i][j]\\n                var cand = t + go(i + 1, k - 1 - j)\\n                best = Math.max(best, cand)\\n            }\\n            return Math.max(best, go(i + 1, k)) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (i == M || k == 0)\\n                return 0\\n            var key = \"$i,$k\"\\n            if (!m.contains(key)) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + go(i + 1, k - 1 - j)\\n                    best = Math.max(best, cand)\\n                }\\n                m[key] = Math.max(best, go(i + 1, k)) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var dp = Array(M + 1) { IntArray(K + 1 ) { 0 } }\\n        for (i in M - 1 downTo 0) {\\n            for (k in 1..K) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + dp[i + 1][k - 1 - j]\\n                    best = Math.max(best, cand)\\n                }\\n                dp[i][k] = Math.max(best, dp[i + 1][k]) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K]\\n    }\\n}\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var pre = IntArray(K + 1) { 0 }\\n        for (i in M - 1 downTo 0) {\\n            var cur = IntArray(K + 1) { 0 }\\n            for (k in 1..K) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + pre[k - 1 - j]\\n                    best = Math.max(best, cand)\\n                }\\n                cur[k] = Math.max(best, pre[k]) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur\\n        }\\n        return pre[K]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let go = (i = 0, k = K) => {\\n        if (i == M || !k)\\n            return 0;\\n        let [t, best] = [0, 0];\\n        for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n            t += A[i][j];\\n            let cand = t + go(i + 1, k - 1 - j);\\n            best = Math.max(best, cand);\\n        }\\n        return Math.max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet maxValueOfCoins = (A, K, m = new Map()) => {\\n    let M = A.length;\\n    let go = (i = 0, k = K) => {\\n        if (i == M || !k)\\n            return 0;\\n        let key = `${i},${k}`;\\n        if (!m.has(key)) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + go(i + 1, k - 1 - j);\\n                best = Math.max(best, cand);\\n            }\\n            m.set(key, Math.max(best, go(i + 1, k))); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let dp = [...Array(M + 1)].map(_ => Array(K + 1).fill(0));\\n    for (let i = M - 1; 0 <= i; --i) {\\n        for (let k = 1; k <= K; ++k) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + dp[i + 1][k - 1 - j];\\n                best = Math.max(best, cand);\\n            }\\n            dp[i][k] = Math.max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n    }\\n    return dp[0][K];\\n};\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let pre = Array(K + 1).fill(0);\\n    for (let i = M - 1; 0 <= i; --i) {\\n        let cur = Array(K + 1).fill(0);\\n        for (let k = 1; k <= K; ++k) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + pre[k - 1 - j];\\n                best = Math.max(best, cand);\\n            }\\n            cur[k] = Math.max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        pre = cur;\\n    }\\n    return pre[K];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        def go(i = 0, k = K):\\n            if i == M or not k:\\n                return 0\\n            t, best = 0, 0\\n            for j in range(0, min(len(A[i]), k)):\\n                t += A[i][j]\\n                cand = t + go(i + 1, k - 1 - j)\\n                best = max(best, cand)\\n            return max(best, go(i + 1, k)) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        @cache\\n        def go(i = 0, k = K):\\n            if i == M or not k:\\n                return 0\\n            t, best = 0, 0\\n            for j in range(0, min(len(A[i]), k)):\\n                t += A[i][j]\\n                cand = t + go(i + 1, k - 1 - j)\\n                best = max(best, cand)\\n            return max(best, go(i + 1, k)) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        dp = [[0] * (K + 1) for _ in range(M + 1)]\\n        for i in range(M - 1, -1, -1):\\n            for k in range(K, -1, -1):\\n                t, best = 0, 0\\n                for j in range(0, min(len(A[i]), k)):\\n                    t += A[i][j]\\n                    cand = t + dp[i + 1][k - 1 - j]\\n                    best = max(best, cand)\\n                dp[i][k] = max(best, dp[i + 1][k]) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return dp[0][K]\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        pre = [0] * (K + 1)\\n        for i in range(M - 1, -1, -1):\\n            cur = [0] * (K + 1)\\n            for k in range(K, -1, -1):\\n                t, best = 0, 0\\n                for j in range(0, min(len(A[i]), k)):\\n                    t += A[i][j]\\n                    cand = t + pre[k - 1 - j]\\n                    best = max(best, cand)\\n                cur[k] = max(best, pre[k]) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            pre = cur\\n        return pre[K]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\n// TODO: how to write recursive closure in Rust which captures the parent\\'s scope?\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\n// TODO: how to write recursive closure in Rust which captures the parent\\'s scope?\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_value_of_coins(A: VVI, K_: i32) -> i32 {\\n        let M = A.len();\\n        let K = K_ as usize;\\n        let mut dp = vec![vec![0; K + 1]; M + 1];\\n        for i in (0..M).rev() {\\n            for k in 1..=K {\\n                let (mut t, mut best) = (0, 0);\\n                for j in 0..min(A[i].len(), k) {\\n                    t += A[i][j];\\n                    let cand = t + dp[i + 1][k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                dp[i][k] = max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n}\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_value_of_coins(A: VVI, K_: i32) -> i32 {\\n        let M = A.len();\\n        let K = K_ as usize;\\n        let mut pre = vec![0; K + 1];\\n        for i in (0..M).rev() {\\n            let mut cur = vec![0; K + 1];\\n            for k in 1..=K {\\n                let (mut t, mut best) = (0, 0);\\n                for j in 0..min(A[i].len(), k) {\\n                    t += A[i][j];\\n                    let cand = t + pre[k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                cur[k] = max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur;\\n        }\\n        return pre[K];\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        fun go = [&](auto i, auto k) {\\n            if (i == M || !k)\\n                return 0;\\n            auto [t, best] = make_pair(0, 0);\\n            for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                t += A[i][j];\\n                auto cand = t + go(i + 1, k - 1 - j);\\n                best = max(best, cand);\\n            }\\n            return max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maxValueOfCoins(VVI& A, int K, Map m = {}) {\\n        int M = A.size();\\n        auto hash = [](auto i, auto k) {\\n            stringstream ss; ss << i << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto k) {\\n            if (i == M || !k)\\n                return 0;\\n            auto key = hash(i, k);\\n            if (m.find(key) == m.end()) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + go(i + 1, k - 1 - j);\\n                    best = max(best, cand);\\n                }\\n                m[key] = max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            return m[key];\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        VVI dp(M + 1, VI(K + 1));\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            for (auto k{ 1 }; k <= K; ++k) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + dp[i + 1][k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                dp[i][k] = max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n};\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        VI pre(K + 1);\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            VI cur(K + 1);\\n            for (auto k{ 1 }; k <= K; ++k) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + pre[k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                cur[k] = max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur;\\n        }\\n        return pre[K];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (i == M || k == 0)\\n                return 0\\n            var (t, best) = Pair(0, 0)\\n            for (j in 0 until Math.min(A[i].size, k)) {\\n                t += A[i][j]\\n                var cand = t + go(i + 1, k - 1 - j)\\n                best = Math.max(best, cand)\\n            }\\n            return Math.max(best, go(i + 1, k)) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (i == M || k == 0)\\n                return 0\\n            var key = \"$i,$k\"\\n            if (!m.contains(key)) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + go(i + 1, k - 1 - j)\\n                    best = Math.max(best, cand)\\n                }\\n                m[key] = Math.max(best, go(i + 1, k)) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var dp = Array(M + 1) { IntArray(K + 1 ) { 0 } }\\n        for (i in M - 1 downTo 0) {\\n            for (k in 1..K) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + dp[i + 1][k - 1 - j]\\n                    best = Math.max(best, cand)\\n                }\\n                dp[i][k] = Math.max(best, dp[i + 1][k]) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var pre = IntArray(K + 1) { 0 }\\n        for (i in M - 1 downTo 0) {\\n            var cur = IntArray(K + 1) { 0 }\\n            for (k in 1..K) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + pre[k - 1 - j]\\n                    best = Math.max(best, cand)\\n                }\\n                cur[k] = Math.max(best, pre[k]) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur\\n        }\\n        return pre[K]\\n    }\\n}\\n```\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let go = (i = 0, k = K) => {\\n        if (i == M || !k)\\n            return 0;\\n        let [t, best] = [0, 0];\\n        for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n            t += A[i][j];\\n            let cand = t + go(i + 1, k - 1 - j);\\n            best = Math.max(best, cand);\\n        }\\n        return Math.max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n    };\\n    return go();\\n};\\n```\n```\\nlet maxValueOfCoins = (A, K, m = new Map()) => {\\n    let M = A.length;\\n    let go = (i = 0, k = K) => {\\n        if (i == M || !k)\\n            return 0;\\n        let key = `${i},${k}`;\\n        if (!m.has(key)) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + go(i + 1, k - 1 - j);\\n                best = Math.max(best, cand);\\n            }\\n            m.set(key, Math.max(best, go(i + 1, k))); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let dp = [...Array(M + 1)].map(_ => Array(K + 1).fill(0));\\n    for (let i = M - 1; 0 <= i; --i) {\\n        for (let k = 1; k <= K; ++k) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + dp[i + 1][k - 1 - j];\\n                best = Math.max(best, cand);\\n            }\\n            dp[i][k] = Math.max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n    }\\n    return dp[0][K];\\n};\\n```\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let pre = Array(K + 1).fill(0);\\n    for (let i = M - 1; 0 <= i; --i) {\\n        let cur = Array(K + 1).fill(0);\\n        for (let k = 1; k <= K; ++k) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + pre[k - 1 - j];\\n                best = Math.max(best, cand);\\n            }\\n            cur[k] = Math.max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        pre = cur;\\n    }\\n    return pre[K];\\n};\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        def go(i = 0, k = K):\\n            if i == M or not k:\\n                return 0\\n            t, best = 0, 0\\n            for j in range(0, min(len(A[i]), k)):\\n                t += A[i][j]\\n                cand = t + go(i + 1, k - 1 - j)\\n                best = max(best, cand)\\n            return max(best, go(i + 1, k)) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return go()\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        @cache\\n        def go(i = 0, k = K):\\n            if i == M or not k:\\n                return 0\\n            t, best = 0, 0\\n            for j in range(0, min(len(A[i]), k)):\\n                t += A[i][j]\\n                cand = t + go(i + 1, k - 1 - j)\\n                best = max(best, cand)\\n            return max(best, go(i + 1, k)) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return go()\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        dp = [[0] * (K + 1) for _ in range(M + 1)]\\n        for i in range(M - 1, -1, -1):\\n            for k in range(K, -1, -1):\\n                t, best = 0, 0\\n                for j in range(0, min(len(A[i]), k)):\\n                    t += A[i][j]\\n                    cand = t + dp[i + 1][k - 1 - j]\\n                    best = max(best, cand)\\n                dp[i][k] = max(best, dp[i + 1][k]) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return dp[0][K]\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        pre = [0] * (K + 1)\\n        for i in range(M - 1, -1, -1):\\n            cur = [0] * (K + 1)\\n            for k in range(K, -1, -1):\\n                t, best = 0, 0\\n                for j in range(0, min(len(A[i]), k)):\\n                    t += A[i][j]\\n                    cand = t + pre[k - 1 - j]\\n                    best = max(best, cand)\\n                cur[k] = max(best, pre[k]) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            pre = cur\\n        return pre[K]\\n```\n```\\n// TODO: how to write recursive closure in Rust which captures the parent\\'s scope?\\n```\n```\\n// TODO: how to write recursive closure in Rust which captures the parent\\'s scope?\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_value_of_coins(A: VVI, K_: i32) -> i32 {\\n        let M = A.len();\\n        let K = K_ as usize;\\n        let mut dp = vec![vec![0; K + 1]; M + 1];\\n        for i in (0..M).rev() {\\n            for k in 1..=K {\\n                let (mut t, mut best) = (0, 0);\\n                for j in 0..min(A[i].len(), k) {\\n                    t += A[i][j];\\n                    let cand = t + dp[i + 1][k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                dp[i][k] = max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n}\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_value_of_coins(A: VVI, K_: i32) -> i32 {\\n        let M = A.len();\\n        let K = K_ as usize;\\n        let mut pre = vec![0; K + 1];\\n        for i in (0..M).rev() {\\n            let mut cur = vec![0; K + 1];\\n            for k in 1..=K {\\n                let (mut t, mut best) = (0, 0);\\n                for j in 0..min(A[i].len(), k) {\\n                    t += A[i][j];\\n                    let cand = t + pre[k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                cur[k] = max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur;\\n        }\\n        return pre[K];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        fun go = [&](auto i, auto k) {\\n            if (i == M || !k)\\n                return 0;\\n            auto [t, best] = make_pair(0, 0);\\n            for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                t += A[i][j];\\n                auto cand = t + go(i + 1, k - 1 - j);\\n                best = max(best, cand);\\n            }\\n            return max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maxValueOfCoins(VVI& A, int K, Map m = {}) {\\n        int M = A.size();\\n        auto hash = [](auto i, auto k) {\\n            stringstream ss; ss << i << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto k) {\\n            if (i == M || !k)\\n                return 0;\\n            auto key = hash(i, k);\\n            if (m.find(key) == m.end()) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + go(i + 1, k - 1 - j);\\n                    best = max(best, cand);\\n                }\\n                m[key] = max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            return m[key];\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        VVI dp(M + 1, VI(K + 1));\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            for (auto k{ 1 }; k <= K; ++k) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + dp[i + 1][k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                dp[i][k] = max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        VI pre(K + 1);\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            VI cur(K + 1);\\n            for (auto k{ 1 }; k <= K; ++k) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + pre[k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                cur[k] = max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur;\\n        }\\n        return pre[K];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888531,
                "title": "c-2d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    \\n    int helper(int idx,vector<vector<int>>& preffix,int k){\\n        \\n        if(idx >= preffix.size() || k<=0){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1){\\n            return dp[idx][k];\\n        }\\n        \\n        int max_score = INT_MIN;\\n        \\n        \\n        for(int i=0;i<=k && i<=preffix[idx].size();i++){\\n             int sum = 0;\\n            \\n             if(i>0){\\n                sum += preffix[idx][i-1];      \\n             }\\n           \\n             int score = helper(idx+1,preffix,k-i) + sum;\\n             max_score = max(max_score,score);   \\n        }\\n       \\n        return dp[idx][k] = max_score;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k){\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<vector<int>> preffix;\\n        \\n        for(int i=0;i<piles.size();i++){\\n            vector<int> v(piles[i].size());\\n            v[0] = piles[i][0];\\n            \\n            \\n            for(int j=1;j<piles[i].size();j++){\\n                v[j] = piles[i][j] + v[j-1];\\n            }\\n            \\n            preffix.push_back(v);\\n        }\\n       \\n        return helper(0,preffix,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    \\n    int helper(int idx,vector<vector<int>>& preffix,int k){\\n        \\n        if(idx >= preffix.size() || k<=0){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1){\\n            return dp[idx][k];\\n        }\\n        \\n        int max_score = INT_MIN;\\n        \\n        \\n        for(int i=0;i<=k && i<=preffix[idx].size();i++){\\n             int sum = 0;\\n            \\n             if(i>0){\\n                sum += preffix[idx][i-1];      \\n             }\\n           \\n             int score = helper(idx+1,preffix,k-i) + sum;\\n             max_score = max(max_score,score);   \\n        }\\n       \\n        return dp[idx][k] = max_score;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k){\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<vector<int>> preffix;\\n        \\n        for(int i=0;i<piles.size();i++){\\n            vector<int> v(piles[i].size());\\n            v[0] = piles[i][0];\\n            \\n            \\n            for(int j=1;j<piles[i].size();j++){\\n                v[j] = piles[i][j] + v[j-1];\\n            }\\n            \\n            preffix.push_back(v);\\n        }\\n       \\n        return helper(0,preffix,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888110,
                "title": "c-simple-bottom-up-dp",
                "content": "Solution:\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        \\n        // dp[i][j] = maximum money after taking j coins from first i piles.\\n        vector<vector<int> > dp(n+1, vector<int>(k+1, -2000000000));\\n        \\n        dp[0][0]=0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<=k; j++){\\n                \\n                // do not take any coin from this pile.\\n                dp[i+1][j]=max(dp[i+1][j], dp[i][j]);\\n                \\n                int sum=0, cnt=0;\\n                for(int p: piles[i]){\\n                    sum+=p;\\n                    cnt++;\\n                    if(j+cnt<=k)\\n                        // take first cnt coins from this pile.\\n                        dp[i+1][j+cnt]=max(dp[i+1][j+cnt], dp[i][j]+sum);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```\\n\\nTime complexity: O(k * sum(piles[i].length))\\nProof: In iterative solutions it is much easier to deduce the time complexity.\\n```\\nfor each pile:\\n\\tfor each k:\\n\\t\\tfor each prefix of pile:\\n```\\nis equivalent to\\n```\\nfor each pile:\\n\\tfor each prefix of pile:\\n\\t\\tfor each k:\\n```\\n\\nO(piles[0].length * k + piles[1].length * k + ...... + piles[n-1].length * k) = O(k * sum(piles[i].length))",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        \\n        // dp[i][j] = maximum money after taking j coins from first i piles.\\n        vector<vector<int> > dp(n+1, vector<int>(k+1, -2000000000));\\n        \\n        dp[0][0]=0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<=k; j++){\\n                \\n                // do not take any coin from this pile.\\n                dp[i+1][j]=max(dp[i+1][j], dp[i][j]);\\n                \\n                int sum=0, cnt=0;\\n                for(int p: piles[i]){\\n                    sum+=p;\\n                    cnt++;\\n                    if(j+cnt<=k)\\n                        // take first cnt coins from this pile.\\n                        dp[i+1][j+cnt]=max(dp[i+1][j+cnt], dp[i][j]+sum);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```\n```\\nfor each pile:\\n\\tfor each k:\\n\\t\\tfor each prefix of pile:\\n```\n```\\nfor each pile:\\n\\tfor each prefix of pile:\\n\\t\\tfor each k:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887572,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n\\t\\t//dp[i][j] - > maximum total value of coins using i piles and j coins.\\n        vector<vector<int>> dp(n+1,vector<int>(k+1));\\n\\t\\t// store the prefix sum for each pile.\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<(int)piles[i].size();j++)\\n                piles[i][j]+=piles[i][j-1];\\n            \\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=k;j++) // calculate max total value to pick  j coins using i piles.\\n                for(int w=0;w<=(int)piles[i-1].size() and w<=j;w++) // check for all combinations of coins that sum upto j coins. we can pick w coins from this pile and j-w coins from previous piles(dp[i-1][j-w]) i.e=> (j-w)+w=j coins in total.\\n                    dp[i][j]=max(dp[i][j],dp[i-1][j-w]+((w-1>=0)?piles[i-1][w-1]:0));\\n        \\n        return dp[n][k];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n\\t\\t//dp[i][j] - > maximum total value of coins using i piles and j coins.\\n        vector<vector<int>> dp(n+1,vector<int>(k+1));\\n\\t\\t// store the prefix sum for each pile.\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<(int)piles[i].size();j++)\\n                piles[i][j]+=piles[i][j-1];\\n            \\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=k;j++) // calculate max total value to pick  j coins using i piles.\\n                for(int w=0;w<=(int)piles[i-1].size() and w<=j;w++) // check for all combinations of coins that sum upto j coins. we can pick w coins from this pile and j-w coins from previous piles(dp[i-1][j-w]) i.e=> (j-w)+w=j coins in total.\\n                    dp[i][j]=max(dp[i][j],dp[i-1][j-w]+((w-1>=0)?piles[i-1][w-1]:0));\\n        \\n        return dp[n][k];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1887499,
                "title": "ignore-the-sc-and-understand-the-logic",
                "content": "There are only 2 ways\\n1. Take :\\n\\tif you choose the top element there are again two possibilities \\n\\t1. take current element and move to next list or \\n\\t2. take curr element and stand on the same list and call recursion for the next element in the same list.\\n2. Not Take :\\n\\tjust simply move to next list.\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int max=0;\\n        for(List<Integer> curr: piles){\\n            max=Math.max(max,curr.size());\\n        }\\n        Integer dp[][][]=new Integer[piles.size()][max][k+1];\\n        return f(piles,piles.size()-1,0,k,dp);\\n    }\\n    \\n    public int f(List<List<Integer>> piles, int n, int i, int k,Integer dp[][][]){\\n        if(n==-1 || i>=piles.get(n).size() || k<=0){\\n            return 0;\\n        }\\n    \\n        if(dp[n][i][k]!=null) return dp[n][i][k];\\n        int take=0;\\n        if(i<piles.get(n).size()){\\n            \\n            take=piles.get(n).get(i)+ Math.max(f(piles,n,i+1,k-1,dp),f(piles,n-1,0,k-1,dp));\\n        }\\n        int notTake=f(piles,n-1,0,k,dp);\\n        return dp[n][i][k]=Math.max(take,notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int max=0;\\n        for(List<Integer> curr: piles){\\n            max=Math.max(max,curr.size());\\n        }\\n        Integer dp[][][]=new Integer[piles.size()][max][k+1];\\n        return f(piles,piles.size()-1,0,k,dp);\\n    }\\n    \\n    public int f(List<List<Integer>> piles, int n, int i, int k,Integer dp[][][]){\\n        if(n==-1 || i>=piles.get(n).size() || k<=0){\\n            return 0;\\n        }\\n    \\n        if(dp[n][i][k]!=null) return dp[n][i][k];\\n        int take=0;\\n        if(i<piles.get(n).size()){\\n            \\n            take=piles.get(n).get(i)+ Math.max(f(piles,n,i+1,k-1,dp),f(piles,n-1,0,k-1,dp));\\n        }\\n        int notTake=f(piles,n-1,0,k,dp);\\n        return dp[n][i][k]=Math.max(take,notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887376,
                "title": "dp-c",
                "content": "Let\\'s define dp[i][j] = maximum total value with j coins till i-th pile .\\n\\nif we take x coins from i-th pile then we need (j-x) coins till (i-1)-th pile i.e dp[i-1][j-x] . \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                dp[i][j]=dp[i-1][j];\\n                int sum=0;\\n                for(int x=1;x<=j && x<=piles[i-1].size();x++){\\n                    sum += piles[i-1][x-1];\\n                    dp[i][j]=max(dp[i][j], sum + dp[i-1][j-x]);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                dp[i][j]=dp[i-1][j];\\n                int sum=0;\\n                for(int x=1;x<=j && x<=piles[i-1].size();x++){\\n                    sum += piles[i-1][x-1];\\n                    dp[i][j]=max(dp[i][j], sum + dp[i-1][j-x]);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887357,
                "title": "c-2d-dp-memoization-easy",
                "content": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2D dp + Memoization.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\\n\\n**EXPLANATION**\\n* Base Case-> if piles completed or k coins taken\\n* skip current pile and call recursion\\n* check for current pile and call recursion for further piles\\n* keep max value\\n* update memoizated 2d vector\\n\\n\\n\\nTIME COMPLEXITY : O(N^N) , N is size of matrix    **Beats 90.02%**\\nSPACE COMPLEXITY : O(N^N),                                **Beats 70.50%**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\n int solve(int i,vector<vector<int>>&p, int k,vector<vector<int>> &dp){\\n        if(i>=p.size() || k<=0) return 0;     //Base Case-> if piles completed or k coins taken\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int fur = solve(i+1,p,k,dp), cur=0;   // skip current pile\\n        \\n        for(int idx=0;idx<p[i].size() && idx<k; idx++){  // check for current pile \\n            cur += p[i][idx];\\n            fur = max(fur, cur+solve(i+1,p,k-idx-1,dp));  // recursive call for further piles\\n        }\\n        return dp[i][k]=fur;                 // update dp\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        vector<vector<int>> dp(p.size(), vector<int>(k+1,-1));\\n        return solve(0,p,k,dp);\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2D dp + Memoization.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\n```\\n int solve(int i,vector<vector<int>>&p, int k,vector<vector<int>> &dp){\\n        if(i>=p.size() || k<=0) return 0;     //Base Case-> if piles completed or k coins taken\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int fur = solve(i+1,p,k,dp), cur=0;   // skip current pile\\n        \\n        for(int idx=0;idx<p[i].size() && idx<k; idx++){  // check for current pile \\n            cur += p[i][idx];\\n            fur = max(fur, cur+solve(i+1,p,k-idx-1,dp));  // recursive call for further piles\\n        }\\n        return dp[i][k]=fur;                 // update dp\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        vector<vector<int>> dp(p.size(), vector<int>(k+1,-1));\\n        return solve(0,p,k,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887189,
                "title": "java-solution-memoization",
                "content": "```\\nclass Solution {\\n    \\n    Integer [][]dp;\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        dp = new Integer[piles.size() + 1][k + 1];\\n        return maxPoints(piles, piles.size() - 1, k);\\n    }\\n    \\n        \\n    private int maxPoints(List<List<Integer>>piles, int i, int k){\\n\\n        if(i < 0 || k <= 0) \\n            return 0;\\n\\n        if(dp[i][k] != null) \\n            return dp[i][k];\\n\\n        int notTake = maxPoints(piles, i-1, k);\\n\\n        int take = 0;\\n        \\n        for(int j=0, sum=0; j <  Math.min(piles.get(i).size(), k) ; j++){\\n\\n            sum += piles.get(i).get(j);\\n\\n            take = Math.max(sum + maxPoints(piles, i-1, k-j-1), take);\\n        }\\n\\n        int res = Math.max(take, notTake);\\n\\n        dp[i][k] = res;\\n        return res;\\n    }\\n}\\n```\\n\\n#### BOTTOM UP\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        \\n        int n = piles.size();\\n        int[][] dp = new int[n+1][k+1];\\n\\n        for(int i = 1; i <= n; i ++) {\\n            for(int j = 1; j <= k; j ++) {\\n                \\n                dp[i][j] = dp[i-1][j];\\n                int sum = 0;\\n                \\n                for(int l = 1 ; l <= Math.min(piles.get(i-1).size() , j) ; l++) {\\n\\n                    sum += piles.get(i - 1).get(l - 1);\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-1][j-l]+sum);\\n                    \\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Integer [][]dp;\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        dp = new Integer[piles.size() + 1][k + 1];\\n        return maxPoints(piles, piles.size() - 1, k);\\n    }\\n    \\n        \\n    private int maxPoints(List<List<Integer>>piles, int i, int k){\\n\\n        if(i < 0 || k <= 0) \\n            return 0;\\n\\n        if(dp[i][k] != null) \\n            return dp[i][k];\\n\\n        int notTake = maxPoints(piles, i-1, k);\\n\\n        int take = 0;\\n        \\n        for(int j=0, sum=0; j <  Math.min(piles.get(i).size(), k) ; j++){\\n\\n            sum += piles.get(i).get(j);\\n\\n            take = Math.max(sum + maxPoints(piles, i-1, k-j-1), take);\\n        }\\n\\n        int res = Math.max(take, notTake);\\n\\n        dp[i][k] = res;\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        \\n        int n = piles.size();\\n        int[][] dp = new int[n+1][k+1];\\n\\n        for(int i = 1; i <= n; i ++) {\\n            for(int j = 1; j <= k; j ++) {\\n                \\n                dp[i][j] = dp[i-1][j];\\n                int sum = 0;\\n                \\n                for(int l = 1 ; l <= Math.min(piles.get(i-1).size() , j) ; l++) {\\n\\n                    sum += piles.get(i - 1).get(l - 1);\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-1][j-l]+sum);\\n                    \\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897107,
                "title": "dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int r, vector<vector<int>> &piles, int k, vector<vector<int>> &dp)\\n{\\n    if (r == piles.size())\\n    {\\n        if(k == 0)\\n        {\\n            return 0;\\n        }\\n        return -1e9;\\n    }\\n    \\n    if(dp[r][k] != -1)\\n    {\\n        return dp[r][k];\\n    }\\n       \\n    int ans = solve(r + 1, piles, k, dp);\\n    int temp = 0;\\n\\n    for (int i = 0; i < min((int)piles[r].size(), k); i++)\\n    {\\n        temp += piles[r][i];\\n        ans = max(ans, temp + solve(r + 1, piles, k - i - 1, dp));\\n    }\\n\\n    return dp[r][k] = ans;\\n}\\n\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n    return solve(0, piles, k, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int r, vector<vector<int>> &piles, int k, vector<vector<int>> &dp)\\n{\\n    if (r == piles.size())\\n    {\\n        if(k == 0)\\n        {\\n            return 0;\\n        }\\n        return -1e9;\\n    }\\n    \\n    if(dp[r][k] != -1)\\n    {\\n        return dp[r][k];\\n    }\\n       \\n    int ans = solve(r + 1, piles, k, dp);\\n    int temp = 0;\\n\\n    for (int i = 0; i < min((int)piles[r].size(), k); i++)\\n    {\\n        temp += piles[r][i];\\n        ans = max(ans, temp + solve(r + 1, piles, k - i - 1, dp));\\n    }\\n\\n    return dp[r][k] = ans;\\n}\\n\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n    return solve(0, piles, k, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426217,
                "title": "python-divid-and-conquer-without-dp-100",
                "content": "#### Idea\\nCreate a helper function getValues(s, e) that returns a vector vals. \\nvals[i] stores the maximum value that you can get from picking i coins from piles s, s+1, s+2, ..., e.\\nWith the helper fucntion, the final result will be geValues(1, n)[k].\\n\\nThe basic case of getValues is when s equal to t. In this case, there is only one pile. Therefore, for vals[i], we just need to pick the first i coins.\\nFor s < e, we split the piles into two parts ( (s, mid), (mid+1, e)) and get the values of both parts. \\nWith the vals of left and right piles, we can calculate vals[i] by consider taking different j coins from the left part piles and take i-j coins from the right part piles and select the j that can have the maximum value.\\n\\n#### Complexity\\n\\nTime: O(K^2) \\nThis method is better than the DP solution when sum(piles[i].length) is larger than 2000, such as sum(piles[i].length) = 20000.\\nSpace: O(K)\\n\\n#### Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        def getValues(s, e): # return maximum values of getting different numbers from pile s to plie e\\n            if s == e: # only one piles\\n                coin_num = min(len(piles[s]), k)\\n                vals = [0] * (coin_num+1)\\n                for i in range(1, coin_num + 1):\\n                    vals[i] = (vals[i-1] + piles[s][i-1])\\n                return vals\\n            \\n            # more than one piles\\n            mid = (s+e)//2\\n            left_vals = getValues(s, mid)\\n            right_vals = getValues(mid+1, e)\\n            \\n            coin_num_l = len(left_vals) -1\\n            coin_num_r = len(right_vals) -1\\n            coin_num = min(k, coin_num_l+coin_num_r)\\n            vals = [0] * (coin_num+1)\\n            for i in range(1, coin_num+1): # calculate max value of picking i coins (vals[i])\\n                vals[i] = -1\\n                min_l = max(0, (i - coin_num_r)) # minimum coins that need to take from left in order to take i coins  from both sides \\n                max_l = min(i, coin_num_l) + 1 # maxmum coins that need to take from left in order to take i coins  from both sides \\n                for j in range(min_l, max_l): # consider the case of select j coins from the left side\\n                    tmp = left_vals[j] + right_vals[i-j] \\n                    if vals[i] < tmp:\\n                        vals[i] = tmp\\n            return vals\\n        \\n        vals = getValues(0, len(piles)-1)\\n        \\n        return vals[k]\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        def getValues(s, e): # return maximum values of getting different numbers from pile s to plie e\\n            if s == e: # only one piles\\n                coin_num = min(len(piles[s]), k)\\n                vals = [0] * (coin_num+1)\\n                for i in range(1, coin_num + 1):\\n                    vals[i] = (vals[i-1] + piles[s][i-1])\\n                return vals\\n            \\n            # more than one piles\\n            mid = (s+e)//2\\n            left_vals = getValues(s, mid)\\n            right_vals = getValues(mid+1, e)\\n            \\n            coin_num_l = len(left_vals) -1\\n            coin_num_r = len(right_vals) -1\\n            coin_num = min(k, coin_num_l+coin_num_r)\\n            vals = [0] * (coin_num+1)\\n            for i in range(1, coin_num+1): # calculate max value of picking i coins (vals[i])\\n                vals[i] = -1\\n                min_l = max(0, (i - coin_num_r)) # minimum coins that need to take from left in order to take i coins  from both sides \\n                max_l = min(i, coin_num_l) + 1 # maxmum coins that need to take from left in order to take i coins  from both sides \\n                for j in range(min_l, max_l): # consider the case of select j coins from the left side\\n                    tmp = left_vals[j] + right_vals[i-j] \\n                    if vals[i] < tmp:\\n                        vals[i] = tmp\\n            return vals\\n        \\n        vals = getValues(0, len(piles)-1)\\n        \\n        return vals[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421191,
                "title": "dp-solution-easy-to-understand-step-by-step-explanation-c",
                "content": "# Intuition\\n<!--  -->\\nIt\\'s obvious that there is no greedy solution for this problem since there are multiple combinations and also restriction of picking topmost of pile.\\n So, we are probably going to explore all combinations and choose the most optimal one. \\nThis should give a hint for a recursive complete search solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet the **state** of our DP be DP[i][k].\\n\\nHere DP[i][k] is defined as the maximum profit we can get starting from the i-th pile and still having room for k more coins.\\n\\nNow, the **transition** is going to be simple. There are two choices:\\n1. Don\\'t pick any coin from this pile. In that case, DP[i][k] = DP[i+1][k]\\n2. Pick exactly j coins from this pile (given that j <= k).\\nIn this case, DP[i][k] = sum of topmost j coins + DP[i+1][k-j].\\n\\nNow, coming to the **base cases**:\\n1. If we don\\'t have space for any more coins, then profit will be 0.\\n    So, DP[...][0]=0\\n2. If we are at the end of our list of piles, we can no longer generate anymore profit. \\n    So, DP[n][...]=0\\n\\nOur final answer, is going to be present in DP[0][k]. \\nWe can construct a DP table of size (N*K) and use it to store and fill in the DP values. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n* k * |pile[i]| )$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*k)$$\\n# Code\\nHere\\'s the Dynamic Programming Solution:\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=(int)piles.size();\\n        vector<vector<int>>dp;\\n        dp.resize(n+1, vector<int>(k+1,0));\\n        // State: dp[i][k]-> Max profit starting from i-th pile and remaining k coins\\n        // Transition: dp[i][k]=max(dp[i+1][k], (pick first j coins) -> dp[i+1][k-j])\\n        // Base Case: dp[n][...]=0, dp[...][0]=0\\n        // Final Answer: dp[0][k]\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=0;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int coins=0;coins<=k;coins++){\\n                // Don\\'t take any coin.\\n                dp[i][coins]=dp[i+1][coins];\\n                int cost=0;\\n                // Take j coins (j<=coins)\\n                for(int j=0;j<(int)piles[i].size() && j<coins;j++){\\n                    cost+=piles[i][j];\\n                    dp[i][coins]=max(dp[i][coins], cost + dp[i+1][coins - (j+1)]);\\n                }\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=(int)piles.size();\\n        vector<vector<int>>dp;\\n        dp.resize(n+1, vector<int>(k+1,0));\\n        // State: dp[i][k]-> Max profit starting from i-th pile and remaining k coins\\n        // Transition: dp[i][k]=max(dp[i+1][k], (pick first j coins) -> dp[i+1][k-j])\\n        // Base Case: dp[n][...]=0, dp[...][0]=0\\n        // Final Answer: dp[0][k]\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=0;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int coins=0;coins<=k;coins++){\\n                // Don\\'t take any coin.\\n                dp[i][coins]=dp[i+1][coins];\\n                int cost=0;\\n                // Take j coins (j<=coins)\\n                for(int j=0;j<(int)piles[i].size() && j<coins;j++){\\n                    cost+=piles[i][j];\\n                    dp[i][coins]=max(dp[i][coins], cost + dp[i+1][coins - (j+1)]);\\n                }\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421076,
                "title": "easy-c-solution-recursion-to-memoization-using-prefix-sum",
                "content": "# Intuition\\nWe can iterate through piles and decide if we want to take something from the pile or not take it. \\nIf we decide to take coins from a particular pile, then we have the choice of how many coins to take.\\n\\n# Approach\\nLet\\'s try to think of a recursive solution. \\nWe have two choices, to take coins from a particular pile, or to take nothing. Suppose we start from the last pile, then we have two choices:\\n\\n**notTake: f(i-1, k)**  // *just move to the next pile*\\n**take: (sum of x coins) + f(i-1, k-x)**  // *if we decide to take x coins from pile[i], then we need the sum of all coins from 0 to x, and my k is reduced accordingly, this can be done using a for loop*\\n\\nInstead of calculating sum of x coins everytime I decide to take coins from the pile, we can make a prefix sum array so we can access the sum by going the xth index in the ith pile, it piles[i][x];\\n\\n\\n# Code\\n**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int k, vector<vector<int>>& prefixPiles){\\n        // if we reach the end of piles, or k becomes 0 we return 0\\n        if(i<0 || k==0) return 0;\\n\\n        int temp=prefixPiles[i].size();\\n        //we can only take coins from a pile n times.\\n        int n=min(temp, k);\\n\\n        //move to the next index and k remains same\\n        int notTake=f(i-1, k, prefixPiles);\\n\\n        int take=0;\\n        for(int j=0; j<n; j++){\\n            //take coins from pile\\n            take=max(take, prefixPiles[i][j]+f(i-1, k-j-1, prefixPiles));\\n        }\\n        //return max\\n        return max(take, notTake);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //making a prefix sum array to aviod adding coins everytime.\\n        vector<vector<int>> prefixPiles;\\n        for(int i=0; i<piles.size(); i++){\\n            vector<int> temp;\\n            temp.push_back(piles[i][0]);\\n            for(int j=1; j<piles[i].size(); j++){\\n                temp.push_back(temp[j-1]+piles[i][j]);\\n            }\\n            prefixPiles.push_back(temp);\\n        }\\n        //calling recursion starting from the last pile\\n        return f(piles.size()-1, k, prefixPiles);\\n    }\\n};\\n```\\n\\n**Memoization:**\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int k, vector<vector<int>>& prefixPiles, vector<vector<int>>& dp){\\n        if(i<0 || k==0) return 0;\\n\\n        //if value is available for a particular index, use it\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int temp=prefixPiles[i].size();\\n        int n=min(temp, k);\\n        int notTake=f(i-1, k, prefixPiles, dp);\\n\\n        int take=0;\\n        for(int j=0; j<n; j++){\\n            take=max(take, prefixPiles[i][j]+f(i-1, k-j-1, prefixPiles, dp));\\n        }\\n        //store max in dp array\\n        return dp[i][k]=max(take, notTake);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //making a prefix sum array to aviod adding coins everytime.\\n        vector<vector<int>> prefixPiles;\\n        for(int i=0; i<piles.size(); i++){\\n            vector<int> temp;\\n            temp.push_back(piles[i][0]);\\n            for(int j=1; j<piles[i].size(); j++){\\n                temp.push_back(temp[j-1]+piles[i][j]);\\n            }\\n            prefixPiles.push_back(temp);\\n        }\\n        //declare dp array\\n        vector<vector<int>> dp(piles.size()+1, vector<int>(k+1,-1));\\n        return f(piles.size()-1, k, prefixPiles, dp);\\n    }\\n};\\n```\\n**Please upvote if you understood the solution.**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int k, vector<vector<int>>& prefixPiles){\\n        // if we reach the end of piles, or k becomes 0 we return 0\\n        if(i<0 || k==0) return 0;\\n\\n        int temp=prefixPiles[i].size();\\n        //we can only take coins from a pile n times.\\n        int n=min(temp, k);\\n\\n        //move to the next index and k remains same\\n        int notTake=f(i-1, k, prefixPiles);\\n\\n        int take=0;\\n        for(int j=0; j<n; j++){\\n            //take coins from pile\\n            take=max(take, prefixPiles[i][j]+f(i-1, k-j-1, prefixPiles));\\n        }\\n        //return max\\n        return max(take, notTake);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //making a prefix sum array to aviod adding coins everytime.\\n        vector<vector<int>> prefixPiles;\\n        for(int i=0; i<piles.size(); i++){\\n            vector<int> temp;\\n            temp.push_back(piles[i][0]);\\n            for(int j=1; j<piles[i].size(); j++){\\n                temp.push_back(temp[j-1]+piles[i][j]);\\n            }\\n            prefixPiles.push_back(temp);\\n        }\\n        //calling recursion starting from the last pile\\n        return f(piles.size()-1, k, prefixPiles);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i, int k, vector<vector<int>>& prefixPiles, vector<vector<int>>& dp){\\n        if(i<0 || k==0) return 0;\\n\\n        //if value is available for a particular index, use it\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int temp=prefixPiles[i].size();\\n        int n=min(temp, k);\\n        int notTake=f(i-1, k, prefixPiles, dp);\\n\\n        int take=0;\\n        for(int j=0; j<n; j++){\\n            take=max(take, prefixPiles[i][j]+f(i-1, k-j-1, prefixPiles, dp));\\n        }\\n        //store max in dp array\\n        return dp[i][k]=max(take, notTake);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //making a prefix sum array to aviod adding coins everytime.\\n        vector<vector<int>> prefixPiles;\\n        for(int i=0; i<piles.size(); i++){\\n            vector<int> temp;\\n            temp.push_back(piles[i][0]);\\n            for(int j=1; j<piles[i].size(); j++){\\n                temp.push_back(temp[j-1]+piles[i][j]);\\n            }\\n            prefixPiles.push_back(temp);\\n        }\\n        //declare dp array\\n        vector<vector<int>> dp(piles.size()+1, vector<int>(k+1,-1));\\n        return f(piles.size()-1, k, prefixPiles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421061,
                "title": "php-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(k * s)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[][] $piles\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function maxValueOfCoins($piles, $k)\\n    {\\n        $a = array_fill(0, 2, array_fill(1, $k, 0));\\n        $c = 0;\\n        foreach ($piles as $pile) {\\n            for ($i = 1; $i <= $k; $i++) {\\n                for ($j = 0, $s = 0, $kk = min($i, count($pile)) ; $j < $kk; $j++) {\\n                    $s += $pile[$j];\\n                    $a[$c][$i] = max($a[$c][$i], $a[1 - $c][$i], $s + $a[1 - $c][$i - $j - 1]);\\n                }\\n            }\\n            $c = 1 - $c;\\n        }\\n\\n        return end($a[1 - $c]);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "PHP",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[][] $piles\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function maxValueOfCoins($piles, $k)\\n    {\\n        $a = array_fill(0, 2, array_fill(1, $k, 0));\\n        $c = 0;\\n        foreach ($piles as $pile) {\\n            for ($i = 1; $i <= $k; $i++) {\\n                for ($j = 0, $s = 0, $kk = min($i, count($pile)) ; $j < $kk; $j++) {\\n                    $s += $pile[$j];\\n                    $a[$c][$i] = max($a[$c][$i], $a[1 - $c][$i], $s + $a[1 - $c][$i - $j - 1]);\\n                }\\n            }\\n            $c = 1 - $c;\\n        }\\n\\n        return end($a[1 - $c]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420694,
                "title": "c-top-down-dp-linear-space-complexity-bottom-up-dp",
                "content": "# Top Down DP linear space\\n```\\nclass Solution {\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        vector<int> dp(k + 1);\\n        dp[0] = 0;\\n\\n        for(int j = 1; j <= k; j++)\\n            dp[j] = dp[j - 1] + (j - 1 < piles[n - 1].size() ? piles[n - 1][j - 1] : 0);\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            vector<int> _dp(k + 1);\\n            _dp[0] = 0;\\n            for(int j = 1; j <= k; j++)\\n            {\\n                int preSum = 0;\\n                int currMax = dp[j];\\n                for(int x = 1; x <= j && x - 1 < piles[i].size(); x++)\\n                {\\n                    preSum += piles[i][x - 1];\\n                    currMax = max(currMax, preSum + dp[j - x]);\\n                }\\n                _dp[j] = currMax;\\n            }\\n            dp.swap(_dp);\\n        }\\n\\n        return dp[k];\\n    }\\n};\\n\\n```\\n\\n\\n# Bottom Up DP\\n```\\n\\nclass Solution {\\n\\n    int DFS(int index, int k, vector<vector<int>>& piles, vector<vector<int>> &dp)\\n    {\\n        if(index >= piles.size() || k == 0)\\n            return 0;\\n\\n        if(dp[index][k] != -1)\\n            return dp[index][k];\\n\\n        int ret = 0;\\n        int preSum = 0;\\n        \\n        // completely ignore the current pile\\n        ret = DFS(index + 1, k, piles, dp);\\n\\n        // try to add more and more coins from current pile and then move on\\n        for(int i = 0; i < piles[index].size() && k - i - 1 >= 0; i++)\\n        {\\n            preSum += piles[index][i];\\n            ret = max(ret, preSum + DFS(index + 1, k - i - 1, piles, dp));\\n        }\\n\\n        return dp[index][k] = ret;\\n    }\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int>(k + 1, -1));\\n        return DFS(0, k, piles, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        vector<int> dp(k + 1);\\n        dp[0] = 0;\\n\\n        for(int j = 1; j <= k; j++)\\n            dp[j] = dp[j - 1] + (j - 1 < piles[n - 1].size() ? piles[n - 1][j - 1] : 0);\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            vector<int> _dp(k + 1);\\n            _dp[0] = 0;\\n            for(int j = 1; j <= k; j++)\\n            {\\n                int preSum = 0;\\n                int currMax = dp[j];\\n                for(int x = 1; x <= j && x - 1 < piles[i].size(); x++)\\n                {\\n                    preSum += piles[i][x - 1];\\n                    currMax = max(currMax, preSum + dp[j - x]);\\n                }\\n                _dp[j] = currMax;\\n            }\\n            dp.swap(_dp);\\n        }\\n\\n        return dp[k];\\n    }\\n};\\n\\n```\n```\\n\\nclass Solution {\\n\\n    int DFS(int index, int k, vector<vector<int>>& piles, vector<vector<int>> &dp)\\n    {\\n        if(index >= piles.size() || k == 0)\\n            return 0;\\n\\n        if(dp[index][k] != -1)\\n            return dp[index][k];\\n\\n        int ret = 0;\\n        int preSum = 0;\\n        \\n        // completely ignore the current pile\\n        ret = DFS(index + 1, k, piles, dp);\\n\\n        // try to add more and more coins from current pile and then move on\\n        for(int i = 0; i < piles[index].size() && k - i - 1 >= 0; i++)\\n        {\\n            preSum += piles[index][i];\\n            ret = max(ret, preSum + DFS(index + 1, k - i - 1, piles, dp));\\n        }\\n\\n        return dp[index][k] = ret;\\n    }\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int>(k + 1, -1));\\n        return DFS(0, k, piles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420685,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        presum = [list(accumulate(p, initial=0)) for p in piles]\\n        n = len(piles)\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        for i, s in enumerate(presum, 1):\\n            for j in range(k + 1):\\n                for idx, v in enumerate(s):\\n                    if j >= idx:\\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - idx] + v)\\n        return dp[-1][-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        presum = [list(accumulate(p, initial=0)) for p in piles]\\n        n = len(piles)\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        for i, s in enumerate(presum, 1):\\n            for j in range(k + 1):\\n                for idx, v in enumerate(s):\\n                    if j >= idx:\\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - idx] + v)\\n        return dp[-1][-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419962,
                "title": "easy-c-dp-memoization-without-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<vector<int>>& dp,vector<vector<int>>& piles)\\n    {\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int np = solve(i+1,k,dp,piles);\\n        int p=0;\\n        int sum=0;\\n        for(int ind=0;ind<piles[i].size() and ind+1<=k;ind++)\\n        {\\n            sum+=piles[i][ind];\\n            p=max(p,sum+solve(i+1,k-ind-1,dp,piles));\\n            \\n        }\\n        return dp[i][k]=max(p,np);\\n    }\\n int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(0,k,dp,piles);  \\n }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<vector<int>>& dp,vector<vector<int>>& piles)\\n    {\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int np = solve(i+1,k,dp,piles);\\n        int p=0;\\n        int sum=0;\\n        for(int ind=0;ind<piles[i].size() and ind+1<=k;ind++)\\n        {\\n            sum+=piles[i][ind];\\n            p=max(p,sum+solve(i+1,k-ind-1,dp,piles));\\n            \\n        }\\n        return dp[i][k]=max(p,np);\\n    }\\n int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(0,k,dp,piles);  \\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419918,
                "title": "easy-c-dp-memoization-tabulation-with-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<vector<int>>& dp,vector<vector<int>>& piles)\\n    {\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int np = solve(i+1,k,dp,piles);\\n        int p=0;\\n        for(int ind=0;ind<piles[i].size();ind++)\\n        {\\n            if(ind+1<=k)\\n            {\\n                p=max(p,piles[i][ind]+solve(i+1,k-ind-1,dp,piles));\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[i][k]=max(p,np);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<piles[i].size();j++)\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(0,k,dp,piles);        \\n    }\\n};\\n```\\nTABULATION\\n```\\n int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<piles[i].size();j++)\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,0));\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=1;j<=k;j++)\\n            {\\n                int np = dp[i+1][j];\\n                int p=0;\\n                for(int ind=0;ind<piles[i].size();ind++)\\n                {\\n                    if(ind+1<=j)\\n                    {\\n                        p=max(p,piles[i][ind]+dp[i+1][j-ind-1]);\\n                    }\\n                    else\\n                    {   \\n                        break;\\n                    }\\n                }\\n                dp[i][j]=max(p,np); \\n            }\\n        }return dp[0][k];\\n\\n        //return solve(0,k,dp,piles);        \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<vector<int>>& dp,vector<vector<int>>& piles)\\n    {\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int np = solve(i+1,k,dp,piles);\\n        int p=0;\\n        for(int ind=0;ind<piles[i].size();ind++)\\n        {\\n            if(ind+1<=k)\\n            {\\n                p=max(p,piles[i][ind]+solve(i+1,k-ind-1,dp,piles));\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[i][k]=max(p,np);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<piles[i].size();j++)\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(0,k,dp,piles);        \\n    }\\n};\\n```\n```\\n int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<piles[i].size();j++)\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,0));\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=1;j<=k;j++)\\n            {\\n                int np = dp[i+1][j];\\n                int p=0;\\n                for(int ind=0;ind<piles[i].size();ind++)\\n                {\\n                    if(ind+1<=j)\\n                    {\\n                        p=max(p,piles[i][ind]+dp[i+1][j-ind-1]);\\n                    }\\n                    else\\n                    {   \\n                        break;\\n                    }\\n                }\\n                dp[i][j]=max(p,np); \\n            }\\n        }return dp[0][k];\\n\\n        //return solve(0,k,dp,piles);        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419910,
                "title": "java-runtime-53-ms-beats-95-6-memory-43-1-mb-beats-82-72",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];// k steps dynamic programming;\\n        for(List<Integer> pile:piles){\\n            int m=pile.size();\\n            int[] cum=new int[m+1];\\n            for(int i=0;i<m;i++) cum[i+1]=cum[i]+pile.get(i);\\n            int[] curdp=new int[k+1];\\n            for(int i=0;i<=k;i++){\\n                for(int j=0;j<=m&& i+j <=k;j++){\\n                    curdp[i+j]=Math.max(curdp[i+j],dp[i]+cum[j]);\\n                }\\n            }\\n            dp=curdp;\\n        }\\n        return dp[k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];// k steps dynamic programming;\\n        for(List<Integer> pile:piles){\\n            int m=pile.size();\\n            int[] cum=new int[m+1];\\n            for(int i=0;i<m;i++) cum[i+1]=cum[i]+pile.get(i);\\n            int[] curdp=new int[k+1];\\n            for(int i=0;i<=k;i++){\\n                for(int j=0;j<=m&& i+j <=k;j++){\\n                    curdp[i+j]=Math.max(curdp[i+j],dp[i]+cum[j]);\\n                }\\n            }\\n            dp=curdp;\\n        }\\n        return dp[k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419644,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\tpublic static int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n\\t\\tint[] mv = new int[k + 1];\\n\\t\\tint[] pileSum = new int[k + 1];\\n\\t\\tfor (List<Integer> pile : piles) {\\n\\t\\t\\tint n = Math.min(k, pile.size());\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t\\tpileSum[i] = sum += pile.get(i - 1);\\n\\t\\t\\tfor (int i = k; i > 0; i--) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\tfor (int j = Math.min(i, n); j >= 0; j--)\\n\\t\\t\\t\\t\\tmax = Math.max(max, pileSum[j] + mv[i - j]);\\n\\t\\t\\t\\tmv[i] = max;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mv[k];\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n\\t\\tint[] mv = new int[k + 1];\\n\\t\\tint[] pileSum = new int[k + 1];\\n\\t\\tfor (List<Integer> pile : piles) {\\n\\t\\t\\tint n = Math.min(k, pile.size());\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t\\tpileSum[i] = sum += pile.get(i - 1);\\n\\t\\t\\tfor (int i = k; i > 0; i--) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\tfor (int j = Math.min(i, n); j >= 0; j--)\\n\\t\\t\\t\\t\\tmax = Math.max(max, pileSum[j] + mv[i - j]);\\n\\t\\t\\t\\tmv[i] = max;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mv[k];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419627,
                "title": "choose-or-dont-choose-that-pile-with-how-many-are-you-going-to-choose-from-that-pile-is-the-idea",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(int npile , int coins, int n,vector<vector<int>>& p,vector<vector<int>> &c)\\n    {\\n        if(npile>=n || coins <= 0)\\n            return 0;\\n        if(c[npile][coins]!=-1)\\n            return c[npile][coins];\\n        c[npile][coins] = dfs(npile+1,coins,n,p,c);\\n        int cpile = 0;\\n        for(int j=0;j<min(coins,(int)p[npile].size());j++)\\n        {\\n            cpile+=p[npile][j];\\n            c[npile][coins] = max(c[npile][coins],cpile+dfs(npile+1,coins-1-j,n,p,c));\\n        }\\n        return c[npile][coins];\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        \\n        int n = p.size();\\n        vector<vector<int>> cache(n+1,vector<int> (k+1,-1));\\n        return dfs(0,k,n,p,cache);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(int npile , int coins, int n,vector<vector<int>>& p,vector<vector<int>> &c)\\n    {\\n        if(npile>=n || coins <= 0)\\n            return 0;\\n        if(c[npile][coins]!=-1)\\n            return c[npile][coins];\\n        c[npile][coins] = dfs(npile+1,coins,n,p,c);\\n        int cpile = 0;\\n        for(int j=0;j<min(coins,(int)p[npile].size());j++)\\n        {\\n            cpile+=p[npile][j];\\n            c[npile][coins] = max(c[npile][coins],cpile+dfs(npile+1,coins-1-j,n,p,c));\\n        }\\n        return c[npile][coins];\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        \\n        int n = p.size();\\n        vector<vector<int>> cache(n+1,vector<int> (k+1,-1));\\n        return dfs(0,k,n,p,cache);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419423,
                "title": "2218-maximum-value-of-k-coins-from-piles-java",
                "content": "```\\nclass Solution {\\n    public int solve (List<List<Integer>> piles,int i,int k,int [][] dp )\\n    {\\n        if(i>=piles.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int max=0;\\n            max=Math.max(max,solve(piles,i+1,k,dp));\\n        for(int j=0;j<piles.get(i).size();j++)\\n        {\\n            if(j+1<=k)\\n                max=Math.max(max,piles.get(i).get(j)+solve(piles,i+1,k-j-1,dp));\\n            else\\n                break;\\n        }\\n        return dp[i][k]=max;\\n    }\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        for(int i=0;i<piles.size();i++)\\n        {\\n         \\n         for(int j=1;j<piles.get(i).size();j++)\\n            {   \\n                int removed=  piles.get(i).get(j);\\n                removed+=  piles.get(i).get(j-1);\\n                piles.get(i).set(j,removed); \\n            } \\n        }\\n        int n=piles.size();\\n        int [][]dp=new int [n+1][k+1];\\n        for(int x[]:dp)\\n            Arrays.fill(x,-1);\\n        return solve(piles,0,k,dp);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int solve (List<List<Integer>> piles,int i,int k,int [][] dp )\\n    {\\n        if(i>=piles.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int max=0;\\n            max=Math.max(max,solve(piles,i+1,k,dp));\\n        for(int j=0;j<piles.get(i).size();j++)\\n        {\\n            if(j+1<=k)\\n                max=Math.max(max,piles.get(i).get(j)+solve(piles,i+1,k-j-1,dp));\\n            else\\n                break;\\n        }\\n        return dp[i][k]=max;\\n    }\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        for(int i=0;i<piles.size();i++)\\n        {\\n         \\n         for(int j=1;j<piles.get(i).size();j++)\\n            {   \\n                int removed=  piles.get(i).get(j);\\n                removed+=  piles.get(i).get(j-1);\\n                piles.get(i).set(j,removed); \\n            } \\n        }\\n        int n=piles.size();\\n        int [][]dp=new int [n+1][k+1];\\n        for(int x[]:dp)\\n            Arrays.fill(x,-1);\\n        return solve(piles,0,k,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419414,
                "title": "c-take-and-nottake-dp-memoization-simple-and-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(n*k)\\n\\n- Space complexity:\\no(n*k)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, vector<vector<int>>& piles, vector<vector<int>>& dp, int k) {\\n        if(ind >= piles.size()) return 0;\\n\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n\\n        int sum = 0, take = 0;\\n\\n        //not taking from current pile;\\n        int notTake = 0 + solve(ind+1,piles,dp,k);\\n\\n        //taking from current pile if we can take according to given k and move towards next ind\\n        for(int i=0;i<piles[ind].size();i++) {\\n            sum += piles[ind][i];\\n\\n            if(k - (i+1) >= 0) {\\n                take = max(take, sum + solve(ind+1, piles, dp, k-(i+1)));\\n            }\\n        }\\n\\n        return dp[ind][k] = max(take, notTake);\\n    }\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return solve(0,piles,dp,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int ind, vector<vector<int>>& piles, vector<vector<int>>& dp, int k) {\\n        if(ind >= piles.size()) return 0;\\n\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n\\n        int sum = 0, take = 0;\\n\\n        //not taking from current pile;\\n        int notTake = 0 + solve(ind+1,piles,dp,k);\\n\\n        //taking from current pile if we can take according to given k and move towards next ind\\n        for(int i=0;i<piles[ind].size();i++) {\\n            sum += piles[ind][i];\\n\\n            if(k - (i+1) >= 0) {\\n                take = max(take, sum + solve(ind+1, piles, dp, k-(i+1)));\\n            }\\n        }\\n\\n        return dp[ind][k] = max(take, notTake);\\n    }\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return solve(0,piles,dp,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419195,
                "title": "kotlin-prefix-sum-dp-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nUse top-down dp to find max value of coin.\\n\\nSave every optimal value in dp table and use that value at next iteration.\\n\\nFlow goes like this:\\n\\n![Screenshot 1.png](https://assets.leetcode.com/users/images/abeeeae2-06c1-45ab-98ec-e99d61aaf750_1681554282.2017314.png)\\n\\n![Screenshot 2.png](https://assets.leetcode.com/users/images/4177b469-39d5-4caa-bde3-8a3e783423c1_1681554331.997646.png)\\n\\n![Screenshot 3.png](https://assets.leetcode.com/users/images/26f7b9be-ddfd-4433-9779-047d65f30417_1681554338.7622476.png)\\n\\n![Screenshot 4.png](https://assets.leetcode.com/users/images/f384cb7e-1371-4d88-8edf-c60e73325969_1681554343.7514818.png)\\n\\n![Screenshot 5.png](https://assets.leetcode.com/users/images/476ca714-3bfc-4901-b983-129cbe384803_1681554361.4551725.png)\\n\\n![Screenshot 6.png](https://assets.leetcode.com/users/images/a8dfd35d-1eff-4c1d-bb4d-cc743ec3cbef_1681554384.7290597.png)\\n\\n![Screenshot 7.png](https://assets.leetcode.com/users/images/781dd1af-b1c0-4fdf-bf95-481d894f4e1e_1681554394.5070295.png)\\n\\n![Screenshot 8.png](https://assets.leetcode.com/users/images/f0d1fc8a-21a2-4f23-baff-d3b77a3de1ef_1681554401.5723536.png)\\n\\n![Screenshot 9.png](https://assets.leetcode.com/users/images/5571a620-8666-4c19-98ed-9a06cdc9123e_1681554419.5653806.png)\\n\\n![Screenshot 10.png](https://assets.leetcode.com/users/images/59b913fc-712b-4493-8ff6-c96e3956570f_1681554441.5546458.png)\\n\\n![Screenshot 11.png](https://assets.leetcode.com/users/images/5ae3a06d-6a14-47c9-822d-49ddb10ccbe0_1681554486.8244655.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {\\n       val dp = Array(piles.size + 1) { IntArray(k + 1) }\\n\\n        for (i in piles.lastIndex downTo 0) {\\n            for (kIndex in k downTo 1) {\\n                var currentValue = 0\\n                var maxValue = dp[i + 1][kIndex]\\n\\n                for (j in 0 until minOf(kIndex, piles[i].size)) {\\n                    currentValue += piles[i][j]\\n                    maxValue = maxOf(maxValue, currentValue + dp[i + 1][kIndex - (j + 1)])\\n                }\\n\\n                dp[i][kIndex] = maxValue\\n            }\\n        }\\n\\n        return dp[0][k]\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {\\n       val dp = Array(piles.size + 1) { IntArray(k + 1) }\\n\\n        for (i in piles.lastIndex downTo 0) {\\n            for (kIndex in k downTo 1) {\\n                var currentValue = 0\\n                var maxValue = dp[i + 1][kIndex]\\n\\n                for (j in 0 until minOf(kIndex, piles[i].size)) {\\n                    currentValue += piles[i][j]\\n                    maxValue = maxOf(maxValue, currentValue + dp[i + 1][kIndex - (j + 1)])\\n                }\\n\\n                dp[i][kIndex] = maxValue\\n            }\\n        }\\n\\n        return dp[0][k]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419176,
                "title": "c-dp-recursion",
                "content": "# Intuition\\nUse DP and recursion.\\n\\n# Approach\\nCreate the method\\n```\\nprivate int MaxValueOfCoins((int index, int k) key, Dictionary<(int index, int k), int> dic, IList<IList<int>> piles)\\n```\\n, where\\n- (int index, int k) key contains the index of a current pile and k - the number of coins\\n- Dictionary<(int index, int k), int> dic is a dictionary with a result for a certain key\\n- IList<IList<int>> piles is an initial piles\\nCall this method recursively.\\n# Complexity\\n- Time complexity:\\n$$O(sum(len(piles[i])))$$\\n\\n- Space complexity:\\n$$O(sum(len(piles[i])))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n        var rs = MaxValueOfCoins((0, k), new Dictionary<(int index, int k), int>(), piles);\\n        return rs;\\n    }\\n    private int MaxValueOfCoins((int index, int k) key, Dictionary<(int index, int k), int> dic, IList<IList<int>> piles)\\n    {\\n        if (piles.Count <= key.index || key.k <= 0) return 0;\\n        if (dic.ContainsKey(key)) return dic[key];\\n        var rs = MaxValueOfCoins((key.index + 1, key.k), dic, piles);\\n        var sum = 0;\\n        for (int i = 0; i < Math.Min(piles[key.index].Count, key.k); i++)\\n        {\\n            sum += piles[key.index][i];\\n            var rs0 = sum + MaxValueOfCoins((key.index + 1, key.k - (i + 1)), dic, piles);\\n            if (rs < rs0) rs = rs0;\\n        }\\n        if (!dic.ContainsKey(key)) dic.Add(key, rs);\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nprivate int MaxValueOfCoins((int index, int k) key, Dictionary<(int index, int k), int> dic, IList<IList<int>> piles)\\n```\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n        var rs = MaxValueOfCoins((0, k), new Dictionary<(int index, int k), int>(), piles);\\n        return rs;\\n    }\\n    private int MaxValueOfCoins((int index, int k) key, Dictionary<(int index, int k), int> dic, IList<IList<int>> piles)\\n    {\\n        if (piles.Count <= key.index || key.k <= 0) return 0;\\n        if (dic.ContainsKey(key)) return dic[key];\\n        var rs = MaxValueOfCoins((key.index + 1, key.k), dic, piles);\\n        var sum = 0;\\n        for (int i = 0; i < Math.Min(piles[key.index].Count, key.k); i++)\\n        {\\n            sum += piles[key.index][i];\\n            var rs0 = sum + MaxValueOfCoins((key.index + 1, key.k - (i + 1)), dic, piles);\\n            if (rs < rs0) rs = rs0;\\n        }\\n        if (!dic.ContainsKey(key)) dic.Add(key, rs);\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419122,
                "title": "no-brainer-dfs-solution-with-cache",
                "content": "# Intuition\\nIntuition 1: for pile i, I can pick l = 0, 1, ..., min(k, len(pile[i])) coins from pile i;\\nIntuition 2: when I pick l coins on pile i, I then can pick k-l coins from i+1 to N-1 piles.\\n        \\n# Approach\\nSolve a subproblem: Find the maximum total value if we are picking from ith pile upto (N-1)th pile for a total of k coins.\\n\\n# Complexity\\n- Time complexity:\\n$$O(Nmk)$$ - N is the length of piles, m is the number of coins in each pile.\\n\\n- Space complexity:\\n$$O(Nk)$$ - N is the length of piles.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        Intuition 1: for pile i, I can pick l = 0, 1, ..., min(k, len(pile[i])) coins from pile i;\\n        Intuition 2: when I pick l coins on pile i, from i+1 to N-1 piles, I then can k-l coins.\\n        Subproblem: Find the maximum total value if we pick from i-th pile and up for a total of k coins.\\n        \"\"\"\\n        @cache\\n        def solve(i: int, k: int) -> int:\\n            # end of piles or no more room for any coin\\n            if i == len(piles) or k == 0:\\n                return 0\\n\\n            # don\\'t pick this pile\\n            res = solve(i+1, k)\\n            cur_total = 0\\n\\n            # If we pick this pile, try all possible number of coins that we can pick, e.g. 1, 2, ..., or\\n            # up to k or the total number of coins in piles[i] whenever which one comes first.\\n            for l in range(min(k, len(piles[i]))):\\n                cur_total += piles[i][l]\\n\\n                # once I pick l+1 coins in i-th pile, then solve the subproblem\\n                # for (i+1)th and onward piles, with k-l-1 room left to fill.\\n                res = max(res, cur_total + solve(i+1, k-l-1))\\n\\n            return res\\n\\n        return solve(0,k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        Intuition 1: for pile i, I can pick l = 0, 1, ..., min(k, len(pile[i])) coins from pile i;\\n        Intuition 2: when I pick l coins on pile i, from i+1 to N-1 piles, I then can k-l coins.\\n        Subproblem: Find the maximum total value if we pick from i-th pile and up for a total of k coins.\\n        \"\"\"\\n        @cache\\n        def solve(i: int, k: int) -> int:\\n            # end of piles or no more room for any coin\\n            if i == len(piles) or k == 0:\\n                return 0\\n\\n            # don\\'t pick this pile\\n            res = solve(i+1, k)\\n            cur_total = 0\\n\\n            # If we pick this pile, try all possible number of coins that we can pick, e.g. 1, 2, ..., or\\n            # up to k or the total number of coins in piles[i] whenever which one comes first.\\n            for l in range(min(k, len(piles[i]))):\\n                cur_total += piles[i][l]\\n\\n                # once I pick l+1 coins in i-th pile, then solve the subproblem\\n                # for (i+1)th and onward piles, with k-l-1 room left to fill.\\n                res = max(res, cur_total + solve(i+1, k-l-1))\\n\\n            return res\\n\\n        return solve(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419084,
                "title": "c-memoization-tabulation",
                "content": "# Memoization Code\\n```\\nclass Solution {\\npublic:\\nint dp[1001][2001];\\nint solve(vector<vector<int>> &piles, int idx, int k)\\n{\\n    if (k == 0)\\n        return 0;\\n    if (idx >= piles.size())\\n        return 0;\\n    if (dp[idx][k] != -1)\\n        return dp[idx][k];\\n\\n    int ans = INT_MIN;\\n    int s = 0;\\n    int res = solve(piles, idx + 1, k);// if not choosing idxth pile\\n    for (int j = 0; j < piles[idx].size() && j<=k-1; j++)\\n    {\\n       s = s + piles[idx][j];\\n       ans = max({ans, s + solve(piles, idx + 1, k - (j + 1)), res});\\n    }\\n    if (ans < 0) return dp[idx][k] = 0;\\n    return dp[idx][k] = ans;\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    return solve(piles, 0, k);\\n}\\n};\\n```\\n# Tabulation Code\\n```\\nclass Solution {\\npublic:\\nint solve_tab(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n\\n    // last row and first column initialized with 0\\n    // for idx use r and for k use c\\n    for (int r = n - 1; r >= 0; r--)\\n    {\\n        for (int c = 1; c <= k; c++)\\n        {\\n            int ans = INT_MIN;\\n            int s = 0;\\n            int res = dp[r+1][c];// if not choosing rth pile\\n            for(int j=0; j<piles[r].size() && j<=c-1; j++)\\n            {\\n                s = s+piles[r][j];\\n                ans = max({ ans, s+dp[r+1][c-(j+1)] , res });\\n            }\\n            if(ans<0) dp[r][c] = 0;\\n            else dp[r][c] = ans;\\n        }\\n    }\\n    return dp[0][k];\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    return solve_tab(piles, k);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[1001][2001];\\nint solve(vector<vector<int>> &piles, int idx, int k)\\n{\\n    if (k == 0)\\n        return 0;\\n    if (idx >= piles.size())\\n        return 0;\\n    if (dp[idx][k] != -1)\\n        return dp[idx][k];\\n\\n    int ans = INT_MIN;\\n    int s = 0;\\n    int res = solve(piles, idx + 1, k);// if not choosing idxth pile\\n    for (int j = 0; j < piles[idx].size() && j<=k-1; j++)\\n    {\\n       s = s + piles[idx][j];\\n       ans = max({ans, s + solve(piles, idx + 1, k - (j + 1)), res});\\n    }\\n    if (ans < 0) return dp[idx][k] = 0;\\n    return dp[idx][k] = ans;\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    return solve(piles, 0, k);\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint solve_tab(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n\\n    // last row and first column initialized with 0\\n    // for idx use r and for k use c\\n    for (int r = n - 1; r >= 0; r--)\\n    {\\n        for (int c = 1; c <= k; c++)\\n        {\\n            int ans = INT_MIN;\\n            int s = 0;\\n            int res = dp[r+1][c];// if not choosing rth pile\\n            for(int j=0; j<piles[r].size() && j<=c-1; j++)\\n            {\\n                s = s+piles[r][j];\\n                ans = max({ ans, s+dp[r+1][c-(j+1)] , res });\\n            }\\n            if(ans<0) dp[r][c] = 0;\\n            else dp[r][c] = ans;\\n        }\\n    }\\n    return dp[0][k];\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    return solve_tab(piles, k);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419067,
                "title": "maximum-value-of-k-coins-from-piles-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n               int n = piles.Count;\\n        int[][] dp = new int[n + 1][];\\n        for (int i = 0; i < dp.Length; i++) {\\n            dp[i] = new int[k + 1];\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int coins = 0; coins <= k; coins++) {\\n                int current_sum = 0;\\n                for (int current_coins = 0; current_coins <= Math.Min(piles[i - 1].Count, coins); current_coins++) {\\n                    if (current_coins > 0) {\\n                        current_sum += piles[i - 1][current_coins - 1];\\n                    }\\n                    dp[i][coins] = Math.Max(dp[i][coins], dp[i - 1][coins - current_coins] + current_sum);\\n                }\\n            }\\n        }\\n        return dp[n][k]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n               int n = piles.Count;\\n        int[][] dp = new int[n + 1][];\\n        for (int i = 0; i < dp.Length; i++) {\\n            dp[i] = new int[k + 1];\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int coins = 0; coins <= k; coins++) {\\n                int current_sum = 0;\\n                for (int current_coins = 0; current_coins <= Math.Min(piles[i - 1].Count, coins); current_coins++) {\\n                    if (current_coins > 0) {\\n                        current_sum += piles[i - 1][current_coins - 1];\\n                    }\\n                    dp[i][coins] = Math.Max(dp[i][coins], dp[i - 1][coins - current_coins] + current_sum);\\n                }\\n            }\\n        }\\n        return dp[n][k]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419036,
                "title": "ruby-recursion-memoization",
                "content": "# Intuition\\nTry (1..k) from the first pile and calculate max for the rest with new k = k - tried, and so on\\n\\n# Approach\\nReworked translation to Ruby of [aryan_0077 C++ solution](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solutions/3417959/image-explanation-top-down-dp-easy-concise-c-java-python/) (same idea, technical details taken from his solution)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*k)$$\\n\\n- Space complexity:\\n$$O(n*k)$$\\n\\n# Code\\n```ruby\\n# Reworked translation to Ruby of aryan_0077 C++ solution\\n\\nclass Solver\\n    attr_reader :piles, :k, :dp\\n\\n    def initialize(piles, k)\\n        @piles, @k = piles, k\\n        @dp = Array.new(piles.size + 1) {|i| Array.new(k + 1) }\\n    end\\n\\n    def solve(i = 0, kk = k)\\n        cur = 0 # If cur is included in inject() param below then TLE\\n        @dp[i][kk] ||= (i >= piles.size || !kk.positive?) ? \\n            0 :\\n            [piles[i].size, kk].min.times.inject(solve(i + 1, kk)) {|res, j|\\n                cur += piles[i][j]\\n                [res, cur + solve(i + 1, kk - j - 1)].max\\n            }\\n    end\\nend\\n\\ndef max_value_of_coins(piles, k)\\n    Solver.new(piles, k).solve\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```ruby\\n# Reworked translation to Ruby of aryan_0077 C++ solution\\n\\nclass Solver\\n    attr_reader :piles, :k, :dp\\n\\n    def initialize(piles, k)\\n        @piles, @k = piles, k\\n        @dp = Array.new(piles.size + 1) {|i| Array.new(k + 1) }\\n    end\\n\\n    def solve(i = 0, kk = k)\\n        cur = 0 # If cur is included in inject() param below then TLE\\n        @dp[i][kk] ||= (i >= piles.size || !kk.positive?) ? \\n            0 :\\n            [piles[i].size, kk].min.times.inject(solve(i + 1, kk)) {|res, j|\\n                cur += piles[i][j]\\n                [res, cur + solve(i + 1, kk - j - 1)].max\\n            }\\n    end\\nend\\n\\ndef max_value_of_coins(piles, k)\\n    Solver.new(piles, k).solve\\nend\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418932,
                "title": "prefix-sum-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int k, int n, vector<vector<int>> &piles, vector<vector<int>> &dp) {\\n        if(!k || i == n) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        int ans = 0;\\n        for(int j=0; j<min((int)piles[i].size(), k); j++) {\\n            int notpick = dfs(i + 1, k, n, piles, dp), pick = 0;\\n            if(k - j - 1 >= 0) pick = piles[i][j] + dfs(i + 1, k - j - 1, n, piles, dp);\\n            ans = max({ans, pick, notpick});\\n        }\\n        return dp[i][k] = ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        for(auto &p : piles) {\\n            for(int i=1; i<p.size(); i++) p[i] += p[i - 1];\\n        }\\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        return dfs(0, k, n, piles, dp);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int k, int n, vector<vector<int>> &piles, vector<vector<int>> &dp) {\\n        if(!k || i == n) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        int ans = 0;\\n        for(int j=0; j<min((int)piles[i].size(), k); j++) {\\n            int notpick = dfs(i + 1, k, n, piles, dp), pick = 0;\\n            if(k - j - 1 >= 0) pick = piles[i][j] + dfs(i + 1, k - j - 1, n, piles, dp);\\n            ans = max({ans, pick, notpick});\\n        }\\n        return dp[i][k] = ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        for(auto &p : piles) {\\n            for(int i=1; i<p.size(); i++) p[i] += p[i - 1];\\n        }\\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        return dfs(0, k, n, piles, dp);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418709,
                "title": "very-easy-to-understand-c-recursion-memoization",
                "content": "# APPROACH :\\n\\nSo we have n number of piles where each pile contains m={m1,m2,m3...}\\nno of coins.\\n\\nSo from each pile we can take atmost \\'m\\' no of coins. So from 1st pile we can take \\'0\\' coins upto \\'m1\\' coins from this pile.\\n\\nSimilarly we can apply this logic to all piles.\\n\\nwhen (k-total coins selected)==0 then it is valid to return ;\\n\\nnow we need to max of all the valid solutions.\\n# Recursion\\n```\\nint solve(int i,vector<vector<int>>& piles,int k )\\n    {\\n        if(k==0)\\n        return 0;\\n        if(i>=piles.size())\\n        return 0;\\n         \\n        int maxi=0;\\n        int sum=0;\\n        for(int j=0;j<=k && j<=piles[i].size() ;j++)\\n        {\\n            if(j!=0)\\n            sum+=piles[i][j-1];\\n            maxi=max(maxi,sum+solve(i+1,piles,k-j ));\\n        } \\n        return  maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        \\n        return solve(0,piles,k);    \\n    }\\n```\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i,vector<vector<int>>& piles,int k,vector<vector<int>>&dp)\\n    {\\n        \\n\\n        if(k==0)\\n        return 0;\\n\\n        if(i>=piles.size())\\n        return 0;\\n\\n        if(dp[i][k]!=-1)\\n        return dp[i][k];\\n\\n        int maxi=0;\\n        int sum=0;\\n        for(int j=0;j<=k && j<=piles[i].size() ;j++)\\n        {\\n            if(j!=0)\\n            sum+=piles[i][j-1];\\n            maxi=max(maxi,sum+solve(i+1,piles,k-j,dp));\\n        }\\n         \\n        return dp[i][k]=maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(0,piles,k,dp);\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint solve(int i,vector<vector<int>>& piles,int k )\\n    {\\n        if(k==0)\\n        return 0;\\n        if(i>=piles.size())\\n        return 0;\\n         \\n        int maxi=0;\\n        int sum=0;\\n        for(int j=0;j<=k && j<=piles[i].size() ;j++)\\n        {\\n            if(j!=0)\\n            sum+=piles[i][j-1];\\n            maxi=max(maxi,sum+solve(i+1,piles,k-j ));\\n        } \\n        return  maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        \\n        return solve(0,piles,k);    \\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i,vector<vector<int>>& piles,int k,vector<vector<int>>&dp)\\n    {\\n        \\n\\n        if(k==0)\\n        return 0;\\n\\n        if(i>=piles.size())\\n        return 0;\\n\\n        if(dp[i][k]!=-1)\\n        return dp[i][k];\\n\\n        int maxi=0;\\n        int sum=0;\\n        for(int j=0;j<=k && j<=piles[i].size() ;j++)\\n        {\\n            if(j!=0)\\n            sum+=piles[i][j-1];\\n            maxi=max(maxi,sum+solve(i+1,piles,k-j,dp));\\n        }\\n         \\n        return dp[i][k]=maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(0,piles,k,dp);\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418651,
                "title": "java-prefix-sum-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        for (int i = 0; i < piles.size(); i++) {\\n            for (int j = 1; j < piles.get(i).size(); j++) {\\n                piles.get(i).set(j, piles.get(i).get(j) + piles.get(i).get(j-1));\\n            }\\n        }\\n\\n    int n = piles.size();\\n    int[][] dp = new int[n+1][k+1];\\n\\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= k; j++) {\\n            dp[i][j] = -1;\\n        }\\n    }\\n\\n    return solve(piles, k, 0, dp);\\n    }\\n\\n    public int solve (List<List<Integer>> p,int k,int i, int[][]dp){\\n         if (i == p.size())\\n            return 0;\\n\\n        if (dp[i][k] != -1)\\n            return dp[i][k];\\n\\n        int max = 0;\\n        max = Math.max(max, solve(p, k, i+1, dp));\\n\\n        for (int j = 0; j < p.get(i).size(); j++) {\\n            if (j+1 <= k) {\\n                max = Math.max(max, p.get(i).get(j) + solve(p, k-j-1, i+1, dp));\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return dp[i][k] = max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        for (int i = 0; i < piles.size(); i++) {\\n            for (int j = 1; j < piles.get(i).size(); j++) {\\n                piles.get(i).set(j, piles.get(i).get(j) + piles.get(i).get(j-1));\\n            }\\n        }\\n\\n    int n = piles.size();\\n    int[][] dp = new int[n+1][k+1];\\n\\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= k; j++) {\\n            dp[i][j] = -1;\\n        }\\n    }\\n\\n    return solve(piles, k, 0, dp);\\n    }\\n\\n    public int solve (List<List<Integer>> p,int k,int i, int[][]dp){\\n         if (i == p.size())\\n            return 0;\\n\\n        if (dp[i][k] != -1)\\n            return dp[i][k];\\n\\n        int max = 0;\\n        max = Math.max(max, solve(p, k, i+1, dp));\\n\\n        for (int j = 0; j < p.get(i).size(); j++) {\\n            if (j+1 <= k) {\\n                max = Math.max(max, p.get(i).get(j) + solve(p, k-j-1, i+1, dp));\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return dp[i][k] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418646,
                "title": "from-tle-to-optimes-dp-c-recursion-memoization",
                "content": "# Intuition\\nwe have to take k element from top so we have two options at every element either to take or not. SO we can apply here pick or notPick concept of dp\\n\\nIn basic method if we take 3 varibles i,j,k where i and j is for piles[i][j] then we have to apply 3-D dp which leads to TLE. \\n\\nTo optimise this we can run a loop in j and take only those elements where k>0. it will reduce a lot of operations.\\n\\n# Approach\\nFor TLE CODE:\\n```\\nmap<vector<int>,int>mp;\\n    int f(int i, int j, int k, vector<vector<int>> &piles){\\n        if(i>=piles.size() || j>=piles[i].size() || k<=0) return 0;\\n\\n        if(mp.find({i,j,k})!=mp.end()){\\n            return mp[{i,j,k}];\\n        }\\n\\n        int f1=piles[i][j]+f(i,j+1,k-1,piles);\\n        int f2=piles[i][j]+f(i+1,0,k-1,piles);\\n        int f3=f(i+1,0,k,piles);\\n\\n        return mp[{i,j,k}]=max({f1,f2,f3});\\n    }\\n```\\n\\nOPTIMISE APPROACH:\\n```\\nint f(int i,int k,vector<vector<int>> &v,vector<vector<int>> &dp){\\n        if(i>=n || k<=0) return 0;\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int notTake=f(i+1,k,v,dp);\\n        int Take=0;\\n        for(int j=0;j<v[i].size();++j){\\n            Take+=v[i][j];\\n            if(k-j-1>=0){\\n                notTake=max(notTake,Take+f(i+1,k-j-1,v,dp));\\n            }\\n        }\\n\\n        return dp[i][k]=notTake;\\n    }\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n^3) & O(n*k)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int f(int i,int k,vector<vector<int>> &v,vector<vector<int>> &dp){\\n        if(i>=n || k<=0) return 0;\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int notTake=f(i+1,k,v,dp);\\n        int Take=0;\\n        for(int j=0;j<v[i].size();++j){\\n            Take+=v[i][j];\\n            if(k-j-1>=0){\\n                notTake=max(notTake,Take+f(i+1,k-j-1,v,dp));\\n            }\\n        }\\n\\n        return dp[i][k]=notTake;\\n    }\\n\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return f(0,k,piles,dp);\\n    }\\n};\\n```\\nPLEASEEE UPVOTEE IF IT HELPED",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nmap<vector<int>,int>mp;\\n    int f(int i, int j, int k, vector<vector<int>> &piles){\\n        if(i>=piles.size() || j>=piles[i].size() || k<=0) return 0;\\n\\n        if(mp.find({i,j,k})!=mp.end()){\\n            return mp[{i,j,k}];\\n        }\\n\\n        int f1=piles[i][j]+f(i,j+1,k-1,piles);\\n        int f2=piles[i][j]+f(i+1,0,k-1,piles);\\n        int f3=f(i+1,0,k,piles);\\n\\n        return mp[{i,j,k}]=max({f1,f2,f3});\\n    }\\n```\n```\\nint f(int i,int k,vector<vector<int>> &v,vector<vector<int>> &dp){\\n        if(i>=n || k<=0) return 0;\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int notTake=f(i+1,k,v,dp);\\n        int Take=0;\\n        for(int j=0;j<v[i].size();++j){\\n            Take+=v[i][j];\\n            if(k-j-1>=0){\\n                notTake=max(notTake,Take+f(i+1,k-j-1,v,dp));\\n            }\\n        }\\n\\n        return dp[i][k]=notTake;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int f(int i,int k,vector<vector<int>> &v,vector<vector<int>> &dp){\\n        if(i>=n || k<=0) return 0;\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int notTake=f(i+1,k,v,dp);\\n        int Take=0;\\n        for(int j=0;j<v[i].size();++j){\\n            Take+=v[i][j];\\n            if(k-j-1>=0){\\n                notTake=max(notTake,Take+f(i+1,k-j-1,v,dp));\\n            }\\n        }\\n\\n        return dp[i][k]=notTake;\\n    }\\n\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return f(0,k,piles,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418569,
                "title": "easy-solution-recursive-dp-using-memoization-prefix-sum",
                "content": "# Intuition\\nFor each pile i, what will be the total value of coins we can collect if we choose the first j coins? Gives Hint for PrefixSum.\\nThan problem is reduced to Coin Change II Dp pattern.\\n\\n# Approach\\nFirst take PrefixSum of all piles in same pile from top to bottom\\nsuch that pile[i][j] defines first j coins in ith pile.\\n\\nSecond Define State of DP:\\nDP[k][n]=optimal sum of k coins from first n piles\\n\\nThird form a recurrance relation(same way as in coin change II):\\nset mAx = 0\\nif(we include nth pile) then\\n    loop: take max of all by considering first k coins of nth pile \\nthen if take max without including nth pile\\n\\n# Complexity\\n- Time complexity:\\nPrefixSum = O(n*k)\\nDP with Memoization = O(n*k)*O(k) i.e. (No. of Call * work in each Calls) but overall will be only O(n*k) as very rarely in each call it will take O(k).\\n\\ntotal TC = O(n*k) + O(n*k) = O(n*k)\\n\\n- Space complexity:\\nFor memoization matrix: O(n*k);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getMax(vector<vector<int>> &memo,vector<vector<int>> &pil,int k,int n){\\n        if(memo[k][n]==-1){\\n            if(k==0 || n==0) return 0;\\n            for(int i=0;i<pil[n-1].size();i++){\\n                if(i<k){\\n                    memo[k][n]=max(memo[k][n],pil[n-1][i]+getMax(memo,pil,k-(i+1),n-1));\\n                }\\n                else break;\\n            }\\n            memo[k][n]=max(memo[k][n],getMax(memo,pil,k,n-1));  \\n        }\\n        return memo[k][n];\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& pil, int k) {\\n        for(int i=0;i<pil.size();i++){\\n            for(int j=1;j<pil[i].size();j++){\\n                pil[i][j]+=pil[i][j-1];\\n            }\\n        }\\n        vector<vector<int>> memo(k+1,vector<int>(pil.size()+1,-1));\\n        return getMax(memo,pil,k,pil.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getMax(vector<vector<int>> &memo,vector<vector<int>> &pil,int k,int n){\\n        if(memo[k][n]==-1){\\n            if(k==0 || n==0) return 0;\\n            for(int i=0;i<pil[n-1].size();i++){\\n                if(i<k){\\n                    memo[k][n]=max(memo[k][n],pil[n-1][i]+getMax(memo,pil,k-(i+1),n-1));\\n                }\\n                else break;\\n            }\\n            memo[k][n]=max(memo[k][n],getMax(memo,pil,k,n-1));  \\n        }\\n        return memo[k][n];\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& pil, int k) {\\n        for(int i=0;i<pil.size();i++){\\n            for(int j=1;j<pil[i].size();j++){\\n                pil[i][j]+=pil[i][j-1];\\n            }\\n        }\\n        vector<vector<int>> memo(k+1,vector<int>(pil.size()+1,-1));\\n        return getMax(memo,pil,k,pil.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418550,
                "title": "c-dp-memoization-recursion-95-fastest-solution-easily-understandable-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at the problem, it is very obvious that it is an extension of Knapsack problem. The similarity is that here we can from each pile choose at most min(k, size of the current pile) and at least no coins.\\nWe move through all the piles one by one collecting zero or more coins from each of them. At the end when we pass the last index and reach the nth position, we make sure that we have taken exactly k coins.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple considering that you have solved 0/1 Knapsack problem.\\n1. We maintain an index i for the current pile.\\n2. Value K is maintained for the number of coins that are yet to be used.\\n3. In each pile we traverse j from 0 to pile[i].size() in order to add the current coin to currVal which is initialized zero.\\n4. When j == 0, we do not add anything as we can also choose to leave the complete pile and in all the other cases we add the piles[i][j - 1] to the currVal and then make a call for the next pile (i + 1);\\n5. At the end when we reach the nth index, we check that we have k == 0 and return 0 otherwise we return -1e9;\\n6. From each recursive call we return maxVal which is initialized to be -1e9 and is maximised with every recusrive call.\\n\\n# Recusrive Solution (TLE)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& piles, int n, int i, int k) {\\n        if (i == n) {\\n            if (!k) return 0;\\n            return -1e9;\\n        }\\n        int maxVal = -1e9, currVal = 0;\\n        for (int j = 0; j <= piles[i].size(); j++){\\n            if (j == 0) maxVal = max(maxVal, f(piles, n, i + 1, k));\\n            else if (k - j >= 0){\\n                currVal += piles[i][j - 1];\\n                maxVal = max(maxVal, currVal + f(piles, n, i + 1, \\n                k - j));\\n            }\\n        }\\n        return maxVal;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        return f(piles, n, 0, k);\\n    }\\n};\\n```\\n\\n# Memoization Solution\\n\\n# Complexity\\n**Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k * maximum pile size)$$\\n\\n**Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k) + Auxiliiary Stack Space$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& piles, int n, int i, int k, \\n    vector<vector<int>>& dp) {\\n        if (i == n) {\\n            if (!k) return 0;\\n            return -1e9;\\n        }\\n        if (dp[i][k] != -1) return dp[i][k];\\n        int maxVal = -1e9, currVal = 0;\\n        for (int j = 0; j <= piles[i].size(); j++){\\n            if (j == 0) maxVal = max(maxVal, f(piles, n, i + 1, k, dp));\\n            else if (k - j >= 0){\\n                currVal += piles[i][j - 1];\\n                maxVal = max(maxVal, currVal + f(piles, n, i + 1, \\n                k - j, dp));\\n            }\\n        }\\n        return dp[i][k] = maxVal;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k + 1, - 1));\\n        return f(piles, n, 0, k, dp);\\n    }\\n};\\n```\\n\\n# Dynamic Programming Solution\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k * maximum pile size)$$\\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1e9));\\n        dp[n][0] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int K = 0; K <= k; K++) {\\n                int maxVal = -1e9, currVal = 0;\\n                for (int j = 0; j <= piles[i].size(); j++){\\n                    if (j == 0) \\n                        maxVal = max(maxVal, dp[i + 1][K]);\\n                    else if (K - j >= 0){\\n                        currVal += piles[i][j - 1];\\n                        maxVal = max(maxVal, currVal + dp[i + 1][K - j]);\\n                    }\\n                }\\n                dp[i][K] = maxVal;\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\\n\\n# Space Optimized Dynamic Programming Solution\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k * maximum pile size)$$\\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<int> prev(k + 1, -1e9), curr(k + 1, -1e9);\\n        prev[0] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int K = 0; K <= k; K++) {\\n                int maxVal = -1e9, currVal = 0;\\n                for (int j = 0; j <= piles[i].size(); j++){\\n                    if (j == 0) \\n                        maxVal = max(maxVal, prev[K]);\\n                    else if (K - j >= 0){\\n                        currVal += piles[i][j - 1];\\n                        maxVal = max(maxVal, currVal + prev[K - j]);\\n                    }\\n                }\\n                curr[K] = maxVal;\\n            }\\n            prev = curr;\\n        }\\n        return prev[k];\\n    }\\n};\\n```\\n\\n## Kindly like / upvote if you like my solution :-)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& piles, int n, int i, int k) {\\n        if (i == n) {\\n            if (!k) return 0;\\n            return -1e9;\\n        }\\n        int maxVal = -1e9, currVal = 0;\\n        for (int j = 0; j <= piles[i].size(); j++){\\n            if (j == 0) maxVal = max(maxVal, f(piles, n, i + 1, k));\\n            else if (k - j >= 0){\\n                currVal += piles[i][j - 1];\\n                maxVal = max(maxVal, currVal + f(piles, n, i + 1, \\n                k - j));\\n            }\\n        }\\n        return maxVal;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        return f(piles, n, 0, k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& piles, int n, int i, int k, \\n    vector<vector<int>>& dp) {\\n        if (i == n) {\\n            if (!k) return 0;\\n            return -1e9;\\n        }\\n        if (dp[i][k] != -1) return dp[i][k];\\n        int maxVal = -1e9, currVal = 0;\\n        for (int j = 0; j <= piles[i].size(); j++){\\n            if (j == 0) maxVal = max(maxVal, f(piles, n, i + 1, k, dp));\\n            else if (k - j >= 0){\\n                currVal += piles[i][j - 1];\\n                maxVal = max(maxVal, currVal + f(piles, n, i + 1, \\n                k - j, dp));\\n            }\\n        }\\n        return dp[i][k] = maxVal;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k + 1, - 1));\\n        return f(piles, n, 0, k, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1e9));\\n        dp[n][0] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int K = 0; K <= k; K++) {\\n                int maxVal = -1e9, currVal = 0;\\n                for (int j = 0; j <= piles[i].size(); j++){\\n                    if (j == 0) \\n                        maxVal = max(maxVal, dp[i + 1][K]);\\n                    else if (K - j >= 0){\\n                        currVal += piles[i][j - 1];\\n                        maxVal = max(maxVal, currVal + dp[i + 1][K - j]);\\n                    }\\n                }\\n                dp[i][K] = maxVal;\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<int> prev(k + 1, -1e9), curr(k + 1, -1e9);\\n        prev[0] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int K = 0; K <= k; K++) {\\n                int maxVal = -1e9, currVal = 0;\\n                for (int j = 0; j <= piles[i].size(); j++){\\n                    if (j == 0) \\n                        maxVal = max(maxVal, prev[K]);\\n                    else if (K - j >= 0){\\n                        currVal += piles[i][j - 1];\\n                        maxVal = max(maxVal, currVal + prev[K - j]);\\n                    }\\n                }\\n                curr[K] = maxVal;\\n            }\\n            prev = curr;\\n        }\\n        return prev[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418512,
                "title": "best-solution-c-knapsack-algorithm-applying-prefix-sum-easy-to-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find the maximum total value of coins we can have in our wallet if we choose at most k coins from all the piles.\\n\\nWe can choose at most one coin from each pile, and we can choose any number of coins from each pile as long as the total number of coins chosen is at most k.\\n\\nWe can solve this problem using dynamic programming.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array mv of size k+1 , where mv[i] represents the maximum total value of coins we can have in our wallet if we choose at most i coins from all the piles considered so far.\\n2. Initialize an array pileSum of size k+1 , where pileSum[i] represents the sum of coins taken from the current pile for i coins. For each pile in piles , do the following:\\n\\n---\\n\\ni) Calculate the number of coins in the pile to consider, which is the minimum of k and the length of the pile.\\n\\nii) Calculate the sum of coins taken from the pile for each possible number of coins (from 1 to the minimum of the number of coins in the pile and k ), and store it in the pileSum array.\\n\\niii) Iterate over each possible number of coins (from k to 1), and for each number of coins, do the following: Initialize a variable maxVal to 0.\\n\\niv) Iterate over each possible number of coins taken from the current pile (from the minimum of the number of coins in the pile and the current number of coins to 0), and for each number of coins taken, do the following:\\n\\n---\\n\\na) Update maxVal to be the maximum of its current value and the sum of coins taken from the current pile and the maximum total value of coins we can have in our wallet if we choose the remaining coins from the previous piles.\\n\\nb) Update mv[i] to be maxVal . Return mv[k] , which represents the maximum total value of coins we can have in our wallet if we choose at most k coins from all the piles.\\n# Complexity\\n- Time complexity: O(k*s), where s is the total number of coins in all piles.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k), due to the use of the mv and pileSum arrays.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<int> v(k+1, 0), pileSum(k+1, 0);\\n        for(auto &pile : piles) {\\n            int n = min(k, (int)pile.size());\\n            for(int i = 1; i <= n; i++) pileSum[i] = pileSum[i-1] + pile[i-1];\\n            for(int i = k; i > 0; i--) {\\n                int large = 0;\\n                for(int j = min(i, n); j >= 0; j--) large = max(large, pileSum[j] + v[i-j]);\\n                v[i] = large;\\n            }\\n        }\\n        return v[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<int> v(k+1, 0), pileSum(k+1, 0);\\n        for(auto &pile : piles) {\\n            int n = min(k, (int)pile.size());\\n            for(int i = 1; i <= n; i++) pileSum[i] = pileSum[i-1] + pile[i-1];\\n            for(int i = k; i > 0; i--) {\\n                int large = 0;\\n                for(int j = min(i, n); j >= 0; j--) large = max(large, pileSum[j] + v[i-j]);\\n                v[i] = large;\\n            }\\n        }\\n        return v[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418497,
                "title": "java-solution-with-comments-memoization",
                "content": "# Complexity\\n- Time complexity:\\n`f(x,y) = f(x, y-1) +  f(x-1, y-1)`\\nassume x and y to be equal\\n`T(n) = 2T(n-1) + C`\\n$$O(2^n)$$    where $$n = max(i, k)$$\\n\\n- Space complexity: $$O(logn)$$ height of recursive tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[][] dp;\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int N = piles.size();\\n        \\n        dp = new Integer[N+1][k+1];\\n\\n        return getScore(piles, N-1, k);        \\n    }\\n\\n    /**\\n    * Calculates maximum total value that can be obtained using given no. of choices\\n    *\\n    * @param piles  - List of piles, piles.get(i) represents a single pile\\n    * @param i      - Index of pile under consideration\\n    * @param k      - Maximum no. of elements that can be choosen from all the piles\\n    * @return       - Max. value that can be achieved by making k choices from piles 0 to i\\n    */\\n    int getScore(List<List<Integer>> piles, int i, int k) {\\n        if (i < 0 || k < 0)\\n            return 0;\\n        \\n        if (dp[i][k] != null)\\n            return dp[i][k];\\n\\n        // At max, we can process k elements from current pile\\n        int N = Math.min(k, piles.get(i).size());\\n\\n        // When no item from current pile is choosen and we move to the next pile\\n        int exclude = getScore(piles, i-1, k);\\n\\n        // when 1 or more items from current pile is choosen\\n        int include = 0, sum = 0;\\n        for (int j = 0; j < N; j++) {\\n            // when j+1 elements are included from current pile\\n            // and we move to the next pile\\n            sum += piles.get(i).get(j);\\n            include = Math.max(include, sum + getScore(piles, i-1, k-j-1));\\n        }\\n\\n        // return maximum possible value achieved after exploring all possibilities\\n        return dp[i][k] = Math.max(include, exclude);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][] dp;\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int N = piles.size();\\n        \\n        dp = new Integer[N+1][k+1];\\n\\n        return getScore(piles, N-1, k);        \\n    }\\n\\n    /**\\n    * Calculates maximum total value that can be obtained using given no. of choices\\n    *\\n    * @param piles  - List of piles, piles.get(i) represents a single pile\\n    * @param i      - Index of pile under consideration\\n    * @param k      - Maximum no. of elements that can be choosen from all the piles\\n    * @return       - Max. value that can be achieved by making k choices from piles 0 to i\\n    */\\n    int getScore(List<List<Integer>> piles, int i, int k) {\\n        if (i < 0 || k < 0)\\n            return 0;\\n        \\n        if (dp[i][k] != null)\\n            return dp[i][k];\\n\\n        // At max, we can process k elements from current pile\\n        int N = Math.min(k, piles.get(i).size());\\n\\n        // When no item from current pile is choosen and we move to the next pile\\n        int exclude = getScore(piles, i-1, k);\\n\\n        // when 1 or more items from current pile is choosen\\n        int include = 0, sum = 0;\\n        for (int j = 0; j < N; j++) {\\n            // when j+1 elements are included from current pile\\n            // and we move to the next pile\\n            sum += piles.get(i).get(j);\\n            include = Math.max(include, sum + getScore(piles, i-1, k-j-1));\\n        }\\n\\n        // return maximum possible value achieved after exploring all possibilities\\n        return dp[i][k] = Math.max(include, exclude);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418483,
                "title": "java-naive-recursion-brute-force-approach",
                "content": "```\\n// Approach 1: Naive Recursion - Brute Force Approach => LTE\\n\\n// Time complexity: O(2^s), where s is total no of coins.\\n// Space complexity: O(2^s)\\n\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        return dfs(piles, 0, k);\\n    }\\n    \\n    private int dfs(List<List<Integer>> piles, int i, int coins) {\\n       if (i == piles.size())\\n           return 0;\\n        \\n        int res = dfs(piles, i + 1, coins); // skip curr pile\\n        \\n        int currPile = 0; // get 1 to k coins from curr pile\\n        \\n        for (int j = 0; j < Math.min(piles.get(i).size(), coins); j++) {\\n            currPile += piles.get(i).get(j);\\n            res = Math.max(res, currPile + dfs(piles, i + 1, coins - j - 1));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Approach 1: Naive Recursion - Brute Force Approach => LTE\\n\\n// Time complexity: O(2^s), where s is total no of coins.\\n// Space complexity: O(2^s)\\n\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        return dfs(piles, 0, k);\\n    }\\n    \\n    private int dfs(List<List<Integer>> piles, int i, int coins) {\\n       if (i == piles.size())\\n           return 0;\\n        \\n        int res = dfs(piles, i + 1, coins); // skip curr pile\\n        \\n        int currPile = 0; // get 1 to k coins from curr pile\\n        \\n        for (int j = 0; j < Math.min(piles.get(i).size(), coins); j++) {\\n            currPile += piles.get(i).get(j);\\n            res = Math.max(res, currPile + dfs(piles, i + 1, coins - j - 1));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418481,
                "title": "easiest-c-memoaization-dp-solution-beats-80-striver-s-knapsack-approach-well-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple knapsack dp problem implementation, just traverse the piles vector one by one and then use pick/notpick approach and write recursive approches accordingly.\\n\\nGive the code a good read and you will be able to grasp the logic and intuition behind it.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n```\\nThanks to striver for teaching DP so well, couldn\\'t have had solved the problem without his videos !\\n```\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lol(int ind, int k, int n, vector<vector<int>> &piles, vector<vector<int>> &dp){\\n        //base case\\n        //if we reach the end of pile traversal\\n        //or if we reach the max limit of coins chosen\\n        if(ind==n or k==0) return 0;\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n\\n        int maxi=INT_MIN;\\n        //dont pick from that pile, move to next\\n        int notpick= lol(ind+1,k,n,piles,dp);\\n        //ctc is variable holding the number of coins \\n        //we have left to choose\\n        int pick=0, ctc=k, sum=0;\\n\\n        for(int i=0;i<piles[ind].size() and ctc>0;i++){\\n            ctc--;\\n            sum+=piles[ind][i];\\n            int r= sum + lol(ind+1,ctc,n,piles,dp);\\n            pick=max(pick,r);\\n        }\\n        return dp[ind][k]= max(pick,notpick);        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n= piles.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return lol(0,k,n,piles,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nThanks to striver for teaching DP so well, couldn\\'t have had solved the problem without his videos !\\n```\n```\\nclass Solution {\\npublic:\\n    int lol(int ind, int k, int n, vector<vector<int>> &piles, vector<vector<int>> &dp){\\n        //base case\\n        //if we reach the end of pile traversal\\n        //or if we reach the max limit of coins chosen\\n        if(ind==n or k==0) return 0;\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n\\n        int maxi=INT_MIN;\\n        //dont pick from that pile, move to next\\n        int notpick= lol(ind+1,k,n,piles,dp);\\n        //ctc is variable holding the number of coins \\n        //we have left to choose\\n        int pick=0, ctc=k, sum=0;\\n\\n        for(int i=0;i<piles[ind].size() and ctc>0;i++){\\n            ctc--;\\n            sum+=piles[ind][i];\\n            int r= sum + lol(ind+1,ctc,n,piles,dp);\\n            pick=max(pick,r);\\n        }\\n        return dp[ind][k]= max(pick,notpick);        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n= piles.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return lol(0,k,n,piles,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418394,
                "title": "python-3-top-down-dp",
                "content": "# Intuition\\nFrom the question, you need to exhaust the possibilities of:\\n1.picking certain number of coin from a pile\\n2.loop the remaining piles with k_remain\\n\\nThese are the 2 state variables.\\n\\nFrom eg.2, you know you can\\'t do greedy. Previous choice affect future choice. So DP is the only solution.\\n\\n# Approach\\ntop-down DP\\n\\n# Complexity\\n- Time complexity:\\nO(nk) -> need to do all state variables combination\\n\\n- Space complexity:\\nO(nk) -> cache size\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n\\n        import collections\\n        ind2sumdict = collections.defaultdict(collections.defaultdict) # ind: {coin token: sum}\\n\\n        for i in range(len(piles)):\\n            ind2sumdict[i][0] = 0\\n            end = min(k, len(piles[i]))\\n            total = 0\\n            for j in range(end):\\n                total += piles[i][j]\\n                ind2sumdict[i][j+1] = total\\n        \\n        @lru_cache(None)\\n        def dp(i, k_remain):\\n            if k_remain == 0 or i == len(piles): # can\\'t take / exceed piles len\\n                return 0\\n            end = min(len(ind2sumdict[i]) - 1, k_remain)\\n            ans = 0\\n            for take_coin in range(end+1):\\n                ans = max(ans, ind2sumdict[i][take_coin] + dp(i+1, k_remain - take_coin))\\n            return ans\\n\\n        return dp(0, k)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n\\n        import collections\\n        ind2sumdict = collections.defaultdict(collections.defaultdict) # ind: {coin token: sum}\\n\\n        for i in range(len(piles)):\\n            ind2sumdict[i][0] = 0\\n            end = min(k, len(piles[i]))\\n            total = 0\\n            for j in range(end):\\n                total += piles[i][j]\\n                ind2sumdict[i][j+1] = total\\n        \\n        @lru_cache(None)\\n        def dp(i, k_remain):\\n            if k_remain == 0 or i == len(piles): # can\\'t take / exceed piles len\\n                return 0\\n            end = min(len(ind2sumdict[i]) - 1, k_remain)\\n            ans = 0\\n            for take_coin in range(end+1):\\n                ans = max(ans, ind2sumdict[i][take_coin] + dp(i+1, k_remain - take_coin))\\n            return ans\\n\\n        return dp(0, k)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418104,
                "title": "swift-solution-with-detailed-explanations",
                "content": "# Approach\\n1. create a memo array, which is a 2D array of size (piles.length + 1) x (k + 1)\\n2. fill the memo array with -1\\n3. call a function dp, which returns the maximum value of coins, with the following arguments:\\n    - piles: the 2D array of piles, where each pile is an array of coins\\n    - memo: the memo array\\n    - i: the current index of the piles array\\n    - k: the number of piles that can be picked\\n4. the dp function does the following:\\n    - if k is 0 or i is the length of the piles array, return 0\\n    - if the value of the memo array at index i and k is not -1, return that value\\n    - set res to the result of calling dp with the following arguments:\\n        - piles\\n        - memo\\n        - i + 1\\n        - k\\n    - set cur to 0\\n    - loop through the coins in the current pile\\n        - add the current coin to cur\\n        - set res to the max of res and cur + the result of calling dp with the following arguments:\\n            - piles\\n            - memo\\n            - i + 1\\n            - k - j - 1\\n    - set the value of the memo array at index i and k to res\\n    - return res \\n\\n# Complexity\\n- Time complexity: O(n^2 * k)\\n- Space complexity: O(n * k)\\n\\n# Code\\n```\\nclass Solution {\\n    func maxValueOfCoins(_ piles: [[Int]], _ k: Int) -> Int {\\n        var memo = Array(repeating: Array(repeating: -1, count: k + 1), count: piles.count + 1)\\n        return dp(piles, &memo, 0, k)\\n    }\\n    func dp(_ piles: [[Int]], _ memo: inout [[Int]], _ i: Int, _ k: Int) -> Int {\\n        if k == 0 || i == piles.count { return 0 }\\n        if memo[i][k] != -1 { return memo[i][k] }\\n\\n        var res = dp(piles, &memo, i + 1, k)\\n        var cur = 0\\n\\n        for j in 0..<min(piles[i].count, k) {\\n            cur += piles[i][j]\\n            res = max(res, cur + dp(piles, &memo, i + 1, k - j - 1))\\n        }\\n        memo[i][k] = res\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxValueOfCoins(_ piles: [[Int]], _ k: Int) -> Int {\\n        var memo = Array(repeating: Array(repeating: -1, count: k + 1), count: piles.count + 1)\\n        return dp(piles, &memo, 0, k)\\n    }\\n    func dp(_ piles: [[Int]], _ memo: inout [[Int]], _ i: Int, _ k: Int) -> Int {\\n        if k == 0 || i == piles.count { return 0 }\\n        if memo[i][k] != -1 { return memo[i][k] }\\n\\n        var res = dp(piles, &memo, i + 1, k)\\n        var cur = 0\\n\\n        for j in 0..<min(piles[i].count, k) {\\n            cur += piles[i][j]\\n            res = max(res, cur + dp(piles, &memo, i + 1, k - j - 1))\\n        }\\n        memo[i][k] = res\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418077,
                "title": "c-dp-memo-faster-easy-to-understand",
                "content": "* ***Memo***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[1005][2005];\\n    \\n    int helper(vector<vector<int>>& piles, int i, int n, int k)\\n    {\\n        // base case\\n        \\n        if(i == n || k == 0)\\n            return 0;\\n        \\n        // if alreday claculated\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int max_sum = 0;\\n        \\n        // inclusion part\\n        \\n        for(int pos = 0; pos < piles[i].size(); pos++)\\n        {\\n            if(k - pos - 1 >= 0)\\n            {\\n                max_sum = max({max_sum, piles[i][pos] + helper(piles, i + 1, n, k - pos - 1), helper(piles, i + 1, n, k)});\\n            }\\n        }\\n        \\n        // exclusion part\\n        \\n         max_sum = max(max_sum, helper(piles, i + 1, n, k));\\n        \\n        // store the result and return it\\n        \\n        return dp[i][k] = max_sum;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        \\n        // calculate the prefix sum of each row\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < piles[i].size(); j++)\\n            {\\n                piles[i][j] += piles[i][j - 1];\\n            }\\n        }\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(piles, 0, n, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[1005][2005];\\n    \\n    int helper(vector<vector<int>>& piles, int i, int n, int k)\\n    {\\n        // base case\\n        \\n        if(i == n || k == 0)\\n            return 0;\\n        \\n        // if alreday claculated\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int max_sum = 0;\\n        \\n        // inclusion part\\n        \\n        for(int pos = 0; pos < piles[i].size(); pos++)\\n        {\\n            if(k - pos - 1 >= 0)\\n            {\\n                max_sum = max({max_sum, piles[i][pos] + helper(piles, i + 1, n, k - pos - 1), helper(piles, i + 1, n, k)});\\n            }\\n        }\\n        \\n        // exclusion part\\n        \\n         max_sum = max(max_sum, helper(piles, i + 1, n, k));\\n        \\n        // store the result and return it\\n        \\n        return dp[i][k] = max_sum;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        \\n        // calculate the prefix sum of each row\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < piles[i].size(); j++)\\n            {\\n                piles[i][j] += piles[i][j - 1];\\n            }\\n        }\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(piles, 0, n, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417955,
                "title": "kotlin-search",
                "content": "```\\nclass Solution {\\n  fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {\\n    val N = piles.size\\n    val memo = Array(N) { IntArray(k + 1) }\\n    fun dfs(idx: Int, K: Int): Int {\\n      if (K == 0) return 0\\n      if (idx == -1) return Int.MIN_VALUE\\n      if (memo[idx][K] == 0) {\\n        var res = dfs(idx - 1, K)\\n        var sum = 0\\n        for (i in 0 until minOf(K, piles[idx].size)) {\\n          sum += piles[idx][i]\\n          res = maxOf(res, sum + dfs(idx - 1, K - i - 1))\\n        }\\n        memo[idx][K] = res\\n      }\\n      return memo[idx][K]\\n    }\\n    return dfs(N - 1, k)\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {\\n    val N = piles.size\\n    val memo = Array(N) { IntArray(k + 1) }\\n    fun dfs(idx: Int, K: Int): Int {\\n      if (K == 0) return 0\\n      if (idx == -1) return Int.MIN_VALUE\\n      if (memo[idx][K] == 0) {\\n        var res = dfs(idx - 1, K)\\n        var sum = 0\\n        for (i in 0 until minOf(K, piles[idx].size)) {\\n          sum += piles[idx][i]\\n          res = maxOf(res, sum + dfs(idx - 1, K - i - 1))\\n        }\\n        memo[idx][K] = res\\n      }\\n      return memo[idx][K]\\n    }\\n    return dfs(N - 1, k)\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417944,
                "title": "bottom-up-dp-python",
                "content": "\\n\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\\n        for i in range(1, n + 1):\\n            for coins in range(0, k + 1):\\n                currSum = 0\\n                for currCoins in range(0, min(len(piles[i - 1]), coins) + 1):\\n                    if currCoins > 0:\\n                        currSum += piles[i - 1][currCoins - 1]\\n                    dp[i][coins] = max(dp[i][coins], dp[i - 1][coins - currCoins] + currSum)\\n        return dp[n][k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\\n        for i in range(1, n + 1):\\n            for coins in range(0, k + 1):\\n                currSum = 0\\n                for currCoins in range(0, min(len(piles[i - 1]), coins) + 1):\\n                    if currCoins > 0:\\n                        currSum += piles[i - 1][currCoins - 1]\\n                    dp[i][coins] = max(dp[i][coins], dp[i - 1][coins - currCoins] + currSum)\\n        return dp[n][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417895,
                "title": "maximum-value-of-k-coins-from-piles-java-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach used in my code solution is a recursive approach with memoization (top-down approach). The maxValueOfCoins() method recursively calculates the maximum value of coins that can be obtained by picking exactly k coins from the piles list, starting from the ith pile. The dp array is used for memoization to store the results of previously computed subproblems, so that we can avoid redundant calculations and optimize the time complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity of the solution: The time complexity of the solution depends on the number of piles (n) and the maximum value of k. In the worst case, we may need to explore all possible choices of picking coins from each pile. Therefore, the time complexity is O(n * k), where n is the number of piles.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity of the solution: The space complexity of the solution is also dependent on the number of piles (n) and the maximum value of k. We need to store the results of previously computed subproblems in the dp array, which requires O(n * k) space. Additionally, the recursion stack also requires space proportional to the maximum depth of recursion, which can be at most n. Therefore, the overall space complexity is O(n * k + n), which can be simplified to O(n * k).\\n# Code\\n```\\nclass Solution {\\n  public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n    // dp[i][k] := max value of picking k coins from piles[i:]\\n    Integer[][] dp = new Integer[piles.size()][k + 1];\\n    return maxValueOfCoins(piles, 0, k, dp);\\n  }\\n\\n  private int maxValueOfCoins(List<List<Integer>> piles, int i, int k, Integer[][] dp) {\\n    if (i == piles.size() || k == 0)\\n      return 0;\\n    if (dp[i][k] != null)\\n      return dp[i][k];\\n\\n    int ans = maxValueOfCoins(piles, i + 1, k, dp); // Pick 0 coins from current pile\\n    int val = 0;                                // Coins picked from current pile\\n\\n    // Try to pick 1, 2, ..., k coins from current pile\\n    for (int j = 0; j < Math.min(piles.get(i).size(), k); ++j) {\\n      val += piles.get(i).get(j);\\n      ans = Math.max(ans, val + maxValueOfCoins(piles, i + 1, k - j - 1, dp));\\n    }\\n\\n    return dp[i][k] = ans;\\n  }\\n}\\n\\n```\\nPlease upvote if you find it helpful",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n  public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n    // dp[i][k] := max value of picking k coins from piles[i:]\\n    Integer[][] dp = new Integer[piles.size()][k + 1];\\n    return maxValueOfCoins(piles, 0, k, dp);\\n  }\\n\\n  private int maxValueOfCoins(List<List<Integer>> piles, int i, int k, Integer[][] dp) {\\n    if (i == piles.size() || k == 0)\\n      return 0;\\n    if (dp[i][k] != null)\\n      return dp[i][k];\\n\\n    int ans = maxValueOfCoins(piles, i + 1, k, dp); // Pick 0 coins from current pile\\n    int val = 0;                                // Coins picked from current pile\\n\\n    // Try to pick 1, 2, ..., k coins from current pile\\n    for (int j = 0; j < Math.min(piles.get(i).size(), k); ++j) {\\n      val += piles.get(i).get(j);\\n      ans = Math.max(ans, val + maxValueOfCoins(piles, i + 1, k - j - 1, dp));\\n    }\\n\\n    return dp[i][k] = ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417883,
                "title": "easy-solution-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    Integer[][] cache;\\n    List<List<Integer>> piles;\\n    int m;\\n    \\n    private int res(int pos, int rem) {\\n        if (rem < 0) {\\n            return Integer.MIN_VALUE;\\n        }\\n        else if (pos == m || rem == 0) {\\n            return 0;\\n        }\\n        else if (cache[pos][rem] != null) {\\n            return cache[pos][rem];\\n        }\\n        else {\\n            List<Integer> pile = piles.get(pos);\\n            int n = pile.size();\\n            int max = res(pos+1, rem);\\n            for (int i = 0; i < n; i++) {\\n                max = Math.max(max, pile.get(i) + res(pos + 1, rem - i - 1));\\n            }\\n            cache[pos][rem] = max;\\n            return max;\\n        }\\n    }\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        this.m = piles.size();\\n        this.piles = piles;\\n        this.cache = new Integer[m][k+1];\\n\\t\\t\\n\\t\\t// caculate running sum for each pile.\\n        for (List<Integer> pile: piles) {\\n            int n = pile.size();\\n            for (int i = 1; i < n; i++) {\\n                pile.set(i, pile.get(i) + pile.get(i-1));\\n            }\\n        }\\n\\t\\t\\n\\t\\t// DP\\n        return res(0, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Integer[][] cache;\\n    List<List<Integer>> piles;\\n    int m;\\n    \\n    private int res(int pos, int rem) {\\n        if (rem < 0) {\\n            return Integer.MIN_VALUE;\\n        }\\n        else if (pos == m || rem == 0) {\\n            return 0;\\n        }\\n        else if (cache[pos][rem] != null) {\\n            return cache[pos][rem];\\n        }\\n        else {\\n            List<Integer> pile = piles.get(pos);\\n            int n = pile.size();\\n            int max = res(pos+1, rem);\\n            for (int i = 0; i < n; i++) {\\n                max = Math.max(max, pile.get(i) + res(pos + 1, rem - i - 1));\\n            }\\n            cache[pos][rem] = max;\\n            return max;\\n        }\\n    }\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        this.m = piles.size();\\n        this.piles = piles;\\n        this.cache = new Integer[m][k+1];\\n\\t\\t\\n\\t\\t// caculate running sum for each pile.\\n        for (List<Integer> pile: piles) {\\n            int n = pile.size();\\n            for (int i = 1; i < n; i++) {\\n                pile.set(i, pile.get(i) + pile.get(i-1));\\n            }\\n        }\\n\\t\\t\\n\\t\\t// DP\\n        return res(0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266599,
                "title": "python-solution-dp",
                "content": "# Intuition\\n$dp[i][j]$ is the maximal value after processing the $i$-th pile where the total number of coins is at most $j$. State transition is\\n$dp[i + 1][j] = \\\\max(s_i[q] + dp[i][j - q] : 0 \\\\le q \\\\le \\\\ell_{i + 1})$\\nwhere $\\\\ell_{i + 1} = len(piles[i + 1])$. \\n\\nHere, $s_i[q] := \\\\sum_{j = 0}^{q - 1} piles[i][j] = sum(piles[i][:q])$ be the prefix sum of the $i$-th pile.\\n\\nNote that either $dp[i]$ or $s_i$ can be exhausted in the maximum computation. We can ensure $j - q \\\\ge 0$ by $q \\\\le j$. Hence, $q \\\\le \\\\min(\\\\ell_{i + 1}, j)$. We can use $s_i[\\\\min(q, \\\\ell_{i + 1})]$ to ensure the boundary. It does not affect because the definition of $dp$ requires at most $j$ coins are selected. It is allowed that $i + 1$ contributes less.\\n\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        dp = [0] * (k + 1)\\n        for i in range(len(piles)):\\n            # prefix_sum[i] = sum(pile[:i])\\n            s = len(piles[i])\\n            prefix_sum = [0] * (s + 1)\\n            for j in range(s):\\n                prefix_sum[j + 1] = prefix_sum[j] + piles[i][j]\\n            for j in range(k, -1, -1):\\n                temp = 0\\n                for q in range(j + 1):\\n                    temp = max(temp, dp[j - q] + prefix_sum[min(q, s)])\\n                dp[j] = temp\\n        return dp[-1]\\n```\\n\\nThis implementation causes TLE when $k$ is large. The reason is there are many useless computations (giving zero) when $k$ is large. For example, $k = 100$ but the first two piles are of length $1$. Then, the last $99$ slots of $dp$ is not changed at all.\\n\\nTo save more time, we can keep only effectively changeable part of $dp$ in each computation.\\n\\nLet $L_i = len(dp[i]) = \\\\sum_{j = 0}^i \\\\ell_j + 1$.\\n\\n\\nThe index for $dp[i][j - q]$ imposes another condition for $q$. That is $0 \\\\le j - q \\\\le L_i - 1$ which is $j - L_i + 1 \\\\le q \\\\le j$. Then, the intersection of conditions gives\\n$\\\\max(0, j - L_i + 1) \\\\le q \\\\le \\\\min(\\\\ell_{i + 1}, j)$. This is the window of maximum computation.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        prev = [0]\\n        for i in range(len(piles)):\\n            s = len(piles[i])\\n            l = len(prev)\\n            # prefix_sum[i] = sum(pile[:i])\\n            prefix_sum = [0] * (s + 1)\\n            for j in range(s):\\n                prefix_sum[j + 1] = prefix_sum[j] + piles[i][j]\\n            max_size = s + l\\n            dp = [0] * min(k + 1, max_size)\\n            for j in range(len(dp) - 1, -1, -1):\\n                temp = 0\\n                for q in range(max(0, j - l + 1), min(s ,j) + 1):\\n                    temp = max(temp, prev[j - q] + prefix_sum[q])\\n                dp[j] = temp\\n            prev = dp\\n        return dp[k]    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        dp = [0] * (k + 1)\\n        for i in range(len(piles)):\\n            # prefix_sum[i] = sum(pile[:i])\\n            s = len(piles[i])\\n            prefix_sum = [0] * (s + 1)\\n            for j in range(s):\\n                prefix_sum[j + 1] = prefix_sum[j] + piles[i][j]\\n            for j in range(k, -1, -1):\\n                temp = 0\\n                for q in range(j + 1):\\n                    temp = max(temp, dp[j - q] + prefix_sum[min(q, s)])\\n                dp[j] = temp\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        prev = [0]\\n        for i in range(len(piles)):\\n            s = len(piles[i])\\n            l = len(prev)\\n            # prefix_sum[i] = sum(pile[:i])\\n            prefix_sum = [0] * (s + 1)\\n            for j in range(s):\\n                prefix_sum[j + 1] = prefix_sum[j] + piles[i][j]\\n            max_size = s + l\\n            dp = [0] * min(k + 1, max_size)\\n            for j in range(len(dp) - 1, -1, -1):\\n                temp = 0\\n                for q in range(max(0, j - l + 1), min(s ,j) + 1):\\n                    temp = max(temp, prev[j - q] + prefix_sum[q])\\n                dp[j] = temp\\n            prev = dp\\n        return dp[k]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241714,
                "title": "c-o-2000k-short-1d-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDefine state `dp[i][k]` the maximal coin value we can get using the first i piles of coins with total `k` coins taken.\\n\\nWe can see that `dp[i][k]` can be obtained by `dp[i-1][l] + prefixsum[i][k-l]`, where `l <= k`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCan build a 1D dynamic programming table since the state  `dp[i][j]` only depends on `dp[i-1][<=j]`. We can reduce the space by building a DP table `dp[k+1]`, for each new piles we update the table from entry `dp[k]` back to `dp[0]` so that we don\\'t ruin the state `dp[i-1][<j]`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(2000k)$\\nThe worst case is when there is 2000 coins evenly distributed in `n` piles. In that case, the cost to fill out each entry would be `2000/n` and there will be `nk` entries to be filled out. Hence the total time complexity is `O(2000/n*(nk) = 2000k)`, which is tolerable.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(k)$\\n\\n# Code\\n```\\nint dp[2001];\\n\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        // dp of taking first i piles with taking n coins \\n        // dp[i][k] <- dp[i-1][l <= k] + prefsum[i][k-l]\\n        // total coins taken are less than 2000\\n\\n        // to prefix sum\\n        for (auto & v: piles)\\n            for (int i = 1; i < v.size(); ++i)\\n                v[i] += v[i-1];\\n\\n        // 1D dynamic programming\\n        int n = piles.size();\\n        dp[0] = 0;\\n        for (int i = 1; i <= k; ++i)\\n            dp[i] = INT_MIN;\\n        for (int i = 0; i < n; ++i) {\\n            int m = piles[i].size();\\n            for (int j = k; j >= 0; --j) {\\n                for (int l = 1; l <= min(m, j); ++l)\\n                    dp[j] = max(dp[j], dp[j-l] + piles[i][l-1]);\\n            }\\n        }\\n        return dp[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint dp[2001];\\n\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        // dp of taking first i piles with taking n coins \\n        // dp[i][k] <- dp[i-1][l <= k] + prefsum[i][k-l]\\n        // total coins taken are less than 2000\\n\\n        // to prefix sum\\n        for (auto & v: piles)\\n            for (int i = 1; i < v.size(); ++i)\\n                v[i] += v[i-1];\\n\\n        // 1D dynamic programming\\n        int n = piles.size();\\n        dp[0] = 0;\\n        for (int i = 1; i <= k; ++i)\\n            dp[i] = INT_MIN;\\n        for (int i = 0; i < n; ++i) {\\n            int m = piles[i].size();\\n            for (int j = k; j >= 0; --j) {\\n                for (int l = 1; l <= min(m, j); ++l)\\n                    dp[j] = max(dp[j], dp[j-l] + piles[i][l-1]);\\n            }\\n        }\\n        return dp[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720127,
                "title": "c-top-downn-dp-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int maxValueOfCoins(vector<vector<int>>& A, int K) {\\n        int n = A.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(K + 1, 0));\\n        function<int(int, int)> dp = [&](int i, int k) {\\n            if (memo[i][k] > 0) return memo[i][k];\\n            if (i == n || k == 0) return 0;\\n            int res = dp(i + 1, k), cur = 0;\\n            for (int j = 0; j < A[i].size() && j < k; ++j) {\\n                cur += A[i][j];\\n                res = max(res, dp(i + 1, k - j - 1) + cur);\\n            }\\n            memo[i][k] = res;\\n            return res;\\n        };\\n        return dp(0, K);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int maxValueOfCoins(vector<vector<int>>& A, int K) {\\n        int n = A.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(K + 1, 0));\\n        function<int(int, int)> dp = [&](int i, int k) {\\n            if (memo[i][k] > 0) return memo[i][k];\\n            if (i == n || k == 0) return 0;\\n            int res = dp(i + 1, k), cur = 0;\\n            for (int j = 0; j < A[i].size() && j < k; ++j) {\\n                cur += A[i][j];\\n                res = max(res, dp(i + 1, k - j - 1) + cur);\\n            }\\n            memo[i][k] = res;\\n            return res;\\n        };\\n        return dp(0, K);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533358,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        dp = [0 for _ in range(k + 1)]\\n        for pile in piles:\\n            for i in range(k, 0, -1):\\n                pileSum = 0\\n                for j in range(min(i, len(pile))):\\n                    pileSum += pile[j]\\n                    dp[i] = max(dp[i], dp[i - j - 1] + pileSum)\\n        return dp[k]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        dp = [0 for _ in range(k + 1)]\\n        for pile in piles:\\n            for i in range(k, 0, -1):\\n                pileSum = 0\\n                for j in range(min(i, len(pile))):\\n                    pileSum += pile[j]\\n                    dp[i] = max(dp[i], dp[i - j - 1] + pileSum)\\n        return dp[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420193,
                "title": "c-easiest-and-cleanest-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> pre;\\n    \\n    int dfs(int i, int k) {\\n        if(i==pre.size()) return k==0 ? 0 : INT_MIN;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=0;\\n        for(int j=0; j<=min(k,(int)pre[i].size()-1); j++)\\n            ans = max(ans,pre[i][j]+dfs(i+1,k-j));\\n        return dp[i][k]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        dp.resize(n,vector<int>(k+1,-1));\\n        pre.resize(n);\\n        for(int i=0; i<n; i++) {\\n            pre[i].push_back(0);\\n            for(auto &x : piles[i])\\n                pre[i].push_back(pre[i].back()+x);\\n        }\\n        return dfs(0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> pre;\\n    \\n    int dfs(int i, int k) {\\n        if(i==pre.size()) return k==0 ? 0 : INT_MIN;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=0;\\n        for(int j=0; j<=min(k,(int)pre[i].size()-1); j++)\\n            ans = max(ans,pre[i][j]+dfs(i+1,k-j));\\n        return dp[i][k]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        dp.resize(n,vector<int>(k+1,-1));\\n        pre.resize(n);\\n        for(int i=0; i<n; i++) {\\n            pre[i].push_back(0);\\n            for(auto &x : piles[i])\\n                pre[i].push_back(pre[i].back()+x);\\n        }\\n        return dfs(0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176850,
                "title": "a-simple-bottom-up-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int dp[n+1][k+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=k;j++)\\n            {\\n                if(i==0 || j==0) // i = 0 means no items are available and j = 0 means no items are chosen so maximum value = 0 \\n                {\\n                    dp[i][j]=0;\\n                    continue;\\n                }\\n                int s = 0;\\n                dp[i][j]=dp[i-1][j]; // no items are chosen from i th pile so maximum value is same as chosing j items from (i-1) th pile\\n                for(int k1=1;k1<=min(j,(int)piles[i-1].size());k1++)  // chosing k1 items from i th pile so j - k1 items will be selected from (i-1) th pile \\n                {\\n                    s+=piles[i-1][k1-1];\\n                    dp[i][j] = max(dp[i][j],dp[i-1][j-k1] + s);\\n                }\\n            }\\n        }\\n        return dp[n][k];  // final answer chosing k items from n piles\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int dp[n+1][k+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=k;j++)\\n            {\\n                if(i==0 || j==0) // i = 0 means no items are available and j = 0 means no items are chosen so maximum value = 0 \\n                {\\n                    dp[i][j]=0;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2174568,
                "title": "c-recursive-bottom-up-memomization",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoinsUtils(vector<vector<int>> &piles, int n, int k, vector<vector<int>> & dp)\\n    {\\n        if(k == 0 || n == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[n-1][k] != -1)\\n        {\\n            return dp[n-1][k];\\n        }\\n        \\n        /*\\n         * Selected a Pile\\n         */\\n        int sum = 0;\\n        int n_selected_pile = 0;\\n        for(int i = 0; i < piles[n-1].size() && i < k; i++)\\n        {\\n            sum += piles[n-1][i];\\n            n_selected_pile = max(n_selected_pile, sum + maxValueOfCoinsUtils(piles, n - 1, k - i - 1, dp));\\n        }\\n        \\n        /*\\n         * Not -selected a Pile\\n         */\\n        int n_not_selected_pile = maxValueOfCoinsUtils(piles, n - 1, k, dp);\\n        \\n        return dp[n-1][k] = max(n_selected_pile, n_not_selected_pile);\\n       \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         vector<vector<int>> dp(piles.size(), vector<int>(k+1, -1));\\n         return maxValueOfCoinsUtils(piles, piles.size(), k, dp);   \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int maxValueOfCoinsUtils(vector<vector<int>> &piles, int n, int k, vector<vector<int>> & dp)\\n    {\\n        if(k == 0 || n == 0)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2083576,
                "title": "c-memoization",
                "content": "The maximum value will contain a certain number of elements from some stacks, therefore in this approach we visit each index and iterate through the different number of items we can take from that index, after which we move to the next index\\n\\nSubproblems: S(index,k)=The maxium value that can be obtained if we have to take exactly k coins from piles[index:]\\n\\nRelations: We can either:-\\n1. Not take any coins from pile[index]=ans1=S(index+1,k)\\n2. Take a certain coins, we will choose the number that maximises the value at the end=ans2=max{piles[index][j]+S(index+1,k-j-1) **for all** j **in** [0,min(k,piles[index].size)]}\\nThe final answer: S(index,k)=max{ans1,ans2}\\n\\nBase case: \\n1. S(index,k)=0 if k==0\\n2. S(index,k)=INT_MIN if index>=n and k!=0\\n\\nOriginal problem: S(0,K)\\n\\nTime complexity: O(NK)xO(K)=O(NK^2)\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>mem;\\n    int solve(vector<vector<int>>&piles,int index,int k){\\n        if(k<=0){\\n            return 0;\\n        } else if(index>=piles.size()){\\n            return INT_MIN;\\n        } else if(mem[index][k]!=-1){\\n            return mem[index][k];\\n        } else {\\n            int ans1=solve(piles,index+1,k);\\n            int value=0,ans2=INT_MIN;\\n            for(int j=0;j<k and j<piles[index].size();j++){\\n                value+=piles[index][j];\\n                int rec=solve(piles,index+1,k-j-1);\\n                ans2=max(ans2,rec+value);\\n            }\\n            return mem[index][k]=max(ans1,ans2);\\n        }\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        mem=vector<vector<int>>(n,vector<int>(k+1,-1));\\n        return solve(piles,0,k);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    vector<vector<int>>mem;\\n    int solve(vector<vector<int>>&piles,int index,int k){\\n        if(k<=0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2071770,
                "title": "c-easy-to-understand-clean-code-93-faster",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int solve(vector<vector<int>>& v,int index,int k){\\n        if(k==0 || index<0) return 0;\\n        \\n        if(dp[index][k]!=0)return dp[index][k];\\n        \\n        int not_take = solve(v,index-1,k); //skip the current pile!!\\n        int sum = 0;\\n        \\n        int n = v[index].size();\\n        int allowed = min(n,k);\\n        int take = 0;\\n        for(int i=0;i<allowed;i++) //iterations for consuming the current pile!\\n        {\\n            sum+=v[index][i];\\n            take=max(take,sum+solve(v,index-1,k-i-1));\\n        }\\n        int ans = max(take, not_take);\\n        return dp[index][k]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        dp.resize(piles.size(),vector<int>(k+1,0));\\n        return solve(piles,piles.size()-1,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int solve(vector<vector<int>>& v,int index,int k){\\n        if(k==0 || index<0) return 0;\\n        \\n        if(dp[index][k]!=0)return dp[index][k];\\n        \\n        int not_take = solve(v,index-1,k); //skip the current pile!!\\n        int sum = 0;\\n        \\n        int n = v[index].size();\\n        int allowed = min(n,k);\\n        int take = 0;\\n        for(int i=0;i<allowed;i++) //iterations for consuming the current pile!\\n        {\\n            sum+=v[index][i];\\n            take=max(take,sum+solve(v,index-1,k-i-1));\\n        }\\n        int ans = max(take, not_take);\\n        return dp[index][k]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        dp.resize(piles.size(),vector<int>(k+1,0));\\n        return solve(piles,piles.size()-1,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059670,
                "title": "easy-c-code",
                "content": "```\\nint solve(vector<vector<int>>& v,int index,int k,vector<vector<int>>& dp){\\n        if(k==0 || index==v.size())return 0;\\n        \\n        if(dp[index][k]!=0)return dp[index][k];\\n        \\n        int ans=solve(v,index+1,k,dp);\\n        int sum=0;\\n        \\n        for(int i=0;i<v[index].size() && i<k;i++){\\n            sum=sum+v[index][i];\\n            ans=max(ans,sum+solve(v,index+1,k-i-1,dp));\\n        }\\n        return dp[index][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<vector<int>> dp(piles.size(),vector<int>(k+1,0));\\n        return solve(piles,0,k,dp);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint solve(vector<vector<int>>& v,int index,int k,vector<vector<int>>& dp){\\n        if(k==0 || index==v.size())return 0;\\n        \\n        if(dp[index][k]!=0)return dp[index][k];\\n        \\n        int ans=solve(v,index+1,k,dp);\\n        int sum=0;\\n        \\n        for(int i=0;i<v[index].size() && i<k;i++){\\n            sum=sum+v[index][i];\\n            ans=max(ans,sum+solve(v,index+1,k-i-1,dp));\\n        }\\n        return dp[index][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<vector<int>> dp(piles.size(),vector<int>(k+1,0));\\n        return solve(piles,0,k,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931769,
                "title": "easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2001];// dp of 2 states,,since i and k are the only parameters changing .. we created a dp for that \\n    int fun(int i,int k,vector<vector<int>>& piles,int n)\\n    {\\n        if(i>=n || k<0){return 0;}\\n        if(dp[i][k]!=-1){return dp[i][k];}\\n        int ans=fun(i+1,k,piles,n);//first choice ,to skip the current stack\\n        for(int j=0;j<piles[i].size();j++)//either u want top coin or top 2 coins or top 3....and so on\\n        {     if(k-(j+1)<0){break;} //it is not possible to take more than k coins,,\\n            int temp=piles[i][j]+fun(i+1,k-(j+1),piles,n);\\n            if(temp>ans){ans=temp;}\\n        }\\n        return dp[i][k]=ans;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<piles[i].size();j++)\\n            {\\n                piles[i][j]=piles[i][j-1]+piles[i][j];//prefix sum ,,think about it\\n            }\\n        }\\n         memset(dp,-1,sizeof(dp));\\n        int ans=fun(0,k,piles,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2001];// dp of 2 states,,since i and k are the only parameters changing .. we created a dp for that \\n    int fun(int i,int k,vector<vector<int>>& piles,int n)\\n    {\\n        if(i>=n || k<0){return 0;}\\n        if(dp[i][k]!=-1){return dp[i][k];}\\n        int ans=fun(i+1,k,piles,n);//first choice ,to skip the current stack\\n        for(int j=0;j<piles[i].size();j++)//either u want top coin or top 2 coins or top 3....and so on\\n        {     if(k-(j+1)<0){break;} //it is not possible to take more than k coins,,\\n            int temp=piles[i][j]+fun(i+1,k-(j+1),piles,n);\\n            if(temp>ans){ans=temp;}\\n        }\\n        return dp[i][k]=ans;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<piles[i].size();j++)\\n            {\\n                piles[i][j]=piles[i][j-1]+piles[i][j];//prefix sum ,,think about it\\n            }\\n        }\\n         memset(dp,-1,sizeof(dp));\\n        int ans=fun(0,k,piles,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924063,
                "title": "dp-solution-with-nested-loops-easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int n) {\\n        for (int i = 0; i < piles.size(); i++) {\\n            int sum = 0;\\n            for (int k = 0; k < piles[i].size(); k++) {\\n                sum += piles[i][k];\\n                piles[i][k] = sum;\\n            }\\n        }\\n        vector<int> dp(n + 1);\\n        for (int i = 0; i < piles.size(); i++) {\\n            vector<int> temp = dp;\\n            for (int j = 1; j <= n; j++) {\\n                for (int k = 0; k < piles[i].size() && k < j; k++) {\\n                    temp[j] = max(dp[j-k-1] + piles[i][k], temp[j]);\\n                }\\n            }\\n            dp = temp;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int n) {\\n        for (int i = 0; i < piles.size(); i++) {\\n            int sum = 0;\\n            for (int k = 0; k < piles[i].size(); k++) {\\n                sum += piles[i][k];\\n                piles[i][k] = sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1923748,
                "title": "python3-simple-dp-state-and-transition-explained",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        # just a simple DP once you figure out the state and state transition\\n        # figuring out state and state transition is the tough part\\n        # state: f(i, k) = max value of coins that can be made by taking k coins from stack i and stacks to its right\\n        #           Thus piles[i] is the leftmost stack that we can still use.\\n        # transition: our final answer is just some number of coins taken from the top of each stack,\\n        #   so we can do one stack at a time basically. This means we take all the coins we need from\\n        #   the first stack, then move onto second, etc. Our optimal answer is guaranteed to fit this\\n        #   format. Thus, at any state, we either \\n        #       (1) take no coins from the leftmost stack  ->  0 + f(i+1, k)\\n        #       (2) take between 1 and min(k, len(leftmost stack)) coins from leftmost stack \\n        #               ->  sum(leftmost_stack[0:coins_taken]) + f(i+1, k-coins_taken)\\n        \\n        dp = {} # memo table\\n        \\n        def f(i, k):\\n            \\n            # base cases\\n            if i == len(piles)  or k == 0:\\n                return 0\\n            if (i, k) in dp:\\n                return dp[(i, k)]\\n            \\n            # take no coins from this stack\\n            best = f(i+1, k)\\n            \\n            # take one or more coins from this stack\\n            val_sum = 0\\n            lm_stack = piles[i]\\n            for c in range(min(k, len(lm_stack))):\\n                # take coin at index c\\n                val_sum += lm_stack[c]\\n                best = max(best, val_sum + f(i+1, k-c-1))\\n                \\n            dp[(i, k)] = best\\n            return best\\n        \\n        return f(0, k)\\n    \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        # just a simple DP once you figure out the state and state transition\\n        # figuring out state and state transition is the tough part\\n        # state: f(i, k) = max value of coins that can be made by taking k coins from stack i and stacks to its right\\n        #           Thus piles[i] is the leftmost stack that we can still use.\\n        # transition: our final answer is just some number of coins taken from the top of each stack,\\n        #   so we can do one stack at a time basically. This means we take all the coins we need from\\n        #   the first stack, then move onto second, etc. Our optimal answer is guaranteed to fit this\\n        #   format. Thus, at any state, we either \\n        #       (1) take no coins from the leftmost stack  ->  0 + f(i+1, k)\\n        #       (2) take between 1 and min(k, len(leftmost stack)) coins from leftmost stack \\n        #               ->  sum(leftmost_stack[0:coins_taken]) + f(i+1, k-coins_taken)\\n        \\n        dp = {} # memo table\\n        \\n        def f(i, k):\\n            \\n            # base cases\\n            if i == len(piles)  or k == 0:\\n                return 0\\n            if (i, k) in dp:\\n                return dp[(i, k)]\\n            \\n            # take no coins from this stack\\n            best = f(i+1, k)\\n            \\n            # take one or more coins from this stack\\n            val_sum = 0\\n            lm_stack = piles[i]\\n            for c in range(min(k, len(lm_stack))):\\n                # take coin at index c\\n                val_sum += lm_stack[c]\\n                best = max(best, val_sum + f(i+1, k-c-1))\\n                \\n            dp[(i, k)] = best\\n            return best\\n        \\n        return f(0, k)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919092,
                "title": "c-simple-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> ps(n); //Calculating all the prefix sums\\n        \\n        for(int i=0;i<n;i++){\\n            int sz = piles[i].size();\\n            \\n            ps[i]=vector<int>(sz+1,0);\\n            \\n            for(int j=0;j<sz;j++)\\n                ps[i][j+1]=ps[i][j]+piles[i][j];\\n            \\n        }\\n\\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        /*Here dp[i][j] represents the max value obtained after picking up j coins up to the i th pile.\\n\\t\\t   Therefore, dp[i][j] = max(dp[i-1][x] + ps[i-1][j-x]) i.e. max of picking j-x coins upto  i-1 th pile\\n\\t\\t   and then picking the remaining x coins in the ith pile.Here  x can go from 0 to min(k,piles[i-1].size()).\\n\\t\\t*/\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                int lim = min(j,(int)piles[i-1].size());\\n                for(int x=0;x<=lim;x++)\\n                    dp[i][j] = max(dp[i-1][j-x] + ps[i-1][x],dp[i][j]);\\n            }\\n        }\\n        return  dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> ps(n); //Calculating all the prefix sums\\n        \\n        for(int i=0;i<n;i++){\\n            int sz = piles[i].size();\\n            \\n            ps[i]=vector<int>(sz+1,0);\\n            \\n            for(int j=0;j<sz;j++)\\n                ps[i][j+1]=ps[i][j]+piles[i][j];\\n            \\n        }\\n\\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        /*Here dp[i][j] represents the max value obtained after picking up j coins up to the i th pile.\\n\\t\\t   Therefore, dp[i][j] = max(dp[i-1][x] + ps[i-1][j-x]) i.e. max of picking j-x coins upto  i-1 th pile\\n\\t\\t   and then picking the remaining x coins in the ith pile.Here  x can go from 0 to min(k,piles[i-1].size()).\\n\\t\\t*/\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                int lim = min(j,(int)piles[i-1].size());\\n                for(int x=0;x<=lim;x++)\\n                    dp[i][j] = max(dp[i-1][j-x] + ps[i-1][x],dp[i][j]);\\n            }\\n        }\\n        return  dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897467,
                "title": "dp-recursive",
                "content": "```class Solution {\\npublic:\\n    int dp[1001][2002];\\n    int solve(vector<vector<int>>&piles,int k,int start){\\n        \\n        if(start==piles.size() || k==0){\\n            return 0;\\n        }\\n        if(dp[start][k]!=-1){\\n            return dp[start][k];\\n        }\\n        \\n        int ans=0;\\n        int op1=solve(piles,k,start+1);\\n        int op2=0;int sum=0;\\n        for(int i=0;i<piles[start].size();i++){\\n            sum+=piles[start][i];\\n            if(k-(i+1)>=0){\\n                op2=sum+solve(piles,k-(i+1),start+1);\\n            }\\n            int c=max(op1,op2);\\n            ans=max(ans,c);\\n        }\\n        return dp[start][k]=ans;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,k,0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[1001][2002];\\n    int solve(vector<vector<int>>&piles,int k,int start){\\n        \\n        if(start==piles.size() || k==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1897175,
                "title": "c-top-down-dp-0-1-knapsack-code",
                "content": "```\\nclass Solution {\\npublic:\\nint dp[1001][2001];\\nint func(vector<vector<int>> &nums, int k, int n)\\n{\\n    if (n == 0 or k <= 0)\\n        return 0;\\n\\n    if (dp[n][k] != -1)\\n        return dp[n][k];\\n\\n    int sum = 0, res = 0, i = 0;\\n    int temp = k;\\n    int m = nums[n - 1].size() - 1;\\n    res = max(res, func(nums, k, n - 1));\\n    while (i <= m and k > 0)\\n    {\\n        sum += nums[n - 1][i];\\n        res = max(res, sum + func(nums, k - 1, n - 1));\\n        i++;\\n        k--;\\n    }\\n\\n    return dp[n][temp] = res;\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    memset(dp, -1, sizeof(dp));\\n    return func(piles, k, n);\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[1001][2001];\\nint func(vector<vector<int>> &nums, int k, int n)\\n{\\n    if (n == 0 or k <= 0)\\n        return 0;\\n\\n    if (dp[n][k] != -1)\\n        return dp[n][k];\\n\\n    int sum = 0, res = 0, i = 0;\\n    int temp = k;\\n    int m = nums[n - 1].size() - 1;\\n    res = max(res, func(nums, k, n - 1));\\n    while (i <= m and k > 0)\\n    {\\n        sum += nums[n - 1][i];\\n        res = max(res, sum + func(nums, k - 1, n - 1));\\n        i++;\\n        k--;\\n    }\\n\\n    return dp[n][temp] = res;\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    memset(dp, -1, sizeof(dp));\\n    return func(piles, k, n);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895041,
                "title": "top-down-dp-approach-memoization-c-clean-code",
                "content": "Code\\n-----------------\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& piles, vector<vector<int>>& dp, int idx, int k, int n) {\\n        if(k == 0 or idx == n) {\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1) return dp[idx][k];\\n                \\n        int value = solve(piles, dp, idx+1, k, n);\\n        \\n        int sum = 0;\\n        \\n        for(int i=0; i<min(k, (int)piles[idx].size()); i++) {\\n            sum += piles[idx][i];\\n            value = max(value, sum + solve(piles, dp, idx+1, k-(i+1), n));\\n        }\\n        \\n        return dp[idx][k] = value;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return solve(piles, dp, 0, k, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& piles, vector<vector<int>>& dp, int idx, int k, int n) {\\n        if(k == 0 or idx == n) {\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1) return dp[idx][k];\\n                \\n        int value = solve(piles, dp, idx+1, k, n);\\n        \\n        int sum = 0;\\n        \\n        for(int i=0; i<min(k, (int)piles[idx].size()); i++) {\\n            sum += piles[idx][i];\\n            value = max(value, sum + solve(piles, dp, idx+1, k-(i+1), n));\\n        }\\n        \\n        return dp[idx][k] = value;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return solve(piles, dp, 0, k, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893475,
                "title": "bottom-up-eze-to-understand-complexity-analysis",
                "content": "Either pick all k from previous piles, or choose j from current pile and pick k-j from previous piles\\nRecurrence relation:\\nf(i,k) represents the max sum of coins collected from first i piles and choosing k top coins.\\n```\\nf(i,k) = min(\\n\\t\\t\\tf(i-1,k) // pick k from previous piles\\n\\t\\t\\t,min(f(i-1,k-j-1)+sum(0 to j) for j = 0 to min(k,p[i-1].size())) // pick j+1 from current pile and k-j-1 from previous piles\\n\\t\\t)\\n```\\n\\nif k = 0, i.e. you can\\'t pick any coin then ans = 0\\nif n = 0, i.e. you don\\'t have any piles then ans = 0\\nBase cases :\\nf(0,k) = 0\\nf(n,0) = 0\\n\\nComplexity at max will be O(n*k+2000). Why? beacuse its given that sum of all lengths of piles is at max 2000  \\n(1 <= k <= sum(piles[i].length) <= 2000). So you iterate over all **a[i][j]** at max once.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& a, int k) {\\n        int dp[1005][2005]={{0}};\\n        int n=a.size();\\n        //finding prefix sum before hand \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<a[i].size();j++){\\n                a[i][j]+=a[i][j-1];\\n            }\\n        }\\n        //imagine a case when you have to choose from only one pile with diff value of k ,obviously it will be their prefix sum!!\\n       for(int j=1;j<2005;j++){\\n           if(j<=a[0].size())\\n           dp[0][j]+=a[0][j-1];\\n       }\\n        for(int i=1;i<n;i++){\\n           for(int j=1;j<2005;j++){\\n               int x=dp[i-1][j];  //if I dont choose any value from current i.e ith pile\\n               //now i will try to find max value if i choose 1,2,3...(min(a[i].size(),k)) ele fro current pile\\n               int y=0;\\n               for(int l=0;l<a[i].size();l++){\\n                   if(j-l-1>=0)  //(min(a[i].size(),k) condition.\\n                   y=max(y,a[i][l]+dp[i-1][j-l-1]);\\n               }\\n               dp[i][j]=max(x,y); //max of both\\n               \\n        }\\n        }\\n        \\n        return dp[n-1][k];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nf(i,k) = min(\\n\\t\\t\\tf(i-1,k) // pick k from previous piles\\n\\t\\t\\t,min(f(i-1,k-j-1)+sum(0 to j) for j = 0 to min(k,p[i-1].size())) // pick j+1 from current pile and k-j-1 from previous piles\\n\\t\\t)\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& a, int k) {\\n        int dp[1005][2005]={{0}};\\n        int n=a.size();\\n        //finding prefix sum before hand \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<a[i].size();j++){\\n                a[i][j]+=a[i][j-1];\\n            }\\n        }\\n        //imagine a case when you have to choose from only one pile with diff value of k ,obviously it will be their prefix sum!!\\n       for(int j=1;j<2005;j++){\\n           if(j<=a[0].size())\\n           dp[0][j]+=a[0][j-1];\\n       }\\n        for(int i=1;i<n;i++){\\n           for(int j=1;j<2005;j++){\\n               int x=dp[i-1][j];  //if I dont choose any value from current i.e ith pile\\n               //now i will try to find max value if i choose 1,2,3...(min(a[i].size(),k)) ele fro current pile\\n               int y=0;\\n               for(int l=0;l<a[i].size();l++){\\n                   if(j-l-1>=0)  //(min(a[i].size(),k) condition.\\n                   y=max(y,a[i][l]+dp[i-1][j-l-1]);\\n               }\\n               dp[i][j]=max(x,y); //max of both\\n               \\n        }\\n        }\\n        \\n        return dp[n-1][k];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893337,
                "title": "simple-solution-in-java-iterative-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int numPiles = piles.size();\\n        \\n        int[][] dp = new int[numPiles+1][k+1];\\n        \\n        for(int i=1; i<=numPiles; i++){\\n            for(int j=1; j<=k; j++){\\n                dp[i][j] = dp[i-1][j]; // Not taking any coin at all from the current pile\\n                \\n                // For the current pile, we have the option to take the atmost j coins if present\\n                List<Integer> currPile = piles.get(i-1);\\n                int coinSum = 0;\\n                for(int c=0; c < Math.min(currPile.size(), j); c++){\\n                    coinSum += currPile.get(c);\\n                    \\n                    // Take c coins from the current pile and remaining coins from the previous piles\\n                    dp[i][j] = Math.max(dp[i][j], coinSum + dp[i-1][j - c - 1]); \\n                }\\n            }\\n        }\\n        \\n        return dp[numPiles][k];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int numPiles = piles.size();\\n        \\n        int[][] dp = new int[numPiles+1][k+1];\\n        \\n        for(int i=1; i<=numPiles; i++){\\n            for(int j=1; j<=k; j++){\\n                dp[i][j] = dp[i-1][j]; // Not taking any coin at all from the current pile\\n                \\n                // For the current pile, we have the option to take the atmost j coins if present\\n                List<Integer> currPile = piles.get(i-1);\\n                int coinSum = 0;\\n                for(int c=0; c < Math.min(currPile.size(), j); c++){\\n                    coinSum += currPile.get(c);\\n                    \\n                    // Take c coins from the current pile and remaining coins from the previous piles\\n                    dp[i][j] = Math.max(dp[i][j], coinSum + dp[i-1][j - c - 1]); \\n                }\\n            }\\n        }\\n        \\n        return dp[numPiles][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893060,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * K)***\\n* ***Space Complexity : O(N * K)***\\n\\n```\\n    vector<vector<int>> dp;\\n    \\n    int helper(vector<vector<int>>& piles, int pos, int k)\\n    {\\n        if(pos >= piles.size())\\n            return 0;\\n        \\n        if(k == 0)\\n            return 0;\\n        \\n        if(k < 0)\\n            return INT_MIN + 5000;\\n        \\n        if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        int option_1 = 0;\\n        \\n        int option_2 = 0;\\n        \\n        int taken = 0;\\n        \\n        for(int i = 0; i < min(k, (int)piles[pos].size()); i++)\\n        {\\n            taken += piles[pos][i];\\n            \\n            option_1 = max(option_1, taken + helper(piles, pos + 1, k - 1- i));\\n        }\\n        \\n        option_2 = helper(piles, pos + 1, k);\\n        \\n        return dp[pos][k] = max(option_1, option_2);\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        \\n        dp.resize(n + 1);\\n        \\n        dp.assign(n + 1, vector<int> (k + 1, -1));\\n        \\n        return helper(piles, 0, k);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    vector<vector<int>> dp;\\n    \\n    int helper(vector<vector<int>>& piles, int pos, int k)\\n    {\\n        if(pos >= piles.size())\\n            return 0;\\n        \\n        if(k == 0)\\n            return 0;\\n        \\n        if(k < 0)\\n            return INT_MIN + 5000;\\n        \\n        if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        int option_1 = 0;\\n        \\n        int option_2 = 0;\\n        \\n        int taken = 0;\\n        \\n        for(int i = 0; i < min(k, (int)piles[pos].size()); i++)\\n        {\\n            taken += piles[pos][i];\\n            \\n            option_1 = max(option_1, taken + helper(piles, pos + 1, k - 1- i));\\n        }\\n        \\n        option_2 = helper(piles, pos + 1, k);\\n        \\n        return dp[pos][k] = max(option_1, option_2);\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        \\n        dp.resize(n + 1);\\n        \\n        dp.assign(n + 1, vector<int> (k + 1, -1));\\n        \\n        return helper(piles, 0, k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891330,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1002][2002] = {};\\n    \\n    int solve(vector<vector<int>>& piles, int pileIdx, int k){\\n        \\n        if(pileIdx >= piles.size() or k <= 0) return 0;\\n        \\n        if(dp[pileIdx][k] != 0) return dp[pileIdx][k];\\n        \\n        // no pick up from this pile\\n        int ans = solve(piles, pileIdx+1, k);\\n        \\n        int sum = 0;\\n        for(int i=0; i< piles[pileIdx].size() and i < k; i++){\\n            \\n            // pick up i+1 coins from this pile\\n            \\n            sum+= piles[pileIdx][i];\\n            \\n            ans = max(ans, sum+solve(piles, pileIdx+1, k-(i+1)));\\n            \\n        }\\n        \\n        return dp[pileIdx][k] = ans;\\n        \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        return solve(piles,0,k);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1002][2002] = {};\\n    \\n    int solve(vector<vector<int>>& piles, int pileIdx, int k){\\n        \\n        if(pileIdx >= piles.size() or k <= 0) return 0;\\n        \\n        if(dp[pileIdx][k] != 0) return dp[pileIdx][k];\\n        \\n        // no pick up from this pile\\n        int ans = solve(piles, pileIdx+1, k);\\n        \\n        int sum = 0;\\n        for(int i=0; i< piles[pileIdx].size() and i < k; i++){\\n            \\n            // pick up i+1 coins from this pile\\n            \\n            sum+= piles[pileIdx][i];\\n            \\n            ans = max(ans, sum+solve(piles, pileIdx+1, k-(i+1)));\\n            \\n        }\\n        \\n        return dp[pileIdx][k] = ans;\\n        \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        return solve(piles,0,k);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890924,
                "title": "c-top-down-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& p, int k,int i,vector<vector<int>>& dp){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int notake = 0 + f(p,k,i-1,dp);\\n        int take = 0;\\n        int sum=0;\\n        for(int l=0; l<p[i].size(); l++){\\n            sum+=p[i][l];\\n            if(k>=(l+1)) take = max(take,sum+f(p,k-l-1,i-1,dp));\\n        }\\n        return dp[i][k]=max(notake,take);\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1,-1));\\n        return f(p,k,n-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& p, int k,int i,vector<vector<int>>& dp){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int notake = 0 + f(p,k,i-1,dp);\\n        int take = 0;\\n        int sum=0;\\n        for(int l=0; l<p[i].size(); l++){\\n            sum+=p[i][l];\\n            if(k>=(l+1)) take = max(take,sum+f(p,k-l-1,i-1,dp));\\n        }\\n        return dp[i][k]=max(notake,take);\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1,-1));\\n        return f(p,k,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890250,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/051db66d8b0518ebeccdb1e18229f849b1291f38) for solutions of weekly 286. \\n\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return \"\"\"\\n            if i == len(piles) or k == 0: return 0 \\n            ans = fn(i+1, k)\\n            prefix = 0 \\n            for j in range(min(k, len(piles[i]))): \\n                prefix += piles[i][j]\\n                ans = max(ans, prefix + fn(i+1, k-j-1))\\n            return ans \\n        \\n        return fn(0, k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return \"\"\"\\n            if i == len(piles) or k == 0: return 0 \\n            ans = fn(i+1, k)\\n            prefix = 0 \\n            for j in range(min(k, len(piles[i]))): \\n                prefix += piles[i][j]\\n                ans = max(ans, prefix + fn(i+1, k-j-1))\\n            return ans \\n        \\n        return fn(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888985,
                "title": "c-knapsack",
                "content": "class Solution {\\npublic:\\n\\n    int dp[1001][2001]; \\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(p,0,k);\\n    }\\n    int solve(vector<vector<int>>&p ,int i ,int k){\\n      if(i>=p.size())\\n      return 0;\\n      if(dp[i][k] !=-1)\\n        return dp[i][k];\\n      int exclude=solve(p,i+1,k);\\n      int include=0,sum=0;\\n      for(int j=0;j<p[i].size();j++){\\n        sum+=p[i][j];\\n        if(k-j-1>=0)\\n        include=max(include,sum+solve(p,i+1,k-j-1));\\n      }\\n      return dp[i][k]=max(exclude,include);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int dp[1001][2001]; \\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(p,0,k);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1888423,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve (vector<vector<int>> &piles, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i>=piles.size())\\n            return 0;\\n        \\n        if (dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int res=0;\\n        res=max(res,solve(piles, i+1, k, dp));\\n        \\n        for(int j=0; j<piles[i].size()&&j+1<=k; j++)\\n        {\\n            res=max(res, piles[i][j]+solve(piles, i+1, k-j-1, dp));\\n        }\\n        return dp[i][k]=res;     \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        for(int i=0; i<piles.size(); i++)\\n        {\\n            for(int j=1; j<piles[i].size(); j++)\\n            {\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n            }\\n        }\\n        int n=piles.size();\\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));\\n        return solve(piles, 0, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve (vector<vector<int>> &piles, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i>=piles.size())\\n            return 0;\\n        \\n        if (dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int res=0;\\n        res=max(res,solve(piles, i+1, k, dp));\\n        \\n        for(int j=0; j<piles[i].size()&&j+1<=k; j++)\\n        {\\n            res=max(res, piles[i][j]+solve(piles, i+1, k-j-1, dp));\\n        }\\n        return dp[i][k]=res;     \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        for(int i=0; i<piles.size(); i++)\\n        {\\n            for(int j=1; j<piles[i].size(); j++)\\n            {\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n            }\\n        }\\n        int n=piles.size();\\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));\\n        return solve(piles, 0, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888217,
                "title": "c-2d-dp-memomization",
                "content": "```\\nclass Solution {\\n    int fun(vector<vector<int>>& piles,int k,int l,vector<vector<int>> &dp){\\n        int n = piles.size();\\n        if(l == n || k == 0)    return 0;\\n        \\n        if(dp[l][k] != -1)  return dp[l][k];\\n        \\n        int ans = fun(piles,k,l+1,dp);\\n        int sum = 0;\\n       \\n        for(int i=0; i<piles[l].size() && i<k; i++){\\n            sum += piles[l][i];\\n            ans = max(ans, sum + fun(piles,k-i-1,l+1,dp));\\n        }\\n        \\n        dp[l][k] = ans;\\n        return ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles,int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1,-1));\\n        \\n        return fun(piles,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int fun(vector<vector<int>>& piles,int k,int l,vector<vector<int>> &dp){\\n        int n = piles.size();\\n        if(l == n || k == 0)    return 0;\\n        \\n        if(dp[l][k] != -1)  return dp[l][k];\\n        \\n        int ans = fun(piles,k,l+1,dp);\\n        int sum = 0;\\n       \\n        for(int i=0; i<piles[l].size() && i<k; i++){\\n            sum += piles[l][i];\\n            ans = max(ans, sum + fun(piles,k-i-1,l+1,dp));\\n        }\\n        \\n        dp[l][k] = ans;\\n        return ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles,int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1,-1));\\n        \\n        return fun(piles,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888148,
                "title": "c-memoization-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles,int k,int i,vector<vector<int>>& dp)\\n    {\\n        if(i<0)\\n            return 0;\\n        \\n        if(k==0)\\n            return 0;\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        \\n        //skipping this pile and moving to the next one\\n        int ans=solve(piles,k,i-1,dp),j,sum=0;\\n        for(j=0;j<piles[i].size();j++)\\n        {\\n            sum+=piles[i][j];\\n            //choose a coin from this pile & then try going to the next pile\\n            //or go deep into this pile and add its value\\n            if(k-j-1>=0)// untill k>=0\\n            {\\n                ans=max(ans,sum+solve(piles,k-j-1,i-1,dp));\\n            }\\n            else //if k<0 then can\\'t do anything else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));\\n        return solve(piles,k,n-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles,int k,int i,vector<vector<int>>& dp)\\n    {\\n        if(i<0)\\n            return 0;\\n        \\n        if(k==0)\\n            return 0;\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        \\n        //skipping this pile and moving to the next one\\n        int ans=solve(piles,k,i-1,dp),j,sum=0;\\n        for(j=0;j<piles[i].size();j++)\\n        {\\n            sum+=piles[i][j];\\n            //choose a coin from this pile & then try going to the next pile\\n            //or go deep into this pile and add its value\\n            if(k-j-1>=0)// untill k>=0\\n            {\\n                ans=max(ans,sum+solve(piles,k-j-1,i-1,dp));\\n            }\\n            else //if k<0 then can\\'t do anything else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));\\n        return solve(piles,k,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888140,
                "title": "easy-recursion-memo-2-d-dp-top-down-o-n-k-time-space",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][2001];\\n    int fun(vector<vector<int>>& piles, int i, int k){\\n        if(k==0 || i==piles.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int skip = fun(piles, i+1, k);\\n        int take = 0, sum = 0;\\n        for(int cur = 0, count = k; cur < piles[i].size() && count; cur++){\\n            sum += piles[i][cur]; count--;\\n            take = max(take, sum + fun(piles, i+1, count));\\n        }\\n        return dp[i][k] = max(skip, take);\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp, -1, sizeof dp);\\n        return fun(piles, 0, k);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][2001];\\n    int fun(vector<vector<int>>& piles, int i, int k){\\n        if(k==0 || i==piles.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int skip = fun(piles, i+1, k);\\n        int take = 0, sum = 0;\\n        for(int cur = 0, count = k; cur < piles[i].size() && count; cur++){\\n            sum += piles[i][cur]; count--;\\n            take = max(take, sum + fun(piles, i+1, count));\\n        }\\n        return dp[i][k] = max(skip, take);\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp, -1, sizeof dp);\\n        return fun(piles, 0, k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888020,
                "title": "racket-dp-solution",
                "content": "```scheme\\n(define/contract (max-value-of-coins piles k)\\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\\n  (define (dp i k)\\n    (cond [(= i (vector-length piles)) 0]\\n          [(= k 0) 0]\\n          [else (let ([maximum (dp (+ i 1) k)]\\n                      [prefix 0])\\n                  (for ([j (range 0 (min (vector-length (vector-ref piles i))\\n                                         k))]\\n                        [vij (vector-ref piles i)])\\n                    (set-var! prefix + vij)\\n                    (set-var! maximum max (+ prefix (dp (+ i 1) (- k j 1)))))\\n                  maximum)]))\\n  (set! piles (list2d->vector2d piles))\\n  (set! dp (vector-memoize dp (vector-length piles) k -1))\\n  (dp 0 k))\\n\\n;; helpers ;;\\n\\n(define (list2d->vector2d ll)\\n  (list->vector (map list->vector ll)))\\n\\n(define (vector2d-ref vec x y)\\n  (vector-ref (vector-ref vec x) y))\\n\\n(define (vector2d-set! vec x y val)\\n  (vector-set! (vector-ref vec x) y val))\\n\\n(define (make-vector2d x y init)\\n  (build-vector x (lambda (row) (make-vector y init))))\\n\\n(define (vector-memoize old-proc xlimit ylimit init)\\n  (let ([vec (make-vector2d (+ xlimit 1) (+ ylimit 1) init)])\\n    (lambda (x y)\\n      (when (= (vector2d-ref vec x y) init)\\n            (vector2d-set! vec x y (old-proc x y)))\\n      (vector2d-ref vec x y))))\\n\\n(define-syntax-rule (set-var! x f delta)\\n  (set! x (f x delta)))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```scheme\\n(define/contract (max-value-of-coins piles k)\\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\\n  (define (dp i k)\\n    (cond [(= i (vector-length piles)) 0]\\n          [(= k 0) 0]\\n          [else (let ([maximum (dp (+ i 1) k)]\\n                      [prefix 0])\\n                  (for ([j (range 0 (min (vector-length (vector-ref piles i))\\n                                         k))]\\n                        [vij (vector-ref piles i)])\\n                    (set-var! prefix + vij)\\n                    (set-var! maximum max (+ prefix (dp (+ i 1) (- k j 1)))))\\n                  maximum)]))\\n  (set! piles (list2d->vector2d piles))\\n  (set! dp (vector-memoize dp (vector-length piles) k -1))\\n  (dp 0 k))\\n\\n;; helpers ;;\\n\\n(define (list2d->vector2d ll)\\n  (list->vector (map list->vector ll)))\\n\\n(define (vector2d-ref vec x y)\\n  (vector-ref (vector-ref vec x) y))\\n\\n(define (vector2d-set! vec x y val)\\n  (vector-set! (vector-ref vec x) y val))\\n\\n(define (make-vector2d x y init)\\n  (build-vector x (lambda (row) (make-vector y init))))\\n\\n(define (vector-memoize old-proc xlimit ylimit init)\\n  (let ([vec (make-vector2d (+ xlimit 1) (+ ylimit 1) init)])\\n    (lambda (x y)\\n      (when (= (vector2d-ref vec x y) init)\\n            (vector2d-set! vec x y (old-proc x y)))\\n      (vector2d-ref vec x y))))\\n\\n(define-syntax-rule (set-var! x f delta)\\n  (set! x (f x delta)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887605,
                "title": "top-down-dp-solution-3d-2d",
                "content": "## **Top Down Approach**\\n\\n*Pure top down accepted solution but less efficient*\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &piles, int n, int k, int i, int index[], vector<vector<vector<int>>> &dp) {\\n        if(i == n || k == 0) return 0;\\n        \\n        if(dp[i][index[i]][k] != -1) return dp[i][index[i]][k];\\n        \\n        int x = 0, y = 0;\\n        if(index[i] < piles[i].size()) {\\n            index[i]++;\\n            x = piles[i][index[i]-1] + helper(piles, n, k-1, i, index, dp);\\n            index[i]--;\\n        }\\n        y = helper(piles, n, k, i+1, index, dp);\\n        \\n        return dp[i][index[i]][k] = max(x, y);    \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        int index[1000] = {0};\\n        vector<vector<vector<int>>> dp(n);\\n        for(int i=0; i<n; i++) {\\n            vector<vector<int>> temp(piles[i].size()+1, vector<int>(k+1, -1));\\n            dp[i] = temp;\\n        }\\n        \\n        return helper(piles, n, k, 0, index, dp);\\n    }\\n};\\n```\\n\\n\\n*Top down accepted solution and more efficient*\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &piles, int n, int k, int i, vector<vector<int>> &dp) {\\n        if(k == 0) return 0;\\n        else if(i == n || k < 0) return INT_MIN;\\n        \\n        if(dp[i][k] != -1) return dp[i][k];\\n        \\n        int x = 0, sum = 0;\\n        for(int j=0; j<piles[i].size(); j++) {\\n            sum += piles[i][j];\\n            x = max(x, sum + helper(piles, n, k-j-1, i+1, dp));\\n        }\\n        int y = helper(piles, n, k, i+1, dp);\\n        \\n        return dp[i][k] = max(x, y);\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        \\n        return helper(piles, n, k, 0, dp);\\n    }\\n};\\n```\\n\\n#1stPost",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &piles, int n, int k, int i, int index[], vector<vector<vector<int>>> &dp) {\\n        if(i == n || k == 0) return 0;\\n        \\n        if(dp[i][index[i]][k] != -1) return dp[i][index[i]][k];\\n        \\n        int x = 0, y = 0;\\n        if(index[i] < piles[i].size()) {\\n            index[i]++;\\n            x = piles[i][index[i]-1] + helper(piles, n, k-1, i, index, dp);\\n            index[i]--;\\n        }\\n        y = helper(piles, n, k, i+1, index, dp);\\n        \\n        return dp[i][index[i]][k] = max(x, y);    \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        int index[1000] = {0};\\n        vector<vector<vector<int>>> dp(n);\\n        for(int i=0; i<n; i++) {\\n            vector<vector<int>> temp(piles[i].size()+1, vector<int>(k+1, -1));\\n            dp[i] = temp;\\n        }\\n        \\n        return helper(piles, n, k, 0, index, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &piles, int n, int k, int i, vector<vector<int>> &dp) {\\n        if(k == 0) return 0;\\n        else if(i == n || k < 0) return INT_MIN;\\n        \\n        if(dp[i][k] != -1) return dp[i][k];\\n        \\n        int x = 0, sum = 0;\\n        for(int j=0; j<piles[i].size(); j++) {\\n            sum += piles[i][j];\\n            x = max(x, sum + helper(piles, n, k-j-1, i+1, dp));\\n        }\\n        int y = helper(piles, n, k, i+1, dp);\\n        \\n        return dp[i][k] = max(x, y);\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        \\n        return helper(piles, n, k, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887231,
                "title": "dp-tabulation-c-space-optimized-o-k",
                "content": "Problem Simillar to Knapsack.\\n\\n\\n```\\n int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=0;j<=k;++j){\\n                int nt=dp[i+1][j];\\n                int a=0;\\n                 for(int m=0;m<p[i].size()&&m<j;++m){\\n                     a+=p[i][m];\\n                     nt=max(nt,a+dp[i+1][j-m-1]);\\n                 }\\n                dp[i][j]=nt;\\n                }\\n        }\\n        return dp[0][k];\\n    }\\n\\t\\n\\t\\n\\t// T.C.=> O(n*k^2)\\n\\t// S.C=> O(n*k)\\n\\t\\n\\t\\n```\\n\\nAdding more space optimized in future\\n____________________________________________________________________________________\\n\\nEdit:\\nSpace Optimized\\n\\n```\\nint maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n\\t\\t// will not be using 2d Matrix here instead of that we will use two 1-d array of size k+1 \\n        // vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        \\n        vector<int> pre(k+1,0),curr(k+1,0);\\n        \\n        \\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=0;j<=k;++j){\\n                int nt=pre[j];\\n                int a=0;\\n                 for(int m=0;m<p[i].size()&&m<j;++m){\\n                     a+=p[i][m];\\n                     nt=max(nt,a+pre[j-m-1]);\\n                 }\\n                \\n                curr[j]=nt;\\n                \\n                }\\n            pre=curr;\\n   \\n        }\\n\\n        return pre[k];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// T.C.=> O(n*k^2)\\n\\t       // S.C=> O(k)\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=0;j<=k;++j){\\n                int nt=dp[i+1][j];\\n                int a=0;\\n                 for(int m=0;m<p[i].size()&&m<j;++m){\\n                     a+=p[i][m];\\n                     nt=max(nt,a+dp[i+1][j-m-1]);\\n                 }\\n                dp[i][j]=nt;\\n                }\\n        }\\n        return dp[0][k];\\n    }\\n\\t\\n\\t\\n\\t// T.C.=> O(n*k^2)\\n\\t// S.C=> O(n*k)\\n\\t\\n\\t\\n```\n```\\nint maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n\\t\\t// will not be using 2d Matrix here instead of that we will use two 1-d array of size k+1 \\n        // vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        \\n        vector<int> pre(k+1,0),curr(k+1,0);\\n        \\n        \\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=0;j<=k;++j){\\n                int nt=pre[j];\\n                int a=0;\\n                 for(int m=0;m<p[i].size()&&m<j;++m){\\n                     a+=p[i][m];\\n                     nt=max(nt,a+pre[j-m-1]);\\n                 }\\n                \\n                curr[j]=nt;\\n                \\n                }\\n            pre=curr;\\n   \\n        }\\n\\n        return pre[k];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// T.C.=> O(n*k^2)\\n\\t       // S.C=> O(k)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887152,
                "title": "c-solution-o-k-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& rows, int k) {\\n        vector<int> dp(k + 1, -1e9);\\n    dp[0] = 0;\\n        for(auto &it:rows)\\n        {\\n            reverse(it.begin(),it.end());\\n        }\\n    for (const auto& nums : rows) {\\n        int n = nums.size();\\n        auto dpc = dp;\\n\\n        for (int i = 1; i <= k; ++i) {\\n            int sum = 0;\\n            for (int j = 1; j <= min(i, n); ++j)\\n                dpc[i] = max(dpc[i], (sum += nums[n - j]) + dp[i - j]);\\n        }\\n\\n        dp = dpc;\\n    }\\n\\n    return dp[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& rows, int k) {\\n        vector<int> dp(k + 1, -1e9);\\n    dp[0] = 0;\\n        for(auto &it:rows)\\n        {\\n            reverse(it.begin(),it.end());\\n        }\\n    for (const auto& nums : rows) {\\n        int n = nums.size();\\n        auto dpc = dp;\\n\\n        for (int i = 1; i <= k; ++i) {\\n            int sum = 0;\\n            for (int j = 1; j <= min(i, n); ++j)\\n                dpc[i] = max(dpc[i], (sum += nums[n - j]) + dp[i - j]);\\n        }\\n\\n        dp = dpc;\\n    }\\n\\n    return dp[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887108,
                "title": "java-memoization",
                "content": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n= piles.size();\\n        int[][] memo= new int[n][k+1];\\n        for(int i=0; i<n; i++) Arrays.fill(memo[i], -1);\\n        return maxValue(0, k, new ArrayList<>(piles), memo);\\n    }\\n    \\n    int maxValue(int i, int k, ArrayList<List<Integer>> piles, int[][] memo){\\n        if(k==0) return 0;\\n        int n= piles.size();\\n        if(i==n) return 0;\\n        \\n        if(memo[i][k]!=-1) return memo[i][k];\\n       \\n        List<Integer> pile= piles.get(i);\\n        int len= pile.size(), canTake= Math.min(len, k);\\n        int thisMaxValue= maxValue(i+1, k, piles, memo);\\n        int taken= 0, takenValue= 0;\\n        for(int coin:pile){\\n            if(taken==canTake) break;\\n            taken++;\\n            takenValue+= coin;\\n            thisMaxValue= Math.max(thisMaxValue, takenValue + maxValue(i+1, k-taken, piles, memo));\\n        }\\n        return memo[i][k]= thisMaxValue;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n= piles.size();\\n        int[][] memo= new int[n][k+1];\\n        for(int i=0; i<n; i++) Arrays.fill(memo[i], -1);\\n        return maxValue(0, k, new ArrayList<>(piles), memo);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1887096,
                "title": "dp-java-solution",
                "content": "\\n    class Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n      int max=0;\\n        for(List<Integer> l:piles){\\n            max=Math.max(max,l.size());\\n        }\\n        int dp[][][]=new int[piles.size()][max][k+1];\\n        for(int p[][]:dp){\\n            for(int x[]:p){\\n                Arrays.fill(x,-1);\\n            }\\n        }\\n        return maxvalue(0,0,piles,k,dp);\\n    }\\n    public int maxvalue(int i,int j,List<List<Integer>> piles,int k,int dp[][][]){\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(j>=piles.get(i).size())return 0;\\n        if(dp[i][j][k]!=-1)return dp[i][j][k];\\n      int take=0;\\n            take=piles.get(i).get(j)+Math.max(maxvalue(i,j+1,piles,k-1,dp),maxvalue(i+1,0,piles,k-1,dp));\\n            int not=maxvalue(i+1,0,piles,k,dp);\\n        \\n        return dp[i][j][k]=Math.max(take,not);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n      int max=0;\\n        for(List<Integer> l:piles){\\n            max=Math.max(max,l.size());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1887037,
                "title": "top-down-dp-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int explore(vector<vector<int>>& piles,int k,int &n,int i,vector<vector<int>>& dp)\\n    {\\n        if(i==n||k==0)\\n            return 0;\\n       \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int ans=0;\\n        ans=explore(piles,k,n,i+1,dp);\\n        int sum=0;\\n        int K=k;\\n        for(int j=0;j<piles[i].size()&&k>0;j++)\\n        {\\n            \\n            sum+=piles[i][j];\\n            k--;\\n            ans=max(ans,sum+explore(piles,k,n,i+1,dp));\\n           \\n        }\\n     \\n        return dp[i][K]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2001,-1));\\n        return explore(piles,k,n,0,dp);\\n        \\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explore(vector<vector<int>>& piles,int k,int &n,int i,vector<vector<int>>& dp)\\n    {\\n        if(i==n||k==0)\\n            return 0;\\n       \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int ans=0;\\n        ans=explore(piles,k,n,i+1,dp);\\n        int sum=0;\\n        int K=k;\\n        for(int j=0;j<piles[i].size()&&k>0;j++)\\n        {\\n            \\n            sum+=piles[i][j];\\n            k--;\\n            ans=max(ans,sum+explore(piles,k,n,i+1,dp));\\n           \\n        }\\n     \\n        return dp[i][K]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2001,-1));\\n        return explore(piles,k,n,0,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887019,
                "title": "c-2218-maximum-value-of-k-coins-from-piles",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<vector<int>> seen(piles.size(), vector<int>(k+1, -1)); \\n        \\n        function<int(int, int)> fn = [&](int i, int k) {\\n            if (i == piles.size()) return 0; \\n            if (k == 0) return 0; \\n            if (seen[i][k] == -1) {\\n                seen[i][k] = fn(i+1, k); \\n                int prefix = 0; \\n                for (int j = 0; j < piles[i].size() && j < k; ++j) {\\n                    prefix += piles[i][j]; \\n                    seen[i][k] = max(seen[i][k], prefix + fn(i+1, k-j-1)); \\n                }\\n            }\\n            return seen[i][k]; \\n        }; \\n        \\n        return fn(0, k); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<vector<int>> seen(piles.size(), vector<int>(k+1, -1)); \\n        \\n        function<int(int, int)> fn = [&](int i, int k) {\\n            if (i == piles.size()) return 0; \\n            if (k == 0) return 0; \\n            if (seen[i][k] == -1) {\\n                seen[i][k] = fn(i+1, k); \\n                int prefix = 0; \\n                for (int j = 0; j < piles[i].size() && j < k; ++j) {\\n                    prefix += piles[i][j]; \\n                    seen[i][k] = max(seen[i][k], prefix + fn(i+1, k-j-1)); \\n                }\\n            }\\n            return seen[i][k]; \\n        }; \\n        \\n        return fn(0, k); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886946,
                "title": "cpp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int util(int k, int idx, vector<vector<int>>& piles) {\\n        if(idx == piles.size()) return 0;\\n        if(k <= 0) return 0;\\n        if(dp[k][idx] != -1) return dp[k][idx];\\n        int res = util(k, idx + 1, piles);\\n        int cnt = 0;\\n        for(int i = 0; i < piles[idx].size() && k - i - 1 >= 0; i++) {\\n            cnt += piles[idx][i];\\n            res = max(res, cnt + util(k - i - 1, idx + 1, piles));\\n        }\\n        \\n        return dp[k][idx] = res;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        dp = vector<vector<int>>(k + 1, vector<int>(piles.size(), -1));\\n        return util(k, 0, piles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int util(int k, int idx, vector<vector<int>>& piles) {\\n        if(idx == piles.size()) return 0;\\n        if(k <= 0) return 0;\\n        if(dp[k][idx] != -1) return dp[k][idx];\\n        int res = util(k, idx + 1, piles);\\n        int cnt = 0;\\n        for(int i = 0; i < piles[idx].size() && k - i - 1 >= 0; i++) {\\n            cnt += piles[idx][i];\\n            res = max(res, cnt + util(k - i - 1, idx + 1, piles));\\n        }\\n        \\n        return dp[k][idx] = res;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        dp = vector<vector<int>>(k + 1, vector<int>(piles.size(), -1));\\n        return util(k, 0, piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886931,
                "title": "c-prefix-sum-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        // prefix sum\\n        vector<vector<int>> pfs(m);\\n        int all_sum = 0;\\n        int all_cnt = 0;\\n        for(int i=0;i<m;i++){\\n            auto& pile = piles[i];\\n            auto& sums = pfs[i];\\n            int pile_nums = 0;\\n            for(int num: pile){\\n                int sum = sums.empty()? num: (num+sums.back());\\n                sums.push_back(sum);\\n                all_sum += num;\\n                all_cnt++;\\n                pile_nums++;\\n                if(pile_nums==k){\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(all_cnt<=k){\\n            return all_sum;\\n        }\\n        \\n        vector<vector<int>> dp(m,vector<int>(k+1,0));\\n        \\n        auto get =[&](int i,int num){\\n            auto& sums = pfs[i];\\n            int len = sums.size();\\n            if(len==0||num==0){\\n                return 0;\\n            }\\n            return sums[min(len-1,num-1)];\\n        };\\n        \\n        for(int i=0; i<m;i++){\\n            for(int j=1;j<=k;j++){\\n                for(int get_here =0;get_here<=j&&get_here<=pfs[i].size();get_here++){\\n                    int get_before = j-get_here;\\n                    dp[i][j] = max(dp[i][j], get(i,get_here)+(i==0?0:dp[i-1][get_before]));\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n\\n        \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        // prefix sum\\n        vector<vector<int>> pfs(m);\\n        int all_sum = 0;\\n        int all_cnt = 0;\\n        for(int i=0;i<m;i++){\\n            auto& pile = piles[i];\\n            auto& sums = pfs[i];\\n            int pile_nums = 0;\\n            for(int num: pile){\\n                int sum = sums.empty()? num: (num+sums.back());\\n                sums.push_back(sum);\\n                all_sum += num;\\n                all_cnt++;\\n                pile_nums++;\\n                if(pile_nums==k){\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(all_cnt<=k){\\n            return all_sum;\\n        }\\n        \\n        vector<vector<int>> dp(m,vector<int>(k+1,0));\\n        \\n        auto get =[&](int i,int num){\\n            auto& sums = pfs[i];\\n            int len = sums.size();\\n            if(len==0||num==0){\\n                return 0;\\n            }\\n            return sums[min(len-1,num-1)];\\n        };\\n        \\n        for(int i=0; i<m;i++){\\n            for(int j=1;j<=k;j++){\\n                for(int get_here =0;get_here<=j&&get_here<=pfs[i].size();get_here++){\\n                    int get_before = j-get_here;\\n                    dp[i][j] = max(dp[i][j], get(i,get_here)+(i==0?0:dp[i-1][get_before]));\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886917,
                "title": "c-dp-with-some-explaination",
                "content": "``` c++\\nclass Solution {\\n   public:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n\\n        // dp[i][j]: the maximum value we can get picking j coins from the first\\n        // i piles\\n        vector<vector<int>> dp(n, vector<int>(k + 1));\\n        for (int i = 1; i <= min(k, (int)piles[0].size()); i++) {\\n            dp[0][i] = dp[0][i - 1] + piles[0][i - 1];\\n        }\\n\\n        // the total number of coins of the first (i - 1) piles\\n        int tot = piles[0].size();\\n        for (int i = 1; i < n; i++) {\\n            int pileSize = piles[i].size();\\n\\n            // presum of the i-th pile\\n            vector<int> presum(k + 1);\\n            for (int j = 1; j <= min(k, pileSize); j++) {\\n                presum[j] = presum[j - 1] + piles[i][j - 1];\\n            }\\n\\n            // pick j coins from the first i piles, j should be no greater than\\n            // the sum of the first i piles\\n            for (int j = 0; j <= min(k, tot + pileSize); j++) {\\n                // pick l coins from the first (i - 1) piles\\n                // these j coins consist of two parts:\\n                // 1. l coins from the previous piles, dp[i-1][j]\\n                // 2. j - l coins from the current (i-th) pile, presum[j-l]\\n                for (int l = max(0, j - pileSize); l <= min({j, k, tot}); l++) {\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][l] + presum[j - l]);\\n                }\\n            }\\n\\n            // update tot\\n            tot += pileSize;\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` c++\\nclass Solution {\\n   public:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n\\n        // dp[i][j]: the maximum value we can get picking j coins from the first\\n        // i piles\\n        vector<vector<int>> dp(n, vector<int>(k + 1));\\n        for (int i = 1; i <= min(k, (int)piles[0].size()); i++) {\\n            dp[0][i] = dp[0][i - 1] + piles[0][i - 1];\\n        }\\n\\n        // the total number of coins of the first (i - 1) piles\\n        int tot = piles[0].size();\\n        for (int i = 1; i < n; i++) {\\n            int pileSize = piles[i].size();\\n\\n            // presum of the i-th pile\\n            vector<int> presum(k + 1);\\n            for (int j = 1; j <= min(k, pileSize); j++) {\\n                presum[j] = presum[j - 1] + piles[i][j - 1];\\n            }\\n\\n            // pick j coins from the first i piles, j should be no greater than\\n            // the sum of the first i piles\\n            for (int j = 0; j <= min(k, tot + pileSize); j++) {\\n                // pick l coins from the first (i - 1) piles\\n                // these j coins consist of two parts:\\n                // 1. l coins from the previous piles, dp[i-1][j]\\n                // 2. j - l coins from the current (i-th) pile, presum[j-l]\\n                for (int l = max(0, j - pileSize); l <= min({j, k, tot}); l++) {\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][l] + presum[j - l]);\\n                }\\n            }\\n\\n            // update tot\\n            tot += pileSize;\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038386,
                "title": "top-down-approach-100-step-by-step-explanation-easy-to-understand",
                "content": "# Intuition\\nYour intuition for solving this problem is not explicitly mentioned in the comments, but it seems like you want to use dynamic programming to keep track of the maximum number of coins that can be obtained while considering the constraints given by k.\\n\\n# Approach\\nYour approach involves using dynamic programming to compute the maximum number of coins you can obtain up to the i-th pile with j chosen coins. Here\\'s a breakdown of your approach:\\n\\nInitialize a 2D vector dp of size (n + 1) x (k + 1) where n is the number of piles.\\n\\nCompute the prefix sum for each pile. This is done by iterating through each pile and accumulating the number of coins from left to right. The prefix sum is stored in the same pile vector, replacing the original values.\\n\\nUse nested loops to iterate through the dp array. The outer loop iterates over the piles (i) from 1 to n, and the inner loop iterates over the number of chosen coins (j) from 1 to k.\\n\\nWithin the inner loop, you initialize dp[i][j] to be equal to dp[i-1][j], which means you are considering not choosing any coins from the current pile.\\n\\nThen, you use another loop (x) to consider choosing from 1 to min(j, (int)piles[i - 1].size()) coins from the current pile (piles[i-1]). For each value of x, you update dp[i][j] with the maximum between its current value (dp[i][j]) and the value obtained by choosing x coins from the current pile (piles[i-1][x-1]) and adding it to the value of dp[i-1][j-x], which represents the maximum obtained from the previous piles with the remaining j-x chosen coins.\\n\\nAfter completing the loops, dp[n][k] will contain the maximum number of coins you can obtain.\\n\\nYour maxValueOfCoins function simply calls maxCoins and returns its result.\\n\\n# Complexity\\n- Time complexity:\\nO(n * k * min(j, (int)piles[i - 1].size()))\\n\\n- Space complexity:\\nO(n * k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<vector<int>>& piles, int k) {\\n    int n = piles.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n \\n    for (int i = 0; i < n; i++) {\\n        int prefixSum = 0;\\n        for (int j = 0; j < piles[i].size(); j++) {\\n            prefixSum += piles[i][j];\\n            piles[i][j] = prefixSum;\\n        }\\n    }\\n    \\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= k; j++) {\\n            dp[i][j] = dp[i - 1][j]; \\n            \\n            for (int x = 1; x <= min(j, (int)piles[i - 1].size()); x++) {\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + piles[i - 1][x - 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[n][k];\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n     return maxCoins(piles, k); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<vector<int>>& piles, int k) {\\n    int n = piles.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n \\n    for (int i = 0; i < n; i++) {\\n        int prefixSum = 0;\\n        for (int j = 0; j < piles[i].size(); j++) {\\n            prefixSum += piles[i][j];\\n            piles[i][j] = prefixSum;\\n        }\\n    }\\n    \\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= k; j++) {\\n            dp[i][j] = dp[i - 1][j]; \\n            \\n            for (int x = 1; x <= min(j, (int)piles[i - 1].size()); x++) {\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + piles[i - 1][x - 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[n][k];\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n     return maxCoins(piles, k); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023455,
                "title": "simple-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[-1] * (k + 1) for _ in range(n)]\\n\\n        def dfs(i,coins):\\n            if i==n:\\n                return 0\\n            if dp[i][coins] != -1:\\n                return dp[i][coins]\\n            dp[i][coins] = dfs(i + 1, coins) #not take\\n            curPile = 0\\n            for j in range(min(coins, len(piles[i]))):\\n                curPile += piles[i][j] \\n                dp[i][coins] = max(dp[i][coins], curPile + dfs(i + 1, coins - j - 1)) #taking the coin from same piles until it exist and checking \\n            return dp[i][coins]\\n        return dfs(0, k) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[-1] * (k + 1) for _ in range(n)]\\n\\n        def dfs(i,coins):\\n            if i==n:\\n                return 0\\n            if dp[i][coins] != -1:\\n                return dp[i][coins]\\n            dp[i][coins] = dfs(i + 1, coins) #not take\\n            curPile = 0\\n            for j in range(min(coins, len(piles[i]))):\\n                curPile += piles[i][j] \\n                dp[i][coins] = max(dp[i][coins], curPile + dfs(i + 1, coins - j - 1)) #taking the coin from same piles until it exist and checking \\n            return dp[i][coins]\\n        return dfs(0, k) \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1863496,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863543,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863729,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863859,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863595,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863503,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863943,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863510,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1864055,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863574,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863496,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863543,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863729,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863859,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863595,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863503,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863943,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863510,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1864055,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863574,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863546,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1863511,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1863618,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 2036283,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 2009740,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 2008157,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1869407,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1867325,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1866029,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1865407,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1864474,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864458,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864085,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864021,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864010,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864007,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863927,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863924,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863746,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863731,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863698,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863569,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863550,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863542,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863532,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863516,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863515,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863499,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863977,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1767382,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways to Buy Pens and Pencils",
        "question_content": "<p>You are given an integer <code>total</code> indicating the amount of money you have. You are also given two integers <code>cost1</code> and <code>cost2</code> indicating the price of a pen and pencil respectively. You can spend <strong>part or all</strong> of your money to buy multiple quantities (or none) of each kind of writing utensil.</p>\n\n<p>Return <em>the <strong>number of distinct ways</strong> you can buy some number of pens and pencils.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> total = 20, cost1 = 10, cost2 = 5\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> The price of a pen is 10 and the price of a pencil is 5.\n- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\n- If you buy 1 pen, you can buy 0, 1, or 2 pencils.\n- If you buy 2 pens, you cannot buy any pencils.\nThe total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> total = 5, cost1 = 10, cost2 = 10\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= total, cost1, cost2 &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1953645,
                "title": "division",
                "content": "If we buy `cnt` pens, we can buy up to `(total - cnt * cost1) / cost2 + 1` pencils. We do plus one as we can also buy zero pencils. \\n\\n**C++**\\n```cpp\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n    long long res = 0;\\n    for (int cnt = 0; cnt * cost1 <= total; ++cnt)\\n        res += (total - cnt * cost1) / cost2 + 1;\\n    return res;\\n}\\n```\\n\\n#### Recursive one-liner\\n**C++**\\n```cpp\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n    return total < 0 ? 0 : 1 + total / cost2 + waysToBuyPensPencils(total - cost1, cost1, cost2);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n    long long res = 0;\\n    for (int cnt = 0; cnt * cost1 <= total; ++cnt)\\n        res += (total - cnt * cost1) / cost2 + 1;\\n    return res;\\n}\\n```\n```cpp\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n    return total < 0 ? 0 : 1 + total / cost2 + waysToBuyPensPencils(total - cost1, cost1, cost2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953663,
                "title": "c-python-java-greedy-o-n-100-faster",
                "content": "**This is a question of observing**\\nFirst example clearly gives idea to solve this.\\nInput: total = 20, cost1 = 10, cost2 = 5\\nOutput: 9\\nExplanation: The price of a pen is 10 and the price of a pencil is 5.\\n- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\\n- If you buy 1 pen, you can buy 0, 1, or 2 pencils.\\n- If you buy 2 pens, you cannot buy any pencils.\\nThe total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\\n\\n**Idea: Buy pen and count possible ways to buy pencils**\\n* As we can see we have to try number of ways:\\n* just calulate how much pen i can buy with this total\\n* for example in 1st expmple you can buy from range 0 to 2 pens.\\n* So available choice are 0 pens, for that just think how much pencil you can buy \\n* i.e m = remaining amount / pencil cost\\n* you can buy maximum m pencils so you have m + 1 choices\\n* Now try for next choosen way of pen buying i.e buy 1 pen. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ways = 0;\\n        long long penscost = 0;\\n        while(penscost <= total) {\\n            long long remainingAmount = total - penscost;\\n            long long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }\\n        return ways;\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ways = 0;\\n        penscost = 0;\\n        while penscost <= total:\\n            remainingAmount = total - penscost;\\n            pencils = remainingAmount//cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        return ways\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ways = 0;\\n        long penscost = 0;\\n        while(penscost <= total) {\\n            long remainingAmount = total - penscost;\\n            long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }\\n        return ways;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3a1414b5-2586-4194-aef9-53821e747a9c_1650280252.3769152.png)\\n\\n\\n**If you have any doubt comment, upvote if liked.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ways = 0;\\n        long long penscost = 0;\\n        while(penscost <= total) {\\n            long long remainingAmount = total - penscost;\\n            long long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }\\n        return ways;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ways = 0;\\n        penscost = 0;\\n        while penscost <= total:\\n            remainingAmount = total - penscost;\\n            pencils = remainingAmount//cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        return ways\\n```\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ways = 0;\\n        long penscost = 0;\\n        while(penscost <= total) {\\n            long remainingAmount = total - penscost;\\n            long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955208,
                "title": "o-sqrt-total-python-0-21-ms-java-c-0-ms",
                "content": "(Update/challenge: [Can we do it in O(log(total))?](https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/discuss/1958437/O(log(total)))\\n\\nFour solutions, from the simple brute force one that almost everyone is using, to the slightly improved one that steps by the larger cost, to fast ones that I haven\\'t seen from anyone yet. LeetCode reports ~35 ms for the fast ones in Python, though as I also just [showed for another problem](https://leetcode.com/problems/find-closest-number-to-zero/discuss/1954364/Proper-benchmarks-3.4-ms-Python), that\\'s almost entirely judge overhead. They actually take only about 0.22 ms, as measured by myself with the below code. Actual times for the four solutions:\\n```\\nsimple    422.24 ms  423.20 ms  423.36 ms\\nimproved  284.80 ms  284.84 ms  284.86 ms\\nfast1       0.21 ms    0.21 ms    0.21 ms\\nfast2       0.23 ms    0.23 ms    0.23 ms\\n```\\nFor a Java implementation of `fast1`, LeetCode reported 0 ms itself. For a C++ implementation, it reported 0 ms or 3 ms.\\n\\nAs a preview, here\\'s `fast2`:\\n\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        return sum(\\n            (rest//c+1) * blocks + C * comb(blocks, 2)\\n            for rest in range(total % C, min(blocksize, total+1), C)\\n            for blocks in [(total-rest) // blocksize + 1]\\n        )\\n\\n**Explanation**\\n\\nConsider for example the input `total = 120`, `cost1 = 7` and `cost2 = 5`. By buying 0, 1, 2, etc pens, we have 120, 113, 106, etc left to buy pencils. For 120, we have `floor(120/5)+1 = 25` possible numbers of pencils. For 113, it\\'s `floor(113/5)+1 = 23`. Etc. Here\\'s the list of those numbers:\\n```\\n120 25\\n113 23\\n106 22\\n99 20\\n92 19\\n85 18\\n78 16\\n71 15\\n64 13\\n57 12\\n50 11\\n43 9\\n36 8\\n29 6\\n22 5\\n15 4\\n8 2\\n1 1\\n```\\nNow let\\'s split this into blocks of `5` (the smaller of the two costs). We\\'ll see some adjusted repetition of the numbers:\\n```\\n120 25\\n113 23\\n106 22\\n99 20\\n92 19\\nblock sum = 25+23+22+20+19 = 109\\n\\n85 18=25-7       Note that this block starts with 85, that is 5*7=35 less than\\n78 16=23-7       the 120 that the block above started with. The blocks cover a\\n71 15=22-7       range of 5*7, so the remainders modulo 5 (and modulo 7, but\\n64 13=20-7       that is irrelevant) are the same in each block. That is why\\n57 12=19-7       they are so similar (same pencil numbers, just \"-7\" on all).\\nblock sum = 109 - 5*7\\n\\n50 11=25-2*7\\n43 9=23-2*7\\n36 8=22-2*7\\n29 6=20-2*7\\n22 5=19-2*7\\nblock sum = 109 - 2*(5*7)\\n\\n15 4\\n8 2\\n1 1\\npartial-block sum = 4+2+1 = 7\\n```\\n\\n**Algorithm of `fast1`** in pseudocode (maybe more readable for non-Python-coders than my below Python code):\\n\\nIt starts with some organizational calculations about the blocks. Then it computes the sum of that partial block on the bottom. And then if there are full blocks, it computes the sum of the top one, and uses that to calculate the total sum of *all* full blocks.\\n\\n    function waysToBuyPensPencils(total, cost1, cost2):\\n        c = min(cost1, cost2)\\n\\t\\tC = max(cost1, cost2)\\n        blocksize = c * C\\n        blocks = floor(total / blocksize)\\n        partial = total % blocksize\\n        result = 0\\n        for (rest = partial; rest >= 0; rest -= C):\\n            result += floor(rest / c) + 1\\n        if blocks > 0:\\n            blocksum = 0\\n            for (rest = total; rest > total - blocksize; rest -= C):\\n                blocksum += floor(rest / c) + 1\\n            result += blocks * blocksum - blocksize * blocks*(blocks-1)/2\\n        return result\\n\\nIt can be improved further by using `lcm(c, C)` (least common multiple) as the block size instead of `c * C`, which would reduce the number of loop iterations by factor `gcd(c, C)`. But with LeetCode\\'s test cases, that didn\\'t help, and actually made it slightly slower (0.23 ms instead of 0.21 ms).\\n\\n**About `fast2`:**\\n\\nLater I realized I don\\'t have treat the partial block and the full blocks differently. Rearrange the rows from my example/analysis as follows, grouping the `rest` values by their remainder modulo 35. So for example `rest` values 1, 36, 71 and 106 go together:\\n```\\n1 1   = 1+0*7\\n36 8   =1+1*7\\n71 15  =1+2*7\\n106 22 =1+3*7\\ngroup sum = 1+8+15+22 = 1*4 + 7*(4*3/2) = 46\\n\\n8 2    =2+0*7\\n43 9   =2+1*7\\n78 16  =2+2*7\\n113 23 =2+3*7\\ngroup sum = 2+9+16+23 = 2*4 + 7*(4*3/2) = 50\\n\\n15 4   =4+0*7\\n50 11  =4+1*7\\n85 18  =4+2*7\\n120 25 =4+3*7\\ngroup sum = 4+11+18+25 = 4*4 + 7*(4*3/2) = 58\\n\\n22 5  =5+0*7\\n57 12 =5+1*7\\n92 19 =5+2*7\\ngroup sum = 5+12+19 = 5*3 + 7*(3*2/2) = 36\\n\\n29 6  =6+0*7\\n64 13 =6+1*7\\n99 20 =6+2*7\\ngroup sum = 6+13+20 = 6*3 + 7*(3*2/2) = 39\\n```\\nSo I just loop over the `rest` values 1, 8, 15, 22 and 29, compute their group sums, and add them all.\\n\\nAnd actually, the group sums are so similar that I think we can simplify the calculation further. You see there are *three* groups with four rows, which adds `7*(4*3/2)` *three* times. And *two* groups with three rows, which adds `7*(3*2/2)` *two* times. Stay tuned for `fast3` :-)\\n\\nUpdate: of all the group sums like `1*4 + 7*(4*3/2)`, I can compute the sum of all the parts like `7*(4*3/2)` in O(1) now. Let\\'s see if I can compute the sum of all the parts like `1*4` in O(1) as well... then it\\'d be an overall O(1) solution. Although maybe I should look at the big picture instead. The answer is *almost* `(total // cost1 + 1) * (total // cost2 + 1) // 2`, maybe I should just figure out how to fix that one.\\n\\n**Python code of the solutions and my benchmarker**\\n\\nCan be submitted as such, but after the last test case, it intentionally returns without the correct result and prints the benchmark times, which LeetCode then shows.\\n```\\nclass Solution:\\n\\n    def simple(self, total: int, cost1: int, cost2: int) -> int:\\n        return sum(rest // cost1 + 1\\n                   for rest in range(total, -1, -cost2))\\n    \\n    def improved(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        return sum(rest // c + 1\\n                   for rest in range(total, -1, -C))\\n\\n    def fast1(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        blocks, partial = divmod(total, blocksize)\\n        result = sum(rest // c + 1\\n                     for rest in range(partial, -1, -C))\\n        if blocks:\\n            blocksum = sum(rest // c + 1\\n                           for rest in range(total, total - blocksize, -C))\\n            result += blocks * blocksum - blocksize * comb(blocks, 2)\\n        return result\\n\\n    def fast2(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        return sum(\\n            (rest//c+1) * blocks + C * comb(blocks, 2)\\n            for rest in range(total % C, min(blocksize, total+1), C)\\n            for blocks in [(total-rest) // blocksize + 1]\\n        )\\n\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int, timess=defaultdict(lambda: [0] * 5), testcase=[0]) -> int:\\n        solutions = self.simple, self.improved, self.fast1, self.fast2\\n        expect = dummy = object()\\n        from time import perf_counter as time\\n        for i in range(5):\\n            for solution in solutions:\\n                start = time()\\n                result = solution(total, cost1, cost2)\\n                end = time()\\n                if expect is dummy:\\n                    expect = result\\n                assert result == expect\\n                timess[solution.__name__][i] += end - start\\n        testcase[0] += 1\\n        if testcase[0] == 145:\\n            for name, times in timess.items():\\n                print(f\\'{name:8}\\', *(f\\'{t*1e3:7.2f} ms\\' for t in sorted(times)[:3]))\\n            return\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nsimple    422.24 ms  423.20 ms  423.36 ms\\nimproved  284.80 ms  284.84 ms  284.86 ms\\nfast1       0.21 ms    0.21 ms    0.21 ms\\nfast2       0.23 ms    0.23 ms    0.23 ms\\n```\n```\\n120 25\\n113 23\\n106 22\\n99 20\\n92 19\\n85 18\\n78 16\\n71 15\\n64 13\\n57 12\\n50 11\\n43 9\\n36 8\\n29 6\\n22 5\\n15 4\\n8 2\\n1 1\\n```\n```\\n120 25\\n113 23\\n106 22\\n99 20\\n92 19\\nblock sum = 25+23+22+20+19 = 109\\n\\n85 18=25-7       Note that this block starts with 85, that is 5*7=35 less than\\n78 16=23-7       the 120 that the block above started with. The blocks cover a\\n71 15=22-7       range of 5*7, so the remainders modulo 5 (and modulo 7, but\\n64 13=20-7       that is irrelevant) are the same in each block. That is why\\n57 12=19-7       they are so similar (same pencil numbers, just \"-7\" on all).\\nblock sum = 109 - 5*7\\n\\n50 11=25-2*7\\n43 9=23-2*7\\n36 8=22-2*7\\n29 6=20-2*7\\n22 5=19-2*7\\nblock sum = 109 - 2*(5*7)\\n\\n15 4\\n8 2\\n1 1\\npartial-block sum = 4+2+1 = 7\\n```\n```\\n1 1   = 1+0*7\\n36 8   =1+1*7\\n71 15  =1+2*7\\n106 22 =1+3*7\\ngroup sum = 1+8+15+22 = 1*4 + 7*(4*3/2) = 46\\n\\n8 2    =2+0*7\\n43 9   =2+1*7\\n78 16  =2+2*7\\n113 23 =2+3*7\\ngroup sum = 2+9+16+23 = 2*4 + 7*(4*3/2) = 50\\n\\n15 4   =4+0*7\\n50 11  =4+1*7\\n85 18  =4+2*7\\n120 25 =4+3*7\\ngroup sum = 4+11+18+25 = 4*4 + 7*(4*3/2) = 58\\n\\n22 5  =5+0*7\\n57 12 =5+1*7\\n92 19 =5+2*7\\ngroup sum = 5+12+19 = 5*3 + 7*(3*2/2) = 36\\n\\n29 6  =6+0*7\\n64 13 =6+1*7\\n99 20 =6+2*7\\ngroup sum = 6+13+20 = 6*3 + 7*(3*2/2) = 39\\n```\n```\\nclass Solution:\\n\\n    def simple(self, total: int, cost1: int, cost2: int) -> int:\\n        return sum(rest // cost1 + 1\\n                   for rest in range(total, -1, -cost2))\\n    \\n    def improved(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        return sum(rest // c + 1\\n                   for rest in range(total, -1, -C))\\n\\n    def fast1(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        blocks, partial = divmod(total, blocksize)\\n        result = sum(rest // c + 1\\n                     for rest in range(partial, -1, -C))\\n        if blocks:\\n            blocksum = sum(rest // c + 1\\n                           for rest in range(total, total - blocksize, -C))\\n            result += blocks * blocksum - blocksize * comb(blocks, 2)\\n        return result\\n\\n    def fast2(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        return sum(\\n            (rest//c+1) * blocks + C * comb(blocks, 2)\\n            for rest in range(total % C, min(blocksize, total+1), C)\\n            for blocks in [(total-rest) // blocksize + 1]\\n        )\\n\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int, timess=defaultdict(lambda: [0] * 5), testcase=[0]) -> int:\\n        solutions = self.simple, self.improved, self.fast1, self.fast2\\n        expect = dummy = object()\\n        from time import perf_counter as time\\n        for i in range(5):\\n            for solution in solutions:\\n                start = time()\\n                result = solution(total, cost1, cost2)\\n                end = time()\\n                if expect is dummy:\\n                    expect = result\\n                assert result == expect\\n                timess[solution.__name__][i] += end - start\\n        testcase[0] += 1\\n        if testcase[0] == 145:\\n            for name, times in timess.items():\\n                print(f\\'{name:8}\\', *(f\\'{t*1e3:7.2f} ms\\' for t in sorted(times)[:3]))\\n            return\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953640,
                "title": "simple-math",
                "content": "**This question boils to solving the equation:**\\n\\n**cost1 * x + cost2 * y = total;**\\n\\n**y =(total - cost1 * x) / cost2;**\\n\\n// for every value of x starting from \"0\" find  the value for \" y\" using above equation :\\n\\n// if (total - cost1 * x) is  less than \"0\" we cant find any other solutions so we end the process.\\n\\n// other wise for every x we  get some value \"y\" that means \"y+1\" distinct pairs so add it to answer\\n\\n**Note**: we should take the floor value of y because we cant buy a 0.5 pencils or 1.2 pencils etc... we can only buy 0,1,2.... pencils only/\\n   \\n```\\nclass Solution\\n{\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2)\\n    {\\n        long ans=0;\\n        int val=0;\\n        for(int x=0;;x++)\\n        {\\n            val=total-cost1*x;\\n            if(val < 0) break;\\n            ans+= (long)Math.floor((long)val /(long) cost2)+1;   \\n        }\\n         return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2)\\n    {\\n        long ans=0;\\n        int val=0;\\n        for(int x=0;;x++)\\n        {\\n            val=total-cost1*x;\\n            if(val < 0) break;\\n            ans+= (long)Math.floor((long)val /(long) cost2)+1;   \\n        }\\n         return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953842,
                "title": "number-of-ways-division-loop-o-n",
                "content": "Hi Everyone, \\n\\nStep by step into the problem :\\n  1. Keep one as constant I took pen as constant\\n  2. Increment the constant from 0 till the number * cost1 < amount\\n  3. If the remanining amount, find the quotient of by dividing it by cost2\\n  4. Sum the quotient and return the sum\\n\\nNote: Even if both cost are greater than total then possible way is 0 and 0..\\n\\nPlease upvote if it helps.. Happy learning :)\\n\\n```\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long res=0;\\n\\t\\tfor (int i = 0; i * cost1 <= total; i++)\\n\\t\\t\\t\\tres += (total - i * cost1) / cost2 + 1;\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi Everyone, \\n\\nStep by step into the problem :\\n  1. Keep one as constant I took pen as constant\\n  2. Increment the constant from 0 till the number * cost1 < amount\\n  3. If the remanining amount, find the quotient of by dividing it by cost2\\n  4. Sum the quotient and return the sum\\n\\nNote: Even if both cost are greater than total then possible way is 0 and 0..\\n\\nPlease upvote if it helps.. Happy learning :)\\n\\n```\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long res=0;\\n\\t\\tfor (int i = 0; i * cost1 <= total; i++)\\n\\t\\t\\t\\tres += (total - i * cost1) / cost2 + 1;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1953638,
                "title": "buy-pen-and-count-pencils",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ways = 0\\n        for i in range(1 + total // cost1):\\n            left = max(total - i * cost1, 0)\\n            ways += 1 + left // cost2\\n        return ways\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ways = 0\\n        for i in range(1 + total // cost1):\\n            left = max(total - i * cost1, 0)\\n            ways += 1 + left // cost2\\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956896,
                "title": "very-simple-easy-to-understand-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/9632be29-c5c6-4ce4-8ebf-766d84b161bc_1650190514.5924041.png)\\n\\nJust Observe the First Given Test-Case and You\\'ll very easily understand how i came up with this Intuition.\\n\\nCODE:-\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        if(cost1>total && cost2>total){\\n            return 1;\\n        }\\n        if(cost1>cost2){\\n            for(int i=total;i>=0;i=i-cost1){\\n                int k=i/cost2;\\n                ans+=k+1;\\n            }\\n        }else{\\n            for(int i=total;i>=0;i=i-cost2){\\n                int k=i/cost1;\\n                ans+=k+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        if(cost1>total && cost2>total){\\n            return 1;\\n        }\\n        if(cost1>cost2){\\n            for(int i=total;i>=0;i=i-cost1){\\n                int k=i/cost2;\\n                ans+=k+1;\\n            }\\n        }else{\\n            for(int i=total;i>=0;i=i-cost2){\\n                int k=i/cost1;\\n                ans+=k+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954301,
                "title": "dp-recursion-memoization-tabulation-space-optimization",
                "content": "**Problem Pattern -** \\n\\nDynamic Programming  -> DP on Subsequences -> Unbounded Knapsack -> Coin Change\\n\\n\\n**Coin Change Problem Link -**\\n\\nhttps://leetcode.com/problems/coin-change/\\n\\n\\n**Solution Of This Problem -**\\n\\n\\n```\\n//Recursion\\n//time complexity - Exponential\\n//space complexity - Greater than O(n)\\n// class Solution {\\n// private:\\n//     long long f(int i, int T, vector<int> &v){\\n//         //Base case\\n//         if(T == 0) return 0;\\n//         if(i == 0) {\\n//             return T/v[i];\\n//         }\\n        \\n//         long long nottake = f(i - 1, T , v);\\n        \\n//         long long take = 0;\\n//         if(T >= v[i]) take = 1 + f(i,T - v[i], v);\\n        \\n//         return take + nottake;\\n//     }\\n// public:\\n//     long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n//         vector<int> v;\\n//         v.push_back(cost1);\\n//         v.push_back(cost2);\\n        \\n//         int m = v.size();\\n//         int n = total;\\n        \\n//         return f(m-1,n,v) + 1;\\n//     }\\n// };\\n\\n\\n\\n//Memoization\\n//time complexity - O(m*n) [m = 2 , n = total]\\n//space complexity - O(m*n) + O(n)\\n// class Solution {\\n// private:\\n//     long long f(int i, int T, vector<int> &v,vector<vector<long long>> &dp){\\n//         //Base case\\n//         if(T == 0) return 0;\\n//         if(i == 0) {\\n//             return T/v[i];\\n//         }\\n        \\n//         if(dp[i][T] != -1) return dp[i][T];\\n        \\n//         long long nottake = f(i - 1, T , v,dp);\\n        \\n//         long long take = 0;\\n//         if(T >= v[i]) take = 1 + f(i,T - v[i], v,dp);\\n        \\n//         return dp[i][T] =  take + nottake;\\n//     }\\n// public:\\n//     long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n//         vector<int> v;\\n//         v.push_back(cost1);\\n//         v.push_back(cost2);\\n        \\n//         int m = v.size();\\n//         int n = total;\\n        \\n//         vector<vector<long long>> dp(m,vector<long long>(n+1,-1));\\n        \\n//         return f(m-1,n,v,dp) + 1;\\n//     }\\n// };\\n\\n\\n\\n\\n\\n//Tabulation\\n//time complexity - O(m*n) [m = 2 , n = total]\\n//space complexity - O(m*n) \\n// class Solution {\\n// public:\\n//     long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n//         vector<int> v;\\n//         v.push_back(cost1);\\n//         v.push_back(cost2);\\n        \\n//         int m = v.size();\\n//         int n = total;\\n        \\n//         vector<vector<long long>> dp(m,vector<long long>(n+1,0));\\n        \\n//         for(int i = 0;i < m;i++) dp[i][0] = 0;\\n        \\n//         for(int T = 1; T <= n;T++) dp[0][T] = T/v[0];\\n        \\n//         for(int i = 1; i< m; i++){\\n//             for(int T = 1; T <= n;T++){\\n//                 long long nottake = dp[i - 1][T];\\n        \\n//                 long long take = 0;\\n                \\n//                 if(T >= v[i]) take = 1 + dp[i][T - v[i]];\\n\\n//                 dp[i][T] =  take + nottake;\\n//             }\\n//         }\\n        \\n//         return dp[m-1][n] + 1;\\n//     }\\n// };\\n\\n\\n\\n\\n//Space Optimization\\n//time complexity - O(m*n) [m = 2 , n = total]\\n//space complexity - O(2*n) \\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        vector<int> v;\\n        v.push_back(cost1);\\n        v.push_back(cost2);\\n        \\n        int m = v.size();\\n        int n = total;\\n        \\n        vector<long long> prev(n+1,0),cur(n+1,0);\\n        \\n        for(int i = 0;i < m;i++) prev[0] = 0;\\n        \\n        for(int T = 1; T <= n;T++) prev[T] = T/v[0];\\n        \\n        for(int i = 1; i< m; i++){\\n            for(int T = 1; T <= n;T++){\\n                long long nottake = prev[T];\\n        \\n                long long take = 0;\\n                \\n                if(T >= v[i]) take = 1 + cur[T - v[i]];\\n\\n                cur[T] =  take + nottake;\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[n] + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Recursion\\n//time complexity - Exponential\\n//space complexity - Greater than O(n)\\n// class Solution {\\n// private:\\n//     long long f(int i, int T, vector<int> &v){\\n//         //Base case\\n//         if(T == 0) return 0;\\n//         if(i == 0) {\\n//             return T/v[i];\\n//         }\\n        \\n//         long long nottake = f(i - 1, T , v);\\n        \\n//         long long take = 0;\\n//         if(T >= v[i]) take = 1 + f(i,T - v[i], v);\\n        \\n//         return take + nottake;\\n//     }\\n// public:\\n//     long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n//         vector<int> v;\\n//         v.push_back(cost1);\\n//         v.push_back(cost2);\\n        \\n//         int m = v.size();\\n//         int n = total;\\n        \\n//         return f(m-1,n,v) + 1;\\n//     }\\n// };\\n\\n\\n\\n//Memoization\\n//time complexity - O(m*n) [m = 2 , n = total]\\n//space complexity - O(m*n) + O(n)\\n// class Solution {\\n// private:\\n//     long long f(int i, int T, vector<int> &v,vector<vector<long long>> &dp){\\n//         //Base case\\n//         if(T == 0) return 0;\\n//         if(i == 0) {\\n//             return T/v[i];\\n//         }\\n        \\n//         if(dp[i][T] != -1) return dp[i][T];\\n        \\n//         long long nottake = f(i - 1, T , v,dp);\\n        \\n//         long long take = 0;\\n//         if(T >= v[i]) take = 1 + f(i,T - v[i], v,dp);\\n        \\n//         return dp[i][T] =  take + nottake;\\n//     }\\n// public:\\n//     long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n//         vector<int> v;\\n//         v.push_back(cost1);\\n//         v.push_back(cost2);\\n        \\n//         int m = v.size();\\n//         int n = total;\\n        \\n//         vector<vector<long long>> dp(m,vector<long long>(n+1,-1));\\n        \\n//         return f(m-1,n,v,dp) + 1;\\n//     }\\n// };\\n\\n\\n\\n\\n\\n//Tabulation\\n//time complexity - O(m*n) [m = 2 , n = total]\\n//space complexity - O(m*n) \\n// class Solution {\\n// public:\\n//     long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n//         vector<int> v;\\n//         v.push_back(cost1);\\n//         v.push_back(cost2);\\n        \\n//         int m = v.size();\\n//         int n = total;\\n        \\n//         vector<vector<long long>> dp(m,vector<long long>(n+1,0));\\n        \\n//         for(int i = 0;i < m;i++) dp[i][0] = 0;\\n        \\n//         for(int T = 1; T <= n;T++) dp[0][T] = T/v[0];\\n        \\n//         for(int i = 1; i< m; i++){\\n//             for(int T = 1; T <= n;T++){\\n//                 long long nottake = dp[i - 1][T];\\n        \\n//                 long long take = 0;\\n                \\n//                 if(T >= v[i]) take = 1 + dp[i][T - v[i]];\\n\\n//                 dp[i][T] =  take + nottake;\\n//             }\\n//         }\\n        \\n//         return dp[m-1][n] + 1;\\n//     }\\n// };\\n\\n\\n\\n\\n//Space Optimization\\n//time complexity - O(m*n) [m = 2 , n = total]\\n//space complexity - O(2*n) \\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        vector<int> v;\\n        v.push_back(cost1);\\n        v.push_back(cost2);\\n        \\n        int m = v.size();\\n        int n = total;\\n        \\n        vector<long long> prev(n+1,0),cur(n+1,0);\\n        \\n        for(int i = 0;i < m;i++) prev[0] = 0;\\n        \\n        for(int T = 1; T <= n;T++) prev[T] = T/v[0];\\n        \\n        for(int i = 1; i< m; i++){\\n            for(int T = 1; T <= n;T++){\\n                long long nottake = prev[T];\\n        \\n                long long take = 0;\\n                \\n                if(T >= v[i]) take = 1 + cur[T - v[i]];\\n\\n                cur[T] =  take + nottake;\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[n] + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953946,
                "title": "simplest-solution-o-n-time",
                "content": "<br>\\n\\n* Buy pens with cost1, 2*cost1, 3*cost1, ... total amount\\n* and buy pencils with remanining amount\\n\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        for(int spent = 0; spent <= total; spent += cost1) {\\n            int left = total - spent;\\n            ans += (left / cost2) + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        for(int spent = 0; spent <= total; spent += cost1) {\\n            int left = total - spent;\\n            ans += (left / cost2) + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953805,
                "title": "4-lines-o-n",
                "content": "Consider taking 1 by 1.. upto x (total/cost1) cost1 product \\nthen for rest total take cost2 product\\n```\\nclass Solution {\\n\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long x = total / cost1 , ans = 0;\\n        for (int i = 0; i <= x; i++) \\n            ans += (long) ((total - (i * cost1)) / cost2) + 1;\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long x = total / cost1 , ans = 0;\\n        for (int i = 0; i <= x; i++) \\n            ans += (long) ((total - (i * cost1)) / cost2) + 1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959638,
                "title": "explained-c-python-easy-solution",
                "content": "To approach this problem we need to follow certain simple steps:\\n1. Take an ans variable to store result.\\n2. We can buy pen/ pencil in various number of ways from (0 to total//cost), So we need to calculate all the combination of one article with other. For this we will get a for loop from 0 to total/cost.\\n3. Then for each value we ca calculate the number of ways to buy other item, i.e also from 0 to remaining_amount/cost.\\n4. To calculate that we can just calculate the sum of n natural numbers +1 for 0.\\n\\n## c++ code:\\n```\\n\\t\\tint result=0;\\n        for (int i =0; i<=total/cost1;i++){\\n            int remaining_amount=total-i*cost1;\\n            result+=int(remaining_amount/cost2)+1;\\n        }\\n        return result;\\n```\\n\\n## python code:\\n```\\n\\t\\tresult=0\\n        for i in range((total//cost1)+1):\\n            remaining_amount = total - (i * cost1)\\n            result += (remaining_amount // cost2)+1\\n        return result\\n```\\n\\nTime complexity: O(N)\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\n\\t\\tint result=0;\\n        for (int i =0; i<=total/cost1;i++){\\n            int remaining_amount=total-i*cost1;\\n            result+=int(remaining_amount/cost2)+1;\\n        }\\n        return result;\\n```\n```\\n\\t\\tresult=0\\n        for i in range((total//cost1)+1):\\n            remaining_amount = total - (i * cost1)\\n            result += (remaining_amount // cost2)+1\\n        return result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1954153,
                "title": "simple-math-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        int pens = total / cost1;\\n        for(int i = 0; i <= pens; i++) {\\n            int b = (total - (cost1*i))/cost2;\\n            if(b<=0) \\n                ans+=1;\\n            else\\n                ans += b + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        int pens = total / cost1;\\n        for(int i = 0; i <= pens; i++) {\\n            int b = (total - (cost1*i))/cost2;\\n            if(b<=0) \\n                ans+=1;\\n            else\\n                ans += b + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953873,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        int s=cost1>cost2?cost1:cost2;\\n        int r=s==cost1?cost2:cost1;\\n        for(int i=0;i<=total;i+=s){\\n            if(i==0){\\n                ans+=(total/r)+1;\\n            }else{\\n                if(total-i==0)ans++;\\n                else ans+=(total-i)/r+1;                \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        int s=cost1>cost2?cost1:cost2;\\n        int r=s==cost1?cost2:cost1;\\n        for(int i=0;i<=total;i+=s){\\n            if(i==0){\\n                ans+=(total/r)+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1953817,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int i = 0;// i denotes the no. of pens bought\\n        long long ans = 0;\\n        for(; i * cost1 <= total; i++) {\\n            int remainingCost = total - (i * cost1);\\n            ans = ans + (remainingCost / cost2) + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int i = 0;// i denotes the no. of pens bought\\n        long long ans = 0;\\n        for(; i * cost1 <= total; i++) {\\n            int remainingCost = total - (i * cost1);\\n            ans = ans + (remainingCost / cost2) + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953702,
                "title": "time-o-n-c-solution-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        for(int i=0;i<=total;i+=cost1)\\n        {\\n            ans+=1+(total-i)/cost2;\\n        }\\n     return ans;   \\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        for(int i=0;i<=total;i+=cost1)\\n        {\\n            ans+=1+(total-i)/cost2;\\n        }\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964250,
                "title": "math-solution-with-explanation",
                "content": "To solve this solution, we have to see that from the example given in the problem description that **we are returning the number of pencils we can get for every number of pens**:\\n\\n```\\nInput: total = 20, cost1 = 10, cost2 = 5\\nOutput: 9\\n**Explanation:** The price of a pen is 10 and a pencils price is 5.\\n- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\\n- If you buy 1 pen, you can buy 0, 1, or 2 pencils.\\n- If you buy 2 pens, you cannot buy any pencils.\\nThe total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\\n```\\n\\nIn this example, for `0` pens, we are getting `5` combinations of pencils, for `1` pen, we are getting `3` combinations of pencils, and for `2` pens, we are getting `0` combinations of pencils but `1` pen. So we have `5 + 3 + 1 = 9`, our result.\\n\\nSo to solve this problem, we can start with a basic equation:\\n\\n`n * x + m * y = total`\\n\\nWhere `x = cost1`, `y = cost2`, `n = number of pens`, `m = number of pencils`.\\n\\nNow, all we have to do is solve for `m` because we want the number of pencils:\\n\\n`n * x + m * y = total`\\n\\n`m * y = total - n * x`\\n\\n`m = (total - n * x) / y`\\n\\nSo we can add `(total - n * x) / y` to `res` for `n <= total / cost1`.\\n\\nBut wait, when we try to use this equation `res += (total - cost1 * i) / cost2`, we only `m - 1` combinations because we are not finding the combinations with `0` pencils. This can be shown using the previous example: \\n\\n`Input: total = 20, cost1 = 10, cost2 = 5`\\n\\nIf we try to do `res += (total - cost1 * i) / cost2` then we have:\\n\\n* For `0` pens we can buy `1, 2, 3, or 4` pencils (4 combinations)\\n* For `1` pens we can buy `1 or 2` pencils (2 combinations)\\n* For `2` pens we can not buy pencils (0 combinations)\\n\\nIf we sum up our results `4 + 2 + 0 = 6` we can see that this is not our expected answer. So we can do `res += (total - cost1 * i) / cost2 + 1` to account for our extra combinations. \\n\\n``` go\\nfunc waysToBuyPensPencils(total int, cost1 int, cost2 int) int64 {\\n    res := int64(0)\\n    \\n    for i := 0; i <= total / cost1; i++ {\\n        res += int64(total - (cost1 * i)) / int64(cost2) + 1\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nInput: total = 20, cost1 = 10, cost2 = 5\\nOutput: 9\\n**Explanation:** The price of a pen is 10 and a pencils price is 5.\\n- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\\n- If you buy 1 pen, you can buy 0, 1, or 2 pencils.\\n- If you buy 2 pens, you cannot buy any pencils.\\nThe total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\\n```\n``` go\\nfunc waysToBuyPensPencils(total int, cost1 int, cost2 int) int64 {\\n    res := int64(0)\\n    \\n    for i := 0; i <= total / cost1; i++ {\\n        res += int64(total - (cost1 * i)) / int64(cost2) + 1\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958437,
                "title": "can-we-do-it-in-o-log-total",
                "content": "I\\'ve posted an [O(sqrt(total)) solution](https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/discuss/1955208/O(sqrt(total))-Python-0.21-ms-JavaC%2B%2B-0-ms) but I\\'m convinced we can do it in O(log(total)). And that\\'s just for computing `gcd(cost1, cost2)`, otherwise it should be O(1).\\n\\nThe answer is *almost* `floor(total/cost1+1) * floor(total/cost2+1) / 2`, and this Python code which I derived from that with adjustments passes the first 118 test cases before it fails one. \\n\\n```python\\ndef waysToBuyPensPencils(_, total, cost1, cost2):\\n\\n    # Handle special cases (ensures neither cost exceeds the total)\\n    if cost1 > total:\\n        return total // cost2 + 1\\n    if cost2 > total:\\n        return total // cost1 + 1\\n\\n    # Divide out the common unit (makes the costs coprime)\\n    g = gcd(cost1, cost2)\\n    a = cost1 // g\\n    b = cost2 // g\\n    n = total // g\\n\\t\\n\\t# Almost correct formula\\n    return (n+a+b+1) * n // (2*a*b) + 1\\n```\\nI need to do other things now, but perhaps this can motivate someone else to get it done.",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\ndef waysToBuyPensPencils(_, total, cost1, cost2):\\n\\n    # Handle special cases (ensures neither cost exceeds the total)\\n    if cost1 > total:\\n        return total // cost2 + 1\\n    if cost2 > total:\\n        return total // cost1 + 1\\n\\n    # Divide out the common unit (makes the costs coprime)\\n    g = gcd(cost1, cost2)\\n    a = cost1 // g\\n    b = cost2 // g\\n    n = total // g\\n\\t\\n\\t# Almost correct formula\\n    return (n+a+b+1) * n // (2*a*b) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1954398,
                "title": "c-faster-than-100-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/c54c1978-8ab6-491c-825b-5b7a73934c2e_1650133550.5919044.png)\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        ll ans = 0;\\n        if (cost2 < cost1) swap(cost1, cost2);\\n        for (int i = 0; i <= total; i += cost1) {\\n            ans += (total - i)/cost2 + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease **Upvote** if you like my solution/approach.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        ll ans = 0;\\n        if (cost2 < cost1) swap(cost1, cost2);\\n        for (int i = 0; i <= total; i += cost1) {\\n            ans += (total - i)/cost2 + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954365,
                "title": "java-100-in-time-and-space",
                "content": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if ( cost1 > total && cost2 > total ){\\n            return 1;\\n        }\\n        long count = 0;\\n        int a = 0;\\n        while ( total-(a*cost1) >= 0 ) {\\n                count += (( total - a*cost1) / cost2 )+ 1;\\n                a++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if ( cost1 > total && cost2 > total ){\\n            return 1;\\n        }\\n        long count = 0;\\n        int a = 0;\\n        while ( total-(a*cost1) >= 0 ) {\\n                count += (( total - a*cost1) / cost2 )+ 1;\\n                a++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953867,
                "title": "java-intuition-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If total is < min(cost1, cost2) return 1 as we can only get 0 and 0\\n        2. Determine min of the two costs. Loop from i = 0 to i * min < total,\\n           determining how many other items you can get if you get i items of min cost\\n           EG: i = 0: 0 pens, and total - 0 / pencils + 1 ( + 1 to catch the case of buying 0 pencils)\\n               i = 1: 1 pens and (20-5) / 10 pencils\\n               i = 2: 2 pens and (20- 2 * 5) / 10 pencils\\n        3. Return number of ways.       \\n    */\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if (total < Math.min(cost1, cost2)) {\\n            return 1;\\n        }\\n        long ways = 0;\\n        int minCost = Math.min(cost1, cost2);\\n        int maxCost = Math.max(cost1, cost2);\\n        int rounds = 0;\\n        while(rounds * minCost <= total) {\\n            ways += ((total - (rounds * minCost)) / maxCost) + 1;\\n            rounds++;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If total is < min(cost1, cost2) return 1 as we can only get 0 and 0\\n        2. Determine min of the two costs. Loop from i = 0 to i * min < total,\\n           determining how many other items you can get if you get i items of min cost\\n           EG: i = 0: 0 pens, and total - 0 / pencils + 1 ( + 1 to catch the case of buying 0 pencils)\\n               i = 1: 1 pens and (20-5) / 10 pencils\\n               i = 2: 2 pens and (20- 2 * 5) / 10 pencils\\n        3. Return number of ways.       \\n    */\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if (total < Math.min(cost1, cost2)) {\\n            return 1;\\n        }\\n        long ways = 0;\\n        int minCost = Math.min(cost1, cost2);\\n        int maxCost = Math.max(cost1, cost2);\\n        int rounds = 0;\\n        while(rounds * minCost <= total) {\\n            ways += ((total - (rounds * minCost)) / maxCost) + 1;\\n            rounds++;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953754,
                "title": "simple-greedy-solution-o-n-c",
                "content": "```\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(cost1>total && cost2>total) return 1;\\n        long long ans=0;\\n        int l1=max(cost1,cost2);\\n        int l2=min(cost1,cost2);\\n        int n=total/l1;\\n        while(n>=0){\\n            int amt = total-(n*l1);\\n            int temp=(amt/l2)+1;\\n            ans+=temp;\\n            n--;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(cost1>total && cost2>total) return 1;\\n        long long ans=0;\\n        int l1=max(cost1,cost2);\\n        int l2=min(cost1,cost2);\\n        int n=total/l1;\\n        while(n>=0){\\n            int amt = total-(n*l1);\\n            int temp=(amt/l2)+1;\\n            ans+=temp;\\n            n--;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1953753,
                "title": "c-easy-to-understand-linear-efficient-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        ll ans=0;\\n        ll n1=total/cost1;\\n        for(int i=0;i<=n1;i++)\\n        {\\n            ll left=total-cost1*i;\\n            ans+=left/cost2;\\n            ans++;   \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        ll ans=0;\\n        ll n1=total/cost1;\\n        for(int i=0;i<=n1;i++)\\n        {\\n            ll left=total-cost1*i;\\n            ans+=left/cost2;\\n            ans++;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390981,
                "title": "java-solution-easy-to-understand",
                "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long count = 0;\\n        long curr = 0;\\n        for(int i = 0;i<=total/cost1;i++){\\n            curr = total-(cost1*i);\\n            count += curr/cost2 + 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long count = 0;\\n        long curr = 0;\\n        for(int i = 0;i<=total/cost1;i++){\\n            curr = total-(cost1*i);\\n            count += curr/cost2 + 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262937,
                "title": "very-clear-solution-c-short",
                "content": "\\n\\n# Approach\\nFind the number of pens we can buy. Then for each pen calculate thenumber of pencils we can buy.\\nThe extra +1 is done for 0 pencils.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        int pen=total/cost1;\\n        for(int i=0;i<=pen;i++){\\n            int t=total;\\n            t=t-(cost1*i);\\n            int pencil=t/cost2;\\n            ans+=pencil+1;\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        int pen=total/cost1;\\n        for(int i=0;i<=pen;i++){\\n            int t=total;\\n            t=t-(cost1*i);\\n            int pencil=t/cost2;\\n            ans+=pencil+1;\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223092,
                "title": "simple-maths-beats-98-c",
                "content": "\\n```\\n\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(total < cost1 && total < cost2) return 1;            // 0 pen 0 pencil\\n        long long ans = 0;\\n\\t\\t// keeping cost1 as maximum so that we have minimum opperations later \\n        if(cost2 > cost1) swap(cost2, cost1);\\n        int n = (total/cost1)+ 1;\\n\\t\\t\\n\\t\\t// Calculate the number of  pens you can buy for each number of pencils\\n\\t\\t// for 0 pens -> total_pencil = total_cost / cost_of_pencil +1\\n\\t\\t// for 1 pen -> total_pencil = (total_cost-cost_of_1pen) / cost_of_pencil +1\\n\\t\\t// dry run once... you\\'ll get it\\n        for(int i = 0; i < n; i++){\\n            ans += total / cost2 + 1;\\n            total -= cost1;\\n        }\\n        // ans += n; (if we don\\'t add 1 in each step we can do +n instead)\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(total < cost1 && total < cost2) return 1;            // 0 pen 0 pencil\\n        long long ans = 0;\\n\\t\\t// keeping cost1 as maximum so that we have minimum opperations later \\n        if(cost2 > cost1) swap(cost2, cost1);\\n        int n = (total/cost1)+ 1;\\n\\t\\t\\n\\t\\t// Calculate the number of  pens you can buy for each number of pencils\\n\\t\\t// for 0 pens -> total_pencil = total_cost / cost_of_pencil +1\\n\\t\\t// for 1 pen -> total_pencil = (total_cost-cost_of_1pen) / cost_of_pencil +1\\n\\t\\t// dry run once... you\\'ll get it\\n        for(int i = 0; i < n; i++){\\n            ans += total / cost2 + 1;\\n            total -= cost1;\\n        }\\n        // ans += n; (if we don\\'t add 1 in each step we can do +n instead)\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222385,
                "title": "1line-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int x, int a, int b) {\\n        long long int ans = 0;\\n        for(int i = 0; i <= x/a; i++){\\n            ans += (x-(a*i))/b+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int x, int a, int b) {\\n        long long int ans = 0;\\n        for(int i = 0; i <= x/a; i++){\\n            ans += (x-(a*i))/b+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097423,
                "title": "python-solution-using-lambda-function-easy-to-understand-for-begineers",
                "content": "```\\nfrom math import floor\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ans = 0\\n        y = lambda x: (total-x*cost1)/cost2\\n        for i in range(total+1):\\n            c = floor(y(i))\\n            if c>=0:\\n                ans += c+1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nfrom math import floor\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ans = 0\\n        y = lambda x: (total-x*cost1)/cost2\\n        for i in range(total+1):\\n            c = floor(y(i))\\n            if c>=0:\\n                ans += c+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827218,
                "title": "beginner-friendly-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        //BEGINNER FRIENDLY APPROACH\\n        long long ways = 0;\\n        long long penscost = 0;\\n        while(penscost <= total) {\\n            long long remainingAmount = total - penscost;\\n            long long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }\\n        return ways;\\n\\n         // pens*cost1 + pencils*cost2 = total\\n         //Short 3 Liner Solution\\n    //     long long res = 0;\\n    //     for (int cnt = 0; cnt * cost1 <= total; ++cnt) \\n    //         res += (total - cnt * cost1) / cost2 + 1;\\n    //     return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        //BEGINNER FRIENDLY APPROACH\\n        long long ways = 0;\\n        long long penscost = 0;\\n        while(penscost <= total) {\\n            long long remainingAmount = total - penscost;\\n            long long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }\\n        return ways;\\n\\n         // pens*cost1 + pencils*cost2 = total\\n         //Short 3 Liner Solution\\n    //     long long res = 0;\\n    //     for (int cnt = 0; cnt * cost1 <= total; ++cnt) \\n    //         res += (total - cnt * cost1) / cost2 + 1;\\n    //     return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731718,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ways = 0;\\n        long long penscost = 0;\\n        while(penscost <= total) {\\n            long long remainingAmount = total - penscost;\\n            long long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }\\n        return ways;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ways = 0;\\n        long long penscost = 0;\\n        while(penscost <= total) {\\n            long long remainingAmount = total - penscost;\\n            long long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }\\n        return ways;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437004,
                "title": "python-simple-for-loop",
                "content": "```\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        cnt = 0\\n        for i in range(total // cost1 + 1):\\n            cnt += (total - i * cost1) // cost2 + 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        cnt = 0\\n        for i in range(total // cost1 + 1):\\n            cnt += (total - i * cost1) // cost2 + 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2123208,
                "title": "python-easy-solution",
                "content": "For better understanding remove the comments before the print statements and then run ur code, u will understand the ques and approach in much better way.\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        x=max(cost1,cost2)\\n        y=min(cost1,cost2)\\n        z=total//y\\n        count=1\\n        for i in range(z):\\n            a=total\\n            #print(count)\\n            a-=(y*i)\\n            z1=a//x+1\\n            count+=z1\\n            #print(count,z1)\\n        \\n        return count\\n```\\nIf u understood the code then plz.......UPVOTE...........Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        x=max(cost1,cost2)\\n        y=min(cost1,cost2)\\n        z=total//y\\n        count=1\\n        for i in range(z):\\n            a=total\\n            #print(count)\\n            a-=(y*i)\\n            z1=a//x+1\\n            count+=z1\\n            #print(count,z1)\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967233,
                "title": "math-closed-form-o-1-answer-in-some-cases-beats-100",
                "content": "Here\\'s a dump of my code including comments:\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        //return (total/cost1 + 1)*(1 + total/cost2) - (cost1/cost2)*(total/cost1)*(1 + total/cost1)/2;\\n        if (cost1 < cost2) {\\n            return waysToBuyPensPencils(total, cost2, cost1);\\n        }\\n        if (cost1 % cost2 == 0) {\\n            return ((long)(total/cost1 + 1)*(1 + total/cost2)) - (long)((cost1/cost2)*((long)(total/cost1)*(1 + total/cost1)/2));\\n        }\\n        int sum = 0;\\n        for(int numCost1=0; numCost1<=total/cost1; numCost1++) {\\n            sum += 1 + (total - numCost1*cost1)/cost2;\\n        }\\n        return sum;\\n    }\\n}\\n/*\\nforgot what knapsack is but remainds me of that. some budget given by total.\\n\\nsay buy I pens and J pencils. cost AI+BJ. not like we can get that with other stuff\\n(unless maybe costs same, or A = B)\\nso maybe knapsack type stuff only shines when 3+.\\nhmm edge cases A=0 or B = 0 or A/B > total\\n\\nhmmm.. ok consider if A != B\\nthen one is larger, say A.\\nbuy 0 A, then can buy up to total / B. and add 1 for the 0 of B case.\\nthen buy 1 A, so have (total - A) to spend so 1 + (total - A)/B\\nthen buy 2 A, so have (total - 2A)/B + 1\\n\\n\\nso total/B + 1 + (total - A)/B + 1 + (total -2A)/B + 1 + .... (total-total/A)/B + 1\\nso (total/A + 1) cases of buying 0, 1 ,...nums A\\nso for the 0 B case, that\\'s total/A + 1 1\\'s or ways = total/A + 1.\\nand (total/B)*(total/A + 1)\\n\\n-A/B + -2A/B + -3A/B + ...-NA/B\\n\\n(-A/B)(1 + 2 + ...+ total/A) and recall 1 + ... + n = n(n+1)/2\\nso (-A/B)*(total/A)(1+ total/A)/2\\n```\\nBasically I used the fact that sum of ```1 + 2 + ... + n = (n)(n + 1)/2```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        //return (total/cost1 + 1)*(1 + total/cost2) - (cost1/cost2)*(total/cost1)*(1 + total/cost1)/2;\\n        if (cost1 < cost2) {\\n            return waysToBuyPensPencils(total, cost2, cost1);\\n        }\\n        if (cost1 % cost2 == 0) {\\n            return ((long)(total/cost1 + 1)*(1 + total/cost2)) - (long)((cost1/cost2)*((long)(total/cost1)*(1 + total/cost1)/2));\\n        }\\n        int sum = 0;\\n        for(int numCost1=0; numCost1<=total/cost1; numCost1++) {\\n            sum += 1 + (total - numCost1*cost1)/cost2;\\n        }\\n        return sum;\\n    }\\n}\\n/*\\nforgot what knapsack is but remainds me of that. some budget given by total.\\n\\nsay buy I pens and J pencils. cost AI+BJ. not like we can get that with other stuff\\n(unless maybe costs same, or A = B)\\nso maybe knapsack type stuff only shines when 3+.\\nhmm edge cases A=0 or B = 0 or A/B > total\\n\\nhmmm.. ok consider if A != B\\nthen one is larger, say A.\\nbuy 0 A, then can buy up to total / B. and add 1 for the 0 of B case.\\nthen buy 1 A, so have (total - A) to spend so 1 + (total - A)/B\\nthen buy 2 A, so have (total - 2A)/B + 1\\n\\n\\nso total/B + 1 + (total - A)/B + 1 + (total -2A)/B + 1 + .... (total-total/A)/B + 1\\nso (total/A + 1) cases of buying 0, 1 ,...nums A\\nso for the 0 B case, that\\'s total/A + 1 1\\'s or ways = total/A + 1.\\nand (total/B)*(total/A + 1)\\n\\n-A/B + -2A/B + -3A/B + ...-NA/B\\n\\n(-A/B)(1 + 2 + ...+ total/A) and recall 1 + ... + n = n(n+1)/2\\nso (-A/B)*(total/A)(1+ total/A)/2\\n```\n```1 + 2 + ... + n = (n)(n + 1)/2```",
                "codeTag": "Java"
            },
            {
                "id": 1962778,
                "title": "python-easy-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        if total < cost1 and total < cost2:\\n            return 1\\n        ways = 0\\n        if cost1 > cost2:\\n            for i in range(0, (total // cost1)+1):\\n                rem = total - (i * cost1)\\n                ways += (rem // cost2) + 1\\n            return ways\\n        for i in range(0, (total // cost2)+1):\\n            rem = total - (i * cost2)\\n            ways += (rem // cost1) + 1\\n        return ways",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        if total < cost1 and total < cost2:\\n            return 1\\n        ways = 0\\n        if cost1 > cost2:\\n            for i in range(0, (total // cost1)+1):\\n                rem = total - (i * cost1)\\n                ways += (rem // cost2) + 1\\n            return ways\\n        for i in range(0, (total // cost2)+1):\\n            rem = total - (i * cost2)\\n            ways += (rem // cost1) + 1\\n        return ways",
                "codeTag": "Java"
            },
            {
                "id": 1961917,
                "title": "c-short-simple-code",
                "content": "```\\nclass Solution {\\n    long long sum=0;\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        while(total>=0){sum+=(total/cost1)+1;   total-=cost2;}\\n        return sum;\\n    }\\n};\\n```\\nDo upvote it it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    long long sum=0;\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        while(total>=0){sum+=(total/cost1)+1;   total-=cost2;}\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961654,
                "title": "c-100-faster-solution",
                "content": "class Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        int x=0;\\n        long long ans=0;\\n        while(x<=total){\\n            ans+=(total-x)/cost2+1;\\n            x+=cost1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        int x=0;\\n        long long ans=0;\\n        while(x<=total){\\n            ans+=(total-x)/cost2+1;\\n            x+=cost1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1960636,
                "title": "literally-faster-than-100-percent-and-memory-optimization-also-100-perecnt",
                "content": "Runtime: 22 ms, faster than 100.00% of C++ online submissions for Number of Ways to Buy Pens and Pencils.\\nMemory Usage: 5.9 MB, less than 100.00% of C++ online submissions for Number of Ways to Buy Pens and Pencils.\\nNext challenges:\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        for(int i=0;i<=total;i+=cost1)\\n        {\\n            if(i==0)\\n                ans+=(total/cost2)+1;\\n            else \\n                ans+=((total-i)/cost2)+1;\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        for(int i=0;i<=total;i+=cost1)\\n        {\\n            if(i==0)\\n                ans+=(total/cost2)+1;\\n            else \\n                ans+=((total-i)/cost2)+1;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1957895,
                "title": "simple-python-using-dp-framework-with-explanation",
                "content": "Here is a solution using standard dynamic programming.\\nInitialise DP Array with value 1.\\nThis is because we can choose not to buy anything at every stage.\\n\\nOn each iteration , F(i) = F(i-c)+F(i)\\n\\nPlease **Upvote** if you like the solution!\\n\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        dp=[1]*(total+1)\\n        dp[0]=1\\n        \\n        for coin in [cost1, cost2]:\\n            for i in range(coin, total+1):\\n                dp[i]+=dp[i-coin]\\n                \\n        return dp[-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        dp=[1]*(total+1)\\n        dp[0]=1\\n        \\n        for coin in [cost1, cost2]:\\n            for i in range(coin, total+1):\\n                dp[i]+=dp[i-coin]\\n                \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954367,
                "title": "simple-maths-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long int ans=0;\\n        int i=0;\\n        if(total<cost1 && total<cost2){\\n               return 1;\\n        }\\n            \\n        while(total>=0){\\n            ans+=(total/cost2)+1;\\n            total=total-cost1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long int ans=0;\\n        int i=0;\\n        if(total<cost1 && total<cost2){\\n               return 1;\\n        }\\n            \\n        while(total>=0){\\n            ans+=(total/cost2)+1;\\n            total=total-cost1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953942,
                "title": "do-what-said-in-question-simple-implementation",
                "content": "I take pen=0, pen =1 , pen =2 , till total >0 and find correspondin pencil \\n\\ncode\\n\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        long long ans=0;\\n        \\n       long long pen=0,pencil=0;\\n        long long T=total;\\n        while(total>=0){\\n            \\n            \\n             ans+=( total/cost2 +1);\\n             pen++;\\n             total=T- pen*cost1;\\n          \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        long long ans=0;\\n        \\n       long long pen=0,pencil=0;\\n        long long T=total;\\n        while(total>=0){\\n            \\n            \\n             ans+=( total/cost2 +1);\\n             pen++;\\n             total=T- pen*cost1;\\n          \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953935,
                "title": "easy-to-understand-clear-python-solution-o-n-time-o-1-space",
                "content": "```\\n# Approach 1: \\n# Time:  O(total//max(cost1,cost2))\\n# Space: O(1)\\n\\ndef waysToBuyPensPencils(total, cost1, cost2):\\n    \"\"\"\\n    :type total: int\\n    :type cost1: int\\n    :type cost2: int\\n    :rtype: int\\n    \"\"\"\\n\\n    max_cost = max(cost1, cost2)\\n    min_cost = min(cost1, cost2)\\n\\n    orig_total, cnt = total, 0\\n    \\n    for i in range(total//max_cost+1):\\n        total -= max_cost*i\\n        if total >= 0:\\n            cnt += total//min_cost+1\\n            total = orig_total\\n\\n    return cnt\\n```\\n",
                "solutionTags": [],
                "code": "```\\n# Approach 1: \\n# Time:  O(total//max(cost1,cost2))\\n# Space: O(1)\\n\\ndef waysToBuyPensPencils(total, cost1, cost2):\\n    \"\"\"\\n    :type total: int\\n    :type cost1: int\\n    :type cost2: int\\n    :rtype: int\\n    \"\"\"\\n\\n    max_cost = max(cost1, cost2)\\n    min_cost = min(cost1, cost2)\\n\\n    orig_total, cnt = total, 0\\n    \\n    for i in range(total//max_cost+1):\\n        total -= max_cost*i\\n        if total >= 0:\\n            cnt += total//min_cost+1\\n            total = orig_total\\n\\n    return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953911,
                "title": "c-simple-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        if(cost1 < cost2)   swap(cost1,cost2);\\n        \\n        int totalPossibleBuys = (total/cost1);\\n        for(int i=0;i<=totalPossibleBuys;i++){\\n            int newCost = total - (cost1 * i);\\n            if(newCost >= 0){\\n                ans += (newCost/cost2) + 1;                \\n            }\\n        }\\n        \\n        if(ans == 0)    return 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        if(cost1 < cost2)   swap(cost1,cost2);\\n        \\n        int totalPossibleBuys = (total/cost1);\\n        for(int i=0;i<=totalPossibleBuys;i++){\\n            int newCost = total - (cost1 * i);\\n            if(newCost >= 0){\\n                ans += (newCost/cost2) + 1;                \\n            }\\n        }\\n        \\n        if(ans == 0)    return 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953859,
                "title": "c-3-lines",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nTry using pen `cnt = 0,1,2,...` times. For the remainder `remainder = total - cnt * a` money, there are `remainder / b + 1` ways of using pencil.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/\\n// Author: github.com/lzl124631x\\n// Time: O(T/A)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int a, int b) {\\n        long ans = 0;\\n        for (int cnt = 0; cnt * a <= total; ++cnt) {\\n            ans += (total - cnt * a) / b + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nOr\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/\\n// Author: github.com/lzl124631x\\n// Time: O(T/A)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int a, int b) {\\n        long ans = 0;\\n        for (; total >= 0; total -= a) ans += total / b + 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/\\n// Author: github.com/lzl124631x\\n// Time: O(T/A)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int a, int b) {\\n        long ans = 0;\\n        for (int cnt = 0; cnt * a <= total; ++cnt) {\\n            ans += (total - cnt * a) / b + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/\\n// Author: github.com/lzl124631x\\n// Time: O(T/A)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int a, int b) {\\n        long ans = 0;\\n        for (; total >= 0; total -= a) ans += total / b + 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953775,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long res=0,a=(max(cost1,cost2)),b=min(cost1,cost2);\\n    \\n        long long n=total/a;\\n        \\n        \\n        \\n        for(long long i=0;i<=n;i++)\\n        {\\n            long long x=total-i*a;\\n            res+=x/b;\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long res=0,a=(max(cost1,cost2)),b=min(cost1,cost2);\\n    \\n        long long n=total/a;\\n        \\n        \\n        \\n        for(long long i=0;i<=n;i++)\\n        {\\n            long long x=total-i*a;\\n            res+=x/b;\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953634,
                "title": "straightforward-java",
                "content": "Approach:\\nTry to buy pen first, and then pencil with the remaining money.\\nTry to buy 0,1,2 ... x pens and calculate max, the maximum number of pencils which can be bought from the remaining amount.\\nNumber of pencils can vary from 0 to max for each (0-x) pens. Answer is the sum of these.\\n    \\n```\\nclass Solution\\n{\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2)\\n    {\\n        long ret = 0;\\n        for(int i = 0; i <= total; i += cost1) // i is the cost of pens\\n        {\\n            int rem = total - i; // remaining money\\n            ret += ((rem/cost2)+1);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2)\\n    {\\n        long ret = 0;\\n        for(int i = 0; i <= total; i += cost1) // i is the cost of pens\\n        {\\n            int rem = total - i; // remaining money\\n            ret += ((rem/cost2)+1);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930717,
                "title": "recursion-memoization-optimized",
                "content": "**Up Vote if Helps**![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n\\n________________________________\\n\\n# Recursion\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int[] cost={cost1,cost2};\\n        return 1+ waysToBuyPensPencils(total,cost,0);\\n    }\\n    public long waysToBuyPensPencils(int total, int[] cost, int si){\\n        if(si==cost.length-1){\\n            return total/cost[si];\\n        }\\n        if(total==0){\\n            return 0;\\n        }\\n        long pick=0;\\n        long notPick=waysToBuyPensPencils(total,cost,si+1);\\n        if(total-cost[si]>=0){\\n           pick = 1 + waysToBuyPensPencils(total-cost[si],cost,si);\\n        }\\n        return pick+notPick;\\n    }\\n}\\n```\\n\\n________________________________\\n\\n\\n# Memoization\\n```\\nclass Solution {\\n    Long[][] memo;\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        memo = new Long[total+1][2];\\n        int[] cost={cost1,cost2};\\n        return 1+ waysToBuyPensPencils(total,cost,0);\\n    }\\n    public long waysToBuyPensPencils(int total, int[] cost, int si){\\n        if(si==cost.length-1){\\n            return total/cost[si];\\n        }\\n        if(total==0){\\n            return 0;\\n        }\\n        if(memo[total][si]!=null){\\n            return memo[total][si];\\n        }\\n        long pick=0;\\n        long notPick=waysToBuyPensPencils(total,cost,si+1);\\n        if(total-cost[si]>=0){\\n           pick = 1 + waysToBuyPensPencils(total-cost[si],cost,si);\\n        }\\n        return memo[total][si] = pick+notPick;\\n    }\\n}\\n```\\n\\n________________________________\\n\\n\\n# Optimization\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long waysToBuy=0;\\n        int waystoBuyPen=total/cost1;\\n        for(int i=0; i<=waystoBuyPen ; i++){\\n            waysToBuy += 1+ (total-cost1*i)/cost2;\\n        }\\n        return waysToBuy;\\n    }\\n}\\n```\\n\\n________________________________\\n\\n**Upvote if helps**\\n![image.png](https://assets.leetcode.com/users/images/f18ccf7b-bb7d-4a8e-8622-2f0acbd705cc_1683886081.2272806.png)\\n\\n________________________________\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int[] cost={cost1,cost2};\\n        return 1+ waysToBuyPensPencils(total,cost,0);\\n    }\\n    public long waysToBuyPensPencils(int total, int[] cost, int si){\\n        if(si==cost.length-1){\\n            return total/cost[si];\\n        }\\n        if(total==0){\\n            return 0;\\n        }\\n        long pick=0;\\n        long notPick=waysToBuyPensPencils(total,cost,si+1);\\n        if(total-cost[si]>=0){\\n           pick = 1 + waysToBuyPensPencils(total-cost[si],cost,si);\\n        }\\n        return pick+notPick;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Long[][] memo;\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        memo = new Long[total+1][2];\\n        int[] cost={cost1,cost2};\\n        return 1+ waysToBuyPensPencils(total,cost,0);\\n    }\\n    public long waysToBuyPensPencils(int total, int[] cost, int si){\\n        if(si==cost.length-1){\\n            return total/cost[si];\\n        }\\n        if(total==0){\\n            return 0;\\n        }\\n        if(memo[total][si]!=null){\\n            return memo[total][si];\\n        }\\n        long pick=0;\\n        long notPick=waysToBuyPensPencils(total,cost,si+1);\\n        if(total-cost[si]>=0){\\n           pick = 1 + waysToBuyPensPencils(total-cost[si],cost,si);\\n        }\\n        return memo[total][si] = pick+notPick;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long waysToBuy=0;\\n        int waystoBuyPen=total/cost1;\\n        for(int i=0; i<=waystoBuyPen ; i++){\\n            waysToBuy += 1+ (total-cost1*i)/cost2;\\n        }\\n        return waysToBuy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807655,
                "title": "c-iterative-logarithmic-runtime-constant-space-beats-100",
                "content": "# Intuition\\nThe simple solution would be something like this:\\n# Code\\n```\\nlong long result = 0;\\nwhile (total >= 0) {\\n    result += total / cost2 + 1;\\n    total -= cost1;\\n}\\nreturn result;\\n```\\nIt calculates for each number of item 1 the possible number of item 2 and sums the results. The worst case execution time would be $$O(total / max(cost1, cost2))$$ if we optimize by subtracting the greatest of $$cost1$$ and $$cost2$$ from $$total$$, but it is still linear (proportional to $$total$$) in the worst case.\\n\\nCan we do faster? It turns out yes. \\n\\nThe problem is equivalent to a geometrical problem of finding the number of discrete points that satisfy these conditions: \\n1. $$cost1 * x + cost2 * y \\\\le\\\\ total$$\\n2. $$x \\\\ge\\\\ 0$$\\n3. $$y \\\\ge\\\\ 0$$\\n4. $$x$$ is a whole number\\n5. $$y$$ is a whole number\\n\\nFor $$11 x\\\\ + 17y \\\\le\\\\ 40$$ the graphical representation will be like this:\\n![Capture.PNG](https://assets.leetcode.com/users/images/fc121c79-f11d-4caf-8956-53f6e2ad8244_1690155260.5088198.png)\\n\\nThe red trianlge contains 8 points (including the ones that touch its sides) that have integer (whole) coordinates.\\n\\nSo how can we quickly find the number of such points in any triangle?\\n# Approach\\n\\nWe can calculate the total amount of points by taking the advantage of the fact that we can calculate the number of the points in a triangle with legs $$a$$ and $$k*a$$ in a constant amount of time, where $$k$$ is a whole number and $$a$$ is a positive number (can be non whole number too).\\n\\nLet\\'s consider a trianlge with $$k = 2$$:\\n![Capture3.PNG](https://assets.leetcode.com/users/images/6eb73038-6be8-4ebe-9bd1-3b946b2a4ca1_1690156773.5017366.png)\\n\\nWe can easily calculate the number of points within a constant amount of time with the help of arithmetic progression, since every next (upper) row has $$k$$ (in this example 2) less points than the previous one and we can calculate the number of elements and the points in the bottom row in a constant amount of time by integer division / rounding.\\n\\nOK, but not all cases will be triangles with legs of $$a$$ and $$a * k$$, so how can we count for any triangle? Yes, not all triangles are like this, but we can extract such triangle from any triangle and transform the remaing figure to a smaller triangle and repeat this process until the remaing figure is small enought to calculate its points in a constant amount of time. \\n\\nThis is how it works:\\n![Capture4.PNG](https://assets.leetcode.com/users/images/462c1866-2de7-4b68-912b-5eab9b157b80_1690158559.6475108.png)\\n\\n- The pink trianlge (it\\'s the largest tringle, only small part is visible) is the original one.\\n- The gray one shares the smallest leg with the original one. Its other leg is the largest multiple of the smallest leg that fits in the original triangle\\'s largest leg ($$k = 3$$ in this example)\\n- The blue line is parallel to the hypotenuse of the gray triangle and passes through the closest integer points (from the right), if the gray triangle hypotenuse passes through integer points the blue line should pass through the next closest (right) integer points.\\n- The red triangle is the part of the original triangle that is above the blue line.\\n- Since the blue line passes throught points with integer coordinates the red triangle can be safely transformed (preserving the number of the points with integer coordinates) to the blue triangle with a horizontal skew.\\n- The total points in the original triangle will be the number of the points in the gray triangle + the number of points in the red triangle (or the blue triangle, since it preserves the red triagle points\\' number). The area between the hypotenuse of the gray triangle and blue line (looks pink in the picture) cannot contain any point with integer coordinates.\\n- So, in order to calculate the the total points, we need to calculate the total points of the gray triangle (const time) and recursively calculate the point number of the blue triangle.\\n\\nSince in each iteration one of the sides of the next triangle decreases by a factor of at least 2 (similar to Euclidean algorithm), the complexity will be logarithmical in the worst case. \\n\\n# Complexity\\n- Time complexity: $$O(log(min(cost1, cost2, total)))$$ (worst case)\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int t, int a, int b) {\\n        if (b < a) {\\n            swap(a, b);\\n        }\\n\\n        long long res = 0;\\n\\n        while (true) {\\n            if (4 * b > t) {\\n                while (t >= 0) {\\n                    res += t / a + 1;\\n                    t -= b;\\n                }\\n\\n                return res;\\n            }\\n\\n            auto k = b / a;\\n            auto n = t / b;\\n            auto l = k * t / b + 1;\\n\\n            res += (long long)(n + 1) * (2 * l - k * n) / 2;\\n\\n            t -= a * l;\\n            auto temp = b;\\n            b = a;\\n            a = temp - k * a;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long result = 0;\\nwhile (total >= 0) {\\n    result += total / cost2 + 1;\\n    total -= cost1;\\n}\\nreturn result;\\n```\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int t, int a, int b) {\\n        if (b < a) {\\n            swap(a, b);\\n        }\\n\\n        long long res = 0;\\n\\n        while (true) {\\n            if (4 * b > t) {\\n                while (t >= 0) {\\n                    res += t / a + 1;\\n                    t -= b;\\n                }\\n\\n                return res;\\n            }\\n\\n            auto k = b / a;\\n            auto n = t / b;\\n            auto l = k * t / b + 1;\\n\\n            res += (long long)(n + 1) * (2 * l - k * n) / 2;\\n\\n            t -= a * l;\\n            auto temp = b;\\n            b = a;\\n            a = temp - k * a;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736734,
                "title": "o-log-n-solution-for-all-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWith some quite advanced math you can get to O(log n) solution. It\\'s  similar to the Euclid algorithm for GCD.\\n\\nThe core of this solution is a recurrent formula to calculate the $$F(n,k,m) = \\\\sum_{i=0}^n \\\\lfloor{\\\\frac{k*i}{m}}\\\\rfloor$$ from $$F(n\\', m \\\\%k, k)$$, which results in a logarithmic algorithm (simliar to GCD).\\n\\n# Approach\\nWe will count all the integer non-negative solutions for the equation $$a*x+b*y=c$$ for all non-negative $$c$$ upto ```totalCost``` (here $$a$$ and $$b$$ are the two costs from the problem).\\n\\nFirst, if $$GCD(a,b) \\\\neq 1$$, we can divide everything by it. Next, assume that $$GCD(a,b) = 1$$ Then using the Extended Euclid algorithm we can get $$x_0 \\\\lt 0$$ and $$y_0 \\\\gt 0$$, s.t. $$x_0*a+y_0*b=1$$. Using that we can list all the non-negative interger solutions for the equation in question as:\\n$$x = x_0*c + b*t \\\\\\\\\\ny = y_0*c - a*t \\\\\\\\\\n\\\\lceil \\\\frac{(-x_0)*c}{b}\\\\rceil \\\\le t \\\\le \\\\lfloor \\\\frac{y_0*c}{a} \\\\rfloor$$\\n\\nJust imagine a line: Two consecutive integer points on it will be spaced by $$\\\\{b, -a\\\\}$$ vector, since $$GCD(a,b) = 1$$. By multiplying $$x_0$$ and $$y_0$$ by $$c$$ we get some solution on the line. Then we specify the correct range for amount of shifts by the given vector to put the point in the positive quadrant.\\n\\nThus, the amount of integer non-negative solutions for the given $$c$$ is:\\n$$\\\\lfloor \\\\frac{y_0*c}{a} \\\\rfloor - \\\\lceil \\\\frac{(-x_0)*c}{b}\\\\rceil + 1$$\\n\\nThe answer to the problem is acquired  by summing on c from 0 to totalCost:\\n$$\\\\sum_{i=0}^{totalCost} ( \\\\lfloor \\\\frac{y_0*c}{a} \\\\rfloor - \\\\lceil \\\\frac{(-x_0)*c}{b}\\\\rceil + 1)$$\\n\\nThe second term, the Ceil can be replaced by Floor: they will be equal when the value is integer. Since $$GCD(x_0, b) = 1$$ this happens only for $$i$$ divisible by $$b$$. Thus, there are $$totalCost - \\\\lfloor \\\\frac{totalCost}{b}\\\\rfloor - 1$$ extra ones inside the sum if we replace ceil with the floor.\\n\\nThe final answer is:\\n$$\\\\sum_{i=0}^{totalCost} \\\\lfloor \\\\frac{y_0*c}{a} \\\\rfloor - \\\\sum_{i=0}^{totalCost} \\\\lfloor \\\\frac{(-x_0)*c}{b}\\\\rfloor + \\\\lfloor \\\\frac{totalCost}{b} \\\\rfloor + 1$$\\n\\nNow, the tricky part is to implemnt the function to calculate the $$\\\\sum_{i=0}^n \\\\lfloor{\\\\frac{k*i}{m}}\\\\rfloor$$\\n\\nUsing the [Hermite\\'s identity](https://en.wikipedia.org/wiki/Hermite%27s_identity) we can rewrite this as (using $$k$$ as $$N$$):\\n$$\\\\sum_{i=0}^n \\\\sum_{t=0}^{k-1} \\\\lfloor{\\\\frac{i}{m} + \\\\frac{t}{k}}\\\\rfloor$$\\n\\nThen change the order of summation:\\n$$\\\\sum_{t=0}^{k-1} \\\\sum_{i=0}^n  \\\\lfloor{\\\\frac{i}{m} + \\\\frac{t}{k}}\\\\rfloor$$\\n\\nThen notice, that the value inside the floor is a sum of two values less than 1. So the floor is equal to 0 or to 1 if:\\n$$\\\\frac{i}{m} + \\\\frac{t}{k} \\\\ge 1$$\\n\\nFrom this we can get a new bound on i:\\n$$ i \\\\ge m -\\\\frac{mt}{k}$$\\n\\nSince i is integer we can rewrite:\\n$$ i \\\\ge m -\\\\lfloor\\\\frac{mt}{k}\\\\rfloor$$\\nThen if we change the lower bound on i, there will be a sum of only 1. We should not forget the bound on t, s.t. the range on i is non-empty, which is:\\n$$ m -\\\\lfloor\\\\frac{mt}{k}\\\\rfloor \\\\le n $$\\nSimplifying to:\\n$$t \\\\ge \\\\lfloor \\\\frac{(m-n)k}{m}\\\\rfloor$$\\n\\nThus, we can rewrite our original sum as\\n$$ \\\\sum_{t=\\\\lfloor \\\\frac{(m-n)k}{m}\\\\rfloor}^{k-1} (n-m+\\\\lfloor\\\\frac{mt}{k}\\\\rfloor+1)$$\\n\\nInteger part of it can be computed and separated out.\\n\\nThe remainder is almost as the original sum, except it\\'s not from 0 to N, but from N to some max possible value. But we can compute the sum from 0 to k-1 and calculate the desired sum as the result minus the sum from 0 to some upper bound.\\n\\nNote, that we got the sum of the same form but we\\'ve swapped the m and k. Now k can be rwritten as $$m*\\\\lfloor\\\\frac{k}{m}\\\\rfloor+ k\\\\%m $$. Then some integer values can be separated and summed up as an arithmetic progression.\\n\\nThere are alot of details ommited there, since the computations are very involved, but the end results is:\\n\\n$$ F(n,k,m) = \\\\frac{(m-1)*(k-1) - (n1+1)*n1*(\\\\lfloor\\\\frac{m}{k}\\\\rfloor)}{2} + (n - m + 1)*(k-n1-1) - F(n1, m\\\\%k, k)$$\\n where $$n1=\\\\lfloor \\\\frac{((m-n)*k - 1)}{m}\\\\rfloor$$\\n\\nThen, it all works only if $$ n \\\\le m $$ and $$ k \\\\lt m$$, but similar to the calculation above, it\\'s possible to separate part of the sum upto $$n - n\\\\%m$$ and remove integer part due to $$\\\\lfloor \\\\frac{k}{m} \\\\rfloor$$. This is done in the ```FloorSum()``` function in the code below. The recursive ```FloorSumInternal()``` does the recurrent calculations using the formula above.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log\\\\ n)$$, the same as GCD algorithm.\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(1)$$ -->\\n$$O(log\\\\ n)$$, probably can be reimplemented in an iterative way instead, then it will be $$O(1)$$\\n\\n# Code\\n```\\n// returns GCD(a,b) and x,y s.t. a*x+b*y = GCD(a,b)\\nint GcdEx(int a, int b, int &x, int &y) {\\n    if (b == 0) {\\n        x = 1;\\n        y = 0;\\n        return a;\\n    }\\n    if (b > a) return GcdEx(b, a, y, x);\\n    int xx, yy;\\n    int d = GcdEx(b, a % b, xx, yy);\\n    // a%b = a - (a/b)*b\\n    y = xx - a/b*yy;\\n    x = yy;\\n    return d;\\n}\\n\\n// Computes sum i = 0.. n k*i/m\\n// GCD(k, m) must be 1.\\n// n < m\\n// k < m\\nlong long FloorSumInternal(long long n, long long k, long long m) {\\n\\tif (k == 0 || n <= 0) return 0;\\n\\tif (m == 1) return k*n*(n+1)/2;\\n\\tconst long long n1 = ((m-n)*k - 1)/m;\\n\\tlong long ans = (m-1)*(k-1)/2 - (n1+1)*n1*(m/k)/2 + (n - m + 1)*(k-n1-1);\\n\\tans -=  FloorSumInternal(n1, m%k, k);\\n\\treturn ans;\\n}\\n\\n\\n// Computes sum i = 0.. n k*i/m\\nlong long FloorSum(long long n, long long k, long long m) {\\n\\tif (k == 0 || n <= 0) return 0;\\n\\tif (m == 1) return k*n*(n+1)/2;\\n\\n\\tif (k >= m || n >= m) {\\n\\t\\t// (n*k*(n+1)/2 - ModSum(n, k, m, d))/m;\\n\\n\\t\\tconst long long nn = (n+1)%m-1;\\n\\t\\tconst long long num_full = (n+1) / m;\\n\\t\\tconst long long kk = k % m;\\n\\n\\t\\tlong long ans = 0;\\n\\t\\tans = (k*n*(n+1) - kk*(nn+1)*nn)/m - num_full * (m-1);\\n\\t\\tans /= 2;\\n\\t\\tans +=  FloorSumInternal(nn, kk, m);\\n\\t\\treturn ans;\\n\\t}\\n\\treturn FloorSumInternal(n, k, m);\\n}\\n\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int a, int b) {\\n        int x0, y0, d;\\n        d = GcdEx(a, b, x0, y0);\\n        if (d > 1) {\\n            a /= d;\\n            b /= d;\\n            total /= d;\\n        }\\n        if (x0 >= 0) {\\n            int t = x0/b + 1;\\n            x0 -= b*t;\\n            y0 += a*t;\\n        }\\n        if (y0 <= 0) {\\n            int t = -y0 / a + 1;\\n            x0 -= b*t;\\n            y0 += a*t;\\n        }\\n\\n        return FloorSum(total, y0, a) - FloorSum(total, -x0, b) + total / b + 1;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```totalCost```\n```FloorSum()```\n```FloorSumInternal()```\n```\\n// returns GCD(a,b) and x,y s.t. a*x+b*y = GCD(a,b)\\nint GcdEx(int a, int b, int &x, int &y) {\\n    if (b == 0) {\\n        x = 1;\\n        y = 0;\\n        return a;\\n    }\\n    if (b > a) return GcdEx(b, a, y, x);\\n    int xx, yy;\\n    int d = GcdEx(b, a % b, xx, yy);\\n    // a%b = a - (a/b)*b\\n    y = xx - a/b*yy;\\n    x = yy;\\n    return d;\\n}\\n\\n// Computes sum i = 0.. n k*i/m\\n// GCD(k, m) must be 1.\\n// n < m\\n// k < m\\nlong long FloorSumInternal(long long n, long long k, long long m) {\\n\\tif (k == 0 || n <= 0) return 0;\\n\\tif (m == 1) return k*n*(n+1)/2;\\n\\tconst long long n1 = ((m-n)*k - 1)/m;\\n\\tlong long ans = (m-1)*(k-1)/2 - (n1+1)*n1*(m/k)/2 + (n - m + 1)*(k-n1-1);\\n\\tans -=  FloorSumInternal(n1, m%k, k);\\n\\treturn ans;\\n}\\n\\n\\n// Computes sum i = 0.. n k*i/m\\nlong long FloorSum(long long n, long long k, long long m) {\\n\\tif (k == 0 || n <= 0) return 0;\\n\\tif (m == 1) return k*n*(n+1)/2;\\n\\n\\tif (k >= m || n >= m) {\\n\\t\\t// (n*k*(n+1)/2 - ModSum(n, k, m, d))/m;\\n\\n\\t\\tconst long long nn = (n+1)%m-1;\\n\\t\\tconst long long num_full = (n+1) / m;\\n\\t\\tconst long long kk = k % m;\\n\\n\\t\\tlong long ans = 0;\\n\\t\\tans = (k*n*(n+1) - kk*(nn+1)*nn)/m - num_full * (m-1);\\n\\t\\tans /= 2;\\n\\t\\tans +=  FloorSumInternal(nn, kk, m);\\n\\t\\treturn ans;\\n\\t}\\n\\treturn FloorSumInternal(n, k, m);\\n}\\n\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int a, int b) {\\n        int x0, y0, d;\\n        d = GcdEx(a, b, x0, y0);\\n        if (d > 1) {\\n            a /= d;\\n            b /= d;\\n            total /= d;\\n        }\\n        if (x0 >= 0) {\\n            int t = x0/b + 1;\\n            x0 -= b*t;\\n            y0 += a*t;\\n        }\\n        if (y0 <= 0) {\\n            int t = -y0 / a + 1;\\n            x0 -= b*t;\\n            y0 += a*t;\\n        }\\n\\n        return FloorSum(total, y0, a) - FloorSum(total, -x0, b) + total / b + 1;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671198,
                "title": "java-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFix the a constant purchase of either item.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- By setting constant purchase calculate number of times it can be purchased without considering purchase of other item. \\n- Then gradually decrease the number of items fixed item can be purchase until simultaneously increase purchase of other item by considering the amount left after purchasing fixed item.\\n- Decrease till number of fixed item can be purchased is 0.\\n# Complexity\\n- Time complexity: Depends upon the input of `cost1` or `cost2`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ways = 0;\\n        int np = total/cost1; // NUMBER OF TIMES PEN CAN BE PURCHASED\\n        for(int i=0; i<=np; i++){\\n            ways += (total-(cost1*i))/cost2+1; // DECREASE THE NUMBER OF TIMES PEN CAN BE PURCHASED AND INCREASE THE PURCHASE OF PENCILS\\n// + 1 IS THERE CAUSE WE CAN ALSO SELECT 0 PENCIL AS OPTION\\n// USE OPERATOR OVERLOADING INSTEAD OF EXTRA MEMORY FOR CONVERTING TO LONG\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ways = 0;\\n        int np = total/cost1; // NUMBER OF TIMES PEN CAN BE PURCHASED\\n        for(int i=0; i<=np; i++){\\n            ways += (total-(cost1*i))/cost2+1; // DECREASE THE NUMBER OF TIMES PEN CAN BE PURCHASED AND INCREASE THE PURCHASE OF PENCILS\\n// + 1 IS THERE CAUSE WE CAN ALSO SELECT 0 PENCIL AS OPTION\\n// USE OPERATOR OVERLOADING INSTEAD OF EXTRA MEMORY FOR CONVERTING TO LONG\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494701,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nvar waysToBuyPensPencils = function(total, cost1, cost2) {\\n    var count = 0;\\n    for(var i = 0; i <= total / cost1; ++i){\\n        count += Math.trunc((total - i * cost1) / cost2 + 1);\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nvar waysToBuyPensPencils = function(total, cost1, cost2) {\\n    var count = 0;\\n    for(var i = 0; i <= total / cost1; ++i){\\n        count += Math.trunc((total - i * cost1) / cost2 + 1);\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3346336,
                "title": "simple-mathematics-solution-java",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int min = Math.min(cost1,cost2);\\n        int max = Math.max(cost1,cost2);\\n        long ways = 0;\\n        for(int i = 0; i <= total; i += max){\\n            int rem = total - i;\\n            ways += rem/min + 1;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int min = Math.min(cost1,cost2);\\n        int max = Math.max(cost1,cost2);\\n        long ways = 0;\\n        for(int i = 0; i <= total; i += max){\\n            int rem = total - i;\\n            ways += rem/min + 1;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339181,
                "title": "the-only-true-o-log-n-solution-0-ms",
                "content": "# Complexity\\n- Time complexity:\\n$$O(\\\\log (\\\\min\\\\{total,\\\\,cost1,\\\\,cost2\\\\}))$$\\n\\n- Space complexity:\\n$$O(1)$$ (tail recursion)\\n\\n# Code\\n```\\nclass Solution {\\n\\tprivate static final int SMALL_TOTAL_THRESHOLD = 3;\\n\\n\\tpublic static long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n\\t\\tif (cost2 > cost1)\\n\\t\\t\\treturn waysToBuyPensPencils(total, cost2, cost1);\\n\\t\\tint pivotX = total / cost1;\\n\\t\\tif (pivotX < SMALL_TOTAL_THRESHOLD) { // this optimization is optional\\n\\t\\t\\tlong result = 0;\\n\\t\\t\\tdo\\n\\t\\t\\t\\tresult += total / cost2 + 1;\\n\\t\\t\\twhile ((total -= cost1) >= 0);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tint pivotY = total % cost1 / cost2;\\n\\t\\tint slope = cost1 / cost2;\\n\\t\\tlong triangle = (long) (2 * pivotY + slope * pivotX) * (pivotX + 1) / 2;\\n\\t\\tint r = cost1 % cost2; // slope remainder\\n\\t\\tif (r == 0) // parallel lines\\n\\t\\t\\treturn triangle + pivotX + 1;\\n\\t\\tint d = total % cost1 % cost2; // total - cost1 * pivotX - cost2 * pivotY\\n\\t\\t// d / r is a surplus that we need to subtract from the recursive result\\n\\t\\treturn triangle - d / r + waysToBuyPensPencils(d + r * pivotX, cost2, r);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n\\tprivate static final int SMALL_TOTAL_THRESHOLD = 3;\\n\\n\\tpublic static long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n\\t\\tif (cost2 > cost1)\\n\\t\\t\\treturn waysToBuyPensPencils(total, cost2, cost1);\\n\\t\\tint pivotX = total / cost1;\\n\\t\\tif (pivotX < SMALL_TOTAL_THRESHOLD) { // this optimization is optional\\n\\t\\t\\tlong result = 0;\\n\\t\\t\\tdo\\n\\t\\t\\t\\tresult += total / cost2 + 1;\\n\\t\\t\\twhile ((total -= cost1) >= 0);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tint pivotY = total % cost1 / cost2;\\n\\t\\tint slope = cost1 / cost2;\\n\\t\\tlong triangle = (long) (2 * pivotY + slope * pivotX) * (pivotX + 1) / 2;\\n\\t\\tint r = cost1 % cost2; // slope remainder\\n\\t\\tif (r == 0) // parallel lines\\n\\t\\t\\treturn triangle + pivotX + 1;\\n\\t\\tint d = total % cost1 % cost2; // total - cost1 * pivotX - cost2 * pivotY\\n\\t\\t// d / r is a surplus that we need to subtract from the recursive result\\n\\t\\treturn triangle - d / r + waysToBuyPensPencils(d + r * pivotX, cost2, r);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839391,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long n = total / cost1, ans = 0;\\n        for(int i=0; i<=n; i++) ans += (total - i * cost1) / cost2 + 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long n = total / cost1, ans = 0;\\n        for(int i=0; i<=n; i++) ans += (total - i * cost1) / cost2 + 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828992,
                "title": "substract-cost1-from-total-java-most-optimal-solution",
                "content": "Code itself saying something here\\nHappy Coding :)\\n```\\npublic long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n            long res = 0 ;\\n            while(total>=0){\\n                res+=(total/cost2+1);\\n                total-=cost1;\\n            }\\n            return res;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n            long res = 0 ;\\n            while(total>=0){\\n                res+=(total/cost2+1);\\n                total-=cost1;\\n            }\\n            return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2736963,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long res = 0L;\\n        for (int i = 0; i <= total; i += cost1) {\\n            int a = total - i;\\n            res += (a / cost2) + 1;\\n        } \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long res = 0L;\\n        for (int i = 0; i <= total; i += cost1) {\\n            int a = total - i;\\n            res += (a / cost2) + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2680021,
                "title": "simple-math-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n{\\n     int maxpen = total / cost1;   //0 1 2\\n     \\n     long long int ways=0;\\n     for(int i=0;i<=maxpen;i++)   //fixing the quantitiy of the pens\\n     {\\n     \\tways=ways+fun(total - (cost1*i),cost2);\\n\\t }\\n\\t return ways;\\n}\\nint fun(int amt,int cost2)\\n{\\n\\tint x= amt / cost2;\\n\\treturn x+1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n{\\n     int maxpen = total / cost1;   //0 1 2\\n     \\n     long long int ways=0;\\n     for(int i=0;i<=maxpen;i++)   //fixing the quantitiy of the pens\\n     {\\n     \\tways=ways+fun(total - (cost1*i),cost2);\\n\\t }\\n\\t return ways;\\n}\\nint fun(int amt,int cost2)\\n{\\n\\tint x= amt / cost2;\\n\\treturn x+1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544587,
                "title": "c-easy-short-explained",
                "content": "![image](https://assets.leetcode.com/users/images/6d4ee5d9-a85c-440e-b172-e57b491242b5_1662551156.5507567.png)\\n\\n***Approach->Fix the number of pencils purchased and calculate the number of ways to buy pens and Sum up the number of ways to buy pens for each amount of pencils purchased to get the answer.\\n*\\n**T->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n\\t\\t\\t\\tlong long ways=0;\\n\\t\\t\\t\\tfor(int i=0;(total-i*cost1)>=0;i++){\\n\\t\\t\\t\\t\\tint j=(total-i*cost1)/cost2;\\n\\t\\t\\t\\t\\tways+=j+1;       \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ways;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n\\t\\t\\t\\tlong long ways=0;\\n\\t\\t\\t\\tfor(int i=0;(total-i*cost1)>=0;i++){\\n\\t\\t\\t\\t\\tint j=(total-i*cost1)/cost2;\\n\\t\\t\\t\\t\\tways+=j+1;       \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2404281,
                "title": "simple-logic-based-on-math",
                "content": "This seems closer to easy than medium, but anyways:\\n\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int pen_cost, int pencil_cost) {\\n        /* Number of different pens you can buy, including 0.  */\\n        long long ans = total / pen_cost + 1;\\n        \\n        /* Number of different pencils you can buy for every combination of pens.  */\\n        for (int remaining=total; remaining>=0; remaining-=pen_cost) {\\n            ans += remaining / pencil_cost;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int pen_cost, int pencil_cost) {\\n        /* Number of different pens you can buy, including 0.  */\\n        long long ans = total / pen_cost + 1;\\n        \\n        /* Number of different pencils you can buy for every combination of pens.  */\\n        for (int remaining=total; remaining>=0; remaining-=pen_cost) {\\n            ans += remaining / pencil_cost;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352239,
                "title": "simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long res=0;\\n        \\n        for(int i=0; i<=total; i+=cost1) {\\n            res+=(total-i)/cost2+1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long res=0;\\n        \\n        for(int i=0; i<=total; i+=cost1) {\\n            res+=(total-i)/cost2+1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343067,
                "title": "c-easiest-dp-solution-tabulation",
                "content": "class Solution {\\npublic:\\n\\n    typedef long long ll;\\n    \\n    \\n    long long waysToBuyPensPencils(int n, int x, int y) {\\n        \\n        vector<ll> dp(n+1,1);\\n        \\n        dp[0] = 1;\\n        \\n        for(int i = 1; i < n+1; i++){\\n            \\n            if(i >= x)\\n                dp[i] += dp[i-x];\\n            \\n            if(i >= y)\\n                dp[i] += dp[i-y];\\n            \\n            if(i >= x+y)\\n                dp[i] -= dp[i-x-y];\\n            \\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    typedef long long ll;\\n    \\n    \\n    long long waysToBuyPensPencils(int n, int x, int y) {\\n        \\n        vector<ll> dp(n+1,1);\\n        \\n        dp[0] = 1;\\n        \\n        for(int i = 1; i < n+1; i++){\\n            \\n            if(i >= x)\\n                dp[i] += dp[i-x];\\n            \\n            if(i >= y)\\n                dp[i] += dp[i-y];\\n            \\n            if(i >= x+y)\\n                dp[i] -= dp[i-x-y];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2298857,
                "title": "least-runtime-solution",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        return sum(\\n            (rest//c+1) * blocks + C * comb(blocks, 2)\\n            for rest in range(total % C, min(blocksize, total+1), C)\\n            for blocks in [(total-rest) // blocksize + 1]\\n        )\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        return sum(\\n            (rest//c+1) * blocks + C * comb(blocks, 2)\\n            for rest in range(total % C, min(blocksize, total+1), C)\\n            for blocks in [(total-rest) // blocksize + 1]\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240897,
                "title": "c-simple-intuition",
                "content": "**Upvote if you found helpful**\\n```C++\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        while (total >= 0) {\\n            ans += (total / cost2) + 1;\\n            total -= cost1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        while (total >= 0) {\\n            ans += (total / cost2) + 1;\\n            total -= cost1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167318,
                "title": "simple-maths",
                "content": "So it\\'s very simple just fix the number of pens and calculate how many pencils you can buy with the leftover money. keep on doing that till the max no. of pens u can buy. \\nand find the number of pen/ pencils that can be bought using division.\\nand to count the number of combinations.\\nEx:- suppose you can buy 1 pen and 3 pencils.Thus for 1 pen you could have 0,1,2,3 pencils , so by observation you see the number of combinations = number of pencils+1;\\nand **solved!**\\n**upvote if you like the solution**\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        int pen=max(cost1,cost2);\\n        int pencil=min(cost1,cost2);\\n        int mx_pens=total/pen;\\n        long long ctr=0;\\n        for(int i=0;i<=mx_pens;i++)\\n        {\\n            int left=total-(i*pen);\\n            int no_pencil=left/pencil;\\n            ctr+=(long long)no_pencil+1;\\n        }\\n    return ctr;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        int pen=max(cost1,cost2);\\n        int pencil=min(cost1,cost2);\\n        int mx_pens=total/pen;\\n        long long ctr=0;\\n        for(int i=0;i<=mx_pens;i++)\\n        {\\n            int left=total-(i*pen);\\n            int no_pencil=left/pencil;\\n            ctr+=(long long)no_pencil+1;\\n        }\\n    return ctr;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086816,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        int n = total/cost1;\\n        for(int i=0;i<=n;i++)\\n        {\\n            ans+=((total-i*cost1)/cost2 + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        int n = total/cost1;\\n        for(int i=0;i<=n;i++)\\n        {\\n            ans+=((total-i*cost1)/cost2 + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993367,
                "title": "c-super-easy-o-n",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        long long ans=0;\\n        \\n        ans=(total/cost2)+1;\\n        \\n        while(total>0){\\n            \\n            total = total - cost1;\\n            \\n            if(total<0)\\n                return ans;\\n            \\n            if(total==0)\\n                return ans+1;\\n            \\n            ans+= (total/cost2)+1;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        long long ans=0;\\n        \\n        ans=(total/cost2)+1;\\n        \\n        while(total>0){\\n            \\n            total = total - cost1;\\n            \\n            if(total<0)\\n                return ans;\\n            \\n            if(total==0)\\n                return ans+1;\\n            \\n            ans+= (total/cost2)+1;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1982386,
                "title": "java-math-very-easy-several-examples-dry-run-covering-all-possible-cases",
                "content": "```\\nQuestion:\\n\\nYou are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. You can spend part or all of your money to buy multiple quantities (or none) of each kind of writing utensil.\\n\\nReturn the number of distinct ways you can buy some number of pens and pencils.\\n\\n \\n\\nExample 1:\\n\\nInput: totalMoney = Rs20, costPen = Rs 10, costPencil = Rs5\\nOutput: 9\\nExplanation: The price of each pen is Rs10 and the price of each pencil is Rs5.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 20,now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil or 3 Pencil or 4 pencil. i.e total 5 ways : (0,0) and (0,1) and (0,2) and (0,3) and (0,4)\\n- If you buy 1 pen,=>Remaining Money: Rs 10, now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil . i.e 3 ways : (1,0) and (1,1) and (1,2)\\n- If you buy 2 pens,=>Remaining Money: Rs 0, you cannot buy any pencils i.e 0 pencil. i.e 1 way : (2,0)\\n(You can not buy 3 pens or more coz of Insufficient Money)\\n  The total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\\n\\nExample 2:\\n\\nInput: totalMoney = Rs20, costPen = Rs 5, costPencil = Rs 10\\nOutput: 9\\nExplanation: The price of each pen is Rs 5 and the price of each pencil is Rs 10.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 20,now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil. i.e total 3 ways : (0,0) and (0,1) and (0,2).\\n- If you buy 1 pen,=>Remaining Money: Rs 15, now you can Either buy 0 Pencil or 1 Pencil . i.e 2 ways : (1,0) and (1,1)\\n- If you buy 2 pens,=>Remaining Money: Rs 10, now you can Either buy 0 Pencil or 1 Pencil. i.e 2 ways : (2,0) and (2,1)\\n- If you buy 3 pens,=>Remaining Money: Rs 5, you cannot buy any pencil i.e 0 pencil. i.e 1 way : (3,0)\\n- If you buy 4 pens,=>Remaining Money: Rs 0, you cannot buy any pencil i.e 0 pencil. i.e 1 way : (4,0)\\n(You can not buy 5 pens or more coz of Insufficient Money)\\n  The total number of ways to buy pens and pencils is 3+2+2+1+1=9.\\n\\n\\nExample 3:\\n\\nInput: totalMoney = Rs20, costPen =Rs 10, costPencil = Rs 10\\nOutput: 6\\nExplanation: The price of each pen is Rs 5 and the price of each pencil is Rs 10.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 20,now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil. i.e total 3 ways : (0,0) and (0,1) and (0,2).\\n- If you buy 1 pen,=>Remaining Money: Rs 10, now you can Either buy 0 Pencil or 1 Pencil . i.e 2 ways : (1,0) and (1,1)\\n- If you buy 2 pens,=>Remaining Money: Rs 0, now you cannot buy any pencil i.e 0 pencil. i.e 1 way : (2,0)\\n(You can not buy 3 pens or more coz of Insufficient Money)\\n\\n  The total number of ways to buy pens and pencils is 3+2+1=6.\\n \\n \\n Example 4:\\n\\nInput: totalMoney =Rs 5, costPen =Rs 10, costPencil = Rs 10\\nOutput: 1\\nExplanation: The price of both pens and pencils are Rs10 Each, which cost more than total, so you cannot buy any writing utensils. \\nTherefore, there is only 1 way: buy 0 pens and 0 pencils.\\n\\n\\nExample 5:\\n\\nInput: totalMoney = Rs16, costPen = Rs 10, costPencil = Rs5\\nOutput: 6\\nExplanation: The price of each pen is Rs10 and the price of each pencil is Rs5.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 16,now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil or 3 Pencil.i.e total 4 ways : (0,0) and (0,1) and (0,2) and (0,3)\\n- If you buy 1 pen,=>Remaining Money: Rs 6, now you can Either buy 0 Pencil or 1 Pencil. i.e 2 ways : (1,0) and (1,1)\\n(You can not buy 2 pens or more coz of Insufficient Money)\\n The total number of ways to buy pens and pencils is 4 + 2 = 6.\\n \\n \\n Example 6:\\n\\nInput: totalMoney = Rs16, costPen = Rs 5, costPencil = Rs 10\\nOutput: 6\\nExplanation: The price of each pen is Rs 5  and the price of each pencil is Rs 10.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 16,now you can Either buy 0 Pencil or 1 Pencil.i.e total 2 ways : (0,0) and (0,1)\\n- If you buy 1 pen,=>Remaining Money: Rs 11, now you can Either buy 0 Pencil or 1 Pencil. i.e 2 ways : (1,0) and (1,1)\\n- If you buy 2 pen,=>Remaining Money: Rs 6, now you cannot buy any pencil i.e 0 pencil. i.e 1 way : (2,0)\\n- If you buy 3 pen,=>Remaining Money: Rs 1, now you cannot buy any pencil i.e 0 pencil. i.e 1 way : (3,0)\\n(You can not buy 4 pens or more coz of Insufficient Money)\\n\\n The total number of ways to buy pens and pencils is 2+2+1+1 = 6.\\n```\\n\\n```\\n //Java Code\\n //If we buy cnt Number of pens, we can buy up to (total - cnt * cost1) / cost2 + 1 No. of pencils. We do plus one as we can also buy zero pencils.\\n \\n\\n class Solution {\\n    public long waysToBuyPensPencils(int totalMoney, int costPen, int costPencil)\\n    {\\n       long ways = 0;\\n       for (int cntPen = 0; (cntPen*costPen)<= totalMoney; cntPen++)\\n       {\\n           int remMoney=(totalMoney- (cntPen*costPen));\\n           ways+=(remMoney/costPencil) + 1;  \\n       }  \\n       return ways;\\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nQuestion:\\n\\nYou are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. You can spend part or all of your money to buy multiple quantities (or none) of each kind of writing utensil.\\n\\nReturn the number of distinct ways you can buy some number of pens and pencils.\\n\\n \\n\\nExample 1:\\n\\nInput: totalMoney = Rs20, costPen = Rs 10, costPencil = Rs5\\nOutput: 9\\nExplanation: The price of each pen is Rs10 and the price of each pencil is Rs5.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 20,now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil or 3 Pencil or 4 pencil. i.e total 5 ways : (0,0) and (0,1) and (0,2) and (0,3) and (0,4)\\n- If you buy 1 pen,=>Remaining Money: Rs 10, now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil . i.e 3 ways : (1,0) and (1,1) and (1,2)\\n- If you buy 2 pens,=>Remaining Money: Rs 0, you cannot buy any pencils i.e 0 pencil. i.e 1 way : (2,0)\\n(You can not buy 3 pens or more coz of Insufficient Money)\\n  The total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\\n\\nExample 2:\\n\\nInput: totalMoney = Rs20, costPen = Rs 5, costPencil = Rs 10\\nOutput: 9\\nExplanation: The price of each pen is Rs 5 and the price of each pencil is Rs 10.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 20,now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil. i.e total 3 ways : (0,0) and (0,1) and (0,2).\\n- If you buy 1 pen,=>Remaining Money: Rs 15, now you can Either buy 0 Pencil or 1 Pencil . i.e 2 ways : (1,0) and (1,1)\\n- If you buy 2 pens,=>Remaining Money: Rs 10, now you can Either buy 0 Pencil or 1 Pencil. i.e 2 ways : (2,0) and (2,1)\\n- If you buy 3 pens,=>Remaining Money: Rs 5, you cannot buy any pencil i.e 0 pencil. i.e 1 way : (3,0)\\n- If you buy 4 pens,=>Remaining Money: Rs 0, you cannot buy any pencil i.e 0 pencil. i.e 1 way : (4,0)\\n(You can not buy 5 pens or more coz of Insufficient Money)\\n  The total number of ways to buy pens and pencils is 3+2+2+1+1=9.\\n\\n\\nExample 3:\\n\\nInput: totalMoney = Rs20, costPen =Rs 10, costPencil = Rs 10\\nOutput: 6\\nExplanation: The price of each pen is Rs 5 and the price of each pencil is Rs 10.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 20,now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil. i.e total 3 ways : (0,0) and (0,1) and (0,2).\\n- If you buy 1 pen,=>Remaining Money: Rs 10, now you can Either buy 0 Pencil or 1 Pencil . i.e 2 ways : (1,0) and (1,1)\\n- If you buy 2 pens,=>Remaining Money: Rs 0, now you cannot buy any pencil i.e 0 pencil. i.e 1 way : (2,0)\\n(You can not buy 3 pens or more coz of Insufficient Money)\\n\\n  The total number of ways to buy pens and pencils is 3+2+1=6.\\n \\n \\n Example 4:\\n\\nInput: totalMoney =Rs 5, costPen =Rs 10, costPencil = Rs 10\\nOutput: 1\\nExplanation: The price of both pens and pencils are Rs10 Each, which cost more than total, so you cannot buy any writing utensils. \\nTherefore, there is only 1 way: buy 0 pens and 0 pencils.\\n\\n\\nExample 5:\\n\\nInput: totalMoney = Rs16, costPen = Rs 10, costPencil = Rs5\\nOutput: 6\\nExplanation: The price of each pen is Rs10 and the price of each pencil is Rs5.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 16,now you can Either buy 0 Pencil or 1 Pencil or 2 Pencil or 3 Pencil.i.e total 4 ways : (0,0) and (0,1) and (0,2) and (0,3)\\n- If you buy 1 pen,=>Remaining Money: Rs 6, now you can Either buy 0 Pencil or 1 Pencil. i.e 2 ways : (1,0) and (1,1)\\n(You can not buy 2 pens or more coz of Insufficient Money)\\n The total number of ways to buy pens and pencils is 4 + 2 = 6.\\n \\n \\n Example 6:\\n\\nInput: totalMoney = Rs16, costPen = Rs 5, costPencil = Rs 10\\nOutput: 6\\nExplanation: The price of each pen is Rs 5  and the price of each pencil is Rs 10.\\n\\n- If you buy 0 pens,=>Remaining Money: Rs 16,now you can Either buy 0 Pencil or 1 Pencil.i.e total 2 ways : (0,0) and (0,1)\\n- If you buy 1 pen,=>Remaining Money: Rs 11, now you can Either buy 0 Pencil or 1 Pencil. i.e 2 ways : (1,0) and (1,1)\\n- If you buy 2 pen,=>Remaining Money: Rs 6, now you cannot buy any pencil i.e 0 pencil. i.e 1 way : (2,0)\\n- If you buy 3 pen,=>Remaining Money: Rs 1, now you cannot buy any pencil i.e 0 pencil. i.e 1 way : (3,0)\\n(You can not buy 4 pens or more coz of Insufficient Money)\\n\\n The total number of ways to buy pens and pencils is 2+2+1+1 = 6.\\n```\n```\\n //Java Code\\n //If we buy cnt Number of pens, we can buy up to (total - cnt * cost1) / cost2 + 1 No. of pencils. We do plus one as we can also buy zero pencils.\\n \\n\\n class Solution {\\n    public long waysToBuyPensPencils(int totalMoney, int costPen, int costPencil)\\n    {\\n       long ways = 0;\\n       for (int cntPen = 0; (cntPen*costPen)<= totalMoney; cntPen++)\\n       {\\n           int remMoney=(totalMoney- (cntPen*costPen));\\n           ways+=(remMoney/costPencil) + 1;  \\n       }  \\n       return ways;\\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970737,
                "title": "c-linq-one-line",
                "content": "```\\n\\tpublic long WaysToBuyPensPencils(int total, int cost1, int cost2) \\n        => Enumerable.Range(0, 1+total/cost1)\\n                     .Sum(count1 => 1L + (total-count1*cost1)/cost2);\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic long WaysToBuyPensPencils(int total, int cost1, int cost2) \\n        => Enumerable.Range(0, 1+total/cost1)\\n                     .Sum(count1 => 1L + (total-count1*cost1)/cost2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967957,
                "title": "one-line-math-solution-python",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        # max_pen = total // cost1\\n        # max_pencil = total // cost2\\n        # res = 0\\n        # for i in range(0, max_pen + 1):\\n        #     res += (total - i * cost1) // cost2 + 1\\n        # return res\\n    \\n        return sum((total - i * cost1) // cost2 + 1 for i in range(total // cost1 + 1) )\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        # max_pen = total // cost1\\n        # max_pencil = total // cost2\\n        # res = 0\\n        # for i in range(0, max_pen + 1):\\n        #     res += (total - i * cost1) // cost2 + 1\\n        # return res\\n    \\n        return sum((total - i * cost1) // cost2 + 1 for i in range(total // cost1 + 1) )\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960864,
                "title": "python3-100-o-n-solution",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        count=0\\n        while total >= 0:\\n            count+= total//cost2\\n            count+=1\\n            total-=cost1\\n        return count\\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        count=0\\n        while total >= 0:\\n            count+= total//cost2\\n            count+=1\\n            total-=cost1\\n        return count\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1959223,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int t, int c1, int c2) {\\n        if(t<c1&&t<c2)\\n            return 1;\\n        long s=0;\\n        for(int i=0;;i++)\\n        {\\n            int p=t-(i*c1);\\n            if(p<0)\\n                break;\\n            s=s+(long)((long)p/(long)c2)+1;\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public long waysToBuyPensPencils(int t, int c1, int c2) {\\n        if(t<c1&&t<c2)\\n            return 1;\\n        long s=0;\\n        for(int i=0;;i++)\\n        {\\n            int p=t-(i*c1);\\n            if(p<0)\\n                break;\\n            s=s+(long)((long)p/(long)c2)+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1958313,
                "title": "scala-solution-tail-recursion",
                "content": "```\\n    def waysToBuyPensPencils(total: Int, cost1: Int, cost2: Int): Long = {\\n        def loop(buyPen: Int, result: Long): Long = {\\n          val sumAfterBuingPen = total - (cost1 * buyPen)\\n          val amountPencile = (sumAfterBuingPen / cost2) + 1\\n          if(sumAfterBuingPen < 0) result\\n          else loop(buyPen + 1, result + amountPencile)\\n        }\\n\\n        loop(0, 0)\\n    }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n    def waysToBuyPensPencils(total: Int, cost1: Int, cost2: Int): Long = {\\n        def loop(buyPen: Int, result: Long): Long = {\\n          val sumAfterBuingPen = total - (cost1 * buyPen)\\n          val amountPencile = (sumAfterBuingPen / cost2) + 1\\n          if(sumAfterBuingPen < 0) result\\n          else loop(buyPen + 1, result + amountPencile)\\n        }\\n\\n        loop(0, 0)\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1957387,
                "title": "c-simple-greedy-solution",
                "content": "```\\n  typedef long long ll;\\n    long long waysToBuyPensPencils(int total, int c1, int c2)\\n    {\\n        if(c1<c2)\\n        {\\n            swap(c1,c2);\\n        }\\n        if(total <c1 and total < c2)\\n        {\\n            return 1;\\n        }\\n        int i=0;\\n        ll cnt=0;\\n        while(i*c1<=total)\\n        {\\n            \\n                cnt++;\\n                cnt+=(total-i*c1)/c2;\\n                i++;\\n                \\n            \\n        }\\n        return cnt;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n  typedef long long ll;\\n    long long waysToBuyPensPencils(int total, int c1, int c2)\\n    {\\n        if(c1<c2)\\n        {\\n            swap(c1,c2);\\n        }\\n        if(total <c1 and total < c2)\\n        {\\n            return 1;\\n        }\\n        int i=0;\\n        ll cnt=0;\\n        while(i*c1<=total)\\n        {\\n            \\n                cnt++;\\n                cnt+=(total-i*c1)/c2;\\n                i++;\\n                \\n            \\n        }\\n        return cnt;\\n        \\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1956750,
                "title": "a-simple-observation-based-solution",
                "content": "A simple observation based solution where I just need to see the example to get the approach.\\nUsing the given examples I derived the formula for-\\n\\ni) number of times loop will run = looptimes = (total / max of cost1 and cost2);\\nii) count of the total = (total - i * maxi) / mini;\\n\\n```\\nclass Solution \\n{\\n    public:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long long count = 0;\\n        \\n        long long maxi = max(cost1,cost2),mini = min(cost1,cost2);\\n        \\n        long long looptimes = (total / maxi);\\n        \\n        for(int i=0;i<=looptimes;i++)\\n        {\\n            count += (total - i*maxi) / mini;\\n            count++;\\n        }\\n\\n             if(count==0)\\n             {\\n                 return 1;\\n             }\\n        \\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long long count = 0;\\n        \\n        long long maxi = max(cost1,cost2),mini = min(cost1,cost2);\\n        \\n        long long looptimes = (total / maxi);\\n        \\n        for(int i=0;i<=looptimes;i++)\\n        {\\n            count += (total - i*maxi) / mini;\\n            count++;\\n        }\\n\\n             if(count==0)\\n             {\\n                 return 1;\\n             }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956284,
                "title": "c-simple-maths-and-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(total<cost1&&total<cost2)\\n            return 1;\\n        \\n       long long int ans;\\n           long long int npens=total/cost1;\\n        ans=npens;\\n           int i=0;\\n           while(i<=npens)\\n            {\\n              ans+=((total-i*cost1)/cost2);\\n              i++;\\n            }\\n       \\n           return  ans+1;   \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(total<cost1&&total<cost2)\\n            return 1;\\n        \\n       long long int ans;\\n           long long int npens=total/cost1;\\n        ans=npens;\\n           int i=0;\\n           while(i<=npens)\\n            {\\n              ans+=((total-i*cost1)/cost2);\\n              i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1954465,
                "title": "simple-c-solution",
                "content": "```\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int a = total/cost1;\\n        long long sum = 0;\\n         for(int i=0;i<=a;i++){\\n             sum+=total/cost2 +1;\\n             total -=cost1; \\n             if(total<0){\\n                 break;\\n             }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int a = total/cost1;\\n        long long sum = 0;\\n         for(int i=0;i<=a;i++){\\n             sum+=total/cost2 +1;\\n             total -=cost1; \\n             if(total<0){\\n                 break;\\n             }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1954380,
                "title": "python-simple-loop",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:                  \\n        result = pen = 0             \\n        while pen * cost1 <= total:            \\n            result += 1 + (total - pen * cost1) // cost2            \\n            pen += 1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:                  \\n        result = pen = 0             \\n        while pen * cost1 <= total:            \\n            result += 1 + (total - pen * cost1) // cost2            \\n            pen += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954239,
                "title": "c-simple",
                "content": "**CODE :**\\n\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int original = total;\\n        long long numofpen = total/cost1;\\n        long long result = 0;\\n        for(long long i=0;i<=numofpen;i++){\\n            total = original - (i*cost1);\\n            long long numofpencil = total/cost2;\\n            result += 1 + numofpencil;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nThank You!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int original = total;\\n        long long numofpen = total/cost1;\\n        long long result = 0;\\n        for(long long i=0;i<=numofpen;i++){\\n            total = original - (i*cost1);\\n            long long numofpencil = total/cost2;\\n            result += 1 + numofpencil;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954218,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        int max_pens = total / cost1;\\n        \\n        long long res = 0;\\n        \\n        for(int i = 0; i <= max_pens; i++)\\n        {\\n            int rem = total - cost1 * i;\\n            \\n            int pensil = rem / cost2;\\n            \\n            res += pensil + 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        int max_pens = total / cost1;\\n        \\n        long long res = 0;\\n        \\n        for(int i = 0; i <= max_pens; i++)\\n        {\\n            int rem = total - cost1 * i;\\n            \\n            int pensil = rem / cost2;\\n            \\n            res += pensil + 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954207,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(long long curr,int &total,int &cost1,int &cost2, long long &totalpens)\\n    {\\n        long long ways = 0,npencil=0;\\n        while(curr <= totalpens)\\n        {\\n            npencil = total/cost2;\\n            ways += npencil+1;\\n            total -= cost1;\\n            curr++;\\n        }\\n        \\n        return ways;\\n    }\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(total < cost1 and total < cost2)\\n            return 1;\\n        \\n        long long totalpens = total/cost1;\\n        \\n        return solve(0,total,cost1,cost2,totalpens);\\n        \\n    }\\n};\\n```\\n\\nPLS UPVOTE IF U LIKE IT!!!!!!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(long long curr,int &total,int &cost1,int &cost2, long long &totalpens)\\n    {\\n        long long ways = 0,npencil=0;\\n        while(curr <= totalpens)\\n        {\\n            npencil = total/cost2;\\n            ways += npencil+1;\\n            total -= cost1;\\n            curr++;\\n        }\\n        \\n        return ways;\\n    }\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(total < cost1 and total < cost2)\\n            return 1;\\n        \\n        long long totalpens = total/cost1;\\n        \\n        return solve(0,total,cost1,cost2,totalpens);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954180,
                "title": "go-golang-time-o-n-46-ms-100-space-o-1-1-9-mb-100",
                "content": "```\\nfunc waysToBuyPensPencils(total int, cost1 int, cost2 int) int64 {\\n    result := int64(0)\\n    \\n    for c1 := 0; c1 <= total; c1 += cost1 {\\n        result += int64((total - c1) / cost2 + 1)\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc waysToBuyPensPencils(total int, cost1 int, cost2 int) int64 {\\n    result := int64(0)\\n    \\n    for c1 := 0; c1 <= total; c1 += cost1 {\\n        result += int64((total - c1) / cost2 + 1)\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1954165,
                "title": "number-of-ways-to-buy-pens-and-pencils-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long maxPen=total/cost1;\\n        long ans=0l;\\n        for(long pen=0;pen<=maxPen;pen++)\\n        {\\n            long rem=total-(pen*cost1);\\n            long maxPencil=rem/cost2;\\n            ans+=maxPencil+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long maxPen=total/cost1;\\n        long ans=0l;\\n        for(long pen=0;pen<=maxPen;pen++)\\n        {\\n            long rem=total-(pen*cost1);\\n            long maxPencil=rem/cost2;\\n            ans+=maxPencil+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954136,
                "title": "easy-to-understand-solution-c-simple-math",
                "content": "```\\n long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        long long cnt=total/cost1;\\n        int curr=0;\\n        while(curr<=cnt){\\n            long long temp=total-curr*(cost1);\\n            ans+=(temp)/(cost2);\\n            ans++;\\n            curr++;\\n        }\\n        return (curr==0)?1:ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        long long cnt=total/cost1;\\n        int curr=0;\\n        while(curr<=cnt){\\n            long long temp=total-curr*(cost1);\\n            ans+=(temp)/(cost2);\\n            ans++;\\n            curr++;\\n        }\\n        return (curr==0)?1:ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1954061,
                "title": "c-maths-single-while-loop-o-n",
                "content": "count all possible ways of `cost2` for every possible `cost1`\\n````\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long count = 0;\\n        int n = 0;\\n        while(cost1 * n <= total) {\\n            int remaining = total - cost1*n;\\n            count += (remaining / cost2) + 1;\\n            n++;\\n        }\\n        return count;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long count = 0;\\n        int n = 0;\\n        while(cost1 * n <= total) {\\n            int remaining = total - cost1*n;\\n            count += (remaining / cost2) + 1;\\n            n++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953957,
                "title": "python-easy-o-budget-max-cost1-cost2-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        \\n        result = 0\\n        budget = total\\n        \\n        cost1, cost2 = sorted([cost1, cost2], reverse = True)\\n        \\n        for i in range((budget // cost1) + 1):\\n            budget = total\\n            budget -= (i * cost1)\\n            j = max(budget // cost2, 0)\\n            result += j + 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        \\n        result = 0\\n        budget = total\\n        \\n        cost1, cost2 = sorted([cost1, cost2], reverse = True)\\n        \\n        for i in range((budget // cost1) + 1):\\n            budget = total\\n            budget -= (i * cost1)\\n            j = max(budget // cost2, 0)\\n            result += j + 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953831,
                "title": "very-easy-greedy-solution-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n            long long x=0;\\n            long long y=0;\\n            long long ans=0;\\n        if(total<cost1 && total<cost2) return 1;\\n        for(int i=0;i<=total/cost1;i++){\\n            long long left=total-cost1*i;\\n            long long pencils=left/cost2+1;\\n            ans+=pencils;\\n        }\\n            \\n            return ans;\\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n            long long x=0;\\n            long long y=0;\\n            long long ans=0;\\n        if(total<cost1 && total<cost2) return 1;\\n        for(int i=0;i<=total/cost1;i++){\\n            long long left=total-cost1*i;\\n            long long pencils=left/cost2+1;\\n            ans+=pencils;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1953822,
                "title": "c-simple-easy-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n         long long sum=0;\\n        int i=0;\\n        int total1=total;\\n        while(total1>0){\\n            total1=total;\\n            total1-=cost1*i;\\n             if(total1<0)\\n                break;\\n          \\n            sum+=(total1/cost2) +1;\\n       \\n            i++;\\n           \\n        }\\n       return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n         long long sum=0;\\n        int i=0;\\n        int total1=total;\\n        while(total1>0){\\n            total1=total;\\n            total1-=cost1*i;\\n             if(total1<0)\\n                break;\\n          \\n            sum+=(total1/cost2) +1;\\n       \\n            i++;\\n           \\n        }\\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953804,
                "title": "c-simple-maths-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if (cost1 > total && cost2 > total)\\n            return 1;\\n        long long x;\\n        long long y;\\n        long long count = 0;\\n        for(int x = 0; x <= floor(total / cost1); x++){\\n            y = (total - cost1 * x) / cost2;\\n            if (y == floor(y)){\\n                count += y + 1;\\n            }\\n        }\\n       \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if (cost1 > total && cost2 > total)\\n            return 1;\\n        long long x;\\n        long long y;\\n        long long count = 0;\\n        for(int x = 0; x <= floor(total / cost1); x++){\\n            y = (total - cost1 * x) / cost2;\\n            if (y == floor(y)){\\n                count += y + 1;\\n            }\\n        }\\n       \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953795,
                "title": "c-classic-dp-memoization",
                "content": "A perfect DP problem for a beginner to start with. How about we store states using memoization.\\n\\nOne thing worth noticing is that for every multiple of cost1 or cost2 our dp array gets filled using previous values.\\nLet\\'s initialize first element with \\'1\\' as per explained in second sample case. Now, iterate over all the possibilities and populate our dp array accordingly, doing for both cost 1 and 2.\\n\\nFinally, summing our dp array we got our number of ways.\\n\\n```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    ll waysToBuyPensPencils(int n, int c1, int c2) {\\n        vector<ll> dp(n+1,0);\\n        dp[0] = 1;\\n        for(int i=c1; i<=n; ++i) dp[i] += dp[i - c1];\\n        for(int i=c2; i<=n; ++i) dp[i] += dp[i - c2];\\n        return accumulate(dp.begin(), dp.end(), 0LL);\\n    }\\n};\\n```\\n\\nTime complexity :- O(n - c1 + 1) + O(n - c2 + 1) + O(n+1) = O(n)\\nSpace complexity :- O(n)\\n\\nAlthough I believe, it can be solved much efficiently using combinatorics and greedy but a solution worth mentioning in interviews. \\uD83D\\uDE09",
                "solutionTags": [],
                "code": "```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    ll waysToBuyPensPencils(int n, int c1, int c2) {\\n        vector<ll> dp(n+1,0);\\n        dp[0] = 1;\\n        for(int i=c1; i<=n; ++i) dp[i] += dp[i - c1];\\n        for(int i=c2; i<=n; ++i) dp[i] += dp[i - c2];\\n        return accumulate(dp.begin(), dp.end(), 0LL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953792,
                "title": "python3-solution-o-n",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        p = total // cost1\\n        ways = 0\\n        \\n        for i in range(p + 1):\\n            t = total - i * cost1\\n            ways += (t // cost2) + 1\\n           \\n        return ways\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        p = total // cost1\\n        ways = 0\\n        \\n        for i in range(p + 1):\\n            t = total - i * cost1\\n            ways += (t // cost2) + 1\\n           \\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953647,
                "title": "simple-and-easy-c-solution",
                "content": "```\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long n = 0;\\n        long long count = 0;\\n        while(n <= total) {\\n            count += (total-n)/cost2 + 1;\\n            n += cost1;\\n        }\\n        return count;\\n}\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long n = 0;\\n        long long count = 0;\\n        while(n <= total) {\\n            count += (total-n)/cost2 + 1;\\n            n += cost1;\\n        }\\n        return count;\\n}\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1953631,
                "title": "clean-java-solution-explanation-with-example",
                "content": "Let\\'s take an example of `total=10`, cost of pen: `cost1=5`, cost of pencil:  `cost2=2`\\nNow total number of ways =\\n* 0 pen + (0,1,2,3,4,5) pencils = 6 ways \\n* 1 pen + (0,1,2) pencils = 3 ways\\n* 2 pen + (0) pencil = 1 way\\nHence,  total number of ways = 6+3+1 = 10\\n**Note:** To consuider 0 in the case, I have added `cost2` everytime while calculating `ans`\\n```\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ans = 0;\\n        for (int i = 0; i * cost1 <= total; i++) \\n\\t\\t\\tans += (cost2 + total - i * cost1) / cost2;\\n        return ans;\\n    }\\n```\\nDon\\'t forget to upvote if it helps :)\\nKeep hustling!",
                "solutionTags": [],
                "code": "```\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ans = 0;\\n        for (int i = 0; i * cost1 <= total; i++) \\n\\t\\t\\tans += (cost2 + total - i * cost1) / cost2;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953622,
                "title": "java-concise-and-simple",
                "content": "```\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long res = 0;\\n        for (int cost = 0; cost <= total; cost += cost1)\\n        \\tres += (total - cost) / cost2 + 1;\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long res = 0;\\n        for (int cost = 0; cost <= total; cost += cost1)\\n        \\tres += (total - cost) / cost2 + 1;\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4092391,
                "title": "c-simple-2-line-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long long ans = 0;\\n\\n        for(int pen=0; pen<=total/cost1; pen++)\\n            ans += (total - pen*cost1)/cost2 + 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long long ans = 0;\\n\\n        for(int pen=0; pen<=total/cost1; pen++)\\n            ans += (total - pen*cost1)/cost2 + 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085484,
                "title": "less-memory-consumption",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long range = total / cost1;\\n        long totalSum = 0;\\n            for(long i =0; i<= range; i++){\\n                long prod = i*cost1;\\n                long amt = total - prod;\\n                totalSum += (amt / cost2) + 1 ;  \\n    }  \\n        return totalSum == 0? 1 : totalSum ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long range = total / cost1;\\n        long totalSum = 0;\\n            for(long i =0; i<= range; i++){\\n                long prod = i*cost1;\\n                long amt = total - prod;\\n                totalSum += (amt / cost2) + 1 ;  \\n    }  \\n        return totalSum == 0? 1 : totalSum ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063609,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n      long long ans=0;\\n      for (int i=0;i<=total;i+=cost1)\\n      {\\n          int left=(total-i);\\n          ans+=((left/cost2) +1);\\n      }    \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n      long long ans=0;\\n      for (int i=0;i<=total;i+=cost1)\\n      {\\n          int left=(total-i);\\n          ans+=((left/cost2) +1);\\n      }    \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040501,
                "title": "number-of-ways-to-buy-pens-and-pencils",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        // if(cost1>total&&cost2>total)\\n        // return 1;\\n        // long sum = 0;\\n        // sum=sum+total/cost1;\\n        // sum=sum+total/cost2;\\n        // if(total<cost1||total<cost2)\\n        // return sum+1;\\n        // sum=sum+(total-cost1)/cost1+(total-cost1)/cost2;\\n        // return sum;\\n    long ans = 0;\\n    final int maxPen = total / cost1;\\n    for (int i = 0; i <= maxPen; ++i)\\n      ans += (total - i * cost1) / cost2 + 1;\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        // if(cost1>total&&cost2>total)\\n        // return 1;\\n        // long sum = 0;\\n        // sum=sum+total/cost1;\\n        // sum=sum+total/cost2;\\n        // if(total<cost1||total<cost2)\\n        // return sum+1;\\n        // sum=sum+(total-cost1)/cost1+(total-cost1)/cost2;\\n        // return sum;\\n    long ans = 0;\\n    final int maxPen = total / cost1;\\n    for (int i = 0; i <= maxPen; ++i)\\n      ans += (total - i * cost1) / cost2 + 1;\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034467,
                "title": "easy-to-read-python3-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        if cost1 > total and cost2 > total:\\n            return 1\\n\\n        cur = 0\\n        ans = 0\\n        while cur <= total:\\n            curTotal = total - cur\\n            ans += (curTotal // cost2 + 1)\\n            cur += cost1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        if cost1 > total and cost2 > total:\\n            return 1\\n\\n        cur = 0\\n        ans = 0\\n        while cur <= total:\\n            curTotal = total - cur\\n            ans += (curTotal // cost2 + 1)\\n            cur += cost1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015058,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long ans = 0;\\n        long val = 0;\\n        for(int x=0; ; x++)\\n        {\\n            val = total-cost1*x;\\n            if(val<0) break;\\n            ans+= (long)Math.floor((long)val/(long)cost2)+1;\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution \\n{\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long ans = 0;\\n        long val = 0;\\n        for(int x=0; ; x++)\\n        {\\n            val = total-cost1*x;\\n            if(val<0) break;\\n            ans+= (long)Math.floor((long)val/(long)cost2)+1;\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989634,
                "title": "simple-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        long long pen,pencil;\\n        pen = total/cost1;\\n        // pencil = total/cost2;\\n\\n        for(int i=0;i<=pen;i++){\\n            long long num_pen = total-(cost1*i);\\n\\n            long long temp = (num_pen)/cost2;\\n            ans+=temp;\\n            ans+=1;\\n        }\\n\\n        // if(ans==1){\\n        //     ans+=pencil;\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        long long pen,pencil;\\n        pen = total/cost1;\\n        // pencil = total/cost2;\\n\\n        for(int i=0;i<=pen;i++){\\n            long long num_pen = total-(cost1*i);\\n\\n            long long temp = (num_pen)/cost2;\\n            ans+=temp;\\n            ans+=1;\\n        }\\n\\n        // if(ans==1){\\n        //     ans+=pencil;\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968596,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nvar waysToBuyPensPencils = function(total, cost1, cost2) {\\n    let res=0;\\n    for(let i=0; i<=total/cost1; i++){\\n        res+=Math.floor((total-cost1*i)/cost2)+1;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nvar waysToBuyPensPencils = function(total, cost1, cost2) {\\n    let res=0;\\n    for(let i=0; i<=total/cost1; i++){\\n        res+=Math.floor((total-cost1*i)/cost2)+1;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954770,
                "title": "python-3-easy-to-understand-with-comments-and-math",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        # 1. set up an answer variable\\n        answer = 0\\n\\n        # 2. go thru every multiple of total // cost1 + 1, we add 1 because we need to account for when we buy 0 items of cost1\\n        for i in range(total // cost1 + 1):\\n            # 2.1. remainder is how much is left for items of cost2\\n            remainder = total - i * cost1\\n            # 2.2. add remainder // cost2 + 1 to the answer, remainder // cost2 is how many items of cost2 we can buy, the 1 is for when we buy 0 items of cost2\\n            answer += remainder // cost2 + 1\\n\\n        # 3. return the variable\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        # 1. set up an answer variable\\n        answer = 0\\n\\n        # 2. go thru every multiple of total // cost1 + 1, we add 1 because we need to account for when we buy 0 items of cost1\\n        for i in range(total // cost1 + 1):\\n            # 2.1. remainder is how much is left for items of cost2\\n            remainder = total - i * cost1\\n            # 2.2. add remainder // cost2 + 1 to the answer, remainder // cost2 is how many items of cost2 we can buy, the 1 is for when we buy 0 items of cost2\\n            answer += remainder // cost2 + 1\\n\\n        # 3. return the variable\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926483,
                "title": "solution-using-floor-division-rt-better-than-96-mem-better-than-93",
                "content": "# Approach\\nSimple approach using floor division.\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ways = 0\\n\\n        m = max(cost1, cost2)\\n        n = min(cost1, cost2)\\n\\n        for i in range((total // m) + 1):\\n            _sum = total - (i * m)\\n            ways += (_sum // n) + 1\\n\\n        return ways\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ways = 0\\n\\n        m = max(cost1, cost2)\\n        n = min(cost1, cost2)\\n\\n        for i in range((total // m) + 1):\\n            _sum = total - (i * m)\\n            ways += (_sum // n) + 1\\n\\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897995,
                "title": "easy-permutation-beats-82",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        int maxpens = total/cost1;\\n        for(int i=0;i<=maxpens;i++)\\n        {\\n            int rem=total-(i*cost1);\\n            int possible = rem/cost2;\\n            ans = ans+(long long)possible+(long long)1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        int maxpens = total/cost1;\\n        for(int i=0;i<=maxpens;i++)\\n        {\\n            int rem=total-(i*cost1);\\n            int possible = rem/cost2;\\n            ans = ans+(long long)possible+(long long)1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879396,
                "title": "java-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int pen = 0;\\n        int alPen = total/cost1;\\n        long ans = 0;\\n        while(pen<=alPen){\\n            int remCost = total-(cost1*pen);\\n            int temp1 = (remCost/cost2) +1;\\n            ans = ans+temp1;\\n            pen++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int pen = 0;\\n        int alPen = total/cost1;\\n        long ans = 0;\\n        while(pen<=alPen){\\n            int remCost = total-(cost1*pen);\\n            int temp1 = (remCost/cost2) +1;\\n            ans = ans+temp1;\\n            pen++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864898,
                "title": "simple-if-else-if-arithmetic-division",
                "content": "# Code\\n```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nconst waysToBuyPensPencils = function(total, cost1, cost2) {\\n  let distinctWays = 0;\\n\\n  if (cost1 <= total && cost2 <= total) {\\n\\n    const maxCost = Math.max(cost1, cost2);\\n    const minCost = Math.min(cost1, cost2);\\n\\n    while (total >= 0) {\\n      distinctWays += Math.floor(total / minCost) + 1;\\n      total -= maxCost;\\n    }\\n\\n  } else if (cost1 > total && cost2 <= total) {\\n\\n    distinctWays = Math.floor(total / cost2) + 1;\\n\\n  } else if (cost1 <= total && cost2 > total) {\\n\\n    distinctWays = Math.floor(total / cost1) + 1;\\n\\n  } else if (cost1 > total && cost2 > total) {\\n\\n    // 0 Pen and 0 Pencil\\n    distinctWays = 1;\\n\\n  }\\n\\n  return distinctWays;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nconst waysToBuyPensPencils = function(total, cost1, cost2) {\\n  let distinctWays = 0;\\n\\n  if (cost1 <= total && cost2 <= total) {\\n\\n    const maxCost = Math.max(cost1, cost2);\\n    const minCost = Math.min(cost1, cost2);\\n\\n    while (total >= 0) {\\n      distinctWays += Math.floor(total / minCost) + 1;\\n      total -= maxCost;\\n    }\\n\\n  } else if (cost1 > total && cost2 <= total) {\\n\\n    distinctWays = Math.floor(total / cost2) + 1;\\n\\n  } else if (cost1 <= total && cost2 > total) {\\n\\n    distinctWays = Math.floor(total / cost1) + 1;\\n\\n  } else if (cost1 > total && cost2 > total) {\\n\\n    // 0 Pen and 0 Pencil\\n    distinctWays = 1;\\n\\n  }\\n\\n  return distinctWays;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854606,
                "title": "count-no-of-pens-bought-for-pencils-bought-0-1-2-3",
                "content": "# Complexity\\n- Time complexity: $$O(total/cost)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n      int totalPencils = total/cost2;\\n      long long ans = 0;\\n      for(int pencils=0; pencils<=totalPencils; pencils++)\\n      {\\n          int rupeesLeft = total - pencils*cost2; \\n          int pens = floor(rupeesLeft/cost1);\\n           ans += (pens+1);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n      int totalPencils = total/cost2;\\n      long long ans = 0;\\n      for(int pencils=0; pencils<=totalPencils; pencils++)\\n      {\\n          int rupeesLeft = total - pencils*cost2; \\n          int pens = floor(rupeesLeft/cost1);\\n           ans += (pens+1);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853078,
                "title": "c-easy-solution-simple-maths",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int n=total/cost1;\\n        ll ans=0;\\n        for(int i=0;i<=n;i++){\\n            int k=total - (i*cost1);\\n            ans+=(k/cost2+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int n=total/cost1;\\n        ll ans=0;\\n        for(int i=0;i<=n;i++){\\n            int k=total - (i*cost1);\\n            ans+=(k/cost2+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822810,
                "title": "easy-solution-97-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple for Loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int n = total/cost1;\\n        long ways=0;\\n        for(int i=0; i<=n; i++){\\n            ways +=(total-cost1*i)/cost2+1;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int n = total/cost1;\\n        long ways=0;\\n        for(int i=0; i<=n; i++){\\n            ways +=(total-cost1*i)/cost2+1;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786150,
                "title": "number-of-way-buy-pencil-and-pen-based-on-given-total",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(total)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n      long long ans=0;\\n      ans+=(total/cost2)+1;\\n      while(total>0)\\n      {\\n          total-=cost1;\\n          if(total<0)\\n          {\\n              break;\\n          }\\n          if(total==0)\\n          {\\n              ans+=1;\\n              break;\\n          }\\n          ans+=(total/cost2)+1;\\n      }\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n      long long ans=0;\\n      ans+=(total/cost2)+1;\\n      while(total>0)\\n      {\\n          total-=cost1;\\n          if(total<0)\\n          {\\n              break;\\n          }\\n          if(total==0)\\n          {\\n              ans+=1;\\n              break;\\n          }\\n          ans+=(total/cost2)+1;\\n      }\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741363,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        // iterate over the larger cost to improve performance\\n        int costMax = Math.max(cost1, cost2);\\n        int costMin = Math.min(cost1, cost2);\\n\\n        long r = 1 + total / costMax;\\n\\n        for (int left = total; left >= 0; left -= costMax) {\\n            r += left / costMin;\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        // iterate over the larger cost to improve performance\\n        int costMax = Math.max(cost1, cost2);\\n        int costMin = Math.min(cost1, cost2);\\n\\n        long r = 1 + total / costMax;\\n\\n        for (int left = total; left >= 0; left -= costMax) {\\n            r += left / costMin;\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741041,
                "title": "linear-1-liner",
                "content": "\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, t: int, c1: int, c2: int) -> int:\\n        return sum((t-c1*i)//c2+1 for i in range(0, t//c1+1))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, t: int, c1: int, c2: int) -> int:\\n        return sum((t-c1*i)//c2+1 for i in range(0, t//c1+1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713922,
                "title": "simple-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate how many you can buy for the more expensive one, then from buying none of the more expensive one to max, calculate how many less expensive one you can buy, sums up all the answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  - O(total / maxPrice)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction waysToBuyPensPencils(total: number, cost1: number, cost2: number): number {\\n    const maxPrice = Math.max(cost1, cost2);\\n    const minPrice = Math.min(cost1, cost2);\\n    const mostForMaxPrice = Math.floor(total / maxPrice);\\n\\n    let count = 0;\\n    for(let i = 0; i <= mostForMaxPrice; i++) {\\n        count += Math.floor((total - maxPrice * i) / minPrice) + 1\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction waysToBuyPensPencils(total: number, cost1: number, cost2: number): number {\\n    const maxPrice = Math.max(cost1, cost2);\\n    const minPrice = Math.min(cost1, cost2);\\n    const mostForMaxPrice = Math.floor(total / maxPrice);\\n\\n    let count = 0;\\n    for(let i = 0; i <= mostForMaxPrice; i++) {\\n        count += Math.floor((total - maxPrice * i) / minPrice) + 1\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3711139,
                "title": "easy-brute-force-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        while(total>=0){\\n            ans+=(total/cost2);\\n            ans++;\\n            total-=cost1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        while(total>=0){\\n            ans+=(total/cost2);\\n            ans++;\\n            total-=cost1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699177,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, c1: int, c2: int) -> int:\\n\\n        m=max(c1,c2)\\n        n=min(c1,c2)\\n        d=total//m\\n        ans=0\\n        for i in range(0,d+1):\\n            ans=ans+1+(total//n)\\n            total-=m\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, c1: int, c2: int) -> int:\\n\\n        m=max(c1,c2)\\n        n=min(c1,c2)\\n        d=total//m\\n        ans=0\\n        for i in range(0,d+1):\\n            ans=ans+1+(total//n)\\n            total-=m\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692401,
                "title": "java-easy-to-understand-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        long result=0;\\n\\n        while(total>=0){\\n            result+=(total/cost2)+1;\\n            total-=cost1;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        long result=0;\\n\\n        while(total>=0){\\n            result+=(total/cost2)+1;\\n            total-=cost1;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692003,
                "title": "simple-explanation-using-coin-change-problem-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        # Similar to Coin Change (1 , 2) problem \\n    \\n        lst = [cost1 , cost2]\\n        # Tabulation ..!\\n\\n        dp = [[1 for i in range(total+1)] for j in range(2)]        \\n        # initially set app element od dp to 1 .... \\n        # this is only difference from Coin Change (where we set as 0 )\\n\\n        for ind in range(2):\\n            for target in range(total+1):\\n                not_take = dp[ind-1][target]\\n\\n                take = 0\\n                if lst[ind] <= target:\\n                    take = dp[ind][target-lst[ind]]\\n                \\n                dp[ind][target] = take + not_take\\n        return dp[1][target]\\n\\n        # Memoization ...!! [Maximum Recursion Depth exceeded]        \\n        \"\"\"\\n        lst = [cost1 , cost2]\\n        min_val = min(cost1 , cost2)\\n\\n        dp = [[-1 for i in range(total+1)] for j in range(2)]\\n\\n        def solve( ind , target ):\\n            if target < min_val:\\n                return 0\\n            \\n            if ind == 0:\\n                return (target // lst[0]) \\n            \\n            if dp[ind][target] != -1: dp[ind][target]\\n\\n            not_take = solve( ind-1 , target )\\n\\n            take = 0\\n            if lst[ind] <= target:\\n                take = 1 + solve( ind , target-lst[ind] )\\n            \\n            dp[ind][target] = take + not_take\\n            return dp[ind][target]\\n\\n        return solve( 1 , total ) + 1\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        # Similar to Coin Change (1 , 2) problem \\n    \\n        lst = [cost1 , cost2]\\n        # Tabulation ..!\\n\\n        dp = [[1 for i in range(total+1)] for j in range(2)]        \\n        # initially set app element od dp to 1 .... \\n        # this is only difference from Coin Change (where we set as 0 )\\n\\n        for ind in range(2):\\n            for target in range(total+1):\\n                not_take = dp[ind-1][target]\\n\\n                take = 0\\n                if lst[ind] <= target:\\n                    take = dp[ind][target-lst[ind]]\\n                \\n                dp[ind][target] = take + not_take\\n        return dp[1][target]\\n\\n        # Memoization ...!! [Maximum Recursion Depth exceeded]        \\n        \"\"\"\\n        lst = [cost1 , cost2]\\n        min_val = min(cost1 , cost2)\\n\\n        dp = [[-1 for i in range(total+1)] for j in range(2)]\\n\\n        def solve( ind , target ):\\n            if target < min_val:\\n                return 0\\n            \\n            if ind == 0:\\n                return (target // lst[0]) \\n            \\n            if dp[ind][target] != -1: dp[ind][target]\\n\\n            not_take = solve( ind-1 , target )\\n\\n            take = 0\\n            if lst[ind] <= target:\\n                take = 1 + solve( ind , target-lst[ind] )\\n            \\n            dp[ind][target] = take + not_take\\n            return dp[ind][target]\\n\\n        return solve( 1 , total ) + 1\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677283,
                "title": "easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int t, int c1, int c2) {\\n        if(t<c1 && t<c2) return 1; // if total cost is less than both\\n        long long ways=0; // no of ways to  spend\\n      for(int i=0;i<=t/c1;i++){\\n          ways+= (t-(i*c1))/c2 +1;\\n\\n      }\\n       return ways;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int t, int c1, int c2) {\\n        if(t<c1 && t<c2) return 1; // if total cost is less than both\\n        long long ways=0; // no of ways to  spend\\n      for(int i=0;i<=t/c1;i++){\\n          ways+= (t-(i*c1))/c2 +1;\\n\\n      }\\n       return ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673199,
                "title": "easy-and-descriptive-solution",
                "content": "**Fix the count of one article and count the other one** \\n\\n\\n(1)Initialise count to 0.(as return type is long long count variable is not int but long long.)\\n\\n(2)Initialise another variable temp with total.\\n\\n(3)if cost of both articles is less than total money we return 1\\n\\n(4)Otherwise run a for loop from 0 to total/cost2 (here we are fixing count of pencils thus cost2 is used)\\n\\n(5)decrease temp every time by i times cost of pencil(i times because i represents how many pencils have been bought already and temp will tell how much money is left to buy pens)\\n\\n(6)Increase count by temp/cost1 + 1 times on every iteration of loop(divide by cost1 because these much pens can be bought +1 because total ways will be +1 of no. of pens bought)\\nEx-when i=0 we buy 0 pencils and can buy 0,1,2 pens i.e., we can buy in 3 ways (0 pencil and 0 pens , 0 pencil and 1 pen, 0 pencil and 2 pens)\\n\\n(7)At end of each iteration we reset temp to original total money\\n \\n(8)At last return Count.   \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long count=0;\\n        int temp=total;\\n        if(cost1>total && cost2>total)\\n            return 1;\\n        else{\\n            for(int i=0;i<=total/cost2;i++){\\n                temp-=i*cost2;\\n                count+=(temp/cost1)+1;\\n                temp=total;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long count=0;\\n        int temp=total;\\n        if(cost1>total && cost2>total)\\n            return 1;\\n        else{\\n            for(int i=0;i<=total/cost2;i++){\\n                temp-=i*cost2;\\n                count+=(temp/cost1)+1;\\n                temp=total;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669581,
                "title": "66-loop-and-math",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        max_c1 = total // cost1\\n        ways = max_c1+1\\n        for i in range (max_c1+1):\\n            current_cost = i*cost1\\n            rest = total - current_cost\\n            cost_2_ways = (rest // cost2)\\n            ways += cost_2_ways\\n        return (ways)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        max_c1 = total // cost1\\n        ways = max_c1+1\\n        for i in range (max_c1+1):\\n            current_cost = i*cost1\\n            rest = total - current_cost\\n            cost_2_ways = (rest // cost2)\\n            ways += cost_2_ways\\n        return (ways)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668208,
                "title": "c-easy-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        while(total>=0){\\n      \\n        ans+=((total/cost2)+1);\\n        total=total-cost1;\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0;\\n        while(total>=0){\\n      \\n        ans+=((total/cost2)+1);\\n        total=total-cost1;\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650154,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nvar waysToBuyPensPencils = function(total, cost1, cost2) {\\n    // pen pencil\\n    let count = 0;\\n    let price = 0;\\n    let pen = 1;\\n    // 0 pen = > 4 + 1 pencils\\n    // 1 pen => 2 + 1 pencils\\n    // 2 pen => 0 + 1 pencils\\n    while (price <= total){\\n        count = count + 1 + Math.floor((total-price)/cost2);\\n        price = pen * cost1;\\n        pen+=1;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nvar waysToBuyPensPencils = function(total, cost1, cost2) {\\n    // pen pencil\\n    let count = 0;\\n    let price = 0;\\n    let pen = 1;\\n    // 0 pen = > 4 + 1 pencils\\n    // 1 pen => 2 + 1 pencils\\n    // 2 pen => 0 + 1 pencils\\n    while (price <= total){\\n        count = count + 1 + Math.floor((total-price)/cost2);\\n        price = pen * cost1;\\n        pen+=1;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642410,
                "title": "c-easy",
                "content": "# Intuition\\nBasic combination problem \\n\\n# Complexity\\n- Time complexity:\\n O(n) where: n= (total/max(cost1,cost2)) + 1\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        //considering maximum cost permutation first\\n        long long i=0,pri=max(cost1,cost2),npri=min(cost1,cost2);\\n        long long n=total/pri;\\n        \\n        /*In case where the total amount is less then the value of \\n          maximum cost; we get combinations based on minimum cost */\\n        if(n==0){\\n            return (total/npri)+1;\\n        }\\n\\n        //sum of all the combinations considering both the costs;\\n        long long sum=0;\\n        while(i<=n){\\n            int temp=total-i*pri;\\n            sum+=(temp/npri)+1;\\n            i++;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        \\n        //considering maximum cost permutation first\\n        long long i=0,pri=max(cost1,cost2),npri=min(cost1,cost2);\\n        long long n=total/pri;\\n        \\n        /*In case where the total amount is less then the value of \\n          maximum cost; we get combinations based on minimum cost */\\n        if(n==0){\\n            return (total/npri)+1;\\n        }\\n\\n        //sum of all the combinations considering both the costs;\\n        long long sum=0;\\n        while(i<=n){\\n            int temp=total-i*pri;\\n            sum+=(temp/npri)+1;\\n            i++;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636029,
                "title": "c-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        while (total >= 0){\\n            int n = total / cost1;\\n            ++ans += n;\\n            total -= cost2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        while (total >= 0){\\n            int n = total / cost1;\\n            ++ans += n;\\n            total -= cost2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633269,
                "title": "easy-explanation-beats-100",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(total < cost1 && total < cost2) return 1;            // 0 pen 0 pencil\\n        long long ans = 0;\\n\\t\\t// keeping cost1 as maximum so that we have minimum opperations later \\n        if(cost2 > cost1) swap(cost2, cost1);\\n        int n = (total/cost1)+ 1;\\n\\t\\t\\n\\t\\t// Calculate the number of  pens you can buy for each number of pencils\\n\\t\\t// for 0 pens -> total_pencil = total_cost / cost_of_pencil +1\\n\\t\\t// for 1 pen -> total_pencil = (total_cost-cost_of_1pen) / cost_of_pencil +1\\n\\t\\t// dry run once... you\\'ll get it\\n        for(int i = 0; i < n; i++){\\n            ans += total / cost2 + 1;\\n            total -= cost1;\\n        }\\n        // ans += n; (if we don\\'t add 1 in each step we can do +n instead)\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(total < cost1 && total < cost2) return 1;            // 0 pen 0 pencil\\n        long long ans = 0;\\n\\t\\t// keeping cost1 as maximum so that we have minimum opperations later \\n        if(cost2 > cost1) swap(cost2, cost1);\\n        int n = (total/cost1)+ 1;\\n\\t\\t\\n\\t\\t// Calculate the number of  pens you can buy for each number of pencils\\n\\t\\t// for 0 pens -> total_pencil = total_cost / cost_of_pencil +1\\n\\t\\t// for 1 pen -> total_pencil = (total_cost-cost_of_1pen) / cost_of_pencil +1\\n\\t\\t// dry run once... you\\'ll get it\\n        for(int i = 0; i < n; i++){\\n            ans += total / cost2 + 1;\\n            total -= cost1;\\n        }\\n        // ans += n; (if we don\\'t add 1 in each step we can do +n instead)\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623386,
                "title": "c-simple-4-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int amount, int cost1, int cost2) {\\n        long long ans=0,j,i;\\n        for(i=0;i<=amount;i+=cost2){\\n           j=amount-i;\\n           ans+=(j/cost1)+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int amount, int cost1, int cost2) {\\n        long long ans=0,j,i;\\n        for(i=0;i<=amount;i+=cost2){\\n           j=amount-i;\\n           ans+=(j/cost1)+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610434,
                "title": "c-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n    if(cost1>total and cost2>total) {\\n        return 1;\\n    } \\n    long long ans=0;  \\n    for(int i=0;i<=(total/cost1);i++){\\n        ans+=(total-(cost1*(i)))/cost2+1;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n    if(cost1>total and cost2>total) {\\n        return 1;\\n    } \\n    long long ans=0;  \\n    for(int i=0;i<=(total/cost1);i++){\\n        ans+=(total-(cost1*(i)))/cost2+1;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603804,
                "title": "python-o-n",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$ n being the maximum number of Pens that can be purchesed\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        count = 0\\n\\n        for numPen in range(0, (total//cost1)+1):\\n            # print(((total - cost1*numPen)//cost2)+1)\\n            count += (total - cost1*numPen)//cost2+1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        count = 0\\n\\n        for numPen in range(0, (total//cost1)+1):\\n            # print(((total - cost1*numPen)//cost2)+1)\\n            count += (total - cost1*numPen)//cost2+1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601785,
                "title": "straightforward-ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nFind the max number of pens you can buy.  For each pen possibility, add the number of pencil possibilities to count.\\n\\n# Approach\\n1. Initialize count to zero.\\n2. Find the max number of pens you can buy.\\n3. For each number of pens, subtract the cost of those pens from total and divide by the cost of pencils to find the max number of pencils you can buy.  Add that to count, +1 because you could buy 0 pencils.\\n4. Return count.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where *n* is the maximum number of pens you can buy.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef ways_to_buy_pens_pencils(total, pen, pencil)\\n    count = 0\\n    max_pen = total / pen\\n    (0..max_pen).each { |k| count += (total - k*pen) / pencil + 1 }\\n    count \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef ways_to_buy_pens_pencils(total, pen, pencil)\\n    count = 0\\n    max_pen = total / pen\\n    (0..max_pen).each { |k| count += (total - k*pen) / pencil + 1 }\\n    count \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3578700,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn ways_to_buy_pens_pencils(total: i32, cost1: i32, cost2: i32) -> i64 {\\n    let mut result = 0;\\n    let t = total as i64;\\n    let c1 = cost1 as i64;\\n    let c2 = cost2 as i64;\\n    for num in 0.. {\\n      let v = num * c1;\\n      if t < v {\\n        break\\n      }\\n\\n      let left = t - v;\\n      result += left / c2 + 1;\\n    }\\n\\n    result      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn ways_to_buy_pens_pencils(total: i32, cost1: i32, cost2: i32) -> i64 {\\n    let mut result = 0;\\n    let t = total as i64;\\n    let c1 = cost1 as i64;\\n    let c2 = cost2 as i64;\\n    for num in 0.. {\\n      let v = num * c1;\\n      if t < v {\\n        break\\n      }\\n\\n      let left = t - v;\\n      result += left / c2 + 1;\\n    }\\n\\n    result      \\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536645,
                "title": "short-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n            long long count=0;\\n            while(total>=0)\\n            {\\n                count+=(total/cost2)+1;\\n                total-=cost1;\\n            }\\n            return count;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n            long long count=0;\\n            while(total>=0)\\n            {\\n                count+=(total/cost2)+1;\\n                total-=cost1;\\n            }\\n            return count;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511941,
                "title": "c-math-easy-solution",
                "content": "# Intuition\\nFix the number of pencil and then find number of ways to take pens. For example if we take one pencil then the total cost will reduce by the cost of one pencil and now we need to find how many pens we can take with remaining money i.e. either 0, 1, 2....etc.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int tot, int c1, int c2) {\\n        long long ans = 0;\\n        long long maxp = tot/c1;\\n        for(int i=0;i<=maxp;i++)\\n        {\\n            long long pen = (tot-(i*c1))/c2;\\n            ans+=(pen+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int tot, int c1, int c2) {\\n        long long ans = 0;\\n        long long maxp = tot/c1;\\n        for(int i=0;i<=maxp;i++)\\n        {\\n            long long pen = (tot-(i*c1))/c2;\\n            ans+=(pen+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510058,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long max(long long x , long long y)\\n    {\\n        if(x > y) return x; \\n        return y;\\n    }\\n    \\n    long long waysToBuyPensPencils(int n, int c1, int c2) {\\n        long long ans = 0; \\n        // c1*x + c2*y = n\\n        int max_x = n / c1; \\n        for(int i = 0 ; i <= max_x ; ++i){\\n            int n_y = n - (i * c1); \\n            if(n_y < 0) break; \\n            int cnt = n_y / c2; \\n            int rem = n_y % c2; \\n            ++cnt; \\n            //cout << \" i \" << i << \" ny \" << n_y << \" rem \" << rem << \" cnt \" << cnt << endl; \\n            ans = ans + cnt; \\n        }\\n        return max(1, ans); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long max(long long x , long long y)\\n    {\\n        if(x > y) return x; \\n        return y;\\n    }\\n    \\n    long long waysToBuyPensPencils(int n, int c1, int c2) {\\n        long long ans = 0; \\n        // c1*x + c2*y = n\\n        int max_x = n / c1; \\n        for(int i = 0 ; i <= max_x ; ++i){\\n            int n_y = n - (i * c1); \\n            if(n_y < 0) break; \\n            int cnt = n_y / c2; \\n            int rem = n_y % c2; \\n            ++cnt; \\n            //cout << \" i \" << i << \" ny \" << n_y << \" rem \" << rem << \" cnt \" << cnt << endl; \\n            ans = ans + cnt; \\n        }\\n        return max(1, ans); \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3491837,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple maths use cost1 as count for 1 type of pensil and count number of type2 pensil you can buy of remaining cost.\\nHere 1 extra denotes you can buy 0 type2 pencil\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0,count1=0;\\n        while(count1*cost1<=total)\\n        {\\n            int remain=total-count1*cost1;\\n            ans+=(1+remain/cost2);\\n            count1++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans=0,count1=0;\\n        while(count1*cost1<=total)\\n        {\\n            int remain=total-count1*cost1;\\n            ans+=(1+remain/cost2);\\n            count1++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490084,
                "title": "a-simpler-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long int ways=0;\\n        long long tempcount=0;\\n\\n        while(total>=0) {\\n            ways=ways + total/cost2;\\n            total= total -cost1;\\n            tempcount++;\\n        }\\n        return ways+tempcount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long int ways=0;\\n        long long tempcount=0;\\n\\n        while(total>=0) {\\n            ways=ways + total/cost2;\\n            total= total -cost1;\\n            tempcount++;\\n        }\\n        return ways+tempcount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449992,
                "title": "scala-count-bought-pens-beats-100-100",
                "content": "# Approach\\nIterate over \"bought pens\" and accumulate possible amount of bought pencies for the money left\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nobject Solution {\\n\\n  def waysToBuyPensPencils(total: Int, cost1: Int, cost2: Int): Long = {\\n    var result = 0L\\n\\n    var boughtPens = 0\\n    while (boughtPens * cost1 <= total){\\n      val left = total - (boughtPens * cost1)\\n      val canBuyPencils = left / cost2 + 1\\n      result += canBuyPencils\\n      boughtPens += 1\\n    }\\n\\n    result\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Math",
                    "Enumeration"
                ],
                "code": "```\\nobject Solution {\\n\\n  def waysToBuyPensPencils(total: Int, cost1: Int, cost2: Int): Long = {\\n    var result = 0L\\n\\n    var boughtPens = 0\\n    while (boughtPens * cost1 <= total){\\n      val left = total - (boughtPens * cost1)\\n      val canBuyPencils = left / cost2 + 1\\n      result += canBuyPencils\\n      boughtPens += 1\\n    }\\n\\n    result\\n  }\\n\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3441695,
                "title": "beginner-friendly-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {    \\n    int pen=total/cost1;\\n    int pencil=total/cost2;\\n    long count=0;\\n    int i=0;\\n    int temp=total;\\n    while(i<=pen){\\n    temp=temp-(cost1*i);\\n    int sum=temp/cost2;\\n    count=count+sum+1;\\n    temp=total;\\n    i++;\\n    }\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {    \\n    int pen=total/cost1;\\n    int pencil=total/cost2;\\n    long count=0;\\n    int i=0;\\n    int temp=total;\\n    while(i<=pen){\\n    temp=temp-(cost1*i);\\n    int sum=temp/cost2;\\n    count=count+sum+1;\\n    temp=total;\\n    i++;\\n    }\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440232,
                "title": "js-javascript-simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nvar waysToBuyPensPencils = function(total, cost1, cost2) {\\n  let res = 0;\\n  let i = 0\\n  while (cost1 * i <= total){\\n      res += 1 +  Math.trunc((total - cost1 * i) / cost2)\\n      i++\\n  }  \\n  return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} total\\n * @param {number} cost1\\n * @param {number} cost2\\n * @return {number}\\n */\\nvar waysToBuyPensPencils = function(total, cost1, cost2) {\\n  let res = 0;\\n  let i = 0\\n  while (cost1 * i <= total){\\n      res += 1 +  Math.trunc((total - cost1 * i) / cost2)\\n      i++\\n  }  \\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439523,
                "title": "math-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        l = total//cost1\\n        count = 0\\n        for i in range(l+1):\\n            remain = total-cost1*i\\n            num = remain // cost2\\n            count += (num+1)\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        l = total//cost1\\n        count = 0\\n        for i in range(l+1):\\n            remain = total-cost1*i\\n            num = remain // cost2\\n            count += (num+1)\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426197,
                "title": "simple-math-c-easy",
                "content": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ans = 0;\\n        int k = total/cost1, count = 0;\\n        while(count <= k){\\n            int amt_left = total - count*cost1;\\n            ans += amt_left/cost2 + 1;\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ans = 0;\\n        int k = total/cost1, count = 0;\\n        while(count <= k){\\n            int amt_left = total - count*cost1;\\n            ans += amt_left/cost2 + 1;\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414185,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ncost1, res = total//cost1, 0\\n        for i in range(ncost1 + 1):\\n            totalremaining = total - cost1*i\\n            if totalremaining >= 0:\\n                res += totalremaining//cost2\\n            res+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        ncost1, res = total//cost1, 0\\n        for i in range(ncost1 + 1):\\n            totalremaining = total - cost1*i\\n            if totalremaining >= 0:\\n                res += totalremaining//cost2\\n            res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396258,
                "title": "75-36-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long way = 0;\\n        for (int i = 0; ; i++) {\\n            int totCost1 = i * cost1;\\n            if (totCost1 > total)\\n                break;\\n            int totCost2 = total - totCost1;\\n            int temp = totCost2 / cost2 + 1;\\n            way += temp;\\n        }\\n        return way;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long way = 0;\\n        for (int i = 0; ; i++) {\\n            int totCost1 = i * cost1;\\n            if (totCost1 > total)\\n                break;\\n            int totCost2 = total - totCost1;\\n            int temp = totCost2 / cost2 + 1;\\n            way += temp;\\n        }\\n        return way;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367727,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func waysToBuyPensPencils(_ total: Int, _ cost1: Int, _ cost2: Int) -> Int {\\n        \\n        var res = 1\\n        var money = total\\n\\n        while money >= min(cost1, cost2) {\\n            res += min(1, money / cost1) + money / cost2\\n            money -= cost1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func waysToBuyPensPencils(_ total: Int, _ cost1: Int, _ cost2: Int) -> Int {\\n        \\n        var res = 1\\n        var money = total\\n\\n        while money >= min(cost1, cost2) {\\n            res += min(1, money / cost1) + money / cost2\\n            money -= cost1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356360,
                "title": "division",
                "content": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long cnt = 0;\\n        int sum = total;\\n        while(sum >= 0 || sum/cost2 > 0) {\\n            cnt+= (sum/cost2 + 1);\\n            sum -= cost1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long cnt = 0;\\n        int sum = total;\\n        while(sum >= 0 || sum/cost2 > 0) {\\n            cnt+= (sum/cost2 + 1);\\n            sum -= cost1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329959,
                "title": "simple-math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        long long end1 = total/cost1;\\n        for(int i = 0;i<=end1;i++){\\n            long long rem = total - i*cost1;\\n            if(rem==0) ans++;\\n            else if(rem>0) ans = ans + (rem/cost2)+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long ans = 0;\\n        long long end1 = total/cost1;\\n        for(int i = 0;i<=end1;i++){\\n            long long rem = total - i*cost1;\\n            if(rem==0) ans++;\\n            else if(rem>0) ans = ans + (rem/cost2)+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326598,
                "title": "c-solution-beat-100-iterative-math",
                "content": "# Complexity\\n- Time complexity: `O( min( numPens, numPencils )`\\n\\n- Space complexity: `O( 1 )`\\n\\n# Code\\n```\\n//\\n// Time Complexity: O( min( numPens, numPencils )\\n// Space Complexity: O( 1 )\\n//\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int largerCost = cost1 >= cost2 ? cost1 : cost2;\\n        int smallerCost = cost1 <= cost2 ? cost1 : cost2;\\n\\n        long long count = 0;\\n        for ( int i = 0; i <= total / largerCost; ++i ) {\\n            count += ( total - largerCost * i ) / smallerCost + 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//\\n// Time Complexity: O( min( numPens, numPencils )\\n// Space Complexity: O( 1 )\\n//\\n\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        int largerCost = cost1 >= cost2 ? cost1 : cost2;\\n        int smallerCost = cost1 <= cost2 ? cost1 : cost2;\\n\\n        long long count = 0;\\n        for ( int i = 0; i <= total / largerCost; ++i ) {\\n            count += ( total - largerCost * i ) / smallerCost + 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316895,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        tot = 0\\n        cost1_cnt = total//cost1 + 1\\n        for i in range(cost1_cnt):\\n            tot += (total - i * cost1)//cost2 + 1\\n        return tot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        tot = 0\\n        cost1_cnt = total//cost1 + 1\\n        for i in range(cost1_cnt):\\n            tot += (total - i * cost1)//cost2 + 1\\n        return tot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299285,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long count =0;\\n        int maxCost1 = total / cost1;\\n        int maxCost2 = total / cost2;\\n\\n        if(total < 1000){\\n        for(int i =0 ; i<=maxCost1; i++){\\n            for(int j=0; j<=maxCost2; j++){\\n                System.out.println(cost1*i + cost2*j); \\n                int totPrice = cost1*i + cost2*j;\\n                if(totPrice <= total){\\n                    count++;\\n                }\\n            }\\n            \\n        }\\n    }\\n    else{\\n        for(int i =0 ; i<=maxCost1; i++){\\n            int remMoney = total - i * cost1;\\n            int maxcost2 = remMoney / cost2;\\n\\n            count += maxcost2 + 1;\\n        }\\n    }\\n\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long count =0;\\n        int maxCost1 = total / cost1;\\n        int maxCost2 = total / cost2;\\n\\n        if(total < 1000){\\n        for(int i =0 ; i<=maxCost1; i++){\\n            for(int j=0; j<=maxCost2; j++){\\n                System.out.println(cost1*i + cost2*j); \\n                int totPrice = cost1*i + cost2*j;\\n                if(totPrice <= total){\\n                    count++;\\n                }\\n            }\\n            \\n        }\\n    }\\n    else{\\n        for(int i =0 ; i<=maxCost1; i++){\\n            int remMoney = total - i * cost1;\\n            int maxcost2 = remMoney / cost2;\\n\\n            count += maxcost2 + 1;\\n        }\\n    }\\n\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279517,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\nLeetCode Hints : \\n- Fix the number of pencils purchased and calculate the number of ways to buy pens.\\n- Sum up the number of ways to buy pens for each amount of pencils purchased to get the answer.\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long long pens=total/cost1;\\n        long long ans=0;\\n        for(int x=0; x<=pens; x++)\\n        {\\n            ans+=(total-cost1*x)/cost2+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) \\n    {\\n        long long pens=total/cost1;\\n        long long ans=0;\\n        for(int x=0; x<=pens; x++)\\n        {\\n            ans+=(total-cost1*x)/cost2+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263303,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn ways_to_buy_pens_pencils(total: i32, cost1: i32, cost2: i32) -> i64 {\\n        let mut ans = 0;\\n        for i in 0..=total / cost1 {\\n            ans += ((total - (cost1 * i)) / cost2 + 1) as i64;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ways_to_buy_pens_pencils(total: i32, cost1: i32, cost2: i32) -> i64 {\\n        let mut ans = 0;\\n        for i in 0..=total / cost1 {\\n            ans += ((total - (cost1 * i)) / cost2 + 1) as i64;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3211448,
                "title": "python-easy-solution-1-loop",
                "content": "# Intuition\\n* if total < cost1, total < cost2 -> 1 way (0 pen, 0 pencil)\\n* larger, smaller = max(cost1, cost2), min(cost1, cost2)\\n* for num from 0 to (total//larger+1): ways = (total - num*larger)//smaller + 1\\n\\n** 25, 10, 5 -> 25//10 + 1 = 3\\n0, 25, 25//5 (0, 1, 2, 3, 4, 5) -> 6 ways to buy pencils  \\n1, 25-10=15, 15//5 (0, 1, 2, 3)-> 4 ways\\n2, 25-20=5, 5/5 (0, 1) -> 2 ways \\n6 + 4 + 2 = 12 ways \\n\\n** 20, 10, 5 -> 20//10 + 1 = 2\\n0, (20)//5 + 1 = 5 ways  \\n1, (20-10)//5 + 1 = 3 ways\\n2, (20-20)//5 + 1 = 1 ways\\n\\n# Time and space complexity\\ntime: O(total/max(cost1, cost2))\\nspace: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n\\n        if total < cost1 and total < cost2: \\n            return 1\\n\\n        larger, smaller = max(cost1, cost2), min(cost1, cost2)\\n        ways = 0\\n        for num in range(total//larger+1):\\n            ways += (total - num*larger)//smaller + 1\\n\\n        return ways\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n\\n        if total < cost1 and total < cost2: \\n            return 1\\n\\n        larger, smaller = max(cost1, cost2), min(cost1, cost2)\\n        ways = 0\\n        for num in range(total//larger+1):\\n            ways += (total - num*larger)//smaller + 1\\n\\n        return ways\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201980,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: ```O(N)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(cost1 > total && cost2 > total) return 1;\\n        if(cost1 < cost2) swap(cost1 , cost2);\\n        long long x = 0, res = 0;\\n        while(total > 0){\\n            total -= x;\\n            if(total >= 0)\\n                res += total/cost2 + 1;\\n            x = cost1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(N)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        if(cost1 > total && cost2 > total) return 1;\\n        if(cost1 < cost2) swap(cost1 , cost2);\\n        long long x = 0, res = 0;\\n        while(total > 0){\\n            total -= x;\\n            if(total >= 0)\\n                res += total/cost2 + 1;\\n            x = cost1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1755107,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "Is this a medium-level problem?"
                    },
                    {
                        "username": "surenenfiajyan",
                        "content": "Sort of, for standard / official solutions. To figure out more advanced solutions it\\'s pretty hard and often involves more advanced math. But this can be said for many leetcode problems."
                    },
                    {
                        "username": "LunarFang_416",
                        "content": "[@supsep](/supsep) Yes."
                    },
                    {
                        "username": "supsep",
                        "content": "Yes."
                    },
                    {
                        "username": "Tejesh_Avadanam",
                        "content": "Why is this problem even in the medium section? I was thinking the solution of a medium problem couldn\\'t be this easy. I solved it, but the difficulty level sometimes can be really misleading. I was really starting to think on the lines of dp but before actually coming up with a dp approach, I just gave the basic approach a trail and it worked. This should be moved into an easy problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "This is a basic level medium question !"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Is this possible to solve without knowing that math equation ?!"
                    }
                ]
            },
            {
                "id": 2004702,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "Is this a medium-level problem?"
                    },
                    {
                        "username": "surenenfiajyan",
                        "content": "Sort of, for standard / official solutions. To figure out more advanced solutions it\\'s pretty hard and often involves more advanced math. But this can be said for many leetcode problems."
                    },
                    {
                        "username": "LunarFang_416",
                        "content": "[@supsep](/supsep) Yes."
                    },
                    {
                        "username": "supsep",
                        "content": "Yes."
                    },
                    {
                        "username": "Tejesh_Avadanam",
                        "content": "Why is this problem even in the medium section? I was thinking the solution of a medium problem couldn\\'t be this easy. I solved it, but the difficulty level sometimes can be really misleading. I was really starting to think on the lines of dp but before actually coming up with a dp approach, I just gave the basic approach a trail and it worked. This should be moved into an easy problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "This is a basic level medium question !"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Is this possible to solve without knowing that math equation ?!"
                    }
                ]
            },
            {
                "id": 1966997,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "Is this a medium-level problem?"
                    },
                    {
                        "username": "surenenfiajyan",
                        "content": "Sort of, for standard / official solutions. To figure out more advanced solutions it\\'s pretty hard and often involves more advanced math. But this can be said for many leetcode problems."
                    },
                    {
                        "username": "LunarFang_416",
                        "content": "[@supsep](/supsep) Yes."
                    },
                    {
                        "username": "supsep",
                        "content": "Yes."
                    },
                    {
                        "username": "Tejesh_Avadanam",
                        "content": "Why is this problem even in the medium section? I was thinking the solution of a medium problem couldn\\'t be this easy. I solved it, but the difficulty level sometimes can be really misleading. I was really starting to think on the lines of dp but before actually coming up with a dp approach, I just gave the basic approach a trail and it worked. This should be moved into an easy problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "This is a basic level medium question !"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Is this possible to solve without knowing that math equation ?!"
                    }
                ]
            },
            {
                "id": 1889025,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "Is this a medium-level problem?"
                    },
                    {
                        "username": "surenenfiajyan",
                        "content": "Sort of, for standard / official solutions. To figure out more advanced solutions it\\'s pretty hard and often involves more advanced math. But this can be said for many leetcode problems."
                    },
                    {
                        "username": "LunarFang_416",
                        "content": "[@supsep](/supsep) Yes."
                    },
                    {
                        "username": "supsep",
                        "content": "Yes."
                    },
                    {
                        "username": "Tejesh_Avadanam",
                        "content": "Why is this problem even in the medium section? I was thinking the solution of a medium problem couldn\\'t be this easy. I solved it, but the difficulty level sometimes can be really misleading. I was really starting to think on the lines of dp but before actually coming up with a dp approach, I just gave the basic approach a trail and it worked. This should be moved into an easy problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "This is a basic level medium question !"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Is this possible to solve without knowing that math equation ?!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Consecutive Cards to Pick Up",
        "question_content": "<p>You are given an integer array <code>cards</code> where <code>cards[i]</code> represents the <strong>value</strong> of the <code>i<sup>th</sup></code> card. A pair of cards are <strong>matching</strong> if the cards have the <strong>same</strong> value.</p>\n\n<p>Return<em> the <strong>minimum</strong> number of <strong>consecutive</strong> cards you have to pick up to have a pair of <strong>matching</strong> cards among the picked cards.</em> If it is impossible to have matching cards, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> cards = [3,4,2,3,4,7]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> cards = [1,0,5,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is no way to pick up a set of consecutive cards that contain a pair of matching cards.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cards.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= cards[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1996243,
                "title": "track-last",
                "content": "We need to find the minimum distance between any two matching cards.\\n\\nFor that, we can strore the `last` position of a card. If we find the matching card, we use the `last` position to find out the distance.\\n\\n**C++**\\nSince the `last` array is initialized with zeros, we need to do `i + 1`.\\n\\n```cpp\\nint minimumCardPickup(vector<int>& cards) {\\n    int last[1000001] = {}, res = INT_MAX;\\n    for (int i = 0; i < cards.size(); ++i) {\\n        if (last[cards[i]])\\n            res = min(res, i - last[cards[i]] + 2);\\n        last[cards[i]] = i + 1;\\n    }\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimumCardPickup(vector<int>& cards) {\\n    int last[1000001] = {}, res = INT_MAX;\\n    for (int i = 0; i < cards.size(); ++i) {\\n        if (last[cards[i]])\\n            res = min(res, i - last[cards[i]] + 2);\\n        last[cards[i]] = i + 1;\\n    }\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996208,
                "title": "java-hashmap",
                "content": "1. Maintain the previous index of each card.\\n2. Minimize difference between current index and previous (if present) among all pairs\\n3. Else return -1 if no duplicate\\n```\\nclass Solution\\n{\\n    public int minimumCardPickup(int[] cards)\\n    {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < cards.length; i++)\\n        {\\n            if(map.containsKey(cards[i]))\\n                min = Math.min(i-map.get(cards[i])+1,min); // Check if the difference in indices is smaller than minimum\\n            map.put(cards[i],i); // Update the last found index of the card\\n        }\\n        return min == Integer.MAX_VALUE?-1:min; // Repetition found or not\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int minimumCardPickup(int[] cards)\\n    {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < cards.length; i++)\\n        {\\n            if(map.containsKey(cards[i]))\\n                min = Math.min(i-map.get(cards[i])+1,min); // Check if the difference in indices is smaller than minimum\\n            map.put(cards[i],i); // Update the last found index of the card\\n        }\\n        return min == Integer.MAX_VALUE?-1:min; // Repetition found or not\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996232,
                "title": "using-map-c",
                "content": "We will store the previous occurence of an element in a map and we continue to traverese the array. If element is already present we take its index and find the current length. We update the  _\"ans\"_  if current length is less than  _\"ans\"_ .\\n\\nIf all the elements are unique then \"ans\" won\\'t get updated we can return \"-1\"\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& v) {\\n        int n = v.size();\\n        int ans = INT_MAX;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            if(m.find(v[i])!=m.end()){\\n                ans = min(ans,i-m[v[i]]+1);\\n            }\\n            m[v[i]] = i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& v) {\\n        int n = v.size();\\n        int ans = INT_MAX;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            if(m.find(v[i])!=m.end()){\\n                ans = min(ans,i-m[v[i]]+1);\\n            }\\n            m[v[i]] = i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996393,
                "title": "python3-beginner-friendly-explained",
                "content": "**Thought Process:**\\n\\nSo we want to find the minimum difference between current character\\'s position and previously seen position. And only keep the minimum!\\n\\n1.\\tKeep the index of visiting number (We will always update the index to latest since we are looking for minimum length)\\n2.\\tIf your current number is seen before, then calculate the length from previously seen index, and update if its difference is smaller than what we have seen so far\\n3.\\tAt the end of iteration, if we didn\\u2019t find any duplicate, return -1; otherwise, return the minimum distance you found\\n\\n**Complexity**\\nTime \\u2013 O(N) as we iterate over the input only once\\nSpace \\u2013 O(N) at worst case we will be storing all the numbers in the input to our index hashmap. (in case of all distinct numbers in input array)\\n\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        minPick = float(\\'inf\\')\\n        seen = {}\\n        for i, n in enumerate(cards):\\n            if n in seen:\\n                if i - seen[n] + 1 < minPick:\\n                    minPick = i - seen[n] + 1\\n            seen[n] = i\\n        if minPick == float(\\'inf\\'):\\n            return -1\\n        return minPick\\n```\\n\\n**Please correct me if I am wrong !\\nPlease UPVOTE if you find this solution helpful !\\nHappy algo!**\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        minPick = float(\\'inf\\')\\n        seen = {}\\n        for i, n in enumerate(cards):\\n            if n in seen:\\n                if i - seen[n] + 1 < minPick:\\n                    minPick = i - seen[n] + 1\\n            seen[n] = i\\n        if minPick == float(\\'inf\\'):\\n            return -1\\n        return minPick\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996993,
                "title": "c-using-map-linear-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        int n = cards.size();\\n        bool found = false;\\n        unordered_map<int, int> dp;\\n        \\n        dp[cards[0]] = 0;\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            \\n            if(dp.find(cards[i]) != dp.end()){\\n                \\n                ans = min(ans, i - dp[cards[i]] + 1);\\n                found = true;\\n                \\n            }\\n            \\n            dp[cards[i]] = i;\\n            \\n        }\\n        \\n        if(!found) ans = -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        int n = cards.size();\\n        bool found = false;\\n        unordered_map<int, int> dp;\\n        \\n        dp[cards[0]] = 0;\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            \\n            if(dp.find(cards[i]) != dp.end()){\\n                \\n                ans = min(ans, i - dp[cards[i]] + 1);\\n                found = true;\\n                \\n            }\\n            \\n            dp[cards[i]] = i;\\n            \\n        }\\n        \\n        if(!found) ans = -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996314,
                "title": "hashing",
                "content": "**Store the index of last occurence of a card in a map.**\\n**For every card check if it is stored in the map.**\\n**If yes :**\\n\\tthen find the number of cards to be removed and then update the index of last occurence as current index.\\n**else :**\\n\\tstore the card with its index.\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        int res (INT_MAX), n(size(cards));\\n        unordered_map<int, int> m;\\n        for (auto i=0; i<n; i++) {\\n            // number of consecutive cards you have to pick up to have a pair of matching cards == (Diference between 2 indexes of same card) + 1\\n            if (m.count(cards[i]))  res = min(res, i-m[cards[i]]+1);\\n            m[cards[i]] = i;\\n        }\\n        return (res == INT_MAX) ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        int res (INT_MAX), n(size(cards));\\n        unordered_map<int, int> m;\\n        for (auto i=0; i<n; i++) {\\n            // number of consecutive cards you have to pick up to have a pair of matching cards == (Diference between 2 indexes of same card) + 1\\n            if (m.count(cards[i]))  res = min(res, i-m[cards[i]]+1);\\n            m[cards[i]] = i;\\n        }\\n        return (res == INT_MAX) ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693527,
                "title": "c-hashing-faster-approach-o-n-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>&s) {\\n\\n       int maxi = INT_MAX;\\n       unordered_map<int,int>mpp;\\n       int n = s.size();\\n\\n       for(int i = 0; i < n; ++i)\\n       {   \\n\\n           if(mpp.find(s[i]) != mpp.end())  maxi = min(maxi, i-mpp[s[i]]+1);\\n\\n             mpp[s[i]] = i;\\n       }\\n\\n      if(maxi == INT_MAX) return -1;\\n\\n      return maxi;\\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>&s) {\\n\\n       int maxi = INT_MAX;\\n       unordered_map<int,int>mpp;\\n       int n = s.size();\\n\\n       for(int i = 0; i < n; ++i)\\n       {   \\n\\n           if(mpp.find(s[i]) != mpp.end())  maxi = min(maxi, i-mpp[s[i]]+1);\\n\\n             mpp[s[i]] = i;\\n       }\\n\\n      if(maxi == INT_MAX) return -1;\\n\\n      return maxi;\\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996658,
                "title": "c-easy-solution-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int, vector<int>> m;\\n        for(int i = 0; i < cards.size(); i++)\\n        {\\n            m[cards[i]].push_back(i);\\n        }\\n        int mn = INT_MAX;\\n        for(auto i : m)\\n        {\\n            auto v = i.second;\\n            if(v.size() > 1)\\n            {\\n                for(int i = 1; i < v.size(); i++)\\n                {\\n                    mn = min(mn, v[i] - v[i - 1] + 1);\\n                }\\n            }\\n        }\\n        return mn == INT_MAX ? -1 : mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int, vector<int>> m;\\n        for(int i = 0; i < cards.size(); i++)\\n        {\\n            m[cards[i]].push_back(i);\\n        }\\n        int mn = INT_MAX;\\n        for(auto i : m)\\n        {\\n            auto v = i.second;\\n            if(v.size() > 1)\\n            {\\n                for(int i = 1; i < v.size(); i++)\\n                {\\n                    mn = min(mn, v[i] - v[i - 1] + 1);\\n                }\\n            }\\n        }\\n        return mn == INT_MAX ? -1 : mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996320,
                "title": "python-o-n-time-space-by-using-dict",
                "content": "```\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        ans = math.inf\\n        n = len(cards)\\n        pos = defaultdict(lambda: -1)\\n        for i in range(n):\\n            if pos[cards[i]] != -1:\\n                ans = min(i - pos[cards[i]] + 1, ans)\\n            pos[cards[i]] = i\\n        return ans if ans != math.inf else -1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        ans = math.inf\\n        n = len(cards)\\n        pos = defaultdict(lambda: -1)\\n        for i in range(n):\\n            if pos[cards[i]] != -1:\\n                ans = min(i - pos[cards[i]] + 1, ans)\\n            pos[cards[i]] = i\\n        return ans if ans != math.inf else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1996246,
                "title": "python-sliding-window-exactly-same-as-3-longest-substring-without-repeating-characters",
                "content": "This is exactly same as https://leetcode.com/problems/longest-substring-without-repeating-characters/ but in opposite. Instead of longest we are looking for smallest. And only when the window becomes invalid.\\n\\n```\\ndef minimumCardPickup(self, cards: List[int]) -> int:\\n    seen = {}\\n    s = cards\\n    smallest_card_len = sys.maxsize\\n    start, end = 0, 0\\n\\n    if len(s) == 0:\\n        return 0\\n\\n    while end < len(s):\\n        c = s[end]\\n\\n        if c in seen:\\n            # invalid window\\n            # update start\\n            start = seen[c] + 1\\n            smallest_card_len = min(smallest_card_len, end - start + 1)\\n\\n        seen[c] = end\\n\\n        end += 1\\n\\n    if smallest_card_len == sys.maxsize:\\n        return -1\\n\\n    return smallest_card_len + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimumCardPickup(self, cards: List[int]) -> int:\\n    seen = {}\\n    s = cards\\n    smallest_card_len = sys.maxsize\\n    start, end = 0, 0\\n\\n    if len(s) == 0:\\n        return 0\\n\\n    while end < len(s):\\n        c = s[end]\\n\\n        if c in seen:\\n            # invalid window\\n            # update start\\n            start = seen[c] + 1\\n            smallest_card_len = min(smallest_card_len, end - start + 1)\\n\\n        seen[c] = end\\n\\n        end += 1\\n\\n    if smallest_card_len == sys.maxsize:\\n        return -1\\n\\n    return smallest_card_len + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3753552,
                "title": "easy-java-solution-hashmap-o-nlogn",
                "content": "# Intuition\\nWe have to find repetition of element in array and the smallest length to for that repetition. First thought is to het the previous index of that repeted element.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHashMap to get previous index. Then maintaing a variable to get minimum length.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Finding repetition in array using hashmap\\n//if a repetition is found then we calculate the length or \\n//number of cards we hab to pick to get that repetition\\n//Maintain another variable to store min length\\n//VOILAAAAA...\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i=0; i<cards.length; i++){\\n\\n            if(map.containsKey(cards[i])){\\n            int idx = map.get(cards[i]);\\n                int res = i - idx + 1;\\n                ans = Math.min(ans, res);\\n            }\\n\\n            map.put(cards[i], i);\\n        }\\n        return ans==Integer.MAX_VALUE ?-1 :ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\n//Finding repetition in array using hashmap\\n//if a repetition is found then we calculate the length or \\n//number of cards we hab to pick to get that repetition\\n//Maintain another variable to store min length\\n//VOILAAAAA...\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i=0; i<cards.length; i++){\\n\\n            if(map.containsKey(cards[i])){\\n            int idx = map.get(cards[i]);\\n                int res = i - idx + 1;\\n                ans = Math.min(ans, res);\\n            }\\n\\n            map.put(cards[i], i);\\n        }\\n        return ans==Integer.MAX_VALUE ?-1 :ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962686,
                "title": "easy-o-n-time-solution-with-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeeping track of last position of particular card. And finding difference between its last occurred index and current index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the current value is present in hash map then finding minimum of the difference between its last occurred index and the current index.\\n(Min because to find minimum no. of cards to be picked)\\n\\n2. Updating the index of the current value in map\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map <int, int> hash;\\n        int res = INT_MAX, flag=0;\\n\\n        for(int i= 0; i<cards.size(); i++){\\n\\n            if(hash.count(cards[i])){\\n                res = min(res, i-hash[cards[i]]+1 );\\n                flag =1;\\n            }\\n            hash[cards[i]] = i; \\n        }\\n\\n        return (flag ==0) ? -1 :res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map <int, int> hash;\\n        int res = INT_MAX, flag=0;\\n\\n        for(int i= 0; i<cards.size(); i++){\\n\\n            if(hash.count(cards[i])){\\n                res = min(res, i-hash[cards[i]]+1 );\\n                flag =1;\\n            }\\n            hash[cards[i]] = i; \\n        }\\n\\n        return (flag ==0) ? -1 :res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175165,
                "title": "go-sliding-window-o-n-hashmap",
                "content": "```\\nfunc minimumCardPickup(cards []int) int {\\n    if len(cards) == 0 || len(cards) == 1 {return -1}\\n    \\n    res := 1 << 63 - 1\\n    \\n    m := make(map[int]int)\\n    m[cards[0]]++\\n    l := 0\\n    \\n    for i := 1; i < len(cards); i++ {\\n        m[cards[i]]++\\n        \\n        checking := false\\n        \\n        for m[cards[i]] > 1 {\\n            checking = true\\n            m[cards[l]]--\\n            \\n            if m[cards[l]] == 0 {\\n                delete(m, cards[l])\\n            }\\n            \\n            l++\\n        }\\n        \\n        if checking {\\n            if i - l + 2 < res {\\n                res = i - l + 2\\n            }\\n        }\\n    }\\n    \\n    if res != 1 << 63 - 1 {\\n        return res\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumCardPickup(cards []int) int {\\n    if len(cards) == 0 || len(cards) == 1 {return -1}\\n    \\n    res := 1 << 63 - 1\\n    \\n    m := make(map[int]int)\\n    m[cards[0]]++\\n    l := 0\\n    \\n    for i := 1; i < len(cards); i++ {\\n        m[cards[i]]++\\n        \\n        checking := false\\n        \\n        for m[cards[i]] > 1 {\\n            checking = true\\n            m[cards[l]]--\\n            \\n            if m[cards[l]] == 0 {\\n                delete(m, cards[l])\\n            }\\n            \\n            l++\\n        }\\n        \\n        if checking {\\n            if i - l + 2 < res {\\n                res = i - l + 2\\n            }\\n        }\\n    }\\n    \\n    if res != 1 << 63 - 1 {\\n        return res\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2004688,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int prev[1000001] = {0}, ans = INT_MAX;\\n        \\n        for (int i = 0; i < cards.size(); i++) {\\n            if (prev[cards[i]])\\n                ans = min(ans, (i + 1) - prev[cards[i]] + 1);\\n            prev[cards[i]] = i + 1;\\n        }\\n        \\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n};\\n\\n/*\\n    Approach: \\n    - storing all the indices in the vector\\n    - calculating the pair wise minimum\\n\\n    Improvement:\\n    - instead of keeping track of all the indices\\n    just keep track of previous value\\n\\n    CODE\\n    ====\\n        unordered_map<int, vector<int>> m;\\n        for (int i = 0; i < cards.size(); i++) {\\n            m[cards[i]].push_back(i + 1);\\n        }\\n\\n        int ans = INT_MAX;\\n        for (auto x : m) {\\n            if (x.second.size() > 1) {\\n                vector<int> a = x.second;\\n                for (int i = 1; i < a.size(); i++) {\\n                    ans = min(ans, a[i] - a[i - 1] + 1);\\n                }\\n            }\\n        }\\n\\n        return (ans == INT_MAX ? -1 : ans);\\n        }\\n*/",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int prev[1000001] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 3400582,
                "title": "simple-and-easy-java-code-with-complete-walkthrough",
                "content": "# Intuition\\n* Since it was a medium problem, I thought it would be difficult but came up with a solution pretty quickly.\\n\\n# Approach\\n* We\\'ve used HashMap in our code to track the values that we\\'ve visited previously. Here\\'s the walkthrough.\\n    * First we initialize a HashMap with <Integer, Integer> datatype.\\n    * Then we set the value min to Integer.MAX_VALUE ( which is 2147483647 ) because intitializing min with -1 tends to stay minimum always when comparing with any size of desired output.\\n    * We traverse through the array only once and check if the Map contains the key value already.\\n    * If true, we calculate the difference between the two occurences and compare it with previous min value to evaluate the least one amongst them.\\n    * Else we simply add it to the map along with its index. We also add duplicate elements to the Map since the difference between similar elements may vary later.\\n    * We check whether the min value is still Integer.MAX_VALUE. If true, we simply return -1 which means no minimum consecutive elements with a single pair is found.\\n\\n# Complexity\\n- Time complexity:\\n    * The time complexity of for loop is O(n). But for HashMap it is O(1). So the total time complexity is O(n).\\n\\n- Space complexity:\\n    * The space complexity is O(n). \\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer, Integer> hm=new HashMap<Integer,Integer>();\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<cards.length;i++)\\n        {\\n            if(hm.containsKey(cards[i]))\\n            {\\n                min=Math.min(min,(i+1)-hm.get(cards[i]));\\n            }\\n            hm.put(cards[i],i);\\n        }\\n        if(min==Integer.MAX_VALUE)\\n            min=-1;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer, Integer> hm=new HashMap<Integer,Integer>();\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<cards.length;i++)\\n        {\\n            if(hm.containsKey(cards[i]))\\n            {\\n                min=Math.min(min,(i+1)-hm.get(cards[i]));\\n            }\\n            hm.put(cards[i],i);\\n        }\\n        if(min==Integer.MAX_VALUE)\\n            min=-1;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222360,
                "title": "99-beats-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int i = 0, j = 0, n = cards.size(),ans = INT_MAX;\\n        vector<int> v(1e6+1);\\n        while(i<n){\\n            v[cards[i]]++;\\n            if(v[cards[i]]==2){\\n                while(v[cards[i]]==2){\\n                    v[cards[j++]]--;\\n                }\\n                // cout<<i<<\" \"<<j<<endl;\\n                ans = min(ans,i-j+2);\\n            }\\n            i++;\\n        }\\n        // cout<<endl;\\n        return (ans==INT_MAX?-1:ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int i = 0, j = 0, n = cards.size(),ans = INT_MAX;\\n        vector<int> v(1e6+1);\\n        while(i<n){\\n            v[cards[i]]++;\\n            if(v[cards[i]]==2){\\n                while(v[cards[i]]==2){\\n                    v[cards[j++]]--;\\n                }\\n                // cout<<i<<\" \"<<j<<endl;\\n                ans = min(ans,i-j+2);\\n            }\\n            i++;\\n        }\\n        // cout<<endl;\\n        return (ans==INT_MAX?-1:ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3032092,
                "title": "easiest-solution-goldman-sachs-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**#ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ6. Minimum Consecutive Cards to pick up**\\n\\n**This code is solving the problem of finding a minimum distance between two same cards in an array, it does this by:**\\n\\nCreate a HashMap to store count and last index of each card\\nIterates through the array and update the count and last index of each card in the HashMap\\nIf the count of a card has increased from last iteration and last count was not zero, calculate the distance from last index, check it with the previous minimum distance and update if it\\'s less.\\nreturn the minimum distance between two same cards, if there\\'s no duplicate cards in the array return -1\\nThe time complexity is O(n) because we iterate through the input array once and for each card, we look up its count and last index in the HashMap which takes constant time, and we are only updating the HashMap once for each card, which also takes constant time.\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = cards.length;\\n        // Use a HashMap to store the count and last index of each card\\n        HashMap<Integer, Pair<Integer, Integer>> cardCount = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int lastCount = cardCount.getOrDefault(cards[i], new Pair<>(0, 0)).getKey();\\n            int lastIndex = cardCount.getOrDefault(cards[i], new Pair<>(0, 0)).getValue();\\n\\n            cardCount.put(cards[i], new Pair<>(lastCount + 1, i));\\n            \\n            if (lastCount + 1 > lastCount && lastCount != 0) {\\n                int current = i - lastIndex + 1;\\n                ans = Math.min(current, ans);\\n            }\\n        }\\n        // If no duplicate cards were found, return -1\\n        if (ans == Integer.MAX_VALUE) return -1;\\n        return ans;\\n    }\\n}\\n\\n```\\n**Alternate and Better Approach:**\\n\\nThe below code uses a TreeMap (which is a red-black tree based implementation of a map in java) to keep track of the last index of each card.\\nIt iterates through the input array and for each card, it checks if it has already seen that card before by looking it up in the TreeMap. If the card has already been seen, it calculates the distance between the current index and the last index of that card and update the minimum distance if the calculated distance is less than the previous minimum distance.\\nIt will return the minimum distance between any duplicate cards found in the array.\\nsolution that uses TreeMap to store the count and last index of each card and has an O(n*log n) time complexity on average.\\n\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = cards.length;\\n        // Use a TreeMap to store the count and last index of each card\\n        TreeMap<Integer, Pair<Integer, Integer>> cardCount = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int lastCount = cardCount.getOrDefault(cards[i], new Pair<>(0, 0)).getKey();\\n            int lastIndex = cardCount.getOrDefault(cards[i], new Pair<>(0, 0)).getValue();\\n\\n            cardCount.put(cards[i], new Pair<>(lastCount + 1, i));\\n            \\n            if (lastCount + 1 > lastCount && lastCount != 0) {\\n                int current = i - lastIndex + 1;\\n                ans = Math.min(current, ans);\\n            }\\n        }\\n        // If no duplicate cards were found, return -1\\n        if (ans == Integer.MAX_VALUE) return -1;\\n        return ans;\\n    }\\n}\\n\\n```\\nHere\\'s how the method works:\\n\\n- Initialize the variable \"ans\" to the maximum possible integer value and \"n\" to the length of the input array.\\n- Create a TreeMap called \"cardCount\" that will store the count and last index of each card.\\n- Iterate over the input array \"cards\" using a for-loop, for each element i in the array\\na. Get the last count and last index of the current card using the getOrDefault method of the TreeMap, providing the current card as the key and the default value as a new Pair<>(0,0).\\nb. Update the TreeMap with the current card as key and the new Pair<>(lastCount+1,i) as value\\nc. Check if the lastCount + 1 > lastCount and lastCount != 0, meaning if this is the second occurrence of this card and if this not the first occurrence of any card\\nd. If it is the second occurrence update the ans with min of current and ans , current = i - lastIndex + 1, meaning how many cards has been pick so far\\n- If no duplicate cards were found, return -1\\n- return ans\\n\\n![6.jpg](https://assets.leetcode.com/users/images/38d2efa2-7da0-4601-b674-e5d2b0c759bb_1673388885.5791228.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = cards.length;\\n        // Use a HashMap to store the count and last index of each card\\n        HashMap<Integer, Pair<Integer, Integer>> cardCount = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int lastCount = cardCount.getOrDefault(cards[i], new Pair<>(0, 0)).getKey();\\n            int lastIndex = cardCount.getOrDefault(cards[i], new Pair<>(0, 0)).getValue();\\n\\n            cardCount.put(cards[i], new Pair<>(lastCount + 1, i));\\n            \\n            if (lastCount + 1 > lastCount && lastCount != 0) {\\n                int current = i - lastIndex + 1;\\n                ans = Math.min(current, ans);\\n            }\\n        }\\n        // If no duplicate cards were found, return -1\\n        if (ans == Integer.MAX_VALUE) return -1;\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = cards.length;\\n        // Use a TreeMap to store the count and last index of each card\\n        TreeMap<Integer, Pair<Integer, Integer>> cardCount = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int lastCount = cardCount.getOrDefault(cards[i], new Pair<>(0, 0)).getKey();\\n            int lastIndex = cardCount.getOrDefault(cards[i], new Pair<>(0, 0)).getValue();\\n\\n            cardCount.put(cards[i], new Pair<>(lastCount + 1, i));\\n            \\n            if (lastCount + 1 > lastCount && lastCount != 0) {\\n                int current = i - lastIndex + 1;\\n                ans = Math.min(current, ans);\\n            }\\n        }\\n        // If no duplicate cards were found, return -1\\n        if (ans == Integer.MAX_VALUE) return -1;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572737,
                "title": "c-solution",
                "content": "```\\n    int minimumCardPickup(vector<int>& nums) {\\n        \\n      int i=0;\\n      int j=0;\\n      int result=INT_MAX;\\n      unordered_map<int,int>mp;\\n      int count=0;\\n      int k=1;\\n        \\n        // Variable window size problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            mp[nums[j]]++;\\n            if(mp[nums[j]]>1)\\n                count++;\\n            \\n            // Play with condition\\n             while(count>=1)\\n             {\\n                 // Store result\\n                 result=min(result,j-i+1);\\n                 \\n                 // Remove calculation for i\\n                 mp[nums[i]]--;\\n                 if(mp[nums[i]]==1)\\n                     count--;\\n                 i++;\\n             }\\n            j++;\\n        }\\n        return result==INT_MAX?-1:result;\\n    }\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(n)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& nums) {\\n        int result=INT_MAX; \\n        unordered_map<int,pair<int,int>>mp;\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         if(mp[nums[i]].second>=1)\\n             result=min(result,i-mp[nums[i]].first+1);\\n             \\n         mp[nums[i]].first=i;\\n        mp[nums[i]].second++;\\n         \\n     }\\n        return result==INT_MAX?-1:result;\\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    int minimumCardPickup(vector<int>& nums) {\\n        \\n      int i=0;\\n      int j=0;\\n      int result=INT_MAX;\\n      unordered_map<int,int>mp;\\n      int count=0;\\n      int k=1;\\n        \\n        // Variable window size problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            mp[nums[j]]++;\\n            if(mp[nums[j]]>1)\\n                count++;\\n            \\n            // Play with condition\\n             while(count>=1)\\n             {\\n                 // Store result\\n                 result=min(result,j-i+1);\\n                 \\n                 // Remove calculation for i\\n                 mp[nums[i]]--;\\n                 if(mp[nums[i]]==1)\\n                     count--;\\n                 i++;\\n             }\\n            j++;\\n        }\\n        return result==INT_MAX?-1:result;\\n    }\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& nums) {\\n        int result=INT_MAX; \\n        unordered_map<int,pair<int,int>>mp;\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         if(mp[nums[i]].second>=1)\\n             result=min(result,i-mp[nums[i]].first+1);\\n             \\n         mp[nums[i]].first=i;\\n        mp[nums[i]].second++;\\n         \\n     }\\n        return result==INT_MAX?-1:result;\\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114624,
                "title": "python-solution",
                "content": "# class Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d = {}\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(len(cards)):\\n            if cards[i] not in d:\\n                d[cards[i]] = i\\n            else:\\n                ans = min(ans, i - d[cards[i]])\\n                d[cards[i]] = i\\n            \\n        return -1 if ans == float(\\'inf\\') else ans + 1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1996986,
                "title": "java-accepted-using-hashmap",
                "content": "```\\nclass Solution {\\n    public static int minimumCardPickup(int[] arr) {\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif (map.containsKey(arr[i])) {\\n\\t\\t\\t\\tmin = Math.min(min, i - map.get(arr[i]));\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(arr[i], i);\\n\\t\\t}\\n\\t\\tif (min == Integer.MAX_VALUE) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn min + 1;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minimumCardPickup(int[] arr) {\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif (map.containsKey(arr[i])) {\\n\\t\\t\\t\\tmin = Math.min(min, i - map.get(arr[i]));\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(arr[i], i);\\n\\t\\t}\\n\\t\\tif (min == Integer.MAX_VALUE) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn min + 1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839954,
                "title": "python-3-using-dictionary-beats-99-694ms",
                "content": "```python3 []\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        res, pos = 10**6+1, {}\\n        for i, c in enumerate(cards):\\n            if c in pos:\\n                res = min(res, i - pos[c] + 1)\\n            pos[c] = i\\n        \\n        return res % (10**6+1) or -1\\n```\\n![Screenshot 2023-07-30 at 22.00.53.png](https://assets.leetcode.com/users/images/459cc81a-b884-4c14-bcc9-f584243c8def_1690743731.1236794.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        res, pos = 10**6+1, {}\\n        for i, c in enumerate(cards):\\n            if c in pos:\\n                res = min(res, i - pos[c] + 1)\\n            pos[c] = i\\n        \\n        return res % (10**6+1) or -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171401,
                "title": "c-easy-solution-beats-82-solution",
                "content": "# Approach\\nMap the first occurence each element with its index. And as soon as  you encounter its second occurence, update the ans variable to the minimum length and update the last occured index for the next occurence. This approach also covers the case where no element is repeated so that ans variable never gets updated. \\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Please Upvote the solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int> ma;\\n        int ans = INT_MAX;\\n        for(int i=0;i<cards.size();i++){\\n            if(ma.find(cards[i])!=ma.end()){\\n                ans = min(ans,i-ma[cards[i]]+1);\\n            }\\n            ma[cards[i]]=i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int> ma;\\n        int ans = INT_MAX;\\n        for(int i=0;i<cards.size();i++){\\n            if(ma.find(cards[i])!=ma.end()){\\n                ans = min(ans,i-ma[cards[i]]+1);\\n            }\\n            ma[cards[i]]=i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090639,
                "title": "hashing-and-then-using-the-indexes-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly store the indexes the elements repeated and donnot forget to update the indexes...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nlinear traversal\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        uni=set(cards)\\n        if(len(uni)==len(cards)):\\n            return -1\\n        d={}\\n        mini=len(cards)\\n        for i in range(0,len(cards)):\\n            if cards[i] in d:\\n                mini=min(mini,i-d[cards[i]]+1)\\n                d[cards[i]]=i\\n            else:\\n                d[cards[i]]=i\\n        return mini\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        uni=set(cards)\\n        if(len(uni)==len(cards)):\\n            return -1\\n        d={}\\n        mini=len(cards)\\n        for i in range(0,len(cards)):\\n            if cards[i] in d:\\n                mini=min(mini,i-d[cards[i]]+1)\\n                d[cards[i]]=i\\n            else:\\n                d[cards[i]]=i\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061202,
                "title": "js-hashmap-easy-clean-142-ms-94-69-mb-96",
                "content": "# Intuition\\nUse the hash map to store the last met card\\'s index by card, when you meet the repetitive card recalculate the answer and move forward.\\n\\n# Approach\\nHash map\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} cards\\n * @return {number}\\n */\\nvar minimumCardPickup = function(cards) {\\n    let dic = new Map();\\n    let ans = Infinity;\\n\\n    for (let i = 0; i < cards.length; i++) {\\n        if (dic.has(cards[i])) {\\n            ans = Math.min(ans, i - dic.get(cards[i]) + 1);\\n        }\\n        \\n        dic.set(cards[i], i);\\n    }\\n\\n    return ans == Infinity ? -1 : ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} cards\\n * @return {number}\\n */\\nvar minimumCardPickup = function(cards) {\\n    let dic = new Map();\\n    let ans = Infinity;\\n\\n    for (let i = 0; i < cards.length; i++) {\\n        if (dic.has(cards[i])) {\\n            ans = Math.min(ans, i - dic.get(cards[i]) + 1);\\n        }\\n        \\n        dic.set(cards[i], i);\\n    }\\n\\n    return ans == Infinity ? -1 : ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3033603,
                "title": "simple-c-solution-o-n-solution-using-hashmaps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        //Here the idea is to create a map with cards[i] and opisition i if we found such elemnt for which cards[i] is alreday present in map so find the min length as res\\n        unordered_map<int,int>m;\\n        int res=INT_MAX;\\n        for(int i=0;i<cards.size();i++){\\n            if(m.find(cards[i])!=m.end()){\\n                res=min(res,i-m[cards[i]]+1);\\n            }\\n            m[cards[i]]=i;            \\n        }\\n\\n        if(res!=INT_MAX){\\n            return res;\\n        }else\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        //Here the idea is to create a map with cards[i] and opisition i if we found such elemnt for which cards[i] is alreday present in map so find the min length as res\\n        unordered_map<int,int>m;\\n        int res=INT_MAX;\\n        for(int i=0;i<cards.size();i++){\\n            if(m.find(cards[i])!=m.end()){\\n                res=min(res,i-m[cards[i]]+1);\\n            }\\n            m[cards[i]]=i;            \\n        }\\n\\n        if(res!=INT_MAX){\\n            return res;\\n        }else\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025234,
                "title": "java-hashset-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n\\n    HashSet<Integer> set = new HashSet<>();  \\n    int ans = Integer.MAX_VALUE;\\n    int j = 0;\\n\\n    for(int card : cards){\\n        if(!set.contains(card)){\\n            set.add(card);\\n        }else{ \\n            while(set.contains(card)){\\n               ans = Math.min(set.size() + 1, ans);\\n               set.remove(cards[j++]);\\n            }\\n              set.add(card);  \\n        }\\n    }\\n    return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n}\\n```\\n### pls upVote if you like it @u@",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n\\n    HashSet<Integer> set = new HashSet<>();  \\n    int ans = Integer.MAX_VALUE;\\n    int j = 0;\\n\\n    for(int card : cards){\\n        if(!set.contains(card)){\\n            set.add(card);\\n        }else{ \\n            while(set.contains(card)){\\n               ans = Math.min(set.size() + 1, ans);\\n               set.remove(cards[j++]);\\n            }\\n              set.add(card);  \\n        }\\n    }\\n    return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012666,
                "title": "easy-simple-c-solution-unordered-map",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int ans= INT_MAX;\\n        unordered_map<int,int> mp;\\n        for (int i=0; i<cards.size(); i++){\\n            if (mp.find(cards[i]) != mp.end()){\\n                ans= min(ans,i-mp[cards[i]]+1);\\n            }\\n            mp[cards[i]]= i;\\n        }\\n        if (ans==INT_MAX)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int ans= INT_MAX;\\n        unordered_map<int,int> mp;\\n        for (int i=0; i<cards.size(); i++){\\n            if (mp.find(cards[i]) != mp.end()){\\n                ans= min(ans,i-mp[cards[i]]+1);\\n            }\\n            mp[cards[i]]= i;\\n        }\\n        if (ans==INT_MAX)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012036,
                "title": "c-maps-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        map<int, vector<int>>m;\\n        int ans=1e9;\\n        for(int i=0; i<cards.size(); i++){\\n            m[cards[i]].push_back(i);\\n        }\\n        for(auto it: m){\\n            //cout<<it.first<<\" \"<<it.second.size()<<endl;\\n            // for(auto it1: it.second){\\n            //     cout<<it1<<\" \";\\n            // }\\n            //cout<<\"h\"<<endl;\\n            if(it.second.size()>1){\\n                int cnt=1e9;\\n                for(int j=0; j<it.second.size()-1; j++){\\n                    cnt=min(cnt, it.second[j+1]-it.second[j]+1);\\n                }\\n                ans=min(ans, cnt);\\n                //cout<<ans<<\" \"<<cnt<<endl;\\n            }\\n        }\\n        if(ans==1e9){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        map<int, vector<int>>m;\\n        int ans=1e9;\\n        for(int i=0; i<cards.size(); i++){\\n            m[cards[i]].push_back(i);\\n        }\\n        for(auto it: m){\\n            //cout<<it.first<<\" \"<<it.second.size()<<endl;\\n            // for(auto it1: it.second){\\n            //     cout<<it1<<\" \";\\n            // }\\n            //cout<<\"h\"<<endl;\\n            if(it.second.size()>1){\\n                int cnt=1e9;\\n                for(int j=0; j<it.second.size()-1; j++){\\n                    cnt=min(cnt, it.second[j+1]-it.second[j]+1);\\n                }\\n                ans=min(ans, cnt);\\n                //cout<<ans<<\" \"<<cnt<<endl;\\n            }\\n        }\\n        if(ans==1e9){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3008234,
                "title": "c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& arr) {\\n        int ans= INT_MAX;\\n        \\n        // for storing latest index of any num\\n        unordered_map<int,int> map;\\n        \\n        \\n        for(int i=0;i<arr.size();i++){\\n            //if num already came then length of subarray can be calculated\\n            if(map.count(arr[i])) ans= min(ans,i-map[arr[i]]+1);\\n            // storing new index and if already present in map then replacing with new index\\n            map[arr[i]]=i;\\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& arr) {\\n        int ans= INT_MAX;\\n        \\n        // for storing latest index of any num\\n        unordered_map<int,int> map;\\n        \\n        \\n        for(int i=0;i<arr.size();i++){\\n            //if num already came then length of subarray can be calculated\\n            if(map.count(arr[i])) ans= min(ans,i-map[arr[i]]+1);\\n            // storing new index and if already present in map then replacing with new index\\n            map[arr[i]]=i;\\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822388,
                "title": "ts-222ms-hashmap-easy-to-understand",
                "content": "```\\nconst minimumCardPickup = (cards: number[]): number => {\\n    const dic = new Map<number, number>();\\n    let ans = Infinity;\\n    for (let i = 0; i < cards.length; i++) {\\n        if (dic.has(cards[i])) {\\n            ans = Math.min(ans, i - dic.get(cards[i]) + 1);\\n        }\\n        \\n        dic.set(cards[i], i);\\n    }\\n    \\n    return ans === Infinity ? -1 : ans;\\n};\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst minimumCardPickup = (cards: number[]): number => {\\n    const dic = new Map<number, number>();\\n    let ans = Infinity;\\n    for (let i = 0; i < cards.length; i++) {\\n        if (dic.has(cards[i])) {\\n            ans = Math.min(ans, i - dic.get(cards[i]) + 1);\\n        }\\n        \\n        dic.set(cards[i], i);\\n    }\\n    \\n    return ans === Infinity ? -1 : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2729646,
                "title": "python3-hashmaps",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        HashMap={}\\n        lengths=[]\\n        for i,j in enumerate(cards):\\n            if j in HashMap:\\n                lengths.append(abs(HashMap[j]-i)+1)\\n                HashMap[j]=i\\n            else:\\n                HashMap[j]=i\\n        if len(lengths)>0:\\n            return min(lengths)\\n        else:\\n            return -1``\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        HashMap={}\\n        lengths=[]\\n        for i,j in enumerate(cards):\\n            if j in HashMap:\\n                lengths.append(abs(HashMap[j]-i)+1)\\n                HashMap[j]=i\\n            else:\\n                HashMap[j]=i\\n        if len(lengths)>0:\\n            return min(lengths)\\n        else:\\n            return -1``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711371,
                "title": "simple-python-solution-complexity-better-than-99-5",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        start=0\\n        minimum=10**5+1\\n        dicts={}\\n        for i in range(len(cards)):\\n            if cards[i] in dicts and start<=dicts[cards[i]]:\\n                minimum=min(minimum,i-dicts[cards[i]]+1)\\n                start=dicts[cards[i]]+1\\n            dicts[cards[i]]=i\\n        if minimum==10**5+1:\\n            return -1\\n        else:\\n            return minimum\\n                \\n                \\n\\n        \\n            \\n        ```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        start=0\\n        minimum=10**5+1\\n        dicts={}\\n        for i in range(len(cards)):\\n            if cards[i] in dicts and start<=dicts[cards[i]]:\\n                minimum=min(minimum,i-dicts[cards[i]]+1)\\n                start=dicts[cards[i]]+1\\n            dicts[cards[i]]=i\\n        if minimum==10**5+1:\\n            return -1\\n        else:\\n            return minimum\\n                \\n                \\n\\n        \\n            \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2634070,
                "title": "java-solution-easy",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int[] lastIdx = new int[1000001];\\n        Arrays.fill(lastIdx, -1);\\n        \\n        int minLen = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < cards.length; i++) {\\n            if (lastIdx[cards[i]] != -1) {\\n                minLen = Math.min(minLen, i - lastIdx[cards[i]] + 1);\\n            }\\n            \\n            lastIdx[cards[i]] = i;\\n        }\\n        \\n        return minLen == Integer.MAX_VALUE ? -1 : minLen;\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int[] lastIdx = new int[1000001];\\n        Arrays.fill(lastIdx, -1);\\n        \\n        int minLen = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < cards.length; i++) {\\n            if (lastIdx[cards[i]] != -1) {\\n                minLen = Math.min(minLen, i - lastIdx[cards[i]] + 1);\\n            }\\n            \\n            lastIdx[cards[i]] = i;\\n        }\\n        \\n        return minLen == Integer.MAX_VALUE ? -1 : minLen;\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503209,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        lastOccurence, ans = defaultdict(list), float(\\'inf\\')\\n        for i in range(len(cards)):\\n            lastOccurence[cards[i]].append(i)\\n        if len(lastOccurence.keys()) == len(cards):\\n            return -1\\n        for card in lastOccurence:\\n            diff = float(\\'inf\\')\\n            if len(lastOccurence[card]) > 1:\\n                for i in range(len(lastOccurence[card])):\\n                    diff = min(diff, abs(lastOccurence[card][i - 1] - lastOccurence[card][i]) + 1)\\n            ans = min(ans, diff)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        lastOccurence, ans = defaultdict(list), float(\\'inf\\')\\n        for i in range(len(cards)):\\n            lastOccurence[cards[i]].append(i)\\n        if len(lastOccurence.keys()) == len(cards):\\n            return -1\\n        for card in lastOccurence:\\n            diff = float(\\'inf\\')\\n            if len(lastOccurence[card]) > 1:\\n                for i in range(len(lastOccurence[card])):\\n                    diff = min(diff, abs(lastOccurence[card][i - 1] - lastOccurence[card][i]) + 1)\\n            ans = min(ans, diff)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408885,
                "title": "c-easy-explanation-o-n-using-unordered-map",
                "content": "### **Code:-**\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size(), mn = INT_MAX;\\n        unordered_map<int, int> mp;     // Store Card Value and its index\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // If found in map\\n            if(mp.count(cards[i]))\\n            {\\n                // Find size of window from prev index to current index\\n                int prev = mp[cards[i]];\\n                mn = min(mn, i - prev + 1);\\n            }\\n            // If not found in map, insert it\\n            mp[cards[i]] = i;\\n        }\\n        \\n        return mn == INT_MAX ? -1 : mn;\\n    }\\n};\\n```\\n\\n### Explanation:-\\n\\n**m[cards[i]] -> Prev index of the number\\ni - m[cards[i]] + 1 is the window/subarray size starting from the prev index to current index.\\nFor eg:\\n```[3, 4, 2, 3, 4, 7]```\\nWhen ```i = 3```, we encounter 3 again. In the map, we have stored ```index of 3 as 0 :- {3, 0}```.\\nSo window/subarray size :-\\n```i - mp[3] + 1 == 3 - 0 + 1 == 4 ( [3, 4, 2, 3] )```**\\n\\nT.C :- O(n)\\nS.C :- O(n) \\n\\n**Hope you found this helpful!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size(), mn = INT_MAX;\\n        unordered_map<int, int> mp;     // Store Card Value and its index\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // If found in map\\n            if(mp.count(cards[i]))\\n            {\\n                // Find size of window from prev index to current index\\n                int prev = mp[cards[i]];\\n                mn = min(mn, i - prev + 1);\\n            }\\n            // If not found in map, insert it\\n            mp[cards[i]] = i;\\n        }\\n        \\n        return mn == INT_MAX ? -1 : mn;\\n    }\\n};\\n```\n```[3, 4, 2, 3, 4, 7]```\n```i = 3```\n```index of 3 as 0 :- {3, 0}```\n```i - mp[3] + 1 == 3 - 0 + 1 == 4 ( [3, 4, 2, 3] )```",
                "codeTag": "Java"
            },
            {
                "id": 2326236,
                "title": "java-92-easy-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int min=Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<cards.length;i++){\\n            if(hm.containsKey(cards[i])){\\n                int l=hm.get(cards[i]);\\n                min=Math.min(min,i-l+1);\\n            }\\n            hm.put(cards[i],i);\\n        }\\n        return min==Integer.MAX_VALUE?-1:min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int min=Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<cards.length;i++){\\n            if(hm.containsKey(cards[i])){\\n                int l=hm.get(cards[i]);\\n                min=Math.min(min,i-l+1);\\n            }\\n            hm.put(cards[i],i);\\n        }\\n        return min==Integer.MAX_VALUE?-1:min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303389,
                "title": "c-using-two-approaches-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int usingSlidingWindow(vector<int> &cards){\\n\\t\\t// Stores the card and its index\\n        unordered_map<int,int> um;\\n        int ans = INT_MAX;\\n        \\n        int i=0, j=0;\\n        while(j<cards.size()){\\n            int card = cards[j];\\n            // If card already present, slide the window until the card is found\\n            while(um.find(card) != um.end() && i<j){\\n                ans = min(ans, j-i+1);\\n                um.erase(cards[i]);\\n                i++;\\n            }\\n            um[card] = j;\\n            j++;\\n        }\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n**Optimized approach:**\\n```\\nint minimumCardPickup(vector<int>& cards) {\\n\\t// Stores the recent index of a card \\n\\tunordered_map<int,int> um;\\n\\tint ans = INT_MAX;\\n\\t\\n\\tfor(int i=0; i<cards.size(); i++){\\n\\t\\tint card = cards[i];\\n\\t\\t// If card already already exists\\n\\t\\tif(um.find(card) != um.end()){\\n\\t\\t\\tans = min(ans, i-um[card]+1);\\n\\t\\t}\\n\\t\\t// Update the index of the card\\n\\t\\tum[card] = i;\\n\\t}\\n\\treturn ans == INT_MAX ? -1 : ans;\\n}\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int usingSlidingWindow(vector<int> &cards){\\n\\t\\t// Stores the card and its index\\n        unordered_map<int,int> um;\\n        int ans = INT_MAX;\\n        \\n        int i=0, j=0;\\n        while(j<cards.size()){\\n            int card = cards[j];\\n            // If card already present, slide the window until the card is found\\n            while(um.find(card) != um.end() && i<j){\\n                ans = min(ans, j-i+1);\\n                um.erase(cards[i]);\\n                i++;\\n            }\\n            um[card] = j;\\n            j++;\\n        }\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\n```\\nint minimumCardPickup(vector<int>& cards) {\\n\\t// Stores the recent index of a card \\n\\tunordered_map<int,int> um;\\n\\tint ans = INT_MAX;\\n\\t\\n\\tfor(int i=0; i<cards.size(); i++){\\n\\t\\tint card = cards[i];\\n\\t\\t// If card already already exists\\n\\t\\tif(um.find(card) != um.end()){\\n\\t\\t\\tans = min(ans, i-um[card]+1);\\n\\t\\t}\\n\\t\\t// Update the index of the card\\n\\t\\tum[card] = i;\\n\\t}\\n\\treturn ans == INT_MAX ? -1 : ans;\\n}\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2147397,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window && Unordered Map***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int mini = INT_MAX;\\n        \\n        int left = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            mp[arr[right]]++;\\n            \\n            while(left <= right && mp[arr[right]] > 1)\\n            {\\n                mini = min(mini, right - left + 1);\\n                \\n                mp[arr[left]]--;\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return mini == INT_MAX ? -1 : mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int mini = INT_MAX;\\n        \\n        int left = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            mp[arr[right]]++;\\n            \\n            while(left <= right && mp[arr[right]] > 1)\\n            {\\n                mini = min(mini, right - left + 1);\\n                \\n                mp[arr[left]]--;\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return mini == INT_MAX ? -1 : mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134873,
                "title": "c-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& v) {\\n        int n=v.size();\\n        if(n<2) return -1;\\n        else if(n==2) return v[0]==v[1]?2:-1;\\n        unordered_map<int,int> m;\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            if(m.find(v[i])!=m.end()) ans=min(i-m[v[i]]+1,ans);\\n            m[v[i]]=i;\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& v) {\\n        int n=v.size();\\n        if(n<2) return -1;\\n        else if(n==2) return v[0]==v[1]?2:-1;\\n        unordered_map<int,int> m;\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            if(m.find(v[i])!=m.end()) ans=min(i-m[v[i]]+1,ans);\\n            m[v[i]]=i;\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100153,
                "title": "java-solution-using-hashmap",
                "content": "the key idea is you need to see for every element that is it repeated if yes then find the distance between both the occurence and also there may be many case of repetition so you need to keep a record of minimum distance between any two repetition so we are using hashmap here which pair the array items to their last occurence index \\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n       HashMap<Integer, Integer> map = new HashMap<>();\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0 ; i < cards.length ; ++i){\\n            if(map.containsKey(cards[i])){\\n                res = Math.min(res ,i + 1- map.get(cards[i]));\\n            }\\n                map.put(cards[i] , i);\\n        }\\n        return (res <= cards.length)? res:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n       HashMap<Integer, Integer> map = new HashMap<>();\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0 ; i < cards.length ; ++i){\\n            if(map.containsKey(cards[i])){\\n                res = Math.min(res ,i + 1- map.get(cards[i]));\\n            }\\n                map.put(cards[i] , i);\\n        }\\n        return (res <= cards.length)? res:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099186,
                "title": "python-easy-set-dictionary",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, a: List[int]) -> int:\\n        d=set()\\n        s={}\\n        n=len(a)\\n        \\n        for i in range(n):\\n        \\n            if a[i] in s:\\n                d.add(a[i])\\n                s[a[i]].append(i)\\n            else:\\n                s[a[i]]=[i]\\n        \\n        if len(d)==0:\\n            return -1\\n        \\n        for i in d:\\n            for j in range(len(s[i])-1):\\n                n=min(n,s[i][j+1]-s[i][j])\\n        \\n        return n+1\\n```\\n![image](https://assets.leetcode.com/users/images/f339c2c8-5aec-4a68-ba01-ba4169649045_1654102996.4132123.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, a: List[int]) -> int:\\n        d=set()\\n        s={}\\n        n=len(a)\\n        \\n        for i in range(n):\\n        \\n            if a[i] in s:\\n                d.add(a[i])\\n                s[a[i]].append(i)\\n            else:\\n                s[a[i]]=[i]\\n        \\n        if len(d)==0:\\n            return -1\\n        \\n        for i in d:\\n            for j in range(len(s[i])-1):\\n                n=min(n,s[i][j+1]-s[i][j])\\n        \\n        return n+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066456,
                "title": "c-use-hashmap-track-last-occurence-of-the-card",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    //store the 1st occurence of the card in the map when it comes 2nd time, \\n    //we calculate the length from its 1st occurence and then find minimum length \\n    \\n    int minimumCardPickup(vector<int>& cards) \\n    {\\n        unordered_map<int,int> indices ;\\n        int ans = INT_MAX ;\\n        \\n        for(int i=0; i<cards.size(); i++)\\n        {\\n            //when card comes 1st time we store its index in the map\\n            if(indices.find(cards[i]) == end(indices))\\n            {\\n                indices[cards[i]] = i ;\\n                continue ;\\n            }\\n            //find mini distance by calculating (index of 2nd occurence - index of 1st occurence)\\n            ans = min(ans, i-indices[cards[i]]+1);\\n            indices[cards[i]] = i ;\\n        }\\n        return ans<INT_MAX ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    //store the 1st occurence of the card in the map when it comes 2nd time, \\n    //we calculate the length from its 1st occurence and then find minimum length \\n    \\n    int minimumCardPickup(vector<int>& cards) \\n    {\\n        unordered_map<int,int> indices ;\\n        int ans = INT_MAX ;\\n        \\n        for(int i=0; i<cards.size(); i++)\\n        {\\n            //when card comes 1st time we store its index in the map\\n            if(indices.find(cards[i]) == end(indices))\\n            {\\n                indices[cards[i]] = i ;\\n                continue ;\\n            }\\n            //find mini distance by calculating (index of 2nd occurence - index of 1st occurence)\\n            ans = min(ans, i-indices[cards[i]]+1);\\n            indices[cards[i]] = i ;\\n        }\\n        return ans<INT_MAX ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065004,
                "title": "o-n-python3-dict",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d = {}\\n        ans = float(\"inf\")\\n        \\n        for i in range(len(cards)):\\n            card = cards[i]\\n            \\n            if not card in d:\\n                d[card] = i\\n            \\n            else:\\n                ans = min(ans, i - d[card] + 1)\\n                d[card] = i\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d = {}\\n        ans = float(\"inf\")\\n        \\n        for i in range(len(cards)):\\n            card = cards[i]\\n            \\n            if not card in d:\\n                d[card] = i\\n            \\n            else:\\n                ans = min(ans, i - d[card] + 1)\\n                d[card] = i\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061028,
                "title": "python-with-dict-99-linear-time",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d={}\\n        x=[]\\n        for i in range(len(cards)):\\n            if cards[i] not in d:\\n                d[cards[i]]=i\\n            else:\\n                x.append(i-d[cards[i]])\\n                d[cards[i]]=i\\n        if len(x)<=0:\\n            return -1\\n        return min(x)+1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d={}\\n        x=[]\\n        for i in range(len(cards)):\\n            if cards[i] not in d:\\n                d[cards[i]]=i\\n            else:\\n                x.append(i-d[cards[i]])\\n                d[cards[i]]=i\\n        if len(x)<=0:\\n            return -1\\n        return min(x)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048032,
                "title": "sliding-window-clear-solution-c",
                "content": "class Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size();\\n        \\n        int i = 0,j = 0,mn = INT32_MAX;\\n        unordered_map<int,int>mp;\\n        \\n        // SIMPLE SLIDING WINDOW PROBLEM\\n        \\n        while(j < n)\\n        {\\n            mp[cards[j]]++;\\n            \\n            if(j-i+1 == mp.size())\\n            {\\n                j++;\\n                // Normal procedure if unique characters are coming, keep inserting into map\\n            }\\n            else if(j-i+1 > mp.size())\\n            {\\n                // When a duplicate character comes length(or size of the sliding window)\\n                // becomes greater than the map\\'s size\\n                while(j-i+1 > mp.size())\\n                {\\n                    mp[cards[i]]--;\\n                    if(mp[cards[i]] == 0)\\n                    {\\n                        mp.erase(cards[i]);\\n                    }\\n                    mn =  min(mn,j-i+1);\\n                    i++;\\n                }\\n                \\n                // HERE INCREMENTING J IS IMPORTANT because we don\\'t want to insert previous \\n                // cards[j] into the map again\\n                j++;\\n            }\\n        }\\n      \\n        if(mn == INT32_MAX) return -1;\\n      \\n        return mn;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size();\\n        \\n        int i = 0,j = 0,mn = INT32_MAX;\\n        unordered_map<int,int>mp;\\n        \\n        // SIMPLE SLIDING WINDOW PROBLEM\\n        \\n        while(j < n)\\n        {\\n            mp[cards[j]]++;\\n            \\n            if(j-i+1 == mp.size())\\n            {\\n                j++;\\n                // Normal procedure if unique characters are coming, keep inserting into map\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2025038,
                "title": "c-unorderedmap-time-complexity-o-n-space-complexity-o-n",
                "content": "Here we traverse through the array and store the numbers with their index in unordered_map and while traversing we check if the element is present earlier in the map. If found, we find the distance between current index and previous index of the same element stored in the map.\\nWe are using an unordered_map so space complexity will O(n) and we are traversing through the array once so time complexity will be O(n).\\nFor finding the element the time taken on average is O(1) in unordered_map.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        if(cards.size()==1) return -1;\\n        unordered_map<int,int> mp;\\n        int ans=INT_MAX;\\n        for(int i=0; i<cards.size(); i++)\\n        {\\n            if(mp.find(cards[i])==mp.end()) mp[cards[i]]=i;\\n            else\\n            {\\n                ans = min(i-mp[cards[i]] + 1,ans);\\n                mp[cards[i]]=i;\\n            }\\n        }\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        if(cards.size()==1) return -1;\\n        unordered_map<int,int> mp;\\n        int ans=INT_MAX;\\n        for(int i=0; i<cards.size(); i++)\\n        {\\n            if(mp.find(cards[i])==mp.end()) mp[cards[i]]=i;\\n            else\\n            {\\n                ans = min(i-mp[cards[i]] + 1,ans);\\n                mp[cards[i]]=i;\\n            }\\n        }\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004584,
                "title": "greedy-c-o-nlogn",
                "content": "Idea:\\nThe idea is to maintain a vector pair of value and index and greedily check the difference between same pairs, for all pairs and take minimum of those.\\n\\nFirst we will create a vector of pairs and push back each pair of value and index into the vector pair.\\n\\nMaintain a res variable for final result.\\n\\nThen we will run a loop on the vector pair.\\n\\nThen first we will check if v[i-1].first==v[i].first, which means both the elements were equal, then we will update our res variable as difference of (v[i].second-v[i].first).\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        int n=cards.size();\\n        \\n        int res=INT_MAX;\\n        \\n        vector<pair<int,int>> v;\\n        for(int i=0;i<cards.size();i++)\\n        {\\n            v.push_back({cards[i],i});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=1;i<v.size();i++)\\n        {\\n            int prev_first=v[i-1].first;\\n            int prev_second=v[i-1].second;\\n            \\n            int curr_first=v[i].first;\\n            int curr_second=v[i].second;\\n            \\n            if(prev_first==curr_first)\\n            {\\n                res=min(res,abs(curr_second-prev_second));\\n            }\\n        }    \\n        \\n        return (res==INT_MAX?-1:res+1);\\n        \\n        \\n    }\\n};\\n\\n```\\n\\nTime Complexity : O(NLogN) \\xA0 \\nSpace Complexity : O(N)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        int n=cards.size();\\n        \\n        int res=INT_MAX;\\n        \\n        vector<pair<int,int>> v;\\n        for(int i=0;i<cards.size();i++)\\n        {\\n            v.push_back({cards[i],i});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=1;i<v.size();i++)\\n        {\\n            int prev_first=v[i-1].first;\\n            int prev_second=v[i-1].second;\\n            \\n            int curr_first=v[i].first;\\n            int curr_second=v[i].second;\\n            \\n            if(prev_first==curr_first)\\n            {\\n                res=min(res,abs(curr_second-prev_second));\\n            }\\n        }    \\n        \\n        return (res==INT_MAX?-1:res+1);\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001675,
                "title": "minimum-consecutive-cards-to-pickup",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) \\n    {\\n        unordered_map<int, int> mp;\\n        int ans = INT_MAX;\\n        for (int i = 0; i < cards.size(); i++)\\n        {\\n            if (mp.find(cards[i]) == mp.end())\\n            {\\n                mp[cards[i]] = i;\\n                continue;\\n            }\\n            ans = min(ans, abs(i - mp[cards[i]] + 1));\\n        }\\n        unordered_map<int, int> mp1;\\n        for (int i = cards.size() - 1; i >= 0; i--)\\n        {\\n            if (mp1.find(cards[i]) == mp1.end())\\n            {\\n                mp1[cards[i]] = i;\\n                continue;\\n            }\\n            ans = min(ans, abs(mp1[cards[i]] + 1 - i));\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) \\n    {\\n        unordered_map<int, int> mp;\\n        int ans = INT_MAX;\\n        for (int i = 0; i < cards.size(); i++)\\n        {\\n            if (mp.find(cards[i]) == mp.end())\\n            {\\n                mp[cards[i]] = i;\\n                continue;\\n            }\\n            ans = min(ans, abs(i - mp[cards[i]] + 1));\\n        }\\n        unordered_map<int, int> mp1;\\n        for (int i = cards.size() - 1; i >= 0; i--)\\n        {\\n            if (mp1.find(cards[i]) == mp1.end())\\n            {\\n                mp1[cards[i]] = i;\\n                continue;\\n            }\\n            ans = min(ans, abs(mp1[cards[i]] + 1 - i));\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998134,
                "title": "easy-javascript-solution",
                "content": "```\\nvar minimumCardPickup = function(cards) {\\n    let ans=Infinity;\\n    let obj={};\\n    for(let i=0; i<cards.length; i++){\\n      if(obj[cards[i]]===undefined){ \\n        obj[cards[i]]=i;\\n      }\\n      else{ ans=Math.min(ans,i-obj[cards[i]]); obj[cards[i]]=i; }\\n    }\\n    return ans===Infinity ?-1 :ans+1;  \\n};      \\n```",
                "solutionTags": [],
                "code": "```\\nvar minimumCardPickup = function(cards) {\\n    let ans=Infinity;\\n    let obj={};\\n    for(let i=0; i<cards.length; i++){\\n      if(obj[cards[i]]===undefined){ \\n        obj[cards[i]]=i;\\n      }\\n      else{ ans=Math.min(ans,i-obj[cards[i]]); obj[cards[i]]=i; }\\n    }\\n    return ans===Infinity ?-1 :ans+1;  \\n};      \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997206,
                "title": "java-100-fast-and-100-memo-easy-10-lines-of-code",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<cards.length;i++){\\n            int temp=map.getOrDefault(cards[i],-1);\\n            if (temp!=-1){\\n                ans=Math.min(i-temp+1,ans);\\n            }\\n            map.put(cards[i],i);\\n\\n        }\\n        if(ans==Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<cards.length;i++){\\n            int temp=map.getOrDefault(cards[i],-1);\\n            if (temp!=-1){\\n                ans=Math.min(i-temp+1,ans);\\n            }\\n            map.put(cards[i],i);\\n\\n        }\\n        if(ans==Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996951,
                "title": "java-easy-code",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int min = (int) 1e9;\\n        for (int i = 0; i < cards.length; i++) {\\n            if (map.containsKey(cards[i])) {\\n                min = Math.min(min, i - map.get(cards[i]) + 1);\\n            }\\n            map.put(cards[i], i);\\n        }\\n\\n        return min == (int) 1e9 ? -1 : min;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int min = (int) 1e9;\\n        for (int i = 0; i < cards.length; i++) {\\n            if (map.containsKey(cards[i])) {\\n                min = Math.min(min, i - map.get(cards[i]) + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1996346,
                "title": "java-from-tle-to-ac-solution-o-n-2-to-o-n",
                "content": "Using two Loops give TLE.\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int card : cards){\\n            set.add(card);\\n        }\\n        if(set.size() == cards.length){\\n            return -1;\\n        }\\n        int minCardsToPickUp = Integer.MAX_VALUE;\\n        for(int i=0; i<cards.length-1; i++){\\n            for(int j=i+1; j<cards.length;j++){\\n                if(cards[i] == cards[j]){\\n                    int cardsPickedUp = j-i+1;\\n                    if(minCardsToPickUp > cardsPickedUp){\\n                        minCardsToPickUp = cardsPickedUp;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(minCardsToPickUp == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return minCardsToPickUp;\\n    }\\n}\\n```\\n\\nSo replacing that by a map where we keep updating the required value and keep track of min cards required.\\n\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int card : cards){\\n            set.add(card);\\n        }\\n        if(set.size() == cards.length){\\n            return -1;\\n        }\\n        int minCardsToPickUp = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0; i<cards.length; i++){\\n            if(map.containsKey(cards[i])){\\n                int temp = i - map.get(cards[i]) + 1;\\n                if(temp < minCardsToPickUp){\\n                    minCardsToPickUp = temp;\\n                }\\n                map.put(cards[i],i);\\n            }\\n            else{\\n               map.put(cards[i],i);\\n            }\\n        }\\n        if(minCardsToPickUp == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return minCardsToPickUp;\\n    }\\n}\\n```\\nVery Simple, if any queries, please comment.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int card : cards){\\n            set.add(card);\\n        }\\n        if(set.size() == cards.length){\\n            return -1;\\n        }\\n        int minCardsToPickUp = Integer.MAX_VALUE;\\n        for(int i=0; i<cards.length-1; i++){\\n            for(int j=i+1; j<cards.length;j++){\\n                if(cards[i] == cards[j]){\\n                    int cardsPickedUp = j-i+1;\\n                    if(minCardsToPickUp > cardsPickedUp){\\n                        minCardsToPickUp = cardsPickedUp;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(minCardsToPickUp == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return minCardsToPickUp;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int card : cards){\\n            set.add(card);\\n        }\\n        if(set.size() == cards.length){\\n            return -1;\\n        }\\n        int minCardsToPickUp = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0; i<cards.length; i++){\\n            if(map.containsKey(cards[i])){\\n                int temp = i - map.get(cards[i]) + 1;\\n                if(temp < minCardsToPickUp){\\n                    minCardsToPickUp = temp;\\n                }\\n                map.put(cards[i],i);\\n            }\\n            else{\\n               map.put(cards[i],i);\\n            }\\n        }\\n        if(minCardsToPickUp == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return minCardsToPickUp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996241,
                "title": "c-easy-to-understand-simple-approach-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int i=0;\\n        int j=0;\\n        int n=cards.size();\\n        map<int,int> mp;\\n        int ans=INT_MAX;\\n        while(j<n)\\n        {\\n            mp[cards[j]]++;\\n            if(mp.size()!=(j-i+1))\\n            {\\n                while(mp.size()!=(j-i+1))\\n                {\\n                    ans=min(ans,j-i+1);\\n                    mp[cards[i]]--;\\n                    if(mp[cards[i]]==0)\\n                    mp.erase(cards[i]);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int i=0;\\n        int j=0;\\n        int n=cards.size();\\n        map<int,int> mp;\\n        int ans=INT_MAX;\\n        while(j<n)\\n        {\\n            mp[cards[j]]++;\\n            if(mp.size()!=(j-i+1))\\n            {\\n                while(mp.size()!=(j-i+1))\\n                {\\n                    ans=min(ans,j-i+1);\\n                    mp[cards[i]]--;\\n                    if(mp[cards[i]]==0)\\n                    mp.erase(cards[i]);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830280,
                "title": "sliding-window-answer-in-c-faster-than-93",
                "content": "\\n# Approach\\nJust keep track of the window and once a valid window is found make sure to take the minimum of that.\\n- What is a valid  window ?\\n> A window which has a duplicate element. And if a window size is less than right - left + 1, then the window has a duplicate element and that means that it is a valid window. \\n \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int size = cards.size();\\n        int left=0,right=0;\\n        int maxi=INT_MAX;\\n        unordered_map<int,int> um;\\n\\n        while(right < size){\\n            um[cards[right]]++;\\n            // checking for a valid window\\n            while(um.size() < right - left + 1){\\n                // taking the minimum window size.\\n                maxi = min(maxi, right - left + 1);\\n                um[cards[left]]--;\\n                if(um[cards[left]] == 0) um.erase(cards[left]);\\n                left++;\\n            }\\n            \\n            if(right - left + 1 == size) return -1;\\n            right++;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int size = cards.size();\\n        int left=0,right=0;\\n        int maxi=INT_MAX;\\n        unordered_map<int,int> um;\\n\\n        while(right < size){\\n            um[cards[right]]++;\\n            // checking for a valid window\\n            while(um.size() < right - left + 1){\\n                // taking the minimum window size.\\n                maxi = min(maxi, right - left + 1);\\n                um[cards[left]]--;\\n                if(um[cards[left]] == 0) um.erase(cards[left]);\\n                left++;\\n            }\\n            \\n            if(right - left + 1 == size) return -1;\\n            right++;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740004,
                "title": "sliding-window-short-and-simple-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery optimal sol will have first and the last card to be same. And this will be our variant to select the size of the window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nUsing hashing in the elements of the window we are keeping track of the window elements and whenever we are encountering any new element (i.e right most element) that is already present int the hash map we are checking if  the left most element is also same or not. If not then we are just decreasing the window size till our condition is satisfied.\\nNow when decreasing the window we are also deleting the left elements from the hash map. And updating the ans accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        unordered_map<int,int> h_map;\\n\\n        int left=0,right=0;\\n        int ans=INT_MAX;\\n        while(right<cards.size())\\n        {\\n            auto ptr= h_map.find(cards[right]);\\n            if(ptr==h_map.end())\\n                h_map.insert({cards[right],right});\\n            else\\n            {                \\n                while(cards[right]!=cards[left])\\n                {   \\n                    h_map.erase(cards[left]); \\n                    left++;\\n                }\\n                ans=min(ans,right-left+1);\\n                //cout<<\"left: \"<<left<<\" right: \"<<right<<\"  ans: \"<<ans<<endl;\\n                ptr->second=right;\\n                left++;\\n            }\\n            right++;\\n        }\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        unordered_map<int,int> h_map;\\n\\n        int left=0,right=0;\\n        int ans=INT_MAX;\\n        while(right<cards.size())\\n        {\\n            auto ptr= h_map.find(cards[right]);\\n            if(ptr==h_map.end())\\n                h_map.insert({cards[right],right});\\n            else\\n            {                \\n                while(cards[right]!=cards[left])\\n                {   \\n                    h_map.erase(cards[left]); \\n                    left++;\\n                }\\n                ans=min(ans,right-left+1);\\n                //cout<<\"left: \"<<left<<\" right: \"<<right<<\"  ans: \"<<ans<<endl;\\n                ptr->second=right;\\n                left++;\\n            }\\n            right++;\\n        }\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3587106,
                "title": "beating-85-16-python-easiest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/50f86f90-d5e0-45e9-bd44-bc1aedd6e3d0_1685645871.6161683.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        if len(set(cards))==len(cards):\\n            return -1\\n        dic={}   \\n        ma=1000000\\n        for i in range (len(cards)):\\n            if cards[i] not in dic:\\n                dic[cards[i]]=i\\n            else:\\n                if ma>(i-(dic[cards[i]])):\\n                    ma=(i-dic[cards[i]])\\n                dic[cards[i]]=i\\n        return ma+1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        if len(set(cards))==len(cards):\\n            return -1\\n        dic={}   \\n        ma=1000000\\n        for i in range (len(cards)):\\n            if cards[i] not in dic:\\n                dic[cards[i]]=i\\n            else:\\n                if ma>(i-(dic[cards[i]])):\\n                    ma=(i-dic[cards[i]])\\n                dic[cards[i]]=i\\n        return ma+1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457813,
                "title": "c-sliding-window",
                "content": "# Intuition\\nFind the first window where freq of an element is greater than 1.\\nStart reducing the window size and keep track of the window length.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& a) {\\n        int n=a.size();\\n        map<int,int>m;\\n        int l=0, r=0, ans=INT_MAX;\\n        while(r<n)\\n        {\\n            m[a[r]]++;\\n            while(m[a[r]]>1)\\n            {\\n                ans= min(ans, r-l+1);\\n                m[a[l]]--;\\n                l++;\\n            }\\n            r++;\\n        }\\n        return ans!=INT_MAX ? ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& a) {\\n        int n=a.size();\\n        map<int,int>m;\\n        int l=0, r=0, ans=INT_MAX;\\n        while(r<n)\\n        {\\n            m[a[r]]++;\\n            while(m[a[r]]>1)\\n            {\\n                ans= min(ans, r-l+1);\\n                m[a[l]]--;\\n                l++;\\n            }\\n            r++;\\n        }\\n        return ans!=INT_MAX ? ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172785,
                "title": "ruby-solution-easy-to-understand",
                "content": "```\\n# @param {Integer[]} cards\\n# @return {Integer}\\ndef minimum_card_pickup(cards)\\n    min = cards.size + 1\\n    past_cards = {} # { key => value } -> { card => index_last_seen }\\n    \\n    (0...cards.size).each do |r|\\n        # record dist btwn current idx and last idx if card has already been seen\\n        min = [min, r - past_cards[cards[r]] + 1].min if past_cards.has_key?(cards[r])  \\n        past_cards[cards[r]] = r\\n    end\\n    \\n    min == cards.size + 1 ? -1 : min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} cards\\n# @return {Integer}\\ndef minimum_card_pickup(cards)\\n    min = cards.size + 1\\n    past_cards = {} # { key => value } -> { card => index_last_seen }\\n    \\n    (0...cards.size).each do |r|\\n        # record dist btwn current idx and last idx if card has already been seen\\n        min = [min, r - past_cards[cards[r]] + 1].min if past_cards.has_key?(cards[r])  \\n        past_cards[cards[r]] = r\\n    end\\n    \\n    min == cards.size + 1 ? -1 : min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3106663,
                "title": "keep-track-of-last-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep track of the last \\n\\n# Approach\\nKeep track of the last element and calculate the min.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int arr[1000001]; \\n        memset(arr, -1 , sizeof(arr)); \\n        int ans = INT_MAX; \\n        for ( int i  =0; i <cards.size(); i++){\\n            if ( arr[cards[i]]==-1) arr[cards[i]]= i ; \\n            else \\n            {\\n                ans = min ( ans , i-arr[cards[i]]+ 1); \\n                arr[cards[i]]= i ; \\n            }\\n        }\\n        return ans == INT_MAX ?-1 :ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int arr[1000001]; \\n        memset(arr, -1 , sizeof(arr)); \\n        int ans = INT_MAX; \\n        for ( int i  =0; i <cards.size(); i++){\\n            if ( arr[cards[i]]==-1) arr[cards[i]]= i ; \\n            else \\n            {\\n                ans = min ( ans , i-arr[cards[i]]+ 1); \\n                arr[cards[i]]= i ; \\n            }\\n        }\\n        return ans == INT_MAX ?-1 :ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083334,
                "title": "using-two-hashtables-time-o-n-beats-time-84-and-memory-65",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreating two hashtables to store the index of previous and current occurance of card.\\n(Storing only two maximum index of each card if occured more than once where highest index in second HT and previous highest in first HT).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst hashtable constains index of card with respect to current card position.\\nSecond hashtable constains index of card if there is multiple occurence.\\n\\nIterate through cards array,\\ncheck if element is already in first HT or not\\n\\nIf maximum 2 occurance for each/any card,\\nThen first occurance in first HT. and second in second HT.\\n\\nIf more than 2 occurance,\\nGreater index in second HT. previous greater in first HT.\\n\\nCalculate difference between indices of that card in different HT to find out minimum consecutive cards to pick.\\n\\ni.e.\\ncards = [3,4,2,3,4,7,2,3,4,3]\\nHT1 = {}\\nHT2 = {}\\nfor each iteartion,\\n\\ncard = 3, index = 0 \\n=> HT1 = {3:0}, HT2 = {}\\n\\ncard = 4, index = 1 \\n=> HT1 = {3:0, 4:1}, HT2 = {}\\n\\ncard = 2, index = 2 \\n=> HT1 = {3:0, 4:1, 2:2}, HT2 = {}\\n\\ncard = 3, index = 3 \\n=> HT1 = {3:0, 4:1, 2:2}, HT2 = {3:3}\\nsecond occurance for card 3. difference in indices is 3-0+1 = 4 cards to pick.\\n\\ncard = 4, index = 4 \\n=> HT1 = {3:0, 4:1, 2:2}, HT2 = {3:3, 4:4}\\nsecond occurance for card 4. difference in indices is 4-1+1 = 4 cards to pick.\\n\\ncard = 7, index = 5 \\n=> HT1 = {3:0, 4:1, 2:2, 7:5}, HT2 = {3:3, 4;4}\\n\\ncard = 2, index = 6 \\n=> HT1 = {3:0, 4:1, 2:2, 7:5}, HT2 = {3:3, 4;4, 2:6}\\nsecond occurance for card 2. difference in indices is 6-2+1 = 5 cards to pick.\\n\\ncard = 3, index = 7 \\n=> HT1 = {3:3, 4:1, 2:2, 7:5}, HT2 = {3:7, 4;4, 2:6}\\nthird occurance for card 3. difference in indices is 7-3+1 = 5 cards to pick.\\n\\ncard = 4, index = 8 \\n=> HT1 = {3:3, 4:4, 2:2, 7:5}, HT2 = {3:7, 4;8, 2:6}\\nthird occurance for card 4. difference in indices is 8-4+1 = 5 cards to pick.\\n\\ncard = 3, index = 8 \\n=> HT1 = {3:7, 4:4, 2:2, 7:5}, HT2 = {3:9, 4;8, 2:6}\\nfourth occurance for card 3. difference in indices is 9-7+1 = 3 cards to pick.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        card1Pos = {}\\n        card2Pos = {}\\n        minCards = float(\\'Inf\\')\\n        for i in range(len(cards)):\\n            if cards[i] in card1Pos:\\n                if cards[i] in card2Pos:\\n                    card1Pos[cards[i]] = card2Pos[cards[i]]\\n                card2Pos[cards[i]] = i\\n                consecCards = card2Pos[cards[i]] - card1Pos[cards[i]] + 1\\n                minCards = min(minCards, consecCards)\\n                if minCards == 2:\\n                    return minCards\\n            else:\\n                card1Pos[cards[i]] = i\\n        return -1 if minCards == float(\\'Inf\\') else minCards\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        card1Pos = {}\\n        card2Pos = {}\\n        minCards = float(\\'Inf\\')\\n        for i in range(len(cards)):\\n            if cards[i] in card1Pos:\\n                if cards[i] in card2Pos:\\n                    card1Pos[cards[i]] = card2Pos[cards[i]]\\n                card2Pos[cards[i]] = i\\n                consecCards = card2Pos[cards[i]] - card1Pos[cards[i]] + 1\\n                minCards = min(minCards, consecCards)\\n                if minCards == 2:\\n                    return minCards\\n            else:\\n                card1Pos[cards[i]] = i\\n        return -1 if minCards == float(\\'Inf\\') else minCards\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026155,
                "title": "easy-and-cool-explanation-gauravthinks",
                "content": "# Intuition\\nIt is as simple as nipple. Just store the card\\'s value(key) with the previous occurence of the index element(value). Whenever, we encounter the duplicate element, we simple calculate the distances b/w the current and previous position. That distance(minimun), is stored stored everytime, we encounter duplicate elements.\\n\\n# Complexity\\n- Time complexity:\\nas only one traversal is done for the whole calculation, \\n    # O(N) time complexity\\n\\n- Space complexity:\\nAs we used, an Unorderd Map for storing the values of elements with their indices, we use\\n    #  O(N)  space\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int res= INT_MAX;\\n        int n= size(cards);\\n        unordered_map<int, int> naksha; //we store the indices with their last index occurences\\n        for(auto it=0; it<n; it++){\\n         if(naksha.count(cards[it])){ // if there exist any element that is previously seen at some index, \\n             res= min(res, it-naksha[cards[it]]+1); // we calculate the distance b/w the current and the previous stored index\\n         }   \\n         naksha[cards[it]]=it; // else, if the element is fresh, then we store the index, to the value of the map\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```\\nIf you liked the explanation with the Cute and simple code, then do upvote the solution, and subscribe to the youtube channel below\\n# GauravThinks <------ Youtube channel",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int res= INT_MAX;\\n        int n= size(cards);\\n        unordered_map<int, int> naksha; //we store the indices with their last index occurences\\n        for(auto it=0; it<n; it++){\\n         if(naksha.count(cards[it])){ // if there exist any element that is previously seen at some index, \\n             res= min(res, it-naksha[cards[it]]+1); // we calculate the distance b/w the current and the previous stored index\\n         }   \\n         naksha[cards[it]]=it; // else, if the element is fresh, then we store the index, to the value of the map\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922215,
                "title": "c-easy-solution-hash-map-tc-o-n-sc-o-k",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k) where k is ``0 <= s.length <= 5 * 10^4``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        vector<int> m(1000001, -1);\\n        int res = INT_MAX, len = INT_MAX;\\n\\n        for (int i = 0; i < cards.size(); i++) {\\n            int val = cards[i];\\n            if (m[val] != -1) {\\n                len = i - m[val] + 1;\\n            }\\n            m[val] = i;\\n            res = min(res, len);\\n        }\\n\\n        return (res == INT_MAX) ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        vector<int> m(1000001, -1);\\n        int res = INT_MAX, len = INT_MAX;\\n\\n        for (int i = 0; i < cards.size(); i++) {\\n            int val = cards[i];\\n            if (m[val] != -1) {\\n                len = i - m[val] + 1;\\n            }\\n            m[val] = i;\\n            res = min(res, len);\\n        }\\n\\n        return (res == INT_MAX) ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676592,
                "title": "c-map-easy-code",
                "content": "```\\nint minimumCardPickup(vector<int>& cards) {\\n        map<int,vector<int>>m;\\n        for(int i=0;i<cards.size();i++)\\n        {\\n            m[cards[i]].push_back(i);\\n        }\\n        int mi=INT_MAX;\\n        for(auto x:m){\\n            if(x.second.size()>1){\\n                for(int i=1;i<x.second.size();i++){\\n                    mi=min(mi,x.second[i]-x.second[i-1]);\\n                }\\n            }\\n        }\\n        if(mi==INT_MAX){\\n            return -1;\\n        }\\n        return mi+1;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumCardPickup(vector<int>& cards) {\\n        map<int,vector<int>>m;\\n        for(int i=0;i<cards.size();i++)\\n        {\\n            m[cards[i]].push_back(i);\\n        }\\n        int mi=INT_MAX;\\n        for(auto x:m){\\n            if(x.second.size()>1){\\n                for(int i=1;i<x.second.size();i++){\\n                    mi=min(mi,x.second[i]-x.second[i-1]);\\n                }\\n            }\\n        }\\n        if(mi==INT_MAX){\\n            return -1;\\n        }\\n        return mi+1;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2675814,
                "title": "c-sliding-window-concept",
                "content": "#  Please Upvote if Usefull\\n\\n**intution**\\n* We will keep on puttung every Element in Hashmap and if we encountered \\nany Value Again ,then From their we will try to Shrink our Window till we get value .\\n\\n* And our ans= ( last index of window - frint index of window +1)\\n\\n**NOTE**\\n* We are Generally Expanding our Window till no value Occour twice and \\n* The Instance we get any Value already present , We will Shrink our window such that all our Element is \\nis Unique\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& a) {\\n        unordered_map< int,int> m;\\n        int ans=INT_MAX,j=0;\\n        for( int i=0;i<a.size();i++){\\n            \\n            m[a[i]]++;\\n            while(  j<i && m[a[i]] >1){\\n                if( a[i]==a[j]){\\n                    m[a[i]]--;\\n                    ans=min( ans, i-j+1);\\n                }\\n                else m.erase(a[j]);\\n                j++;\\n            }\\n        }\\n        return ans!=INT_MAX ? ans :-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& a) {\\n        unordered_map< int,int> m;\\n        int ans=INT_MAX,j=0;\\n        for( int i=0;i<a.size();i++){\\n            \\n            m[a[i]]++;\\n            while(  j<i && m[a[i]] >1){\\n                if( a[i]==a[j]){\\n                    m[a[i]]--;\\n                    ans=min( ans, i-j+1);\\n                }\\n                else m.erase(a[j]);\\n                j++;\\n            }\\n        }\\n        return ans!=INT_MAX ? ans :-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651705,
                "title": "c-easy-to-understand-hash-table",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int ans = 10e5+10;\\n        int n = cards.size();\\n        unordered_map<int,pair<int,int>> cnt; // elm -> {cnt, lastIndx};\\n        for(int i=0;i<n;i++){\\n            int lastCnt = cnt[cards[i]].first;\\n            int lastIdx = cnt[cards[i]].second;\\n\\n            cnt[cards[i]].first += 1;\\n            cnt[cards[i]].second = i;\\n            \\n            if(cnt[cards[i]].first > lastCnt && lastCnt != 0){\\n                int curr = i - lastIdx + 1;\\n                ans = min(curr,ans);\\n            }\\n        }\\n        if(ans == 10e5+10) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int ans = 10e5+10;\\n        int n = cards.size();\\n        unordered_map<int,pair<int,int>> cnt; // elm -> {cnt, lastIndx};\\n        for(int i=0;i<n;i++){\\n            int lastCnt = cnt[cards[i]].first;\\n            int lastIdx = cnt[cards[i]].second;\\n\\n            cnt[cards[i]].first += 1;\\n            cnt[cards[i]].second = i;\\n            \\n            if(cnt[cards[i]].first > lastCnt && lastCnt != 0){\\n                int curr = i - lastIdx + 1;\\n                ans = min(curr,ans);\\n            }\\n        }\\n        if(ans == 10e5+10) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638526,
                "title": "python-sliding-window-set-faster-than-89",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        minL = float(\\'inf\\')\\n        start = 0\\n        uniques = set()\\n        \\n        for end in range(len(cards)):\\n            \\n            while cards[end] in uniques:\\n                uniques.remove(cards[start])\\n                minL = min(minL, end - start + 1)\\n                start += 1\\n            \\n            uniques.add(cards[end])\\n                    \\n        \\n        if minL == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return minL\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        minL = float(\\'inf\\')\\n        start = 0\\n        uniques = set()\\n        \\n        for end in range(len(cards)):\\n            \\n            while cards[end] in uniques:\\n                uniques.remove(cards[start])\\n                minL = min(minL, end - start + 1)\\n                start += 1\\n            \\n            uniques.add(cards[end])\\n                    \\n        \\n        if minL == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return minL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546713,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-track-the-last-occurrence",
                "content": "```C#\\npublic class Solution {\\n    public int MinimumCardPickup(int[] cards) {\\n        Dictionary<int, int> d = new ();\\n        int ans = int.MaxValue;\\n        for (int i = 0; i < cards.Length; i++) {\\n            if (d.TryGetValue(cards[i], out int lastIndex)) ans = Math.Min(ans, i - lastIndex + 1);\\n            d[cards[i]] = i;\\n        }\\n        \\n        if (ans == int.MaxValue) return -1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public int MinimumCardPickup(int[] cards) {\\n        Dictionary<int, int> d = new ();\\n        int ans = int.MaxValue;\\n        for (int i = 0; i < cards.Length; i++) {\\n            if (d.TryGetValue(cards[i], out int lastIndex)) ans = Math.Min(ans, i - lastIndex + 1);\\n            d[cards[i]] = i;\\n        }\\n        \\n        if (ans == int.MaxValue) return -1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438849,
                "title": "c-o-n-solution-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size();\\n        \\n        unordered_map<int, int> mp;\\n        int mincards = INT_MAX;\\n        \\n        for(int i=0; i<n; i++) {\\n            \\n            int c = 0;\\n            if (mp.find(cards[i]) != mp.end()) {\\n                c = (i - mp[cards[i]]);\\n                mp[cards[i]] = i;\\n                mincards = min(mincards, c);\\n            }\\n            else\\n                mp[cards[i]] = i;\\n        }\\n        if (mincards == INT_MAX)\\n            return -1;\\n        return mincards + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size();\\n        \\n        unordered_map<int, int> mp;\\n        int mincards = INT_MAX;\\n        \\n        for(int i=0; i<n; i++) {\\n            \\n            int c = 0;\\n            if (mp.find(cards[i]) != mp.end()) {\\n                c = (i - mp[cards[i]]);\\n                mp[cards[i]] = i;\\n                mincards = min(mincards, c);\\n            }\\n            else\\n                mp[cards[i]] = i;\\n        }\\n        if (mincards == INT_MAX)\\n            return -1;\\n        return mincards + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427878,
                "title": "c-o-n-solution-using-unordered-map-beginner-friendly",
                "content": "\\'\\'\\'\\n\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        int s=0, e=0;\\n        int result=INT_MAX, pos, flag=0;\\n        unordered_map<int, int> mp;\\n        while(e<n)\\n        {\\n           if(mp.find(cards[e])==mp.end())\\n           {\\n               mp[cards[e]]=e;\\n           }\\n           else{\\n               flag=1;\\n               pos=e-mp[cards[e]];\\n               result=min(result, pos);\\n               mp.erase(cards[e]);\\n               mp[cards[e]]=e;\\n               s++;\\n             } \\n               e++;\\n            \\n   }\\n        if(flag==0)\\n            return -1;\\n        return result+1;\\n    }\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\'\\'\\'\\n\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        int s=0, e=0;\\n        int result=INT_MAX, pos, flag=0;\\n        unordered_map<int, int> mp;\\n        while(e<n)\\n        {\\n           if(mp.find(cards[e])==mp.end())\\n           {\\n               mp[cards[e]]=e;\\n           }\\n           else{\\n               flag=1;\\n               pos=e-mp[cards[e]];\\n               result=min(result, pos);\\n               mp.erase(cards[e]);\\n               mp[cards[e]]=e;\\n               s++;\\n             } \\n               e++;\\n            \\n   }\\n        if(flag==0)\\n            return -1;\\n        return result+1;\\n    }\\n\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2413375,
                "title": "python-6-line-solution",
                "content": "```\\ndef minimumCardPickup(self, nums: List[int]) -> int:\\n\\td, ans = {}, len(nums)+5\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] in d:\\n\\t\\t\\tans = min(ans, i-d[nums[i]]+1)\\n\\t\\td[nums[i]] = i\\n\\treturn -1 if ans>len(nums) else ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumCardPickup(self, nums: List[int]) -> int:\\n\\td, ans = {}, len(nums)+5\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] in d:\\n\\t\\t\\tans = min(ans, i-d[nums[i]]+1)\\n\\t\\td[nums[i]] = i\\n\\treturn -1 if ans>len(nums) else ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2369855,
                "title": "c-using-unorderedmap",
                "content": "class Solution {\\n# public:\\n    int minimumCardPickup(vector<int>& cards) {\\n      unordered_map<int,int>m;\\n        int i=0;\\n        int ans=INT_MAX;\\n        int j=0;\\n        while(j<cards.size()){\\n            m[cards[j]]++;\\n            if(m[cards[j]]==2){\\n                while(m[cards[j]]==2){\\n                    ans=min(ans,j-i+1);\\n                    m[cards[i]]--;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n# public:\\n    int minimumCardPickup(vector<int>& cards) {\\n      unordered_map<int,int>m;\\n        int i=0;\\n        int ans=INT_MAX;\\n        int j=0;\\n        while(j<cards.size()){\\n            m[cards[j]]++;\\n            if(m[cards[j]]==2){\\n                while(m[cards[j]]==2){\\n                    ans=min(ans,j-i+1);\\n                    m[cards[i]]--;\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2355987,
                "title": "c-solution-beats-100-straight-forward-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards)\\n    {\\n        unordered_map<int , int> m;\\n        int ans = INT_MAX,  j = 0;\\n        while(j < cards.size())\\n        {\\n            if(m.find(cards[j]) != m.end()) //if pair exist then keep record of min length btw them\\n                ans = min(ans , j - m[cards[j]] +1);\\n            m[cards[j]] = j;//it will automatically hold the closest index of the repeated element\\n            j++;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards)\\n    {\\n        unordered_map<int , int> m;\\n        int ans = INT_MAX,  j = 0;\\n        while(j < cards.size())\\n        {\\n            if(m.find(cards[j]) != m.end()) //if pair exist then keep record of min length btw them\\n                ans = min(ans , j - m[cards[j]] +1);\\n            m[cards[j]] = j;//it will automatically hold the closest index of the repeated element\\n            j++;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256825,
                "title": "sliding-window",
                "content": "using sliding window, basically iterating the array till the letters are distinct ans as soon as one letter is repeated then using sliding shrinking the window from the start of the array till the count of that element is 2 and then store the minimum count upto that point and then start expanding the window again.\\n```\\nint minimumCardPickup(vector<int>& cards) {\\n        \\n        int i=0;\\n        int j=0;\\n        int n=cards.size();\\n        int ans=n+1;\\n        unordered_map<int,int> mp;\\n        while(i<n){\\n            \\n          mp[cards[i]]++;\\n            if(mp[cards[i]]==2){\\n                \\n                while(mp[cards[i]]==2){\\n                    mp[cards[j]]--;\\n                    if(mp[cards[j]]==0){\\n                        mp.erase(cards[j]);\\n                    }\\n                    j++;\\n                }\\n           \\n               \\n                ans=min(ans,i-j+2);\\n            }\\n            i++;\\n            \\n        }\\n        if(ans==n+1){\\n            return -1;\\n        }\\n        return ans;\\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumCardPickup(vector<int>& cards) {\\n        \\n        int i=0;\\n        int j=0;\\n        int n=cards.size();\\n        int ans=n+1;\\n        unordered_map<int,int> mp;\\n        while(i<n){\\n            \\n          mp[cards[i]]++;\\n            if(mp[cards[i]]==2){\\n                \\n                while(mp[cards[i]]==2){\\n                    mp[cards[j]]--;\\n                    if(mp[cards[j]]==0){\\n                        mp.erase(cards[j]);\\n                    }\\n                    j++;\\n                }\\n           \\n               \\n                ans=min(ans,i-j+2);\\n            }\\n            i++;\\n            \\n        }\\n        if(ans==n+1){\\n            return -1;\\n        }\\n        return ans;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249156,
                "title": "java-haspmap",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        HashMap<Integer,Integer> hm  = new HashMap<>();\\n        int count=Integer.MAX_VALUE;\\n        int diff;\\n        for(int i=0;i<cards.length;i++){\\n           \\n            if(hm.containsKey(cards[i])){\\n                diff = (i-hm.get(cards[i])) +1;\\n                count = Math.min(count,diff);\\n            }\\n            hm.put(cards[i],i);\\n           \\n        }\\n        \\n        if(count ==0 || count == Integer.MAX_VALUE) return -1;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        HashMap<Integer,Integer> hm  = new HashMap<>();\\n        int count=Integer.MAX_VALUE;\\n        int diff;\\n        for(int i=0;i<cards.length;i++){\\n           \\n            if(hm.containsKey(cards[i])){\\n                diff = (i-hm.get(cards[i])) +1;\\n                count = Math.min(count,diff);\\n            }\\n            hm.put(cards[i],i);\\n           \\n        }\\n        \\n        if(count ==0 || count == Integer.MAX_VALUE) return -1;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193582,
                "title": "c-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int ans=INT_MAX;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<cards.size();i++){\\n            if(mp.find(cards[i])!=mp.end()){\\n                ans=min(ans,(i-mp[cards[i]]+1));\\n            }\\n            mp[cards[i]]=i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int ans=INT_MAX;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<cards.size();i++){\\n            if(mp.find(cards[i])!=mp.end()){\\n                ans=min(ans,(i-mp[cards[i]]+1));\\n            }\\n            mp[cards[i]]=i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190685,
                "title": "sliding-window-c-beginner-s-way",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int mini= INT_MAX;\\n        int n = cards.size();\\n        int start=0; int end=0;\\n        unordered_map<int,bool>m;\\n        for(end =0; end<n; end++){\\n         while(m[cards[end]]==true){\\n                mini=min(mini,end-start+1);\\n                m[cards[start++]]=false; \\n            }\\n            m[cards[end]]=true;\\n        }\\n        return mini==INT_MAX?-1:mini;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int mini= INT_MAX;\\n        int n = cards.size();\\n        int start=0; int end=0;\\n        unordered_map<int,bool>m;\\n        for(end =0; end<n; end++){\\n         while(m[cards[end]]==true){\\n                mini=min(mini,end-start+1);\\n                m[cards[start++]]=false; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2155924,
                "title": "using-unordered-map-sliding-window-o-n",
                "content": "```\\n int j=0;\\n        unordered_map<int,int>ans;\\n        int len=INT_MAX;\\n       for(int i=0;i<cards.size();i++){\\n            ans[cards[i]]++;\\n           if(ans[cards[i]]>1){\\n             len=min(len,i-j+1);\\n             while(j<i&&ans[cards[i]]>1){\\n                 ans[cards[j]]--;\\n                 if(ans[cards[j]]==0)  ans.erase(ans[cards[j]]);\\n                 j++;\\n             }\\n               len=min(len,i-j+2);\\n           }\\n        }\\n        return len==INT_MAX?-1:len;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int j=0;\\n        unordered_map<int,int>ans;\\n        int len=INT_MAX;\\n       for(int i=0;i<cards.size();i++){\\n            ans[cards[i]]++;\\n           if(ans[cards[i]]>1){\\n             len=min(len,i-j+1);\\n             while(j<i&&ans[cards[i]]>1){\\n                 ans[cards[j]]--;\\n                 if(ans[cards[j]]==0)  ans.erase(ans[cards[j]]);\\n                 j++;\\n             }\\n               len=min(len,i-j+2);\\n           }\\n        }\\n        return len==INT_MAX?-1:len;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2154350,
                "title": "c-sliding-windows-unordered-map",
                "content": "I used a sliding windows with 2 ptr and check in the hash table the number of occurence.\\n\\nC++\\n```\\nint minimumCardPickup(vector<int>& cards) {\\n        int l=0;\\n        int r=0;\\n        unordered_map<int,int> htable;\\n        int res=INT_MAX;\\n        while(r<cards.size()){\\n            htable[cards[r]]++;\\n            \\n            while(htable[cards[r]]>1){\\n                res=min(res,r-l+1);\\n                htable[cards[l]]--;\\n                l++;\\n            }\\n            r++;\\n        }\\n        \\n        return res==INT_MAX? -1 : res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumCardPickup(vector<int>& cards) {\\n        int l=0;\\n        int r=0;\\n        unordered_map<int,int> htable;\\n        int res=INT_MAX;\\n        while(r<cards.size()){\\n            htable[cards[r]]++;\\n            \\n            while(htable[cards[r]]>1){\\n                res=min(res,r-l+1);\\n                htable[cards[l]]--;\\n                l++;\\n            }\\n            r++;\\n        }\\n        \\n        return res==INT_MAX? -1 : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153169,
                "title": "simple-java-solution-using-hashmap",
                "content": "```\\npublic int minimumCardPickup(int[] cards) {\\n        int min = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int L=0, R=0; R< cards.length; R++){\\n            if(map.containsKey(cards[R])){\\n                min = Math.min(min, R- map.get(cards[R]) +1);\\n            }\\n            map.put(cards[R], R);\\n        }\\n        return min == Integer.MAX_VALUE ? -1: min;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int minimumCardPickup(int[] cards) {\\n        int min = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int L=0, R=0; R< cards.length; R++){\\n            if(map.containsKey(cards[R])){\\n                min = Math.min(min, R- map.get(cards[R]) +1);\\n            }\\n            map.put(cards[R], R);\\n        }\\n        return min == Integer.MAX_VALUE ? -1: min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2144162,
                "title": "c-94-faster-sliding-window-map-i-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int j=0,res=INT_MAX;\\n        int m[1000001];\\n        memset(m,0,sizeof(m));\\n        for(int i=0;i<cards.size();i++)\\n        {\\n            m[cards[i]]++;\\n            if(m[cards[i]]>1)\\n            {\\n                while(m[cards[i]]>1)\\n                    m[cards[j++]]--;\\n                res=min(res,i-j+2);\\n            }\\n        }\\n        if(res==INT_MAX)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int j=0,res=INT_MAX;\\n        int m[1000001];\\n        memset(m,0,sizeof(m));\\n        for(int i=0;i<cards.size();i++)\\n        {\\n            m[cards[i]]++;\\n            if(m[cards[i]]>1)\\n            {\\n                while(m[cards[i]]>1)\\n                    m[cards[j++]]--;\\n                res=min(res,i-j+2);\\n            }\\n        }\\n        if(res==INT_MAX)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140389,
                "title": "python-5-liner-time-complexity-o-n-and-aux-space-o-n",
                "content": "1. Data strucutures needed : One empty hashmap and numerical variable setted as infinity (as we need minimum value, set to -inf if maximum value is expected and compare accordingly)\\n2. Traverse over array :\\n\\ta. Check is same element exists in hashmap, if that exists then : get the range of cards needed for pair and compare with the recent pair sequence acquired in previous go through.\\n\\tb. save the minimum value of above case for further comparisons\\n2. Return -1 if the comparison value is infinity else, return the comparison value itself\\n\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        hashmap, no_of_cards = {}, inf``\\n        for  i in range(len(cards)):\\n            if cards[i] in hashmap: no_of_cards = min( i-hashmap[cards[i]] + 1, no_of_cards)\\n            hashmap[cards[i]] = i\\n        return -1 if no_of_cards == inf else no_of_cards\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        hashmap, no_of_cards = {}, inf``\\n        for  i in range(len(cards)):\\n            if cards[i] in hashmap: no_of_cards = min( i-hashmap[cards[i]] + 1, no_of_cards)\\n            hashmap[cards[i]] = i\\n        return -1 if no_of_cards == inf else no_of_cards\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127376,
                "title": "simple-c-approach-without-any-sliding-window-hassle-100-faster-10-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int i=0,n=cards.size();\\n        unordered_map<int,int> m;\\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++) {\\n            if(m.find(cards[i])!=m.end()) {\\n                res = min(res,i+1-m[cards[i]]);\\n                m[cards[i]]=i;\\n            } else {\\n                m[cards[i]]=i;\\n            }\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int i=0,n=cards.size();\\n        unordered_map<int,int> m;\\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++) {\\n            if(m.find(cards[i])!=m.end()) {\\n                res = min(res,i+1-m[cards[i]]);\\n                m[cards[i]]=i;\\n            } else {\\n                m[cards[i]]=i;\\n            }\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096108,
                "title": "python-sliding-window",
                "content": "We can use brute force to find every possible subsequence, confirm if subsequence contains a pair, then update the minimum size.\\n\\nOr we can use a standard sliding window technique to solve.\\nWe grow the window until a pair is found. While a pair is found within the window, shrink the window to find a more minimal solution.\\nTime: O(n)\\nSpace: O(n)\\n\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        \\'\\'\\'\\n            input\\n                cards - list of integers\\n                    cannot be empty\\n                    values are 0 or positive\\n            output\\n                integer - \\n                    min # of cards with a pair\\n                    or -1\\n            constraints\\n                must be a consecutive subarray sequence\\n            \\n            Time: O(n^3) brute force\\n                o(n^2) for nested for loops\\n                    o(n) to verify if a pair is in sequence\\n            space: o(1)\\n            can find all possible sequences\\n                update the minimum if a pair is found\\n            \\n            Time: O(n)\\n            Space: O(n)\\n                hash map can potentially store entire cards array\\n            lots of repeated work\\n            use a sliding window \\n            use a hash map to keep track of cards found\\n            extend the window until a pair is found\\n                shrink the window while pair is found\\n                    try and find a more minimal solution and update\\n            return min size or -1\\n        \\'\\'\\'\\n        \\n        res = float(\\'inf\\')\\n        start = 0\\n        memo = {}\\n        for end, card in enumerate(cards):\\n            memo[card] = memo.get(card, 0) + 1\\n            \\n            # Pair is found. Shrink the window to find a more minimal solution.\\n            while memo[card] >= 2:\\n                res = min(res, end - start + 1)\\n                memo[cards[start]] -= 1\\n                start += 1\\n                \\n        return res if res != float(\\'inf\\') else -1",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        \\'\\'\\'\\n            input\\n                cards - list of integers\\n                    cannot be empty\\n                    values are 0 or positive\\n            output\\n                integer - \\n                    min # of cards with a pair\\n                    or -1\\n            constraints\\n                must be a consecutive subarray sequence\\n            \\n            Time: O(n^3) brute force\\n                o(n^2) for nested for loops\\n                    o(n) to verify if a pair is in sequence\\n            space: o(1)\\n            can find all possible sequences\\n                update the minimum if a pair is found\\n            \\n            Time: O(n)\\n            Space: O(n)\\n                hash map can potentially store entire cards array\\n            lots of repeated work\\n            use a sliding window \\n            use a hash map to keep track of cards found\\n            extend the window until a pair is found\\n                shrink the window while pair is found\\n                    try and find a more minimal solution and update\\n            return min size or -1\\n        \\'\\'\\'\\n        \\n        res = float(\\'inf\\')\\n        start = 0\\n        memo = {}",
                "codeTag": "Java"
            },
            {
                "id": 2081169,
                "title": "golang-o-n-with-explanation",
                "content": "```golang\\n// min returns minimum of two integers.\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc minimumCardPickup(cards []int) int {\\n\\t// Keep track of last index of the same value.\\n    firstIdx := make(map[int]int)\\n\\n\\tdistance := math.MaxInt\\n    for i, card := range cards {\\n        prevIdx, ok := firstIdx[card]\\n        if ok {\\n\\t\\t\\t// Calculate distance between current card and when we saw it last.\\n            distance = min(distance, i - prevIdx + 1)\\n        }\\n\\t\\t// Always update the indices for cases where we might see duplicates.\\n        firstIdx[card] = i\\n    }\\n    if distance == math.MaxInt {\\n        return -1\\n    }\\n    return distance\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\n// min returns minimum of two integers.\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc minimumCardPickup(cards []int) int {\\n\\t// Keep track of last index of the same value.\\n    firstIdx := make(map[int]int)\\n\\n\\tdistance := math.MaxInt\\n    for i, card := range cards {\\n        prevIdx, ok := firstIdx[card]\\n        if ok {\\n\\t\\t\\t// Calculate distance between current card and when we saw it last.\\n            distance = min(distance, i - prevIdx + 1)\\n        }\\n\\t\\t// Always update the indices for cases where we might see duplicates.\\n        firstIdx[card] = i\\n    }\\n    if distance == math.MaxInt {\\n        return -1\\n    }\\n    return distance\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2066070,
                "title": "c-easy-implementation-explanation-with-comments-o-n-solution",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) \\n    {\\n        // created a visited vector that will store the visited values\\n        vector<int> visited(1e6+1, -1);\\n        \\n        // it will store the minimum  consecutive cards\\n        int mn = INT_MAX;\\n        \\n        // iterate over the cards\\n        for(int i=0; i<cards.size(); i++)\\n        {\\n            // if current value is already visited it means there is second occurance of same value\\n            // and it may be our answer so we will check for minimum and store the size of consecutive value\\n            if(visited[cards[i]] != -1)\\n            {   \\n                mn  = min(mn, i- visited[cards[i]]+1);                     // (i=right_pointer - visited[cards[i]]=left_pointer) +2 because (0 base indexing)\\n            }\\n           \\n            // mark the current value as visited instead of -1\\n            visited[cards[i]] = i;\\n        }\\n        \\n        // if mn value is still max then there is no consecutive value so return -1 else return mn value that we founded\\n        return mn==INT_MAX ? -1 : mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) \\n    {\\n        // created a visited vector that will store the visited values\\n        vector<int> visited(1e6+1, -1);\\n        \\n        // it will store the minimum  consecutive cards\\n        int mn = INT_MAX;\\n        \\n        // iterate over the cards\\n        for(int i=0; i<cards.size(); i++)\\n        {\\n            // if current value is already visited it means there is second occurance of same value\\n            // and it may be our answer so we will check for minimum and store the size of consecutive value\\n            if(visited[cards[i]] != -1)\\n            {   \\n                mn  = min(mn, i- visited[cards[i]]+1);                     // (i=right_pointer - visited[cards[i]]=left_pointer) +2 because (0 base indexing)\\n            }\\n           \\n            // mark the current value as visited instead of -1\\n            visited[cards[i]] = i;\\n        }\\n        \\n        // if mn value is still max then there is no consecutive value so return -1 else return mn value that we founded\\n        return mn==INT_MAX ? -1 : mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065538,
                "title": "easy-cpp-solution-hash-map",
                "content": "```\\n if(cards.size()==1)\\n        {\\n            return -1;\\n        }\\n        int count=0,res=INT_MAX;\\n        unordered_map<int,int>m;\\n        unordered_map<int,int>::iterator it;\\n        for(int i=0;i<cards.size();i++)\\n        {\\n            it=m.find(cards[i]);\\n            if(it!=m.end())\\n            {\\n                count=(i-it->second)+1;\\n                res=min(count,res);\\n                count=1;\\n                m.erase(it->first);\\n            }\\n            m[cards[i]]=i;\\n        }\\n        if(res==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return res;\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n if(cards.size()==1)\\n        {\\n            return -1;\\n        }\\n        int count=0,res=INT_MAX;\\n        unordered_map<int,int>m;\\n        unordered_map<int,int>::iterator it;\\n        for(int i=0;i<cards.size();i++)\\n        {\\n            it=m.find(cards[i]);\\n            if(it!=m.end())\\n            {\\n                count=(i-it->second)+1;\\n                res=min(count,res);\\n                count=1;\\n                m.erase(it->first);\\n            }\\n            m[cards[i]]=i;\\n        }\\n        if(res==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return res;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064349,
                "title": "c-keep-track-of-last-occurence-of-the-card",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) \\n    {\\n        vector<int> occur(1e6+1, -1);\\n        int mn = INT_MAX;\\n        for(int i=0; i<cards.size(); i++){\\n            if(occur[cards[i]] != -1){   //element occuring more than one time\\n                mn  = min(mn, i- occur[cards[i]]+1);\\n           }\\n           \\n           occur[cards[i]] = i;\\n       }\\n        \\n        return mn==INT_MAX ? -1 : mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) \\n    {\\n        vector<int> occur(1e6+1, -1);\\n        int mn = INT_MAX;\\n        for(int i=0; i<cards.size(); i++){\\n            if(occur[cards[i]] != -1){   //element occuring more than one time\\n                mn  = min(mn, i- occur[cards[i]]+1);\\n           }\\n           \\n           occur[cards[i]] = i;\\n       }\\n        \\n        return mn==INT_MAX ? -1 : mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045662,
                "title": "cpp-map-slidingwindow-aditya-verma",
                "content": "```\\nint minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int, int> umap;\\n        int i=0, j=0;\\n        int count = 0, mini = INT_MAX;\\n        while(j < cards.size()){\\n            //calculations\\n            umap[cards[j]]++;\\n            if(umap[cards[j]] > 1) count++;\\n            if(count < 1) j++;\\n            else if(count >= 1){\\n                while(count >= 1){\\n                    //remove calculations for i\\n                    mini = min(mini, j-i+1);\\n                    umap[cards[i]]--;\\n                    if(umap[cards[i]]==1) count--;\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return mini==INT_MAX?-1:mini;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int, int> umap;\\n        int i=0, j=0;\\n        int count = 0, mini = INT_MAX;\\n        while(j < cards.size()){\\n            //calculations\\n            umap[cards[j]]++;\\n            if(umap[cards[j]] > 1) count++;\\n            if(count < 1) j++;\\n            else if(count >= 1){\\n                while(count >= 1){\\n                    //remove calculations for i\\n                    mini = min(mini, j-i+1);\\n                    umap[cards[i]]--;\\n                    if(umap[cards[i]]==1) count--;\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return mini==INT_MAX?-1:mini;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045170,
                "title": "c-solution-hashmap-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int> um; // we store cards previous index in map\\n        int n=cards.size();\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int c=cards[i];\\n            if(um.count(c)>0){ // if we have seen that card already\\n                ans=min(ans,abs(i-um[c]+1)); //then update ans as minimum of\\n\\t\\t\\t\\t// ans and (current_position-prev_position+1) \\n            }\\n            um[c]=i; // update that card position to current index\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int> um; // we store cards previous index in map\\n        int n=cards.size();\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int c=cards[i];\\n            if(um.count(c)>0){ // if we have seen that card already\\n                ans=min(ans,abs(i-um[c]+1)); //then update ans as minimum of\\n\\t\\t\\t\\t// ans and (current_position-prev_position+1) \\n            }\\n            um[c]=i; // update that card position to current index\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017259,
                "title": "python-use-hashmap-to-track-last-o-n",
                "content": "```\\nclass Solution:\\n    # O(n), hashmap\\n    # Use hashmap to keep track of the last index of each value\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d = {}\\n        mini = float(\\'inf\\')\\n        for index, value in enumerate(cards):\\n            if value not in d:\\n                d[value] = index\\n            else:\\n                mini = min(mini, index - d[value] + 1)\\n                d[value] = index\\n        return mini if mini != float(\\'inf\\') else -1    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    # O(n), hashmap\\n    # Use hashmap to keep track of the last index of each value\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d = {}\\n        mini = float(\\'inf\\')\\n        for index, value in enumerate(cards):\\n            if value not in d:\\n                d[value] = index\\n            else:\\n                mini = min(mini, index - d[value] + 1)\\n                d[value] = index\\n        return mini if mini != float(\\'inf\\') else -1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015328,
                "title": "javascript-hashmap-easy-o-n-311ms",
                "content": "```\\nvar minimumCardPickup = function(cards) {\\n    let cardsSeen = {};\\n    let minPicks = Infinity;\\n    for (let i = 0; i < cards.length; i++) {\\n        if (!(cards[i] in cardsSeen)) {\\n            cardsSeen[cards[i]] = i;\\n        } else {\\n            const temp = i - cardsSeen[cards[i]] + 1;\\n            minPicks = Math.min(minPicks, temp);\\n            cardsSeen[cards[i]] = i;\\n        }\\n    }\\n    return minPicks === Infinity ? -1 : minPicks;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumCardPickup = function(cards) {\\n    let cardsSeen = {};\\n    let minPicks = Infinity;\\n    for (let i = 0; i < cards.length; i++) {\\n        if (!(cards[i] in cardsSeen)) {\\n            cardsSeen[cards[i]] = i;\\n        } else {\\n            const temp = i - cardsSeen[cards[i]] + 1;\\n            minPicks = Math.min(minPicks, temp);\\n            cardsSeen[cards[i]] = i;\\n        }\\n    }\\n    return minPicks === Infinity ? -1 : minPicks;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001308,
                "title": "simple-sliding-window-with-unordered-map-solution-self-intuitive",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>mp;\\n        int n=cards.size();\\n        int i=0,j=0,res=INT_MAX;\\n        while(j<n){\\n            if(mp.count(cards[j])!=0){\\n                i=mp[cards[j]];                    \\n                res=res>j-i+1?j-i+1:res;\\n                     i++;\\n                     }\\n                     mp[cards[j]]=j;\\n                     j++;\\n        }\\n        if(res==INT_MAX)return -1;\\n                     return res;\\n    }\\n                     \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>mp;\\n        int n=cards.size();\\n        int i=0,j=0,res=INT_MAX;\\n        while(j<n){\\n            if(mp.count(cards[j])!=0){\\n                i=mp[cards[j]];                    \\n                res=res>j-i+1?j-i+1:res;\\n                     i++;\\n                     }\\n                     mp[cards[j]]=j;\\n                     j++;\\n        }\\n        if(res==INT_MAX)return -1;\\n                     return res;\\n    }\\n                     \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001017,
                "title": "c-2-map-approach",
                "content": "```\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int, int> index, number;\\n        \\n        for(int i = 0; i < cards.size(); i++) {\\n            if(index.find(cards[i]) == index.end()) {\\n                index[cards[i]] = i;\\n                number[cards[i]] = INT_MAX;\\n            } else {\\n                int consecutiveCards = i - index[cards[i]];\\n                number[cards[i]] = min(consecutiveCards, number[cards[i]]);\\n                index[cards[i]] = i;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(auto it: number) {\\n            ans = min(ans, it.second);\\n        }\\n        return ans == INT_MAX ? -1 : ans + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int, int> index, number;\\n        \\n        for(int i = 0; i < cards.size(); i++) {\\n            if(index.find(cards[i]) == index.end()) {\\n                index[cards[i]] = i;\\n                number[cards[i]] = INT_MAX;\\n            } else {\\n                int consecutiveCards = i - index[cards[i]];\\n                number[cards[i]] = min(consecutiveCards, number[cards[i]]);\\n                index[cards[i]] = i;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(auto it: number) {\\n            ans = min(ans, it.second);\\n        }\\n        return ans == INT_MAX ? -1 : ans + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1999128,
                "title": "clean-java-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        // Map or array to store the last index of the number\\n        int index[] = new int[1000001];\\n        //Pre-fill to check if values for the card is present while iterating\\n        Arrays.fill(index,-1);\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<cards.length;i++){\\n            //Getting minimum distance between last filled and the current in case of reoccurence\\n            if(index[cards[i]]!=-1) ans = Math.min(ans,i-index[cards[i]]);\\n            index[cards[i]] = i;\\n        }\\n        // Add 1 to count the present card as well\\n        return ans==Integer.MAX_VALUE?-1:ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        // Map or array to store the last index of the number\\n        int index[] = new int[1000001];\\n        //Pre-fill to check if values for the card is present while iterating\\n        Arrays.fill(index,-1);\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<cards.length;i++){\\n            //Getting minimum distance between last filled and the current in case of reoccurence\\n            if(index[cards[i]]!=-1) ans = Math.min(ans,i-index[cards[i]]);\\n            index[cards[i]] = i;\\n        }\\n        // Add 1 to count the present card as well\\n        return ans==Integer.MAX_VALUE?-1:ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998798,
                "title": "cpp-general-sliding-window-approach",
                "content": "Sliding window approach which can be generalized. We can use any number isntead of 2, and pass it to the functions as argument. \\n```\\nint minimumCardPickup(vector<int>& cards) {\\n\\tint left = 0, right = 0, res = INT_MAX;\\n\\tunordered_map<int, int> hmap;\\n\\tfor (right = 0; right < cards.size(); right++) {\\n\\t\\tif (++hmap[cards[right]] >= 2) {\\n\\t\\t\\twhile (hmap[cards[right]] >= 2) {\\n\\t\\t\\t\\tif ((cards[left] != cards[right]) \\n\\t\\t\\t\\t\\t|| hmap[cards[left]] > 2) hmap[cards[left++]]--;\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\tres = min(res, right - left + 1);\\n\\t\\t}\\n\\t}\\n\\treturn res == INT_MAX ? -1 : res;\\n}\\n```\\nWhich of course can be simplified to:\\n```\\nint minimumCardPickup(vector<int>& cards) {\\n\\tint left = 0, right = 0, res = INT_MAX;\\n\\tunordered_map<int, int> hmap;\\n\\tfor (right = 0; right < cards.size(); right++) {\\n\\t\\tif (hmap.count(cards[right])) res = min(res, right - hmap[cards[right]] + 1);\\n\\t\\thmap[cards[right]] = right;\\n\\t}\\n\\treturn res == INT_MAX ? -1 : res;\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimumCardPickup(vector<int>& cards) {\\n\\tint left = 0, right = 0, res = INT_MAX;\\n\\tunordered_map<int, int> hmap;\\n\\tfor (right = 0; right < cards.size(); right++) {\\n\\t\\tif (++hmap[cards[right]] >= 2) {\\n\\t\\t\\twhile (hmap[cards[right]] >= 2) {\\n\\t\\t\\t\\tif ((cards[left] != cards[right]) \\n\\t\\t\\t\\t\\t|| hmap[cards[left]] > 2) hmap[cards[left++]]--;\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\tres = min(res, right - left + 1);\\n\\t\\t}\\n\\t}\\n\\treturn res == INT_MAX ? -1 : res;\\n}\\n```\n```\\nint minimumCardPickup(vector<int>& cards) {\\n\\tint left = 0, right = 0, res = INT_MAX;\\n\\tunordered_map<int, int> hmap;\\n\\tfor (right = 0; right < cards.size(); right++) {\\n\\t\\tif (hmap.count(cards[right])) res = min(res, right - hmap[cards[right]] + 1);\\n\\t\\thmap[cards[right]] = right;\\n\\t}\\n\\treturn res == INT_MAX ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1998652,
                "title": "c-unordered-map-linear-time",
                "content": "* Traverse the array while storing the index of the array elements in an unordered_map.\\n* If you encounter any element while traversing that is already present in the unordered_map calculate the difference between their indexes and update the index of the current duplicate element in the hashmap too so that if there is any other duplicate element like the current element after current location we can calculate their location difference too.\\n* Like this traverse the whole array and we will receive minimum distance in the end.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int, int> index;\\n        int minDist = cards.size()+1;\\n        for(int i=0; i<cards.size(); i++){\\n            if(index.find(cards[i]) != index.end()){\\n                minDist = min(minDist, i-index[cards[i]]+1);\\n            }\\n            index[cards[i]] = i;      \\n        }\\n        return minDist > cards.size() ? -1 : minDist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int, int> index;\\n        int minDist = cards.size()+1;\\n        for(int i=0; i<cards.size(); i++){\\n            if(index.find(cards[i]) != index.end()){\\n                minDist = min(minDist, i-index[cards[i]]+1);\\n            }\\n            index[cards[i]] = i;      \\n        }\\n        return minDist > cards.size() ? -1 : minDist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998026,
                "title": "map-c-few-liners",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& arr) {\\n        map<int,int>mp;\\n        int ans=INT_MAX;\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.find(arr[i])!=mp.end()){\\n                ans=min(ans,i-mp[arr[i]]+1);\\n            }\\n            mp[arr[i]]=i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& arr) {\\n        map<int,int>mp;\\n        int ans=INT_MAX;\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.find(arr[i])!=mp.end()){\\n                ans=min(ans,i-mp[arr[i]]+1);\\n            }\\n            mp[arr[i]]=i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997776,
                "title": "simple-c-solution-5-lines-of-code-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        vector<int> deck(1000007,-1);\\n        int cnt=INT_MAX;\\n        for(int i=0; i<cards.size(); i++) {\\n             if(deck[cards[i]]!=-1) cnt=min(cnt,i-deck[cards[i]]+1);\\n             deck[cards[i]]=i;\\n        }\\n       return cnt == INT_MAX ? -1 : cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        vector<int> deck(1000007,-1);\\n        int cnt=INT_MAX;\\n        for(int i=0; i<cards.size(); i++) {\\n             if(deck[cards[i]]!=-1) cnt=min(cnt,i-deck[cards[i]]+1);\\n             deck[cards[i]]=i;\\n        }\\n       return cnt == INT_MAX ? -1 : cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996929,
                "title": "java-binary-search-on-ans-hashset-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] a) \\n    {\\n        \\n        int n=a.length;\\n        \\n        //Range our our ans will be between 2 to number of elements in the array\\n        int start=2; \\n        int end=n;\\n        \\n        int ans=-1;\\n        \\n        //Binary search on ans\\n        while(start<=end)\\n        {\\n            //lets assume we need to pick mid num of cards to get ATLEAST two cards with same number\\n            int mid=start+(end-start)/2;\\n            \\n            \\n            //if it is possible to do the above task then our assumed min might be the ans or maybe there is some number               lesser than mid\\n            if(isPossible(a,mid,n))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            \\n            else\\n            start=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int a[],int size,int n)\\n    {\\n        Set<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<size;i++)\\n        {\\n            if(set.contains(a[i]))\\n            return true;\\n            \\n            set.add(a[i]);\\n        }\\n        \\n        int j=0;\\n        for(int i=size;i<n;i++)\\n        {\\n            set.remove(a[j]);\\n            \\n            if(set.contains(a[i]))\\n            return true;\\n            \\n            set.add(a[i]);\\n            j++;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] a) \\n    {\\n        \\n        int n=a.length;\\n        \\n        //Range our our ans will be between 2 to number of elements in the array\\n        int start=2; \\n        int end=n;\\n        \\n        int ans=-1;\\n        \\n        //Binary search on ans\\n        while(start<=end)\\n        {\\n            //lets assume we need to pick mid num of cards to get ATLEAST two cards with same number\\n            int mid=start+(end-start)/2;\\n            \\n            \\n            //if it is possible to do the above task then our assumed min might be the ans or maybe there is some number               lesser than mid\\n            if(isPossible(a,mid,n))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            \\n            else\\n            start=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int a[],int size,int n)\\n    {\\n        Set<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<size;i++)\\n        {\\n            if(set.contains(a[i]))\\n            return true;\\n            \\n            set.add(a[i]);\\n        }\\n        \\n        int j=0;\\n        for(int i=size;i<n;i++)\\n        {\\n            set.remove(a[j]);\\n            \\n            if(set.contains(a[i]))\\n            return true;\\n            \\n            set.add(a[i]);\\n            j++;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996908,
                "title": "java-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int min = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<cards.length; i++) {\\n            if(map.containsKey(cards[i]))\\n                min = Math.min(min, i - map.get(cards[i]) + 1); \\n            map.put(cards[i], i);\\n        }\\n        \\n        return min == Integer.MAX_VALUE? -1: min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int min = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<cards.length; i++) {\\n            if(map.containsKey(cards[i]))\\n                min = Math.min(min, i - map.get(cards[i]) + 1); \\n            map.put(cards[i], i);\\n        }\\n        \\n        return min == Integer.MAX_VALUE? -1: min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996877,
                "title": "easy-binary-search-solution-nlogn",
                "content": "If you have ans for length x , then you can go to check if any value lower than x can be our ans or not !\\nRight , this sounds like binary search right ?\\n\\n```\\nint minimumCardPickup(vector<int>& c) {\\n        \\n        auto canbe = [&](int x) -> bool {\\n            const int siz =1e6 + 5 ; \\n            int fq[siz] = {0} ; \\n            for(int i = 0 ; i<sz(c) ; i++){\\n                fq[c[i]]++ ;\\n                if(i >= x) fq[c[i - x]]-- ;\\n                if(fq[c[i]] == 2) return true ;\\n            }\\n            return false ; \\n        } ; \\n        \\n        int ans = -1; \\n        int l = 2 , h = sz(c) ; \\n        while(l <= h){\\n            int mid = (l + h)/2 ; \\n            if(canbe(mid)){\\n                ans = mid ; \\n                h = mid - 1 ; \\n            }else l = mid + 1 ; \\n        }\\n        return ans ; \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint minimumCardPickup(vector<int>& c) {\\n        \\n        auto canbe = [&](int x) -> bool {\\n            const int siz =1e6 + 5 ; \\n            int fq[siz] = {0} ; \\n            for(int i = 0 ; i<sz(c) ; i++){\\n                fq[c[i]]++ ;\\n                if(i >= x) fq[c[i - x]]-- ;\\n                if(fq[c[i]] == 2) return true ;\\n            }\\n            return false ; \\n        } ; \\n        \\n        int ans = -1; \\n        int l = 2 , h = sz(c) ; \\n        while(l <= h){\\n            int mid = (l + h)/2 ; \\n            if(canbe(mid)){\\n                ans = mid ; \\n                h = mid - 1 ; \\n            }else l = mid + 1 ; \\n        }\\n        return ans ; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996822,
                "title": "python-easy-hash-solution",
                "content": "Runtime: 1090 ms, faster than 42.86% of Python3 online submissions for Minimum Consecutive Cards to Pick Up.\\nMemory Usage: 33.9 MB, less than 14.29% of Python3 online submissions for Minimum Consecutive Cards to Pick Up.\\n```\\nclass Solution:\\n  def minimumCardPickup(self, cards: List[int]) -> int:\\n    table = dict()      \\n    answer = len(cards)\\n    \\n    for i in range (len(cards)) :\\n      if cards[i] in table :\\n        answer = min(answer, i - table[cards[i]])\\n      table[cards[i]] = i\\n      \\n    if answer == len(cards) : answer = -2\\n    \\n    return answer + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def minimumCardPickup(self, cards: List[int]) -> int:\\n    table = dict()      \\n    answer = len(cards)\\n    \\n    for i in range (len(cards)) :\\n      if cards[i] in table :\\n        answer = min(answer, i - table[cards[i]])\\n      table[cards[i]] = i\\n      \\n    if answer == len(cards) : answer = -2\\n    \\n    return answer + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996713,
                "title": "track-last-occurence-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int len = (int)1e9;\\n        for(int i=0;i<cards.length;i++){\\n            if(map.containsKey(cards[i])){\\n                 int first = map.get(cards[i]);\\n                 int second = i;\\n                 len = Math.min(len,second-first+1);\\n                 map.put(cards[i],second);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        return len == 1e9 ? -1 : len; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int len = (int)1e9;\\n        for(int i=0;i<cards.length;i++){\\n            if(map.containsKey(cards[i])){\\n                 int first = map.get(cards[i]);\\n                 int second = i;\\n                 len = Math.min(len,second-first+1);\\n                 map.put(cards[i],second);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        return len == 1e9 ? -1 : len; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996655,
                "title": "sliding-window-technique-java-hashset",
                "content": "**// Here problem was solved by using sliding window technique\\n// 2 pointer approach was used here\\n// concept of expansion and contraction\\n// expansion in simply move towards right side of array ( below j ptr is used for expansion )\\n// contraction means ignore left side of array (below i ptr is used for contraction )\\n// Time Complexity - O(2N) - O(N)\\n// Auxilary space Complexity - O(N) **\\n\\n```\\npublic int minimumCardPickup(int[] cards) {\\n        \\n        int ans = Integer.MAX_VALUE;\\n        int i = 0;\\n        int j = 0;\\n        \\n        int n = cards.length;\\n        \\n\\t\\t// store cards element in set \\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        \\n        while(j < n)\\n        {\\n\\t\\t   // insert j\\'th element in set\\n            set.add(cards[j]);\\n            \\n\\t\\t\\t// if any point where set is failed to insert j\\'th element in set \\n\\t\\t\\t// means j\\'th element alread exist in set\\n\\t\\t\\t// we\\'ve checking this using size of set and (pointers values i , j)\\n\\t\\t\\t\\n            if(set.size() != (j - i + 1))\\n            {\\n\\t\\t\\t\\t//may be some points where j\\'th index element is not same as i\\'th index element\\n\\t\\t\\t\\t// in this case we have to used contraction (take i at position where cards[i] == cards[j])\\n\\t\\t\\t\\t\\n                while(cards[i] != cards[j] )\\n                {\\n\\t\\t\\t\\t\\t// remove left side elements of cards of i\\n                    set.remove(cards[i]);\\n                    i++;\\n                }\\n                \\n\\t\\t\\t\\t// if current pointers denoting the value less than prev ans \\n                ans = ans > (j - i + 1) ? (j - i + 1) : ans;\\n                \\n\\t\\t\\t\\t// now remove i\\'th element also because we now have to move to the next windows\\n                set.remove(cards[i]);\\n                i++;\\n                \\n\\t\\t\\t\\t// add j\\'th element in set \\n                set.add(cards[j]);\\n              \\n            }\\n            \\n            j++;                            \\n\\n        }\\n        \\n\\t\\t// if ( cards does not contain duplicates )\\n        if(j - i == n) return -1;\\n        \\n\\t\\t// else return our calculated ans\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int minimumCardPickup(int[] cards) {\\n        \\n        int ans = Integer.MAX_VALUE;\\n        int i = 0;\\n        int j = 0;\\n        \\n        int n = cards.length;\\n        \\n\\t\\t// store cards element in set \\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        \\n        while(j < n)\\n        {\\n\\t\\t   // insert j\\'th element in set\\n            set.add(cards[j]);\\n            \\n\\t\\t\\t// if any point where set is failed to insert j\\'th element in set \\n\\t\\t\\t// means j\\'th element alread exist in set\\n\\t\\t\\t// we\\'ve checking this using size of set and (pointers values i , j)\\n\\t\\t\\t\\n            if(set.size() != (j - i + 1))\\n            {\\n\\t\\t\\t\\t//may be some points where j\\'th index element is not same as i\\'th index element\\n\\t\\t\\t\\t// in this case we have to used contraction (take i at position where cards[i] == cards[j])\\n\\t\\t\\t\\t\\n                while(cards[i] != cards[j] )\\n                {\\n\\t\\t\\t\\t\\t// remove left side elements of cards of i\\n                    set.remove(cards[i]);\\n                    i++;\\n                }\\n                \\n\\t\\t\\t\\t// if current pointers denoting the value less than prev ans \\n                ans = ans > (j - i + 1) ? (j - i + 1) : ans;\\n                \\n\\t\\t\\t\\t// now remove i\\'th element also because we now have to move to the next windows\\n                set.remove(cards[i]);\\n                i++;\\n                \\n\\t\\t\\t\\t// add j\\'th element in set \\n                set.add(cards[j]);\\n              \\n            }\\n            \\n            j++;                            \\n\\n        }\\n        \\n\\t\\t// if ( cards does not contain duplicates )\\n        if(j - i == n) return -1;\\n        \\n\\t\\t// else return our calculated ans\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996629,
                "title": "c-solution-easy-to-understand-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        vector<int>temp;\\n        for(auto i:cards){\\n            temp.push_back(i);\\n        }\\n        bool c = false;\\n        sort(temp.begin(),temp.end());\\n        for(int i=1;i<temp.size();i++){\\n            if(temp[i-1]==temp[i])\\n                c = true;\\n        }\\n        if(c==false){\\n            return -1;\\n        }\\n        unordered_map<int,int>mp;\\n        int ans=-1;\\n        for(int i=0;i<cards.size();i++){\\n            if(mp.find(cards[i])==mp.end())\\n                mp[cards[i]]=i;\\n            else{\\n                int temp = i-mp[cards[i]];\\n                mp[cards[i]]=i;\\n                if(temp<ans || ans==-1){\\n                    ans = temp;\\n                }\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        vector<int>temp;\\n        for(auto i:cards){\\n            temp.push_back(i);\\n        }\\n        bool c = false;\\n        sort(temp.begin(),temp.end());\\n        for(int i=1;i<temp.size();i++){\\n            if(temp[i-1]==temp[i])\\n                c = true;\\n        }\\n        if(c==false){\\n            return -1;\\n        }\\n        unordered_map<int,int>mp;\\n        int ans=-1;\\n        for(int i=0;i<cards.size();i++){\\n            if(mp.find(cards[i])==mp.end())\\n                mp[cards[i]]=i;\\n            else{\\n                int temp = i-mp[cards[i]];\\n                mp[cards[i]]=i;\\n                if(temp<ans || ans==-1){\\n                    ans = temp;\\n                }\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996504,
                "title": "intuition-explained-map-c-simple-solution",
                "content": "* We traverse the array and keep on adding the index of elements into the map\\n* if the element is already present in the map:\\n\\t* we store currLen = currIndex - prevIndex or minLen = currIndex - map[cards[i]]\\n\\t* update the index minLen with minimum of currLen and minLen\\n\\t* update the index of current element in the map\\n\\t\\nAnd we are all set to go! \\uD83D\\uDE0A\\u2728\\n```\\nint minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size();\\n        int minLen = 1000001, currLen;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(mp.find(cards[i]) != mp.end())\\n            {\\n                currLen = i - mp[cards[i]];\\n                minLen = min(currLen, minLen);\\n            }\\n            mp[cards[i]] = i;\\n        }\\n        if(minLen != 1000001) return minLen+1;\\n        return -1;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size();\\n        int minLen = 1000001, currLen;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(mp.find(cards[i]) != mp.end())\\n            {\\n                currLen = i - mp[cards[i]];\\n                minLen = min(currLen, minLen);\\n            }\\n            mp[cards[i]] = i;\\n        }\\n        if(minLen != 1000001) return minLen+1;\\n        return -1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996492,
                "title": "python3-dictionary",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d={}\\n        n=len(cards)\\n        answ=10**6\\n        for i in range(n):\\n            card=cards[i]\\n            if card in d:\\n                answ=min(answ,i-d[card]+1)\\n            d[card]=i\\n        if n<answ:\\n            answ=-1\\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        d={}\\n        n=len(cards)\\n        answ=10**6\\n        for i in range(n):\\n            card=cards[i]\\n            if card in d:\\n                answ=min(answ,i-d[card]+1)\\n            d[card]=i\\n        if n<answ:\\n            answ=-1\\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996396,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nint minimumCardPickup(vector<int>& cards) \\n    {\\n        unordered_map<int,int>m;\\n        \\n        int ma=INT_MAX;\\n        \\n        for(int i=0;i<cards.size();i++)\\n        {\\n            if(m.find(cards[i])!=m.end())\\n            {\\n                ma=min(ma,i-m[cards[i]]+1);\\n                m[cards[i]]=i;\\n            }\\n            else\\n            {\\n                m[cards[i]]=i;\\n            }\\n        }\\n        \\n        if(ma==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return ma;\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\nint minimumCardPickup(vector<int>& cards) \\n    {\\n        unordered_map<int,int>m;\\n        \\n        int ma=INT_MAX;\\n        \\n        for(int i=0;i<cards.size();i++)\\n        {\\n            if(m.find(cards[i])!=m.end())\\n            {\\n                ma=min(ma,i-m[cards[i]]+1);\\n                m[cards[i]]=i;\\n            }\\n            else\\n            {\\n                m[cards[i]]=i;\\n            }\\n        }\\n        \\n        if(ma==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return ma;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1996391,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        set<int> s;\\n        map<int,int> m;\\n        \\n        int n=cards.size();\\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=cards[i];\\n            \\n            if(s.find(x)==s.end())\\n            {\\n                s.insert(x);\\n                m[x]=i;\\n            }\\n            else\\n            {\\n                res=min(res,i-m[x]+1);\\n                m[x]=i;\\n            }\\n        }\\n        if(res==INT_MAX) return -1;\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        set<int> s;\\n        map<int,int> m;\\n        \\n        int n=cards.size();\\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=cards[i];\\n            \\n            if(s.find(x)==s.end())\\n            {\\n                s.insert(x);\\n                m[x]=i;\\n            }\\n            else\\n            {\\n                res=min(res,i-m[x]+1);\\n                m[x]=i;\\n            }\\n        }\\n        if(res==INT_MAX) return -1;\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996370,
                "title": "c-hashmap-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        map<int,int>first,second;\\n        map<int,vector<int>>occ;\\n        int n=cards.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            occ[cards[i]].push_back(i);\\n           \\n        }\\n        int ans=1e9;\\n        for(auto i:occ)\\n        {\\n            int ele=i.first;\\n            vector<int>res=i.second;\\n            if(res.size()<2)\\n                continue;\\n            \\n            for(int j=0;j<res.size()-1;j++)\\n                ans=min(ans,res[j+1]-res[j]+1);\\n            \\n            \\n        }\\n        if(ans==1e9)\\n            return -1;\\n        return ans;\\n    \\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        map<int,int>first,second;\\n        map<int,vector<int>>occ;\\n        int n=cards.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            occ[cards[i]].push_back(i);\\n           \\n        }\\n        int ans=1e9;\\n        for(auto i:occ)\\n        {\\n            int ele=i.first;\\n            vector<int>res=i.second;\\n            if(res.size()<2)\\n                continue;\\n            \\n            for(int j=0;j<res.size()-1;j++)\\n                ans=min(ans,res[j+1]-res[j]+1);\\n            \\n            \\n        }\\n        if(ans==1e9)\\n            return -1;\\n        return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996352,
                "title": "hashmap-o-n",
                "content": "Update the key value by the index everytime. \\nOnce another same key is here, we take the difference and add 1 to find the size between the previous one and the new one.\\nThen update the key to the new index to make sure that the next one we are comparing will be the previous newest one this will result in finding all pairs of sizes of the same keys.\\nThen take the minimum of the given size that we have.\\n\\n\\n```\\ndef minimumCardPickup(self, cards: List[int]) -> int:\\n        hm = {}\\n        res = 100000000000000000000\\n        for i in range(len(cards)):\\n            if (cards[i] in hm):\\n                cur = i - hm[cards[i]] + 1\\n                res = min(cur, res)\\n            hm[cards[i]] = i\\n            \\n        if (res == 100000000000000000000):\\n            return -1\\n        return res\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef minimumCardPickup(self, cards: List[int]) -> int:\\n        hm = {}\\n        res = 100000000000000000000\\n        for i in range(len(cards)):\\n            if (cards[i] in hm):\\n                cur = i - hm[cards[i]] + 1\\n                res = min(cur, res)\\n            hm[cards[i]] = i\\n            \\n        if (res == 100000000000000000000):\\n            return -1\\n        return res\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1996343,
                "title": "c-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n          int n = cards.size();\\n          if(n == 1) return -1;\\n        \\n          unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[cards[i]].push_back(i);\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(auto i : mp){\\n            vector<int> tmp = i.second;\\n            if(tmp.size() <= 1) continue;\\n            \\n            int cur_ans = INT_MAX;\\n            for(int i = 1; i < tmp.size(); i++){\\n                int diff = tmp[i] - tmp[i-1] + 1;\\n                if(diff < cur_ans){\\n                    cur_ans = diff ;\\n                }\\n            }\\n              ans = min(ans, cur_ans);\\n        }\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n          int n = cards.size();\\n          if(n == 1) return -1;\\n        \\n          unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[cards[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1996326,
                "title": "hasmap-solution-python-easy",
                "content": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        dic={}\\n        \\n        for i in range(len(cards)):\\n            try:\\n                dic[cards[i]].append(i)\\n            except:\\n                dic[cards[i]]=[i]\\n              \\n        mini=10000000\\n        br=True\\n        for i in dic:\\n            if len(dic[i])>=2:\\n                br=False\\n                for k in range(1,len(dic[i])):\\n                    #print(dic[i][k],dic[i][k-1],dic[i][k]-dic[i][k-1])\\n                    mini=min(mini,(dic[i][k]-dic[i][k-1])+1)\\n\\n        if br:\\n            return -1\\n        return mini\\n                    \\n                    \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        dic={}\\n        \\n        for i in range(len(cards)):\\n            try:\\n                dic[cards[i]].append(i)\\n            except:\\n                dic[cards[i]]=[i]\\n              \\n        mini=10000000\\n        br=True\\n        for i in dic:\\n            if len(dic[i])>=2:\\n                br=False\\n                for k in range(1,len(dic[i])):\\n                    #print(dic[i][k],dic[i][k-1],dic[i][k]-dic[i][k-1])\\n                    mini=min(mini,(dic[i][k]-dic[i][k-1])+1)\\n\\n        if br:\\n            return -1\\n        return mini\\n                    \\n                    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996283,
                "title": "easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>mp;\\n        unordered_map<int,int>ll;\\n        int ans=INT_MAX;\\n        for(int i=0;i<cards.size();i++){\\n                if(ll[cards[i]]){\\n                    int g = mp[cards[i]];\\n                    ans=min(ans,i-g+1);\\n                }\\n                ll[cards[i]]++;\\n                mp[cards[i]]=i;\\n            }\\n        return ans==INT_MAX?-1:ans;\\n        }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>mp;\\n        unordered_map<int,int>ll;\\n        int ans=INT_MAX;\\n        for(int i=0;i<cards.size();i++){\\n                if(ll[cards[i]]){\\n                    int g = mp[cards[i]];\\n                    ans=min(ans,i-g+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1996236,
                "title": "python-java-sliding-window",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumCardPickup(self, cards: List[int]) -> int:\\n\\t\\t\\ti = 0\\n\\t\\t\\tseen = set()\\n\\t\\t\\tres = float(\"inf\")\\n\\t\\t\\tfor j, card in enumerate(cards):\\n\\t\\t\\t\\twhile card in seen:\\n\\t\\t\\t\\t\\tres = min(res, j - i + 1)\\n\\t\\t\\t\\t\\tseen.remove(cards[i])\\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tseen.add(card)\\n\\t\\t\\tif res != float(\"inf\"):\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int minimumCardPickup(int[] cards) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\tint res = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < cards.length; j ++) {\\n\\t\\t\\t\\twhile (seen.contains(cards[j])) {\\n\\t\\t\\t\\t\\tres = Math.min(res, j - i + 1);\\n\\t\\t\\t\\t\\tseen.remove(cards[i]);\\n\\t\\t\\t\\t\\ti ++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tseen.add(cards[j]);\\n\\t\\t\\t}\\n\\t\\t\\tif (res != Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef minimumCardPickup(self, cards: List[int]) -> int:\\n\\t\\t\\ti = 0\\n\\t\\t\\tseen = set()\\n\\t\\t\\tres = float(\"inf\")\\n\\t\\t\\tfor j, card in enumerate(cards):\\n\\t\\t\\t\\twhile card in seen:\\n\\t\\t\\t\\t\\tres = min(res, j - i + 1)\\n\\t\\t\\t\\t\\tseen.remove(cards[i])\\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tseen.add(card)\\n\\t\\t\\tif res != float(\"inf\"):\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int minimumCardPickup(int[] cards) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\tint res = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < cards.length; j ++) {\\n\\t\\t\\t\\twhile (seen.contains(cards[j])) {\\n\\t\\t\\t\\t\\tres = Math.min(res, j - i + 1);\\n\\t\\t\\t\\t\\tseen.remove(cards[i]);\\n\\t\\t\\t\\t\\ti ++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4093314,
                "title": "hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe job is to find the closest pair of identical elements (A pair of identical having the minimum distance between them).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can create a hashmap/dictionary to store the following:\\n`card no. --> last index it was found at`\\n\\nThis way, when an element gets repeated, we know what index it was last found at, (since that is the instance of this element that would form a pair with minimum distance from the current element).\\n\\nAfter calculating the distance, we can update the last index of that particular element to be the current index.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        map<int, vector<int>> mpp;\\n        int ans = INT_MAX;\\n        for(int i=0; i<cards.size(); i++){\\n            mpp[cards[i]].push_back(i);\\n            if(mpp[cards[i]].size()>1){\\n                int s = mpp[cards[i]].size();\\n                ans = min(ans, mpp[cards[i]][s-1] - mpp[cards[i]][s-2]+1);\\n            }\\n        }\\n        \\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        map<int, vector<int>> mpp;\\n        int ans = INT_MAX;\\n        for(int i=0; i<cards.size(); i++){\\n            mpp[cards[i]].push_back(i);\\n            if(mpp[cards[i]].size()>1){\\n                int s = mpp[cards[i]].size();\\n                ans = min(ans, mpp[cards[i]][s-1] - mpp[cards[i]][s-2]+1);\\n            }\\n        }\\n        \\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081848,
                "title": "beats-100-of-python-users-simple-solution",
                "content": "![image_2023-09-23_205136833.png](https://assets.leetcode.com/users/images/e26dd528-8c1c-46cd-b97a-0821ac546269_1695495096.6468158.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumCardPickup(self, cards):\\n        \"\"\"\\n        :type cards: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # The maximum length of possible result equals to len(cards)\\n        result = len(cards) + 1\\n        card_value = {}\\n        count_cards = 0\\n        card_index = 0\\n        consecutive_length = 0\\n        found_pair = False\\n\\n        for i, card in enumerate(cards):\\n\\n            if card not in card_value:\\n                card_value[card] = i\\n                \\n            else:\\n\\n                if (i - card_value[card] < result):\\n                    found_pair = True\\n                    # Need to add both cards of the pair\\n                    result = i - card_value[card] + 1\\n                \\n                # If there are more then 2 occurences of one value\\n                # we need to update the length\\n                card_value[card] = i\\n\\n        if not found_pair:\\n            return -1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumCardPickup(self, cards):\\n        \"\"\"\\n        :type cards: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # The maximum length of possible result equals to len(cards)\\n        result = len(cards) + 1\\n        card_value = {}\\n        count_cards = 0\\n        card_index = 0\\n        consecutive_length = 0\\n        found_pair = False\\n\\n        for i, card in enumerate(cards):\\n\\n            if card not in card_value:\\n                card_value[card] = i\\n                \\n            else:\\n\\n                if (i - card_value[card] < result):\\n                    found_pair = True\\n                    # Need to add both cards of the pair\\n                    result = i - card_value[card] + 1\\n                \\n                # If there are more then 2 occurences of one value\\n                # we need to update the length\\n                card_value[card] = i\\n\\n        if not found_pair:\\n            return -1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081448,
                "title": "sliding-window-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSlide the window as long as no repeating element found. Once found try minimizing the window size as long as repeating element still present in the window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize your left pointer at 0.\\n2. Have a hashmap to store the count of elements encountered.\\n3. Start your left pointer.\\n4. Keep adding the the current element with its count to the hashmap.\\n5. Once you encounter an element already present in the hashmap, increment the left point as long as the count of present element does not become zero, (you need atleast count=1 of present element,exluding the count of present element)\\n6. Update the result which is the minimum of result and current window size\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O()\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n\\n        consec={} # Map element -> count in the current window\\n        l=0\\n        res=float(\"inf\")\\n        for r in range(len(cards)):\\n            if cards[r] in consec:\\n                while l<r and ((cards[l]!=cards[r]) or (consec[cards[r]]>1)):\\n                    consec[cards[l]]-=1   \\n                    if consec[cards[l]]==0:\\n                        del consec[cards[l]]\\n                    l+=1\\n                \\n                res=min(res,r-l+1)\\n            consec[cards[r]]=1+consec.get(cards[r],0)\\n\\n        return res if not res==float(\"inf\") else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n\\n        consec={} # Map element -> count in the current window\\n        l=0\\n        res=float(\"inf\")\\n        for r in range(len(cards)):\\n            if cards[r] in consec:\\n                while l<r and ((cards[l]!=cards[r]) or (consec[cards[r]]>1)):\\n                    consec[cards[l]]-=1   \\n                    if consec[cards[l]]==0:\\n                        del consec[cards[l]]\\n                    l+=1\\n                \\n                res=min(res,r-l+1)\\n            consec[cards[r]]=1+consec.get(cards[r],0)\\n\\n        return res if not res==float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078386,
                "title": "minimum-consecutive-cards-to-pick-up-python3",
                "content": "# Intuition\\nYou are given an integer array cards where cards[i] represents the value of the ith card. A pair of cards are matching if the cards have the same value.\\n\\nReturn the minimum number of consecutive cards you have to pick up to have a pair of matching cards among the picked cards. If it is impossible to have matching cards, return -1.\\n\\n# Approach\\n1. Create dictionary which can store your number and index\\n2. now keep storing it untill you get a matching pair which number if already present in dict than just pick the index of current number - index of existing same number\\n3. check if its the mininum\\n4. And if there are no matching pair than return -1 \\n5. As i have assigned mindiff max value thats why kept one boolean flag to check if we have any matching pair or not \\n\\nHope the solution helps\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nimport sys\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        mydict = {}\\n        mindiff = sys.maxsize\\n        ismatch = False\\n        for i in range(len(cards)):\\n            if cards[i] in mydict:\\n                curr = (i-mydict[cards[i]])+1\\n                mindiff = min(mindiff,curr)\\n                mydict[cards[i]]=i\\n                ismatch = True\\n            else:\\n                mydict[cards[i]]=i  \\n        \\n        if not ismatch:\\n            #assume there was no matching pair \\n            return -1\\n        return mindiff\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport sys\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        mydict = {}\\n        mindiff = sys.maxsize\\n        ismatch = False\\n        for i in range(len(cards)):\\n            if cards[i] in mydict:\\n                curr = (i-mydict[cards[i]])+1\\n                mindiff = min(mindiff,curr)\\n                mydict[cards[i]]=i\\n                ismatch = True\\n            else:\\n                mydict[cards[i]]=i  \\n        \\n        if not ismatch:\\n            #assume there was no matching pair \\n            return -1\\n        return mindiff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078225,
                "title": "c-using-unordered-map",
                "content": "# Intuition\\n- unordred_map to keep track if previoously encountered said card\\n- if Yes , calculate Min\\n-       ** AND UPDATE its new index\\n- if not add card index to map\\n\\nif \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int> map1 ;\\n        int n=cards.size() ;\\n        int ans = INT_MAX ;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(map1.find(cards[i]) != map1.end()){   // Encountered early\\n                ans = min(ans,i-map1[cards[i]]+1) ;\\n                map1[cards[i]] =i; // UPDATE ITS NEW Index (Card might again come later)\\n            }\\n            else \\n                map1[cards[i]] =i ;\\n        }\\n        if(ans == INT_MAX) \\n            return -1 ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int> map1 ;\\n        int n=cards.size() ;\\n        int ans = INT_MAX ;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(map1.find(cards[i]) != map1.end()){   // Encountered early\\n                ans = min(ans,i-map1[cards[i]]+1) ;\\n                map1[cards[i]] =i; // UPDATE ITS NEW Index (Card might again come later)\\n            }\\n            else \\n                map1[cards[i]] =i ;\\n        }\\n        if(ans == INT_MAX) \\n            return -1 ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075738,
                "title": "2260-minimum-consecutive-cards-to-pick-up",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer, Integer> hash =new HashMap<>();\\n        int min=Integer.MAX_VALUE;\\n        for(int left=0; left<cards.length; left++)\\n        {\\n            if(hash.containsKey(cards[left]))\\n            {\\n                int right = hash.get(cards[left]);\\n                min = Math.min(min, left-right+1);  \\n            }\\n            hash.put(cards[left],left);\\n        }\\n        if(min==Integer.MAX_VALUE) min=-1;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer, Integer> hash =new HashMap<>();\\n        int min=Integer.MAX_VALUE;\\n        for(int left=0; left<cards.length; left++)\\n        {\\n            if(hash.containsKey(cards[left]))\\n            {\\n                int right = hash.get(cards[left]);\\n                min = Math.min(min, left-right+1);  \\n            }\\n            hash.put(cards[left],left);\\n        }\\n        if(min==Integer.MAX_VALUE) min=-1;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074904,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int res=INT_MAX;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<cards.size();i++){\\n            if(mp[cards[i]])\\n                res=fmin(res,i-mp[cards[i]]+2);\\n            mp[cards[i]]=i+1;\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int res=INT_MAX;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<cards.size();i++){\\n            if(mp[cards[i]])\\n                res=fmin(res,i-mp[cards[i]]+2);\\n            mp[cards[i]]=i+1;\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067873,
                "title": "simple-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>mp;\\n\\n        int i=0;\\n        int j=0;\\n        int ans=INT_MAX;\\n\\n        while(j<cards.size())\\n        {\\n            mp[cards[j]]++;\\n\\n            if(mp.size()==j-i)\\n            {\\n                ans=min(ans,j-i+1);\\n                while(mp.size()==j-i)\\n               {   ans=min(ans,j-i+1);\\n                   mp[cards[i]]--;\\n                if(mp[cards[i]]==0)\\n                mp.erase(cards[i]);\\n                i++;\\n                }\\n                j++;\\n            }\\n            else\\n            j++;\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>mp;\\n\\n        int i=0;\\n        int j=0;\\n        int ans=INT_MAX;\\n\\n        while(j<cards.size())\\n        {\\n            mp[cards[j]]++;\\n\\n            if(mp.size()==j-i)\\n            {\\n                ans=min(ans,j-i+1);\\n                while(mp.size()==j-i)\\n               {   ans=min(ans,j-i+1);\\n                   mp[cards[i]]--;\\n                if(mp[cards[i]]==0)\\n                mp.erase(cards[i]);\\n                i++;\\n                }\\n                j++;\\n            }\\n            else\\n            j++;\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054315,
                "title": "using-an-unordered-set-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_set<int>s;\\n        int i,j,n=cards.size();\\n        i=j=0;\\n        int mini=1e9;\\n        while(i<n){\\n            while(j<n and s.find(cards[i])!=s.end()){\\n                mini=min(mini,i-j+1);\\n                s.erase(cards[j]);\\n                j++;\\n            }\\n            s.insert(cards[i]);\\n            i++;\\n        }\\n        return mini=mini==1e9?-1:mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_set<int>s;\\n        int i,j,n=cards.size();\\n        i=j=0;\\n        int mini=1e9;\\n        while(i<n){\\n            while(j<n and s.find(cards[i])!=s.end()){\\n                mini=min(mini,i-j+1);\\n                s.erase(cards[j]);\\n                j++;\\n            }\\n            s.insert(cards[i]);\\n            i++;\\n        }\\n        return mini=mini==1e9?-1:mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048465,
                "title": "slifding-window-tc-o-n-and-sc-o-1",
                "content": "HashMap<Integer, Integer> map=new HashMap<>();\\n\\t\\t        int i=0;\\n\\t\\t\\t\\tint j=0;\\n\\t\\t\\t\\tint min=Integer.MAX_VALUE;\\n\\t\\t\\t\\twhile(j<cards.length){\\n\\t\\t\\t\\t\\tmap.put(cards[j], map.getOrDefault(cards[j],0)+1);\\n\\t\\t\\t\\t\\tif(j-i+1<=map.size()){\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\twhile(j-i+1>map.size() ){\\n\\t\\t\\t\\t\\t\\t// if((j-i+1)%2==0){\\n\\t\\t\\t\\t\\t\\t\\tmin=Math.min(j-i+1, min);\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmap.put(cards[i], map.getOrDefault(cards[i],0)-1);\\n\\t\\t\\t\\t\\t\\tif(map.get(cards[i])==0){\\n\\t\\t\\t\\t\\t\\t\\tmap.remove(cards[i]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn min == Integer.MAX_VALUE? -1: min;\\n\\t\\t\\t}\\n\\t\\t}\\n",
                "solutionTags": [],
                "code": "HashMap<Integer, Integer> map=new HashMap<>();\\n\\t\\t        int i=0;\\n\\t\\t\\t\\tint j=0;\\n\\t\\t\\t\\tint min=Integer.MAX_VALUE;\\n\\t\\t\\t\\twhile(j<cards.length){\\n\\t\\t\\t\\t\\tmap.put(cards[j], map.getOrDefault(cards[j],0)+1);\\n\\t\\t\\t\\t\\tif(j-i+1<=map.size()){\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\twhile(j-i+1>map.size() ){\\n\\t\\t\\t\\t\\t\\t// if((j-i+1)%2==0){\\n\\t\\t\\t\\t\\t\\t\\tmin=Math.min(j-i+1, min);\\n\\t\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmap.put(cards[i], map.getOrDefault(cards[i],0)-1);\\n\\t\\t\\t\\t\\t\\tif(map.get(cards[i])==0){\\n\\t\\t\\t\\t\\t\\t\\tmap.remove(cards[i]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn min == Integer.MAX_VALUE? -1: min;\\n\\t\\t\\t}\\n\\t\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4047771,
                "title": "java-o-n-simple-map-solution",
                "content": "# Intuition\\nSave the last idx for each card and compare it to the next idx.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < cards.length; i++) {\\n            Integer idx = map.get(cards[i]);\\n            if (idx != null) res = Math.min(res, i - idx + 1);\\n            map.put(cards[i], i);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < cards.length; i++) {\\n            Integer idx = map.get(cards[i]);\\n            if (idx != null) res = Math.min(res, i - idx + 1);\\n            map.put(cards[i], i);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045828,
                "title": "c-hashmap-90-faster",
                "content": "Idea: Create a Hashmap. Iterate the cards array and add every element of the cards array into the map. The card will be the key and index will be value. Two things can happen here, card already present in the map or card not present in the map. \\n\\t1.) If an card is already present in the array, use the index present in the hash map and current index(for loop) to calculate the number of elements between these two occurances and store in a variable. Check this value with the minimum and update the minimum. Also, update the index of the card in the hashmap so that if that card occurs again in the cards, the number of cards between the two occurances can found. \\n\\t2.)  If an card is not present, add the card and its index into the map.\\nLast, check if the minimum value is INT_MAX. if it is, then no card has repeated in the array and we can return -1.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size();\\n        unordered_map<int,int> look;\\n        \\n        int i=0, minimum=INT_MAX,current=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(look.find(cards[i]) == look.end())\\n                look[cards[i]] = i;\\n            else{\\n                current = i-look[cards[i]]+1;\\n                if(current < minimum)\\n                    minimum=current;\\n                look[cards[i]] = i;\\n            }\\n        }\\n        \\n        if(minimum == INT_MAX)\\n            return -1;\\n        \\n        \\n        return minimum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size();\\n        unordered_map<int,int> look;\\n        \\n        int i=0, minimum=INT_MAX,current=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(look.find(cards[i]) == look.end())\\n                look[cards[i]] = i;\\n            else{\\n                current = i-look[cards[i]]+1;\\n                if(current < minimum)\\n                    minimum=current;\\n                look[cards[i]] = i;\\n            }\\n        }\\n        \\n        if(minimum == INT_MAX)\\n            return -1;\\n        \\n        \\n        return minimum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044861,
                "title": "java-simple-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n       \\n       int ans=Integer.MAX_VALUE;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n\\n        for(int i=0;i<cards.length;i++){\\n            if(map.containsKey(cards[i])){\\n                ans=Math.min(ans,i-map.get(cards[i])+1);\\n            }\\n\\n                map.put(cards[i],i);\\n            \\n        }\\n\\n       return ans==Integer.MAX_VALUE?-1:ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n       \\n       int ans=Integer.MAX_VALUE;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n\\n        for(int i=0;i<cards.length;i++){\\n            if(map.containsKey(cards[i])){\\n                ans=Math.min(ans,i-map.get(cards[i])+1);\\n            }\\n\\n                map.put(cards[i],i);\\n            \\n        }\\n\\n       return ans==Integer.MAX_VALUE?-1:ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041877,
                "title": "hashing-at-it-s-best",
                "content": "\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        \\n        dic = defaultdict(list)\\n        ans = float(\\'inf\\')\\n        for i in range(len(cards)):\\n            \\n            if cards[i] in dic:\\n                ans = min(ans,i - dic[cards[i]] + 1)\\n\\n            dic[cards[i]] = i\\n            \\n        return ans if ans < float(\"inf\") else -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        \\n        dic = defaultdict(list)\\n        ans = float(\\'inf\\')\\n        for i in range(len(cards)):\\n            \\n            if cards[i] in dic:\\n                ans = min(ans,i - dic[cards[i]] + 1)\\n\\n            dic[cards[i]] = i\\n            \\n        return ans if ans < float(\"inf\") else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033981,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int i = 0, j = 0, res = Integer.MAX_VALUE;\\n        Set<Integer> hs = new HashSet<>();\\n        while(j < cards.length){\\n            if(hs.contains(cards[j])){\\n                res = Math.min(res, j - i + 1);\\n                hs.add(cards[j]);\\n                hs.remove(cards[i++]);\\n            }else{\\n                hs.add(cards[j++]);\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int i = 0, j = 0, res = Integer.MAX_VALUE;\\n        Set<Integer> hs = new HashSet<>();\\n        while(j < cards.length){\\n            if(hs.contains(cards[j])){\\n                res = Math.min(res, j - i + 1);\\n                hs.add(cards[j]);\\n                hs.remove(cards[i++]);\\n            }else{\\n                hs.add(cards[j++]);\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025557,
                "title": "java-hashmap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        int min=cards.length;\\n        for(int i=0;i<cards.length;i++)\\n        {\\n            if(map.containsKey(cards[i]))\\n            {\\n                if(i-map.get(cards[i])<min)\\n                {\\n                    min=i-map.get(cards[i]);\\n                    \\n                }\\n                    \\n            }\\n            map.put(cards[i],i);\\n        }\\n        if(min==cards.length)\\n        {\\n            return -1;\\n        }\\n        return min+1;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        int min=cards.length;\\n        for(int i=0;i<cards.length;i++)\\n        {\\n            if(map.containsKey(cards[i]))\\n            {\\n                if(i-map.get(cards[i])<min)\\n                {\\n                    min=i-map.get(cards[i]);\\n                    \\n                }\\n                    \\n            }\\n            map.put(cards[i],i);\\n        }\\n        if(min==cards.length)\\n        {\\n            return -1;\\n        }\\n        return min+1;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006590,
                "title": "simple-hashmap-solution-o-n-complexity",
                "content": "# Intuition\\nThe problem requires us to return minimum number of consecutive cards to be picked to have a pair of matching card.\\n# Approach\\nWe can use a hashmap to effectively store the value of card, i.e., `cards[i]` and its index where it first occured.\\n\\nWe\\'ll loop through the `cards[]` array and if the `map` contains the card, we can get the index of that card where it first occurred and then we can subtract this from the current position of `i`. This will give us the count of consecutive cards to be picked to have a pair of matching card. We can compare this each time with the `ans` variable.\\n\\nIf the card is not present in map, we can add it in the map.\\n\\nFinally, we will return the `ans` variable storing the minimum count.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<cards.length; i++){\\n\\n            if(map.containsKey(cards[i])){\\n                int idx = map.get(cards[i]);\\n                int res = i - idx + 1;\\n                ans = Math.min(ans, res);\\n            }\\n\\n            map.put(cards[i], i);\\n        }\\n        return ans==Integer.MAX_VALUE ?-1 :ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<cards.length; i++){\\n\\n            if(map.containsKey(cards[i])){\\n                int idx = map.get(cards[i]);\\n                int res = i - idx + 1;\\n                ans = Math.min(ans, res);\\n            }\\n\\n            map.put(cards[i], i);\\n        }\\n        return ans==Integer.MAX_VALUE ?-1 :ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006376,
                "title": "java-o-n-using-map-no-sliding-window",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer, Integer> occur = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < cards.length; i++) {\\n            Integer idx = occur.get(cards[i]);\\n\\n            if (idx != null) {\\n                min = Math.min(min, i - idx + 1);\\n            }\\n\\n            occur.put(cards[i], i);\\n        }\\n\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        Map<Integer, Integer> occur = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < cards.length; i++) {\\n            Integer idx = occur.get(cards[i]);\\n\\n            if (idx != null) {\\n                min = Math.min(min, i - idx + 1);\\n            }\\n\\n            occur.put(cards[i], i);\\n        }\\n\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997473,
                "title": "easy-solution-using-maps-tc-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf I can find the indices of all the different values, and then take the minimum difference of the indices that will be my answer. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n* log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        // This Will store the value and its indices\\n        int n = cards.size();\\n        map<int,vector<int>> m;\\n        for(int i=0;i<n;i++){\\n            m[cards[i]].push_back(i);\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(auto it: m){\\n            for(int i=1;i<m[it.first].size();i++){\\n                int diff = m[it.first][i]-m[it.first][i-1]+1;\\n                mini = min(mini,diff);\\n            }\\n        }\\n        if(mini == INT_MAX) return -1;\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        // This Will store the value and its indices\\n        int n = cards.size();\\n        map<int,vector<int>> m;\\n        for(int i=0;i<n;i++){\\n            m[cards[i]].push_back(i);\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(auto it: m){\\n            for(int i=1;i<m[it.first].size();i++){\\n                int diff = m[it.first][i]-m[it.first][i-1]+1;\\n                mini = min(mini,diff);\\n            }\\n        }\\n        if(mini == INT_MAX) return -1;\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997128,
                "title": "beats-80-63-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int min = Integer.MAX_VALUE;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<cards.length; i++)\\n        {\\n            if(map.containsKey(cards[i]))\\n            {\\n                int y = map.get(cards[i]);\\n                int h = Math.abs(i - y);\\n                if(h < min) {\\n                    min = h;\\n                }\\n                map.put(cards[i], i);\\n            }\\n            map.put(cards[i], i);\\n        }\\n        if(min == Integer.MAX_VALUE) {return -1;}\\n        return min + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int min = Integer.MAX_VALUE;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<cards.length; i++)\\n        {\\n            if(map.containsKey(cards[i]))\\n            {\\n                int y = map.get(cards[i]);\\n                int h = Math.abs(i - y);\\n                if(h < min) {\\n                    min = h;\\n                }\\n                map.put(cards[i], i);\\n            }\\n            map.put(cards[i], i);\\n        }\\n        if(min == Integer.MAX_VALUE) {return -1;}\\n        return min + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991881,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        map<int, vector<int>> m;\\n        for(int i=0; i<cards.size(); i++)\\n        {\\n            m[cards[i]].push_back(i);\\n        }\\n        int ans=INT_MAX;\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second.size()>1)\\n            {\\n                for(int i=0;i<it->second.size()-1;i++)\\n                {\\n                    int diff=abs(it->second[i+1]-it->second[i]);\\n                    ans=min(ans,diff);\\n                }\\n                ans;\\n            }\\n        }\\n        if(ans==INT_MAX)\\n            ans=-1;\\n        else \\n            ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        map<int, vector<int>> m;\\n        for(int i=0; i<cards.size(); i++)\\n        {\\n            m[cards[i]].push_back(i);\\n        }\\n        int ans=INT_MAX;\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second.size()>1)\\n            {\\n                for(int i=0;i<it->second.size()-1;i++)\\n                {\\n                    int diff=abs(it->second[i+1]-it->second[i]);\\n                    ans=min(ans,diff);\\n                }\\n                ans;\\n            }\\n        }\\n        if(ans==INT_MAX)\\n            ans=-1;\\n        else \\n            ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984485,
                "title": "sliding-window-set-map-c",
                "content": "# CPP\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Using Set\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_set<int>st;\\n        int ans=INT_MAX;\\n        int i=0,j=0;\\n        while(i<cards.size()){\\n            if(st.find(cards[i])==st.end()){\\n                st.insert(cards[i]);\\n                i++;\\n            }else{\\n                ans=min(ans,i-j+1);\\n                while(j<=i && st.find(cards[i])!=st.end()){\\n                    ans=min(ans,i-j+1);\\n                    st.erase(cards[j]);\\n                    j++;\\n                }\\n                st.insert(cards[i]);\\n                i++;\\n            }\\n        }\\n        if(st.size()==cards.size()) return -1;\\n        return ans;\\n    }\\n};\\n```\\n# Using Map\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>m;\\n        int ans=INT_MAX;\\n        for(int i=0;i<cards.size();i++){\\n            if(m.find(cards[i])!=m.end()){\\n                ans=min(ans,i-m[cards[i]]+1);\\n            }\\n            m[cards[i]]=i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_set<int>st;\\n        int ans=INT_MAX;\\n        int i=0,j=0;\\n        while(i<cards.size()){\\n            if(st.find(cards[i])==st.end()){\\n                st.insert(cards[i]);\\n                i++;\\n            }else{\\n                ans=min(ans,i-j+1);\\n                while(j<=i && st.find(cards[i])!=st.end()){\\n                    ans=min(ans,i-j+1);\\n                    st.erase(cards[j]);\\n                    j++;\\n                }\\n                st.insert(cards[i]);\\n                i++;\\n            }\\n        }\\n        if(st.size()==cards.size()) return -1;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>m;\\n        int ans=INT_MAX;\\n        for(int i=0;i<cards.size();i++){\\n            if(m.find(cards[i])!=m.end()){\\n                ans=min(ans,i-m[cards[i]]+1);\\n            }\\n            m[cards[i]]=i;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983516,
                "title": "easy-cpp-code-with-intuition-and-approach-and-with-time-complexity-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe want to check the element previously occured or not, therefore map can be optimal\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate on cards array and store its corresponding index if it was founded previously then finding its length, if not just add its index into map\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) //in worst case\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>mpp;\\n        int n=cards.size();\\n        int mini=INT_MAX;\\n        bool flag=true;\\n        for(int i=0;i<n;i++)\\n        {\\n            //founded earlier\\n            if(mpp.find(cards[i])!=mpp.end())\\n            {\\n                mini=min(mini,i-mpp[cards[i]]+1);  \\n                flag=false;\\n            }\\n            mpp[cards[i]]=i;\\n        }\\n        if(flag) return -1;\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        unordered_map<int,int>mpp;\\n        int n=cards.size();\\n        int mini=INT_MAX;\\n        bool flag=true;\\n        for(int i=0;i<n;i++)\\n        {\\n            //founded earlier\\n            if(mpp.find(cards[i])!=mpp.end())\\n            {\\n                mini=min(mini,i-mpp[cards[i]]+1);  \\n                flag=false;\\n            }\\n            mpp[cards[i]]=i;\\n        }\\n        if(flag) return -1;\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973763,
                "title": "171ms-beats-97-78-of-users-with-c-easy",
                "content": "# Code\\n```\\nstatic auto _ = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        unordered_map<int,int> mp;\\n        int mn=INT_MAX;\\n        for(int i = 0 ; i < cards.size() ; ++i)\\n        {\\n            if(!mp.count(cards[i]))\\n                mp[cards[i]] = i;\\n            else\\n            {\\n                int j = mp[cards[i]];\\n                mp[cards[i]] = i;\\n                mn = min(mn,i-j+1);\\n            }\\n        }\\n        return mn==INT_MAX?-1:mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic auto _ = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        \\n        unordered_map<int,int> mp;\\n        int mn=INT_MAX;\\n        for(int i = 0 ; i < cards.size() ; ++i)\\n        {\\n            if(!mp.count(cards[i]))\\n                mp[cards[i]] = i;\\n            else\\n            {\\n                int j = mp[cards[i]];\\n                mp[cards[i]] = i;\\n                mn = min(mn,i-j+1);\\n            }\\n        }\\n        return mn==INT_MAX?-1:mn;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3972195,
                "title": "python-o-n-solution-with-hashmap-dictionary",
                "content": "\\n# Approach\\n- Storing the last visited index of each number in a dictionary `visited`.\\n- For each number, checking the distance (`idx - visited[c] + 1`) of current index of that number with the index occcured previously (if occured) in the dictionary.\\n- Updating the `min_c` if the distance is less than `min_c`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) using hashmap to track visited number index\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        min_c = math.inf\\n        visited = {}\\n        for idx,c in enumerate(cards):\\n            if c in visited:\\n                min_c = min(min_c, idx - visited[c] + 1)\\n            visited[c] = idx\\n        return min_c if min_c != math.inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        min_c = math.inf\\n        visited = {}\\n        for idx,c in enumerate(cards):\\n            if c in visited:\\n                min_c = min(min_c, idx - visited[c] + 1)\\n            visited[c] = idx\\n        return min_c if min_c != math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968537,
                "title": "ts-js-very-easy-to-understand-using-maps",
                "content": "Let me know if anyone is not able to understand. I will be happy to help.\\n# Code\\n```\\nfunction minimumCardPickup(cards: number[]): number {\\n  let hash = new Map<number,number>();\\n  let min = cards.length+1;\\n  for(let i=0;i<cards.length;i++){\\n    if(hash.has(cards[i]))\\n      min = Math.min(min, (i - hash.get(cards[i])+1));\\n    hash.set(cards[i],i);\\n  }\\n  return min === cards.length+1 ? -1 : min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumCardPickup(cards: number[]): number {\\n  let hash = new Map<number,number>();\\n  let min = cards.length+1;\\n  for(let i=0;i<cards.length;i++){\\n    if(hash.has(cards[i]))\\n      min = Math.min(min, (i - hash.get(cards[i])+1));\\n    hash.set(cards[i],i);\\n  }\\n  return min === cards.length+1 ? -1 : min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963786,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minimumCardPickup(vector<int>& cards) {\\n    int ans = INT_MAX;\\n    unordered_map<int, int> lastSeen;\\n\\n    for (int i = 0; i < cards.size(); ++i) {\\n      if (const auto it = lastSeen.find(cards[i]); it != lastSeen.cend())\\n        ans = min(ans, i - it->second + 1);\\n      lastSeen[cards[i]] = i;\\n    }\\n\\n    return ans == INT_MAX ? -1 : ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minimumCardPickup(vector<int>& cards) {\\n    int ans = INT_MAX;\\n    unordered_map<int, int> lastSeen;\\n\\n    for (int i = 0; i < cards.size(); ++i) {\\n      if (const auto it = lastSeen.find(cards[i]); it != lastSeen.cend())\\n        ans = min(ans, i - it->second + 1);\\n      lastSeen[cards[i]] = i;\\n    }\\n\\n    return ans == INT_MAX ? -1 : ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956120,
                "title": "o-n-time-and-o-n-space-simple-python-solution-that-beats-95-78-671ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply, we are interested in two elements in the array that are closest to each other. We can use a Map that maps a number in the array to the last position it was seen on the array. When we iterate in the array, we check wheather the number is in the Map. If we read a number for the first time, then, it\\'s not in the Map, so we add it to the Map with its last seen position index (number, position). If we notice the number we read is already in the array, then we can calculate what\\'s the difference between the two indexes (current index - last seen index retrieved from the Map). Now check whether this difference is the minimun difference we have seen so far, and if so, keep it as the new minimum, and update the last seen index of the number in the Map to current index. If there is no repearing numbers in the list, the length of the Map is equal to length of the cards array, thus, we can return -1. Otherwise we return the minimum difference we calculated + 1 (the Map indexes is zero based).  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) - We only iterate through the input array once. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) - We use extra space. The worse case is when we have unique elements in the array, so the Map will also contains all the elements. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        num_pos = {}\\n        min_v = 1000001\\n        for n in range(len(cards)):\\n            if cards[n] in num_pos:\\n                min_v = min(min_v, (n - num_pos[cards[n]]))\\n            num_pos[cards[n]] = n\\n        return -1 if len(cards) == len(num_pos) else min_v + 1\\n\\n\\n```\\n\\n![Screen Shot 2023-08-24 at 1.25.12 PM.png](https://assets.leetcode.com/users/images/db6715bc-3dd1-40e0-8169-014a1ebe8d41_1692909622.499514.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        num_pos = {}\\n        min_v = 1000001\\n        for n in range(len(cards)):\\n            if cards[n] in num_pos:\\n                min_v = min(min_v, (n - num_pos[cards[n]]))\\n            num_pos[cards[n]] = n\\n        return -1 if len(cards) == len(num_pos) else min_v + 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952981,
                "title": "c-easy-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nphle ek vector lia and initialize the size of it as it given in the constraints ans assign all it as -1; \\nand then mark the value of the index as the current index in the vector you intitlize.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        vector<int> v(1000001, -1);\\n        int ans = INT_MAX;\\n        for (int i = 0; i < cards.size(); i++) {\\n            if (v[cards[i]] != -1) {\\n                ans = min(i - v[cards[i]] + 1, ans);\\n            }\\n            v[cards[i]] = i;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        vector<int> v(1000001, -1);\\n        int ans = INT_MAX;\\n        for (int i = 0; i < cards.size(); i++) {\\n            if (v[cards[i]] != -1) {\\n                ans = min(i - v[cards[i]] + 1, ans);\\n            }\\n            v[cards[i]] = i;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948260,
                "title": "beats-run-time-70-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        hashmap = defaultdict(int)\\n        min_num = len(cards) + 1 \\n        i = 0\\n\\n        for j in range(len(cards)):\\n            hashmap[cards[j]] += 1\\n            if hashmap[cards[j]] == 2: \\n                while(hashmap[cards[j]]>1):\\n                    hashmap[cards[i]] -= 1\\n                    i += 1\\n                min_num = min(min_num,j-i+2)\\n        if min_num == len(cards)+1:\\n            return -1\\n        return min_num\\n\\n\\n\\n             \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        hashmap = defaultdict(int)\\n        min_num = len(cards) + 1 \\n        i = 0\\n\\n        for j in range(len(cards)):\\n            hashmap[cards[j]] += 1\\n            if hashmap[cards[j]] == 2: \\n                while(hashmap[cards[j]]>1):\\n                    hashmap[cards[i]] -= 1\\n                    i += 1\\n                min_num = min(min_num,j-i+2)\\n        if min_num == len(cards)+1:\\n            return -1\\n        return min_num\\n\\n\\n\\n             \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936349,
                "title": "very-easy-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} cards\\n * @return {number}\\n */\\nvar minimumCardPickup = function(cards) {\\n\\n  let map = new Map();\\n    let minDistance = Infinity;\\n    for (let i = 0; i < cards.length; i++) {\\n        if (map.has(cards[i])) {\\n            let lastIndex = map.get(cards[i]);\\n            let currentDistance = i - lastIndex;\\n            minDistance = Math.min(minDistance, currentDistance);\\n        }\\n        map.set(cards[i], i);\\n    }\\n    \\n    if (minDistance === Infinity) {\\n        return -1; \\n    }\\n    \\n    return minDistance + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cards\\n * @return {number}\\n */\\nvar minimumCardPickup = function(cards) {\\n\\n  let map = new Map();\\n    let minDistance = Infinity;\\n    for (let i = 0; i < cards.length; i++) {\\n        if (map.has(cards[i])) {\\n            let lastIndex = map.get(cards[i]);\\n            let currentDistance = i - lastIndex;\\n            minDistance = Math.min(minDistance, currentDistance);\\n        }\\n        map.set(cards[i], i);\\n    }\\n    \\n    if (minDistance === Infinity) {\\n        return -1; \\n    }\\n    \\n    return minDistance + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930893,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size(),i = 0,j = 0,mnLen = INT_MAX;\\n        unordered_map<int,int> mp;\\n        while(j < n){\\n            mp[cards[j]]++;\\n            if(mp.size() == j-i+1) j++;\\n            else{\\n                while(mp.size() < j-i+1){\\n                    mp[cards[i]]--;\\n                    if(mp[cards[i]] == 0) mp.erase(cards[i]);\\n                    i++;\\n                }\\n                mnLen = min(mnLen,(j++) -i+2);\\n            }\\n        }\\n        \\n        if(mnLen == INT_MAX) return -1;\\n        return mnLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n = cards.size(),i = 0,j = 0,mnLen = INT_MAX;\\n        unordered_map<int,int> mp;\\n        while(j < n){\\n            mp[cards[j]]++;\\n            if(mp.size() == j-i+1) j++;\\n            else{\\n                while(mp.size() < j-i+1){\\n                    mp[cards[i]]--;\\n                    if(mp[cards[i]] == 0) mp.erase(cards[i]);\\n                    i++;\\n                }\\n                mnLen = min(mnLen,(j++) -i+2);\\n            }\\n        }\\n        \\n        if(mnLen == INT_MAX) return -1;\\n        return mnLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928290,
                "title": "beats-100-c-78-ms-sol",
                "content": "# Approach\\n\\n- Initialize a vector lastPosition to store the last index of each encountered card.\\n- Traverse through the cards array:\\n  - When a matching card is encountered:\\n    - To calculate the distance, we just subtract the stored last position from the current position.\\n   - Then we update the lastPosition list with the current index, so we\\'re ready for the next time we see this card\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(max_card)\\n\\n# Code\\n```\\nauto x = []() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int maxCard = *max_element(cards.begin(), cards.end());\\n        vector<int> last_occur(maxCard + 1, -1);\\n        int minm = cards.size() + 1;\\n\\n        for (int i = 0; i < cards.size(); i++) {\\n            int card = cards[i];\\n            if (last_occur[card] >= 0) {\\n                minm = min(minm, i - last_occur[card] + 1);\\n            }\\n            last_occur[card] = i;\\n        }\\n\\n        return (minm <= cards.size()) ? minm : -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nauto x = []() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int maxCard = *max_element(cards.begin(), cards.end());\\n        vector<int> last_occur(maxCard + 1, -1);\\n        int minm = cards.size() + 1;\\n\\n        for (int i = 0; i < cards.size(); i++) {\\n            int card = cards[i];\\n            if (last_occur[card] >= 0) {\\n                minm = min(minm, i - last_occur[card] + 1);\\n            }\\n            last_occur[card] = i;\\n        }\\n\\n        return (minm <= cards.size()) ? minm : -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926267,
                "title": "sliding-window-with-using-hash-table-solution-easy-solution-and-understandeble",
                "content": "\\n# Approach\\nThis is easy task if you know sliding window approach and hash table data structure. For a start we need create our hash table I recomend for the task use Set, bacuse it keeps only unique values. Next we just create our loop where we are checking that there was some item in our Set, if not just add this item else we need to calculate the size using $$Window size - 1 = WindowEnd - WindowStart$$ and just get minSize comparing current size and minSize, after that we are going to shrink our sub array while we have an item in our Set. In the end we just check our min Size and return -1 if nothing changes or final result\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minimumCardPickup(cards: number[]): number {\\n    let minLength = Infinity;\\n    let start = 0;\\n    const setOfNumber = new Set();\\n\\n    for (let end = 0; end < cards.length; end++) {\\n        while (setOfNumber.has(cards[end])) {\\n            const size = (end - start) + 1;\\n            minLength = Math.min(minLength, size);\\n            setOfNumber.delete(cards[start]);\\n            start += 1;\\n        }\\n\\n        setOfNumber.add(cards[end]);\\n    }\\n\\n    return minLength !== Infinity ? minLength : -1;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nfunction minimumCardPickup(cards: number[]): number {\\n    let minLength = Infinity;\\n    let start = 0;\\n    const setOfNumber = new Set();\\n\\n    for (let end = 0; end < cards.length; end++) {\\n        while (setOfNumber.has(cards[end])) {\\n            const size = (end - start) + 1;\\n            minLength = Math.min(minLength, size);\\n            setOfNumber.delete(cards[start]);\\n            start += 1;\\n        }\\n\\n        setOfNumber.add(cards[end]);\\n    }\\n\\n    return minLength !== Infinity ? minLength : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921814,
                "title": "python-easy-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to find minimum length of consecutive integers that satifies some condition, we can use sliding window algorithm\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart left and right pointers of the window at 0\\ndeclare a set data structure (seen) to look up if the card that we encountered just now is already encountered before\\nrun a while loop \\nand check if the current card is already present in the seen set \\nif it is present \\nremove the card from the seen set and update the left pointer and calculate the size of the window( Note: size of window is size of window+1 because we need consider the window with the duplicate card)\\nif its not present \\nadd the card to the seen set and increment the right pointer \\nreturn the minimum value of the window \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) (please correct if it wrong)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        l = 0\\n        r = 0\\n        window = len(cards)\\n        seen = set()\\n\\n        while r < len(cards):\\n            \\n            if cards[r] in seen:\\n                while seen and cards[r] in seen:\\n                    seen.remove(cards[l])\\n                    l+=1\\n                window = min(window, r-l+1 + 1)\\n\\n            seen.add(cards[r])\\n            r+=1\\n        \\n        if len(seen) == len(cards):\\n            return -1\\n        else:\\n            return window\\n\\n        \\n                \\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCardPickup(self, cards: List[int]) -> int:\\n        l = 0\\n        r = 0\\n        window = len(cards)\\n        seen = set()\\n\\n        while r < len(cards):\\n            \\n            if cards[r] in seen:\\n                while seen and cards[r] in seen:\\n                    seen.remove(cards[l])\\n                    l+=1\\n                window = min(window, r-l+1 + 1)\\n\\n            seen.add(cards[r])\\n            r+=1\\n        \\n        if len(seen) == len(cards):\\n            return -1\\n        else:\\n            return window\\n\\n        \\n                \\n\\n            \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1804166,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1734621,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1872576,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 2051785,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1989256,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1927041,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1899293,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1817210,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1719561,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1699964,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1804166,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1734621,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1872576,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 2051785,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1989256,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1927041,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1899293,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1817210,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1719561,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            },
            {
                "id": 1699964,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "This one should be marked as easy"
                    },
                    {
                        "username": "hahahamid",
                        "content": "They did ask me this problem in a Dalberg Interview for Software Engineer Intern role lol "
                    },
                    {
                        "username": "heyyyankit",
                        "content": "it\\'s showing it was also asked in google"
                    },
                    {
                        "username": "pascal_fuettern",
                        "content": "Simplest solution does not require sliding window."
                    },
                    {
                        "username": "akash__2001",
                        "content": "easy one "
                    },
                    {
                        "username": "eduard92",
                        "content": "Text is medium\\nSolution is easy\\nDon\\'t overthink"
                    },
                    {
                        "username": "pseudocodeank",
                        "content": "this is very easy."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "Just iterate from array starting index to ending index.\\nif the index element is not present in Hashmap then insert it into hashmap, else check the distance between index of its first appearance and current index if the distance is less then update the distance and update the index to current index. "
                    },
                    {
                        "username": "uavishal777",
                        "content": "Why my Code is only passing 75/80 cases?\\n\\n\\nclass Solution {\\npublic:\\n    int minimumCardPickup(vector<int>& cards) {\\n        int n=cards.size();\\n        map<int,pair<int,int>>mp;\\n        int ans=INT_MAX;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            int len=j-i+1;\\n            if(mp.find(cards[j])==mp.end()){\\n                mp[cards[j]].first++;\\n                mp[cards[j]].second=j;\\n            }\\n            else if(mp.find(cards[j])!=mp.end()){\\n                auto it=mp[cards[j]];\\n                it.first++;\\n                ans=min(ans,j-it.second+1);\\n                it.second=j;\\n            }\\n            j++;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mayankesh",
                        "content": "Try to remove \\'else if \\' in below line.\\n \\nelse if(mp.find(cards[j])!=mp.end())\\n\\nyou are not updating index when second time number occurs."
                    },
                    {
                        "username": "sharma_1901530100039",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        \\n        int n = cards.length;\\n        int ans = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < n;i++){\\n            if(map.containsKey(cards[i])){\\n                int val = map.get(cards[i]);\\n                int moves = (i-val + 1);\\n                ans = Math.min(moves,ans);\\n                map.put(cards[i],i);\\n            }else{\\n                map.put(cards[i],i);\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "zadbuke",
                        "content": "Is it possible to do this with a 2 pointer, set solution - something like this. I thought it was possible and wrote a solution. It passed 64 tests but then I re-evaluated and switched to hashmap track last solution. Anyone managed to do this with hashsets?"
                    }
                ]
            }
        ]
    }
]