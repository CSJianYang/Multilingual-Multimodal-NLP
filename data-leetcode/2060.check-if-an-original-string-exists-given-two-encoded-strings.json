[
    {
        "title": "Check if an Original String Exists Given Two Encoded Strings",
        "question_content": "An original string, consisting of lowercase English letters, can be encoded by the following steps:\n\n\tArbitrarily split it into a sequence of some number of non-empty substrings.\n\tArbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string).\n\tConcatenate the sequence as the encoded string.\n\nFor example, one way to encode an original string \"abcdefghijklmnop\" might be:\n\n\tSplit it as a sequence: [\"ab\", \"cdefghijklmn\", \"o\", \"p\"].\n\tChoose the second and third elements to be replaced by their lengths, respectively. The sequence becomes [\"ab\", \"12\", \"1\", \"p\"].\n\tConcatenate the elements of the sequence to get the encoded string: \"ab121p\".\n\nGiven two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false.\nNote: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3.\n&nbsp;\nExample 1:\n\nInput: s1 = \"internationalization\", s2 = \"i18n\"\nOutput: true\nExplanation: It is possible that \"internationalization\" was the original string.\n- \"internationalization\" \n  -> Split:       [\"internationalization\"]\n  -> Do not replace any element\n  -> Concatenate:  \"internationalization\", which is s1.\n- \"internationalization\"\n  -> Split:       [\"i\", \"nternationalizatio\", \"n\"]\n  -> Replace:     [\"i\", \"18\",                 \"n\"]\n  -> Concatenate:  \"i18n\", which is s2\n\nExample 2:\n\nInput: s1 = \"l123e\", s2 = \"44\"\nOutput: true\nExplanation: It is possible that \"leetcode\" was the original string.\n- \"leetcode\" \n  -> Split:      [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n  -> Replace:    [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n  -> Concatenate: \"l123e\", which is s1.\n- \"leetcode\" \n  -> Split:      [\"leet\", \"code\"]\n  -> Replace:    [\"4\",    \"4\"]\n  -> Concatenate: \"44\", which is s2.\n\nExample 3:\n\nInput: s1 = \"a5b\", s2 = \"c5b\"\nOutput: false\nExplanation: It is impossible.\n- The original string encoded as s1 must start with the letter 'a'.\n- The original string encoded as s2 must start with the letter 'c'.\n\n&nbsp;\nConstraints:\n\n\t1 <= s1.length, s2.length <= 40\n\ts1 and s2 consist of digits 1-9 (inclusive), and lowercase English letters only.\n\tThe number of consecutive digits in s1 and s2 does not exceed 3.",
        "solutions": [
            {
                "id": 1550342,
                "title": "java-clean-dfs-memo",
                "content": "While it is not that `clean` as python, many corner cases.\\nThe thinking solution is straight forward we have 2 pointer in each string\\n1. consider the easy case, they all character, we compare `s1.charAt(i) == s2.charAt(j)`\\n2. digit case, we get a number from s1, we can calculate the number s1 has, (descripton said less than 1000), we can pass this value compare with number from s2 name it diff\\n3. character case if we still has remaing diff to spend passed from our parents, so we can use one dollor a day, one diff one position  `dfs(i + 1, j, diff - 1`\\n4. terminating condition, if both reach the end and `diff == 0`\\n\\nIt really took me 2 hours to figure this out, if you like it please click the upper arrow, that\\'s a great support to my motivation to continue write solution in `clean` Java.\\n\\n```\\n//387 ms\\nclass Solution {\\n    String s1;\\n    String s2;\\n    Boolean[][][] memo = new Boolean[41][41][2000];\\n    public boolean possiblyEquals(String s1, String s2) {\\n        this.s1 = s1;\\n        this.s2 = s2;\\n        return dfs(0, 0, 0); //s1 pointer, s1 pointer, digit difference\\n    }\\n    \\n    private boolean dfs(int i, int j, int diff) {\\n        if (i >= s1.length() && j >= s2.length() && diff == 0) return true;\\n        if (memo[i][j][diff + 1000] != null) return memo[i][j][diff + 1000];\\n        boolean res = false;\\n        if (i < s1.length()) {\\n            if (Character.isDigit(s1.charAt(i))) {\\n                int count = 0, value = 0; //be careful we can not change i cause s2 will use i again\\n                while (i + count < s1.length() && count < 3 && Character.isDigit(s1.charAt(i + count))) {\\n                    value = value * 10 + (s1.charAt(i + count) - \\'0\\');\\n                    count++;\\n                    if (dfs(i + count, j, diff - value)) res = true;\\n                }\\n            } else {\\n                if (diff > 0) {\\n                    if (dfs(i + 1, j, diff - 1)) res = true;\\n                } else if (diff == 0 && j < s2.length() && s1.charAt(i) == s2.charAt(j)) {\\n                    if (dfs(i + 1, j + 1, diff)) res = true;\\n                }\\n            }\\n        }\\n        if (j < s2.length()) {\\n            if (Character.isDigit(s2.charAt(j))) {\\n                int count = 0, value = 0;\\n                while (j + count < s2.length() && count < 3 && Character.isDigit(s2.charAt(j + count))) {\\n                    value = value * 10 + (s2.charAt(j + count) - \\'0\\');\\n                    count++;\\n                    if (dfs(i, j + count, diff + value)) res = true;\\n                }\\n            } else if (diff < 0 && dfs(i, j + 1, diff + 1)) res = true;\\n        }\\n        return memo[i][j][diff + 1000] = res;\\n    }\\n}\\n```\\n\\ncopy new neat answer from @tttyyy49, thanks!\\n\\n```\\nclass Solution {\\n    //112ms\\n    public boolean possiblyEquals(String s1, String s2) {\\n        int l1 = s1.length();\\n        int l2 = s2.length();\\n        \\n        // dp[i][j][diff] means if s1[i:] truncated by <diff> characters if diff > 0 \\n        // and s2[j:] truncated by <-diff> characters if diff < 0 are equal\\n        Boolean[][][] dp = new Boolean[l1 + 1][l2 + 1][2000]; \\n        return dfs(0, 0, 0, s1.toCharArray(), s2.toCharArray(), dp);\\n    }\\n    \\n    private boolean dfs(int i, int j, int diff, char[] s1, char[] s2, Boolean[][][] dp) {\\n        if (i == s1.length && j == s2.length) {\\n            return diff == 0;\\n        }\\n        \\n        if (dp[i][j][diff + 1000] != null) return dp[i][j][diff + 1000];\\n        \\n        // Literal matching on s1[i] and s2[j]\\n        if (i < s1.length && j < s2.length && diff == 0 && s1[i] == s2[j]) {\\n            if (dfs(i + 1, j + 1, 0, s1, s2, dp)) {\\n                return dp[i][j][1000] = true;\\n            }\\n        }\\n        \\n        // Literal matching on s1[i]\\n        if (i < s1.length && !isDigit(s1[i]) && diff > 0 && dfs(i + 1, j, diff - 1, s1, s2, dp)) {\\n            return dp[i][j][diff + 1000] = true;\\n        }\\n        \\n        // Literal matching on s2[j]\\n        if (j < s2.length && !isDigit(s2[j]) && diff < 0 && dfs(i, j + 1, diff + 1, s1, s2, dp)) {\\n            return dp[i][j][diff + 1000] = true;\\n        }\\n        \\n        // Wildcard matching on s1[i]\\n        for (int k = i, val = 0; k < s1.length && isDigit(s1[k]); ++k) {\\n            val = val * 10 + (s1[k] - \\'0\\');\\n            if (dfs(k + 1, j, diff - val, s1, s2, dp)) {\\n                return dp[i][j][diff + 1000] = true;\\n            }\\n        }\\n        \\n        // Wildcard matching on s2[j]\\n        for (int k = j, val = 0; k < s2.length && isDigit(s2[k]); ++k) {\\n            val = val * 10 + (s2[k] - \\'0\\');\\n            if (dfs(i, k + 1, diff + val, s1, s2, dp)) {\\n                return dp[i][j][diff + 1000] = true;\\n            }\\n        }\\n        \\n        return dp[i][j][diff + 1000] = false;\\n    }\\n    \\n    private boolean isDigit(char c) {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//387 ms\\nclass Solution {\\n    String s1;\\n    String s2;\\n    Boolean[][][] memo = new Boolean[41][41][2000];\\n    public boolean possiblyEquals(String s1, String s2) {\\n        this.s1 = s1;\\n        this.s2 = s2;\\n        return dfs(0, 0, 0); //s1 pointer, s1 pointer, digit difference\\n    }\\n    \\n    private boolean dfs(int i, int j, int diff) {\\n        if (i >= s1.length() && j >= s2.length() && diff == 0) return true;\\n        if (memo[i][j][diff + 1000] != null) return memo[i][j][diff + 1000];\\n        boolean res = false;\\n        if (i < s1.length()) {\\n            if (Character.isDigit(s1.charAt(i))) {\\n                int count = 0, value = 0; //be careful we can not change i cause s2 will use i again\\n                while (i + count < s1.length() && count < 3 && Character.isDigit(s1.charAt(i + count))) {\\n                    value = value * 10 + (s1.charAt(i + count) - \\'0\\');\\n                    count++;\\n                    if (dfs(i + count, j, diff - value)) res = true;\\n                }\\n            } else {\\n                if (diff > 0) {\\n                    if (dfs(i + 1, j, diff - 1)) res = true;\\n                } else if (diff == 0 && j < s2.length() && s1.charAt(i) == s2.charAt(j)) {\\n                    if (dfs(i + 1, j + 1, diff)) res = true;\\n                }\\n            }\\n        }\\n        if (j < s2.length()) {\\n            if (Character.isDigit(s2.charAt(j))) {\\n                int count = 0, value = 0;\\n                while (j + count < s2.length() && count < 3 && Character.isDigit(s2.charAt(j + count))) {\\n                    value = value * 10 + (s2.charAt(j + count) - \\'0\\');\\n                    count++;\\n                    if (dfs(i, j + count, diff + value)) res = true;\\n                }\\n            } else if (diff < 0 && dfs(i, j + 1, diff + 1)) res = true;\\n        }\\n        return memo[i][j][diff + 1000] = res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    //112ms\\n    public boolean possiblyEquals(String s1, String s2) {\\n        int l1 = s1.length();\\n        int l2 = s2.length();\\n        \\n        // dp[i][j][diff] means if s1[i:] truncated by <diff> characters if diff > 0 \\n        // and s2[j:] truncated by <-diff> characters if diff < 0 are equal\\n        Boolean[][][] dp = new Boolean[l1 + 1][l2 + 1][2000]; \\n        return dfs(0, 0, 0, s1.toCharArray(), s2.toCharArray(), dp);\\n    }\\n    \\n    private boolean dfs(int i, int j, int diff, char[] s1, char[] s2, Boolean[][][] dp) {\\n        if (i == s1.length && j == s2.length) {\\n            return diff == 0;\\n        }\\n        \\n        if (dp[i][j][diff + 1000] != null) return dp[i][j][diff + 1000];\\n        \\n        // Literal matching on s1[i] and s2[j]\\n        if (i < s1.length && j < s2.length && diff == 0 && s1[i] == s2[j]) {\\n            if (dfs(i + 1, j + 1, 0, s1, s2, dp)) {\\n                return dp[i][j][1000] = true;\\n            }\\n        }\\n        \\n        // Literal matching on s1[i]\\n        if (i < s1.length && !isDigit(s1[i]) && diff > 0 && dfs(i + 1, j, diff - 1, s1, s2, dp)) {\\n            return dp[i][j][diff + 1000] = true;\\n        }\\n        \\n        // Literal matching on s2[j]\\n        if (j < s2.length && !isDigit(s2[j]) && diff < 0 && dfs(i, j + 1, diff + 1, s1, s2, dp)) {\\n            return dp[i][j][diff + 1000] = true;\\n        }\\n        \\n        // Wildcard matching on s1[i]\\n        for (int k = i, val = 0; k < s1.length && isDigit(s1[k]); ++k) {\\n            val = val * 10 + (s1[k] - \\'0\\');\\n            if (dfs(k + 1, j, diff - val, s1, s2, dp)) {\\n                return dp[i][j][diff + 1000] = true;\\n            }\\n        }\\n        \\n        // Wildcard matching on s2[j]\\n        for (int k = j, val = 0; k < s2.length && isDigit(s2[k]); ++k) {\\n            val = val * 10 + (s2[k] - \\'0\\');\\n            if (dfs(i, k + 1, diff + val, s1, s2, dp)) {\\n                return dp[i][j][diff + 1000] = true;\\n            }\\n        }\\n        \\n        return dp[i][j][diff + 1000] = false;\\n    }\\n    \\n    private boolean isDigit(char c) {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550012,
                "title": "python3-dp",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/4001168494179e85482f91afbf0cd66b908544f3) for my solutions of weekly 265. \\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\n        def gg(s): \\n            \"\"\"Return possible length\"\"\"\\n            ans = [int(s)]\\n            if len(s) == 2: \\n                if s[1] != \\'0\\': ans.append(int(s[0]) + int(s[1]))\\n                return ans\\n            elif len(s) == 3: \\n                if s[1] != \\'0\\': ans.append(int(s[:1]) + int(s[1:]))\\n                if s[2] != \\'0\\': ans.append(int(s[:2]) + int(s[2:]))\\n                if s[1] != \\'0\\' and s[2] != \\'0\\': ans.append(int(s[0]) + int(s[1]) + int(s[2]))\\n            return ans \\n        \\n        @cache\\n        def fn(i, j, diff): \\n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n            if i == len(s1) and j == len(s2): return diff == 0\\n            if i < len(s1) and s1[i].isdigit(): \\n                ii = i\\n                while ii < len(s1) and s1[ii].isdigit(): ii += 1\\n                for x in gg(s1[i:ii]): \\n                    if fn(ii, j, diff-x): return True \\n            elif j < len(s2) and s2[j].isdigit(): \\n                jj = j \\n                while jj < len(s2) and s2[jj].isdigit(): jj += 1\\n                for x in gg(s2[j:jj]): \\n                    if fn(i, jj, diff+x): return True \\n            elif diff == 0: \\n                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \\n                return fn(i+1, j+1, 0)\\n            elif diff > 0: \\n                if i == len(s1): return False \\n                return fn(i+1, j, diff-1)\\n            else: \\n                if j == len(s2): return False \\n                return fn(i, j+1, diff+1)\\n            \\n        return fn(0, 0, 0)\\n```\\n\\nUpdated implementation per @lee215, @alexeykonphoto and @lichuan199010. \\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\n        def gg(s): \\n            \"\"\"Return possible length.\"\"\"\\n            ans = {int(s)}\\n            for i in range(1, len(s)): \\n                ans |= {x+y for x in gg(s[:i]) for y in gg(s[i:])}\\n            return ans\\n        \\n        @cache\\n        def fn(i, j, diff): \\n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n            if i == len(s1) and j == len(s2): return diff == 0\\n            if i < len(s1) and s1[i].isdigit(): \\n                ii = i\\n                while ii < len(s1) and s1[ii].isdigit(): ii += 1\\n                for x in gg(s1[i:ii]): \\n                    if fn(ii, j, diff-x): return True \\n            elif j < len(s2) and s2[j].isdigit(): \\n                jj = j \\n                while jj < len(s2) and s2[jj].isdigit(): jj += 1\\n                for x in gg(s2[j:jj]): \\n                    if fn(i, jj, diff+x): return True \\n            elif diff == 0: \\n                if i < len(s1) and j < len(s2) and s1[i] == s2[j]: return fn(i+1, j+1, 0)\\n            elif diff > 0: \\n                if i < len(s1): return fn(i+1, j, diff-1)\\n            else: \\n                if j < len(s2): return fn(i, j+1, diff+1)\\n            return False \\n            \\n        return fn(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\n        def gg(s): \\n            \"\"\"Return possible length\"\"\"\\n            ans = [int(s)]\\n            if len(s) == 2: \\n                if s[1] != \\'0\\': ans.append(int(s[0]) + int(s[1]))\\n                return ans\\n            elif len(s) == 3: \\n                if s[1] != \\'0\\': ans.append(int(s[:1]) + int(s[1:]))\\n                if s[2] != \\'0\\': ans.append(int(s[:2]) + int(s[2:]))\\n                if s[1] != \\'0\\' and s[2] != \\'0\\': ans.append(int(s[0]) + int(s[1]) + int(s[2]))\\n            return ans \\n        \\n        @cache\\n        def fn(i, j, diff): \\n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n            if i == len(s1) and j == len(s2): return diff == 0\\n            if i < len(s1) and s1[i].isdigit(): \\n                ii = i\\n                while ii < len(s1) and s1[ii].isdigit(): ii += 1\\n                for x in gg(s1[i:ii]): \\n                    if fn(ii, j, diff-x): return True \\n            elif j < len(s2) and s2[j].isdigit(): \\n                jj = j \\n                while jj < len(s2) and s2[jj].isdigit(): jj += 1\\n                for x in gg(s2[j:jj]): \\n                    if fn(i, jj, diff+x): return True \\n            elif diff == 0: \\n                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \\n                return fn(i+1, j+1, 0)\\n            elif diff > 0: \\n                if i == len(s1): return False \\n                return fn(i+1, j, diff-1)\\n            else: \\n                if j == len(s2): return False \\n                return fn(i, j+1, diff+1)\\n            \\n        return fn(0, 0, 0)\\n```\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\n        def gg(s): \\n            \"\"\"Return possible length.\"\"\"\\n            ans = {int(s)}\\n            for i in range(1, len(s)): \\n                ans |= {x+y for x in gg(s[:i]) for y in gg(s[i:])}\\n            return ans\\n        \\n        @cache\\n        def fn(i, j, diff): \\n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n            if i == len(s1) and j == len(s2): return diff == 0\\n            if i < len(s1) and s1[i].isdigit(): \\n                ii = i\\n                while ii < len(s1) and s1[ii].isdigit(): ii += 1\\n                for x in gg(s1[i:ii]): \\n                    if fn(ii, j, diff-x): return True \\n            elif j < len(s2) and s2[j].isdigit(): \\n                jj = j \\n                while jj < len(s2) and s2[jj].isdigit(): jj += 1\\n                for x in gg(s2[j:jj]): \\n                    if fn(i, jj, diff+x): return True \\n            elif diff == 0: \\n                if i < len(s1) and j < len(s2) and s1[i] == s2[j]: return fn(i+1, j+1, 0)\\n            elif diff > 0: \\n                if i < len(s1): return fn(i+1, j, diff-1)\\n            else: \\n                if j < len(s2): return fn(i, j+1, diff+1)\\n            return False \\n            \\n        return fn(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551731,
                "title": "dfs",
                "content": "This problem sounds intimidating, and you need a bit of patience to unpack it. \\n\\nTo match the strings, we need to track the current indices `i` and `j`, as well as the number of \"wildcard\" characters.\\n\\n> Since wildcard characters cancel each out, we just need to track the difference (`diff`). Negative value means the first string has wildcards, positive - the other one.\\n\\nWe need to consider three cases:\\n1. `i` or `j` points to a digit:\\n\\t- we get all adjacent digits (up to 3), and generate possible numbers.\\n\\t- we advance the pointer and adjust `diff`, then continue with the recursion.\\n2. both `i` and `j` point to a letter (or end of the string), and `diff != 0`\\n\\t- we match one wildcard character with a letter in another string.\\n3. both `i` and `j` point to a letter, and `diff == 0`\\n\\t- We match two letters.\\n\\n> Node about memoisation. Since the number of skips is limited to `999`, and we only care about the difference, we will have no more than `2000` options (`[-999, 999]`).\\n\\n**C++**\\n```cpp\\nbool visited[41][41][2000] = {};\\nbool possiblyEquals(string &s1, string &s2, int i = 0, int j = 0, int diff = 0) {\\n    auto processDigits = [&](const string &s, int &p, int sign) {\\n        for (int val = 0; p < s.size() && isdigit(s[p]);) {\\n            val = val * 10 + (s[p++] - \\'0\\');\\n            if (possiblyEquals(s1, s2, i, j, diff + val * sign))\\n                return true;\\n        }\\n        return false;\\n    };\\n    if (i == s1.size() && j == s2.size())\\n        return diff == 0;\\n    if (!visited[i][j][1000 + diff]) {\\n        visited[i][j][1000 + diff] = true;\\n        if (i < s1.size() && isdigit(s1[i]))\\n            return processDigits(s1, i, -1);\\n        if (j < s2.size() && isdigit(s2[j]))\\n            return processDigits(s2, j, 1);\\n        if (diff > 0)\\n            return i < s1.size() && possiblyEquals(s1, s2, i + 1, j, diff - 1);\\n        if (diff < 0)\\n            return j < s2.size() && possiblyEquals(s1, s2, i, j + 1, diff + 1);\\n        return i < s1.size() && j < s2.size() && s1[i] == s2[j] && possiblyEquals(s1, s2, i + 1, j + 1, diff);\\n    }\\n    return false;\\n}   \\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool visited[41][41][2000] = {};\\nbool possiblyEquals(string &s1, string &s2, int i = 0, int j = 0, int diff = 0) {\\n    auto processDigits = [&](const string &s, int &p, int sign) {\\n        for (int val = 0; p < s.size() && isdigit(s[p]);) {\\n            val = val * 10 + (s[p++] - \\'0\\');\\n            if (possiblyEquals(s1, s2, i, j, diff + val * sign))\\n                return true;\\n        }\\n        return false;\\n    };\\n    if (i == s1.size() && j == s2.size())\\n        return diff == 0;\\n    if (!visited[i][j][1000 + diff]) {\\n        visited[i][j][1000 + diff] = true;\\n        if (i < s1.size() && isdigit(s1[i]))\\n            return processDigits(s1, i, -1);\\n        if (j < s2.size() && isdigit(s2[j]))\\n            return processDigits(s2, j, 1);\\n        if (diff > 0)\\n            return i < s1.size() && possiblyEquals(s1, s2, i + 1, j, diff - 1);\\n        if (diff < 0)\\n            return j < s2.size() && possiblyEquals(s1, s2, i, j + 1, diff + 1);\\n        return i < s1.size() && j < s2.size() && s1[i] == s2[j] && possiblyEquals(s1, s2, i + 1, j + 1, diff);\\n    }\\n    return false;\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629836,
                "title": "python-top-down-dp-steps-simplified-commented-90-98-time-72-42-mem",
                "content": "This is a simplfication of the approach provided by [@ye15](https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550012/Python3-dp)\\n# Preliminaries\\n1. To get the ending index of the numeric substring of \\'s\\' starting at \\'start\\'; we use the following code:-\\n```\\ndef getValidPrefixLength(s,start):\\n\\tend = start\\n\\twhile end < len(s) and s[end].isdigit(): end += 1\\n\\treturn end\\n```\\n2.  To get all possibles lengths that the numeric substrings \\'s\\' could represent we use the following code:-\\n```\\n@lru_cache(None)\\ndef possibleLengths(s): \\n\\t\"\"\"Return all possible lengths represented by numeric string s.\"\"\"\\n\\tlengths = {int(s)}\\n\\tfor i in range(1, len(s)):\\n\\t\\t# add all lengths by splitting numeric string s at index i\\n\\t\\t# & sum of first split part(i.e. x) and second split part(i.e. y) gives the answer\\n\\t\\tlengths |= {x+y for x in possibleLengths(s[:i]) for y in possibleLengths(s[i:])}\\n\\treturn length\\n```\\n# Main Logic\\nThe main logic is implement a top-down dynamic programming based approach that takes in current pointers of both strings \\'s1\\' & \\'s2\\' as well as the amount of prefix length lead that s2 has over s1. We consider 6 cases in the **dp** in the following order.\\n1. both have reached end, \\n2. s1 has not reached end & s1 has numeric prefix,\\n3. s2 has not reached end & s2 has numeric prefix,\\n4. There is no prefix lead difference between s1 & s2,\\n5. s2 leads over s1,\\n6. s1 leads over s2.\\n\\nBelow is the self-explanatory commented code telling how these cases are implemented.\\n\\n```\\n@lru_cache(None)\\ndef dp(i, j, diff):             \\n\\t\"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n\\n\\t# If both have reached end return true if none of them are leading\\n\\tif i == len(s1) and j == len(s2): return diff == 0\\n\\n\\t# s1 has not reached end and s1 starts with a digit\\n\\tif i < len(s1) and s1[i].isdigit(): \\n\\t\\ti2 = getValidPrefixLength(s1,i)\\n\\t\\tfor L in possibleLengths(s1[i:i2]): \\n\\t\\t\\t# substract since lead of s2  decreases by L\\n\\t\\t\\tif dp(i2, j, diff-L): return True \\n\\n\\t# s2 has not reached end and s2 starts with a digit\\n\\telif j < len(s2) and s2[j].isdigit(): \\n\\t\\tj2 = getValidPrefixLength(s2,j)\\n\\t\\tfor L in possibleLengths(s2[j:j2]): \\n\\t\\t\\t# add since lead of s2 increases by L\\n\\t\\t\\tif dp(i, j2, diff+L): return True \\n\\n\\t# if none of them have integer prefix or a lead over the other\\n\\telif diff == 0: \\n\\t\\t# if only one of them has reached end or current alphabets are not the same \\n\\t\\tif i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \\n\\t\\t# skip same alphabets\\n\\t\\treturn dp(i+1, j+1, 0)\\n\\n\\t# if none of them have integer prefix & s2 lead over s1 \\n\\telif diff > 0: \\n\\t\\t# no s1 to balance s2\\'s lead\\n\\t\\tif i == len(s1): return False\\n\\t\\t# move s1 pointer forward and reduce diff\\n\\t\\treturn dp(i+1, j, diff-1)\\n\\n\\t# if none of them have integer prefix & s1 lead over s2\\n\\telse: \\n\\t\\t# no s2 to balance s1\\'s lead\\n\\t\\tif j == len(s2): return False \\n\\t\\t# move s2 pointer forward and increase diff\\n\\t\\treturn dp(i, j+1, diff+1)\\n```\\nFinally, we call the function as dp(0,0,0)\\nThe main code looks likes:- \\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\n        def getValidPrefixLength(s,start):\\n            end = start\\n            while end < len(s) and s[end].isdigit(): end += 1\\n            return end\\n        \\n        @lru_cache(None)\\n        def possibleLengths(s): \\n            \"\"\"Return all possible lengths represented by numeric string s.\"\"\"\\n            ans = {int(s)}\\n            for i in range(1, len(s)):\\n                # add all lengths by splitting numeric string s at i\\n                ans |= {x+y for x in possibleLengths(s[:i]) for y in possibleLengths(s[i:])}\\n            return ans\\n        \\n        @lru_cache(None)\\n        def dp(i, j, diff):             \\n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n            \\n            # If both have reached end return true if none of them are leading\\n            if i == len(s1) and j == len(s2): return diff == 0\\n            \\n            # s1 has not reached end and s1 starts with a digit\\n            if i < len(s1) and s1[i].isdigit(): \\n                i2 = getValidPrefixLength(s1,i)\\n                for L in possibleLengths(s1[i:i2]): \\n                    # substract since lead of s2  decreases by L\\n                    if dp(i2, j, diff-L): return True \\n            \\n            # s2 has not reached end and s2 starts with a digit\\n            elif j < len(s2) and s2[j].isdigit(): \\n                j2 = getValidPrefixLength(s2,j)\\n                for L in possibleLengths(s2[j:j2]): \\n                    # add since lead of s2 increase by L\\n                    if dp(i, j2, diff+L): return True \\n            \\n            # if none of them have integer prefix or a lead over the other\\n            elif diff == 0: \\n                # if only one of them has reached end or current alphabets are not the same \\n                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \\n                # skip same alphabets\\n                return dp(i+1, j+1, 0)\\n            \\n            # if none of them have integer prefix & s2 lead over s1 \\n            elif diff > 0: \\n                # no s1 to balance s2\\'s lead\\n                if i == len(s1): return False\\n                # move s1 pointer forward and reduce diff\\n                return dp(i+1, j, diff-1)\\n            \\n            # if none of them have integer prefix & s1 lead over s2\\n            else: \\n                # no s2 to balance s1\\'s lead\\n                if j == len(s2): return False \\n                # move s2 pointer forward and increase diff\\n                return dp(i, j+1, diff+1)\\n        \\n        # start with starts of both s1 and s2 with no lead by any of them\\n        return dp(0, 0, 0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef getValidPrefixLength(s,start):\\n\\tend = start\\n\\twhile end < len(s) and s[end].isdigit(): end += 1\\n\\treturn end\\n```\n```\\n@lru_cache(None)\\ndef possibleLengths(s): \\n\\t\"\"\"Return all possible lengths represented by numeric string s.\"\"\"\\n\\tlengths = {int(s)}\\n\\tfor i in range(1, len(s)):\\n\\t\\t# add all lengths by splitting numeric string s at index i\\n\\t\\t# & sum of first split part(i.e. x) and second split part(i.e. y) gives the answer\\n\\t\\tlengths |= {x+y for x in possibleLengths(s[:i]) for y in possibleLengths(s[i:])}\\n\\treturn length\\n```\n```\\n@lru_cache(None)\\ndef dp(i, j, diff):             \\n\\t\"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n\\n\\t# If both have reached end return true if none of them are leading\\n\\tif i == len(s1) and j == len(s2): return diff == 0\\n\\n\\t# s1 has not reached end and s1 starts with a digit\\n\\tif i < len(s1) and s1[i].isdigit(): \\n\\t\\ti2 = getValidPrefixLength(s1,i)\\n\\t\\tfor L in possibleLengths(s1[i:i2]): \\n\\t\\t\\t# substract since lead of s2  decreases by L\\n\\t\\t\\tif dp(i2, j, diff-L): return True \\n\\n\\t# s2 has not reached end and s2 starts with a digit\\n\\telif j < len(s2) and s2[j].isdigit(): \\n\\t\\tj2 = getValidPrefixLength(s2,j)\\n\\t\\tfor L in possibleLengths(s2[j:j2]): \\n\\t\\t\\t# add since lead of s2 increases by L\\n\\t\\t\\tif dp(i, j2, diff+L): return True \\n\\n\\t# if none of them have integer prefix or a lead over the other\\n\\telif diff == 0: \\n\\t\\t# if only one of them has reached end or current alphabets are not the same \\n\\t\\tif i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \\n\\t\\t# skip same alphabets\\n\\t\\treturn dp(i+1, j+1, 0)\\n\\n\\t# if none of them have integer prefix & s2 lead over s1 \\n\\telif diff > 0: \\n\\t\\t# no s1 to balance s2\\'s lead\\n\\t\\tif i == len(s1): return False\\n\\t\\t# move s1 pointer forward and reduce diff\\n\\t\\treturn dp(i+1, j, diff-1)\\n\\n\\t# if none of them have integer prefix & s1 lead over s2\\n\\telse: \\n\\t\\t# no s2 to balance s1\\'s lead\\n\\t\\tif j == len(s2): return False \\n\\t\\t# move s2 pointer forward and increase diff\\n\\t\\treturn dp(i, j+1, diff+1)\\n```\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\n        def getValidPrefixLength(s,start):\\n            end = start\\n            while end < len(s) and s[end].isdigit(): end += 1\\n            return end\\n        \\n        @lru_cache(None)\\n        def possibleLengths(s): \\n            \"\"\"Return all possible lengths represented by numeric string s.\"\"\"\\n            ans = {int(s)}\\n            for i in range(1, len(s)):\\n                # add all lengths by splitting numeric string s at i\\n                ans |= {x+y for x in possibleLengths(s[:i]) for y in possibleLengths(s[i:])}\\n            return ans\\n        \\n        @lru_cache(None)\\n        def dp(i, j, diff):             \\n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n            \\n            # If both have reached end return true if none of them are leading\\n            if i == len(s1) and j == len(s2): return diff == 0\\n            \\n            # s1 has not reached end and s1 starts with a digit\\n            if i < len(s1) and s1[i].isdigit(): \\n                i2 = getValidPrefixLength(s1,i)\\n                for L in possibleLengths(s1[i:i2]): \\n                    # substract since lead of s2  decreases by L\\n                    if dp(i2, j, diff-L): return True \\n            \\n            # s2 has not reached end and s2 starts with a digit\\n            elif j < len(s2) and s2[j].isdigit(): \\n                j2 = getValidPrefixLength(s2,j)\\n                for L in possibleLengths(s2[j:j2]): \\n                    # add since lead of s2 increase by L\\n                    if dp(i, j2, diff+L): return True \\n            \\n            # if none of them have integer prefix or a lead over the other\\n            elif diff == 0: \\n                # if only one of them has reached end or current alphabets are not the same \\n                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \\n                # skip same alphabets\\n                return dp(i+1, j+1, 0)\\n            \\n            # if none of them have integer prefix & s2 lead over s1 \\n            elif diff > 0: \\n                # no s1 to balance s2\\'s lead\\n                if i == len(s1): return False\\n                # move s1 pointer forward and reduce diff\\n                return dp(i+1, j, diff-1)\\n            \\n            # if none of them have integer prefix & s1 lead over s2\\n            else: \\n                # no s2 to balance s1\\'s lead\\n                if j == len(s2): return False \\n                # move s2 pointer forward and increase diff\\n                return dp(i, j+1, diff+1)\\n        \\n        # start with starts of both s1 and s2 with no lead by any of them\\n        return dp(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660436,
                "title": "java-dp-memoization",
                "content": "Please see the comments below.\\n\\n```\\n/**\\nCases:\\n\\ndiff > 0 meaning we need to pick more chars in s1\\ndiff < 0 meaning we need to pick more chars in s2\\n\\n-1000 < diff < 1000 as there can be at most 3 digits in the string meaning largest digits are 999\\n\\n1. s1[i] == s2[j] and diff = 0\\n    increment i+1 and j+1\\n    \\n2. if s1[i] is not digit and diff > 0  then increment i i+1, diff\\n3. if s2[j] is not digit and diff < 0 then increment j j+1, diff\\n4. if s1[i] is digit then get digit value and decrement diff val as we have covered such chars in the s1 string\\n    and increment i i+1, diff-val\\n5. if s2[j] is digit then get digit value and increment diff val as we need to cover such chars in the s2 string and\\n    increment j, j+1, diff+val\\n\\n\\n\\n     01234\\ns1 = l123e\\ns2 = 44\\n\\ni: 0\\nj: 0\\ndiff: 0\\n    // Wildcard matching on s2[j]\\n    val = 4, diff = 0+4 j = 1\\n    \\n\\ti: 0\\n\\tj: 1\\n\\tdiff: 4\\n    // Literal matching on s1[i]\\n    increment ith pointer as ith is a literal and we can move on to next char in s1 and decrement diff\\n\\t\\n\\t\\ti: 1\\n\\t\\tj: 1\\n\\t\\tdiff: 3\\n        // Wildcard matching on s1[i]\\n        val = 1 diff = 3-1 = 2 increment i\\n\\t\\t\\n\\t\\t\\ti: 2\\n\\t\\t\\tj: 1\\n\\t\\t\\tdiff: 2\\n            // Wildcard matching on s1[i]\\n            val = 2 diff = 2-2 = 0   increment i\\n\\t\\t\\t\\n\\t\\t\\t\\ti: 3\\n\\t\\t\\t\\tj: 1\\n\\t\\t\\t\\tdiff: 0 \\n                // Wildcard matching on s1[i]\\n                val=3 diff = 0-3 = -3, increment i\\n                \\n\\t\\t\\t\\t\\ti: 4\\n\\t\\t\\t\\t\\tj: 1\\n\\t\\t\\t\\t\\tdiff: -3\\n\\t\\t\\t\\t\\t// Wildcard matching on s2[j]\\n                    val = 4 diff = -3+4 =1 increment j\\n                    \\n\\t\\t\\t\\t\\t\\ti: 4\\n\\t\\t\\t\\t\\t\\tj: 2\\n\\t\\t\\t\\t\\t\\tdiff: 1\\n                         // Literal matching on s1[i]\\n                         decrement i-1 and increment i\\n                         \\n                            i=5\\n                            j=2\\n                                diff==0 return true\\n                        dp[4][2][1] = true    \\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t    return dp[4][1][1000-3] = true\\n                return dp[3][1][0] = true\\n\\t\\t\\t\\n\\t\\t\\ti: 2\\n\\t\\t\\tj: 1\\n\\t\\t\\tdiff: 2\\n\\t\\t\\treturn dp[2][1][2] = true\\n\\t\\t\\treturn true\\n\\t\\t\\t\\n\\t\\ti: 0\\n\\t\\tj: 1\\n\\t\\tdiff: 4\\n\\t\\treturn dp[0][1][4] = true  \\n    return true\\n*/\\n\\nclass Solution {\\n    //112ms\\n     public boolean possiblyEquals(String s1, String s2) {\\n         return helper(s1.toCharArray(), s2.toCharArray(), 0, 0, 0, new Boolean[s1.length()+1][s2.length()+1][2001]);\\n     }\\n    \\n     boolean helper(char[] s1, char[] s2, int i, int j, int diff, Boolean[][][] dp) {\\n         if(i == s1.length && j == s2.length) {\\n             return diff == 0;\\n         }\\n         \\n         if(dp[i][j][diff+1000] != null)\\n             return dp[i][j][diff+1000];\\n         \\n         // if both i and j are at the same location and chars are same then simply increment both pointers\\n         if(i < s1.length && j < s2.length && diff == 0 && s1[i] == s2[j]) {\\n             if(helper(s1, s2, i+1, j+1, diff, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         // if s1[i] is literal and diff > 0 then increment i and decrement diff by 1\\n         if(i < s1.length && !Character.isDigit(s1[i]) && diff > 0 && helper(s1, s2, i+1, j, diff-1, dp)) {\\n             return dp[i][j][diff+1000] = true;\\n         }\\n         \\n         // if s2[j] is literal and diff < 0 then increment j and increment diff by 1\\n         // as we are done with the current jth char\\n         if(j < s2.length && !Character.isDigit(s2[j]) && diff < 0 && helper(s1, s2, i, j+1, diff+1, dp)) {\\n             return dp[i][j][diff+1000] = true;\\n         }\\n         \\n         // wildcard matching in s1\\n         // if s1 contains l123\\n         // then need to check with val as 1 then val as 12 and val as 123\\n         for(int k = i, val = 0; k < i + 4 && k < s1.length && Character.isDigit(s1[k]); k++) {\\n             val = val * 10 + s1[k] -\\'0\\';\\n             if(helper(s1, s2, k+1, j, diff-val, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         // wildcard matching in s2\\n         // if s2 contains l123\\n         // then need to check with val as 1 then val as 12 and val as 123\\n         for(int k = j, val = 0; k < j + 4 && k < s2.length && Character.isDigit(s2[k]); k++) {\\n             val = val * 10 + s2[k] -\\'0\\';\\n             if(helper(s1, s2, i, k+1, diff+val, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         return dp[i][j][diff+1000] = false;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/**\\nCases:\\n\\ndiff > 0 meaning we need to pick more chars in s1\\ndiff < 0 meaning we need to pick more chars in s2\\n\\n-1000 < diff < 1000 as there can be at most 3 digits in the string meaning largest digits are 999\\n\\n1. s1[i] == s2[j] and diff = 0\\n    increment i+1 and j+1\\n    \\n2. if s1[i] is not digit and diff > 0  then increment i i+1, diff\\n3. if s2[j] is not digit and diff < 0 then increment j j+1, diff\\n4. if s1[i] is digit then get digit value and decrement diff val as we have covered such chars in the s1 string\\n    and increment i i+1, diff-val\\n5. if s2[j] is digit then get digit value and increment diff val as we need to cover such chars in the s2 string and\\n    increment j, j+1, diff+val\\n\\n\\n\\n     01234\\ns1 = l123e\\ns2 = 44\\n\\ni: 0\\nj: 0\\ndiff: 0\\n    // Wildcard matching on s2[j]\\n    val = 4, diff = 0+4 j = 1\\n    \\n\\ti: 0\\n\\tj: 1\\n\\tdiff: 4\\n    // Literal matching on s1[i]\\n    increment ith pointer as ith is a literal and we can move on to next char in s1 and decrement diff\\n\\t\\n\\t\\ti: 1\\n\\t\\tj: 1\\n\\t\\tdiff: 3\\n        // Wildcard matching on s1[i]\\n        val = 1 diff = 3-1 = 2 increment i\\n\\t\\t\\n\\t\\t\\ti: 2\\n\\t\\t\\tj: 1\\n\\t\\t\\tdiff: 2\\n            // Wildcard matching on s1[i]\\n            val = 2 diff = 2-2 = 0   increment i\\n\\t\\t\\t\\n\\t\\t\\t\\ti: 3\\n\\t\\t\\t\\tj: 1\\n\\t\\t\\t\\tdiff: 0 \\n                // Wildcard matching on s1[i]\\n                val=3 diff = 0-3 = -3, increment i\\n                \\n\\t\\t\\t\\t\\ti: 4\\n\\t\\t\\t\\t\\tj: 1\\n\\t\\t\\t\\t\\tdiff: -3\\n\\t\\t\\t\\t\\t// Wildcard matching on s2[j]\\n                    val = 4 diff = -3+4 =1 increment j\\n                    \\n\\t\\t\\t\\t\\t\\ti: 4\\n\\t\\t\\t\\t\\t\\tj: 2\\n\\t\\t\\t\\t\\t\\tdiff: 1\\n                         // Literal matching on s1[i]\\n                         decrement i-1 and increment i\\n                         \\n                            i=5\\n                            j=2\\n                                diff==0 return true\\n                        dp[4][2][1] = true    \\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t    return dp[4][1][1000-3] = true\\n                return dp[3][1][0] = true\\n\\t\\t\\t\\n\\t\\t\\ti: 2\\n\\t\\t\\tj: 1\\n\\t\\t\\tdiff: 2\\n\\t\\t\\treturn dp[2][1][2] = true\\n\\t\\t\\treturn true\\n\\t\\t\\t\\n\\t\\ti: 0\\n\\t\\tj: 1\\n\\t\\tdiff: 4\\n\\t\\treturn dp[0][1][4] = true  \\n    return true\\n*/\\n\\nclass Solution {\\n    //112ms\\n     public boolean possiblyEquals(String s1, String s2) {\\n         return helper(s1.toCharArray(), s2.toCharArray(), 0, 0, 0, new Boolean[s1.length()+1][s2.length()+1][2001]);\\n     }\\n    \\n     boolean helper(char[] s1, char[] s2, int i, int j, int diff, Boolean[][][] dp) {\\n         if(i == s1.length && j == s2.length) {\\n             return diff == 0;\\n         }\\n         \\n         if(dp[i][j][diff+1000] != null)\\n             return dp[i][j][diff+1000];\\n         \\n         // if both i and j are at the same location and chars are same then simply increment both pointers\\n         if(i < s1.length && j < s2.length && diff == 0 && s1[i] == s2[j]) {\\n             if(helper(s1, s2, i+1, j+1, diff, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         // if s1[i] is literal and diff > 0 then increment i and decrement diff by 1\\n         if(i < s1.length && !Character.isDigit(s1[i]) && diff > 0 && helper(s1, s2, i+1, j, diff-1, dp)) {\\n             return dp[i][j][diff+1000] = true;\\n         }\\n         \\n         // if s2[j] is literal and diff < 0 then increment j and increment diff by 1\\n         // as we are done with the current jth char\\n         if(j < s2.length && !Character.isDigit(s2[j]) && diff < 0 && helper(s1, s2, i, j+1, diff+1, dp)) {\\n             return dp[i][j][diff+1000] = true;\\n         }\\n         \\n         // wildcard matching in s1\\n         // if s1 contains l123\\n         // then need to check with val as 1 then val as 12 and val as 123\\n         for(int k = i, val = 0; k < i + 4 && k < s1.length && Character.isDigit(s1[k]); k++) {\\n             val = val * 10 + s1[k] -\\'0\\';\\n             if(helper(s1, s2, k+1, j, diff-val, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         // wildcard matching in s2\\n         // if s2 contains l123\\n         // then need to check with val as 1 then val as 12 and val as 123\\n         for(int k = j, val = 0; k < j + 4 && k < s2.length && Character.isDigit(s2[k]); k++) {\\n             val = val * 10 + s2[k] -\\'0\\';\\n             if(helper(s1, s2, i, k+1, diff+val, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         return dp[i][j][diff+1000] = false;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881004,
                "title": "python3-dfs-cache-clean-and-easy-to-understand",
                "content": "The idea is referenced from [votrubac](https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1551731/DFS) and [rexue70](https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550342/Java-Clean-(DFS-%2B-memo)). The if else condition is borrowed from [ye15](https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550012/Python3-dp) and [Buggy_D_Clown](https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1629836/Pythonor-Top-down-DP-or-Steps-simplified-or-Commented-or-90.98-Time-or-72.42-Mem). I wrote the following code combined from the above resources to make it clean and easy to understand. \\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        return self.dfs(s1, s2, 0, 0, 0)\\n    \\n    @lru_cache(None)\\n    def dfs(self, s1, s2, i, j, diff):\\n        if i == len(s1) and j == len(s2):\\n            return diff == 0\\n        if i < len(s1) and s1[i].isdigit():\\n            k = i\\n            val = 0\\n            while k < len(s1) and s1[k].isdigit():\\n                val = val*10 + int(s1[k])\\n                k += 1\\n                if self.dfs(s1, s2, k, j, diff - val):\\n                    return True\\n        elif j < len(s2) and s2[j].isdigit():\\n            k = j\\n            val = 0\\n            while k < len(s2) and s2[k].isdigit():\\n                val = val*10 + int(s2[k])\\n                k += 1\\n                if self.dfs(s1, s2, i, k, diff + val):\\n                    return True\\n        elif diff == 0:\\n            if i < len(s1) and j < len(s2) and s1[i] == s2[j] and self.dfs(s1, s2, i+1, j+1, diff):\\n                return True\\n        elif diff > 0:\\n            if i < len(s1) and self.dfs(s1, s2, i+1, j, diff - 1):\\n                return True\\n        elif diff < 0:\\n            if j < len(s2) and self.dfs(s1, s2, i, j+1, diff + 1):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        return self.dfs(s1, s2, 0, 0, 0)\\n    \\n    @lru_cache(None)\\n    def dfs(self, s1, s2, i, j, diff):\\n        if i == len(s1) and j == len(s2):\\n            return diff == 0\\n        if i < len(s1) and s1[i].isdigit():\\n            k = i\\n            val = 0\\n            while k < len(s1) and s1[k].isdigit():\\n                val = val*10 + int(s1[k])\\n                k += 1\\n                if self.dfs(s1, s2, k, j, diff - val):\\n                    return True\\n        elif j < len(s2) and s2[j].isdigit():\\n            k = j\\n            val = 0\\n            while k < len(s2) and s2[k].isdigit():\\n                val = val*10 + int(s2[k])\\n                k += 1\\n                if self.dfs(s1, s2, i, k, diff + val):\\n                    return True\\n        elif diff == 0:\\n            if i < len(s1) and j < len(s2) and s1[i] == s2[j] and self.dfs(s1, s2, i+1, j+1, diff):\\n                return True\\n        elif diff > 0:\\n            if i < len(s1) and self.dfs(s1, s2, i+1, j, diff - 1):\\n                return True\\n        elif diff < 0:\\n            if j < len(s2) and self.dfs(s1, s2, i, j+1, diff + 1):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550682,
                "title": "c-dp-with-explanation-56ms",
                "content": "~~I checked that my solution is **about 10 times faster** than other C++ solution.~~ (Faster codes came out)\\nBasically, the code moves `i1`, `i2` (index of `s1` and `s2` respectively) and `diff` (relative character count\\ndifference between two strings) and memoize this 3 dimensional data.\\nAlthough there exists already a DP solution, I focused on following points.\\n1. I manage the variable `diff` to always be in range `(1000, -1000)` by strictly obey a following rule.\\n\\t\\'if `diff < 0`, take element from `s1`, else, from `s2`\\'\\n\\tFor me, this was the most intuitive way to assure `O(40*40*2000)`.\\n2. I did not use additional function for making set of combinations from 3 consecutive digits.\\n    So, I guess my code can simply be extended to 4 or 5 consecutive digit cases if TLE is avoided.\\n\\nSimilar to other posts, there are 5 conditions in a recursive function.\\n1. `diff <= 0` and `s1[i1] == digit`\\n2. `diff >= 0` and `s2[i2] == digit`\\n3. `diff == 0` and `s1[i1] == s2[i2]`\\n4. `diff < 0` and `s1[i1] == alphabet`\\n5. `diff > 0` and `s2[i2] == alphabet`\\n\\n```\\nclass Solution {\\npublic:\\n    bool memo[50][50][2000];\\n    bool comp_seqs(string& s1, string& s2, int i1, int i2, int diff){\\n        // check true condition\\n        if(i1 == s1.size() && i2 == s2.size())\\n\\t\\t\\treturn diff == 0;\\n        // add 1000 to \\'diff\\' be in range [0, 2000)\\n        bool& ret = memo[i1][i2][diff+1000];\\n        if(ret)\\n            return false;  // immediately return\\n        ret = true;  // check visited\\n\\t\\t\\n\\t\\t// diff > 0 or diff < 0 checking to ensure the diff always be in range (-1000, 1000)\\n\\t\\t// in the case that s1[i1] is a digit\\n        if(diff >= 0 && i1 < s1.size() && s1[i1] <= \\'9\\'){ \\n            int num1 = 0;\\n            for(int i=0; i<min(3, (int)s1.size()-i1); i++){  // loop maximum 3 consecutive digits\\n                if(s1[i1 + i] > \\'9\\')\\n                    break;\\n                num1 = num1*10 + s1[i1 + i] - \\'0\\';\\n                if(comp_seqs(s1, s2, i1+i+1, i2, diff-num1))\\n                    return true;\\n            }\\n        }else if(diff <= 0 && i2 < s2.size() && s2[i2] <= \\'9\\'){  // in the case that s2[i2] is a digit \\n            int num2 = 0;\\n            for(int i=0; i<min(3, (int)s2.size()-i2); i++){\\n                if(s2[i2 + i] > \\'9\\')\\n                    break;\\n                num2 = num2*10 + s2[i2 + i] - \\'0\\';\\n                if(comp_seqs(s1, s2, i1, i2+i+1, diff+num2))\\n                    return true;\\n            }\\n        }else if(diff == 0){\\n            if(i1 >= s1.size() || i2 >= s2.size() || s1[i1] != s2[i2])  // reject infeasible cases\\n                return false;\\n            return comp_seqs(s1, s2, i1+1, i2+1, 0);\\n        }else if(diff > 0){\\n            if(i1 >= s1.size())  // reject infeasible cases\\n                return false;\\n            return comp_seqs(s1, s2, i1+1, i2, diff - 1);\\n        }else{\\n            if(i2 >= s2.size())  // reject infeasible cases\\n                return false;\\n            return comp_seqs(s1, s2, i1, i2+1, diff + 1);\\n        }\\n        return false;\\n    }\\n    bool possiblyEquals(string s1, string s2) {\\n        return comp_seqs(s1, s2, 0, 0, 0);\\n    }\\n};\\n```\\n\\nPlease let me know if theres any problem or better optimization",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool memo[50][50][2000];\\n    bool comp_seqs(string& s1, string& s2, int i1, int i2, int diff){\\n        // check true condition\\n        if(i1 == s1.size() && i2 == s2.size())\\n\\t\\t\\treturn diff == 0;\\n        // add 1000 to \\'diff\\' be in range [0, 2000)\\n        bool& ret = memo[i1][i2][diff+1000];\\n        if(ret)\\n            return false;  // immediately return\\n        ret = true;  // check visited\\n\\t\\t\\n\\t\\t// diff > 0 or diff < 0 checking to ensure the diff always be in range (-1000, 1000)\\n\\t\\t// in the case that s1[i1] is a digit\\n        if(diff >= 0 && i1 < s1.size() && s1[i1] <= \\'9\\'){ \\n            int num1 = 0;\\n            for(int i=0; i<min(3, (int)s1.size()-i1); i++){  // loop maximum 3 consecutive digits\\n                if(s1[i1 + i] > \\'9\\')\\n                    break;\\n                num1 = num1*10 + s1[i1 + i] - \\'0\\';\\n                if(comp_seqs(s1, s2, i1+i+1, i2, diff-num1))\\n                    return true;\\n            }\\n        }else if(diff <= 0 && i2 < s2.size() && s2[i2] <= \\'9\\'){  // in the case that s2[i2] is a digit \\n            int num2 = 0;\\n            for(int i=0; i<min(3, (int)s2.size()-i2); i++){\\n                if(s2[i2 + i] > \\'9\\')\\n                    break;\\n                num2 = num2*10 + s2[i2 + i] - \\'0\\';\\n                if(comp_seqs(s1, s2, i1, i2+i+1, diff+num2))\\n                    return true;\\n            }\\n        }else if(diff == 0){\\n            if(i1 >= s1.size() || i2 >= s2.size() || s1[i1] != s2[i2])  // reject infeasible cases\\n                return false;\\n            return comp_seqs(s1, s2, i1+1, i2+1, 0);\\n        }else if(diff > 0){\\n            if(i1 >= s1.size())  // reject infeasible cases\\n                return false;\\n            return comp_seqs(s1, s2, i1+1, i2, diff - 1);\\n        }else{\\n            if(i2 >= s2.size())  // reject infeasible cases\\n                return false;\\n            return comp_seqs(s1, s2, i1, i2+1, diff + 1);\\n        }\\n        return false;\\n    }\\n    bool possiblyEquals(string s1, string s2) {\\n        return comp_seqs(s1, s2, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550035,
                "title": "c-dp-o-n-m-2000",
                "content": "Maintain the length diff to not more than 999 during dp, always extend the shorter one.\\n```\\nbool f[41][41][2000];\\nclass Solution {\\npublic:\\n    bool possiblyEquals(string s1, string s2) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        memset(f, false, sizeof(f));\\n        f[0][0][1000] = true;\\n        for(int i = 0;i<=n;i++)\\n            for(int j = 0;j<=m;j++)\\n                for(int k = 0;k<2000;k++){\\n                    if(!f[i][j][k])continue;\\n\\t\\t\\t\\t\\t// if k==1000 means length diff is 0, so check both next charactors.\\n                    if(i+1<=n&&j+1<=m&&k==1000&&s1[i]==s2[j]){\\n                        f[i+1][j+1][k] = true;\\n                    }\\n\\t\\t\\t\\t\\t// if first string is longer or same length, extend second string.\\n                    if(k>=1000&&j+1<=m){\\n                        if(s2[j]>=\\'a\\'&&s2[j]<=\\'z\\'){\\n\\t\\t\\t\\t\\t\\t\\t// do not extend to be a longer string using a-z.\\n                            if(k>1000){\\n                                f[i][j+1][k-1] = true;\\n                            }\\n                        } else if(s2[j]>\\'0\\') {\\n                            int cur = 0;\\n                            for(int r=j;r<m;r++){\\n                                if(s2[r]>=\\'0\\'&&s2[r]<=\\'9\\'){\\n                                    cur = cur * 10 + (s2[r]-\\'0\\');\\n                                    f[i][r+1][k-cur] = true;\\n                                } else break;\\n                            }\\n                        }\\n                    }\\n\\t\\t\\t\\t\\t// if second string is longer or same length, extend first string.\\n                    if(k<=1000&&i+1<=n){\\n                        if(s1[i]>=\\'a\\'&&s1[i]<=\\'z\\'){\\n                            if(k<1000){\\n                                f[i+1][j][k+1] = true;\\n                            }\\n                        } else if(s1[i]>\\'0\\') {\\n                            int cur = 0;\\n                            for(int r=i;r<n;r++){\\n                                if(s1[r]>=\\'0\\'&&s1[r]<=\\'9\\'){\\n                                    cur = cur * 10 + (s1[r]-\\'0\\');\\n                                    f[r+1][j][k+cur] = true;\\n                                } else break;\\n                            }\\n                        }\\n                    }\\n                }\\n        return f[n][m][1000];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool f[41][41][2000];\\nclass Solution {\\npublic:\\n    bool possiblyEquals(string s1, string s2) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        memset(f, false, sizeof(f));\\n        f[0][0][1000] = true;\\n        for(int i = 0;i<=n;i++)\\n            for(int j = 0;j<=m;j++)\\n                for(int k = 0;k<2000;k++){\\n                    if(!f[i][j][k])continue;\\n\\t\\t\\t\\t\\t// if k==1000 means length diff is 0, so check both next charactors.\\n                    if(i+1<=n&&j+1<=m&&k==1000&&s1[i]==s2[j]){\\n                        f[i+1][j+1][k] = true;\\n                    }\\n\\t\\t\\t\\t\\t// if first string is longer or same length, extend second string.\\n                    if(k>=1000&&j+1<=m){\\n                        if(s2[j]>=\\'a\\'&&s2[j]<=\\'z\\'){\\n\\t\\t\\t\\t\\t\\t\\t// do not extend to be a longer string using a-z.\\n                            if(k>1000){\\n                                f[i][j+1][k-1] = true;\\n                            }\\n                        } else if(s2[j]>\\'0\\') {\\n                            int cur = 0;\\n                            for(int r=j;r<m;r++){\\n                                if(s2[r]>=\\'0\\'&&s2[r]<=\\'9\\'){\\n                                    cur = cur * 10 + (s2[r]-\\'0\\');\\n                                    f[i][r+1][k-cur] = true;\\n                                } else break;\\n                            }\\n                        }\\n                    }\\n\\t\\t\\t\\t\\t// if second string is longer or same length, extend first string.\\n                    if(k<=1000&&i+1<=n){\\n                        if(s1[i]>=\\'a\\'&&s1[i]<=\\'z\\'){\\n                            if(k<1000){\\n                                f[i+1][j][k+1] = true;\\n                            }\\n                        } else if(s1[i]>\\'0\\') {\\n                            int cur = 0;\\n                            for(int r=i;r<n;r++){\\n                                if(s1[r]>=\\'0\\'&&s1[r]<=\\'9\\'){\\n                                    cur = cur * 10 + (s1[r]-\\'0\\');\\n                                    f[r+1][j][k+cur] = true;\\n                                } else break;\\n                            }\\n                        }\\n                    }\\n                }\\n        return f[n][m][1000];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571557,
                "title": "java-dfs-dp-with-explanation",
                "content": "```\\nclass Solution {\\n    // ref = https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550342/Java-Clean-(DFS-//     //   %2B-memo)\\n    \\n    /**\\n    *  s1 = \"abc123ad\"\\n              i\\n    *  s2 = \"bc12de\"\\n                 j\\n       1. Why 2000 options ?\\n       Since max 3 digits can be place, 999\\n       so difference b/w i and j can be -999 to 999 == 2000\\n       since i can be -999 and j can be 999 so diff == 2000\\n       \\n       What is diff ?\\n       This tell diff in index b/w i and j\\n       Suppose\\n       s1 = \\'aaaaaaaabbbbccccc\\'\\n                i=4\\n       s2 = \\'bbbbbbbaaaaaaaaaaaaaadddddddddd\\'\\n                             j=16\\n            diff =  16 - 4 = 12\\n            diff > 0, j > i \\n            diff < 0, i > j\\n            Since digit are introduced in b/w, we have to take all possible digit/numbers that can be form\\n            means\\n            s1 = \\'aaa123bb\\'\\n                     i\\n                     val= 1, 12, 123\\n                       val = 2, 23\\n                         val=3\\n                         all possible no. that can be formed\\n                    suppose val = 12.\\n                    so new i = i + val\\n                       new i = 3 + 12 = 15\\n                   aaa(12 character)(3character)bb\\n                                 \\n                   \\n            s2 = \\'ab12c\\'\\n                   j=1\\n                   diff = j - i, 1 - 15 = -14\\n                   -ve means i > j\\n       2. Basic is to check index value at i and j\\n      case 1. if both at i and j, are character and diff != 0, it means both i and j are at different positions\\n      case 2. if both are digit\\n      case 3. if both are character diff == 0, both are at same position, move to i+1, j+1\\n      case 4. if one character, one digit is there\\n    */\\n    Boolean[][][] dp;\\n    boolean dfs(int i, int j, int diff, String s1, String s2){\\n        if (i >= s1.length() && j >= s2.length() && diff == 0) return true;\\n        // diff > 0, j > i\\n        // diff < 0, i > j\\n        // System.out.println(\" == \"  + diff + \" \"  + (diff+1000) + \" \" + dp[i][j][diff + 1000]);\\n        \\n        if(dp[i][j][diff + 1000] != null){\\n            return dp[i][j][diff+1000];\\n        }\\n        \\n        boolean res = false;\\n        if(i < s1.length()){\\n            if(Character.isDigit(s1.charAt(i))){\\n                int value = 0, count = 0;\\n                while(i+count < s1.length() && count < 3 && Character.isDigit(s1.charAt(i+count))){\\n                    value = value*10 + (s1.charAt(i+count) - \\'0\\');\\n                    count++;\\n                    if(dfs(i+count, j, diff - value, s1, s2)) res = true;\\n                }\\n            }else{\\n                if(diff > 0){\\n                    if(dfs(i+1, j, diff-1, s1, s2)) res = true;\\n                }else if(diff == 0 && j < s2.length() && s1.charAt(i) == s2.charAt(j)){\\n                    if(dfs(i+1, j+1, diff, s1, s2)) res = true;\\n                }\\n            }\\n        }\\n        \\n        \\n        if(j < s2.length()){\\n            if(Character.isDigit(s2.charAt(j))){\\n                int value = 0, count = 0;\\n                while(j + count < s2.length() && count < 3 && Character.isDigit(s2.charAt(j+count))){\\n                    value = value*10 + (s2.charAt(j+count) - \\'0\\');\\n                    count++;\\n                    if(dfs(i, j+count, diff + value, s1, s2)) res = true;\\n                }\\n            }else{\\n                if(diff < 0){\\n                    if(dfs(i, j+1, diff+1, s1, s2)) res = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[i][j][diff + 1000] = res;\\n    }\\n    public boolean possiblyEquals(String s1, String s2) {\\n      int m = s1.length();\\n      int n = s2.length();\\n      dp = new Boolean[m + 1][n + 1][2001];   \\n      return dfs(0, 0, 0, s1, s2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // ref = https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550342/Java-Clean-(DFS-//     //   %2B-memo)\\n    \\n    /**\\n    *  s1 = \"abc123ad\"\\n              i\\n    *  s2 = \"bc12de\"\\n                 j\\n       1. Why 2000 options ?\\n       Since max 3 digits can be place, 999\\n       so difference b/w i and j can be -999 to 999 == 2000\\n       since i can be -999 and j can be 999 so diff == 2000\\n       \\n       What is diff ?\\n       This tell diff in index b/w i and j\\n       Suppose\\n       s1 = \\'aaaaaaaabbbbccccc\\'\\n                i=4\\n       s2 = \\'bbbbbbbaaaaaaaaaaaaaadddddddddd\\'\\n                             j=16\\n            diff =  16 - 4 = 12\\n            diff > 0, j > i \\n            diff < 0, i > j\\n            Since digit are introduced in b/w, we have to take all possible digit/numbers that can be form\\n            means\\n            s1 = \\'aaa123bb\\'\\n                     i\\n                     val= 1, 12, 123\\n                       val = 2, 23\\n                         val=3\\n                         all possible no. that can be formed\\n                    suppose val = 12.\\n                    so new i = i + val\\n                       new i = 3 + 12 = 15\\n                   aaa(12 character)(3character)bb\\n                                 \\n                   \\n            s2 = \\'ab12c\\'\\n                   j=1\\n                   diff = j - i, 1 - 15 = -14\\n                   -ve means i > j\\n       2. Basic is to check index value at i and j\\n      case 1. if both at i and j, are character and diff != 0, it means both i and j are at different positions\\n      case 2. if both are digit\\n      case 3. if both are character diff == 0, both are at same position, move to i+1, j+1\\n      case 4. if one character, one digit is there\\n    */\\n    Boolean[][][] dp;\\n    boolean dfs(int i, int j, int diff, String s1, String s2){\\n        if (i >= s1.length() && j >= s2.length() && diff == 0) return true;\\n        // diff > 0, j > i\\n        // diff < 0, i > j\\n        // System.out.println(\" == \"  + diff + \" \"  + (diff+1000) + \" \" + dp[i][j][diff + 1000]);\\n        \\n        if(dp[i][j][diff + 1000] != null){\\n            return dp[i][j][diff+1000];\\n        }\\n        \\n        boolean res = false;\\n        if(i < s1.length()){\\n            if(Character.isDigit(s1.charAt(i))){\\n                int value = 0, count = 0;\\n                while(i+count < s1.length() && count < 3 && Character.isDigit(s1.charAt(i+count))){\\n                    value = value*10 + (s1.charAt(i+count) - \\'0\\');\\n                    count++;\\n                    if(dfs(i+count, j, diff - value, s1, s2)) res = true;\\n                }\\n            }else{\\n                if(diff > 0){\\n                    if(dfs(i+1, j, diff-1, s1, s2)) res = true;\\n                }else if(diff == 0 && j < s2.length() && s1.charAt(i) == s2.charAt(j)){\\n                    if(dfs(i+1, j+1, diff, s1, s2)) res = true;\\n                }\\n            }\\n        }\\n        \\n        \\n        if(j < s2.length()){\\n            if(Character.isDigit(s2.charAt(j))){\\n                int value = 0, count = 0;\\n                while(j + count < s2.length() && count < 3 && Character.isDigit(s2.charAt(j+count))){\\n                    value = value*10 + (s2.charAt(j+count) - \\'0\\');\\n                    count++;\\n                    if(dfs(i, j+count, diff + value, s1, s2)) res = true;\\n                }\\n            }else{\\n                if(diff < 0){\\n                    if(dfs(i, j+1, diff+1, s1, s2)) res = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[i][j][diff + 1000] = res;\\n    }\\n    public boolean possiblyEquals(String s1, String s2) {\\n      int m = s1.length();\\n      int n = s2.length();\\n      dp = new Boolean[m + 1][n + 1][2001];   \\n      return dfs(0, 0, 0, s1, s2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559867,
                "title": "c-the-shortest-ac-solution-so-far",
                "content": "TBH I didn\\'t expect myself how much boilerplate code can be removed by simply appending a colon `\\':\\'` to each string.\\n\\nThus for an integer value `s[i] - \\'0\\'`\\n- `< 10` signifies a digit character in `s`\\n- `= 10` is _end-of-line_, because `\\':\\' - \\'0\\' == 10`.\\n- everything else is a letter\\n\\nMy solution is then melting down to the following:\\n```c++\\nbool possiblyEquals(string s1, string s2) {\\n    s1 += \":\"; s2 += \":\";\\n    unordered_set<int> seen;\\n    function<bool(int, int, int, int)> DFS = [&](int i, int j, int d, int n) {\\n        int a = s1[i] - \\'0\\', b = s2[j] - \\'0\\', dn = d + n;\\n        return !n && !seen.insert(i * 10000 + j * 1000 + d).second ? false\\n             : a < 10 ? n > 0 && DFS(i + 1, j, d, 10 * n + a) || DFS(i + 1, j, dn, a)\\n             : b < 10 ? n < 0 && DFS(i, j + 1, d, 10 * n - b) || DFS(i, j + 1, dn, -b)\\n             : dn < 0 ? a > 10 && DFS(i + 1, j, dn + 1, 0)\\n             : dn > 0 ? b > 10 && DFS(i, j + 1, dn - 1, 0)\\n             : a == b && (a == 10 || DFS(i + 1, j + 1, 0, 0));\\n    };\\n    return DFS(0, 0, 0, 0);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```c++\\nbool possiblyEquals(string s1, string s2) {\\n    s1 += \":\"; s2 += \":\";\\n    unordered_set<int> seen;\\n    function<bool(int, int, int, int)> DFS = [&](int i, int j, int d, int n) {\\n        int a = s1[i] - \\'0\\', b = s2[j] - \\'0\\', dn = d + n;\\n        return !n && !seen.insert(i * 10000 + j * 1000 + d).second ? false\\n             : a < 10 ? n > 0 && DFS(i + 1, j, d, 10 * n + a) || DFS(i + 1, j, dn, a)\\n             : b < 10 ? n < 0 && DFS(i, j + 1, d, 10 * n - b) || DFS(i, j + 1, dn, -b)\\n             : dn < 0 ? a > 10 && DFS(i + 1, j, dn + 1, 0)\\n             : dn > 0 ? b > 10 && DFS(i, j + 1, dn - 1, 0)\\n             : a == b && (a == 10 || DFS(i + 1, j + 1, 0, 0));\\n    };\\n    return DFS(0, 0, 0, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550407,
                "title": "c-dfs-memory",
                "content": "Given a string `s`,  we can describe a state `(p, c)` indicating we first match `c` any chars and then match the rest of string from position `p`. So with two strings `s1` and `s2`, we can have define a **DFS** process `dfs(p1, c1, p2, c2)`.\\n\\nThe DFS process is literally easy but consisted of so many differenet cases:\\n\\n* Both `s1` and `s2` are at a completed state: `true`\\n* One of the states is completed but another not: `false`\\n* Both are matching any chars (`c1 > 0 && c2 > 0`): cut the first `min(c1, c2)` chars.\\n* One of them are matching any chars (`c1 > 0 || c2 > 0`):\\n\\t* Another string is matching a letter: cut the first one and continue.\\n\\t* Another string is matching a digit: enumerate all possible lengths.\\n* None of them are matching any chars (`c1 = 0 && c2 = 0`):\\n\\t* Both are matching letters (`s1[p1]` and `s2[p2]` are letters): match `s1[p1]` and `s2[p2]` and continue.\\n\\t* One of them are matching a digit: enumerate all possible lengths.\\n\\nTo avoid redundant calculation of **DFS**, take a map to store the results.\\n\\n```c++\\nclass Solution\\n{\\npublic:\\n    \\n    inline bool is_end(string &s, int p, int c)\\n    {\\n        return p == s.length() && c == 0;\\n    }\\n    \\n    inline bool is_digit(char c)\\n    {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n    \\n    inline bool is_letter(char c)\\n    {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n\\n    map<pair<pair<int, int>, pair<int, int>>, bool> f;\\n    \\n    inline bool dfs(string &s1, string &s2, int p1, int p2, int c1, int c2)\\n    {\\n        pair<pair<int, int>, pair<int, int>> key = make_pair(make_pair(p1, p2), make_pair(c1, c2));\\n\\n        if (f.find(key) != f.end())\\n        {\\n            return f[key];\\n        }\\n\\n        bool e1 = is_end(s1, p1, c1);\\n        bool e2 = is_end(s2, p2, c2);\\n        \\n        if (e1 && e2)\\n        {\\n            return f[key] = true;\\n        }\\n        \\n        if (e1 != e2)\\n        {\\n            return f[key] = false;\\n        }\\n        \\n        if (c1 > 0 && c2 > 0)\\n        {\\n            return f[key] = dfs(s1, s2, p1, p2, c1 - min(c1, c2), c2 - min(c1, c2));\\n        }\\n        \\n        if (c1 > 0)\\n        {\\n            // Here, c2 must be 0 and thus p2 < s2.length\\n            \\n            if (is_letter(s2[p2]))\\n            {\\n                return f[key] = dfs(s1, s2, p1, p2 + 1, c1 - 1, 0);\\n            }\\n            else\\n            {\\n                int num = 0;\\n                \\n                for (int i = 0; p2 + i < s2.length(); i++)\\n                {\\n                    if (!is_digit(s2[p2 + i]))\\n                    {\\n                        break;\\n                    }\\n                    \\n                    num = num * 10 + s2[p2 + i] - \\'0\\';\\n                    \\n                    if (dfs(s1, s2, p1, p2 + i + 1, c1, num))\\n                    {\\n                        return f[key] = true;\\n                    }\\n                }\\n                \\n                return f[key] = false;\\n            }\\n        }\\n            \\n        if (c2 > 0)\\n        {\\n            // Here, c1 must be 0 and thus p1 < s1.length\\n            \\n            if (is_letter(s1[p1]))\\n            {\\n                return f[key] = dfs(s1, s2, p1 + 1, p2, 0, c2 - 1);\\n            }\\n            else\\n            {\\n                int num = 0;\\n                \\n                for (int i = 0; p1 + i < s1.length(); i++)\\n                {\\n                    if (!is_digit(s1[p1 + i]))\\n                    {\\n                        break;\\n                    }\\n                    \\n                    num = num * 10 + s1[p1 + i] - \\'0\\';\\n                    \\n                    if (dfs(s1, s2, p1 + i + 1, p2, num, c2))\\n                    {\\n                        return f[key] = true;\\n                    }\\n                }\\n                \\n                return f[key] = false;\\n            }\\n        }\\n        \\n        // Here, both c1 and c2 must be 0s\\n        \\n        if (is_letter(s1[p1]) && is_letter(s2[p2]))\\n        {\\n            return f[key] = (s1[p1] == s2[p2] && dfs(s1, s2, p1 + 1, p2 + 1, 0, 0));\\n        }\\n        \\n        if (is_digit(s1[p1]))\\n        {\\n            int num = 0;\\n            \\n            for (int i = 0; p1 + i < s1.length(); i++)\\n            {\\n                if (!is_digit(s1[p1 + i]))\\n                {\\n                    break;\\n                }\\n                \\n                num = num * 10 + s1[p1 + i] - \\'0\\';\\n                \\n                if (dfs(s1, s2, p1 + i + 1, p2, num, 0))\\n                {\\n                    return f[key] = true;\\n                }\\n            }\\n            \\n            return f[key] = false;\\n        }\\n        \\n        if (is_digit(s2[p2]))\\n        {\\n            int num = 0;\\n            \\n            for (int i = 0; p2 + i < s2.length(); i++)\\n            {\\n                if (!is_digit(s2[p2 + i]))\\n                {\\n                    break;\\n                }\\n                \\n                num = num * 10 + s2[p2 + i] - \\'0\\';\\n                \\n                if (dfs(s1, s2, p1, p2 + i + 1, 0, num))\\n                {\\n                    return f[key] = true;\\n                }\\n            }\\n\\n\\t\\t\\treturn f[key] = false;\\n        }\\n        \\n        // Ideally, we should never go here\\n        throw invalid_argument(\"Sth went wrong\");\\n    }\\n    \\n    bool possiblyEquals(string s1, string s2)\\n    {\\n        return dfs(s1, s2, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution\\n{\\npublic:\\n    \\n    inline bool is_end(string &s, int p, int c)\\n    {\\n        return p == s.length() && c == 0;\\n    }\\n    \\n    inline bool is_digit(char c)\\n    {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n    \\n    inline bool is_letter(char c)\\n    {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n\\n    map<pair<pair<int, int>, pair<int, int>>, bool> f;\\n    \\n    inline bool dfs(string &s1, string &s2, int p1, int p2, int c1, int c2)\\n    {\\n        pair<pair<int, int>, pair<int, int>> key = make_pair(make_pair(p1, p2), make_pair(c1, c2));\\n\\n        if (f.find(key) != f.end())\\n        {\\n            return f[key];\\n        }\\n\\n        bool e1 = is_end(s1, p1, c1);\\n        bool e2 = is_end(s2, p2, c2);\\n        \\n        if (e1 && e2)\\n        {\\n            return f[key] = true;\\n        }\\n        \\n        if (e1 != e2)\\n        {\\n            return f[key] = false;\\n        }\\n        \\n        if (c1 > 0 && c2 > 0)\\n        {\\n            return f[key] = dfs(s1, s2, p1, p2, c1 - min(c1, c2), c2 - min(c1, c2));\\n        }\\n        \\n        if (c1 > 0)\\n        {\\n            // Here, c2 must be 0 and thus p2 < s2.length\\n            \\n            if (is_letter(s2[p2]))\\n            {\\n                return f[key] = dfs(s1, s2, p1, p2 + 1, c1 - 1, 0);\\n            }\\n            else\\n            {\\n                int num = 0;\\n                \\n                for (int i = 0; p2 + i < s2.length(); i++)\\n                {\\n                    if (!is_digit(s2[p2 + i]))\\n                    {\\n                        break;\\n                    }\\n                    \\n                    num = num * 10 + s2[p2 + i] - \\'0\\';\\n                    \\n                    if (dfs(s1, s2, p1, p2 + i + 1, c1, num))\\n                    {\\n                        return f[key] = true;\\n                    }\\n                }\\n                \\n                return f[key] = false;\\n            }\\n        }\\n            \\n        if (c2 > 0)\\n        {\\n            // Here, c1 must be 0 and thus p1 < s1.length\\n            \\n            if (is_letter(s1[p1]))\\n            {\\n                return f[key] = dfs(s1, s2, p1 + 1, p2, 0, c2 - 1);\\n            }\\n            else\\n            {\\n                int num = 0;\\n                \\n                for (int i = 0; p1 + i < s1.length(); i++)\\n                {\\n                    if (!is_digit(s1[p1 + i]))\\n                    {\\n                        break;\\n                    }\\n                    \\n                    num = num * 10 + s1[p1 + i] - \\'0\\';\\n                    \\n                    if (dfs(s1, s2, p1 + i + 1, p2, num, c2))\\n                    {\\n                        return f[key] = true;\\n                    }\\n                }\\n                \\n                return f[key] = false;\\n            }\\n        }\\n        \\n        // Here, both c1 and c2 must be 0s\\n        \\n        if (is_letter(s1[p1]) && is_letter(s2[p2]))\\n        {\\n            return f[key] = (s1[p1] == s2[p2] && dfs(s1, s2, p1 + 1, p2 + 1, 0, 0));\\n        }\\n        \\n        if (is_digit(s1[p1]))\\n        {\\n            int num = 0;\\n            \\n            for (int i = 0; p1 + i < s1.length(); i++)\\n            {\\n                if (!is_digit(s1[p1 + i]))\\n                {\\n                    break;\\n                }\\n                \\n                num = num * 10 + s1[p1 + i] - \\'0\\';\\n                \\n                if (dfs(s1, s2, p1 + i + 1, p2, num, 0))\\n                {\\n                    return f[key] = true;\\n                }\\n            }\\n            \\n            return f[key] = false;\\n        }\\n        \\n        if (is_digit(s2[p2]))\\n        {\\n            int num = 0;\\n            \\n            for (int i = 0; p2 + i < s2.length(); i++)\\n            {\\n                if (!is_digit(s2[p2 + i]))\\n                {\\n                    break;\\n                }\\n                \\n                num = num * 10 + s2[p2 + i] - \\'0\\';\\n                \\n                if (dfs(s1, s2, p1, p2 + i + 1, 0, num))\\n                {\\n                    return f[key] = true;\\n                }\\n            }\\n\\n\\t\\t\\treturn f[key] = false;\\n        }\\n        \\n        // Ideally, we should never go here\\n        throw invalid_argument(\"Sth went wrong\");\\n    }\\n    \\n    bool possiblyEquals(string s1, string s2)\\n    {\\n        return dfs(s1, s2, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345620,
                "title": "short-easy-dynamic-programming",
                "content": "Let `f(i,j,x,y)` denotest whether we can make `s1[i:]` equal to `s2[j:]` knowing that we can add `x` / `y` arbitrary chars to the front of `i`, `j` respectively. \\n\\nObviously, `f(i=0,j=0,x=0,y=0)`  is the expected answer.\\n\\nThere are follwing cases to consider:\\n* If both `x` and `y` is greater than 0, let\\'s `k = min(x,y)` then  `f(i,j,x,y) = f(i,j,x-k,y-k)`.\\n\\t<details>\\n\\t<summary>Explanation</summary>\\n\\t\\n\\t`x` and `y` arbitrary chars can be added to the front of `i`/`j`, therefore there\\'s always a way to make their first `min(x,y)` chars identical. The problem is reduced to the mentioned formula.\\n\\t</details> \\n* If `i` is a char and and `y` is greater than 0, then `f(i,j,x,y) = f(i+1,j,x,y-1)` (using one arbitrary of the first `y` chars of `j` to match `s1[i]`.\\n* If  `i`  is a digit, then up the maximum length of 3, if substring `s1[i:i+length]` is a number,  ` f(i+length,x+s[i:i+length],y)` is a possible solution (move to `i+length` position, the number of arbitrary chars can be add to the front increased by `s[i:i+length]`). \\n* Same arguments can be made with `j` as in the two previous statements\\n* If none of the above occurs, this means, `i` and `j` are chars, and `x=y=0`. In this case, unless `s1[i] == s2[j]` and `f(i+1,j+1)` is True, no solution could be found.\\n\\t\\n```python\\n def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        n, m = len(s1), len(s2)\\n        @functools.lru_cache(None)\\n        def find(i,j,x=0,y=0):\\n            if x > 0 and y > 0:\\n                 return find(i,j,x-min(x,y),y-min(x,y))\\n            if i == n and j == m:\\n                return x == y\\n            if i < n and s1[i].isalpha() and y:\\n                return find(i+1,j,x,y-1)\\n            if j < m and s2[j].isalpha() and x:\\n                return find(i,j+1,x-1,y)\\n            for k in range(i, min(n,i+3)):\\n                if s1[i:k+1].isdigit() and find(k+1,j,x+int(s1[i:k+1]),y):\\n                        return True\\n            for k in range(j,min(m,j+3)):\\n                if s2[j:k+1].isdigit() and find(i,k+1,x,y+int(s2[j:k+1])):\\n                        return True\\n            if i < n and j < m and  s1[i] == s2[j]  and find(i+1,j+1,x,y):\\n                return True\\n        return find(0,0)\\n```",
                "solutionTags": [],
                "code": "```python\\n def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        n, m = len(s1), len(s2)\\n        @functools.lru_cache(None)\\n        def find(i,j,x=0,y=0):\\n            if x > 0 and y > 0:\\n                 return find(i,j,x-min(x,y),y-min(x,y))\\n            if i == n and j == m:\\n                return x == y\\n            if i < n and s1[i].isalpha() and y:\\n                return find(i+1,j,x,y-1)\\n            if j < m and s2[j].isalpha() and x:\\n                return find(i,j+1,x-1,y)\\n            for k in range(i, min(n,i+3)):\\n                if s1[i:k+1].isdigit() and find(k+1,j,x+int(s1[i:k+1]),y):\\n                        return True\\n            for k in range(j,min(m,j+3)):\\n                if s2[j:k+1].isdigit() and find(i,k+1,x,y+int(s2[j:k+1])):\\n                        return True\\n            if i < n and j < m and  s1[i] == s2[j]  and find(i+1,j+1,x,y):\\n                return True\\n        return find(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2185908,
                "title": "c-dfs-added-comments",
                "content": "**Note:** Logic is same as [Votrubac\\'s solution](https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1551731/DFS), but the code is more readable, and I have also added comments to explain what\\'s happening. This problem is super hard.\\n\\n```\\nclass Solution {\\npublic:\\n    bool visited[41][41][2000] = {};\\n    bool possiblyEquals(string a, string b) {\\n        return helper(a, b, 0, 0, 0);\\n    }\\n    \\nprivate:\\n    bool helper(string& a, string& b, int i, int j, int diff){\\n        if(i == a.size() && j== b.size()) return diff == 0;\\n        \\n        if(visited[i][j][diff + 1000] == false){\\n            visited[i][j][diff + 1000] = true;\\n            \\n            \\n            //a[i] is digit\\n            if(i < a.size() && isdigit(a[i])) {\\n                int val = 0;\\n                for(int p = i; p < a.size() && isdigit(a[p]); p++){\\n                    val = val*10 + (a[p] - \\'0\\');\\n                    \\n                    //Wildcard in string a is given by -ve diff, hence diff-val\\n                    if(helper(a, b, p+1, j, diff-val)) return true;\\n                }\\n                return false;\\n            }\\n            \\n            //b[i] is digit\\n            if(j < b.size() && isdigit(b[j])) {\\n                int val = 0;\\n                for(int p = j; p < b.size() && isdigit(b[p]); p++){\\n                    val = val*10 + (b[p] - \\'0\\');\\n\\n                    //Wildcard in string b is given by +ve diff, hence diff+val\\n                    if(helper(a, b, i, p+1, diff+val)) return true;\\n                }\\n                return false;\\n            }\\n            \\n            //b had wildcard and hence diff > 0, so move further in a and move diff towards 0\\n            if(diff > 0) return i<a.size() && helper(a, b, i+1, j, diff-1);\\n            \\n            //a had wildcard and hence diff < 0, so move further in b and move diff towards 0\\n            if(diff < 0) return j<b.size() && helper(a, b, i, j+1, diff+1);\\n            \\n            //if both a[i] and b[j] are characters\\n            return i<a.size() && j<b.size() && a[i] == b[j] && helper(a, b, i+1, j+1, diff);\\n        }\\n        return false;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool visited[41][41][2000] = {};\\n    bool possiblyEquals(string a, string b) {\\n        return helper(a, b, 0, 0, 0);\\n    }\\n    \\nprivate:\\n    bool helper(string& a, string& b, int i, int j, int diff){\\n        if(i == a.size() && j== b.size()) return diff == 0;\\n        \\n        if(visited[i][j][diff + 1000] == false){\\n            visited[i][j][diff + 1000] = true;\\n            \\n            \\n            //a[i] is digit\\n            if(i < a.size() && isdigit(a[i])) {\\n                int val = 0;\\n                for(int p = i; p < a.size() && isdigit(a[p]); p++){\\n                    val = val*10 + (a[p] - \\'0\\');\\n                    \\n                    //Wildcard in string a is given by -ve diff, hence diff-val\\n                    if(helper(a, b, p+1, j, diff-val)) return true;\\n                }\\n                return false;\\n            }\\n            \\n            //b[i] is digit\\n            if(j < b.size() && isdigit(b[j])) {\\n                int val = 0;\\n                for(int p = j; p < b.size() && isdigit(b[p]); p++){\\n                    val = val*10 + (b[p] - \\'0\\');\\n\\n                    //Wildcard in string b is given by +ve diff, hence diff+val\\n                    if(helper(a, b, i, p+1, diff+val)) return true;\\n                }\\n                return false;\\n            }\\n            \\n            //b had wildcard and hence diff > 0, so move further in a and move diff towards 0\\n            if(diff > 0) return i<a.size() && helper(a, b, i+1, j, diff-1);\\n            \\n            //a had wildcard and hence diff < 0, so move further in b and move diff towards 0\\n            if(diff < 0) return j<b.size() && helper(a, b, i, j+1, diff+1);\\n            \\n            //if both a[i] and b[j] are characters\\n            return i<a.size() && j<b.size() && a[i] == b[j] && helper(a, b, i+1, j+1, diff);\\n        }\\n        return false;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128422,
                "title": "python3-recursive-dfs-cache",
                "content": "Inspired by this video: https://www.youtube.com/watch?v=K6d524jDH3A\\n\\nUsed cache to memorize results of previous recursive dfs.\\n\\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def findHead(s):\\n            \"\"\"\\n            Find the head of the string\\n            Input: String / Return:  a letter or a stirng of numbers\\n            \"\"\"\\n            i = 0\\n            if s[0].isalpha():\\n                return s[0], s[1: ]\\n            else:\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                return s[:i], s[i:] \\n\\n        def possibleNumber(ns):\\n            \"\"\"\\n            Function to parse numbers in the string\\n            Input: number as string / Return: list that contains possible numbers\\n            \"\"\"\\n            res = [int(ns)]\\n            if len(ns) == 2:\\n                res.append(int(ns[0]) + int(ns[1]))  # a + b\\n            elif len(ns) == 3:\\n                res.append(int(ns[0]) + int(ns[1]) + int(ns[2]))  # a + b + c\\n                res.append(int(ns[0:2]) + int(ns[2]))  # ab + c\\n                res.append(int(ns[0]) + int(ns[1:]))  # a + bc\\n            return res\\n        \\n        # main recursive func to compare two strings\\n        @cache \\n        def dfs(h1, s1, h2, s2):\\n            \"\"\"\\n            Input: head of s1, s1, head of s2, s2\\n            Return: bool of whether s1 can be encoded to s2\\n            \"\"\"\\n            # if reach to the end for both strings, return True\\n            if not s1 and not s2 and not h1 and not h2:\\n                return True\\n            \\n            # if s1 or s2 reach to end, return False\\n            if (not s1 and not h1) or (not h2 and not s2):\\n                return False\\n            \\n            # if h1 == 0, get new h1 from s1\\n            if h1 == 0:\\n                h1, s1 = findHead(s1)\\n                if h1.isdigit():  # get all possible numbers for h1\\n                    for new_h1 in possibleNumber(h1):\\n                        if dfs(new_h1, s1, h2, s2):\\n                            return True\\n                    return False\\n                    \\n            # if h2 == 0, get new h2 from s2\\n            if h2 == 0: \\n                h2, s2 = findHead(s2)\\n                if h2.isdigit():  # get all possible numbers for h2\\n                    for new_h2 in possibleNumber(h2):\\n                        if dfs(h1, s1, new_h2, s2):\\n                            return True\\n                    return False\\n                \\n            h1_, h2_ = str(h1), str(h2)\\n            # if both h1 and h2 are numbers\\n            if h1_.isdigit() and h2_.isdigit():\\n                    return dfs(max(0, h1 - h2), s1, max(h2 - h1, 0), s2)\\n            \\n            # if h1 is letter and h2 is number\\n            elif h1_.isalpha() and h2_.isdigit():\\n                return dfs(0, s1, h2 - 1, s2)\\n            \\n            # if h2 is letter and h1 is number\\n            elif h2_.isalpha() and h1_.isdigit():\\n                return dfs(h1 - 1, s1, 0, s2)\\n\\n            # if both h1 and h2 are letters\\n            elif h1_.isalpha() and h2_.isalpha():\\n                if h1 != h2:\\n                    return False\\n                return dfs(0, s1, 0, s2)\\n                \\n        return dfs(0, s1, 0, s2)\\n```\\n\\nThe time and space complexity are dependent on the number of recursive calls, which in the worst case  is O(4^10). Please let me know if you have any suggestions. Thanks\\n    \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def findHead(s):\\n            \"\"\"\\n            Find the head of the string\\n            Input: String / Return:  a letter or a stirng of numbers\\n            \"\"\"\\n            i = 0\\n            if s[0].isalpha():\\n                return s[0], s[1: ]\\n            else:\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                return s[:i], s[i:] \\n\\n        def possibleNumber(ns):\\n            \"\"\"\\n            Function to parse numbers in the string\\n            Input: number as string / Return: list that contains possible numbers\\n            \"\"\"\\n            res = [int(ns)]\\n            if len(ns) == 2:\\n                res.append(int(ns[0]) + int(ns[1]))  # a + b\\n            elif len(ns) == 3:\\n                res.append(int(ns[0]) + int(ns[1]) + int(ns[2]))  # a + b + c\\n                res.append(int(ns[0:2]) + int(ns[2]))  # ab + c\\n                res.append(int(ns[0]) + int(ns[1:]))  # a + bc\\n            return res\\n        \\n        # main recursive func to compare two strings\\n        @cache \\n        def dfs(h1, s1, h2, s2):\\n            \"\"\"\\n            Input: head of s1, s1, head of s2, s2\\n            Return: bool of whether s1 can be encoded to s2\\n            \"\"\"\\n            # if reach to the end for both strings, return True\\n            if not s1 and not s2 and not h1 and not h2:\\n                return True\\n            \\n            # if s1 or s2 reach to end, return False\\n            if (not s1 and not h1) or (not h2 and not s2):\\n                return False\\n            \\n            # if h1 == 0, get new h1 from s1\\n            if h1 == 0:\\n                h1, s1 = findHead(s1)\\n                if h1.isdigit():  # get all possible numbers for h1\\n                    for new_h1 in possibleNumber(h1):\\n                        if dfs(new_h1, s1, h2, s2):\\n                            return True\\n                    return False\\n                    \\n            # if h2 == 0, get new h2 from s2\\n            if h2 == 0: \\n                h2, s2 = findHead(s2)\\n                if h2.isdigit():  # get all possible numbers for h2\\n                    for new_h2 in possibleNumber(h2):\\n                        if dfs(h1, s1, new_h2, s2):\\n                            return True\\n                    return False\\n                \\n            h1_, h2_ = str(h1), str(h2)\\n            # if both h1 and h2 are numbers\\n            if h1_.isdigit() and h2_.isdigit():\\n                    return dfs(max(0, h1 - h2), s1, max(h2 - h1, 0), s2)\\n            \\n            # if h1 is letter and h2 is number\\n            elif h1_.isalpha() and h2_.isdigit():\\n                return dfs(0, s1, h2 - 1, s2)\\n            \\n            # if h2 is letter and h1 is number\\n            elif h2_.isalpha() and h1_.isdigit():\\n                return dfs(h1 - 1, s1, 0, s2)\\n\\n            # if both h1 and h2 are letters\\n            elif h1_.isalpha() and h2_.isalpha():\\n                if h1 != h2:\\n                    return False\\n                return dfs(0, s1, 0, s2)\\n                \\n        return dfs(0, s1, 0, s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973418,
                "title": "python-dp-99-70-with-comments",
                "content": "```\\nfrom functools import cache\\n\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def tokenize(s):\\n            # tokenize the string into contiguous\\n            # alpha and digit subsequences\\n            result = []\\n            number = []\\n            for c in s:\\n                if c.isdigit():\\n                    number.append(c)\\n                else:\\n                    if number:\\n                        result.append(\"\".join(number))\\n                        number.clear()\\n                    result.append(c)\\n            if number:\\n                result.append(\"\".join(number))\\n            \\n            return result\\n        \\n        \\n        @cache\\n        def get_numbers(s):\\n            # get possible numbers \\n            # from the digit sequence\\n            result = [int(s)]\\n            if len(s) == 2:\\n                result.append(int(s[0]) + int(s[1]))\\n            elif len(s) == 3:\\n                result.append(int(s[0]) + int(s[1:]))\\n                result.append(int(s[0]) + int(s[1]) + int(s[2]))\\n                result.append(int(s[:2]) + int(s[2]))\\n            \\n            return result\\n        \\n        \\n        # pre-process the strings\\n        s1 = tokenize(s1)\\n        s2 = tokenize(s2)\\n        n1 = len(s1)\\n        n2 = len(s2)\\n\\n        \\n        @cache\\n        def dp_top_down(offset, i1, i2):\\n            if offset > 0:\\n                # there is offset from s1\\n                if i2 == n2:\\n                    # s2 ran out\\n                    return False\\n                elif s2[i2].isalpha():\\n                    # next token in s2 is a letter\\n                    return dp_top_down(offset - 1, i1, i2 + 1)\\n                else:\\n                    # next token in s2 is a number\\n                    for num2 in get_numbers(s2[i2]):\\n                        if dp_top_down(offset - num2, i1, i2 + 1):\\n                            return True\\n            elif offset < 0:\\n                # there is offset from s2\\n                if i1 == n1:\\n                    # s1 ran out\\n                    return False\\n                elif s1[i1].isalpha():\\n                    # next token in s1 is a letter\\n                    return dp_top_down(offset + 1, i1 + 1, i2)\\n                else:\\n                    # next token in s1 is a number\\n                    for num1 in get_numbers(s1[i1]):\\n                        if dp_top_down(offset + num1, i1 + 1, i2):\\n                            return True\\n            elif i1 == n1:\\n                if i2 == n2:\\n                    # both s1 and s2 ran out\\n                    return True\\n                else:\\n                    # s1 ran out, but not s2\\n                    return False\\n            elif i2 == n2:\\n                # s2 ran out, but not s1\\n                return False\\n            elif s1[i1].isalpha():\\n                if s2[i2].isalpha():\\n                    if s1[i1] == s2[i2]:\\n                        # next tokens are equal letters\\n                        return dp_top_down(0, i1 + 1, i2 + 1)\\n                    else:\\n                        # next tokens are different letters\\n                        return False\\n                else:\\n                    # next token in s1 is a letter\\n                    # next token in s2 is a number\\n                    for num2 in get_numbers(s2[i2]):\\n                        if dp_top_down(-num2 + 1, i1 + 1, i2 + 1):\\n                            return True\\n            elif s2[i2].isalpha():\\n                # next token in s1 is a number\\n                # next token in s2 is a letter\\n                for num1 in get_numbers(s1[i1]):\\n                    if dp_top_down(num1 - 1, i1 + 1, i2 + 1):\\n                        return True\\n            else:\\n                # next tokens are numbers\\n                # generate all possible combinations\\n                for num1 in get_numbers(s1[i1]):\\n                    for num2 in get_numbers(s2[i2]):\\n                        if dp_top_down(num1 - num2, i1 + 1, i2 + 1):\\n                            return True\\n            \\n            # none of the above worked\\n            return False\\n        \\n        \\n        # initial conditions: no leftover, \\n        # start from the first tokens in s1 and s2\\n        return dp_top_down(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import cache\\n\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def tokenize(s):\\n            # tokenize the string into contiguous\\n            # alpha and digit subsequences\\n            result = []\\n            number = []\\n            for c in s:\\n                if c.isdigit():\\n                    number.append(c)\\n                else:\\n                    if number:\\n                        result.append(\"\".join(number))\\n                        number.clear()\\n                    result.append(c)\\n            if number:\\n                result.append(\"\".join(number))\\n            \\n            return result\\n        \\n        \\n        @cache\\n        def get_numbers(s):\\n            # get possible numbers \\n            # from the digit sequence\\n            result = [int(s)]\\n            if len(s) == 2:\\n                result.append(int(s[0]) + int(s[1]))\\n            elif len(s) == 3:\\n                result.append(int(s[0]) + int(s[1:]))\\n                result.append(int(s[0]) + int(s[1]) + int(s[2]))\\n                result.append(int(s[:2]) + int(s[2]))\\n            \\n            return result\\n        \\n        \\n        # pre-process the strings\\n        s1 = tokenize(s1)\\n        s2 = tokenize(s2)\\n        n1 = len(s1)\\n        n2 = len(s2)\\n\\n        \\n        @cache\\n        def dp_top_down(offset, i1, i2):\\n            if offset > 0:\\n                # there is offset from s1\\n                if i2 == n2:\\n                    # s2 ran out\\n                    return False\\n                elif s2[i2].isalpha():\\n                    # next token in s2 is a letter\\n                    return dp_top_down(offset - 1, i1, i2 + 1)\\n                else:\\n                    # next token in s2 is a number\\n                    for num2 in get_numbers(s2[i2]):\\n                        if dp_top_down(offset - num2, i1, i2 + 1):\\n                            return True\\n            elif offset < 0:\\n                # there is offset from s2\\n                if i1 == n1:\\n                    # s1 ran out\\n                    return False\\n                elif s1[i1].isalpha():\\n                    # next token in s1 is a letter\\n                    return dp_top_down(offset + 1, i1 + 1, i2)\\n                else:\\n                    # next token in s1 is a number\\n                    for num1 in get_numbers(s1[i1]):\\n                        if dp_top_down(offset + num1, i1 + 1, i2):\\n                            return True\\n            elif i1 == n1:\\n                if i2 == n2:\\n                    # both s1 and s2 ran out\\n                    return True\\n                else:\\n                    # s1 ran out, but not s2\\n                    return False\\n            elif i2 == n2:\\n                # s2 ran out, but not s1\\n                return False\\n            elif s1[i1].isalpha():\\n                if s2[i2].isalpha():\\n                    if s1[i1] == s2[i2]:\\n                        # next tokens are equal letters\\n                        return dp_top_down(0, i1 + 1, i2 + 1)\\n                    else:\\n                        # next tokens are different letters\\n                        return False\\n                else:\\n                    # next token in s1 is a letter\\n                    # next token in s2 is a number\\n                    for num2 in get_numbers(s2[i2]):\\n                        if dp_top_down(-num2 + 1, i1 + 1, i2 + 1):\\n                            return True\\n            elif s2[i2].isalpha():\\n                # next token in s1 is a number\\n                # next token in s2 is a letter\\n                for num1 in get_numbers(s1[i1]):\\n                    if dp_top_down(num1 - 1, i1 + 1, i2 + 1):\\n                        return True\\n            else:\\n                # next tokens are numbers\\n                # generate all possible combinations\\n                for num1 in get_numbers(s1[i1]):\\n                    for num2 in get_numbers(s2[i2]):\\n                        if dp_top_down(num1 - num2, i1 + 1, i2 + 1):\\n                            return True\\n            \\n            # none of the above worked\\n            return False\\n        \\n        \\n        # initial conditions: no leftover, \\n        # start from the first tokens in s1 and s2\\n        return dp_top_down(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789943,
                "title": "python-dp-memo",
                "content": "The general gist is simple - we convert the string to a list of either strings, or sets (where items in the set are all possible variations of wildcard length).\\n\\nThen we iterate through both strings (actually iterating through all possibilities of each string + wildcards) and we see if they match up till the end. They will not match if they have different lengths, or if any character that matches to another character (not a wildcard) aren\\'t equal.\\n\\nThere are 4 cases:\\n1. You\\'re comparing a char to a wildcard\\n2. You\\'re comparing a wildcard to a char\\n3. You\\'re comparing two wildcards\\n4. You\\'re comparing two chars\\n\\nAs long as you keep that in mind you\\'re good.\\n\\n```\\nfrom functools import cache\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        repr1 = Solution.parse(s1)\\n        repr2 = Solution.parse(s2)\\n        i = j = 0\\n        \\n        @cache\\n        def dfs(i, j, diff):\\n            # if both strings have been exhausted, we\\'re done\\n            # if only one string is at max-length, then we\\'re probably iterating through\\n            # the diffs, so we can wait\\n            if i == len(repr1) and j == len(repr2):\\n                return diff == 0\\n            \\n            # if only one string has been exhausted, we\\'re not able to match the two\\n            if i > len(repr1) or j > len(repr2):\\n                return False\\n            \\n            ei = repr1[i] if i < len(repr1) else \\'\\'\\n            ej = repr2[j] if j < len(repr2) else \\'\\'\\n\\n            # if one is wildcards and the other is a string\\n            # go through all the possibilities for wildcards and recurse\\n            if type(ei) != str and type(ej) == str:\\n                for di in ei:\\n                    if dfs(i + 1, j, diff + di):\\n                        return True\\n                return False\\n            \\n            if type(ei) == str and type(ej) != str:\\n                for dj in ej:\\n                    if dfs(i, j + 1, diff - dj):\\n                        return True\\n                return False\\n\\n            # if both are wildcards\\n            # you need to go through all the combinations\\n            if type(ei) != str and type(ej) != str:\\n                for di in ei:\\n                    for dj in ej:\\n                        if dfs(i + 1, j + 1, diff + di - dj):\\n                            return True\\n                return False\\n            \\n            # if both are strings\\n            if type(ei) == str and type(ej) == str:\\n                # if you have no wildcards, you\\'re just checking if both strings are equivalent\\n                if diff == 0:\\n                    if ei != ej:\\n                        return False\\n                    else:\\n                        return dfs(i + 1, j + 1, diff)\\n                else:\\n                    # use up some wildcards\\n                    if diff > 0:\\n                        return dfs(i, j + 1, diff - 1)\\n                    else:\\n                        return dfs(i + 1, j, diff + 1)\\n            \\n        \\n        return dfs(0, 0, 0)\\n        \\n    @staticmethod\\n    def parse(string):\\n        res = []\\n        numbers = []\\n        for c in string:\\n            if c.isdigit():\\n                numbers.append(c)\\n            else:\\n                if numbers:\\n                    res.append(Solution.allpossiblewildcardlengths(numbers, 0, set()))\\n                    numbers = []\\n                res.append(c)\\n        if numbers:\\n            res.append(Solution.allpossiblewildcardlengths(numbers, 0, set()))\\n        return res\\n    \\n    @staticmethod\\n    def allpossiblewildcardlengths(nums, carryover = 0, options = set()):\\n        if len(nums) == 0:\\n            return\\n\\n        # everything\\n        for x in range(1, len(nums) + 1):\\n            prefix = \\'\\'.join(nums[:x])\\n            pint = int(prefix)\\n            if x == len(nums):\\n                options.add(carryover + pint)\\n            else:\\n                Solution.allpossiblewildcardlengths(nums[x:], carryover + pint, options)\\n\\n        return options\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        repr1 = Solution.parse(s1)\\n        repr2 = Solution.parse(s2)\\n        i = j = 0\\n        \\n        @cache\\n        def dfs(i, j, diff):\\n            # if both strings have been exhausted, we\\'re done\\n            # if only one string is at max-length, then we\\'re probably iterating through\\n            # the diffs, so we can wait\\n            if i == len(repr1) and j == len(repr2):\\n                return diff == 0\\n            \\n            # if only one string has been exhausted, we\\'re not able to match the two\\n            if i > len(repr1) or j > len(repr2):\\n                return False\\n            \\n            ei = repr1[i] if i < len(repr1) else \\'\\'\\n            ej = repr2[j] if j < len(repr2) else \\'\\'\\n\\n            # if one is wildcards and the other is a string\\n            # go through all the possibilities for wildcards and recurse\\n            if type(ei) != str and type(ej) == str:\\n                for di in ei:\\n                    if dfs(i + 1, j, diff + di):\\n                        return True\\n                return False\\n            \\n            if type(ei) == str and type(ej) != str:\\n                for dj in ej:\\n                    if dfs(i, j + 1, diff - dj):\\n                        return True\\n                return False\\n\\n            # if both are wildcards\\n            # you need to go through all the combinations\\n            if type(ei) != str and type(ej) != str:\\n                for di in ei:\\n                    for dj in ej:\\n                        if dfs(i + 1, j + 1, diff + di - dj):\\n                            return True\\n                return False\\n            \\n            # if both are strings\\n            if type(ei) == str and type(ej) == str:\\n                # if you have no wildcards, you\\'re just checking if both strings are equivalent\\n                if diff == 0:\\n                    if ei != ej:\\n                        return False\\n                    else:\\n                        return dfs(i + 1, j + 1, diff)\\n                else:\\n                    # use up some wildcards\\n                    if diff > 0:\\n                        return dfs(i, j + 1, diff - 1)\\n                    else:\\n                        return dfs(i + 1, j, diff + 1)\\n            \\n        \\n        return dfs(0, 0, 0)\\n        \\n    @staticmethod\\n    def parse(string):\\n        res = []\\n        numbers = []\\n        for c in string:\\n            if c.isdigit():\\n                numbers.append(c)\\n            else:\\n                if numbers:\\n                    res.append(Solution.allpossiblewildcardlengths(numbers, 0, set()))\\n                    numbers = []\\n                res.append(c)\\n        if numbers:\\n            res.append(Solution.allpossiblewildcardlengths(numbers, 0, set()))\\n        return res\\n    \\n    @staticmethod\\n    def allpossiblewildcardlengths(nums, carryover = 0, options = set()):\\n        if len(nums) == 0:\\n            return\\n\\n        # everything\\n        for x in range(1, len(nums) + 1):\\n            prefix = \\'\\'.join(nums[:x])\\n            pint = int(prefix)\\n            if x == len(nums):\\n                options.add(carryover + pint)\\n            else:\\n                Solution.allpossiblewildcardlengths(nums[x:], carryover + pint, options)\\n\\n        return options\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550260,
                "title": "update-fixed-solutions-that-fail-s1-ab-s2-1a-get-ac",
                "content": "([Issue fixed. The test case has been added to the suite among 3 others](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/5192))\\n\\nThis is surprising. Perhaps this gets overlooked because most people don\\'t write it like this?\\n```\\n# VERY WRONG BUT ACCEPTED \"SOLUTION\"\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:        \\n        def cut(s):\\n            l = []\\n            for k, it in itertools.groupby(s, key=lambda c: c.isdigit()):\\n                sub = \\'\\'.join(it)\\n                l.append(sub)\\n            return l\\n        l1 = cut(s1)\\n        l2 = cut(s2)\\n        def count(d):\\n            d = [int(c) for c in d]\\n            if len(d) == 1:\\n                yield d[0]\\n            elif len(d) == 2:\\n                yield sum(d)\\n                yield 10 * d[0] + d[1]\\n            else:\\n                yield sum(d)\\n                yield 10 * d[0] + d[1] + d[2]\\n                yield d[0] + 10 * d[1] + d[2]\\n                yield 100 * d[0] + 10 * d[1] + d[2]\\n        m, n = len(l1), len(l2)\\n        \\n        @functools.lru_cache(None)\\n        def equ(i, j, diff):\\n            if i == m and j == n:\\n                return not diff\\n            if i < m and l1[i].isdigit():\\n                return any(equ(i + 1, j, diff + op) for op in count(l1[i]))\\n            elif j < n and l2[j].isdigit():\\n                return any(equ(i, j + 1, diff - op) for op in count(l2[j]))\\n            else:\\n                if diff > 0 and j < n:\\n                    return equ(i, j + 1, diff - len(l2[j]))\\n                elif diff < 0 and i < m:\\n                    return equ(i + 1, j, diff + len(l1[i]))\\n                elif i < m and j < n:\\n                    min_len = min(len(l1[i]), len(l2[j]))\\n                    if l1[i][:min_len] != l2[j][:min_len]:\\n                        return False\\n                    if len(l1[i]) == len(l2[j]):\\n                        return equ(i + 1, j + 1, diff)\\n                    elif len(l1[i]) < len(l2[j]):\\n                        return equ(i + 1, j, diff + len(l1[i]))\\n                    else:\\n                        return equ(i, j + 1, diff - len(l2[j]))\\n            return False\\n                \\n        return equ(0, 0, 0)\\n```\\nThis \"solution\" just skips the whole lowercase substring, even when the wildcard count is not big enough. As long as the total length matches this \"solution\" returns true.\\n\\nThe version below seems to be working but I am not 100% sure. It did pass the updated test suite though so I am more confident now \\uD83D\\uDE05:\\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:        \\n        def cut(s):\\n            l = []\\n            for k, it in itertools.groupby(s, key=lambda c: c.isdigit()):\\n                sub = \\'\\'.join(it)\\n                l.append(sub)\\n            return l\\n        l1 = cut(s1)\\n        l2 = cut(s2)\\n        def count(d):\\n            d = [int(c) for c in d]\\n            if len(d) == 1:\\n                yield d[0]\\n            elif len(d) == 2:\\n                yield sum(d)\\n                yield 10 * d[0] + d[1]\\n            else:\\n                yield sum(d)\\n                yield 10 * d[0] + d[1] + d[2]\\n                yield d[0] + 10 * d[1] + d[2]\\n                yield 100 * d[0] + 10 * d[1] + d[2]\\n        m, n = len(l1), len(l2)\\n        def helper(i, j, x, y):\\n            min_c = min(x, y)\\n            x -= min_c\\n            y -= min_c\\n            return equ(i, j, x, y)\\n        \\n        @functools.lru_cache(None)\\n        def equ(i, j, x, y):\\n            if (i == m and not x) or (j == n and not y):\\n                return (i == m and not x) and (j == n and not y)\\n            if i < m and l1[i].isdigit():\\n                return any(helper(i + 1, j, x + op, y) for op in count(l1[i]))\\n            elif j < n and l2[j].isdigit():\\n                return any(helper(i, j + 1, x, y + op) for op in count(l2[j]))\\n            else:\\n                if x > 0 and x >= len(l2[j]):\\n                    return helper(i, j + 1, x - len(l2[j]), y)\\n                elif y > 0 and y >= len(l1[i]):\\n                    return helper(i + 1, j, x, y - len(l1[i]))\\n                else:\\n                    if i == m or j == n:\\n                        return False\\n                    min_len = min(len(l1[i]) - y, len(l2[j]) - x)\\n                    if l1[i][y: y + min_len] != l2[j][x:x + min_len]:\\n                        return False\\n                    if len(l1[i]) - y == len(l2[j]) - x:\\n                        return helper(i + 1, j + 1, 0, 0)\\n                    elif len(l1[i]) - y < len(l2[j]) - x:\\n                        return helper(i + 1, j, x + len(l1[i]), y)\\n                    else:\\n                        return helper(i, j + 1, x, y + len(l2[j]))\\n        return equ(0, 0, 0, 0)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# VERY WRONG BUT ACCEPTED \"SOLUTION\"\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:        \\n        def cut(s):\\n            l = []\\n            for k, it in itertools.groupby(s, key=lambda c: c.isdigit()):\\n                sub = \\'\\'.join(it)\\n                l.append(sub)\\n            return l\\n        l1 = cut(s1)\\n        l2 = cut(s2)\\n        def count(d):\\n            d = [int(c) for c in d]\\n            if len(d) == 1:\\n                yield d[0]\\n            elif len(d) == 2:\\n                yield sum(d)\\n                yield 10 * d[0] + d[1]\\n            else:\\n                yield sum(d)\\n                yield 10 * d[0] + d[1] + d[2]\\n                yield d[0] + 10 * d[1] + d[2]\\n                yield 100 * d[0] + 10 * d[1] + d[2]\\n        m, n = len(l1), len(l2)\\n        \\n        @functools.lru_cache(None)\\n        def equ(i, j, diff):\\n            if i == m and j == n:\\n                return not diff\\n            if i < m and l1[i].isdigit():\\n                return any(equ(i + 1, j, diff + op) for op in count(l1[i]))\\n            elif j < n and l2[j].isdigit():\\n                return any(equ(i, j + 1, diff - op) for op in count(l2[j]))\\n            else:\\n                if diff > 0 and j < n:\\n                    return equ(i, j + 1, diff - len(l2[j]))\\n                elif diff < 0 and i < m:\\n                    return equ(i + 1, j, diff + len(l1[i]))\\n                elif i < m and j < n:\\n                    min_len = min(len(l1[i]), len(l2[j]))\\n                    if l1[i][:min_len] != l2[j][:min_len]:\\n                        return False\\n                    if len(l1[i]) == len(l2[j]):\\n                        return equ(i + 1, j + 1, diff)\\n                    elif len(l1[i]) < len(l2[j]):\\n                        return equ(i + 1, j, diff + len(l1[i]))\\n                    else:\\n                        return equ(i, j + 1, diff - len(l2[j]))\\n            return False\\n                \\n        return equ(0, 0, 0)\\n```\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:        \\n        def cut(s):\\n            l = []\\n            for k, it in itertools.groupby(s, key=lambda c: c.isdigit()):\\n                sub = \\'\\'.join(it)\\n                l.append(sub)\\n            return l\\n        l1 = cut(s1)\\n        l2 = cut(s2)\\n        def count(d):\\n            d = [int(c) for c in d]\\n            if len(d) == 1:\\n                yield d[0]\\n            elif len(d) == 2:\\n                yield sum(d)\\n                yield 10 * d[0] + d[1]\\n            else:\\n                yield sum(d)\\n                yield 10 * d[0] + d[1] + d[2]\\n                yield d[0] + 10 * d[1] + d[2]\\n                yield 100 * d[0] + 10 * d[1] + d[2]\\n        m, n = len(l1), len(l2)\\n        def helper(i, j, x, y):\\n            min_c = min(x, y)\\n            x -= min_c\\n            y -= min_c\\n            return equ(i, j, x, y)\\n        \\n        @functools.lru_cache(None)\\n        def equ(i, j, x, y):\\n            if (i == m and not x) or (j == n and not y):\\n                return (i == m and not x) and (j == n and not y)\\n            if i < m and l1[i].isdigit():\\n                return any(helper(i + 1, j, x + op, y) for op in count(l1[i]))\\n            elif j < n and l2[j].isdigit():\\n                return any(helper(i, j + 1, x, y + op) for op in count(l2[j]))\\n            else:\\n                if x > 0 and x >= len(l2[j]):\\n                    return helper(i, j + 1, x - len(l2[j]), y)\\n                elif y > 0 and y >= len(l1[i]):\\n                    return helper(i + 1, j, x, y - len(l1[i]))\\n                else:\\n                    if i == m or j == n:\\n                        return False\\n                    min_len = min(len(l1[i]) - y, len(l2[j]) - x)\\n                    if l1[i][y: y + min_len] != l2[j][x:x + min_len]:\\n                        return False\\n                    if len(l1[i]) - y == len(l2[j]) - x:\\n                        return helper(i + 1, j + 1, 0, 0)\\n                    elif len(l1[i]) - y < len(l2[j]) - x:\\n                        return helper(i + 1, j, x + len(l1[i]), y)\\n                    else:\\n                        return helper(i, j + 1, x, y + len(l2[j]))\\n        return equ(0, 0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942862,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\n\\n\\n\\nvar possiblyEquals = function(s1, s2) {    \\n    // Memo array, note that we do not need to memoize true results as these bubble up\\n    const dp = Array.from({length: s1.length+1}, () => \\n                          Array.from({length: s2.length+1}, \\n                                     () => ([])));\\n    \\n    const backtrack = (p1, p2, count) => {\\n        if(p1 === s1.length && p2 === s2.length) return count === 0;\\n        // Optimization: Exit early if we have already visited here and know that it\\'s false\\n        if(dp[p1][p2][count] !== undefined) return dp[p1][p2][count];\\n\\n        let c1 = s1[p1];\\n        let c2 = s2[p2];        \\n        \\n        // Case 1: string matches exactly\\n        if(p1 < s1.length && p2 < s2.length && \\n           c1 === c2 && count === 0 && \\n           backtrack(p1+1, p2+1, count)) return true;\\n\\n        // Case 2: we can delete a character\\n        if(p1 < s1.length && isNaN(c1) && count < 0 && \\n           backtrack(p1+1, p2, count+1)) return true;\\n        if(p2 < s2.length && isNaN(c2) && count > 0 && \\n           backtrack(p1, p2+1, count-1)) return true;            \\n        \\n        // Case 3: we can start stacking numbers to delete\\n        let num = 0;\\n        for(let i = 0; i < 3 && p1+i < s1.length; i++) {            \\n            let c1 = s1[p1+i];\\n            if(isNaN(c1)) break;\\n            num = num * 10 + parseInt(c1);\\n\\n            if(backtrack(p1+i+1, p2, count + num)) return true;\\n        }\\n\\n        num = 0;\\n        for(let i = 0; i < 3 && p2+i < s2.length; i++) {\\n            let c2 = s2[p2+i];\\n            if(isNaN(c2)) break;\\n            num = num * 10 + parseInt(c2);\\n\\n            if(backtrack(p1, p2+i+1, count - num)) return true;\\n        }\\n        \\n        dp[p1][p2][count] = false;\\n        return false;\\n    }\\n    \\n    return backtrack(0,0,0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\n\\n\\n\\nvar possiblyEquals = function(s1, s2) {    \\n    // Memo array, note that we do not need to memoize true results as these bubble up\\n    const dp = Array.from({length: s1.length+1}, () => \\n                          Array.from({length: s2.length+1}, \\n                                     () => ([])));\\n    \\n    const backtrack = (p1, p2, count) => {\\n        if(p1 === s1.length && p2 === s2.length) return count === 0;\\n        // Optimization: Exit early if we have already visited here and know that it\\'s false\\n        if(dp[p1][p2][count] !== undefined) return dp[p1][p2][count];\\n\\n        let c1 = s1[p1];\\n        let c2 = s2[p2];        \\n        \\n        // Case 1: string matches exactly\\n        if(p1 < s1.length && p2 < s2.length && \\n           c1 === c2 && count === 0 && \\n           backtrack(p1+1, p2+1, count)) return true;\\n\\n        // Case 2: we can delete a character\\n        if(p1 < s1.length && isNaN(c1) && count < 0 && \\n           backtrack(p1+1, p2, count+1)) return true;\\n        if(p2 < s2.length && isNaN(c2) && count > 0 && \\n           backtrack(p1, p2+1, count-1)) return true;            \\n        \\n        // Case 3: we can start stacking numbers to delete\\n        let num = 0;\\n        for(let i = 0; i < 3 && p1+i < s1.length; i++) {            \\n            let c1 = s1[p1+i];\\n            if(isNaN(c1)) break;\\n            num = num * 10 + parseInt(c1);\\n\\n            if(backtrack(p1+i+1, p2, count + num)) return true;\\n        }\\n\\n        num = 0;\\n        for(let i = 0; i < 3 && p2+i < s2.length; i++) {\\n            let c2 = s2[p2+i];\\n            if(isNaN(c2)) break;\\n            num = num * 10 + parseInt(c2);\\n\\n            if(backtrack(p1, p2+i+1, count - num)) return true;\\n        }\\n        \\n        dp[p1][p2][count] = false;\\n        return false;\\n    }\\n    \\n    return backtrack(0,0,0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2344464,
                "title": "python-dfs-wild-elements",
                "content": "Thanks for  https://leetcode.com/ye15. \\n\\n1. handle the digits. 2 consecutive digits can have 2 possibility, (\\'23\\': 2+3 or 23) same thing if we got 1 or 3 digits.\\n2. Because there are different combinitions, so here we can use recursion (DFS) to make the code more concise.\\n3. If you play chinese poker, you will be familiar with a card called \\'\\'laizi\\'\\'. And here the digits are the wild elements.\\n4. the DFS func have 4 args: i,j: the idx of s1 &s2. wild1,wild2: the number of wild elements remaining, then start recursion,the problem is solved.\\n\\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def allcomb(s):\\n            n = len(s)\\n            if n == 1:\\n                return [int(s)]\\n            elif n == 2:\\n                return [int(s), int(s[0]) + int(s[1])]\\n            elif n == 3:\\n                return [int(s), int(s[0]) + int(s[1]) + int(s[2]), int(s[:2]) + int(s[2]), int(s[0]) + int(s[1:])]\\n        @lru_cache(maxsize = None)\\n        def solver(i, j, wild1, wild2):\\n            if i == len(s1) and j == len(s2):\\n                return wild1 == wild2\\n            if i < len(s1) and s1[i].isdigit():\\n                newi = i\\n                while newi < len(s1) and s1[newi].isdigit():\\n                    newi += 1\\n                for k in allcomb(s1[i:newi]):\\n                    if solver(newi, j, wild1 + k, wild2):\\n                        return True\\n            elif j < len(s2) and s2[j].isdigit():\\n                newj = j\\n                while newj < len(s2) and s2[newj].isdigit():\\n                    newj += 1\\n                for k in allcomb(s2[j:newj]):\\n                    if solver(i, newj, wild1, wild2 + k):\\n                        return True\\n            else:\\n                    if wild1 > wild2 and j < len(s2):\\n                        return solver(i, j + 1, wild1 - wild2 - 1, 0)\\n                    elif wild1 < wild2 and i < len(s1):\\n                        return solver(i + 1, j, 0, wild2 - wild1 - 1)\\n                    elif i < len(s1) and j < len(s2) and s1[i] == s2[j]:\\n                        return solver(i + 1,j + 1,0,0)\\n            return False\\n        return solver(0,0,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def allcomb(s):\\n            n = len(s)\\n            if n == 1:\\n                return [int(s)]\\n            elif n == 2:\\n                return [int(s), int(s[0]) + int(s[1])]\\n            elif n == 3:\\n                return [int(s), int(s[0]) + int(s[1]) + int(s[2]), int(s[:2]) + int(s[2]), int(s[0]) + int(s[1:])]\\n        @lru_cache(maxsize = None)\\n        def solver(i, j, wild1, wild2):\\n            if i == len(s1) and j == len(s2):\\n                return wild1 == wild2\\n            if i < len(s1) and s1[i].isdigit():\\n                newi = i\\n                while newi < len(s1) and s1[newi].isdigit():\\n                    newi += 1\\n                for k in allcomb(s1[i:newi]):\\n                    if solver(newi, j, wild1 + k, wild2):\\n                        return True\\n            elif j < len(s2) and s2[j].isdigit():\\n                newj = j\\n                while newj < len(s2) and s2[newj].isdigit():\\n                    newj += 1\\n                for k in allcomb(s2[j:newj]):\\n                    if solver(i, newj, wild1, wild2 + k):\\n                        return True\\n            else:\\n                    if wild1 > wild2 and j < len(s2):\\n                        return solver(i, j + 1, wild1 - wild2 - 1, 0)\\n                    elif wild1 < wild2 and i < len(s1):\\n                        return solver(i + 1, j, 0, wild2 - wild1 - 1)\\n                    elif i < len(s1) and j < len(s2) and s1[i] == s2[j]:\\n                        return solver(i + 1,j + 1,0,0)\\n            return False\\n        return solver(0,0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132949,
                "title": "rust-dfs-with-memo",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl5/lc2060)\\n\\n<b>Problem List</b>\\n#DFSMemo - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/search/depth_first_search/by_algorithm/dfs_memo)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/\\n/// Time Complexity:    O(`len1` * `len_2`)\\n/// Space Complexity:   O(`len1` * `len_2`)\\n/// Reference:\\n/// https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550342/Java-Clean-(DFS-+-memo)/1134399\\n/// https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550342/Java-Clean-(DFS-%2B-memo)\\nimpl Solution {\\n    pub fn possibly_equals(s1: String, s2: String) -> bool {\\n        let len1: usize = s1.len();\\n        let chs1: Vec<char> = s1.chars().collect();\\n        let len2: usize = s2.len();\\n        let chs2: Vec<char> = s2.chars().collect();\\n        let mut memo: Vec<Vec<Vec<Option<bool>>>> =\\n            vec![vec![vec![None; 2000]; len2 + 1]; len1 + 1];\\n        Self::dfs(0, 0, 0, &chs1, &chs2, &mut memo)\\n    }\\n    fn dfs(\\n        idx1: usize,\\n        idx2: usize,\\n        diff: i16,\\n        chs1: &Vec<char>,\\n        chs2: &Vec<char>,\\n        memo: &mut Vec<Vec<Vec<Option<bool>>>>,\\n    ) -> bool {\\n        const RADIX: u32 = 10;\\n        let len1: usize = chs1.len();\\n        let len2: usize = chs2.len();\\n        if idx1 == len1 && idx2 == len2 {\\n            return diff == 0;\\n        }\\n        if let Some(m) = memo[idx1][idx2][(diff + 1000) as usize] {\\n            return m;\\n        }\\n        // literal matching for `chs1[idx1]` and `chs2[idx2]`\\n        if idx1 < len1 && idx2 < len2 && diff == 0 && chs1[idx1] == chs2[idx2] {\\n            if Self::dfs(idx1 + 1, idx2 + 1, 0, chs1, chs2, memo) {\\n                memo[idx1][idx2][1000] = Some(true);\\n                return true;\\n            }\\n        }\\n        // literal matching for `chs1[idx1]`\\n        if idx1 < len1\\n            && !chs1[idx1].is_digit(RADIX)\\n            && diff > 0\\n            && Self::dfs(idx1 + 1, idx2, diff - 1, chs1, chs2, memo)\\n        {\\n            memo[idx1][idx2][(diff + 1000) as usize] = Some(true);\\n            return true;\\n        }\\n        // literal matching for `chs2[idx2]`\\n        if idx2 < len2\\n            && !chs2[idx2].is_digit(RADIX)\\n            && diff < 0\\n            && Self::dfs(idx1, idx2 + 1, diff + 1, chs1, chs2, memo)\\n        {\\n            memo[idx1][idx2][(diff + 1000) as usize] = Some(true);\\n            return true;\\n        }\\n        // wild card matching on `chs1[idx1]`\\n        let mut num1: i16 = 0;\\n        for idx in idx1..len1 {\\n            if !chs1[idx].is_digit(RADIX) {\\n                break;\\n            }\\n            num1 = (num1 * 10) + (chs1[idx] as i16 - \\'0\\' as i16);\\n            if Self::dfs(idx + 1, idx2, diff - num1, chs1, chs2, memo) {\\n                memo[idx1][idx2][(diff + 1000) as usize] = Some(true);\\n                return true;\\n            }\\n        }\\n        // wild card matching for `chs2[idx2]`\\n        let mut num2: i16 = 0;\\n        for idx in idx2..len2 {\\n            if !chs2[idx].is_digit(RADIX) {\\n                break;\\n            }\\n            num2 = (num2 * 10) + (chs2[idx] as i16 - \\'0\\' as i16);\\n            if Self::dfs(idx1, idx + 1, diff + num2, chs1, chs2, memo) {\\n                memo[idx1][idx2][(diff + 1000) as usize] = Some(true);\\n                return true;\\n            }\\n        }\\n        memo[idx1][idx2][(diff + 1000) as usize] = Some(false);\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/\\n/// Time Complexity:    O(`len1` * `len_2`)\\n/// Space Complexity:   O(`len1` * `len_2`)\\n/// Reference:\\n/// https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550342/Java-Clean-(DFS-+-memo)/1134399\\n/// https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550342/Java-Clean-(DFS-%2B-memo)\\nimpl Solution {\\n    pub fn possibly_equals(s1: String, s2: String) -> bool {\\n        let len1: usize = s1.len();\\n        let chs1: Vec<char> = s1.chars().collect();\\n        let len2: usize = s2.len();\\n        let chs2: Vec<char> = s2.chars().collect();\\n        let mut memo: Vec<Vec<Vec<Option<bool>>>> =\\n            vec![vec![vec![None; 2000]; len2 + 1]; len1 + 1];\\n        Self::dfs(0, 0, 0, &chs1, &chs2, &mut memo)\\n    }\\n    fn dfs(\\n        idx1: usize,\\n        idx2: usize,\\n        diff: i16,\\n        chs1: &Vec<char>,\\n        chs2: &Vec<char>,\\n        memo: &mut Vec<Vec<Vec<Option<bool>>>>,\\n    ) -> bool {\\n        const RADIX: u32 = 10;\\n        let len1: usize = chs1.len();\\n        let len2: usize = chs2.len();\\n        if idx1 == len1 && idx2 == len2 {\\n            return diff == 0;\\n        }\\n        if let Some(m) = memo[idx1][idx2][(diff + 1000) as usize] {\\n            return m;\\n        }\\n        // literal matching for `chs1[idx1]` and `chs2[idx2]`\\n        if idx1 < len1 && idx2 < len2 && diff == 0 && chs1[idx1] == chs2[idx2] {\\n            if Self::dfs(idx1 + 1, idx2 + 1, 0, chs1, chs2, memo) {\\n                memo[idx1][idx2][1000] = Some(true);\\n                return true;\\n            }\\n        }\\n        // literal matching for `chs1[idx1]`\\n        if idx1 < len1\\n            && !chs1[idx1].is_digit(RADIX)\\n            && diff > 0\\n            && Self::dfs(idx1 + 1, idx2, diff - 1, chs1, chs2, memo)\\n        {\\n            memo[idx1][idx2][(diff + 1000) as usize] = Some(true);\\n            return true;\\n        }\\n        // literal matching for `chs2[idx2]`\\n        if idx2 < len2\\n            && !chs2[idx2].is_digit(RADIX)\\n            && diff < 0\\n            && Self::dfs(idx1, idx2 + 1, diff + 1, chs1, chs2, memo)\\n        {\\n            memo[idx1][idx2][(diff + 1000) as usize] = Some(true);\\n            return true;\\n        }\\n        // wild card matching on `chs1[idx1]`\\n        let mut num1: i16 = 0;\\n        for idx in idx1..len1 {\\n            if !chs1[idx].is_digit(RADIX) {\\n                break;\\n            }\\n            num1 = (num1 * 10) + (chs1[idx] as i16 - \\'0\\' as i16);\\n            if Self::dfs(idx + 1, idx2, diff - num1, chs1, chs2, memo) {\\n                memo[idx1][idx2][(diff + 1000) as usize] = Some(true);\\n                return true;\\n            }\\n        }\\n        // wild card matching for `chs2[idx2]`\\n        let mut num2: i16 = 0;\\n        for idx in idx2..len2 {\\n            if !chs2[idx].is_digit(RADIX) {\\n                break;\\n            }\\n            num2 = (num2 * 10) + (chs2[idx] as i16 - \\'0\\' as i16);\\n            if Self::dfs(idx1, idx + 1, diff + num2, chs1, chs2, memo) {\\n                memo[idx1][idx2][(diff + 1000) as usize] = Some(true);\\n                return true;\\n            }\\n        }\\n        memo[idx1][idx2][(diff + 1000) as usize] = Some(false);\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2109549,
                "title": "bfs-why-tle",
                "content": "Below is my solution for this question.\\nIt passes on each of the individual test cases, but somehow still fails on submission.\\nAnyone can explain what\\'s wrong with my code?\\n\\nAny help would be much appreciated!\\n```\\nfrom collections import deque\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        queue = deque([(s1,s2)])\\n        visited = set()\\n        \\n        def get_s_possible_next_values(s):\\n            next_values = []\\n            i = 0\\n            while i < len(s) and s[i].isdigit():\\n                curr_num_val = int(s[:i+1]) - 1\\n                str_val = str(curr_num_val) if curr_num_val else \\'\\' # handling 0\\n                \\n                next_values.append(str_val + s[i+1: ])\\n                i+=1\\n                \\n            return next_values\\n                \\n        def handle_strings(s1, s2):\\n            if s1[0].isalpha():\\n                s1_next_values = [s1[1:]]\\n            else:\\n                s1_next_values = get_s_possible_next_values(s1)\\n            \\n            if s2[0].isalpha():\\n                s2_next_values = [s2[1:]]\\n            else:\\n                s2_next_values = get_s_possible_next_values(s2)            \\n\\n            # now that we know the next values of each string\\n            # we can add each value combination into the queue to be checked\\n            for s1_val in s1_next_values:\\n                for s2_val in s2_next_values:\\n                    if (s1_val, s2_val) not in visited:\\n                        queue.append((s1_val, s2_val))\\n                        visited.add((s1_val, s2_val))           \\n        \\n        while queue:\\n            s1, s2 = queue.popleft()\\n            if s1 == s2 == \\'\\':                 \\n                return True\\n            if s1 and s2:\\n                if s1[0].isalpha() and s2[0].isalpha():\\n                    if s1[0] != s2[0]: return False\\n                    \\n                    if ((s1[1:], s2[1:]) not in visited):\\n                        queue.append((s1[1:], s2[1:]))\\n                    \\n                visited.add((s1, s2))\\n                handle_strings(s1, s2)\\n        \\n        return False\\n                \\n        \\n        \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        queue = deque([(s1,s2)])\\n        visited = set()\\n        \\n        def get_s_possible_next_values(s):\\n            next_values = []\\n            i = 0\\n            while i < len(s) and s[i].isdigit():\\n                curr_num_val = int(s[:i+1]) - 1\\n                str_val = str(curr_num_val) if curr_num_val else \\'\\' # handling 0\\n                \\n                next_values.append(str_val + s[i+1: ])\\n                i+=1\\n                \\n            return next_values\\n                \\n        def handle_strings(s1, s2):\\n            if s1[0].isalpha():\\n                s1_next_values = [s1[1:]]\\n            else:\\n                s1_next_values = get_s_possible_next_values(s1)\\n            \\n            if s2[0].isalpha():\\n                s2_next_values = [s2[1:]]\\n            else:\\n                s2_next_values = get_s_possible_next_values(s2)            \\n\\n            # now that we know the next values of each string\\n            # we can add each value combination into the queue to be checked\\n            for s1_val in s1_next_values:\\n                for s2_val in s2_next_values:\\n                    if (s1_val, s2_val) not in visited:\\n                        queue.append((s1_val, s2_val))\\n                        visited.add((s1_val, s2_val))           \\n        \\n        while queue:\\n            s1, s2 = queue.popleft()\\n            if s1 == s2 == \\'\\':                 \\n                return True\\n            if s1 and s2:\\n                if s1[0].isalpha() and s2[0].isalpha():\\n                    if s1[0] != s2[0]: return False\\n                    \\n                    if ((s1[1:], s2[1:]) not in visited):\\n                        queue.append((s1[1:], s2[1:]))\\n                    \\n                visited.add((s1, s2))\\n                handle_strings(s1, s2)\\n        \\n        return False\\n                \\n        \\n        \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890614,
                "title": "swift-dfs-dp",
                "content": "```\\nclass Solution {\\n    var s1 = [Character]()\\n    var s2 = [Character]()\\n    var dp = [[[Bool?]]]()\\n    var l1 = 0\\n    var l2 = 0\\n    var nums = Set([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"])\\n    \\n    func possiblyEquals(_ s1: String, _ s2: String) -> Bool {\\n        l1 = s1.count\\n        l2 = s2.count\\n        self.s1 = Array(s1)\\n        self.s2 = Array(s2)\\n\\t\\t\\n        // we use 2000 because it\\'s possible to have wildcard numbers up to 999 in both strings\\n        self.dp = Array(repeating:\\n                        Array(repeating: \\n                              Array(repeating:nil, count: 2000),\\n                              count: l2 + 1), \\n                        count: l1 + 1)\\n        \\n        return dfs(0, 0, 0)\\n    }\\n    \\n\\t// diff is about which string current index is going forward in our comparison\\n    func dfs( _ i: Int, _ j: Int, _ diff: Int) -> Bool {\\n        \\n        if (i == l1 && j == l2) {\\n            return diff == 0\\n        }\\n\\n        if (dp[i][j][diff + 1000] != nil) { return dp[i][j][diff + 1000]! }\\n        \\n        if i < l1\\n        && j < l2 \\n        && s1[i] == s2[j] \\n        && diff == 0 \\n        && dfs(i+1,j+1,diff) {\\n            dp[i][j][diff] = true\\n            return true\\n        }\\n        \\n        if i < l1 \\n        && !nums.contains(String(s1[i])) \\n        && diff > 0 \\n        && dfs(i+1,j,diff-1) {\\n            dp[i][j][diff + 1000] = true\\n            return true\\n        }\\n        \\n        if j < l2\\n        && !nums.contains(String(s2[j])) \\n        && diff < 0 \\n        && dfs(i,j+1,diff+1) {\\n            dp[i][j][diff + 1000] = true\\n            return true\\n        }\\n        \\n        var num = 0\\n        var index1 = i\\n        while index1 < l1 && nums.contains(String(s1[index1])) {\\n            num = num*10 + Int(String(s1[index1]))!\\n            if dfs(index1 + 1,j, diff - num) {\\n                dp[i][j][diff + 1000] = true\\n                return true\\n            }\\n            index1 += 1\\n        }\\n        \\n        num = 0\\n        var index2 = j\\n        \\n        while index2 < l2 && nums.contains(String(s2[index2]))   {\\n            num = num*10 + Int(String(s2[index2]))!\\n            if dfs(i,index2 + 1, diff + num) {\\n                dp[i][j][diff + 1000] = true\\n                return true\\n            }\\n            index2 += 1\\n        }\\n        \\n        dp[i][j][diff+1000] = false\\n        return false\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var s1 = [Character]()\\n    var s2 = [Character]()\\n    var dp = [[[Bool?]]]()\\n    var l1 = 0\\n    var l2 = 0\\n    var nums = Set([\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"])\\n    \\n    func possiblyEquals(_ s1: String, _ s2: String) -> Bool {\\n        l1 = s1.count\\n        l2 = s2.count\\n        self.s1 = Array(s1)\\n        self.s2 = Array(s2)\\n\\t\\t\\n        // we use 2000 because it\\'s possible to have wildcard numbers up to 999 in both strings\\n        self.dp = Array(repeating:\\n                        Array(repeating: \\n                              Array(repeating:nil, count: 2000),\\n                              count: l2 + 1), \\n                        count: l1 + 1)\\n        \\n        return dfs(0, 0, 0)\\n    }\\n    \\n\\t// diff is about which string current index is going forward in our comparison\\n    func dfs( _ i: Int, _ j: Int, _ diff: Int) -> Bool {\\n        \\n        if (i == l1 && j == l2) {\\n            return diff == 0\\n        }\\n\\n        if (dp[i][j][diff + 1000] != nil) { return dp[i][j][diff + 1000]! }\\n        \\n        if i < l1\\n        && j < l2 \\n        && s1[i] == s2[j] \\n        && diff == 0 \\n        && dfs(i+1,j+1,diff) {\\n            dp[i][j][diff] = true\\n            return true\\n        }\\n        \\n        if i < l1 \\n        && !nums.contains(String(s1[i])) \\n        && diff > 0 \\n        && dfs(i+1,j,diff-1) {\\n            dp[i][j][diff + 1000] = true\\n            return true\\n        }\\n        \\n        if j < l2\\n        && !nums.contains(String(s2[j])) \\n        && diff < 0 \\n        && dfs(i,j+1,diff+1) {\\n            dp[i][j][diff + 1000] = true\\n            return true\\n        }\\n        \\n        var num = 0\\n        var index1 = i\\n        while index1 < l1 && nums.contains(String(s1[index1])) {\\n            num = num*10 + Int(String(s1[index1]))!\\n            if dfs(index1 + 1,j, diff - num) {\\n                dp[i][j][diff + 1000] = true\\n                return true\\n            }\\n            index1 += 1\\n        }\\n        \\n        num = 0\\n        var index2 = j\\n        \\n        while index2 < l2 && nums.contains(String(s2[index2]))   {\\n            num = num*10 + Int(String(s2[index2]))!\\n            if dfs(i,index2 + 1, diff + num) {\\n                dp[i][j][diff + 1000] = true\\n                return true\\n            }\\n            index2 += 1\\n        }\\n        \\n        dp[i][j][diff+1000] = false\\n        return false\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837881,
                "title": "python-simple-solution-using-dfs-with-memo",
                "content": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        n1, n2 = len(s1), len(s2)\\n        \\n        @cache\\n        def backtrack(i1, i2, ln, num1, num2):\\n            if i1 >= n1 and i2 >= n2:\\n                return ln == 0           \\n            if (i1 >= n1 and ln <= 0) or (i2 >= n2 and ln >= 0):\\n                return False           \\n            if ln == 0 and i1 < n1 and i2 < n2 and \\'a\\' <= s1[i1] <=\\'z\\' and \\'a\\' <= s2[i2] <= \\'z\\':\\n                return s1[i1] == s2[i2] and backtrack(i1+1, i2+1, ln, 0, 0)           \\n            if ln < 0:\\n                if \\'0\\' <= s1[i1] <= \\'9\\':\\n                    d = int(s1[i1])\\n                    return backtrack(i1+1, i2, ln+d, d, num2) or backtrack(i1+1, i2, ln+num1*10+d-num1, num1*10+d, num2)\\n                else:\\n                    return backtrack(i1+1, i2, ln+1, 0, num2)                   \\n            else:\\n                if \\'0\\' <= s2[i2] <= \\'9\\':\\n                    d = int(s2[i2])\\n                    return backtrack(i1, i2+1, ln-d, num1, d) or backtrack(i1, i2+1, ln-(num2*10+d)+num2, num1, num2*10+d)              \\n                else:\\n                    return backtrack(i1, i2+1, ln-1, num1, 0)                   \\n        return backtrack(0, 0, 0, 0, 0)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        n1, n2 = len(s1), len(s2)\\n        \\n        @cache\\n        def backtrack(i1, i2, ln, num1, num2):\\n            if i1 >= n1 and i2 >= n2:\\n                return ln == 0           \\n            if (i1 >= n1 and ln <= 0) or (i2 >= n2 and ln >= 0):\\n                return False           \\n            if ln == 0 and i1 < n1 and i2 < n2 and \\'a\\' <= s1[i1] <=\\'z\\' and \\'a\\' <= s2[i2] <= \\'z\\':\\n                return s1[i1] == s2[i2] and backtrack(i1+1, i2+1, ln, 0, 0)           \\n            if ln < 0:\\n                if \\'0\\' <= s1[i1] <= \\'9\\':\\n                    d = int(s1[i1])\\n                    return backtrack(i1+1, i2, ln+d, d, num2) or backtrack(i1+1, i2, ln+num1*10+d-num1, num1*10+d, num2)\\n                else:\\n                    return backtrack(i1+1, i2, ln+1, 0, num2)                   \\n            else:\\n                if \\'0\\' <= s2[i2] <= \\'9\\':\\n                    d = int(s2[i2])\\n                    return backtrack(i1, i2+1, ln-d, num1, d) or backtrack(i1, i2+1, ln-(num2*10+d)+num2, num1, num2*10+d)              \\n                else:\\n                    return backtrack(i1, i2+1, ln-1, num1, 0)                   \\n        return backtrack(0, 0, 0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947997,
                "title": "clean-concise-code-with-elaborate-explanations",
                "content": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def parse_int(s: str, i: int) -> Iterator[tuple[int, int]]:\\n            \"\"\"\\n            Incrementally parses an integer starting from s[i].\\n\\n            Example:\\n            \"456\" is parsed as (4,1), (45,2), and (456,3)\\n\\n            :param s: string to parse\\n            :param i: index to start parsing from\\n            :return: the integer and its length (number of digits)\\n            \"\"\"\\n            n = 0\\n            j = i\\n            while j < len(s) and s[j].isdigit():\\n                n = n * 10 + int(s[j])\\n                j += 1\\n                yield n, j - i\\n\\n        @functools.cache\\n        def dfs(i: int, j: int, skip: int) -> bool:\\n            \"\"\"\\n            Checks if two encoded strings s1 and s2 are equal in length after decoding.\\n            The algorithm works similar to digit by digit addition. \\n            The parameter skip is analogous to the carry that indicates how many characters can be skipped from one of the strings.\\n            - If s1[i] or s2[j] is a digit, then we try with increasing lengths of integers, which is combined with skip to produce the new value.\\n            - If neither of s1[i] and s2[j] is a digit, and skip is not zero, then we skip the respective characters from s1 or s2.\\n            - If neither of s1[i] and s2[j] is a digit, and skip is zero, then s1[i] must be equal to s2[j] for the strings to be equal in length.\\n\\n            Example:\\n            s1=\"a3e\", s2=\"ab21\".\\n            Indices with asterisk indicate that it is _not_ incremented in the current iteration.\\n\\n            +----+----+-------+-------+----------------------------------+\\n            | i  | j  | s1[i] | s2[j] | skip (at the start of iteration) |\\n            +----+----+-------+-------+----------------------------------+\\n            | 0  | 0  | \\'a\\'   | \\'a\\'   |                                0 |\\n            | 1  | 1* |  3    | \\'b\\'   |                                0 |\\n            | 2* | 1  | \\'e\\'   | \\'b\\'   |                               -3 |\\n            | 2* | 2  | \\'e\\'   |  2    |                               -2 |\\n            | 2* | 3  | \\'e\\'   |  1    |                                0 |\\n            | 2  | 4* | \\'e\\'   |  ---  |                                1 |\\n            | 3  | 4  | ---   |  ---  |                                0 |\\n            +----+----+-------+-------+----------------------------------+\\n\\n            Note that how skip=-2 and s2[2]=2 are combined to produce skip=0 in the 5th iteration.\\n\\n            :param i: index into string s1\\n            :param j: index into string s2\\n            :param skip: number of characters to skip; if positive, skip from s1, if negative skip from s2\\n            :return: true if the decoded strings are equal in length, false otherwise\\n            \"\"\"\\n            if i == len(s1) and j == len(s2):\\n                return skip == 0\\n            if i < len(s1) and s1[i].isdigit():\\n                return any(dfs(i + k, j, skip - n) for n, k in parse_int(s1, i))\\n            elif j < len(s2) and s2[j].isdigit():\\n                return any(dfs(i, j + k, skip + n) for n, k in parse_int(s2, j))\\n            elif skip == 0 and i < len(s1) and j < len(s2):\\n                return s1[i] == s2[j] and dfs(i + 1, j + 1, skip)\\n            elif skip > 0 and i < len(s1):\\n                return dfs(i + 1, j, skip - 1)\\n            elif skip < 0 and j < len(s2):\\n                return dfs(i, j + 1, skip + 1)\\n            return False\\n            \\n        return dfs(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def parse_int(s: str, i: int) -> Iterator[tuple[int, int]]:\\n            \"\"\"\\n            Incrementally parses an integer starting from s[i].\\n\\n            Example:\\n            \"456\" is parsed as (4,1), (45,2), and (456,3)\\n\\n            :param s: string to parse\\n            :param i: index to start parsing from\\n            :return: the integer and its length (number of digits)\\n            \"\"\"\\n            n = 0\\n            j = i\\n            while j < len(s) and s[j].isdigit():\\n                n = n * 10 + int(s[j])\\n                j += 1\\n                yield n, j - i\\n\\n        @functools.cache\\n        def dfs(i: int, j: int, skip: int) -> bool:\\n            \"\"\"\\n            Checks if two encoded strings s1 and s2 are equal in length after decoding.\\n            The algorithm works similar to digit by digit addition. \\n            The parameter skip is analogous to the carry that indicates how many characters can be skipped from one of the strings.\\n            - If s1[i] or s2[j] is a digit, then we try with increasing lengths of integers, which is combined with skip to produce the new value.\\n            - If neither of s1[i] and s2[j] is a digit, and skip is not zero, then we skip the respective characters from s1 or s2.\\n            - If neither of s1[i] and s2[j] is a digit, and skip is zero, then s1[i] must be equal to s2[j] for the strings to be equal in length.\\n\\n            Example:\\n            s1=\"a3e\", s2=\"ab21\".\\n            Indices with asterisk indicate that it is _not_ incremented in the current iteration.\\n\\n            +----+----+-------+-------+----------------------------------+\\n            | i  | j  | s1[i] | s2[j] | skip (at the start of iteration) |\\n            +----+----+-------+-------+----------------------------------+\\n            | 0  | 0  | \\'a\\'   | \\'a\\'   |                                0 |\\n            | 1  | 1* |  3    | \\'b\\'   |                                0 |\\n            | 2* | 1  | \\'e\\'   | \\'b\\'   |                               -3 |\\n            | 2* | 2  | \\'e\\'   |  2    |                               -2 |\\n            | 2* | 3  | \\'e\\'   |  1    |                                0 |\\n            | 2  | 4* | \\'e\\'   |  ---  |                                1 |\\n            | 3  | 4  | ---   |  ---  |                                0 |\\n            +----+----+-------+-------+----------------------------------+\\n\\n            Note that how skip=-2 and s2[2]=2 are combined to produce skip=0 in the 5th iteration.\\n\\n            :param i: index into string s1\\n            :param j: index into string s2\\n            :param skip: number of characters to skip; if positive, skip from s1, if negative skip from s2\\n            :return: true if the decoded strings are equal in length, false otherwise\\n            \"\"\"\\n            if i == len(s1) and j == len(s2):\\n                return skip == 0\\n            if i < len(s1) and s1[i].isdigit():\\n                return any(dfs(i + k, j, skip - n) for n, k in parse_int(s1, i))\\n            elif j < len(s2) and s2[j].isdigit():\\n                return any(dfs(i, j + k, skip + n) for n, k in parse_int(s2, j))\\n            elif skip == 0 and i < len(s1) and j < len(s2):\\n                return s1[i] == s2[j] and dfs(i + 1, j + 1, skip)\\n            elif skip > 0 and i < len(s1):\\n                return dfs(i + 1, j, skip - 1)\\n            elif skip < 0 and j < len(s2):\\n                return dfs(i, j + 1, skip + 1)\\n            return False\\n            \\n        return dfs(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919705,
                "title": "python3-relative-easy-to-understand-backtracking-with-memorization",
                "content": "# Intuition\\n\\nCalculate diff\\n\\nAlgorithm:\\n\\n```\\ns1  s2  diff desc\\n2a  aba  0   initial state\\na   aba  2   read 2 from s1, remove 2 from s1, diff + 2\\na   ba   1   since diff 2 > 0, remove 1 char from s2, diff - 1\\na   a    0   since diff 1 > 0, remove 1 char from s2, diff - 1\\n\\'\\'  \\'\\'   0   since diff == 0 and s1[0] == s2[0], remove 1 char from each s, same diff\\n\\'\\'  \\'\\'   0   return True\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(N1*N2)$$ ?\\n\\n- Space complexity:\\n$$O(N1*N2)$$ ?\\n\\n# Code\\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n\\n        self.memo = {}\\n        return self.check(s1, s2, 0)\\n\\n    def check(self, s1: str, s2: str, diff: int) -> bool:\\n        if not s1 and not s2: return diff == 0\\n        \\n        # Make sure s1 is not empty\\n        if not s1: return self.check(s2, s1, -diff)\\n\\n        if (s1, s2, diff) in self.memo:\\n            return self.memo[(s1, s2, diff)]\\n\\n        result = False\\n        if diff == 0:\\n            if not s2:\\n                result = False\\n            else:\\n                if s1[0].isalpha():\\n                    if s2[0].isalpha():\\n                        result = (s1[0] == s2[0]) and self.check(s1[1:], s2[1:], diff)\\n                    else:\\n                        # To simplify code, always handle number in s1\\n                        result = self.check(s2, s1, -diff)\\n                else:\\n                    result = self.checkS1Nums(s1, s2, diff)\\n        elif diff > 0: # Expect chars in s2\\n            if not s2:\\n                result = False\\n            else:\\n                if s2[0].isalpha():\\n                    result = self.check(s1, s2[1:], diff - 1)\\n                else:\\n                    # To simplify code, always handle number in s1\\n                    result = self.check(s2, s1, -diff)\\n        else: # diff < 0, expect chars in s1\\n            if s1[0].isalpha():\\n                result = self.check(s1[1:], s2, diff + 1)\\n            else:\\n                result = self.checkS1Nums(s1, s2, diff)\\n        self.memo[(s1, s2, diff)] = result\\n        return result\\n\\n    def checkS1Nums(self, s1: str, s2: str, diff: int) -> bool:\\n        result = False\\n        for i, c in enumerate(s1):\\n            if c.isalpha():\\n                break\\n            num = int(s1[:i+1])\\n            result = result or self.check(s1[i+1:], s2, diff + num)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ns1  s2  diff desc\\n2a  aba  0   initial state\\na   aba  2   read 2 from s1, remove 2 from s1, diff + 2\\na   ba   1   since diff 2 > 0, remove 1 char from s2, diff - 1\\na   a    0   since diff 1 > 0, remove 1 char from s2, diff - 1\\n\\'\\'  \\'\\'   0   since diff == 0 and s1[0] == s2[0], remove 1 char from each s, same diff\\n\\'\\'  \\'\\'   0   return True\\n```\n```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n\\n        self.memo = {}\\n        return self.check(s1, s2, 0)\\n\\n    def check(self, s1: str, s2: str, diff: int) -> bool:\\n        if not s1 and not s2: return diff == 0\\n        \\n        # Make sure s1 is not empty\\n        if not s1: return self.check(s2, s1, -diff)\\n\\n        if (s1, s2, diff) in self.memo:\\n            return self.memo[(s1, s2, diff)]\\n\\n        result = False\\n        if diff == 0:\\n            if not s2:\\n                result = False\\n            else:\\n                if s1[0].isalpha():\\n                    if s2[0].isalpha():\\n                        result = (s1[0] == s2[0]) and self.check(s1[1:], s2[1:], diff)\\n                    else:\\n                        # To simplify code, always handle number in s1\\n                        result = self.check(s2, s1, -diff)\\n                else:\\n                    result = self.checkS1Nums(s1, s2, diff)\\n        elif diff > 0: # Expect chars in s2\\n            if not s2:\\n                result = False\\n            else:\\n                if s2[0].isalpha():\\n                    result = self.check(s1, s2[1:], diff - 1)\\n                else:\\n                    # To simplify code, always handle number in s1\\n                    result = self.check(s2, s1, -diff)\\n        else: # diff < 0, expect chars in s1\\n            if s1[0].isalpha():\\n                result = self.check(s1[1:], s2, diff + 1)\\n            else:\\n                result = self.checkS1Nums(s1, s2, diff)\\n        self.memo[(s1, s2, diff)] = result\\n        return result\\n\\n    def checkS1Nums(self, s1: str, s2: str, diff: int) -> bool:\\n        result = False\\n        for i, c in enumerate(s1):\\n            if c.isalpha():\\n                break\\n            num = int(s1[:i+1])\\n            result = result or self.check(s1[i+1:], s2, diff + num)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817304,
                "title": "just-classic-solution-with-diff-in-go",
                "content": "\\n\\n# Code\\n```\\nfunc possiblyEquals(s1 string, s2 string) bool {\\n    return checkPatterns(s1, s2, 0)\\n}\\n\\nvar cache map[string]bool = map[string]bool{}\\n\\nfunc checkPatterns(s1, s2 string, diff int) bool {\\n    if s1 == \"\" && s2 == \"\" {\\n        return diff == 0\\n    }\\n    if len(s1) > 0 && isDigit(s1[0]) {\\n        return processDigsFor1(s1, s2, diff)\\n    }\\n    if len(s2) > 0 && isDigit(s2[0]) {\\n        return processDigsFor2(s1, s2, diff)\\n    }\\n    if len(s1) > 0 && diff < 0 {\\n        return checkPatterns(s1[1:], s2, diff+1)\\n    }\\n    if len(s2) > 0 && diff > 0 {\\n        return checkPatterns(s1, s2[1:], diff-1)\\n    }\\n    if len(s1) > 0 && len(s2) > 0 && s1[0] == s2[0] {\\n        return checkPatterns(s1[1:], s2[1:], diff)\\n    }\\n    return false\\n}\\n\\nfunc processDigsFor1(s1, s2 string, diff int) bool {\\n    p := fmt.Sprintf(\"%s-%s-%d\", s1, s2, diff)\\n    if v, ok := cache[p]; ok {\\n        return v\\n    }\\n    for i := 0; i < len(s1) && isDigit(s1[i]); i++ {\\n        var ln int\\n        fmt.Sscanf(s1[:i+1], \"%d\", &ln)\\n        if checkPatterns(s1[i+1:], s2, diff+ln) {\\n            cache[p] = true\\n            return true\\n        }\\n    }\\n    cache[p] = false\\n    return false\\n}\\n\\nfunc processDigsFor2(s1, s2 string, diff int) bool {\\n    p := fmt.Sprintf(\"%s-%s-%d\", s1, s2, diff)\\n    if v, ok := cache[p]; ok {\\n        return v\\n    }\\n    for i := 0; i < len(s2) && isDigit(s2[i]); i++ {\\n        var ln int\\n        fmt.Sscanf(s2[:i+1], \"%d\", &ln)\\n        if checkPatterns(s1, s2[i+1:], diff-ln) {\\n            cache[p] = true\\n            return true\\n        }\\n    }\\n    cache[p] = false\\n    return false\\n}\\n\\nfunc isDigit(b byte) bool {\\n    return b >= \\'0\\' && b <= \\'9\\'\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc possiblyEquals(s1 string, s2 string) bool {\\n    return checkPatterns(s1, s2, 0)\\n}\\n\\nvar cache map[string]bool = map[string]bool{}\\n\\nfunc checkPatterns(s1, s2 string, diff int) bool {\\n    if s1 == \"\" && s2 == \"\" {\\n        return diff == 0\\n    }\\n    if len(s1) > 0 && isDigit(s1[0]) {\\n        return processDigsFor1(s1, s2, diff)\\n    }\\n    if len(s2) > 0 && isDigit(s2[0]) {\\n        return processDigsFor2(s1, s2, diff)\\n    }\\n    if len(s1) > 0 && diff < 0 {\\n        return checkPatterns(s1[1:], s2, diff+1)\\n    }\\n    if len(s2) > 0 && diff > 0 {\\n        return checkPatterns(s1, s2[1:], diff-1)\\n    }\\n    if len(s1) > 0 && len(s2) > 0 && s1[0] == s2[0] {\\n        return checkPatterns(s1[1:], s2[1:], diff)\\n    }\\n    return false\\n}\\n\\nfunc processDigsFor1(s1, s2 string, diff int) bool {\\n    p := fmt.Sprintf(\"%s-%s-%d\", s1, s2, diff)\\n    if v, ok := cache[p]; ok {\\n        return v\\n    }\\n    for i := 0; i < len(s1) && isDigit(s1[i]); i++ {\\n        var ln int\\n        fmt.Sscanf(s1[:i+1], \"%d\", &ln)\\n        if checkPatterns(s1[i+1:], s2, diff+ln) {\\n            cache[p] = true\\n            return true\\n        }\\n    }\\n    cache[p] = false\\n    return false\\n}\\n\\nfunc processDigsFor2(s1, s2 string, diff int) bool {\\n    p := fmt.Sprintf(\"%s-%s-%d\", s1, s2, diff)\\n    if v, ok := cache[p]; ok {\\n        return v\\n    }\\n    for i := 0; i < len(s2) && isDigit(s2[i]); i++ {\\n        var ln int\\n        fmt.Sscanf(s2[:i+1], \"%d\", &ln)\\n        if checkPatterns(s1, s2[i+1:], diff-ln) {\\n            cache[p] = true\\n            return true\\n        }\\n    }\\n    cache[p] = false\\n    return false\\n}\\n\\nfunc isDigit(b byte) bool {\\n    return b >= \\'0\\' && b <= \\'9\\'\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3656480,
                "title": "python-recursive-o-n-3-one-case-at-a-time",
                "content": "\\n```\\n\\nclass Solution:\\n    def possiblyEquals(self, s: str, t: str) -> bool:\\n        @cache\\n        def solve(i, j, gap):\\n            if i == len(s) and  j == len(t):\\n                return gap == 0\\n            if i > len(s) or j > len(t):\\n                return False\\n\\n            if i < len(s) and s[i].isdigit():\\n                n = 0\\n                while i < len(s) and s[i].isdigit():\\n                    n = n * 10 + int(s[i])\\n                    if solve(i + 1, j, gap + n):\\n                        return True\\n                    i += 1\\n            elif j < len(t) and t[j].isdigit():\\n                n = 0\\n                while j < len(t) and t[j].isdigit():\\n                    n = n * 10 + int(t[j])\\n                    if solve(i, j + 1, gap - n):\\n                        return True\\n                    j += 1\\n            elif gap > 0:\\n                return solve(i, j + 1, gap - 1)\\n            elif gap < 0:\\n                return solve(i + 1, j, gap + 1)\\n            elif i < len(s) and j < len(t):\\n                if s[i] == t[j]:\\n                    return solve(i + 1, j + 1, 0)\\n            return False\\n\\n        return solve(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def possiblyEquals(self, s: str, t: str) -> bool:\\n        @cache\\n        def solve(i, j, gap):\\n            if i == len(s) and  j == len(t):\\n                return gap == 0\\n            if i > len(s) or j > len(t):\\n                return False\\n\\n            if i < len(s) and s[i].isdigit():\\n                n = 0\\n                while i < len(s) and s[i].isdigit():\\n                    n = n * 10 + int(s[i])\\n                    if solve(i + 1, j, gap + n):\\n                        return True\\n                    i += 1\\n            elif j < len(t) and t[j].isdigit():\\n                n = 0\\n                while j < len(t) and t[j].isdigit():\\n                    n = n * 10 + int(t[j])\\n                    if solve(i, j + 1, gap - n):\\n                        return True\\n                    j += 1\\n            elif gap > 0:\\n                return solve(i, j + 1, gap - 1)\\n            elif gap < 0:\\n                return solve(i + 1, j, gap + 1)\\n            elif i < len(s) and j < len(t):\\n                if s[i] == t[j]:\\n                    return solve(i + 1, j + 1, 0)\\n            return False\\n\\n        return solve(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504945,
                "title": "recursion-with-memoization",
                "content": "# Intuition\\nI am failed. It is rewritten python3 solution to golang https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/solutions/1550012/python3-dp/?languageTags=python3\\n\\n# Approach\\nRecursion + memoization\\n\\nWe have 3 numbers (i,j,diff) where i is position in s1, j is position in s2 and diff is delta in solution string length (s2 gives +) \\n\\nWe recursivelly try to match s1 and s2 from begin to end with memoization\\n\\n# Complexity\\n\\nmax(abs(diff)) = 10^4 (10 times by a999)\\ni,j can be 1..40\\nso we have 40*40*2*10000 = 32*10^6 = 32M possible calls of our recursion function\\n\\n- Time complexity:\\nO(2^N), but with memoization it is less than 32M function calls\\n\\n- Space complexity:\\nO(2^N), but with memoization it is less than 32M records in cache\\n\\n# Code\\n```\\n\\nfunc isDigit(c byte) bool {\\n\\treturn c >= \\'0\\' && c <= \\'9\\'\\n}\\n\\nfunc possibleLens(s string) []int {\\n\\tret := []int{}\\n\\tif len(s) == 1 {\\n\\t\\tret = append(ret, int(s[0]-\\'0\\'))\\n\\t} else if len(s) == 2 {\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')+int(s[1]-\\'0\\'))\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')*10+int(s[1]-\\'0\\'))\\n\\t} else {\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')+int(s[1]-\\'0\\')+int(s[2]-\\'0\\'))\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')*10+int(s[1]-\\'0\\')+int(s[2]-\\'0\\'))\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')+int(s[1]-\\'0\\')*10+int(s[2]-\\'0\\'))\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')*100+int(s[1]-\\'0\\')*10+int(s[2]-\\'0\\'))\\n\\t}\\n\\treturn ret\\n}\\n\\nfunc possiblyEquals(s1 string, s2 string) bool {\\n\\tcache := map[[3]int]bool{}\\n\\tvar fn func(i, j, diff int) bool\\n\\tfn = func(i, j, diff int) bool {\\n\\t\\tkey := [3]int{i, j, diff}\\n\\t\\tret, ok := cache[key]\\n\\t\\tif ok {\\n\\t\\t\\treturn ret\\n\\t\\t}\\n\\t\\tif i == len(s1) && j == len(s2) {\\n\\t\\t\\tret = diff == 0\\n\\t\\t\\tcache[key] = ret\\n\\t\\t\\treturn ret\\n\\t\\t}\\n\\n\\t\\tif i < len(s1) && isDigit(s1[i]) {\\n\\t\\t\\tii := i\\n\\t\\t\\tfor ii < len(s1) && isDigit(s1[ii]) {\\n\\t\\t\\t\\tii++\\n\\t\\t\\t}\\n\\t\\t\\tfor _, x := range possibleLens(s1[i:ii]) {\\n\\t\\t\\t\\tif fn(ii, j, diff-x) {\\n\\t\\t\\t\\t\\tret = true\\n\\t\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\t\\treturn ret\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if j < len(s2) && isDigit(s2[j]) {\\n\\t\\t\\tjj := j\\n\\t\\t\\tfor jj < len(s2) && isDigit(s2[jj]) {\\n\\t\\t\\t\\tjj++\\n\\t\\t\\t}\\n\\t\\t\\tfor _, x := range possibleLens(s2[j:jj]) {\\n\\t\\t\\t\\tif fn(i, jj, diff+x) {\\n\\t\\t\\t\\t\\tret = true\\n\\t\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\t\\treturn ret\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if diff == 0 {\\n\\t\\t\\tif i < len(s1) && j < len(s2) && s1[i] == s2[j] {\\n\\t\\t\\t\\tret = fn(i+1, j+1, 0)\\n\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\treturn ret\\n\\t\\t\\t}\\n\\t\\t} else if diff > 0 {\\n\\t\\t\\tif i < len(s1) {\\n\\t\\t\\t\\tret = fn(i+1, j, diff-1)\\n\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\treturn ret\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif j < len(s2) {\\n\\t\\t\\t\\tret = fn(i, j+1, diff+1)\\n\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\treturn ret\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tret = false\\n\\t\\tcache[key] = ret\\n\\t\\treturn ret\\n\\t}\\n\\treturn fn(0, 0, 0)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc isDigit(c byte) bool {\\n\\treturn c >= \\'0\\' && c <= \\'9\\'\\n}\\n\\nfunc possibleLens(s string) []int {\\n\\tret := []int{}\\n\\tif len(s) == 1 {\\n\\t\\tret = append(ret, int(s[0]-\\'0\\'))\\n\\t} else if len(s) == 2 {\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')+int(s[1]-\\'0\\'))\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')*10+int(s[1]-\\'0\\'))\\n\\t} else {\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')+int(s[1]-\\'0\\')+int(s[2]-\\'0\\'))\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')*10+int(s[1]-\\'0\\')+int(s[2]-\\'0\\'))\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')+int(s[1]-\\'0\\')*10+int(s[2]-\\'0\\'))\\n\\t\\tret = append(ret, int(s[0]-\\'0\\')*100+int(s[1]-\\'0\\')*10+int(s[2]-\\'0\\'))\\n\\t}\\n\\treturn ret\\n}\\n\\nfunc possiblyEquals(s1 string, s2 string) bool {\\n\\tcache := map[[3]int]bool{}\\n\\tvar fn func(i, j, diff int) bool\\n\\tfn = func(i, j, diff int) bool {\\n\\t\\tkey := [3]int{i, j, diff}\\n\\t\\tret, ok := cache[key]\\n\\t\\tif ok {\\n\\t\\t\\treturn ret\\n\\t\\t}\\n\\t\\tif i == len(s1) && j == len(s2) {\\n\\t\\t\\tret = diff == 0\\n\\t\\t\\tcache[key] = ret\\n\\t\\t\\treturn ret\\n\\t\\t}\\n\\n\\t\\tif i < len(s1) && isDigit(s1[i]) {\\n\\t\\t\\tii := i\\n\\t\\t\\tfor ii < len(s1) && isDigit(s1[ii]) {\\n\\t\\t\\t\\tii++\\n\\t\\t\\t}\\n\\t\\t\\tfor _, x := range possibleLens(s1[i:ii]) {\\n\\t\\t\\t\\tif fn(ii, j, diff-x) {\\n\\t\\t\\t\\t\\tret = true\\n\\t\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\t\\treturn ret\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if j < len(s2) && isDigit(s2[j]) {\\n\\t\\t\\tjj := j\\n\\t\\t\\tfor jj < len(s2) && isDigit(s2[jj]) {\\n\\t\\t\\t\\tjj++\\n\\t\\t\\t}\\n\\t\\t\\tfor _, x := range possibleLens(s2[j:jj]) {\\n\\t\\t\\t\\tif fn(i, jj, diff+x) {\\n\\t\\t\\t\\t\\tret = true\\n\\t\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\t\\treturn ret\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if diff == 0 {\\n\\t\\t\\tif i < len(s1) && j < len(s2) && s1[i] == s2[j] {\\n\\t\\t\\t\\tret = fn(i+1, j+1, 0)\\n\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\treturn ret\\n\\t\\t\\t}\\n\\t\\t} else if diff > 0 {\\n\\t\\t\\tif i < len(s1) {\\n\\t\\t\\t\\tret = fn(i+1, j, diff-1)\\n\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\treturn ret\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif j < len(s2) {\\n\\t\\t\\t\\tret = fn(i, j+1, diff+1)\\n\\t\\t\\t\\tcache[key] = ret\\n\\t\\t\\t\\treturn ret\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tret = false\\n\\t\\tcache[key] = ret\\n\\t\\treturn ret\\n\\t}\\n\\treturn fn(0, 0, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464811,
                "title": "working-messy-but-intuitive-code-logic-solution",
                "content": "# Intuition\\nAbbretion is like `aaaaa <many choices of lens> aaaaa <choices of lens> aaaaa`, so whenever encoutner repaeted digits, those added multiple choices.\\n\\nSo bascially maintain two pointers for s1 and s2, and iterate them along the way, if encountered number, need to generate those choices, those choice represent how many chracters can be used as wildcards in each string.\\n\\nSo bascially the logic is based on if s1 got more wildcards than s2, if more, then just iterate s2 further, vice versa.\\n\\n# Approach\\nDFS + Memoization\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 * diff-choices (-999 ~ 999))\\n\\n- Space complexity:\\nO(n^2 * diff-choices (-999 ~ 999))\\n\\n# Code\\n```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean possiblyEquals(String s1, String s2) {\\n        return helper(s1, s2, 0, 0, 0);\\n    }\\n\\n    private boolean helper(String s1, String s2, int i1, int i2, int diff) {\\n        if(i1 == s1.length() && i2 == s2.length() && diff == 0) {\\n            return true;\\n        }\\n        if(diff == 0 && (i1 == s1.length() || i2 == s2.length())) {\\n            return false;\\n        }\\n        if(diff < 0 && i1 == s1.length()) {\\n            return false;\\n        }\\n        if(diff > 0 && i2 == s2.length()) {\\n            return false;\\n        }\\n\\n        String key = i1+\"-\"+i2+\"-\"+diff;\\n        if (mem.containsKey(key)) {\\n            return mem.get(key);\\n        }\\n\\n        if(diff == 0) { // no one got wildcards\\n            char c1 = s1.charAt(i1), c2 = s2.charAt(i2);\\n            if(Character.isDigit(c1) && Character.isDigit(c2)) {\\n                int k1 = getNumEndIdx(s1, i1);\\n                int k2 = getNumEndIdx(s2, i2);\\n                for(int len1 : generateLens(s1.substring(i1, k1))) {\\n                    for(int len2 : generateLens(s2.substring(i2, k2))) {\\n                        if(helper(s1, s2, k1, k2, len1-len2)) {\\n                            mem.put(key, true);\\n                            return true;\\n                        }\\n                    }\\n                }\\n            } else if(Character.isDigit(c1)) {\\n                int k = getNumEndIdx(s1, i1);\\n                for(int len : generateLens(s1.substring(i1, k))) {\\n                    if(helper(s1, s2, k, i2, len)) {\\n                        mem.put(key, true);\\n                        return true;\\n                    }\\n                }\\n            } else if(Character.isDigit(c2)) {\\n                int k = getNumEndIdx(s2, i2);\\n                for(int len : generateLens(s2.substring(i2, k))) {\\n                    if(helper(s1, s2, i1, k, -len)) {\\n                        mem.put(key, true);\\n                        return true;\\n                    }\\n                }\\n            } else if (c1 == c2){\\n                boolean ans = helper(s1, s2, i1+1, i2+1, 0);\\n                mem.put(key, ans);\\n                return ans;\\n            }\\n        } else if(diff < 0) { // s2 still got wildcard, try move s1\\n            if(Character.isDigit(s1.charAt(i1))) {\\n                int k = getNumEndIdx(s1, i1);\\n                for(int len : generateLens(s1.substring(i1, k))) {\\n                    if(helper(s1, s2, k, i2, diff + len)) {\\n                        mem.put(key, true);\\n                        return true;\\n                    }\\n                }\\n            } else {\\n                boolean ans = helper(s1, s2, i1+1, i2, diff+1);\\n                mem.put(key, ans);\\n                return ans;\\n            }\\n        } else { // s1 still got wildcard, try move s2\\n            if(Character.isDigit(s2.charAt(i2))) {\\n                int k = getNumEndIdx(s2, i2);\\n                for(int len : generateLens(s2.substring(i2, k))) {\\n                    if(helper(s1, s2, i1, k, diff - len)) {\\n                        mem.put(key, true);\\n                        return true;\\n                    }\\n                }\\n            } else {\\n                boolean ans = helper(s1, s2, i1, i2+1, diff-1);\\n                mem.put(key, ans);\\n                return ans;\\n            }\\n        }\\n\\n        mem.put(key, false);\\n        return false;\\n    }\\n\\n    private int getNumEndIdx(String str, int i) {\\n        for(int k=i; k<str.length(); k++) {\\n            if (Character.isLetter(str.charAt(k))) {\\n                return k;\\n            }\\n        }\\n        return str.length();\\n    }\\n\\n    private Set<Integer> generateLens(String numStr) {\\n        Set<Integer> res = new HashSet<>();\\n        res.add(Integer.parseInt(numStr));\\n        if(numStr.length() == 2) {\\n            res.add((numStr.charAt(0)-\\'0\\') + (numStr.charAt(1)- \\'0\\'));\\n        } else if(numStr.length() == 3) {\\n            res.add((numStr.charAt(0)-\\'0\\') + (numStr.charAt(1)- \\'0\\') + (numStr.charAt(2)- \\'0\\'));\\n            res.add((numStr.charAt(0)-\\'0\\') + (numStr.charAt(1)- \\'0\\')*10 + (numStr.charAt(2)- \\'0\\'));\\n            res.add((numStr.charAt(0)-\\'0\\')*10 + (numStr.charAt(1)- \\'0\\') + (numStr.charAt(2)- \\'0\\'));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean possiblyEquals(String s1, String s2) {\\n        return helper(s1, s2, 0, 0, 0);\\n    }\\n\\n    private boolean helper(String s1, String s2, int i1, int i2, int diff) {\\n        if(i1 == s1.length() && i2 == s2.length() && diff == 0) {\\n            return true;\\n        }\\n        if(diff == 0 && (i1 == s1.length() || i2 == s2.length())) {\\n            return false;\\n        }\\n        if(diff < 0 && i1 == s1.length()) {\\n            return false;\\n        }\\n        if(diff > 0 && i2 == s2.length()) {\\n            return false;\\n        }\\n\\n        String key = i1+\"-\"+i2+\"-\"+diff;\\n        if (mem.containsKey(key)) {\\n            return mem.get(key);\\n        }\\n\\n        if(diff == 0) { // no one got wildcards\\n            char c1 = s1.charAt(i1), c2 = s2.charAt(i2);\\n            if(Character.isDigit(c1) && Character.isDigit(c2)) {\\n                int k1 = getNumEndIdx(s1, i1);\\n                int k2 = getNumEndIdx(s2, i2);\\n                for(int len1 : generateLens(s1.substring(i1, k1))) {\\n                    for(int len2 : generateLens(s2.substring(i2, k2))) {\\n                        if(helper(s1, s2, k1, k2, len1-len2)) {\\n                            mem.put(key, true);\\n                            return true;\\n                        }\\n                    }\\n                }\\n            } else if(Character.isDigit(c1)) {\\n                int k = getNumEndIdx(s1, i1);\\n                for(int len : generateLens(s1.substring(i1, k))) {\\n                    if(helper(s1, s2, k, i2, len)) {\\n                        mem.put(key, true);\\n                        return true;\\n                    }\\n                }\\n            } else if(Character.isDigit(c2)) {\\n                int k = getNumEndIdx(s2, i2);\\n                for(int len : generateLens(s2.substring(i2, k))) {\\n                    if(helper(s1, s2, i1, k, -len)) {\\n                        mem.put(key, true);\\n                        return true;\\n                    }\\n                }\\n            } else if (c1 == c2){\\n                boolean ans = helper(s1, s2, i1+1, i2+1, 0);\\n                mem.put(key, ans);\\n                return ans;\\n            }\\n        } else if(diff < 0) { // s2 still got wildcard, try move s1\\n            if(Character.isDigit(s1.charAt(i1))) {\\n                int k = getNumEndIdx(s1, i1);\\n                for(int len : generateLens(s1.substring(i1, k))) {\\n                    if(helper(s1, s2, k, i2, diff + len)) {\\n                        mem.put(key, true);\\n                        return true;\\n                    }\\n                }\\n            } else {\\n                boolean ans = helper(s1, s2, i1+1, i2, diff+1);\\n                mem.put(key, ans);\\n                return ans;\\n            }\\n        } else { // s1 still got wildcard, try move s2\\n            if(Character.isDigit(s2.charAt(i2))) {\\n                int k = getNumEndIdx(s2, i2);\\n                for(int len : generateLens(s2.substring(i2, k))) {\\n                    if(helper(s1, s2, i1, k, diff - len)) {\\n                        mem.put(key, true);\\n                        return true;\\n                    }\\n                }\\n            } else {\\n                boolean ans = helper(s1, s2, i1, i2+1, diff-1);\\n                mem.put(key, ans);\\n                return ans;\\n            }\\n        }\\n\\n        mem.put(key, false);\\n        return false;\\n    }\\n\\n    private int getNumEndIdx(String str, int i) {\\n        for(int k=i; k<str.length(); k++) {\\n            if (Character.isLetter(str.charAt(k))) {\\n                return k;\\n            }\\n        }\\n        return str.length();\\n    }\\n\\n    private Set<Integer> generateLens(String numStr) {\\n        Set<Integer> res = new HashSet<>();\\n        res.add(Integer.parseInt(numStr));\\n        if(numStr.length() == 2) {\\n            res.add((numStr.charAt(0)-\\'0\\') + (numStr.charAt(1)- \\'0\\'));\\n        } else if(numStr.length() == 3) {\\n            res.add((numStr.charAt(0)-\\'0\\') + (numStr.charAt(1)- \\'0\\') + (numStr.charAt(2)- \\'0\\'));\\n            res.add((numStr.charAt(0)-\\'0\\') + (numStr.charAt(1)- \\'0\\')*10 + (numStr.charAt(2)- \\'0\\'));\\n            res.add((numStr.charAt(0)-\\'0\\')*10 + (numStr.charAt(1)- \\'0\\') + (numStr.charAt(2)- \\'0\\'));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423791,
                "title": "python-beats-100-solutions",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def values(self, s):\\n        if s in self.values_cache:\\n            return self.values_cache[s]\\n        if len(s)==1:\\n            self.values_cache[s] = [int(s),]\\n        elif len(s)==2:\\n            self.values_cache[s] = [int(s), int(s[0])+int(s[1])]\\n        elif len(s)==3:\\n            self.values_cache[s] = [int(s), int(s[0:2])+int(s[2]), int(s[0])+int(s[1:3]), int(s[0])+int(s[1])+int(s[2])]\\n        else:\\n            raise NotImplementedError\\n        return self.values_cache[s]\\n        \\n    def possiblyEqualsUtil(self, s1, s2, idx1, idx2, sum1, sum2):\\n        # print(s1[:idx1+1], sum1, s2[:idx2+1], sum2)\\n        if (idx1==-1 and sum1==0) and (idx2==-1 and sum2==0): # both s1 and s2 are exhausted means a match\\n            return True\\n        if (idx1==-1 and sum1==0) or (idx2==-1 and sum2==0): # either exhausted but other didn\\'t\\n            return False\\n        if (idx1, idx2, sum1, sum2) in self.dp:\\n            return self.dp[(idx1, idx2, sum1, sum2)] \\n        if sum1==0 and s1[idx1].isdigit(): # update sum1 when the idx1 is a digit and sum1 is 0\\n            next_idx1 = idx1\\n            while next_idx1>=0 and s1[next_idx1].isdigit():\\n                next_idx1 -= 1\\n            values1 = self.values(s1[next_idx1+1: idx1+1])\\n            answer = False\\n            for value1 in values1:\\n                answer = answer or self.possiblyEqualsUtil(s1, s2, next_idx1, idx2, value1, sum2)\\n            self.dp[(idx1, idx2, sum1, sum2)] = answer\\n        elif sum2==0 and s2[idx2].isdigit(): # update sum1 when the idx1 is a digit and sum1 is 0\\n            next_idx2 = idx2\\n            while next_idx2>=0 and s2[next_idx2].isdigit():\\n                next_idx2 -= 1\\n            values2 = self.values(s2[next_idx2+1: idx2+1])\\n            answer = False\\n            for value2 in values2:\\n                answer = answer or self.possiblyEqualsUtil(s1, s2, idx1, next_idx2, sum1, value2)\\n            self.dp[(idx1, idx2, sum1, sum2)] = answer\\n        else: # ready for comparisions\\n            if sum1 > 0 and sum2 > 0: # number-number compaision\\n                sum1, sum2 = sum1 - min(sum1, sum2), sum2 - min(sum1, sum2)\\n                self.dp[(idx1, idx2, sum1, sum2)] = self.possiblyEqualsUtil(s1, s2, idx1, idx2, sum1, sum2)\\n            elif sum1 > 0 and sum2 == 0 and s2[idx2].isalpha(): # number-alpha comparision\\n                self.dp[(idx1, idx2, sum1, sum2)] = self.possiblyEqualsUtil(s1, s2, idx1, idx2-1, sum1-1, sum2)\\n            elif sum2 > 0 and sum1 == 0 and s1[idx1].isalpha():  # number-alpha comparision\\n                self.dp[(idx1, idx2, sum1, sum2)] = self.possiblyEqualsUtil(s1, s2, idx1-1, idx2, sum1, sum2-1)\\n            elif s1[idx1].isalpha() and s2[idx2].isalpha(): # alpha-alpha comparision\\n                if s1[idx1]==s2[idx2]:\\n                    self.dp[(idx1, idx2, sum1, sum2)] = self.possiblyEqualsUtil(s1, s2, idx1-1, idx2-1, sum1, sum2)\\n                else:\\n                    self.dp[(idx1, idx2, sum1, sum2)] = False\\n            else:\\n                raise NotImplementedError\\n        return self.dp[(idx1, idx2, sum1, sum2)]\\n\\n    def possiblyEquals(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        self.values_cache = dict()\\n        self.dp = dict()\\n        return self.possiblyEqualsUtil(s1, s2, len(s1)-1, len(s2)-1, 0, 0)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def values(self, s):\\n        if s in self.values_cache:\\n            return self.values_cache[s]\\n        if len(s)==1:\\n            self.values_cache[s] = [int(s),]\\n        elif len(s)==2:\\n            self.values_cache[s] = [int(s), int(s[0])+int(s[1])]\\n        elif len(s)==3:\\n            self.values_cache[s] = [int(s), int(s[0:2])+int(s[2]), int(s[0])+int(s[1:3]), int(s[0])+int(s[1])+int(s[2])]\\n        else:\\n            raise NotImplementedError\\n        return self.values_cache[s]\\n        \\n    def possiblyEqualsUtil(self, s1, s2, idx1, idx2, sum1, sum2):\\n        # print(s1[:idx1+1], sum1, s2[:idx2+1], sum2)\\n        if (idx1==-1 and sum1==0) and (idx2==-1 and sum2==0): # both s1 and s2 are exhausted means a match\\n            return True\\n        if (idx1==-1 and sum1==0) or (idx2==-1 and sum2==0): # either exhausted but other didn\\'t\\n            return False\\n        if (idx1, idx2, sum1, sum2) in self.dp:\\n            return self.dp[(idx1, idx2, sum1, sum2)] \\n        if sum1==0 and s1[idx1].isdigit(): # update sum1 when the idx1 is a digit and sum1 is 0\\n            next_idx1 = idx1\\n            while next_idx1>=0 and s1[next_idx1].isdigit():\\n                next_idx1 -= 1\\n            values1 = self.values(s1[next_idx1+1: idx1+1])\\n            answer = False\\n            for value1 in values1:\\n                answer = answer or self.possiblyEqualsUtil(s1, s2, next_idx1, idx2, value1, sum2)\\n            self.dp[(idx1, idx2, sum1, sum2)] = answer\\n        elif sum2==0 and s2[idx2].isdigit(): # update sum1 when the idx1 is a digit and sum1 is 0\\n            next_idx2 = idx2\\n            while next_idx2>=0 and s2[next_idx2].isdigit():\\n                next_idx2 -= 1\\n            values2 = self.values(s2[next_idx2+1: idx2+1])\\n            answer = False\\n            for value2 in values2:\\n                answer = answer or self.possiblyEqualsUtil(s1, s2, idx1, next_idx2, sum1, value2)\\n            self.dp[(idx1, idx2, sum1, sum2)] = answer\\n        else: # ready for comparisions\\n            if sum1 > 0 and sum2 > 0: # number-number compaision\\n                sum1, sum2 = sum1 - min(sum1, sum2), sum2 - min(sum1, sum2)\\n                self.dp[(idx1, idx2, sum1, sum2)] = self.possiblyEqualsUtil(s1, s2, idx1, idx2, sum1, sum2)\\n            elif sum1 > 0 and sum2 == 0 and s2[idx2].isalpha(): # number-alpha comparision\\n                self.dp[(idx1, idx2, sum1, sum2)] = self.possiblyEqualsUtil(s1, s2, idx1, idx2-1, sum1-1, sum2)\\n            elif sum2 > 0 and sum1 == 0 and s1[idx1].isalpha():  # number-alpha comparision\\n                self.dp[(idx1, idx2, sum1, sum2)] = self.possiblyEqualsUtil(s1, s2, idx1-1, idx2, sum1, sum2-1)\\n            elif s1[idx1].isalpha() and s2[idx2].isalpha(): # alpha-alpha comparision\\n                if s1[idx1]==s2[idx2]:\\n                    self.dp[(idx1, idx2, sum1, sum2)] = self.possiblyEqualsUtil(s1, s2, idx1-1, idx2-1, sum1, sum2)\\n                else:\\n                    self.dp[(idx1, idx2, sum1, sum2)] = False\\n            else:\\n                raise NotImplementedError\\n        return self.dp[(idx1, idx2, sum1, sum2)]\\n\\n    def possiblyEquals(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        self.values_cache = dict()\\n        self.dp = dict()\\n        return self.possiblyEqualsUtil(s1, s2, len(s1)-1, len(s2)-1, 0, 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247427,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def possiblyEquals(self, s1, s2):\\n        n, m = len(s1), len(s2)\\n\\n        @lru_cache(None)\\n        def dfs(i,j,balance):\\n            if i == n and j == m:\\n                return balance == 0\\n\\n            if i < n and s1[i].isnumeric():\\n                k, val = i, 0\\n                while k < n and s1[k].isnumeric():\\n                    val = val*10 + int(s1[k])\\n                    k += 1\\n                    if dfs(k,j,balance-val):\\n                        return True\\n            elif j < m and s2[j].isnumeric():\\n                k, val = j, 0\\n                while k < m and s2[k].isnumeric():\\n                    val = val*10 + int(s2[k])\\n                    k += 1\\n                    if dfs(i,k,balance+val):\\n                        return True\\n            elif balance == 0:\\n                if i < n and j < m and s1[i] == s2[j]:\\n                    return dfs(i+1,j+1,balance)\\n            elif balance > 0:\\n                if i < n:\\n                    return dfs(i+1,j,balance-1)\\n            elif balance < 0:\\n                if j < m:\\n                    return dfs(i,j+1,balance+1)\\n\\n            return False\\n\\n        return dfs(0,0,0)\\n\\n\\n\\n\\n\\n            \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1, s2):\\n        n, m = len(s1), len(s2)\\n\\n        @lru_cache(None)\\n        def dfs(i,j,balance):\\n            if i == n and j == m:\\n                return balance == 0\\n\\n            if i < n and s1[i].isnumeric():\\n                k, val = i, 0\\n                while k < n and s1[k].isnumeric():\\n                    val = val*10 + int(s1[k])\\n                    k += 1\\n                    if dfs(k,j,balance-val):\\n                        return True\\n            elif j < m and s2[j].isnumeric():\\n                k, val = j, 0\\n                while k < m and s2[k].isnumeric():\\n                    val = val*10 + int(s2[k])\\n                    k += 1\\n                    if dfs(i,k,balance+val):\\n                        return True\\n            elif balance == 0:\\n                if i < n and j < m and s1[i] == s2[j]:\\n                    return dfs(i+1,j+1,balance)\\n            elif balance > 0:\\n                if i < n:\\n                    return dfs(i+1,j,balance-1)\\n            elif balance < 0:\\n                if j < m:\\n                    return dfs(i,j+1,balance+1)\\n\\n            return False\\n\\n        return dfs(0,0,0)\\n\\n\\n\\n\\n\\n            \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874805,
                "title": "javascript-dp-dfs",
                "content": "```\\nvar possiblyEquals = function(s1, s2) {        \\n    let memo = new Array( 41 ).fill(0).map( () => new Array( 41 ).fill(0).map( () => new Array( 2000 ).fill(0) ) );\\n    \\n    var possiblyEqualsUtil = function( i, j, diff ) {     \\n        const isdigit = (ch) => ch >= \\'0\\' && ch <= \\'9\\';\\n        \\n        const processDigits = ( s, idx, sign ) =>\\n        {\\n            for ( let val = 0; idx < s.length && isdigit(s[idx]); )\\n            {\\n                val = val * 10 + ( s[idx++] - \\'0\\' );\\n                sign < 0 ? i = idx : j = idx;\\n                \\n                if ( possiblyEqualsUtil( i, j, diff + val * sign ) ) return true;\\n            }\\n            return false;\\n        };\\n        \\n        if ( i == s1.length && j == s2.length ) return diff == 0;\\n        \\n        if ( !memo[i][j][diff + 1000] )\\n        {\\n            memo[i][j][diff + 1000] = true;\\n            \\n            if ( i < s1.length && isdigit(s1[i]) ) return processDigits( s1, i, -1 );\\n            if ( j < s2.length && isdigit(s2[j]) ) return processDigits( s2, j, 1 );\\n            \\n            if ( diff < 0 ) return j < s2.length && possiblyEqualsUtil( i, j + 1, diff + 1 );\\n            if ( diff > 0 ) return i < s1.length && possiblyEqualsUtil( i + 1, j, diff - 1 );\\n            \\n            return i < s1.length && j < s2.length && s1[i] == s2[j] && possiblyEqualsUtil( i + 1, j + 1, diff );\\n        }       \\n        return false;\\n    } \\n    return possiblyEqualsUtil( 0, 0, 0 );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar possiblyEquals = function(s1, s2) {        \\n    let memo = new Array( 41 ).fill(0).map( () => new Array( 41 ).fill(0).map( () => new Array( 2000 ).fill(0) ) );\\n    \\n    var possiblyEqualsUtil = function( i, j, diff ) {     \\n        const isdigit = (ch) => ch >= \\'0\\' && ch <= \\'9\\';\\n        \\n        const processDigits = ( s, idx, sign ) =>\\n        {\\n            for ( let val = 0; idx < s.length && isdigit(s[idx]); )\\n            {\\n                val = val * 10 + ( s[idx++] - \\'0\\' );\\n                sign < 0 ? i = idx : j = idx;\\n                \\n                if ( possiblyEqualsUtil( i, j, diff + val * sign ) ) return true;\\n            }\\n            return false;\\n        };\\n        \\n        if ( i == s1.length && j == s2.length ) return diff == 0;\\n        \\n        if ( !memo[i][j][diff + 1000] )\\n        {\\n            memo[i][j][diff + 1000] = true;\\n            \\n            if ( i < s1.length && isdigit(s1[i]) ) return processDigits( s1, i, -1 );\\n            if ( j < s2.length && isdigit(s2[j]) ) return processDigits( s2, j, 1 );\\n            \\n            if ( diff < 0 ) return j < s2.length && possiblyEqualsUtil( i, j + 1, diff + 1 );\\n            if ( diff > 0 ) return i < s1.length && possiblyEqualsUtil( i + 1, j, diff - 1 );\\n            \\n            return i < s1.length && j < s2.length && s1[i] == s2[j] && possiblyEqualsUtil( i + 1, j + 1, diff );\\n        }       \\n        return false;\\n    } \\n    return possiblyEqualsUtil( 0, 0, 0 );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757754,
                "title": "python-recursion-and-memorization",
                "content": "\\n```\\ndef helper(s1, s2, index1, index2, num1, num2, match_dict):\\n\\t\"\"\"Decide whether the remaining part of two patterns are equal or not given conditions:\\n\\ts1, s2: patterns\\n\\tindex1/2: location to read in s1/2, \\n\\tnum1/2: additional numbers of arbitary match that comes with pattern 1/2\\n\\tmatch_dict: dictionary that records previous pattern matching results\\n\\t\"\"\"\\n    if (index1, index2, num1, num2) in match_dict:\\n        return match_dict[(index1, index2, num1, num2)]\\n    elif num1 >= num2 > 0:\\n        return helper(s1, s2, index1, index2, num1-num2, 0, match_dict)\\n    elif num2 > num1 > 0:\\n        return helper(s1, s2, index1, index2, 0, num2-num1, match_dict)    \\n    elif num1 > 0:\\n        if index2 == len(s2):\\n            return False\\n        elif not s2[index2].isdigit():\\n            return helper(s1, s2, index1, index2+1, num1-1, 0, match_dict)\\n        else:  \\n            for i in range(index2, len(s2)):\\n                if s2[i].isdigit():\\n                    if helper(s1, s2, index1, i+1, num1, int(s2[index2:i+1]), match_dict):\\n                        match_dict[index1, index2, num1, num2] = True\\n                        return True\\n                else:\\n                    break\\n            match_dict[(index1, index2, num1, num2)] = False\\n            return False\\n    elif num2 > 0:\\n        return helper(s2, s1, index2, index1, num2, 0, match_dict)\\n    else:\\n        if index1 == len(s1) and index2 == len(s2):\\n            return True\\n        elif index1 == len(s1) or index2 == len(s2):\\n            return False\\n        elif not s1[index1].isdigit() and not s2[index2].isdigit():\\n            if s1[index1] == s2[index2]:\\n                match_dict[index1, index2, num1, num2] = helper(s1, s2, index1+1, index2+1, 0, 0, match_dict)\\n                return match_dict[index1, index2, num1, num2]\\n            else:\\n                return False\\n        elif s1[index1].isdigit():\\n            for i in range(index1, len(s1)):\\n                if s1[i].isdigit():\\n                    if helper(s1, s2, i+1, index2, int(s1[index1:i+1]), 0, match_dict):\\n                        match_dict[index1, index2, num1, num2] = True\\n                        return True\\n                else:\\n                    break\\n            match_dict[index1, index2, num1, num2] = False\\n            return False\\n        else:\\n            return helper(s2, s1, index2, index1, 0, 0, match_dict)            \\n\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        return helper(s1, s2, 0, 0, 0, 0, {})\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef helper(s1, s2, index1, index2, num1, num2, match_dict):\\n\\t\"\"\"Decide whether the remaining part of two patterns are equal or not given conditions:\\n\\ts1, s2: patterns\\n\\tindex1/2: location to read in s1/2, \\n\\tnum1/2: additional numbers of arbitary match that comes with pattern 1/2\\n\\tmatch_dict: dictionary that records previous pattern matching results\\n\\t\"\"\"\\n    if (index1, index2, num1, num2) in match_dict:\\n        return match_dict[(index1, index2, num1, num2)]\\n    elif num1 >= num2 > 0:\\n        return helper(s1, s2, index1, index2, num1-num2, 0, match_dict)\\n    elif num2 > num1 > 0:\\n        return helper(s1, s2, index1, index2, 0, num2-num1, match_dict)    \\n    elif num1 > 0:\\n        if index2 == len(s2):\\n            return False\\n        elif not s2[index2].isdigit():\\n            return helper(s1, s2, index1, index2+1, num1-1, 0, match_dict)\\n        else:  \\n            for i in range(index2, len(s2)):\\n                if s2[i].isdigit():\\n                    if helper(s1, s2, index1, i+1, num1, int(s2[index2:i+1]), match_dict):\\n                        match_dict[index1, index2, num1, num2] = True\\n                        return True\\n                else:\\n                    break\\n            match_dict[(index1, index2, num1, num2)] = False\\n            return False\\n    elif num2 > 0:\\n        return helper(s2, s1, index2, index1, num2, 0, match_dict)\\n    else:\\n        if index1 == len(s1) and index2 == len(s2):\\n            return True\\n        elif index1 == len(s1) or index2 == len(s2):\\n            return False\\n        elif not s1[index1].isdigit() and not s2[index2].isdigit():\\n            if s1[index1] == s2[index2]:\\n                match_dict[index1, index2, num1, num2] = helper(s1, s2, index1+1, index2+1, 0, 0, match_dict)\\n                return match_dict[index1, index2, num1, num2]\\n            else:\\n                return False\\n        elif s1[index1].isdigit():\\n            for i in range(index1, len(s1)):\\n                if s1[i].isdigit():\\n                    if helper(s1, s2, i+1, index2, int(s1[index1:i+1]), 0, match_dict):\\n                        match_dict[index1, index2, num1, num2] = True\\n                        return True\\n                else:\\n                    break\\n            match_dict[index1, index2, num1, num2] = False\\n            return False\\n        else:\\n            return helper(s2, s1, index2, index1, 0, 0, match_dict)            \\n\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        return helper(s1, s2, 0, 0, 0, 0, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692744,
                "title": "python-top-down-dp-parsing-and-compare-on-the-fly",
                "content": "The key idea is that we always keep s1 with left part before index i1 not mathed, marked as pre1, which store int or string.\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        if s1 == s2: return True\\n        @lru_cache(None)\\n        def issame(s1, s2, i1, i2, pre1):\\n            if i1 == len(s1) and i2 == len(s2): return not pre1\\n            if i2 == len(s2): return False\\n            if not pre1:\\n                p = \\'\\'\\n                while i1 < len(s1) and s1[i1].islower():\\n                    p += s1[i1]\\n                    i1 += 1\\n                if p: return issame(s1, s2, i1, i2, p)\\n                v = 0\\n                while i1 < len(s1) and s1[i1].isdigit():\\n                    v = v * 10 + int(s1[i1])\\n                    if issame(s1, s2, i1 + 1, i2, v): return True\\n                    i1 += 1\\n                return False\\n            p = \\'\\'\\n            while i2 < len(s2) and s2[i2].islower():\\n                p += s2[i2]\\n                i2 += 1\\n            if p:\\n                if type(pre1) == int:\\n                    if pre1 >= len(p): return issame(s1, s2, i1, i2, pre1 - len(p))\\n                    else: return issame(s2, s1, i2, i1, p[len(pre1):])\\n                else:\\n                    if len(pre1) >= len(p): return pre1.startswith(p) and issame(s1, s2, i1, i2, pre1[len(p):])\\n                    else: return p.startswith(pre1) and issame(s2, s1, i2, i1, p[len(pre1):])\\n            else:\\n                v = 0\\n                while i2 < len(s2) and s2[i2].isdigit():\\n                    v = v * 10 + int(s2[i2])\\n                    if type(pre1) == int:\\n                        if pre1 >= v and issame(s1, s2, i1, i2 + 1, pre1 - v) or pre1 < v and issame(s2, s1, i2 + 1, i1, v - pre1): return True\\n                    else:\\n                        if len(pre1) >= v and issame(s1, s2, i1, i2 + 1, pre1[v:]) or len(pre1) < v and issame(s2, s1, i2 + 1, i1, v - len(pre1)): return True\\n                    i2 += 1\\n            return False\\n        return issame(s1, s2, 0, 0, None)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        if s1 == s2: return True\\n        @lru_cache(None)\\n        def issame(s1, s2, i1, i2, pre1):\\n            if i1 == len(s1) and i2 == len(s2): return not pre1\\n            if i2 == len(s2): return False\\n            if not pre1:\\n                p = \\'\\'\\n                while i1 < len(s1) and s1[i1].islower():\\n                    p += s1[i1]\\n                    i1 += 1\\n                if p: return issame(s1, s2, i1, i2, p)\\n                v = 0\\n                while i1 < len(s1) and s1[i1].isdigit():\\n                    v = v * 10 + int(s1[i1])\\n                    if issame(s1, s2, i1 + 1, i2, v): return True\\n                    i1 += 1\\n                return False\\n            p = \\'\\'\\n            while i2 < len(s2) and s2[i2].islower():\\n                p += s2[i2]\\n                i2 += 1\\n            if p:\\n                if type(pre1) == int:\\n                    if pre1 >= len(p): return issame(s1, s2, i1, i2, pre1 - len(p))\\n                    else: return issame(s2, s1, i2, i1, p[len(pre1):])\\n                else:\\n                    if len(pre1) >= len(p): return pre1.startswith(p) and issame(s1, s2, i1, i2, pre1[len(p):])\\n                    else: return p.startswith(pre1) and issame(s2, s1, i2, i1, p[len(pre1):])\\n            else:\\n                v = 0\\n                while i2 < len(s2) and s2[i2].isdigit():\\n                    v = v * 10 + int(s2[i2])\\n                    if type(pre1) == int:\\n                        if pre1 >= v and issame(s1, s2, i1, i2 + 1, pre1 - v) or pre1 < v and issame(s2, s1, i2 + 1, i1, v - pre1): return True\\n                    else:\\n                        if len(pre1) >= v and issame(s1, s2, i1, i2 + 1, pre1[v:]) or len(pre1) < v and issame(s2, s1, i2 + 1, i1, v - len(pre1)): return True\\n                    i2 += 1\\n            return False\\n        return issame(s1, s2, 0, 0, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619426,
                "title": "python-solution-recursion-with-memoization-dp-the-code-easy-to-follow",
                "content": "Here is my Solution. I hope the code is easy to follow compared to other post. I originally tried to compute all of possible strings with wildcards; that approach worked but proof to be too slow. \\n\\nThis approach similar to others; using a `diff` to track the wildcards in `s1` and `s2`; wildcards in `s2` make `diff` go negative and vice verse for `s1`. \\n\\nIn my case, the solution purposely stops at `n` and `m` and checks the diff as the base case. \\n\\nThe solution is using `memo` to avoid recomputing all failed paths in the recursion tree that we previously attempted.\\n\\n```\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n    \\n        n = len(s1)\\n        m = len(s2)\\n        memo = {}\\n    \\n        def try_digits_s1(i, j, diff):\\n            \\n            k = 0\\n            while i + k < n and s1[i + k].isdigit():\\n                digit = int(s1[i:i + k + 1])\\n                if recurse(i + k + 1, j, diff + digit):\\n                    return True\\n                k += 1\\n            \\n            return False\\n        \\n        def try_digits_s2(i, j, diff):\\n            \\n            k = 0\\n            while j + k < m and s2[j + k].isdigit():\\n                digit = int(s2[j:j + k + 1])\\n                if recurse(i, j + k + 1, diff - digit):\\n                    return True\\n                k += 1\\n            \\n            return False\\n            \\n        def recurse(i, j, diff):\\n            \\n            if (i, j, diff) in memo:\\n                return memo[(i, j, diff)]\\n            \\n            memo[(i, j, diff)] = False\\n            \\n            if i == n and j == m:\\n                return diff == 0 \\n            \\n            if i > n or j > m:\\n                return False\\n            \\n            if i < n and s1[i].isdigit():\\n                return try_digits_s1(i, j, diff)\\n            \\n            if j < m and s2[j].isdigit():\\n                return try_digits_s2(i, j, diff)\\n            \\n            if diff < 0:\\n                return recurse(i + 1, j, diff + 1)\\n            \\n            if diff > 0:\\n                return recurse(i, j + 1, diff - 1)\\n            \\n            if i < n and j < m and s1[i] == s2[j]:\\n                return recurse(i + 1, j + 1, diff)\\n                \\n            return False\\n    \\n        return recurse(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n    \\n        n = len(s1)\\n        m = len(s2)\\n        memo = {}\\n    \\n        def try_digits_s1(i, j, diff):\\n            \\n            k = 0\\n            while i + k < n and s1[i + k].isdigit():\\n                digit = int(s1[i:i + k + 1])\\n                if recurse(i + k + 1, j, diff + digit):\\n                    return True\\n                k += 1\\n            \\n            return False\\n        \\n        def try_digits_s2(i, j, diff):\\n            \\n            k = 0\\n            while j + k < m and s2[j + k].isdigit():\\n                digit = int(s2[j:j + k + 1])\\n                if recurse(i, j + k + 1, diff - digit):\\n                    return True\\n                k += 1\\n            \\n            return False\\n            \\n        def recurse(i, j, diff):\\n            \\n            if (i, j, diff) in memo:\\n                return memo[(i, j, diff)]\\n            \\n            memo[(i, j, diff)] = False\\n            \\n            if i == n and j == m:\\n                return diff == 0 \\n            \\n            if i > n or j > m:\\n                return False\\n            \\n            if i < n and s1[i].isdigit():\\n                return try_digits_s1(i, j, diff)\\n            \\n            if j < m and s2[j].isdigit():\\n                return try_digits_s2(i, j, diff)\\n            \\n            if diff < 0:\\n                return recurse(i + 1, j, diff + 1)\\n            \\n            if diff > 0:\\n                return recurse(i, j + 1, diff - 1)\\n            \\n            if i < n and j < m and s1[i] == s2[j]:\\n                return recurse(i + 1, j + 1, diff)\\n                \\n            return False\\n    \\n        return recurse(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609842,
                "title": "python-my-solution",
                "content": "```\\nclass Solution:\\n    def possiblyEquals(self, a: str, b: str) -> bool:\\n        def get(i):\\n            if len(i)==1:return [int(i)]\\n            if len(i)==2:return [int(i[0])+int(i[1]),int(i)]\\n            if len(i)==3:return [int(i[0])+int(i[1])+int(i[2]),int(i),\\n                                int(i[0])+int(i[1:]),int(i[:2])+int(i[2])]\\n        def convert(a):\\n            r=[]\\n            i=0\\n            while i<len(a):\\n                z=\\'\\'\\n                while i<len(a) and a[i].isdigit():\\n                    z+=a[i]\\n                    i+=1\\n                if z!=\\'\\':\\n                    r.append(get(z))\\n                while i<len(a) and a[i].isalpha():\\n                    r.append(a[i])\\n                    i+=1\\n            return r\\n        a=convert(a)\\n        b=convert(b)\\n        @lru_cache(None)\\n        def f(i,j,s=0):\\n            if i==len(a) and j==len(b):\\n                return s==0\\n            if i==len(a):\\n                if type(b[j])==str:\\n                    return f(i,j+1,s-1)\\n                else:\\n                    for k in b[j]:\\n                        if f(i,j+1,s-k):return True\\n                return False\\n            if j==len(b):\\n                if type(a[i])==str:\\n                    return f(i+1,j,s+1)\\n                else:\\n                    for k in a[i]:\\n                        if f(i+1,j,s+k):return True\\n                return False\\n            if s==0:\\n                if type(a[i])==str and type(b[j])==str:\\n                    return (a[i]==b[j]) and f(i+1,j+1,s)    \\n                elif type(a[i])==str:\\n                    for k in b[j]:\\n                        if f(i,j+1,s-k):return True\\n                elif type(b[j])==str:\\n                    for k in a[i]:\\n                        if f(i+1,j,s+k):return True\\n                else:\\n                    for k in a[i]:\\n                        for l in b[j]:\\n                            if f(i+1,j+1,s+k-l):return True\\n            elif s<0:    \\n                if type(a[i])==str:\\n                    if f(i+1,j,s+1):return True\\n                else:\\n                    for k in a[i]:\\n                        if f(i+1,j,s+k):return True\\n            else:\\n                if type(b[j])==str:\\n                    if f(i,j+1,s-1)    :return True\\n                else:\\n                    for k in b[j]:\\n                        if f(i,j+1,s-k):return True\\n            return False\\n        return f(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, a: str, b: str) -> bool:\\n        def get(i):\\n            if len(i)==1:return [int(i)]\\n            if len(i)==2:return [int(i[0])+int(i[1]),int(i)]\\n            if len(i)==3:return [int(i[0])+int(i[1])+int(i[2]),int(i),\\n                                int(i[0])+int(i[1:]),int(i[:2])+int(i[2])]\\n        def convert(a):\\n            r=[]\\n            i=0\\n            while i<len(a):\\n                z=\\'\\'\\n                while i<len(a) and a[i].isdigit():\\n                    z+=a[i]\\n                    i+=1\\n                if z!=\\'\\':\\n                    r.append(get(z))\\n                while i<len(a) and a[i].isalpha():\\n                    r.append(a[i])\\n                    i+=1\\n            return r\\n        a=convert(a)\\n        b=convert(b)\\n        @lru_cache(None)\\n        def f(i,j,s=0):\\n            if i==len(a) and j==len(b):\\n                return s==0\\n            if i==len(a):\\n                if type(b[j])==str:\\n                    return f(i,j+1,s-1)\\n                else:\\n                    for k in b[j]:\\n                        if f(i,j+1,s-k):return True\\n                return False\\n            if j==len(b):\\n                if type(a[i])==str:\\n                    return f(i+1,j,s+1)\\n                else:\\n                    for k in a[i]:\\n                        if f(i+1,j,s+k):return True\\n                return False\\n            if s==0:\\n                if type(a[i])==str and type(b[j])==str:\\n                    return (a[i]==b[j]) and f(i+1,j+1,s)    \\n                elif type(a[i])==str:\\n                    for k in b[j]:\\n                        if f(i,j+1,s-k):return True\\n                elif type(b[j])==str:\\n                    for k in a[i]:\\n                        if f(i+1,j,s+k):return True\\n                else:\\n                    for k in a[i]:\\n                        for l in b[j]:\\n                            if f(i+1,j+1,s+k-l):return True\\n            elif s<0:    \\n                if type(a[i])==str:\\n                    if f(i+1,j,s+1):return True\\n                else:\\n                    for k in a[i]:\\n                        if f(i+1,j,s+k):return True\\n            else:\\n                if type(b[j])==str:\\n                    if f(i,j+1,s-1)    :return True\\n                else:\\n                    for k in b[j]:\\n                        if f(i,j+1,s-k):return True\\n            return False\\n        return f(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603007,
                "title": "python3-dfs-simplest-solution-and-code",
                "content": "Simplest solution I could find. Based off this [post](https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1881004/Python3-DFS-%2B-cache-or-clean-and-easy-to-understand).\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        n, m = len(s1), len(s2)\\n        \\n        @lru_cache(None)\\n        def dfs(i,j, diff):\\n            if i == n and j == m:\\n                return diff == 0\\n            if i < n and s1[i].isnumeric():\\n                k = i\\n                res = 0\\n                while k < n and s1[k].isnumeric():\\n                    res = res*10 + int(s1[k])\\n                    k += 1\\n                    if dfs(k, j, diff-res):\\n                        return True\\n            elif j < m and s2[j].isnumeric():\\n                k = j\\n                res = 0\\n                while k < m and s2[k].isnumeric():\\n                    res = res*10 + int(s2[k])\\n                    k += 1\\n                    if dfs(i, k, diff+res):\\n                        return True\\n            elif diff == 0:\\n                if i < n and j < m and s1[i] == s2[j]:\\n                    return dfs(i+1,j+1,diff)\\n            elif diff > 0:\\n                if i < n:\\n                    return dfs(i+1,j,diff-1)\\n            elif diff < 0:\\n                if j < m:\\n                    return dfs(i,j+1,diff+1)\\n            return False\\n                \\n        return dfs(0,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        n, m = len(s1), len(s2)\\n        \\n        @lru_cache(None)\\n        def dfs(i,j, diff):\\n            if i == n and j == m:\\n                return diff == 0\\n            if i < n and s1[i].isnumeric():\\n                k = i\\n                res = 0\\n                while k < n and s1[k].isnumeric():\\n                    res = res*10 + int(s1[k])\\n                    k += 1\\n                    if dfs(k, j, diff-res):\\n                        return True\\n            elif j < m and s2[j].isnumeric():\\n                k = j\\n                res = 0\\n                while k < m and s2[k].isnumeric():\\n                    res = res*10 + int(s2[k])\\n                    k += 1\\n                    if dfs(i, k, diff+res):\\n                        return True\\n            elif diff == 0:\\n                if i < n and j < m and s1[i] == s2[j]:\\n                    return dfs(i+1,j+1,diff)\\n            elif diff > 0:\\n                if i < n:\\n                    return dfs(i+1,j,diff-1)\\n            elif diff < 0:\\n                if j < m:\\n                    return dfs(i,j+1,diff+1)\\n            return False\\n                \\n        return dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523601,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  bool possiblyEquals(const string &s1, const string &s2) {\\n    constexpr int base = 10;\\n    constexpr char zero = \\'0\\';\\n    const int n1 = static_cast<int>(s1.size());\\n    const int n2 = static_cast<int>(s2.size());\\n    unordered_set<int> dp[n1 + 1][n2 + 1];\\n    dp[0][0].emplace(0);\\n    for (int length1 = 0; length1 < n1 + 1; ++length1) {\\n      for (int length2 = 0; length2 < n2 + 1; ++length2) {\\n        for (const int delta : dp[length1][length2]) {\\n          if (delta <= 0 && length1 < n1) {\\n            if (isdigit(s1[length1])) {\\n              int number = 0;\\n              for (int i1 = length1; i1 < n1 && isdigit(s1[i1]); ++i1) {\\n                number = base * number + (s1[i1] - zero);\\n                dp[i1 + 1][length2].emplace(delta + number);\\n              }\\n            } else {\\n              if (delta != 0) {\\n                dp[length1 + 1][length2].emplace(delta + 1);\\n              }\\n            }\\n          }\\n          if (delta >= 0 && length2 < n2) {\\n            if (isdigit(s2[length2])) {\\n              int number = 0;\\n              for (int i2 = length2; i2 < n2 && isdigit(s2[i2]); ++i2) {\\n                number = base * number + (s2[i2] - zero);\\n                dp[length1][i2 + 1].emplace(delta - number);\\n              }\\n            } else {\\n              if (delta != 0) {\\n                dp[length1][length2 + 1].emplace(delta - 1);\\n              }\\n            }\\n          }\\n          if (delta == 0 && length1 < n1 && length2 < n2 && s1[length1] == s2[length2]) {\\n            dp[length1 + 1][length2 + 1].emplace(delta);\\n          }\\n        }\\n      }\\n    }\\n    return dp[n1][n2].find(0) != dp[n1][n2].end();\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  bool possiblyEquals(const string &s1, const string &s2) {\\n    constexpr int base = 10;\\n    constexpr char zero = \\'0\\';\\n    const int n1 = static_cast<int>(s1.size());\\n    const int n2 = static_cast<int>(s2.size());\\n    unordered_set<int> dp[n1 + 1][n2 + 1];\\n    dp[0][0].emplace(0);\\n    for (int length1 = 0; length1 < n1 + 1; ++length1) {\\n      for (int length2 = 0; length2 < n2 + 1; ++length2) {\\n        for (const int delta : dp[length1][length2]) {\\n          if (delta <= 0 && length1 < n1) {\\n            if (isdigit(s1[length1])) {\\n              int number = 0;\\n              for (int i1 = length1; i1 < n1 && isdigit(s1[i1]); ++i1) {\\n                number = base * number + (s1[i1] - zero);\\n                dp[i1 + 1][length2].emplace(delta + number);\\n              }\\n            } else {\\n              if (delta != 0) {\\n                dp[length1 + 1][length2].emplace(delta + 1);\\n              }\\n            }\\n          }\\n          if (delta >= 0 && length2 < n2) {\\n            if (isdigit(s2[length2])) {\\n              int number = 0;\\n              for (int i2 = length2; i2 < n2 && isdigit(s2[i2]); ++i2) {\\n                number = base * number + (s2[i2] - zero);\\n                dp[length1][i2 + 1].emplace(delta - number);\\n              }\\n            } else {\\n              if (delta != 0) {\\n                dp[length1][length2 + 1].emplace(delta - 1);\\n              }\\n            }\\n          }\\n          if (delta == 0 && length1 < n1 && length2 < n2 && s1[length1] == s2[length2]) {\\n            dp[length1 + 1][length2 + 1].emplace(delta);\\n          }\\n        }\\n      }\\n    }\\n    return dp[n1][n2].find(0) != dp[n1][n2].end();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505576,
                "title": "c-dfs-with-memo-fast-execution",
                "content": "```\\npublic class Solution {\\n      string _s1;\\n        string _s2;\\n        int[][][] _memo;\\n        public bool PossiblyEquals(string s1, string s2)\\n        {\\n            // abc,3a\\n            // a3,3a\\n            _s1 = s1;\\n            _s2 = s2;\\n            _memo = new int[s1.Length+1][][]; //Need extra 1, as index can exceed by 1 in recursion and not reach stopping conditions\\n\\n            for(int ii=0;ii<s1.Length+1;ii++)\\n            {\\n                _memo[ii] = new int[s2.Length+1][];\\n                for (int jj = 0; jj < s2.Length+1; jj++)\\n                    _memo[ii][jj] = new int[2000]; //To store values -999 to 999\\n            }\\n\\n\\n            return Compare(0, 0, 0);\\n        }\\n\\n\\n        //s1 = l2e\\n        //s2 = 22\\n        private bool Compare(int i1, int i2, int diff) //diff cant be more than 1000, range is  -999 - 900 or 2000 entries\\n        {\\n            bool res = false;\\n            int count = 0;\\n            int tmp = 0;\\n            if (i1 >= _s1.Length && i2 >= _s2.Length && diff==0) return true;\\n            if (_memo[i1][i2][1000 + diff] != 0) return _memo[i1][i2][1000 + diff] == 1 ? true : false;\\n            if (i1 < _s1.Length)\\n            {\\n                if (isDigit(_s1[i1]))\\n                {\\n                    count = 0;\\n                    tmp = 0;\\n                    while (i1 + count < _s1.Length && isDigit(_s1[i1 + count]))\\n                    {\\n                        tmp = tmp * 10 + (_s1[i1 + count] - \\'0\\');//tmp = 1\\n                        count++;\\n                        res = Compare(i1 + count, i2, diff + tmp); \\n                        if (res) break; //We found a true condition no need to continue\\n                    }\\n                }\\n                else\\n                {\\n                    if(diff < 0) //i2 numbers are remaining\\n                        res = Compare(i1 + 1, i2, diff + 1); \\n                    else if(diff == 0 && i2 < _s2.Length) \\n                        if (_s1[i1] == _s2[i2])\\n                            res = Compare(i1 + 1, i2 + 1, diff);\\n                }\\n            }\\n\\n\\n            if (i2 < _s2.Length && !res)\\n            {\\n                if (isDigit(_s2[i2]))\\n                {\\n                    count = 0;\\n                    tmp = 0;\\n                    while (i2 + count < _s2.Length && isDigit(_s2[i2 + count]))\\n                    {\\n                        tmp = tmp * 10 + (_s2[i2 + count] - \\'0\\');\\n                        count++;\\n                        res = Compare(i1, i2+count, diff - tmp); \\n                        if (res) break; //We found a true condition no need to continue\\n                    }\\n                }\\n                else\\n                {\\n                    if (diff > 0) //Remaining items in i2\\n                        res =  Compare(i1, i2+1, diff - 1);\\n                }\\n            }\\n\\n            _memo[i1][i2][1000 + diff] = res == true ? 1 : -1; //1000+(-999) = 1, and 1000+ (999) = 1999\\n            return res;\\n        }\\n\\n        private bool isDigit(char c)\\n        {\\n            return ((c - \\'0\\') >= 0 && (c - \\'0\\') <= 9);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n      string _s1;\\n        string _s2;\\n        int[][][] _memo;\\n        public bool PossiblyEquals(string s1, string s2)\\n        {\\n            // abc,3a\\n            // a3,3a\\n            _s1 = s1;\\n            _s2 = s2;\\n            _memo = new int[s1.Length+1][][]; //Need extra 1, as index can exceed by 1 in recursion and not reach stopping conditions\\n\\n            for(int ii=0;ii<s1.Length+1;ii++)\\n            {\\n                _memo[ii] = new int[s2.Length+1][];\\n                for (int jj = 0; jj < s2.Length+1; jj++)\\n                    _memo[ii][jj] = new int[2000]; //To store values -999 to 999\\n            }\\n\\n\\n            return Compare(0, 0, 0);\\n        }\\n\\n\\n        //s1 = l2e\\n        //s2 = 22\\n        private bool Compare(int i1, int i2, int diff) //diff cant be more than 1000, range is  -999 - 900 or 2000 entries\\n        {\\n            bool res = false;\\n            int count = 0;\\n            int tmp = 0;\\n            if (i1 >= _s1.Length && i2 >= _s2.Length && diff==0) return true;\\n            if (_memo[i1][i2][1000 + diff] != 0) return _memo[i1][i2][1000 + diff] == 1 ? true : false;\\n            if (i1 < _s1.Length)\\n            {\\n                if (isDigit(_s1[i1]))\\n                {\\n                    count = 0;\\n                    tmp = 0;\\n                    while (i1 + count < _s1.Length && isDigit(_s1[i1 + count]))\\n                    {\\n                        tmp = tmp * 10 + (_s1[i1 + count] - \\'0\\');//tmp = 1\\n                        count++;\\n                        res = Compare(i1 + count, i2, diff + tmp); \\n                        if (res) break; //We found a true condition no need to continue\\n                    }\\n                }\\n                else\\n                {\\n                    if(diff < 0) //i2 numbers are remaining\\n                        res = Compare(i1 + 1, i2, diff + 1); \\n                    else if(diff == 0 && i2 < _s2.Length) \\n                        if (_s1[i1] == _s2[i2])\\n                            res = Compare(i1 + 1, i2 + 1, diff);\\n                }\\n            }\\n\\n\\n            if (i2 < _s2.Length && !res)\\n            {\\n                if (isDigit(_s2[i2]))\\n                {\\n                    count = 0;\\n                    tmp = 0;\\n                    while (i2 + count < _s2.Length && isDigit(_s2[i2 + count]))\\n                    {\\n                        tmp = tmp * 10 + (_s2[i2 + count] - \\'0\\');\\n                        count++;\\n                        res = Compare(i1, i2+count, diff - tmp); \\n                        if (res) break; //We found a true condition no need to continue\\n                    }\\n                }\\n                else\\n                {\\n                    if (diff > 0) //Remaining items in i2\\n                        res =  Compare(i1, i2+1, diff - 1);\\n                }\\n            }\\n\\n            _memo[i1][i2][1000 + diff] = res == true ? 1 : -1; //1000+(-999) = 1, and 1000+ (999) = 1999\\n            return res;\\n        }\\n\\n        private bool isDigit(char c)\\n        {\\n            return ((c - \\'0\\') >= 0 && (c - \\'0\\') <= 9);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342080,
                "title": "python-naive-recursive-approach",
                "content": "the intuitve approach is to first parse the arr into alphas and strings of numbers.\\nThe numbers indicate the wild characters count which can be used to match any alpha chara.\\n(1) first need to iterate all the possibilities;\\n(2) offset min number of wild charas;\\n(3) match with wild chara;\\n(4) used up wild charas, then to check the corresponding alphas;\\n(5) two strings need finish and use up all wild charas, in order to be equal.\\n\\n```\\ndef possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def getparse(s):\\n            res=[]\\n            i=0\\n            while i<len(s):\\n                c=s[i]\\n                if c.isdigit():\\n                    if not res or res[-1].isalpha():\\n                        res.append(c)\\n                    else:\\n                        res[-1]+=c\\n                else:\\n                    res.append(c)\\n                i+=1\\n            return res\\n        s1=getparse(s1)\\n        s2=getparse(s2)\\n        m,n=len(s1),len(s2)\\n        visited=set()\\n        def getnums(digits):\\n            digits=[int(a) for a in digits]\\n            d=len(digits)\\n            # if d==0:\\n            #     return {0}\\n            if d==1:\\n                return {digits[0]}\\n            elif d==2:\\n                return set([sum(digits), 10*digits[0]+digits[1]])\\n            elif d==3:\\n                a,b,c=digits\\n                res=set([sum(digits), a*10+b+c, a+10*b+c,100*a+10*b+c])\\n                return res\\n        \\n        \\n        def dfs(i,num1,j,num2):\\n            ##exit conditions\\n            if i==m and j==n:\\n                return num1==num2\\n            if i==m and num1==0:\\n                return False\\n            if j==n and num2==0:\\n                return False\\n            val=str(i)+\\',\\'+str(num1)+\\',\\'+str(j)+\\',\\'+str(num2)\\n            if val in visited:\\n                return False\\n            ## removing the head digits\\n            if i<m and s1[i].isdigit():\\n                nums1=getnums(s1[i])\\n                for x in nums1:\\n                    if dfs(i+1,x+num1,j,num2):\\n                        return True\\n                visited.add(val)    \\n                return False\\n                    \\n            elif j<n and s2[j].isdigit():\\n                nums2=getnums(s2[j])\\n                for y in nums2:\\n                    if dfs(i,num1,j+1,y+num2):\\n                        return True\\n                visited.add(val)\\n                return False\\n                    \\n            ## process the numbers first\\n            if num1>0 and num2>0:\\n                mn=min(num1,num2)\\n                return dfs(i,num1-mn,j,num2-mn)\\n            ## check cases with alpha and one num>0\\n            elif num1>0 and num2==0:\\n                    return dfs(i,num1-1,j+1,num2)\\n            elif num1==0 and num2>0:\\n                return dfs(i+1,num1,j,num2-1)\\n            else:\\n                if s1[i]!=s2[j]:\\n                    visited.add(val)\\n                    return False\\n                return dfs(i+1,0,j+1,0)\\n            \\n        return dfs(0,0,0,0)\\n",
                "solutionTags": [],
                "code": "the intuitve approach is to first parse the arr into alphas and strings of numbers.\\nThe numbers indicate the wild characters count which can be used to match any alpha chara.\\n(1) first need to iterate all the possibilities;\\n(2) offset min number of wild charas;\\n(3) match with wild chara;\\n(4) used up wild charas, then to check the corresponding alphas;\\n(5) two strings need finish and use up all wild charas, in order to be equal.\\n\\n```\\ndef possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def getparse(s):\\n            res=[]\\n            i=0\\n            while i<len(s):\\n                c=s[i]\\n                if c.isdigit():\\n                    if not res or res[-1].isalpha():\\n                        res.append(c)\\n                    else:\\n                        res[-1]+=c\\n                else:\\n                    res.append(c)\\n                i+=1\\n            return res\\n        s1=getparse(s1)\\n        s2=getparse(s2)\\n        m,n=len(s1),len(s2)\\n        visited=set()\\n        def getnums(digits):\\n            digits=[int(a) for a in digits]\\n            d=len(digits)\\n            # if d==0:\\n            #     return {0}\\n            if d==1:\\n                return {digits[0]}\\n            elif d==2:\\n                return set([sum(digits), 10*digits[0]+digits[1]])\\n            elif d==3:\\n                a,b,c=digits\\n                res=set([sum(digits), a*10+b+c, a+10*b+c,100*a+10*b+c])\\n                return res\\n        \\n        \\n        def dfs(i,num1,j,num2):\\n            ##exit conditions\\n            if i==m and j==n:\\n                return num1==num2\\n            if i==m and num1==0:\\n                return False\\n            if j==n and num2==0:\\n                return False\\n            val=str(i)+\\',\\'+str(num1)+\\',\\'+str(j)+\\',\\'+str(num2)\\n            if val in visited:\\n                return False\\n            ## removing the head digits\\n            if i<m and s1[i].isdigit():\\n                nums1=getnums(s1[i])\\n                for x in nums1:\\n                    if dfs(i+1,x+num1,j,num2):\\n                        return True\\n                visited.add(val)    \\n                return False\\n                    \\n            elif j<n and s2[j].isdigit():\\n                nums2=getnums(s2[j])\\n                for y in nums2:\\n                    if dfs(i,num1,j+1,y+num2):\\n                        return True\\n                visited.add(val)\\n                return False\\n                    \\n            ## process the numbers first\\n            if num1>0 and num2>0:\\n                mn=min(num1,num2)\\n                return dfs(i,num1-mn,j,num2-mn)\\n            ## check cases with alpha and one num>0\\n            elif num1>0 and num2==0:\\n                    return dfs(i,num1-1,j+1,num2)\\n            elif num1==0 and num2>0:\\n                return dfs(i+1,num1,j,num2-1)\\n            else:\\n                if s1[i]!=s2[j]:\\n                    visited.add(val)\\n                    return False\\n                return dfs(i+1,0,j+1,0)\\n            \\n        return dfs(0,0,0,0)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2340215,
                "title": "java-so-many-cases-some-explanations",
                "content": "this problem, oh my, there are so many cases to check ...\\n\\nI actually list them out one by one, note that most of them can be merged to make prettier but this is what I have for now.\\n\\nI think the annoying part is that we can\\'t just skip numbers ahead because we may skip the numbers in another string!\\nso this means that we have to basically keep a balance and do kind of like 2 pointer thing, but even then, it still took me a good few WAs to get all the cases down (AC)\\n\\n#### Edge Case\\nOne edge case that took me forever to debug is \\n```\\n\"98u8v8v8v89u888u998v88u98v88u9v99u989v8u\"\\n\"9v898u98v888v89v998u98v9v888u9v899v998u9\"\\n```\\nThis last test case is not helpful at all ... but the bug is that when the pointers for both strings are English letter, we can only advance them by 1 when the balance is 0. Why? Consider a simpler case:\\n```\\nca \\n1c\\n```\\nThe second string will store 1 as its balance, and then it will move forward to `c`, if we just compare `c == c`, then move forward, it will return true, but it can\\'t possibly be true! We can **not** use the 1 for `a`. It is not legal.\\n\\n#### Java\\n```Java\\nclass Solution {\\n    int m, n;\\n    int M = 1000;\\n    public boolean possiblyEquals(String s1, String s2) {\\n        m = s1.length();\\n        n = s2.length();\\n        return solve(0, 0, M, s1, s2, new boolean[s1.length()+1][s2.length()+1][2*M]);\\n    }\\n\\n    private boolean solve(int i, int j, int bal, String A, String B, boolean[][][] seen){\\n        if (i == A.length() && j == B.length()){\\n            return bal == M;\\n        }\\n        if (i == A.length() && !isD(B.charAt(j)) && bal <= M){\\n            return false;\\n        }\\n        if (j == B.length() && !isD(A.charAt(i)) && bal >= M){\\n            return false;\\n        }\\n        if (i < m && j < n && !isD(A.charAt(i)) && !isD(B.charAt(j)) && A.charAt(i) != B.charAt(j) && bal == M){\\n            return false;\\n        }\\n        if (seen[i][j][bal]){\\n            return false;\\n        }\\n        seen[i][j][bal]=true;\\n        if (i == m && j < n && !isD(B.charAt(j)) && bal > M && solve(i, j+1, bal-1, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && j == n && !isD(A.charAt(i)) && bal < M && solve(i+1, j, bal+1, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && j < n && A.charAt(i) == B.charAt(j) && bal == M && solve(i+1, j+1, bal, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && j < n && !isD(A.charAt(i)) && !isD(B.charAt(j)) && bal > M && solve(i, j+1, bal-1, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && j < n && !isD(A.charAt(i)) && !isD(B.charAt(j)) && bal < M && solve(i+1, j, bal+1, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && isD(A.charAt(i))){\\n            int k = i;\\n            while(k < m && isD(A.charAt(k))){\\n                k++;\\n            }\\n            for (int b : gen(A.substring(i, k))){\\n                if (solve(i+len(b),j,bal+b,A,B,seen)){\\n                    return true;\\n                }\\n            }\\n        }\\n        if (j < n && isD(B.charAt(j))){\\n            int k = j;\\n            while(k < n && isD(B.charAt(k))){\\n                k++;\\n            }\\n            for (int b : gen(B.substring(j, k))){\\n                if (solve(i,j+len(b),bal-b,A,B,seen)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private List<Integer> gen(String s){\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 1; i <= s.length(); i++){\\n            ans.add(Integer.parseInt(s.substring(0, i)));\\n        }\\n        return ans;\\n    }\\n\\n    private int len(int n){\\n        if (n < 10){\\n            return 1;\\n        }else if (n < 100){\\n            return 2;\\n        }else{\\n            return 3;\\n        }\\n    }\\n\\n    private boolean isD(char ch){\\n        return Character.isDigit(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\"98u8v8v8v89u888u998v88u98v88u9v99u989v8u\"\\n\"9v898u98v888v89v998u98v9v888u9v899v998u9\"\\n```\n```\\nca \\n1c\\n```\n```Java\\nclass Solution {\\n    int m, n;\\n    int M = 1000;\\n    public boolean possiblyEquals(String s1, String s2) {\\n        m = s1.length();\\n        n = s2.length();\\n        return solve(0, 0, M, s1, s2, new boolean[s1.length()+1][s2.length()+1][2*M]);\\n    }\\n\\n    private boolean solve(int i, int j, int bal, String A, String B, boolean[][][] seen){\\n        if (i == A.length() && j == B.length()){\\n            return bal == M;\\n        }\\n        if (i == A.length() && !isD(B.charAt(j)) && bal <= M){\\n            return false;\\n        }\\n        if (j == B.length() && !isD(A.charAt(i)) && bal >= M){\\n            return false;\\n        }\\n        if (i < m && j < n && !isD(A.charAt(i)) && !isD(B.charAt(j)) && A.charAt(i) != B.charAt(j) && bal == M){\\n            return false;\\n        }\\n        if (seen[i][j][bal]){\\n            return false;\\n        }\\n        seen[i][j][bal]=true;\\n        if (i == m && j < n && !isD(B.charAt(j)) && bal > M && solve(i, j+1, bal-1, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && j == n && !isD(A.charAt(i)) && bal < M && solve(i+1, j, bal+1, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && j < n && A.charAt(i) == B.charAt(j) && bal == M && solve(i+1, j+1, bal, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && j < n && !isD(A.charAt(i)) && !isD(B.charAt(j)) && bal > M && solve(i, j+1, bal-1, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && j < n && !isD(A.charAt(i)) && !isD(B.charAt(j)) && bal < M && solve(i+1, j, bal+1, A, B, seen)){\\n            return true;\\n        }\\n        if (i < m && isD(A.charAt(i))){\\n            int k = i;\\n            while(k < m && isD(A.charAt(k))){\\n                k++;\\n            }\\n            for (int b : gen(A.substring(i, k))){\\n                if (solve(i+len(b),j,bal+b,A,B,seen)){\\n                    return true;\\n                }\\n            }\\n        }\\n        if (j < n && isD(B.charAt(j))){\\n            int k = j;\\n            while(k < n && isD(B.charAt(k))){\\n                k++;\\n            }\\n            for (int b : gen(B.substring(j, k))){\\n                if (solve(i,j+len(b),bal-b,A,B,seen)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private List<Integer> gen(String s){\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 1; i <= s.length(); i++){\\n            ans.add(Integer.parseInt(s.substring(0, i)));\\n        }\\n        return ans;\\n    }\\n\\n    private int len(int n){\\n        if (n < 10){\\n            return 1;\\n        }else if (n < 100){\\n            return 2;\\n        }else{\\n            return 3;\\n        }\\n    }\\n\\n    private boolean isD(char ch){\\n        return Character.isDigit(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330779,
                "title": "dp-memoization",
                "content": "Idea: use `(x, s)` to represent a string `s` with a prefix of `x` (any) chars\\n\\n```py\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def helper(s):\\n            res = []\\n            if s:\\n                if s[0].isalpha():\\n                    res.append((1, s[1:]))\\n                else:\\n                    for i in range(3):\\n                        if i < len(s) and s[i].isdigit():\\n                            res.append((int(s[:i + 1]), s[i + 1:]))\\n                        else:\\n                            break\\n            return res\\n        \\n        @cache\\n        def dp(x, s, y, t):\\n            if x * y > 0:\\n                return dp(x - min(x, y), s, y - min(x, y), t)\\n            if x + y == 0:\\n                if not s and not t:\\n                    return True\\n                if not s or not t:\\n                    return False\\n                if s[0].isalpha() and t[0].isalpha():\\n                    return s[0] == t[0] and dp(0, s[1:], 0, t[1:])\\n            if x == 0:\\n                for xx, ss in helper(s):\\n                    if dp(xx, ss, y, t):\\n                        return True\\n            if y == 0:\\n                for yy, tt in helper(t):\\n                    if dp(x, s, yy, tt):\\n                        return True\\n            return False\\n            \\n        return dp(0, s1, 0, s2)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```py\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def helper(s):\\n            res = []\\n            if s:\\n                if s[0].isalpha():\\n                    res.append((1, s[1:]))\\n                else:\\n                    for i in range(3):\\n                        if i < len(s) and s[i].isdigit():\\n                            res.append((int(s[:i + 1]), s[i + 1:]))\\n                        else:\\n                            break\\n            return res\\n        \\n        @cache\\n        def dp(x, s, y, t):\\n            if x * y > 0:\\n                return dp(x - min(x, y), s, y - min(x, y), t)\\n            if x + y == 0:\\n                if not s and not t:\\n                    return True\\n                if not s or not t:\\n                    return False\\n                if s[0].isalpha() and t[0].isalpha():\\n                    return s[0] == t[0] and dp(0, s[1:], 0, t[1:])\\n            if x == 0:\\n                for xx, ss in helper(s):\\n                    if dp(xx, ss, y, t):\\n                        return True\\n            if y == 0:\\n                for yy, tt in helper(t):\\n                    if dp(x, s, yy, tt):\\n                        return True\\n            return False\\n            \\n        return dp(0, s1, 0, s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283205,
                "title": "good-dp-problem-python-top-down-dp",
                "content": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \"\"\"\\n            find if s1 and s2\\n            sequence matter dp\\n            \\n            dp(ci, cj, diff):  return if s1 and s2 matches from location. ci,cj where diff represents previoius lefttoover from s1 or s2\\n\\n            state ttransittion:\\n                look at code  for this, there are lott of ttransittiion\\n                \\n                \\n                \\n            base case\\n                ci and cj both at end, rett. true\\n                iif. one exhaused rertun False\\n        \\n        \"\"\"\\n        \\n        \"\"\"\\n        eex.\\n        \\n            internationalization\\n             ^\\n            i18n\\n             ^\\n             ci = 1\\n             cj = n\\n             \\n             ci = 18\\n             cj = n \\n              we try both to see. which one. reaches the end\\n        \"\"\"\\n        @cache\\n        def dp(ci, cj, diff):\\n            \\n            if ci == len(s1) and cj == len(s2) and diff == 0:\\n                return True\\n            \\n            if ci > len(s1) or cj > len(s2):\\n                return False\\n            \\n            \\n            if ci < len(s1) and s1[ci].isdigit():\\n                k = ci\\n                curr = \"\"\\n                while k < len(s1) and s1[k].isdigit():\\n                    curr += s1[k]\\n                    k += 1\\n                    if dp(k, cj, diff + int(curr)) == True:\\n                        return True\\n            elif cj < len(s2) and s2[cj].isdigit():\\n                k = cj\\n                curr = \"\"\\n                while k < len(s2)  and s2[k].isdigit():\\n                    curr += s2[k]\\n                    k += 1\\n                    if dp(ci, k, diff - int(curr)) == True:\\n                        return True\\n            elif diff == 0:\\n                if ci < len(s1) and cj < len(s2) and s1[ci] == s2[cj]:\\n                    return dp(ci+1, cj+1, diff)\\n                else:\\n                    return False\\n            else:\\n                if diff > 0 :\\n                    # s1 exist more\\n                    return dp(ci, cj+1, diff-1)\\n                else:\\n                    return dp(ci+1, cj, diff+1)\\n            \\n            return False\\n        \\n        return dp(0, 0, 0)\\n  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \"\"\"\\n            find if s1 and s2\\n            sequence matter dp\\n            \\n            dp(ci, cj, diff):  return if s1 and s2 matches from location. ci,cj where diff represents previoius lefttoover from s1 or s2\\n\\n            state ttransittion:\\n                look at code  for this, there are lott of ttransittiion\\n                \\n                \\n                \\n            base case\\n                ci and cj both at end, rett. true\\n                iif. one exhaused rertun False\\n        \\n        \"\"\"\\n        \\n        \"\"\"\\n        eex.\\n        \\n            internationalization\\n             ^\\n            i18n\\n             ^\\n             ci = 1\\n             cj = n\\n             \\n             ci = 18\\n             cj = n \\n              we try both to see. which one. reaches the end\\n        \"\"\"\\n        @cache\\n        def dp(ci, cj, diff):\\n            \\n            if ci == len(s1) and cj == len(s2) and diff == 0:\\n                return True\\n            \\n            if ci > len(s1) or cj > len(s2):\\n                return False\\n            \\n            \\n            if ci < len(s1) and s1[ci].isdigit():\\n                k = ci\\n                curr = \"\"\\n                while k < len(s1) and s1[k].isdigit():\\n                    curr += s1[k]\\n                    k += 1\\n                    if dp(k, cj, diff + int(curr)) == True:\\n                        return True\\n            elif cj < len(s2) and s2[cj].isdigit():\\n                k = cj\\n                curr = \"\"\\n                while k < len(s2)  and s2[k].isdigit():\\n                    curr += s2[k]\\n                    k += 1\\n                    if dp(ci, k, diff - int(curr)) == True:\\n                        return True\\n            elif diff == 0:\\n                if ci < len(s1) and cj < len(s2) and s1[ci] == s2[cj]:\\n                    return dp(ci+1, cj+1, diff)\\n                else:\\n                    return False\\n            else:\\n                if diff > 0 :\\n                    # s1 exist more\\n                    return dp(ci, cj+1, diff-1)\\n                else:\\n                    return dp(ci+1, cj, diff+1)\\n            \\n            return False\\n        \\n        return dp(0, 0, 0)\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235565,
                "title": "python-dp-top-down",
                "content": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\'\\'\\'\\n        https://www.youtube.com/watch?v=XN9GqDRPv34&ab_channel=ProgrammingLivewithLarry\\n        \\'\\'\\'\\n        \\n        \\'\\'\\'\\n        leftover = no. of chars i1 \"owes\" to i2\\n        \\'\\'\\'\\n        n1, n2 = len(s1), len(s2)\\n        \\n        @cache\\n        def moveS1dueToDigit(i1, i2, leftover):\\n            #print(\"moveS1dueToDigit\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover)\\n            x = int(s1[i1])\\n            #print(\"x\",x)\\n            if go(i1+1, i2, leftover - x):\\n                return True\\n\\n            if i1+1 < n1 and s1[i1+1].isdigit():\\n                x = (x*10+int(s1[i1+1]))\\n                #print(\"x\", x)\\n                if go(i1+2, i2, leftover - x):\\n                    return True\\n\\n                if i1+2 < n1 and s1[i1+2].isdigit():\\n                    x = (x*10+int(s1[i1+2]))\\n                    #print(\"x\", x)\\n                    if go(i1+3, i2, leftover - x):\\n                        return True\\n                    \\n            #print(\"moveS1dueToDigit\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover, \"return false\")\\n            return False\\n        \\n        @cache\\n        def moveS2dueToDigit(i1, i2, leftover):\\n            #print(\"moveS2dueToDigit\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover)\\n            y = int(s2[i2])\\n            #print(\"y\", y)\\n            if go(i1, i2+1, leftover + y):\\n                return True\\n\\n            if i2+1 < n2 and s2[i2+1].isdigit():\\n                y = y*10+int(s2[i2+1])\\n                #print(\"y\", y)\\n                if go(i1, i2+2, leftover + y):\\n                    return True\\n\\n                if i2+2 < n2 and s2[i2+2].isdigit():\\n                    y = y*10+int(s2[i2+2])\\n                    #print(\"y\", y)\\n                    if go(i1, i2+3, leftover + y):\\n                        return True\\n                       \\n            #print(\"moveS2dueToDigit\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover, \"return false\")\\n            return False\\n        \\n        @cache\\n        def go(i1, i2, leftover):\\n            #print(\"go\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover)\\n            if i1 >= n1 and i2 >= n2:\\n                return True if leftover == 0 else False\\n            if (i1 >= n1 or i2 >= n2) and leftover == 0:\\n                return False\\n            \\n            if leftover < 0:\\n                if i2 >= n2:\\n                    return False\\n                \\n                y = s2[i2]\\n                if y.isalpha():\\n                    return go(i1, i2+1, leftover+1)\\n                \\n                return moveS2dueToDigit(i1, i2, leftover)\\n\\n            elif leftover > 0:\\n                if i1 >= n1:\\n                    return False\\n                \\n                if s1[i1].isalpha():\\n                    return go(i1+1, i2, leftover-1)\\n                \\n                return moveS1dueToDigit(i1, i2, leftover)\\n            \\n            #leftover = 0\\n            x, y = s1[i1], s2[i2]\\n            if x.isdigit():\\n                return moveS1dueToDigit(i1, i2, leftover)\\n                        \\n            if y.isdigit():\\n                return moveS2dueToDigit(i1, i2, leftover)\\n                        \\n            if x == y and go(i1+1, i2+1, leftover):\\n                return True\\n            \\n            return False\\n            \\n        return go(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\'\\'\\'\\n        https://www.youtube.com/watch?v=XN9GqDRPv34&ab_channel=ProgrammingLivewithLarry\\n        \\'\\'\\'\\n        \\n        \\'\\'\\'\\n        leftover = no. of chars i1 \"owes\" to i2\\n        \\'\\'\\'\\n        n1, n2 = len(s1), len(s2)\\n        \\n        @cache\\n        def moveS1dueToDigit(i1, i2, leftover):\\n            #print(\"moveS1dueToDigit\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover)\\n            x = int(s1[i1])\\n            #print(\"x\",x)\\n            if go(i1+1, i2, leftover - x):\\n                return True\\n\\n            if i1+1 < n1 and s1[i1+1].isdigit():\\n                x = (x*10+int(s1[i1+1]))\\n                #print(\"x\", x)\\n                if go(i1+2, i2, leftover - x):\\n                    return True\\n\\n                if i1+2 < n1 and s1[i1+2].isdigit():\\n                    x = (x*10+int(s1[i1+2]))\\n                    #print(\"x\", x)\\n                    if go(i1+3, i2, leftover - x):\\n                        return True\\n                    \\n            #print(\"moveS1dueToDigit\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover, \"return false\")\\n            return False\\n        \\n        @cache\\n        def moveS2dueToDigit(i1, i2, leftover):\\n            #print(\"moveS2dueToDigit\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover)\\n            y = int(s2[i2])\\n            #print(\"y\", y)\\n            if go(i1, i2+1, leftover + y):\\n                return True\\n\\n            if i2+1 < n2 and s2[i2+1].isdigit():\\n                y = y*10+int(s2[i2+1])\\n                #print(\"y\", y)\\n                if go(i1, i2+2, leftover + y):\\n                    return True\\n\\n                if i2+2 < n2 and s2[i2+2].isdigit():\\n                    y = y*10+int(s2[i2+2])\\n                    #print(\"y\", y)\\n                    if go(i1, i2+3, leftover + y):\\n                        return True\\n                       \\n            #print(\"moveS2dueToDigit\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover, \"return false\")\\n            return False\\n        \\n        @cache\\n        def go(i1, i2, leftover):\\n            #print(\"go\", \"i1\", i1, \"i2\", i2, \"leftover\", leftover)\\n            if i1 >= n1 and i2 >= n2:\\n                return True if leftover == 0 else False\\n            if (i1 >= n1 or i2 >= n2) and leftover == 0:\\n                return False\\n            \\n            if leftover < 0:\\n                if i2 >= n2:\\n                    return False\\n                \\n                y = s2[i2]\\n                if y.isalpha():\\n                    return go(i1, i2+1, leftover+1)\\n                \\n                return moveS2dueToDigit(i1, i2, leftover)\\n\\n            elif leftover > 0:\\n                if i1 >= n1:\\n                    return False\\n                \\n                if s1[i1].isalpha():\\n                    return go(i1+1, i2, leftover-1)\\n                \\n                return moveS1dueToDigit(i1, i2, leftover)\\n            \\n            #leftover = 0\\n            x, y = s1[i1], s2[i2]\\n            if x.isdigit():\\n                return moveS1dueToDigit(i1, i2, leftover)\\n                        \\n            if y.isdigit():\\n                return moveS2dueToDigit(i1, i2, leftover)\\n                        \\n            if x == y and go(i1+1, i2+1, leftover):\\n                return True\\n            \\n            return False\\n            \\n        return go(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213895,
                "title": "c-clean-with-explanation-recursive-with-memo",
                "content": "```\\nshort dp[41][41][2000];\\n    \\nint offset = 1000;\\n\\nclass Solution {\\npublic:\\n    int n, m;\\n    \\n    \\n    \\n    bool isDigit(char c)\\n    {\\n        return (c <= \\'9\\' && c >= \\'1\\');\\n    }\\n    \\n    bool solve(int i, int j, int diff, string &s1, string &s2)\\n    {\\n        string num1, num2;\\n        // diff must be 0 at the end.\\n        if(i == n && j == m)\\n        {\\n            return diff == 0;\\n        }\\n        bool ans = false;\\n        \\n        if(dp[i][j][diff+offset] != -1) return dp[i][j][diff+offset];\\n        \\n        // if net difference is 0 and both are characters then they must be equal otherwise false\\n        if(i < n && j < m && diff == 0 && !isDigit(s1[i]) && !isDigit(s2[j]))\\n        {\\n            if(s1[i] == s2[j])\\n                ans = solve(i+1, j+1, diff, s1, s2);\\n            else\\n                ans = false;\\n        }\\n        // when diffence is > 0 and s1[i] is character simply reduce the difference and solve for (i+1,j)\\n        if(i < n && diff > 0 && !isDigit(s1[i]))\\n        {\\n            ans = ans || solve(i+1, j, diff-1, s1, s2);\\n        }\\n        // same as above but here increase the difference.\\n        if(j < m && diff < 0 && !isDigit(s2[j]))\\n        {\\n            ans = ans || solve(i, j+1, diff+1, s1, s2);\\n        }\\n        // case when s1[i] is digit we form all the type of numbers and reduce the diffence by that number.\\n        if(i < n)\\n        {\\n            int num = 0;\\n            int i1 = i;\\n            while(i1 < n && isDigit(s1[i1]))\\n            {\\n                num = num * 10 + (s1[i1]-\\'0\\');\\n                ans = ans || solve(i1+1, j, diff-num, s1, s2);\\n                i1++;\\n            }\\n        }\\n        // same as above but for s2 hence diff should be increased.\\n        if(j < m)\\n        {\\n            int num = 0;\\n            int j1 = j;\\n            while(j1 < m && isDigit(s2[j1]))\\n            {\\n                num = num * 10 + (s2[j1]-\\'0\\');\\n                ans = ans || solve(i, j1+1, diff+num, s1, s2);\\n                j1++;\\n            }\\n        }\\n        return dp[i][j][diff+offset] = ans;\\n    }\\n    \\n    bool possiblyEquals(string s1, string s2) {\\n        n = s1.size();\\n        m = s2.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0, 0, s1, s2);   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nshort dp[41][41][2000];\\n    \\nint offset = 1000;\\n\\nclass Solution {\\npublic:\\n    int n, m;\\n    \\n    \\n    \\n    bool isDigit(char c)\\n    {\\n        return (c <= \\'9\\' && c >= \\'1\\');\\n    }\\n    \\n    bool solve(int i, int j, int diff, string &s1, string &s2)\\n    {\\n        string num1, num2;\\n        // diff must be 0 at the end.\\n        if(i == n && j == m)\\n        {\\n            return diff == 0;\\n        }\\n        bool ans = false;\\n        \\n        if(dp[i][j][diff+offset] != -1) return dp[i][j][diff+offset];\\n        \\n        // if net difference is 0 and both are characters then they must be equal otherwise false\\n        if(i < n && j < m && diff == 0 && !isDigit(s1[i]) && !isDigit(s2[j]))\\n        {\\n            if(s1[i] == s2[j])\\n                ans = solve(i+1, j+1, diff, s1, s2);\\n            else\\n                ans = false;\\n        }\\n        // when diffence is > 0 and s1[i] is character simply reduce the difference and solve for (i+1,j)\\n        if(i < n && diff > 0 && !isDigit(s1[i]))\\n        {\\n            ans = ans || solve(i+1, j, diff-1, s1, s2);\\n        }\\n        // same as above but here increase the difference.\\n        if(j < m && diff < 0 && !isDigit(s2[j]))\\n        {\\n            ans = ans || solve(i, j+1, diff+1, s1, s2);\\n        }\\n        // case when s1[i] is digit we form all the type of numbers and reduce the diffence by that number.\\n        if(i < n)\\n        {\\n            int num = 0;\\n            int i1 = i;\\n            while(i1 < n && isDigit(s1[i1]))\\n            {\\n                num = num * 10 + (s1[i1]-\\'0\\');\\n                ans = ans || solve(i1+1, j, diff-num, s1, s2);\\n                i1++;\\n            }\\n        }\\n        // same as above but for s2 hence diff should be increased.\\n        if(j < m)\\n        {\\n            int num = 0;\\n            int j1 = j;\\n            while(j1 < m && isDigit(s2[j1]))\\n            {\\n                num = num * 10 + (s2[j1]-\\'0\\');\\n                ans = ans || solve(i, j1+1, diff+num, s1, s2);\\n                j1++;\\n            }\\n        }\\n        return dp[i][j][diff+offset] = ans;\\n    }\\n    \\n    bool possiblyEquals(string s1, string s2) {\\n        n = s1.size();\\n        m = s2.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0, 0, s1, s2);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995358,
                "title": "typescript-backtracking-memo-solution-100-faster",
                "content": "```\\nfunction isNumber(char: string): boolean {\\n\\treturn isFinite(char as unknown as number);\\n}\\n\\nfunction possibleDigits(index: number, sourceString: string): number[] {\\n\\tlet acc = sourceString[index];\\n\\tconst result = [Number(acc)];\\n\\n\\tlet count = 1;\\n\\twhile (\\n\\t\\tcount < 3 &&\\n\\t\\tindex + count < sourceString.length &&\\n\\t\\tisNumber(sourceString[index + count])\\n\\t) {\\n\\t\\tacc += sourceString[index + count];\\n\\t\\tresult.push(Number(acc));\\n\\t\\tcount++;\\n\\t}\\n\\n\\treturn result;\\n}\\n\\nfunction possiblyEquals(s1: string, s2: string): boolean {\\n\\tconst memo = {};\\n\\n\\tconst backtrack = (i1 = 0, i2 = 0, balance = 0) => {\\n\\t\\tif (i1 >= s1.length && i2 >= s2.length) {\\n\\t\\t\\treturn balance === 0;\\n\\t\\t}\\n\\n\\t\\tconst key = `${i1}-${i2}-${balance}`;\\n\\t\\tif (key in memo) {\\n\\t\\t\\treturn memo[key];\\n\\t\\t}\\n\\n\\t\\t// Literal matching on s1[i1] and s2[i2]\\n\\t\\tif (\\n\\t\\t\\ti1 < s1.length &&\\n\\t\\t\\ti2 < s2.length &&\\n\\t\\t\\tbalance == 0 &&\\n\\t\\t\\ts1[i1] == s2[i2]\\n\\t\\t) {\\n\\t\\t\\tif (backtrack(i1 + 1, i2 + 1, balance)) {\\n\\t\\t\\t\\treturn (memo[key] = true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Literal matching on s1[i1]\\n\\t\\tif (\\n\\t\\t\\ti1 < s1.length &&\\n\\t\\t\\t!isNumber(s1[i1]) &&\\n\\t\\t\\tbalance > 0 &&\\n\\t\\t\\tbacktrack(i1 + 1, i2, balance - 1)\\n\\t\\t) {\\n\\t\\t\\treturn (memo[key] = true);\\n\\t\\t}\\n\\n\\t\\t// Literal matching on s2[i2]\\n\\t\\tif (\\n\\t\\t\\ti2 < s2.length &&\\n\\t\\t\\t!isNumber(s2[i2]) &&\\n\\t\\t\\tbalance < 0 &&\\n\\t\\t\\tbacktrack(i1, i2 + 1, balance + 1)\\n\\t\\t) {\\n\\t\\t\\treturn (memo[key] = true);\\n\\t\\t}\\n\\n\\t\\t// Wildcard matching on s1[i1]\\n\\t\\tif (i1 < s1.length && isNumber(s1[i1])) {\\n\\t\\t\\tlet i = 0;\\n\\t\\t\\tfor (const value of possibleDigits(i1, s1)) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (backtrack(i1 + i, i2, balance - value)) {\\n\\t\\t\\t\\t\\treturn (memo[key] = true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Wildcard matching on s2[i2]\\n\\t\\tif (i2 < s2.length && isNumber(s2[i2])) {\\n\\t\\t\\tlet i = 0;\\n\\t\\t\\tfor (const value of possibleDigits(i2, s2)) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (backtrack(i1, i2 + i, balance + value)) {\\n\\t\\t\\t\\t\\treturn (memo[key] = true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (memo[key] = false);\\n\\t};\\n\\n\\treturn backtrack();\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nfunction isNumber(char: string): boolean {\\n\\treturn isFinite(char as unknown as number);\\n}\\n\\nfunction possibleDigits(index: number, sourceString: string): number[] {\\n\\tlet acc = sourceString[index];\\n\\tconst result = [Number(acc)];\\n\\n\\tlet count = 1;\\n\\twhile (\\n\\t\\tcount < 3 &&\\n\\t\\tindex + count < sourceString.length &&\\n\\t\\tisNumber(sourceString[index + count])\\n\\t) {\\n\\t\\tacc += sourceString[index + count];\\n\\t\\tresult.push(Number(acc));\\n\\t\\tcount++;\\n\\t}\\n\\n\\treturn result;\\n}\\n\\nfunction possiblyEquals(s1: string, s2: string): boolean {\\n\\tconst memo = {};\\n\\n\\tconst backtrack = (i1 = 0, i2 = 0, balance = 0) => {\\n\\t\\tif (i1 >= s1.length && i2 >= s2.length) {\\n\\t\\t\\treturn balance === 0;\\n\\t\\t}\\n\\n\\t\\tconst key = `${i1}-${i2}-${balance}`;\\n\\t\\tif (key in memo) {\\n\\t\\t\\treturn memo[key];\\n\\t\\t}\\n\\n\\t\\t// Literal matching on s1[i1] and s2[i2]\\n\\t\\tif (\\n\\t\\t\\ti1 < s1.length &&\\n\\t\\t\\ti2 < s2.length &&\\n\\t\\t\\tbalance == 0 &&\\n\\t\\t\\ts1[i1] == s2[i2]\\n\\t\\t) {\\n\\t\\t\\tif (backtrack(i1 + 1, i2 + 1, balance)) {\\n\\t\\t\\t\\treturn (memo[key] = true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Literal matching on s1[i1]\\n\\t\\tif (\\n\\t\\t\\ti1 < s1.length &&\\n\\t\\t\\t!isNumber(s1[i1]) &&\\n\\t\\t\\tbalance > 0 &&\\n\\t\\t\\tbacktrack(i1 + 1, i2, balance - 1)\\n\\t\\t) {\\n\\t\\t\\treturn (memo[key] = true);\\n\\t\\t}\\n\\n\\t\\t// Literal matching on s2[i2]\\n\\t\\tif (\\n\\t\\t\\ti2 < s2.length &&\\n\\t\\t\\t!isNumber(s2[i2]) &&\\n\\t\\t\\tbalance < 0 &&\\n\\t\\t\\tbacktrack(i1, i2 + 1, balance + 1)\\n\\t\\t) {\\n\\t\\t\\treturn (memo[key] = true);\\n\\t\\t}\\n\\n\\t\\t// Wildcard matching on s1[i1]\\n\\t\\tif (i1 < s1.length && isNumber(s1[i1])) {\\n\\t\\t\\tlet i = 0;\\n\\t\\t\\tfor (const value of possibleDigits(i1, s1)) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (backtrack(i1 + i, i2, balance - value)) {\\n\\t\\t\\t\\t\\treturn (memo[key] = true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Wildcard matching on s2[i2]\\n\\t\\tif (i2 < s2.length && isNumber(s2[i2])) {\\n\\t\\t\\tlet i = 0;\\n\\t\\t\\tfor (const value of possibleDigits(i2, s2)) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (backtrack(i1, i2 + i, balance + value)) {\\n\\t\\t\\t\\t\\treturn (memo[key] = true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (memo[key] = false);\\n\\t};\\n\\n\\treturn backtrack();\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995276,
                "title": "java-backtracking-with-memo",
                "content": "* key is to store diff, originally I stored calculated length of each string, which caused MLE\\n\\n\\n```\\n\\nclass Solution {\\n    boolean stringMatched = false;\\n    String s1;\\n    String s2;\\n    \\n    class Key {\\n        int i1;\\n        int i2;\\n        \\n        Key(int i1, int i2) {\\n            this.i1 = i1;\\n            this.i2 = i2;\\n        }\\n    }\\n    \\n    Boolean[][][] memo;\\n    \\n    public boolean possiblyEquals(String s1, String s2) {\\n        // backtracking\\n        // during each iteration we just need to know the length diff of 2 matched strings don\\'t need the full length\\n        \\n        this.s1 = s1;\\n        this.s2 = s2;\\n        memo = new Boolean[s1.length()+1][s2.length()+1][2000];\\n        \\n        dfs(0,0,0);\\n        \\n        return stringMatched;\\n    }\\n    \\n    private void dfs(int i1, int i2, int diff) {\\n        // System.out.println(\"i1:\" + i1 + \" i2:\" + i2 + \" len1:\" + len1 + \" len2:\" + len2);\\n        if(stringMatched) return;\\n        if(i1 == s1.length() && i2 == s2.length()) {\\n            if(diff == 0) stringMatched = true;\\n            return;\\n        }\\n        if(i1 == s1.length() && diff <= 0) return;\\n        if(i2 == s2.length() && diff >= 0) return;\\n        if(memo[i1][i2][diff+999] != null) {\\n            stringMatched = memo[i1][i2][diff+999];\\n            return;\\n        }\\n        // System.out.println(\"!!!i1:\" + i1 + \" i2:\" + i2 + \" len1:\" + len1 + \" len2:\" + len2);\\n        \\n        List<int[]> indexNums1 = new ArrayList();\\n        int num1 = 0;\\n        int x1 = i1;\\n        while(x1 < s1.length() && Character.isDigit(s1.charAt(x1))) {\\n            num1 = num1*10 + (s1.charAt(x1) - \\'0\\');\\n            indexNums1.add(new int[]{x1, num1});\\n            x1++;\\n        }\\n        \\n        List<int[]> indexNums2 = new ArrayList();\\n        int num2 = 0;\\n        int x2 = i2;\\n        while(x2 < s2.length() && Character.isDigit(s2.charAt(x2))) {\\n            num2 = num2*10 + (s2.charAt(x2) - \\'0\\');\\n            indexNums2.add(new int[]{x2, num2});\\n            x2++;\\n        }\\n        \\n        \\n        if(diff == 0) {\\n            // System.out.println(\"len1 == len2 i1:\" + i1 + \" i2:\" + i2 + \" len1:\" + len1 + \" len2:\" + len2);\\n            char c1 = s1.charAt(i1); \\n            char c2 = s2.charAt(i2);\\n            if(Character.isLetter(c1) && Character.isLetter(c2)) {\\n                if(c1 != c2) return;\\n                dfs(i1+1, i2+1, diff);\\n                return;\\n            } else {\\n                if(indexNums1.size() > 0) {\\n                    for(int[] num1Item: indexNums1) {\\n                        dfs(num1Item[0]+1, i2, diff+num1Item[1]);\\n                    }\\n                } else {\\n                    for(int[] num2Item: indexNums2) {\\n                        dfs(i1, num2Item[0]+1, diff-num2Item[1]);\\n                    }\\n                }\\n            }\\n        } else if(diff > 0) {\\n            // len1 > len2 diff = len1-len2\\n            if(Character.isLetter(s2.charAt(i2))) {\\n                dfs(i1, i2+1, diff-1);\\n            } else {\\n                for(int[] num2Item: indexNums2) {\\n                    dfs(i1, num2Item[0]+1, diff-num2Item[1]);\\n                }\\n            }\\n        } else {\\n            if(Character.isLetter(s1.charAt(i1))) {\\n                dfs(i1+1, i2, diff+1);\\n            } else {\\n                for(int[] num1Item: indexNums1) {\\n                    dfs(num1Item[0]+1, i2, diff+num1Item[1]);\\n                }\\n            }\\n        }\\n        \\n        memo[i1][i2][diff+999] = stringMatched;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    boolean stringMatched = false;\\n    String s1;\\n    String s2;\\n    \\n    class Key {\\n        int i1;\\n        int i2;\\n        \\n        Key(int i1, int i2) {\\n            this.i1 = i1;\\n            this.i2 = i2;\\n        }\\n    }\\n    \\n    Boolean[][][] memo;\\n    \\n    public boolean possiblyEquals(String s1, String s2) {\\n        // backtracking\\n        // during each iteration we just need to know the length diff of 2 matched strings don\\'t need the full length\\n        \\n        this.s1 = s1;\\n        this.s2 = s2;\\n        memo = new Boolean[s1.length()+1][s2.length()+1][2000];\\n        \\n        dfs(0,0,0);\\n        \\n        return stringMatched;\\n    }\\n    \\n    private void dfs(int i1, int i2, int diff) {\\n        // System.out.println(\"i1:\" + i1 + \" i2:\" + i2 + \" len1:\" + len1 + \" len2:\" + len2);\\n        if(stringMatched) return;\\n        if(i1 == s1.length() && i2 == s2.length()) {\\n            if(diff == 0) stringMatched = true;\\n            return;\\n        }\\n        if(i1 == s1.length() && diff <= 0) return;\\n        if(i2 == s2.length() && diff >= 0) return;\\n        if(memo[i1][i2][diff+999] != null) {\\n            stringMatched = memo[i1][i2][diff+999];\\n            return;\\n        }\\n        // System.out.println(\"!!!i1:\" + i1 + \" i2:\" + i2 + \" len1:\" + len1 + \" len2:\" + len2);\\n        \\n        List<int[]> indexNums1 = new ArrayList();\\n        int num1 = 0;\\n        int x1 = i1;\\n        while(x1 < s1.length() && Character.isDigit(s1.charAt(x1))) {\\n            num1 = num1*10 + (s1.charAt(x1) - \\'0\\');\\n            indexNums1.add(new int[]{x1, num1});\\n            x1++;\\n        }\\n        \\n        List<int[]> indexNums2 = new ArrayList();\\n        int num2 = 0;\\n        int x2 = i2;\\n        while(x2 < s2.length() && Character.isDigit(s2.charAt(x2))) {\\n            num2 = num2*10 + (s2.charAt(x2) - \\'0\\');\\n            indexNums2.add(new int[]{x2, num2});\\n            x2++;\\n        }\\n        \\n        \\n        if(diff == 0) {\\n            // System.out.println(\"len1 == len2 i1:\" + i1 + \" i2:\" + i2 + \" len1:\" + len1 + \" len2:\" + len2);\\n            char c1 = s1.charAt(i1); \\n            char c2 = s2.charAt(i2);\\n            if(Character.isLetter(c1) && Character.isLetter(c2)) {\\n                if(c1 != c2) return;\\n                dfs(i1+1, i2+1, diff);\\n                return;\\n            } else {\\n                if(indexNums1.size() > 0) {\\n                    for(int[] num1Item: indexNums1) {\\n                        dfs(num1Item[0]+1, i2, diff+num1Item[1]);\\n                    }\\n                } else {\\n                    for(int[] num2Item: indexNums2) {\\n                        dfs(i1, num2Item[0]+1, diff-num2Item[1]);\\n                    }\\n                }\\n            }\\n        } else if(diff > 0) {\\n            // len1 > len2 diff = len1-len2\\n            if(Character.isLetter(s2.charAt(i2))) {\\n                dfs(i1, i2+1, diff-1);\\n            } else {\\n                for(int[] num2Item: indexNums2) {\\n                    dfs(i1, num2Item[0]+1, diff-num2Item[1]);\\n                }\\n            }\\n        } else {\\n            if(Character.isLetter(s1.charAt(i1))) {\\n                dfs(i1+1, i2, diff+1);\\n            } else {\\n                for(int[] num1Item: indexNums1) {\\n                    dfs(num1Item[0]+1, i2, diff+num1Item[1]);\\n                }\\n            }\\n        }\\n        \\n        memo[i1][i2][diff+999] = stringMatched;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992290,
                "title": "python-recursion-with-memo",
                "content": "```\\ndef split_digit(s):\\n    ret = []\\n    if s == \"\":\\n        return [0]\\n    if len(s) == 1:\\n        ret.append(int(s))\\n    elif len(s) == 2:\\n        ret.append(int(s))\\n        ret.append(int(s[:1])+int(s[1:]))\\n    else:\\n        ret.append(int(s))\\n        ret.append(int(s[:1])+int(s[1:]))\\n        ret.append(int(s[:2])+int(s[2:]))\\n        ret.append(int(s[0])+int(s[1])+int(s[2]))\\n    return ret\\n        \\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        return self.helper(0, s1, 0, s2)\\n        \\n    @cache\\n    def helper(self, v1, s1, v2, s2):\\n        if len(s1) == 0 == len(s2) == v1 == v2:\\n            return True\\n        i = -1\\n        for i in range(len(s1)):\\n            if not s1[i].isdigit():\\n                break\\n        else:\\n            i = len(s1)\\n        digits1 = split_digit(s1[:i])\\n        if i != -1:\\n            s1 = s1[i:]\\n        for idx in range(len(digits1)):\\n            digits1[idx] += v1\\n        i = -1\\n        for i in range(len(s2)):\\n            if not s2[i].isdigit():\\n                break \\n        else:\\n            i = len(s2)\\n        digits2 = split_digit(s2[:i])\\n        if i != -1:\\n            s2 = s2[i:]\\n        for idx in range(len(digits2)):\\n            digits2[idx] += v2\\n            \\n        for new_v1 in digits1:\\n            for new_v2 in digits2:\\n                #if new_v1 > 40 or new_v2 > 40:\\n                #    continue\\n                if new_v1 != 0 and new_v2 != 0:\\n                    if new_v1 >= new_v2:\\n                        if self.helper(new_v1-new_v2, s1, 0, s2):\\n                            return True\\n                    else:\\n                        if self.helper(0, s1, new_v2-new_v1, s2):\\n                            return True\\n                elif new_v1 == 0 and new_v2 == 0:\\n                    if len(s1) == 0 and len(s2) == 0:\\n                        return True\\n                    elif len(s1) != 0 and len(s2) != 0:\\n                        if self.helper(0, s1[1:], 0, s2[1:]) and s1[0] == s2[0]:\\n                            return True\\n                elif new_v1 == 0 and new_v2 != 0:\\n                    if len(s1) != 0 and self.helper(0, s1[1:], new_v2-1, s2):\\n                        return True\\n                elif new_v2 == 0 and new_v1 != 0:\\n                    if len(s2) != 0 and self.helper(new_v1-1, s1, 0, s2[1:]):\\n                        return True\\n                    \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef split_digit(s):\\n    ret = []\\n    if s == \"\":\\n        return [0]\\n    if len(s) == 1:\\n        ret.append(int(s))\\n    elif len(s) == 2:\\n        ret.append(int(s))\\n        ret.append(int(s[:1])+int(s[1:]))\\n    else:\\n        ret.append(int(s))\\n        ret.append(int(s[:1])+int(s[1:]))\\n        ret.append(int(s[:2])+int(s[2:]))\\n        ret.append(int(s[0])+int(s[1])+int(s[2]))\\n    return ret\\n        \\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        return self.helper(0, s1, 0, s2)\\n        \\n    @cache\\n    def helper(self, v1, s1, v2, s2):\\n        if len(s1) == 0 == len(s2) == v1 == v2:\\n            return True\\n        i = -1\\n        for i in range(len(s1)):\\n            if not s1[i].isdigit():\\n                break\\n        else:\\n            i = len(s1)\\n        digits1 = split_digit(s1[:i])\\n        if i != -1:\\n            s1 = s1[i:]\\n        for idx in range(len(digits1)):\\n            digits1[idx] += v1\\n        i = -1\\n        for i in range(len(s2)):\\n            if not s2[i].isdigit():\\n                break \\n        else:\\n            i = len(s2)\\n        digits2 = split_digit(s2[:i])\\n        if i != -1:\\n            s2 = s2[i:]\\n        for idx in range(len(digits2)):\\n            digits2[idx] += v2\\n            \\n        for new_v1 in digits1:\\n            for new_v2 in digits2:\\n                #if new_v1 > 40 or new_v2 > 40:\\n                #    continue\\n                if new_v1 != 0 and new_v2 != 0:\\n                    if new_v1 >= new_v2:\\n                        if self.helper(new_v1-new_v2, s1, 0, s2):\\n                            return True\\n                    else:\\n                        if self.helper(0, s1, new_v2-new_v1, s2):\\n                            return True\\n                elif new_v1 == 0 and new_v2 == 0:\\n                    if len(s1) == 0 and len(s2) == 0:\\n                        return True\\n                    elif len(s1) != 0 and len(s2) != 0:\\n                        if self.helper(0, s1[1:], 0, s2[1:]) and s1[0] == s2[0]:\\n                            return True\\n                elif new_v1 == 0 and new_v2 != 0:\\n                    if len(s1) != 0 and self.helper(0, s1[1:], new_v2-1, s2):\\n                        return True\\n                elif new_v2 == 0 and new_v1 != 0:\\n                    if len(s2) != 0 and self.helper(new_v1-1, s1, 0, s2[1:]):\\n                        return True\\n                    \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982249,
                "title": "javascript-backtracking-memoization",
                "content": "```\\nvar possiblyEquals = function(s1, s2) {    \\n    // Memo array, note that we do not need to memoize true results as these bubble up\\n    const dp = Array.from({length: s1.length+1}, () => \\n                          Array.from({length: s2.length+1}, \\n                                     () => ([])));\\n    \\n    const backtrack = (p1, p2, count) => {\\n        if(p1 === s1.length && p2 === s2.length) return count === 0;\\n        // Optimization: Exit early if we have already visited here and know that it\\'s false\\n        if(dp[p1][p2][count] !== undefined) return dp[p1][p2][count];\\n\\n        let c1 = s1[p1];\\n        let c2 = s2[p2];        \\n        \\n        // Case 1: string matches exactly\\n        if(p1 < s1.length && p2 < s2.length && \\n           c1 === c2 && count === 0 && \\n           backtrack(p1+1, p2+1, count)) return true;\\n\\n        // Case 2: we can delete a character\\n        if(p1 < s1.length && isNaN(c1) && count < 0 && \\n           backtrack(p1+1, p2, count+1)) return true;\\n        if(p2 < s2.length && isNaN(c2) && count > 0 && \\n           backtrack(p1, p2+1, count-1)) return true;            \\n        \\n        // Case 3: we can start stacking numbers to delete\\n        let num = 0;\\n        for(let i = 0; i < 3 && p1+i < s1.length; i++) {            \\n            let c1 = s1[p1+i];\\n            if(isNaN(c1)) break;\\n            num = num * 10 + parseInt(c1);\\n\\n            if(backtrack(p1+i+1, p2, count + num)) return true;\\n        }\\n\\n        num = 0;\\n        for(let i = 0; i < 3 && p2+i < s2.length; i++) {\\n            let c2 = s2[p2+i];\\n            if(isNaN(c2)) break;\\n            num = num * 10 + parseInt(c2);\\n\\n            if(backtrack(p1, p2+i+1, count - num)) return true;\\n        }\\n        \\n        dp[p1][p2][count] = false;\\n        return false;\\n    }\\n    \\n    return backtrack(0,0,0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar possiblyEquals = function(s1, s2) {    \\n    // Memo array, note that we do not need to memoize true results as these bubble up\\n    const dp = Array.from({length: s1.length+1}, () => \\n                          Array.from({length: s2.length+1}, \\n                                     () => ([])));\\n    \\n    const backtrack = (p1, p2, count) => {\\n        if(p1 === s1.length && p2 === s2.length) return count === 0;\\n        // Optimization: Exit early if we have already visited here and know that it\\'s false\\n        if(dp[p1][p2][count] !== undefined) return dp[p1][p2][count];\\n\\n        let c1 = s1[p1];\\n        let c2 = s2[p2];        \\n        \\n        // Case 1: string matches exactly\\n        if(p1 < s1.length && p2 < s2.length && \\n           c1 === c2 && count === 0 && \\n           backtrack(p1+1, p2+1, count)) return true;\\n\\n        // Case 2: we can delete a character\\n        if(p1 < s1.length && isNaN(c1) && count < 0 && \\n           backtrack(p1+1, p2, count+1)) return true;\\n        if(p2 < s2.length && isNaN(c2) && count > 0 && \\n           backtrack(p1, p2+1, count-1)) return true;            \\n        \\n        // Case 3: we can start stacking numbers to delete\\n        let num = 0;\\n        for(let i = 0; i < 3 && p1+i < s1.length; i++) {            \\n            let c1 = s1[p1+i];\\n            if(isNaN(c1)) break;\\n            num = num * 10 + parseInt(c1);\\n\\n            if(backtrack(p1+i+1, p2, count + num)) return true;\\n        }\\n\\n        num = 0;\\n        for(let i = 0; i < 3 && p2+i < s2.length; i++) {\\n            let c2 = s2[p2+i];\\n            if(isNaN(c2)) break;\\n            num = num * 10 + parseInt(c2);\\n\\n            if(backtrack(p1, p2+i+1, count - num)) return true;\\n        }\\n        \\n        dp[p1][p2][count] = false;\\n        return false;\\n    }\\n    \\n    return backtrack(0,0,0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1968078,
                "title": "i-can-t-make-this-work-for-my-c-solution-help",
                "content": "C# solution\\nFails with test case: \\n\"p87p739q339p\"\\n\"751p6p259q3p1p\"\\n\\n```\\npublic class Solution {\\n    public bool PossiblyEquals(string s1, string s2) {\\n        if (s1 == null && s2 == null) {\\n            return true;\\n        }\\n        else if (s1 == null || s2 == null) {\\n            return false;\\n        }\\n        \\n        // 0 is visited false, 1 is visited true\\n        var memo = new Dictionary<int, int>[s1.Length + 1][];\\n        for (int i = 0; i < s1.Length + 1 ; i++) {\\n            memo[i] = new Dictionary<int, int>[s2.Length + 1];\\n            for (int j = 0; j < s2.Length + 1; j++) {\\n                memo[i][j] = new Dictionary<int, int>();\\n            }\\n        }\\n        \\n        return FindPossibleEquals(s1, s2, 0, 0, 0, memo);\\n    }\\n    \\n    private bool FindPossibleEquals(string s1, string s2, int i1, int i2, int diff, Dictionary<int, int>[][] memo) {\\n        if (i1 == s1.Length && i2 == s2.Length) {\\n            return diff == 0;\\n        }\\n        \\n        if(memo[i1][i2].ContainsKey(diff)) {\\n            return memo[i1][i2][diff] == 1;\\n        }\\n        \\n        if (i1 < s1.Length && IsNumber(s1[i1])) {\\n            int num = 0;\\n            while (i1 < s1.Length && IsNumber(s1[i1])) {\\n                num = num * 10 + s1[i1] - \\'0\\';\\n                i1++;\\n                if (FindPossibleEquals(s1, s2, i1, i2, diff - num, memo)) {\\n                    memo[i1][i2].Add(diff, 1);\\n                    return true;\\n                }\\n            }\\n        }\\n        else if (i2 < s2.Length && IsNumber(s2[i2])){\\n            int num = 0;\\n            while (i2 < s2.Length && IsNumber(s2[i2])) {\\n                num = num * 10 + s2[i2] - \\'0\\';\\n                i2++;\\n                if (FindPossibleEquals(s1, s2, i1, i2, diff + num, memo)) {\\n                    memo[i1][i2].Add(diff, 1);\\n                    return true;\\n                }\\n            }\\n        }\\n        else if (diff == 0) {\\n            if (i1 < s1.Length && i2 < s2.Length && s1[i1] == s2[i2] && FindPossibleEquals(s1, s2, i1 + 1, i2 + 1, diff, memo)) {\\n                memo[i1][i2].Add(diff, 1);\\n                return true;\\n            }\\n        }\\n        else if (diff > 0) {\\n            if (i1 < s1.Length && FindPossibleEquals(s1, s2, i1 + 1, i2, diff-1, memo)) {\\n                memo[i1][i2].Add(diff, 1);\\n                return true;\\n            }\\n        }\\n        else if (diff < 0) {\\n            if (i2 < s2.Length && FindPossibleEquals(s1, s2, i1, i2 + 1, diff+1, memo)) {\\n                memo[i1][i2].Add(diff, 1);\\n                return true;\\n            }\\n        }\\n        \\n        if (!memo[i1][i2].ContainsKey(diff)) {\\n            memo[i1][i2].Add(diff, 0);\\n        }\\n\\n        return false;\\n    }\\n    \\n    private bool IsNumber(char c) {\\n        return c <= \\'9\\' && c >= \\'0\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool PossiblyEquals(string s1, string s2) {\\n        if (s1 == null && s2 == null) {\\n            return true;\\n        }\\n        else if (s1 == null || s2 == null) {\\n            return false;\\n        }\\n        \\n        // 0 is visited false, 1 is visited true\\n        var memo = new Dictionary<int, int>[s1.Length + 1][];\\n        for (int i = 0; i < s1.Length + 1 ; i++) {\\n            memo[i] = new Dictionary<int, int>[s2.Length + 1];\\n            for (int j = 0; j < s2.Length + 1; j++) {\\n                memo[i][j] = new Dictionary<int, int>();\\n            }\\n        }\\n        \\n        return FindPossibleEquals(s1, s2, 0, 0, 0, memo);\\n    }\\n    \\n    private bool FindPossibleEquals(string s1, string s2, int i1, int i2, int diff, Dictionary<int, int>[][] memo) {\\n        if (i1 == s1.Length && i2 == s2.Length) {\\n            return diff == 0;\\n        }\\n        \\n        if(memo[i1][i2].ContainsKey(diff)) {\\n            return memo[i1][i2][diff] == 1;\\n        }\\n        \\n        if (i1 < s1.Length && IsNumber(s1[i1])) {\\n            int num = 0;\\n            while (i1 < s1.Length && IsNumber(s1[i1])) {\\n                num = num * 10 + s1[i1] - \\'0\\';\\n                i1++;\\n                if (FindPossibleEquals(s1, s2, i1, i2, diff - num, memo)) {\\n                    memo[i1][i2].Add(diff, 1);\\n                    return true;\\n                }\\n            }\\n        }\\n        else if (i2 < s2.Length && IsNumber(s2[i2])){\\n            int num = 0;\\n            while (i2 < s2.Length && IsNumber(s2[i2])) {\\n                num = num * 10 + s2[i2] - \\'0\\';\\n                i2++;\\n                if (FindPossibleEquals(s1, s2, i1, i2, diff + num, memo)) {\\n                    memo[i1][i2].Add(diff, 1);\\n                    return true;\\n                }\\n            }\\n        }\\n        else if (diff == 0) {\\n            if (i1 < s1.Length && i2 < s2.Length && s1[i1] == s2[i2] && FindPossibleEquals(s1, s2, i1 + 1, i2 + 1, diff, memo)) {\\n                memo[i1][i2].Add(diff, 1);\\n                return true;\\n            }\\n        }\\n        else if (diff > 0) {\\n            if (i1 < s1.Length && FindPossibleEquals(s1, s2, i1 + 1, i2, diff-1, memo)) {\\n                memo[i1][i2].Add(diff, 1);\\n                return true;\\n            }\\n        }\\n        else if (diff < 0) {\\n            if (i2 < s2.Length && FindPossibleEquals(s1, s2, i1, i2 + 1, diff+1, memo)) {\\n                memo[i1][i2].Add(diff, 1);\\n                return true;\\n            }\\n        }\\n        \\n        if (!memo[i1][i2].ContainsKey(diff)) {\\n            memo[i1][i2].Add(diff, 0);\\n        }\\n\\n        return false;\\n    }\\n    \\n    private bool IsNumber(char c) {\\n        return c <= \\'9\\' && c >= \\'0\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967045,
                "title": "nightmare-for-an-interview",
                "content": "The number of edge cases is more.\\nThe time it takes to understand them in the first go will be more and during implementation we will need to very careful not to miss any cases.\\nOverall for a 45 minutes interview, this will be a challenge!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1944453,
                "title": "help-typescript-javascript-solution-cannot-pass-tle",
                "content": "```\\nfunction possiblyEquals(s1: string, s2: string): boolean {\\n  const m = s1.length;\\n  const n = s2.length;\\n\\n  const memo = [...new Array(41)].map(() =>\\n    [...new Array(41)].map(() => new Array(2000).fill(null))\\n  );\\n\\n  function isCharacter(c: string): boolean {\\n    if (c >= \\'a\\' && c <= \\'z\\') {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  function dfs(i: number, j: number, diff: number) {\\n    if (i >= m && j >= n) {\\n      return diff === 0;\\n    }\\n\\n    if (memo[i][j][diff + 1000] !== null) {\\n      return memo[i][j][diff + 1000];\\n    }\\n\\n    // literal matching\\n    if (i < m && j < n && diff === 0 && s1[i] === s2[j]) {\\n      if (dfs(i + 1, j + 1, 0)) {\\n        return (memo[i][j][1000] = true);\\n      }\\n    }\\n\\n    if (i < m && isCharacter(s1[i]) && diff > 0 && dfs(i + 1, j, diff - 1)) {\\n      return (memo[i][j][diff + 1000] = true);\\n    }\\n\\n    if (j < n && isCharacter(s2[j]) && diff < 0 && dfs(i, j + 1, diff + 1)) {\\n      return (memo[i][j][diff + 1000] = true);\\n    }\\n\\n    for (let k = i, val = 0; k < m && isCharacter(s1[k]) === false; ++k) {\\n      val = val * 10 + parseInt(s1[k]);\\n      if (dfs(k + 1, j, diff - val)) {\\n        return (memo[i][j][diff + 1000] = true);\\n      }\\n    }\\n\\n    for (let k = j, val = 0; k < n && isCharacter(s2[k]) === false; ++k) {\\n      val = val * 10 + parseInt(s2[k]);\\n      if (dfs(i, k + 1, diff + val)) {\\n        return (memo[i][j][diff + 1000] = true);\\n      }\\n    }\\n\\n    return (memo[i][j][diff + 1000] = false);\\n  }\\n\\n  return dfs(0, 0, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction possiblyEquals(s1: string, s2: string): boolean {\\n  const m = s1.length;\\n  const n = s2.length;\\n\\n  const memo = [...new Array(41)].map(() =>\\n    [...new Array(41)].map(() => new Array(2000).fill(null))\\n  );\\n\\n  function isCharacter(c: string): boolean {\\n    if (c >= \\'a\\' && c <= \\'z\\') {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  function dfs(i: number, j: number, diff: number) {\\n    if (i >= m && j >= n) {\\n      return diff === 0;\\n    }\\n\\n    if (memo[i][j][diff + 1000] !== null) {\\n      return memo[i][j][diff + 1000];\\n    }\\n\\n    // literal matching\\n    if (i < m && j < n && diff === 0 && s1[i] === s2[j]) {\\n      if (dfs(i + 1, j + 1, 0)) {\\n        return (memo[i][j][1000] = true);\\n      }\\n    }\\n\\n    if (i < m && isCharacter(s1[i]) && diff > 0 && dfs(i + 1, j, diff - 1)) {\\n      return (memo[i][j][diff + 1000] = true);\\n    }\\n\\n    if (j < n && isCharacter(s2[j]) && diff < 0 && dfs(i, j + 1, diff + 1)) {\\n      return (memo[i][j][diff + 1000] = true);\\n    }\\n\\n    for (let k = i, val = 0; k < m && isCharacter(s1[k]) === false; ++k) {\\n      val = val * 10 + parseInt(s1[k]);\\n      if (dfs(k + 1, j, diff - val)) {\\n        return (memo[i][j][diff + 1000] = true);\\n      }\\n    }\\n\\n    for (let k = j, val = 0; k < n && isCharacter(s2[k]) === false; ++k) {\\n      val = val * 10 + parseInt(s2[k]);\\n      if (dfs(i, k + 1, diff + val)) {\\n        return (memo[i][j][diff + 1000] = true);\\n      }\\n    }\\n\\n    return (memo[i][j][diff + 1000] = false);\\n  }\\n\\n  return dfs(0, 0, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840016,
                "title": "python-dfs",
                "content": "brutal force recursive search.\\n`i, j` to track the next available position, `budget` to track the number of chars can be replaced (sign is meaningful)\\nwhen encountering digits, greedily check all possible ways to interpret it\\n```\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        \\n        def get_possible_nums(s, k):\\n            n_digit = 0\\n            while k < len(s) and s[k].isdigit():\\n                n_digit += 1\\n                k += 1\\n            yield int(s[k - n_digit : k]), k\\n            if n_digit == 2:\\n                yield int(s[k - 2]) + int(s[k - 1]), k\\n            elif n_digit == 3:\\n                yield int(s[k - 3]) + int(s[k - 2]) + int(s[k - 1]), k\\n                yield int(s[k - 3 : k - 1]) + int(s[k - 1]), k\\n                yield int(s[k - 3]) + int(s[k - 2 : k]), k\\n                \\n        @lru_cache(None)\\n        def helper(i, j, budget):\\n            if i == m and j == n:\\n                return budget == 0\\n            if i < m and s1[i].isdigit():\\n                return any(helper(k, j, budget + num) for num, k in get_possible_nums(s1, i))\\n            if j < n and s2[j].isdigit():\\n                return any(helper(i, k, budget - num) for num, k in get_possible_nums(s2, j))\\n            \\n            if budget == 0:\\n                if i == m or j == n or s1[i] != s2[j]:\\n                    return False\\n                while i < m and j < n and s1[i].isalpha() and s1[i] == s2[j]:\\n                    i += 1\\n                    j += 1\\n            elif budget > 0:\\n                if j == n: return False\\n                while budget > 0 and j < n and s2[j].isalpha():\\n                    j += 1\\n                    budget -= 1\\n            else:\\n                if i == m: return False\\n                while budget < 0 and i < m and s1[i].isalpha():\\n                    i += 1\\n                    budget += 1\\n            return helper(i, j, budget)\\n        \\n        return helper(0, 0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        \\n        def get_possible_nums(s, k):\\n            n_digit = 0\\n            while k < len(s) and s[k].isdigit():\\n                n_digit += 1\\n                k += 1\\n            yield int(s[k - n_digit : k]), k\\n            if n_digit == 2:\\n                yield int(s[k - 2]) + int(s[k - 1]), k\\n            elif n_digit == 3:\\n                yield int(s[k - 3]) + int(s[k - 2]) + int(s[k - 1]), k\\n                yield int(s[k - 3 : k - 1]) + int(s[k - 1]), k\\n                yield int(s[k - 3]) + int(s[k - 2 : k]), k\\n                \\n        @lru_cache(None)\\n        def helper(i, j, budget):\\n            if i == m and j == n:\\n                return budget == 0\\n            if i < m and s1[i].isdigit():\\n                return any(helper(k, j, budget + num) for num, k in get_possible_nums(s1, i))\\n            if j < n and s2[j].isdigit():\\n                return any(helper(i, k, budget - num) for num, k in get_possible_nums(s2, j))\\n            \\n            if budget == 0:\\n                if i == m or j == n or s1[i] != s2[j]:\\n                    return False\\n                while i < m and j < n and s1[i].isalpha() and s1[i] == s2[j]:\\n                    i += 1\\n                    j += 1\\n            elif budget > 0:\\n                if j == n: return False\\n                while budget > 0 and j < n and s2[j].isalpha():\\n                    j += 1\\n                    budget -= 1\\n            else:\\n                if i == m: return False\\n                while budget < 0 and i < m and s1[i].isalpha():\\n                    i += 1\\n                    budget += 1\\n            return helper(i, j, budget)\\n        \\n        return helper(0, 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1821457,
                "title": "python-dfs-with-memoization",
                "content": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def enume(s):\\n            ans = [int(s)]\\n            if len(s) == 2:\\n                ans.append(int(s[0])+int(s[1]))\\n            elif len(s) == 3:\\n                ans.append(int(s[:1])+int(s[1:]))\\n                ans.append(int(s[:2])+int(s[2:]))\\n                ans.append(int(s[0])+int(s[1])+int(s[2]))\\n            return ans\\n            \\n        @lru_cache(None)\\n        def dfs(i1,i2,diff):\\n            print(i1,i2,diff)\\n            if i1 == len(s1) and i2 == len(s2):\\n                return diff == 0\\n            if i1 < len(s1) and s1[i1].isdigit():\\n                j1 = i1\\n                while j1 < len(s1) and s1[j1].isdigit():\\n                    j1 += 1\\n                print(enume(s1[i1:j1]))\\n                for x in enume(s1[i1:j1]):\\n                    if dfs(j1,i2,x+diff):\\n                        return True\\n            elif i2 < len(s2) and s2[i2].isdigit():\\n                j2 = i2\\n                while j2 < len(s2) and s2[j2].isdigit():\\n                    j2 += 1\\n                print(enume(s2[i2:j2]))\\n                for x in enume(s2[i2:j2]):\\n                    if dfs(i1,j2,diff-x):\\n                        return True\\n            elif diff == 0:\\n                if i1 == len(s1) or i2  == len(s2):\\n                    return False\\n                if s1[i1] != s2[i2]:\\n                    return False\\n                while i1<len(s1) and i2<len(s2) and s1[i1].isalpha() and s1[i1] == s2[i2]:\\n                    i1 += 1\\n                    i2 += 1\\n                if dfs(i1,i2,0):\\n                    return True\\n            elif diff > 0:\\n                if i2 == len(s2):\\n                    return False\\n                while i2 < len(s2) and diff and s2[i2].isalpha():\\n                    i2 += 1\\n                    diff -= 1\\n                return dfs(i1,i2,diff)\\n            elif diff < 0:\\n                if i1 == len(s1):\\n                    return False\\n                while i1 < len(s1) and diff and s1[i1].isalpha():\\n                    i1 += 1\\n                    diff += 1\\n                return dfs(i1,i2,diff)\\n            return False\\n        return dfs(0,0,0)\\n            \\n                \\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def enume(s):\\n            ans = [int(s)]\\n            if len(s) == 2:\\n                ans.append(int(s[0])+int(s[1]))\\n            elif len(s) == 3:\\n                ans.append(int(s[:1])+int(s[1:]))\\n                ans.append(int(s[:2])+int(s[2:]))\\n                ans.append(int(s[0])+int(s[1])+int(s[2]))\\n            return ans\\n            \\n        @lru_cache(None)\\n        def dfs(i1,i2,diff):\\n            print(i1,i2,diff)\\n            if i1 == len(s1) and i2 == len(s2):\\n                return diff == 0\\n            if i1 < len(s1) and s1[i1].isdigit():\\n                j1 = i1\\n                while j1 < len(s1) and s1[j1].isdigit():\\n                    j1 += 1\\n                print(enume(s1[i1:j1]))\\n                for x in enume(s1[i1:j1]):\\n                    if dfs(j1,i2,x+diff):\\n                        return True\\n            elif i2 < len(s2) and s2[i2].isdigit():\\n                j2 = i2\\n                while j2 < len(s2) and s2[j2].isdigit():\\n                    j2 += 1\\n                print(enume(s2[i2:j2]))\\n                for x in enume(s2[i2:j2]):\\n                    if dfs(i1,j2,diff-x):\\n                        return True\\n            elif diff == 0:\\n                if i1 == len(s1) or i2  == len(s2):\\n                    return False\\n                if s1[i1] != s2[i2]:\\n                    return False\\n                while i1<len(s1) and i2<len(s2) and s1[i1].isalpha() and s1[i1] == s2[i2]:\\n                    i1 += 1\\n                    i2 += 1\\n                if dfs(i1,i2,0):\\n                    return True\\n            elif diff > 0:\\n                if i2 == len(s2):\\n                    return False\\n                while i2 < len(s2) and diff and s2[i2].isalpha():\\n                    i2 += 1\\n                    diff -= 1\\n                return dfs(i1,i2,diff)\\n            elif diff < 0:\\n                if i1 == len(s1):\\n                    return False\\n                while i1 < len(s1) and diff and s1[i1].isalpha():\\n                    i1 += 1\\n                    diff += 1\\n                return dfs(i1,i2,diff)\\n            return False\\n        return dfs(0,0,0)\\n            \\n                \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787508,
                "title": "easy-to-follow-c-solution",
                "content": "```\\nclass Solution {\\n    string s1;\\n    string s2;\\n    int l1;\\n    int l2;\\n    int dp[42][42][2001];\\n    \\n    //-999 999\\n    //diff > 0 s1 has to give character\\n    int recur(int i, int j, int diff) {\\n        \\n        if(i == l1 && j == l2) {\\n            if(diff == 0)\\n                return 1;\\n            return 0;\\n        }\\n        //cout<<dp[i][j][diff+1000];\\n        if(dp[i][j][diff+1000] != -1)\\n            return dp[i][j][diff+1000];\\n        \\n        if(diff > 0) {\\n            //\\n            if(i == l1)\\n                return 0;\\n            \\n            if(!isdigit(s1[i])) {\\n                return dp[i][j][diff+1000] = recur(i+1, j, diff-1);\\n            }\\n            int num = 0;\\n            int pos = i;\\n            while(pos < l1 && isdigit(s1[pos])) {\\n                num = num*10 + (s1[pos]-\\'0\\');\\n                if(recur(pos+1, j, diff-num)) {\\n                    return dp[i][j][diff+1000] = 1;\\n                }\\n                pos++;\\n            }\\n        } else if(diff < 0) {\\n            \\n            //\\n            if(j == l2)\\n                return 0;\\n            \\n            if(!isdigit(s2[j])) {\\n                return dp[i][j][diff+1000] = recur(i, j+1, diff+1);\\n            }\\n            int num = 0;\\n            int pos = j;\\n            while(pos < l2 && isdigit(s2[pos])) {\\n                num = num*10 + (s2[pos]-\\'0\\');\\n                if(recur(i, pos+1, diff+num)) {\\n                    return dp[i][j][diff+1000] = 1;\\n                }\\n                pos++;\\n            }\\n        } else {\\n            //\\n            \\n            if(i == l1 || j == l2)\\n                return 0;\\n            \\n            if(!isdigit(s1[i]) && !isdigit(s2[j])) {\\n                \\n                if(s1[i] != s2[j])\\n                    return dp[i][j][diff+1000] = 0;\\n                return dp[i][j][diff+1000] = recur(i+1, j+1, diff);\\n            }\\n            if(isdigit(s1[i])) {\\n                int num = 0;\\n                int pos = i;\\n                while(pos < l1 && isdigit(s1[pos])) {\\n                    num = num*10 + (s1[pos]-\\'0\\');\\n                    if(recur(pos+1, j, diff-num)) {\\n                        return dp[i][j][diff+1000] = 1;\\n                    }\\n                    pos++;\\n                }\\n            } else {\\n                int num = 0;\\n                int pos = j;\\n                while(pos < l2 && isdigit(s2[pos])) {\\n                    num = num*10 + (s2[pos]-\\'0\\');\\n                    if(recur(i, pos+1, diff+num)) {\\n                        return dp[i][j][diff+1000] = 1;\\n                    }\\n                    pos++;\\n                }\\n            }\\n        }\\n        return dp[i][j][diff+1000] = 0;\\n        \\n    }\\npublic:\\n    bool possiblyEquals(string st1, string st2) {\\n        s1 = st1;\\n        s2 = st2;\\n        l1 = s1.length();\\n        l2 = s2.length();\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0 , 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    string s1;\\n    string s2;\\n    int l1;\\n    int l2;\\n    int dp[42][42][2001];\\n    \\n    //-999 999\\n    //diff > 0 s1 has to give character\\n    int recur(int i, int j, int diff) {\\n        \\n        if(i == l1 && j == l2) {\\n            if(diff == 0)\\n                return 1;\\n            return 0;\\n        }\\n        //cout<<dp[i][j][diff+1000];\\n        if(dp[i][j][diff+1000] != -1)\\n            return dp[i][j][diff+1000];\\n        \\n        if(diff > 0) {\\n            //\\n            if(i == l1)\\n                return 0;\\n            \\n            if(!isdigit(s1[i])) {\\n                return dp[i][j][diff+1000] = recur(i+1, j, diff-1);\\n            }\\n            int num = 0;\\n            int pos = i;\\n            while(pos < l1 && isdigit(s1[pos])) {\\n                num = num*10 + (s1[pos]-\\'0\\');\\n                if(recur(pos+1, j, diff-num)) {\\n                    return dp[i][j][diff+1000] = 1;\\n                }\\n                pos++;\\n            }\\n        } else if(diff < 0) {\\n            \\n            //\\n            if(j == l2)\\n                return 0;\\n            \\n            if(!isdigit(s2[j])) {\\n                return dp[i][j][diff+1000] = recur(i, j+1, diff+1);\\n            }\\n            int num = 0;\\n            int pos = j;\\n            while(pos < l2 && isdigit(s2[pos])) {\\n                num = num*10 + (s2[pos]-\\'0\\');\\n                if(recur(i, pos+1, diff+num)) {\\n                    return dp[i][j][diff+1000] = 1;\\n                }\\n                pos++;\\n            }\\n        } else {\\n            //\\n            \\n            if(i == l1 || j == l2)\\n                return 0;\\n            \\n            if(!isdigit(s1[i]) && !isdigit(s2[j])) {\\n                \\n                if(s1[i] != s2[j])\\n                    return dp[i][j][diff+1000] = 0;\\n                return dp[i][j][diff+1000] = recur(i+1, j+1, diff);\\n            }\\n            if(isdigit(s1[i])) {\\n                int num = 0;\\n                int pos = i;\\n                while(pos < l1 && isdigit(s1[pos])) {\\n                    num = num*10 + (s1[pos]-\\'0\\');\\n                    if(recur(pos+1, j, diff-num)) {\\n                        return dp[i][j][diff+1000] = 1;\\n                    }\\n                    pos++;\\n                }\\n            } else {\\n                int num = 0;\\n                int pos = j;\\n                while(pos < l2 && isdigit(s2[pos])) {\\n                    num = num*10 + (s2[pos]-\\'0\\');\\n                    if(recur(i, pos+1, diff+num)) {\\n                        return dp[i][j][diff+1000] = 1;\\n                    }\\n                    pos++;\\n                }\\n            }\\n        }\\n        return dp[i][j][diff+1000] = 0;\\n        \\n    }\\npublic:\\n    bool possiblyEquals(string st1, string st2) {\\n        s1 = st1;\\n        s2 = st2;\\n        l1 = s1.length();\\n        l2 = s2.length();\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0 , 0, 0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1738895,
                "title": "easy-to-follow-java-solution-with-memo",
                "content": "Hopefully this is easy to follow and can help explain how this question works.\\n\\n```\\nclass Solution {\\n    final int[] singleSkip = new int[]{0, 0};\\n    final HashSet<List<Integer>> failMemo = new HashSet<>();\\n    \\n    String string1;\\n    String string2;\\n\\n    public boolean possiblyEquals(String s1, String s2) {\\n        this.string1 = s1;\\n        this.string2 = s2;\\n        return recurse( 0, 0, 0, 0);\\n    }\\n\\n    private boolean recurse(int i1, int wildcards1, int i2, int wildCards2) {\\n        int commonReduce = Math.min(wildcards1, wildCards2);\\n        wildcards1 -= commonReduce;\\n        wildCards2 -= commonReduce;\\n\\n        while (true) {\\n            if (wildcards1 > 0) {\\n                if (isEnd(i2, string2)) return false; // wildcard but the other is done\\n                if (isLetter(i2, string2)) { // wild card used\\n                    wildcards1--;\\n                    i2++;\\n                }\\n                else break; // wildcard meeting number\\n            } else if (wildCards2 > 0) {\\n                if (isEnd(i1, string1)) return false; // wildcard but the other is done\\n                if (isLetter(i1, string1)) { // wild card used\\n                    wildCards2--;\\n                    i1++;\\n                }\\n                else break; // wildcard meeting number\\n            } else {\\n                if (isEnd(i2, string2) && isEnd(i1, string1)) return true; // both happen to be done\\n                else if (isEnd(i2, string2) || isEnd(i1, string1)) return false; // one ended while the other did not\\n                else if (isLetter(i1, string1) && isLetter(i2, string2)) { // both letter used\\n                    if (string1.charAt(i1) != string2.charAt(i2)) return false; // letter with no match is fail\\n                    i1++;\\n                    i2++;\\n                }\\n                else break;\\n            }\\n        }\\n\\n        // processed all cancellations and letters, one side may have wildcard, the other side will have new numbers\\n\\n        final List<Integer> memoState = List.of(i1, wildcards1, i2, wildCards2); // memo to optimize failed state\\n        if (failMemo.contains(memoState)) return false; // check memo\\n\\n        // generate all possible wildcards from numerical values\\n        Set<int[]> skips1 = !isEnd(i1, string1) && !isLetter(i1, string1) ? extractSkips(string1, i1) : Set.of(singleSkip);\\n        Set<int[]> skips2 = !isEnd(i2, string2) && !isLetter(i2, string2) ? extractSkips(string2, i2) : Set.of(singleSkip);\\n\\n        for (int[] candidates1 : skips1) {\\n            for (int[] candidates2 : skips2) {\\n                boolean result = recurse(\\n                        i1 + candidates1[0],\\n                        wildcards1 + candidates1[1],\\n                        i2 + candidates2[0],\\n                        wildCards2 + candidates2[1]); // recurse for all combinations of possible wildcards\\n                \\n                if (result) return true; // if any of the recursion yielded good result, return true\\n            }\\n        }\\n\\n        failMemo.add(memoState); // if no recursion yielded good result, add to memo and return false\\n        return false;\\n    }\\n\\n    private Set<int[]> extractSkips(String string, int start) {\\n        Set<int[]> result = new HashSet<>();\\n        generateSkipsRecur(string, start, result, 0, 0);\\n        return result;\\n    }\\n\\n    private void generateSkipsRecur(String string, int digitStart, Set<int[]> result, int valueSoFar, int lengthSoFar) {\\n        int end = digitStart;\\n        if (isEnd(end, string) || isLetter(end, string)) {\\n            result.add(new int[]{lengthSoFar, valueSoFar});\\n            return;\\n        }\\n        int curNum = 0;\\n        while (!isEnd(end, string) && !isLetter(end, string)) {\\n            curNum = curNum * 10 + Character.getNumericValue(string.charAt(end));\\n            int segLength = end - digitStart + 1;\\n            generateSkipsRecur(string, end + 1, result, valueSoFar + curNum, lengthSoFar + segLength);\\n            end++;\\n        }\\n    }\\n\\n    private boolean isLetter(int index, String string) {\\n        return Character.isAlphabetic(string.charAt(index));\\n    }\\n\\n    private boolean isEnd(int index, String string) {\\n        return index >= string.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    final int[] singleSkip = new int[]{0, 0};\\n    final HashSet<List<Integer>> failMemo = new HashSet<>();\\n    \\n    String string1;\\n    String string2;\\n\\n    public boolean possiblyEquals(String s1, String s2) {\\n        this.string1 = s1;\\n        this.string2 = s2;\\n        return recurse( 0, 0, 0, 0);\\n    }\\n\\n    private boolean recurse(int i1, int wildcards1, int i2, int wildCards2) {\\n        int commonReduce = Math.min(wildcards1, wildCards2);\\n        wildcards1 -= commonReduce;\\n        wildCards2 -= commonReduce;\\n\\n        while (true) {\\n            if (wildcards1 > 0) {\\n                if (isEnd(i2, string2)) return false; // wildcard but the other is done\\n                if (isLetter(i2, string2)) { // wild card used\\n                    wildcards1--;\\n                    i2++;\\n                }\\n                else break; // wildcard meeting number\\n            } else if (wildCards2 > 0) {\\n                if (isEnd(i1, string1)) return false; // wildcard but the other is done\\n                if (isLetter(i1, string1)) { // wild card used\\n                    wildCards2--;\\n                    i1++;\\n                }\\n                else break; // wildcard meeting number\\n            } else {\\n                if (isEnd(i2, string2) && isEnd(i1, string1)) return true; // both happen to be done\\n                else if (isEnd(i2, string2) || isEnd(i1, string1)) return false; // one ended while the other did not\\n                else if (isLetter(i1, string1) && isLetter(i2, string2)) { // both letter used\\n                    if (string1.charAt(i1) != string2.charAt(i2)) return false; // letter with no match is fail\\n                    i1++;\\n                    i2++;\\n                }\\n                else break;\\n            }\\n        }\\n\\n        // processed all cancellations and letters, one side may have wildcard, the other side will have new numbers\\n\\n        final List<Integer> memoState = List.of(i1, wildcards1, i2, wildCards2); // memo to optimize failed state\\n        if (failMemo.contains(memoState)) return false; // check memo\\n\\n        // generate all possible wildcards from numerical values\\n        Set<int[]> skips1 = !isEnd(i1, string1) && !isLetter(i1, string1) ? extractSkips(string1, i1) : Set.of(singleSkip);\\n        Set<int[]> skips2 = !isEnd(i2, string2) && !isLetter(i2, string2) ? extractSkips(string2, i2) : Set.of(singleSkip);\\n\\n        for (int[] candidates1 : skips1) {\\n            for (int[] candidates2 : skips2) {\\n                boolean result = recurse(\\n                        i1 + candidates1[0],\\n                        wildcards1 + candidates1[1],\\n                        i2 + candidates2[0],\\n                        wildCards2 + candidates2[1]); // recurse for all combinations of possible wildcards\\n                \\n                if (result) return true; // if any of the recursion yielded good result, return true\\n            }\\n        }\\n\\n        failMemo.add(memoState); // if no recursion yielded good result, add to memo and return false\\n        return false;\\n    }\\n\\n    private Set<int[]> extractSkips(String string, int start) {\\n        Set<int[]> result = new HashSet<>();\\n        generateSkipsRecur(string, start, result, 0, 0);\\n        return result;\\n    }\\n\\n    private void generateSkipsRecur(String string, int digitStart, Set<int[]> result, int valueSoFar, int lengthSoFar) {\\n        int end = digitStart;\\n        if (isEnd(end, string) || isLetter(end, string)) {\\n            result.add(new int[]{lengthSoFar, valueSoFar});\\n            return;\\n        }\\n        int curNum = 0;\\n        while (!isEnd(end, string) && !isLetter(end, string)) {\\n            curNum = curNum * 10 + Character.getNumericValue(string.charAt(end));\\n            int segLength = end - digitStart + 1;\\n            generateSkipsRecur(string, end + 1, result, valueSoFar + curNum, lengthSoFar + segLength);\\n            end++;\\n        }\\n    }\\n\\n    private boolean isLetter(int index, String string) {\\n        return Character.isAlphabetic(string.charAt(index));\\n    }\\n\\n    private boolean isEnd(int index, String string) {\\n        return index >= string.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714432,
                "title": "wrong-test-case",
                "content": "test case 183:\\n\\n\"p87p739q339p\"\\n\"751p6p259q3p1p\"\\n\\nI am using a bit different approach, I am trying to build all possible strings using patterns. For example, if I have \"a12a\", then it can be \"a...a\"(any 3 letters in the middle) or \"a............a\" (any 12 letters in the middle). So based on my approach for s1 I have just one string with the lenght of 53 and for s2 I have 2 strings length of 62 and 44 so there is not common base string since lengts are different so I return False but test case expects True...\\n\\n```\\ns1_patterns = [\\'p...............p...................q...............p\\']\\n\\ns2_patterns = [\\'.............p......p..................................q...p.p\\', \\'.............p......p................q...p.p\\']\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ns1_patterns = [\\'p...............p...................q...............p\\']\\n\\ns2_patterns = [\\'.............p......p..................................q...p.p\\', \\'.............p......p................q...p.p\\']\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697981,
                "title": "python-dfs-memo",
                "content": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        #dfs with memorization\\n        #memo keeps track of if s1[i:], s2[:j] matched with differernt jump distance d. \\n        #if d > 0, j jump further than i\\n        #if d < 0, i jump further than j\\n        memo = {}\\n        return self.dfs(s1, s2, 0, 0, 0, memo)\\n    \\n    def dfs(self, s1, s2, i, j, d, memo):\\n        if (i, j, d) in memo:\\n            return memo[(i, j, d)]\\n        #all has been matched\\n        if i == len(s1) and j == len(s2) and d == 0:\\n            return True\\n        #s1[:i] and s[:j] matched, current characters are matched, move the pointers to the next one\\n        if d == 0 and i < len(s1) and j < len(s2) and s1[i] == s2[j] and self.dfs(s1, s2, i + 1, j + 1, 0, memo):\\n            memo[(i, j, d)] = True\\n            return True   \\n        #in this case, j has jumped further than i, use s1[i] to fill the jumped distance\\n        if d > 0 and i < len(s1) and s1[i].isalpha() and self.dfs(s1, s2, i + 1, j, d - 1, memo):\\n            memo[(i, j, d)] = True\\n            return True\\n        #in this case, i has jumped further than i, use s2[j] to fill the jumped distance\\n        if d < 0 and j < len(s2) and s2[j].isalpha() and self.dfs(s1, s2, i, j + 1, d + 1, memo):\\n            memo[(i, j, d)] = True\\n            return True\\n        #s1[:i] matched s2[:j] or j has jumped further than i, try different possible jump distance on i to shorten the distance\\n        if d >= 0:\\n            k, num = i, 0\\n            while k < len(s1) and s1[k].isdigit():\\n                num = num * 10 + int(s1[k])\\n                if self.dfs(s1, s2, k + 1, j , d - num, memo):\\n                    memo[(i, j, d)] = True\\n                    return True                    \\n                k += 1\\n        #s1[:i] matched s2[:j] or i has jumped further than j, try different possible jump distance on j to shorten the distance\\n        if d <= 0:\\n            k, num = j, 0\\n            while k < len(s2) and s2[k].isdigit():\\n                num = num *10 + int(s2[k])\\n                if dfs(s1, s2, i, k + 1, d + num, memo):\\n                    memo[(i, j, d)] = True\\n                    return True\\n                k += 1\\n        \\n        memo[(i, j ,d)] = False\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        #dfs with memorization\\n        #memo keeps track of if s1[i:], s2[:j] matched with differernt jump distance d. \\n        #if d > 0, j jump further than i\\n        #if d < 0, i jump further than j\\n        memo = {}\\n        return self.dfs(s1, s2, 0, 0, 0, memo)\\n    \\n    def dfs(self, s1, s2, i, j, d, memo):\\n        if (i, j, d) in memo:\\n            return memo[(i, j, d)]\\n        #all has been matched\\n        if i == len(s1) and j == len(s2) and d == 0:\\n            return True\\n        #s1[:i] and s[:j] matched, current characters are matched, move the pointers to the next one\\n        if d == 0 and i < len(s1) and j < len(s2) and s1[i] == s2[j] and self.dfs(s1, s2, i + 1, j + 1, 0, memo):\\n            memo[(i, j, d)] = True\\n            return True   \\n        #in this case, j has jumped further than i, use s1[i] to fill the jumped distance\\n        if d > 0 and i < len(s1) and s1[i].isalpha() and self.dfs(s1, s2, i + 1, j, d - 1, memo):\\n            memo[(i, j, d)] = True\\n            return True\\n        #in this case, i has jumped further than i, use s2[j] to fill the jumped distance\\n        if d < 0 and j < len(s2) and s2[j].isalpha() and self.dfs(s1, s2, i, j + 1, d + 1, memo):\\n            memo[(i, j, d)] = True\\n            return True\\n        #s1[:i] matched s2[:j] or j has jumped further than i, try different possible jump distance on i to shorten the distance\\n        if d >= 0:\\n            k, num = i, 0\\n            while k < len(s1) and s1[k].isdigit():\\n                num = num * 10 + int(s1[k])\\n                if self.dfs(s1, s2, k + 1, j , d - num, memo):\\n                    memo[(i, j, d)] = True\\n                    return True                    \\n                k += 1\\n        #s1[:i] matched s2[:j] or i has jumped further than j, try different possible jump distance on j to shorten the distance\\n        if d <= 0:\\n            k, num = j, 0\\n            while k < len(s2) and s2[k].isdigit():\\n                num = num *10 + int(s2[k])\\n                if dfs(s1, s2, i, k + 1, d + num, memo):\\n                    memo[(i, j, d)] = True\\n                    return True\\n                k += 1\\n        \\n        memo[(i, j ,d)] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640312,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public bool PossiblyEquals(string s1, string s2) {\\n        int[,,] dp = new int[s1.Length + 1, s2.Length + 1, 2001];\\n        for (int i = 0; i < dp.GetLength(0); ++i)\\n            for (int j = 0; j < dp.GetLength(1); ++j)\\n                for (int k = 0; k < dp.GetLength(2); ++k)\\n                    dp[i, j, k] = -1;\\n        \\n        int r = DFS(0, 0, 0, s1, s2, dp);\\n        return r == 1 ? true : false;\\n    }\\n    \\n    public int DFS(int i, int j, int d, string s1, string s2, int[,,] dp) {\\n        if (i >= s1.Length && j >= s2.Length && d == 0) return 1;\\n        \\n        if (dp[i, j, d + 1000] != -1) return dp[i, j, d + 1000];\\n        \\n        int v = 0;\\n        \\n        if (i < s1.Length) {\\n            if (s1[i] - \\'0\\' <= 9) {\\n                int val = 0, c = 0;\\n                while (i + c < s1.Length && c < 3 && s1[i + c] - \\'0\\' <= 9) {\\n                    val = val * 10 + (s1[i + c] - \\'0\\');\\n                    c++;\\n                    if (DFS(i + c, j, d - val, s1, s2, dp) == 1) v = 1;\\n                }\\n            } else {\\n                if (d > 0) {\\n                    if (DFS(i + 1, j, d - 1, s1, s2, dp) == 1) v = 1;\\n                } else if (d == 0 && j < s2.Length && s1[i] == s2[j]) {\\n                    if (DFS(i + 1, j + 1, d, s1, s2, dp) == 1) v = 1;\\n                }\\n            }\\n        }\\n        \\n        if (j < s2.Length) {\\n            if (s2[j] - \\'0\\' <= 9) {\\n                int val = 0, c = 0;\\n                while (j + c < s2.Length && c < 3 && s2[j + c] - \\'0\\' <= 9) {\\n                    val = val * 10 + (s2[j + c] - \\'0\\');\\n                    c++;\\n                    if (DFS(i, j + c, d + val, s1, s2, dp) == 1) v = 1;\\n                }\\n            } else {\\n                if (d < 0) {\\n                    if (DFS(i, j + 1, d + 1, s1, s2, dp) == 1) v = 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[i, j, d + 1000] = v;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool PossiblyEquals(string s1, string s2) {\\n        int[,,] dp = new int[s1.Length + 1, s2.Length + 1, 2001];\\n        for (int i = 0; i < dp.GetLength(0); ++i)\\n            for (int j = 0; j < dp.GetLength(1); ++j)\\n                for (int k = 0; k < dp.GetLength(2); ++k)\\n                    dp[i, j, k] = -1;\\n        \\n        int r = DFS(0, 0, 0, s1, s2, dp);\\n        return r == 1 ? true : false;\\n    }\\n    \\n    public int DFS(int i, int j, int d, string s1, string s2, int[,,] dp) {\\n        if (i >= s1.Length && j >= s2.Length && d == 0) return 1;\\n        \\n        if (dp[i, j, d + 1000] != -1) return dp[i, j, d + 1000];\\n        \\n        int v = 0;\\n        \\n        if (i < s1.Length) {\\n            if (s1[i] - \\'0\\' <= 9) {\\n                int val = 0, c = 0;\\n                while (i + c < s1.Length && c < 3 && s1[i + c] - \\'0\\' <= 9) {\\n                    val = val * 10 + (s1[i + c] - \\'0\\');\\n                    c++;\\n                    if (DFS(i + c, j, d - val, s1, s2, dp) == 1) v = 1;\\n                }\\n            } else {\\n                if (d > 0) {\\n                    if (DFS(i + 1, j, d - 1, s1, s2, dp) == 1) v = 1;\\n                } else if (d == 0 && j < s2.Length && s1[i] == s2[j]) {\\n                    if (DFS(i + 1, j + 1, d, s1, s2, dp) == 1) v = 1;\\n                }\\n            }\\n        }\\n        \\n        if (j < s2.Length) {\\n            if (s2[j] - \\'0\\' <= 9) {\\n                int val = 0, c = 0;\\n                while (j + c < s2.Length && c < 3 && s2[j + c] - \\'0\\' <= 9) {\\n                    val = val * 10 + (s2[j + c] - \\'0\\');\\n                    c++;\\n                    if (DFS(i, j + c, d + val, s1, s2, dp) == 1) v = 1;\\n                }\\n            } else {\\n                if (d < 0) {\\n                    if (DFS(i, j + 1, d + 1, s1, s2, dp) == 1) v = 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[i, j, d + 1000] = v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596201,
                "title": "c-top-down-solution",
                "content": "Diff means how many wildcards there need to match. \\nWe have to solve the problem case by case. \\n```\\nclass Solution {\\npublic:\\n    // a has some extra wildcards need to match, diff < 0 \\n    // b has some extra wildcards need to match, diff > 0 \\n    bool f(const string& a, const string& b, int i, int j, int diff, vector<vector<vector<int>>>& dp) {\\n        if(i == a.size() && j == b.size()) {\\n            if(diff == 0) {\\n                return true; \\n            }\\n            return false; \\n        }\\n        if(dp[i][j][diff + 1000] != -1) {\\n            return dp[i][j][diff+1000];\\n        }\\n        if(i<a.size() && isdigit(a[i])) {\\n            int t = 0; \\n            for(int k = i;k<a.size()&&isdigit(a[k]);k++) {\\n                t = t * 10 + a[k] - \\'0\\';\\n                if(f(a,b,k+1,j,diff-t,dp)) {\\n                    return dp[i][j][diff + 1000] = true; \\n                }\\n            }\\n        } else {\\n            if(diff > 0) {\\n                if(i == a.size()) {\\n                    return dp[i][j][diff + 1000] = false; \\n                }\\n                return f(a,b,i+1,j,diff-1,dp);\\n            } else if(diff == 0) {\\n                if(i == a.size()) {\\n                    return dp[i][j][diff + 1000] = false; \\n                }\\n                if(a[i] == b[j]) {\\n                    return dp[i][j][diff + 1000] = f(a,b,i+1,j+1,0,dp);\\n                }\\n            }\\n        }\\n        if(j<b.size() && isdigit(b[j])) {\\n            int t = 0; \\n            for(int k = j;k<b.size()&&isdigit(b[k]);k++) {\\n                t = t * 10 + b[k] - \\'0\\';\\n                if(f(a,b,i,k+1,diff+t,dp)) {\\n                    return dp[i][j][diff + 1000] = true; \\n                }\\n            }\\n        } else {\\n            if(diff < 0) {\\n                if(j == b.size()) {\\n                    return dp[i][j][diff + 1000] = false; \\n                }\\n                return f(a,b,i,j+1,diff+1,dp);\\n            } else if(diff == 0) {\\n                if(j == b.size()) {\\n                    return dp[i][j][diff + 1000] = false; \\n                }\\n                if(a[i] == b[j]) {\\n                    return dp[i][j][diff + 1000] = f(a,b,i+1,j+1,0,dp);\\n                }\\n            }\\n        }\\n        return dp[i][j][diff + 1000] = false; \\n    }\\n    \\n    bool possiblyEquals(string s1, string s2) {\\n        if(s1 == s2) {\\n            return true; \\n        }\\n        vector<vector<vector<int>>> dp(s1.size()+1,vector<vector<int>>(s2.size()+1,vector<int>(2000,-1)));\\n        return f(s1,s2,0,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // a has some extra wildcards need to match, diff < 0 \\n    // b has some extra wildcards need to match, diff > 0 \\n    bool f(const string& a, const string& b, int i, int j, int diff, vector<vector<vector<int>>>& dp) {\\n        if(i == a.size() && j == b.size()) {\\n            if(diff == 0) {\\n                return true; \\n            }\\n            return false; \\n        }\\n        if(dp[i][j][diff + 1000] != -1) {\\n            return dp[i][j][diff+1000];\\n        }\\n        if(i<a.size() && isdigit(a[i])) {\\n            int t = 0; \\n            for(int k = i;k<a.size()&&isdigit(a[k]);k++) {\\n                t = t * 10 + a[k] - \\'0\\';\\n                if(f(a,b,k+1,j,diff-t,dp)) {\\n                    return dp[i][j][diff + 1000] = true; \\n                }\\n            }\\n        } else {\\n            if(diff > 0) {\\n                if(i == a.size()) {\\n                    return dp[i][j][diff + 1000] = false; \\n                }\\n                return f(a,b,i+1,j,diff-1,dp);\\n            } else if(diff == 0) {\\n                if(i == a.size()) {\\n                    return dp[i][j][diff + 1000] = false; \\n                }\\n                if(a[i] == b[j]) {\\n                    return dp[i][j][diff + 1000] = f(a,b,i+1,j+1,0,dp);\\n                }\\n            }\\n        }\\n        if(j<b.size() && isdigit(b[j])) {\\n            int t = 0; \\n            for(int k = j;k<b.size()&&isdigit(b[k]);k++) {\\n                t = t * 10 + b[k] - \\'0\\';\\n                if(f(a,b,i,k+1,diff+t,dp)) {\\n                    return dp[i][j][diff + 1000] = true; \\n                }\\n            }\\n        } else {\\n            if(diff < 0) {\\n                if(j == b.size()) {\\n                    return dp[i][j][diff + 1000] = false; \\n                }\\n                return f(a,b,i,j+1,diff+1,dp);\\n            } else if(diff == 0) {\\n                if(j == b.size()) {\\n                    return dp[i][j][diff + 1000] = false; \\n                }\\n                if(a[i] == b[j]) {\\n                    return dp[i][j][diff + 1000] = f(a,b,i+1,j+1,0,dp);\\n                }\\n            }\\n        }\\n        return dp[i][j][diff + 1000] = false; \\n    }\\n    \\n    bool possiblyEquals(string s1, string s2) {\\n        if(s1 == s2) {\\n            return true; \\n        }\\n        vector<vector<vector<int>>> dp(s1.size()+1,vector<vector<int>>(s2.size()+1,vector<int>(2000,-1)));\\n        return f(s1,s2,0,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564984,
                "content": [
                    {
                        "username": "JennaSarfo",
                        "content": "I do not understand why I will pay for premium but still be struggling to find the answer to a problem."
                    },
                    {
                        "username": "user4878dN",
                        "content": "One of the tests is s1=\"x94\" s2=\"x14\" with expected as False.\nI don't understand why it's not True.\nThe original string \"x94\" can create both.\n\"x94\" -> [\"x\", \"9\", \"4\"] -> [\"x\", \"1\", \"4\"] -> \"x14\"\n\nsame for s1=\"3a7a3\" and s2=\"44a\"\nwith the original string \"xxxa7axxa\" \n\"xxxa7axxa\" -> [\"xxx\", \"a7a\", \"xxa\"] -> [\"3\", \"a7a\", \"3\"] -> \"3a7a3\"\n\"xxxa7axxa\" -> [\"xxxa\", \"7axx\", \"a\"] -> [\"4\", \"4\", \"a\"] -> \"44a\""
                    },
                    {
                        "username": "madhava1",
                        "content": "the decoded string is not expected to have numbers. only alphabets."
                    }
                ]
            },
            {
                "id": 1784785,
                "content": [
                    {
                        "username": "JennaSarfo",
                        "content": "I do not understand why I will pay for premium but still be struggling to find the answer to a problem."
                    },
                    {
                        "username": "user4878dN",
                        "content": "One of the tests is s1=\"x94\" s2=\"x14\" with expected as False.\nI don't understand why it's not True.\nThe original string \"x94\" can create both.\n\"x94\" -> [\"x\", \"9\", \"4\"] -> [\"x\", \"1\", \"4\"] -> \"x14\"\n\nsame for s1=\"3a7a3\" and s2=\"44a\"\nwith the original string \"xxxa7axxa\" \n\"xxxa7axxa\" -> [\"xxx\", \"a7a\", \"xxa\"] -> [\"3\", \"a7a\", \"3\"] -> \"3a7a3\"\n\"xxxa7axxa\" -> [\"xxxa\", \"7axx\", \"a\"] -> [\"4\", \"4\", \"a\"] -> \"44a\""
                    },
                    {
                        "username": "madhava1",
                        "content": "the decoded string is not expected to have numbers. only alphabets."
                    }
                ]
            }
        ]
    }
]